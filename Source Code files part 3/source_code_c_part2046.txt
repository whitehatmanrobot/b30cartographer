.GetClientTypeOperationCompleted == null)) {
                this.GetClientTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetClientTypeOperationCompleted);
            }
            this.InvokeAsync("GetClientType", new object[0], this.GetClientTypeOperationCompleted, userState);
        }
        
        private void OnGetClientTypeOperationCompleted(object arg) {
            if ((this.GetClientTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetClientTypeCompleted(this, new GetClientTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetLocaleArray", RequestElementName="GetLocaleArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetLocaleArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetLocaleArrayResult")]
        public Locale[] GetLocale() {
            object[] results = this.Invoke("GetLocale", new object[0]);
            return ((Locale[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLocale(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLocale", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Locale[] EndGetLocale(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Locale[])(results[0]));
        }
        
        /// <remarks/>
        public void GetLocaleAsync() {
            this.GetLocaleAsync(null);
        }
        
        /// <remarks/>
        public void GetLocaleAsync(object userState) {
            if ((this.GetLocaleOperationCompleted == null)) {
                this.GetLocaleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLocaleOperationCompleted);
            }
            this.InvokeAsync("GetLocale", new object[0], this.GetLocaleOperationCompleted, userState);
        }
        
        private void OnGetLocaleOperationCompleted(object arg) {
            if ((this.GetLocaleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLocaleCompleted(this, new GetLocaleCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetImageFormatArray", RequestElementName="GetImageFormatArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetImageFormatArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetImageFormatArrayResult")]
        public ImageFormat[] GetImageFormat() {
            object[] results = this.Invoke("GetImageFormat", new object[0]);
            return ((ImageFormat[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetImageFormat(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetImageFormat", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public ImageFormat[] EndGetImageFormat(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ImageFormat[])(results[0]));
        }
        
        /// <remarks/>
        public void GetImageFormatAsync() {
            this.GetImageFormatAsync(null);
        }
        
        /// <remarks/>
        public void GetImageFormatAsync(object userState) {
            if ((this.GetImageFormatOperationCompleted == null)) {
                this.GetImageFormatOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetImageFormatOperationCompleted);
            }
            this.InvokeAsync("GetImageFormat", new object[0], this.GetImageFormatOperationCompleted, userState);
        }
        
        private void OnGetImageFormatOperationCompleted(object arg) {
            if ((this.GetImageFormatCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetImageFormatCompleted(this, new GetImageFormatCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetImageSizeArray", RequestElementName="GetImageSizeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetImageSizeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetImageSizeArrayResult")]
        public ImageSize[] GetImageSize() {
            object[] results = this.Invoke("GetImageSize", new object[0]);
            return ((ImageSize[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetImageSize(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetImageSize", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public ImageSize[] EndGetImageSize(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ImageSize[])(results[0]));
        }
        
        /// <remarks/>
        public void GetImageSizeAsync() {
            this.GetImageSizeAsync(null);
        }
        
        /// <remarks/>
        public void GetImageSizeAsync(object userState) {
            if ((this.GetImageSizeOperationCompleted == null)) {
                this.GetImageSizeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetImageSizeOperationCompleted);
            }
            this.InvokeAsync("GetImageSize", new object[0], this.GetImageSizeOperationCompleted, userState);
        }
        
        private void OnGetImageSizeOperationCompleted(object arg) {
            if ((this.GetImageSizeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetImageSizeCompleted(this, new GetImageSizeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetMediaRelationshipTypeArray", RequestElementName="GetMediaRelationshipTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetMediaRelationshipTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetMediaRelationshipTypeArrayResult")]
        public MediaRelationshipType[] GetMediaRelationshipType() {
            object[] results = this.Invoke("GetMediaRelationshipType", new object[0]);
            return ((MediaRelationshipType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMediaRelationshipType(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMediaRelationshipType", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public MediaRelationshipType[] EndGetMediaRelationshipType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MediaRelationshipType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetMediaRelationshipTypeAsync() {
            this.GetMediaRelationshipTypeAsync(null);
        }
        
        /// <remarks/>
        public void GetMediaRelationshipTypeAsync(object userState) {
            if ((this.GetMediaRelationshipTypeOperationCompleted == null)) {
                this.GetMediaRelationshipTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMediaRelationshipTypeOperationCompleted);
            }
            this.InvokeAsync("GetMediaRelationshipType", new object[0], this.GetMediaRelationshipTypeOperationCompleted, userState);
        }
        
        private void OnGetMediaRelationshipTypeOperationCompleted(object arg) {
            if ((this.GetMediaRelationshipTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMediaRelationshipTypeCompleted(this, new GetMediaRelationshipTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetPreviewMediaInstanceTypeArray", RequestElementName="GetPreviewMediaInstanceTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetPreviewMediaInstanceTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetPreviewMediaInstanceTypeArrayResult")]
        public PreviewMediaInstanceType[] GetPreviewMediaInstanceType() {
            object[] results = this.Invoke("GetPreviewMediaInstanceType", new object[0]);
            return ((PreviewMediaInstanceType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPreviewMediaInstanceType(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPreviewMediaInstanceType", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public PreviewMediaInstanceType[] EndGetPreviewMediaInstanceType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PreviewMediaInstanceType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetPreviewMediaInstanceTypeAsync() {
            this.GetPreviewMediaInstanceTypeAsync(null);
        }
        
        /// <remarks/>
        public void GetPreviewMediaInstanceTypeAsync(object userState) {
            if ((this.GetPreviewMediaInstanceTypeOperationCompleted == null)) {
                this.GetPreviewMediaInstanceTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPreviewMediaInstanceTypeOperationCompleted);
            }
            this.InvokeAsync("GetPreviewMediaInstanceType", new object[0], this.GetPreviewMediaInstanceTypeOperationCompleted, userState);
        }
        
        private void OnGetPreviewMediaInstanceTypeOperationCompleted(object arg) {
            if ((this.GetPreviewMediaInstanceTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPreviewMediaInstanceTypeCompleted(this, new GetPreviewMediaInstanceTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetRoleArray", RequestElementName="GetRoleArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetRoleArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetRoleArrayResult")]
        public Role[] GetRole() {
            object[] results = this.Invoke("GetRole", new object[0]);
            return ((Role[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRole(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRole", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Role[] EndGetRole(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Role[])(results[0]));
        }
        
        /// <remarks/>
        public void GetRoleAsync() {
            this.GetRoleAsync(null);
        }
        
        /// <remarks/>
        public void GetRoleAsync(object userState) {
            if ((this.GetRoleOperationCompleted == null)) {
                this.GetRoleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRoleOperationCompleted);
            }
            this.InvokeAsync("GetRole", new object[0], this.GetRoleOperationCompleted, userState);
        }
        
        private void OnGetRoleOperationCompleted(object arg) {
            if ((this.GetRoleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRoleCompleted(this, new GetRoleCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetStoreArray", RequestElementName="GetStoreArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetStoreArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetStoreArrayResult")]
        public Store[] GetStore() {
            object[] results = this.Invoke("GetStore", new object[0]);
            return ((Store[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStore(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStore", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Store[] EndGetStore(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Store[])(results[0]));
        }
        
        /// <remarks/>
        public void GetStoreAsync() {
            this.GetStoreAsync(null);
        }
        
        /// <remarks/>
        public void GetStoreAsync(object userState) {
            if ((this.GetStoreOperationCompleted == null)) {
                this.GetStoreOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStoreOperationCompleted);
            }
            this.InvokeAsync("GetStore", new object[0], this.GetStoreOperationCompleted, userState);
        }
        
        private void OnGetStoreOperationCompleted(object arg) {
            if ((this.GetStoreCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStoreCompleted(this, new GetStoreCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetTaskStatusArray", RequestElementName="GetTaskStatusArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetTaskStatusArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetTaskStatusArrayResult")]
        public TaskStatus[] GetTaskStatus() {
            object[] results = this.Invoke("GetTaskStatus", new object[0]);
            return ((TaskStatus[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTaskStatus(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTaskStatus", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public TaskStatus[] EndGetTaskStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TaskStatus[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTaskStatusAsync() {
            this.GetTaskStatusAsync(null);
        }
        
        /// <remarks/>
        public void GetTaskStatusAsync(object userState) {
            if ((this.GetTaskStatusOperationCompleted == null)) {
                this.GetTaskStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTaskStatusOperationCompleted);
            }
            this.InvokeAsync("GetTaskStatus", new object[0], this.GetTaskStatusOperationCompleted, userState);
        }
        
        private void OnGetTaskStatusOperationCompleted(object arg) {
            if ((this.GetTaskStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTaskStatusCompleted(this, new GetTaskStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetTasksByStatus", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Task[] GetTasksByStatus(int statusId) {
            object[] results = this.Invoke("GetTasksByStatus", new object[] {
                        statusId});
            return ((Task[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTasksByStatus(int statusId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTasksByStatus", new object[] {
                        statusId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Task[] EndGetTasksByStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Task[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTasksByStatusAsync(int statusId) {
            this.GetTasksByStatusAsync(statusId, null);
        }
        
        /// <remarks/>
        public void GetTasksByStatusAsync(int statusId, object userState) {
            if ((this.GetTasksByStatusOperationCompleted == null)) {
                this.GetTasksByStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTasksByStatusOperationCompleted);
            }
            this.InvokeAsync("GetTasksByStatus", new object[] {
                        statusId}, this.GetTasksByStatusOperationCompleted, userState);
        }
        
        private void OnGetTasksByStatusOperationCompleted(object arg) {
            if ((this.GetTasksByStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTasksByStatusCompleted(this, new GetTasksByStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetTasks", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Task[] GetTasks() {
            object[] results = this.Invoke("GetTasks", new object[0]);
            return ((Task[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTasks(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTasks", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Task[] EndGetTasks(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Task[])(results[0]));
        }
        
        /// <remarks/>
        public void GetTasksAsync() {
            this.GetTasksAsync(null);
        }
        
        /// <remarks/>
        public void GetTasksAsync(object userState) {
            if ((this.GetTasksOperationCompleted == null)) {
                this.GetTasksOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTasksOperationCompleted);
            }
            this.InvokeAsync("GetTasks", new object[0], this.GetTasksOperationCompleted, userState);
        }
        
        private void OnGetTasksOperationCompleted(object arg) {
            if ((this.GetTasksCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTasksCompleted(this, new GetTasksCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetAvailableTaskAsXML", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetAvailableTaskAsXML() {
            object[] results = this.Invoke("GetAvailableTaskAsXML", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAvailableTaskAsXML(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAvailableTaskAsXML", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetAvailableTaskAsXML(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetAvailableTaskAsXMLAsync() {
            this.GetAvailableTaskAsXMLAsync(null);
        }
        
        /// <remarks/>
        public void GetAvailableTaskAsXMLAsync(object userState) {
            if ((this.GetAvailableTaskAsXMLOperationCompleted == null)) {
                this.GetAvailableTaskAsXMLOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAvailableTaskAsXMLOperationCompleted);
            }
            this.InvokeAsync("GetAvailableTaskAsXML", new object[0], this.GetAvailableTaskAsXMLOperationCompleted, userState);
        }
        
        private void OnGetAvailableTaskAsXMLOperationCompleted(object arg) {
            if ((this.GetAvailableTaskAsXMLCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAvailableTaskAsXMLCompleted(this, new GetAvailableTaskAsXMLCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/PurgeTaskQueue", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void PurgeTaskQueue() {
            this.Invoke("PurgeTaskQueue", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurgeTaskQueue(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PurgeTaskQueue", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurgeTaskQueue(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void PurgeTaskQueueAsync() {
            this.PurgeTaskQueueAsync(null);
        }
        
        /// <remarks/>
        public void PurgeTaskQueueAsync(object userState) {
            if ((this.PurgeTaskQueueOperationCompleted == null)) {
                this.PurgeTaskQueueOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurgeTaskQueueOperationCompleted);
            }
            this.InvokeAsync("PurgeTaskQueue", new object[0], this.PurgeTaskQueueOperationCompleted, userState);
        }
        
        private void OnPurgeTaskQueueOperationCompleted(object arg) {
            if ((this.PurgeTaskQueueCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurgeTaskQueueCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveTaskByObject", RequestElementName="SaveTaskByObject", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="SaveTaskByObjectResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveTask(Task taskQueue) {
            this.Invoke("SaveTask", new object[] {
                        taskQueue});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveTask(Task taskQueue, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveTask", new object[] {
                        taskQueue}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveTask(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveTaskAsync(Task taskQueue) {
            this.SaveTaskAsync(taskQueue, null);
        }
        
        /// <remarks/>
        public void SaveTaskAsync(Task taskQueue, object userState) {
            if ((this.SaveTaskOperationCompleted == null)) {
                this.SaveTaskOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveTaskOperationCompleted);
            }
            this.InvokeAsync("SaveTask", new object[] {
                        taskQueue}, this.SaveTaskOperationCompleted, userState);
        }
        
        private void OnSaveTaskOperationCompleted(object arg) {
            if ((this.SaveTaskCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveTaskCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveDRMTaskByObject", RequestElementName="SaveDRMTaskByObject", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="SaveDRMTaskByObjectResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveDRMTask(DRMTask task) {
            this.Invoke("SaveDRMTask", new object[] {
                        task});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveDRMTask(DRMTask task, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveDRMTask", new object[] {
                        task}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveDRMTask(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveDRMTaskAsync(DRMTask task) {
            this.SaveDRMTaskAsync(task, null);
        }
        
        /// <remarks/>
        public void SaveDRMTaskAsync(DRMTask task, object userState) {
            if ((this.SaveDRMTaskOperationCompleted == null)) {
                this.SaveDRMTaskOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveDRMTaskOperationCompleted);
            }
            this.InvokeAsync("SaveDRMTask", new object[] {
                        task}, this.SaveDRMTaskOperationCompleted, userState);
        }
        
        private void OnSaveDRMTaskOperationCompleted(object arg) {
            if ((this.SaveDRMTaskCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveDRMTaskCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="SaveTask1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveTaskByString", RequestElementName="SaveTaskByString", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="SaveTaskByStringResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveTask(string taskQueueXML) {
            this.Invoke("SaveTask1", new object[] {
                        taskQueueXML});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveTask1(string taskQueueXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveTask1", new object[] {
                        taskQueueXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveTask1(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveTask1Async(string taskQueueXML) {
            this.SaveTask1Async(taskQueueXML, null);
        }
        
        /// <remarks/>
        public void SaveTask1Async(string taskQueueXML, object userState) {
            if ((this.SaveTask1OperationCompleted == null)) {
                this.SaveTask1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveTask1OperationCompleted);
            }
            this.InvokeAsync("SaveTask1", new object[] {
                        taskQueueXML}, this.SaveTask1OperationCompleted, userState);
        }
        
        private void OnSaveTask1OperationCompleted(object arg) {
            if ((this.SaveTask1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveTask1Completed(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetUserTypeArray", RequestElementName="GetUserTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetUserTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetUserTypeArrayResult")]
        public UserType[] GetUserType() {
            object[] results = this.Invoke("GetUserType", new object[0]);
            return ((UserType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserType(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserType", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public UserType[] EndGetUserType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetUserTypeAsync() {
            this.GetUserTypeAsync(null);
        }
        
        /// <remarks/>
        public void GetUserTypeAsync(object userState) {
            if ((this.GetUserTypeOperationCompleted == null)) {
                this.GetUserTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserTypeOperationCompleted);
            }
            this.InvokeAsync("GetUserType", new object[0], this.GetUserTypeOperationCompleted, userState);
        }
        
        private void OnGetUserTypeOperationCompleted(object arg) {
            if ((this.GetUserTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserTypeCompleted(this, new GetUserTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVideoDefinitionArray", RequestElementName="GetVideoDefinitionArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetVideoDefinitionArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetVideoDefinitionArrayResult")]
        public VideoDefinition[] GetVideoDefinition() {
            object[] results = this.Invoke("GetVideoDefinition", new object[0]);
            return ((VideoDefinition[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVideoDefinition(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVideoDefinition", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public VideoDefinition[] EndGetVideoDefinition(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VideoDefinition[])(results[0]));
        }
        
        /// <remarks/>
        public void GetVideoDefinitionAsync() {
            this.GetVideoDefinitionAsync(null);
        }
        
        /// <remarks/>
        public void GetVideoDefinitionAsync(object userState) {
            if ((this.GetVideoDefinitionOperationCompleted == null)) {
                this.GetVideoDefinitionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVideoDefinitionOperationCompleted);
            }
            this.InvokeAsync("GetVideoDefinition", new object[0], this.GetVideoDefinitionOperationCompleted, userState);
        }
        
        private void OnGetVideoDefinitionOperationCompleted(object arg) {
            if ((this.GetVideoDefinitionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVideoDefinitionCompleted(this, new GetVideoDefinitionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVideoEncodingArray", RequestElementName="GetVideoEncodingArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetVideoEncodingArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetVideoEncodingArrayResult")]
        public VideoEncoding[] GetVideoEncoding() {
            object[] results = this.Invoke("GetVideoEncoding", new object[0]);
            return ((VideoEncoding[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVideoEncoding(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVideoEncoding", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public VideoEncoding[] EndGetVideoEncoding(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VideoEncoding[])(results[0]));
        }
        
        /// <remarks/>
        public void GetVideoEncodingAsync() {
            this.GetVideoEncodingAsync(null);
        }
        
        /// <remarks/>
        public void GetVideoEncodingAsync(object userState) {
            if ((this.GetVideoEncodingOperationCompleted == null)) {
                this.GetVideoEncodingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVideoEncodingOperationCompleted);
            }
            this.InvokeAsync("GetVideoEncoding", new object[0], this.GetVideoEncodingOperationCompleted, userState);
        }
        
        private void OnGetVideoEncodingOperationCompleted(object arg) {
            if ((this.GetVideoEncodingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVideoEncodingCompleted(this, new GetVideoEncodingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVisibilityLevelArray", RequestElementName="GetVisibilityLevelArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetVisibilityLevelArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetVisibilityLevelArrayResult")]
        public VisibilityLevel[] GetVisibilityLevel() {
            object[] results = this.Invoke("GetVisibilityLevel", new object[0]);
            return ((VisibilityLevel[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVisibilityLevel(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVisibilityLevel", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public VisibilityLevel[] EndGetVisibilityLevel(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VisibilityLevel[])(results[0]));
        }
        
        /// <remarks/>
        public void GetVisibilityLevelAsync() {
            this.GetVisibilityLevelAsync(null);
        }
        
        /// <remarks/>
        public void GetVisibilityLevelAsync(object userState) {
            if ((this.GetVisibilityLevelOperationCompleted == null)) {
                this.GetVisibilityLevelOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVisibilityLevelOperationCompleted);
            }
            this.InvokeAsync("GetVisibilityLevel", new object[0], this.GetVisibilityLevelOperationCompleted, userState);
        }
        
        private void OnGetVisibilityLevelOperationCompleted(object arg) {
            if ((this.GetVisibilityLevelCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVisibilityLevelCompleted(this, new GetVisibilityLevelCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetVisibilityStatusArray", RequestElementName="GetVisibilityStatusArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetVisibilityStatusArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetVisibilityStatusArrayResult")]
        public VisibilityStatus[] GetVisibilityStatus() {
            object[] results = this.Invoke("GetVisibilityStatus", new object[0]);
            return ((VisibilityStatus[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetVisibilityStatus(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetVisibilityStatus", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public VisibilityStatus[] EndGetVisibilityStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VisibilityStatus[])(results[0]));
        }
        
        /// <remarks/>
        public void GetVisibilityStatusAsync() {
            this.GetVisibilityStatusAsync(null);
        }
        
        /// <remarks/>
        public void GetVisibilityStatusAsync(object userState) {
            if ((this.GetVisibilityStatusOperationCompleted == null)) {
                this.GetVisibilityStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetVisibilityStatusOperationCompleted);
            }
            this.InvokeAsync("GetVisibilityStatus", new object[0], this.GetVisibilityStatusOperationCompleted, userState);
        }
        
        private void OnGetVisibilityStatusOperationCompleted(object arg) {
            if ((this.GetVisibilityStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetVisibilityStatusCompleted(this, new GetVisibilityStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetProviderOne", RequestElementName="GetProviderOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetProviderOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetProviderOneResult")]
        public Provider GetProvider(int id) {
            object[] results = this.Invoke("GetProvider", new object[] {
                        id});
            return ((Provider)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetProvider(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetProvider", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public Provider EndGetProvider(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Provider)(results[0]));
        }
        
        /// <remarks/>
        public void GetProviderAsync(int id) {
            this.GetProviderAsync(id, null);
        }
        
        /// <remarks/>
        public void GetProviderAsync(int id, object userState) {
            if ((this.GetProviderOperationCompleted == null)) {
                this.GetProviderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetProviderOperationCompleted);
            }
            this.InvokeAsync("GetProvider", new object[] {
                        id}, this.GetProviderOperationCompleted, userState);
        }
        
        private void OnGetProviderOperationCompleted(object arg) {
            if ((this.GetProviderCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetProviderCompleted(this, new GetProviderCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetProvider1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetProviderArray", RequestElementName="GetProviderArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetProviderArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetProviderArrayResult")]
        public Provider[] GetProvider() {
            object[] results = this.Invoke("GetProvider1", new object[0]);
            return ((Provider[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetProvider1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetProvider1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public Provider[] EndGetProvider1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Provider[])(results[0]));
        }
        
        /// <remarks/>
        public void GetProvider1Async() {
            this.GetProvider1Async(null);
        }
        
        /// <remarks/>
        public void GetProvider1Async(object userState) {
            if ((this.GetProvider1OperationCompleted == null)) {
                this.GetProvider1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetProvider1OperationCompleted);
            }
            this.InvokeAsync("GetProvider1", new object[0], this.GetProvider1OperationCompleted, userState);
        }
        
        private void OnGetProvider1OperationCompleted(object arg) {
            if ((this.GetProvider1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetProvider1Completed(this, new GetProvider1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetMetadataProviderOne", RequestElementName="GetMetadataProviderOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetMetadataProviderOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetMetadataProviderOneResult")]
        public MetadataProvider GetMetadataProvider(int id) {
            object[] results = this.Invoke("GetMetadataProvider", new object[] {
                        id});
            return ((MetadataProvider)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMetadataProvider(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMetadataProvider", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public MetadataProvider EndGetMetadataProvider(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MetadataProvider)(results[0]));
        }
        
        /// <remarks/>
        public void GetMetadataProviderAsync(int id) {
            this.GetMetadataProviderAsync(id, null);
        }
        
        /// <remarks/>
        public void GetMetadataProviderAsync(int id, object userState) {
            if ((this.GetMetadataProviderOperationCompleted == null)) {
                this.GetMetadataProviderOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMetadataProviderOperationCompleted);
            }
            this.InvokeAsync("GetMetadataProvider", new object[] {
                        id}, this.GetMetadataProviderOperationCompleted, userState);
        }
        
        private void OnGetMetadataProviderOperationCompleted(object arg) {
            if ((this.GetMetadataProviderCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMetadataProviderCompleted(this, new GetMetadataProviderCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetMetadataProvider1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetMetadataProviderArray", RequestElementName="GetMetadataProviderArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetMetadataProviderArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetMetadataProviderArrayResult")]
        public MetadataProvider[] GetMetadataProvider() {
            object[] results = this.Invoke("GetMetadataProvider1", new object[0]);
            return ((MetadataProvider[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMetadataProvider1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMetadataProvider1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public MetadataProvider[] EndGetMetadataProvider1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MetadataProvider[])(results[0]));
        }
        
        /// <remarks/>
        public void GetMetadataProvider1Async() {
            this.GetMetadataProvider1Async(null);
        }
        
        /// <remarks/>
        public void GetMetadataProvider1Async(object userState) {
            if ((this.GetMetadataProvider1OperationCompleted == null)) {
                this.GetMetadataProvider1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMetadataProvider1OperationCompleted);
            }
            this.InvokeAsync("GetMetadataProvider1", new object[0], this.GetMetadataProvider1OperationCompleted, userState);
        }
        
        private void OnGetMetadataProvider1OperationCompleted(object arg) {
            if ((this.GetMetadataProvider1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMetadataProvider1Completed(this, new GetMetadataProvider1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetDRMLicenseIssuerOne", RequestElementName="GetDRMLicenseIssuerOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetDRMLicenseIssuerOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetDRMLicenseIssuerOneResult")]
        public DRMLicenseIssuer GetDRMLicenseIssuer(int id) {
            object[] results = this.Invoke("GetDRMLicenseIssuer", new object[] {
                        id});
            return ((DRMLicenseIssuer)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDRMLicenseIssuer(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDRMLicenseIssuer", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public DRMLicenseIssuer EndGetDRMLicenseIssuer(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((DRMLicenseIssuer)(results[0]));
        }
        
        /// <remarks/>
        public void GetDRMLicenseIssuerAsync(int id) {
            this.GetDRMLicenseIssuerAsync(id, null);
        }
        
        /// <remarks/>
        public void GetDRMLicenseIssuerAsync(int id, object userState) {
            if ((this.GetDRMLicenseIssuerOperationCompleted == null)) {
                this.GetDRMLicenseIssuerOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDRMLicenseIssuerOperationCompleted);
            }
            this.InvokeAsync("GetDRMLicenseIssuer", new object[] {
                        id}, this.GetDRMLicenseIssuerOperationCompleted, userState);
        }
        
        private void OnGetDRMLicenseIssuerOperationCompleted(object arg) {
            if ((this.GetDRMLicenseIssuerCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDRMLicenseIssuerCompleted(this, new GetDRMLicenseIssuerCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetDRMLicenseIssuer1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetDRMLicenseIssuerArray", RequestElementName="GetDRMLicenseIssuerArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetDRMLicenseIssuerArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetDRMLicenseIssuerArrayResult")]
        public DRMLicenseIssuer[] GetDRMLicenseIssuer() {
            object[] results = this.Invoke("GetDRMLicenseIssuer1", new object[0]);
            return ((DRMLicenseIssuer[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDRMLicenseIssuer1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDRMLicenseIssuer1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public DRMLicenseIssuer[] EndGetDRMLicenseIssuer1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((DRMLicenseIssuer[])(results[0]));
        }
        
        /// <remarks/>
        public void GetDRMLicenseIssuer1Async() {
            this.GetDRMLicenseIssuer1Async(null);
        }
        
        /// <remarks/>
        public void GetDRMLicenseIssuer1Async(object userState) {
            if ((this.GetDRMLicenseIssuer1OperationCompleted == null)) {
                this.GetDRMLicenseIssuer1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDRMLicenseIssuer1OperationCompleted);
            }
            this.InvokeAsync("GetDRMLicenseIssuer1", new object[0], this.GetDRMLicenseIssuer1OperationCompleted, userState);
        }
        
        private void OnGetDRMLicenseIssuer1OperationCompleted(object arg) {
            if ((this.GetDRMLicenseIssuer1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDRMLicenseIssuer1Completed(this, new GetDRMLicenseIssuer1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetLicenseTypeOne", RequestElementName="GetLicenseTypeOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetLicenseTypeOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetLicenseTypeOneResult")]
        public LicenseType GetLicenseType(int id) {
            object[] results = this.Invoke("GetLicenseType", new object[] {
                        id});
            return ((LicenseType)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLicenseType(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLicenseType", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public LicenseType EndGetLicenseType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseType)(results[0]));
        }
        
        /// <remarks/>
        public void GetLicenseTypeAsync(int id) {
            this.GetLicenseTypeAsync(id, null);
        }
        
        /// <remarks/>
        public void GetLicenseTypeAsync(int id, object userState) {
            if ((this.GetLicenseTypeOperationCompleted == null)) {
                this.GetLicenseTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLicenseTypeOperationCompleted);
            }
            this.InvokeAsync("GetLicenseType", new object[] {
                        id}, this.GetLicenseTypeOperationCompleted, userState);
        }
        
        private void OnGetLicenseTypeOperationCompleted(object arg) {
            if ((this.GetLicenseTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLicenseTypeCompleted(this, new GetLicenseTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetLicenseType1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetLicenseTypeArray", RequestElementName="GetLicenseTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetLicenseTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetLicenseTypeArrayResult")]
        public LicenseType[] GetLicenseType() {
            object[] results = this.Invoke("GetLicenseType1", new object[0]);
            return ((LicenseType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLicenseType1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLicenseType1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public LicenseType[] EndGetLicenseType1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetLicenseType1Async() {
            this.GetLicenseType1Async(null);
        }
        
        /// <remarks/>
        public void GetLicenseType1Async(object userState) {
            if ((this.GetLicenseType1OperationCompleted == null)) {
                this.GetLicenseType1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLicenseType1OperationCompleted);
            }
            this.InvokeAsync("GetLicenseType1", new object[0], this.GetLicenseType1OperationCompleted, userState);
        }
        
        private void OnGetLicenseType1OperationCompleted(object arg) {
            if ((this.GetLicenseType1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLicenseType1Completed(this, new GetLicenseType1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveLicenseType", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveLicenseType(LicenseType licenseType) {
            this.Invoke("SaveLicenseType", new object[] {
                        licenseType});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveLicenseType(LicenseType licenseType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveLicenseType", new object[] {
                        licenseType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveLicenseType(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveLicenseTypeAsync(LicenseType licenseType) {
            this.SaveLicenseTypeAsync(licenseType, null);
        }
        
        /// <remarks/>
        public void SaveLicenseTypeAsync(LicenseType licenseType, object userState) {
            if ((this.SaveLicenseTypeOperationCompleted == null)) {
                this.SaveLicenseTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveLicenseTypeOperationCompleted);
            }
            this.InvokeAsync("SaveLicenseType", new object[] {
                        licenseType}, this.SaveLicenseTypeOperationCompleted, userState);
        }
        
        private void OnSaveLicenseTypeOperationCompleted(object arg) {
            if ((this.SaveLicenseTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveLicenseTypeCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetLicenseClassOne", RequestElementName="GetLicenseClassOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetLicenseClassOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetLicenseClassOneResult")]
        public LicenseClass GetLicenseClass(int id) {
            object[] results = this.Invoke("GetLicenseClass", new object[] {
                        id});
            return ((LicenseClass)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLicenseClass(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLicenseClass", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public LicenseClass EndGetLicenseClass(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseClass)(results[0]));
        }
        
        /// <remarks/>
        public void GetLicenseClassAsync(int id) {
            this.GetLicenseClassAsync(id, null);
        }
        
        /// <remarks/>
        public void GetLicenseClassAsync(int id, object userState) {
            if ((this.GetLicenseClassOperationCompleted == null)) {
                this.GetLicenseClassOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLicenseClassOperationCompleted);
            }
            this.InvokeAsync("GetLicenseClass", new object[] {
                        id}, this.GetLicenseClassOperationCompleted, userState);
        }
        
        private void OnGetLicenseClassOperationCompleted(object arg) {
            if ((this.GetLicenseClassCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLicenseClassCompleted(this, new GetLicenseClassCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetLicenseClass1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetLicenseClassArray", RequestElementName="GetLicenseClassArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetLicenseClassArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetLicenseClassArrayResult")]
        public LicenseClass[] GetLicenseClass() {
            object[] results = this.Invoke("GetLicenseClass1", new object[0]);
            return ((LicenseClass[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLicenseClass1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLicenseClass1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public LicenseClass[] EndGetLicenseClass1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseClass[])(results[0]));
        }
        
        /// <remarks/>
        public void GetLicenseClass1Async() {
            this.GetLicenseClass1Async(null);
        }
        
        /// <remarks/>
        public void GetLicenseClass1Async(object userState) {
            if ((this.GetLicenseClass1OperationCompleted == null)) {
                this.GetLicenseClass1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLicenseClass1OperationCompleted);
            }
            this.InvokeAsync("GetLicenseClass1", new object[0], this.GetLicenseClass1OperationCompleted, userState);
        }
        
        private void OnGetLicenseClass1OperationCompleted(object arg) {
            if ((this.GetLicenseClass1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLicenseClass1Completed(this, new GetLicenseClass1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetPricingRuleOne", RequestElementName="GetPricingRuleOne", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetPricingRuleOneResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetPricingRuleOneResult")]
        public PricingRule GetPricingRule(int id) {
            object[] results = this.Invoke("GetPricingRule", new object[] {
                        id});
            return ((PricingRule)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPricingRule(int id, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPricingRule", new object[] {
                        id}, callback, asyncState);
        }
        
        /// <remarks/>
        public PricingRule EndGetPricingRule(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PricingRule)(results[0]));
        }
        
        /// <remarks/>
        public void GetPricingRuleAsync(int id) {
            this.GetPricingRuleAsync(id, null);
        }
        
        /// <remarks/>
        public void GetPricingRuleAsync(int id, object userState) {
            if ((this.GetPricingRuleOperationCompleted == null)) {
                this.GetPricingRuleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPricingRuleOperationCompleted);
            }
            this.InvokeAsync("GetPricingRule", new object[] {
                        id}, this.GetPricingRuleOperationCompleted, userState);
        }
        
        private void OnGetPricingRuleOperationCompleted(object arg) {
            if ((this.GetPricingRuleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPricingRuleCompleted(this, new GetPricingRuleCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetPricingRule1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetPricingRuleArray", RequestElementName="GetPricingRuleArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetPricingRuleArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetPricingRuleArrayResult")]
        public PricingRule[] GetPricingRule() {
            object[] results = this.Invoke("GetPricingRule1", new object[0]);
            return ((PricingRule[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPricingRule1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPricingRule1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public PricingRule[] EndGetPricingRule1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PricingRule[])(results[0]));
        }
        
        /// <remarks/>
        public void GetPricingRule1Async() {
            this.GetPricingRule1Async(null);
        }
        
        /// <remarks/>
        public void GetPricingRule1Async(object userState) {
            if ((this.GetPricingRule1OperationCompleted == null)) {
                this.GetPricingRule1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPricingRule1OperationCompleted);
            }
            this.InvokeAsync("GetPricingRule1", new object[0], this.GetPricingRule1OperationCompleted, userState);
        }
        
        private void OnGetPricingRule1OperationCompleted(object arg) {
            if ((this.GetPricingRule1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPricingRule1Completed(this, new GetPricingRule1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SavePricingRule", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SavePricingRule(PricingRule pricingRule) {
            this.Invoke("SavePricingRule", new object[] {
                        pricingRule});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSavePricingRule(PricingRule pricingRule, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SavePricingRule", new object[] {
                        pricingRule}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSavePricingRule(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SavePricingRuleAsync(PricingRule pricingRule) {
            this.SavePricingRuleAsync(pricingRule, null);
        }
        
        /// <remarks/>
        public void SavePricingRuleAsync(PricingRule pricingRule, object userState) {
            if ((this.SavePricingRuleOperationCompleted == null)) {
                this.SavePricingRuleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSavePricingRuleOperationCompleted);
            }
            this.InvokeAsync("SavePricingRule", new object[] {
                        pricingRule}, this.SavePricingRuleOperationCompleted, userState);
        }
        
        private void OnSavePricingRuleOperationCompleted(object arg) {
            if ((this.SavePricingRuleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SavePricingRuleCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetMediaTypeArray", RequestElementName="GetMediaTypeArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="GetMediaTypeArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("GetMediaTypeArrayResult")]
        public MediaType[] GetMediaType() {
            object[] results = this.Invoke("GetMediaType", new object[0]);
            return ((MediaType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMediaType(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMediaType", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public MediaType[] EndGetMediaType(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MediaType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetMediaTypeAsync() {
            this.GetMediaTypeAsync(null);
        }
        
        /// <remarks/>
        public void GetMediaTypeAsync(object userState) {
            if ((this.GetMediaTypeOperationCompleted == null)) {
                this.GetMediaTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMediaTypeOperationCompleted);
            }
            this.InvokeAsync("GetMediaType", new object[0], this.GetMediaTypeOperationCompleted, userState);
        }
        
        private void OnGetMediaTypeOperationCompleted(object arg) {
            if ((this.GetMediaTypeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMediaTypeCompleted(this, new GetMediaTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveGame", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveGame(Game game) {
            this.Invoke("SaveGame", new object[] {
                        game});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveGame(Game game, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveGame", new object[] {
                        game}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveGame(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveGameAsync(Game game) {
            this.SaveGameAsync(game, null);
        }
        
        /// <remarks/>
        public void SaveGameAsync(Game game, object userState) {
            if ((this.SaveGameOperationCompleted == null)) {
                this.SaveGameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveGameOperationCompleted);
            }
            this.InvokeAsync("SaveGame", new object[] {
                        game}, this.SaveGameOperationCompleted, userState);
        }
        
        private void OnSaveGameOperationCompleted(object arg) {
            if ((this.SaveGameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveGameCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetGame", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Game GetGame(System.Guid gameId) {
            object[] results = this.Invoke("GetGame", new object[] {
                        gameId});
            return ((Game)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGame(System.Guid gameId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGame", new object[] {
                        gameId}, callback, asyncState);
        }
        
        /// <remarks/>
        public Game EndGetGame(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Game)(results[0]));
        }
        
        /// <remarks/>
        public void GetGameAsync(System.Guid gameId) {
            this.GetGameAsync(gameId, null);
        }
        
        /// <remarks/>
        public void GetGameAsync(System.Guid gameId, object userState) {
            if ((this.GetGameOperationCompleted == null)) {
                this.GetGameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetGameOperationCompleted);
            }
            this.InvokeAsync("GetGame", new object[] {
                        gameId}, this.GetGameOperationCompleted, userState);
        }
        
        private void OnGetGameOperationCompleted(object arg) {
            if ((this.GetGameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetGameCompleted(this, new GetGameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/SaveGameContent", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SaveGameContent(GameContent gameContent) {
            this.Invoke("SaveGameContent", new object[] {
                        gameContent});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveGameContent(GameContent gameContent, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveGameContent", new object[] {
                        gameContent}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSaveGameContent(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SaveGameContentAsync(GameContent gameContent) {
            this.SaveGameContentAsync(gameContent, null);
        }
        
        /// <remarks/>
        public void SaveGameContentAsync(GameContent gameContent, object userState) {
            if ((this.SaveGameContentOperationCompleted == null)) {
                this.SaveGameContentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveGameContentOperationCompleted);
            }
            this.InvokeAsync("SaveGameContent", new object[] {
                        gameContent}, this.SaveGameContentOperationCompleted, userState);
        }
        
        private void OnSaveGameContentOperationCompleted(object arg) {
            if ((this.SaveGameContentCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveGameContentCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/GetGameContent", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GameContent GetGameContent(System.Guid gameContentId) {
            object[] results = this.Invoke("GetGameContent", new object[] {
                        gameContentId});
            return ((GameContent)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGameContent(System.Guid gameContentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGameContent", new object[] {
                        gameContentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GameContent EndGetGameContent(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GameContent)(results[0]));
        }
        
        /// <remarks/>
        public void GetGameContentAsync(System.Guid gameContentId) {
            this.GetGameContentAsync(gameContentId, null);
        }
        
        /// <remarks/>
        public void GetGameContentAsync(System.Guid gameContentId, object userState) {
            if ((this.GetGameContentOperationCompleted == null)) {
                this.GetGameContentOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetGameContentOperationCompleted);
            }
            this.InvokeAsync("GetGameContent", new object[] {
                        gameContentId}, this.GetGameContentOperationCompleted, userState);
        }
        
        private void OnGetGameContentOperationCompleted(object arg) {
            if ((this.GetGameContentCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetGameContentCompleted(this, new GetGameContentCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/PaymentMethod", RequestElementName="PaymentMethod", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="PaymentMethodResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("PaymentMethodResult")]
        public PaymentType GetPaymentMethod(int paymentId) {
            object[] results = this.Invoke("GetPaymentMethod", new object[] {
                        paymentId});
            return ((PaymentType)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentMethod(int paymentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentMethod", new object[] {
                        paymentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public PaymentType EndGetPaymentMethod(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PaymentType)(results[0]));
        }
        
        /// <remarks/>
        public void GetPaymentMethodAsync(int paymentId) {
            this.GetPaymentMethodAsync(paymentId, null);
        }
        
        /// <remarks/>
        public void GetPaymentMethodAsync(int paymentId, object userState) {
            if ((this.GetPaymentMethodOperationCompleted == null)) {
                this.GetPaymentMethodOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentMethodOperationCompleted);
            }
            this.InvokeAsync("GetPaymentMethod", new object[] {
                        paymentId}, this.GetPaymentMethodOperationCompleted, userState);
        }
        
        private void OnGetPaymentMethodOperationCompleted(object arg) {
            if ((this.GetPaymentMethodCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentMethodCompleted(this, new GetPaymentMethodCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute(MessageName="GetPaymentMethod1")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.microsoft.com/ems/CatalogWebService/PaymentMethodArray", RequestElementName="PaymentMethodArray", RequestNamespace="http://www.microsoft.com/ems/CatalogWebService/", ResponseElementName="PaymentMethodArrayResponse", ResponseNamespace="http://www.microsoft.com/ems/CatalogWebService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("PaymentMethodArrayResult")]
        public PaymentType[] GetPaymentMethod() {
            object[] results = this.Invoke("GetPaymentMethod1", new object[0]);
            return ((PaymentType[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentMethod1(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentMethod1", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public PaymentType[] EndGetPaymentMethod1(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PaymentType[])(results[0]));
        }
        
        /// <remarks/>
        public void GetPaymentMethod1Async() {
            this.GetPaymentMethod1Async(null);
        }
        
        /// <remarks/>
        public void GetPaymentMethod1Async(object userState) {
            if ((this.GetPaymentMethod1OperationCompleted == null)) {
                this.GetPaymentMethod1OperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentMethod1OperationCompleted);
            }
            this.InvokeAsync("GetPaymentMethod1", new object[0], this.GetPaymentMethod1OperationCompleted, userState);
        }
        
        private void OnGetPaymentMethod1OperationCompleted(object arg) {
            if ((this.GetPaymentMethod1Completed != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentMethod1Completed(this, new GetPaymentMethod1CompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PublishingSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PodcastSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(TaskSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DRMTaskSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GameOfferSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GameTitleSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamePublisherSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ImageSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ContributorRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OfferSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSeasonSearchRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSeriesSearchRequest))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public abstract partial class Request {
        
        private int maxResultsField;
        
        /// <remarks/>
        public int MaxResults {
            get {
                return this.maxResultsField;
            }
            set {
                this.maxResultsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PaymentType {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaType {
        
        private int idField;
        
        private string nameField;
        
        private string mediaClassField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string MediaClass {
            get {
                return this.mediaClassField;
            }
            set {
                this.mediaClassField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PricingRuleInstance {
        
        private int idField;
        
        private int pricingRuleIdField;
        
        private decimal priceWholesaleFromField;
        
        private decimal priceWholesaleToField;
        
        private int pointsRetailField;
        
        private decimal priceRetailField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int PricingRuleId {
            get {
                return this.pricingRuleIdField;
            }
            set {
                this.pricingRuleIdField = value;
            }
        }
        
        /// <remarks/>
        public decimal PriceWholesaleFrom {
            get {
                return this.priceWholesaleFromField;
            }
            set {
                this.priceWholesaleFromField = value;
            }
        }
        
        /// <remarks/>
        public decimal PriceWholesaleTo {
            get {
                return this.priceWholesaleToField;
            }
            set {
                this.priceWholesaleToField = value;
            }
        }
        
        /// <remarks/>
        public int PointsRetail {
            get {
                return this.pointsRetailField;
            }
            set {
                this.pointsRetailField = value;
            }
        }
        
        /// <remarks/>
        public decimal PriceRetail {
            get {
                return this.priceRetailField;
            }
            set {
                this.priceRetailField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public enum DataChangeType {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        Add,
        
        /// <remarks/>
        Update,
        
        /// <remarks/>
        Delete,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PricingRule {
        
        private int primaryIdField;
        
        private string nameField;
        
        private System.DateTime startDateTimeField;
        
        private int providerIdField;
        
        private string countryCodeField;
        
        private string retailCurrencyCodeField;
        
        private string wholesaleCurrencyCodeField;
        
        private int mediaTypeIdField;
        
        private decimal marginField;
        
        private decimal rateField;
        
        private PricingRuleInstance[] pricingRuleInstancesField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int PrimaryId {
            get {
                return this.primaryIdField;
            }
            set {
                this.primaryIdField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDateTime {
            get {
                return this.startDateTimeField;
            }
            set {
                this.startDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public int ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string RetailCurrencyCode {
            get {
                return this.retailCurrencyCodeField;
            }
            set {
                this.retailCurrencyCodeField = value;
            }
        }
        
        /// <remarks/>
        public string WholesaleCurrencyCode {
            get {
                return this.wholesaleCurrencyCodeField;
            }
            set {
                this.wholesaleCurrencyCodeField = value;
            }
        }
        
        /// <remarks/>
        public int MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public decimal Margin {
            get {
                return this.marginField;
            }
            set {
                this.marginField = value;
            }
        }
        
        /// <remarks/>
        public decimal Rate {
            get {
                return this.rateField;
            }
            set {
                this.rateField = value;
            }
        }
        
        /// <remarks/>
        public PricingRuleInstance[] PricingRuleInstances {
            get {
                return this.pricingRuleInstancesField;
            }
            set {
                this.pricingRuleInstancesField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class LicenseClass {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class LicenseTypeLegalTextLocale {
        
        private int licenseTypeIdField;
        
        private int legaltextlcidField;
        
        private string textField;
        
        private string localeField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int LicenseTypeId {
            get {
                return this.licenseTypeIdField;
            }
            set {
                this.licenseTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public int Legaltextlcid {
            get {
                return this.legaltextlcidField;
            }
            set {
                this.legaltextlcidField = value;
            }
        }
        
        /// <remarks/>
        public string Text {
            get {
                return this.textField;
            }
            set {
                this.textField = value;
            }
        }
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class LicenseType {
        
        private LicenseTypeLegalTextLocale[] legalTextLocalesField;
        
        private int idField;
        
        private string nameField;
        
        private int licenseClassIdField;
        
        private string licenseXMLField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public LicenseTypeLegalTextLocale[] LegalTextLocales {
            get {
                return this.legalTextLocalesField;
            }
            set {
                this.legalTextLocalesField = value;
            }
        }
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public int LicenseClassId {
            get {
                return this.licenseClassIdField;
            }
            set {
                this.licenseClassIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string LicenseXML {
            get {
                return this.licenseXMLField;
            }
            set {
                this.licenseXMLField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VisibilityStatus {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VisibilityLevel {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoDefinition {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class UserType {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DRMTask))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Task {
        
        private int taskStatusIdField;
        
        private string taskStatusNameField;
        
        private string taskDataField;
        
        private System.Guid taskInstanceIdField;
        
        private string fileNameField;
        
        private string inputFileLocationField;
        
        private string outputFileLocationField;
        
        private System.Nullable<System.DateTime> endDateField;
        
        private System.DateTime startDateField;
        
        private DataChangeType modifiedField;
        
        private string stagerFileLocationField;
        
        private string asperaFileLocationField;
        
        private string statusMessageField;
        
        /// <remarks/>
        public int TaskStatusId {
            get {
                return this.taskStatusIdField;
            }
            set {
                this.taskStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public string TaskStatusName {
            get {
                return this.taskStatusNameField;
            }
            set {
                this.taskStatusNameField = value;
            }
        }
        
        /// <remarks/>
        public string TaskData {
            get {
                return this.taskDataField;
            }
            set {
                this.taskDataField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid TaskInstanceId {
            get {
                return this.taskInstanceIdField;
            }
            set {
                this.taskInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string FileName {
            get {
                return this.fileNameField;
            }
            set {
                this.fileNameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string InputFileLocation {
            get {
                return this.inputFileLocationField;
            }
            set {
                this.inputFileLocationField = value;
            }
        }
        
        /// <remarks/>
        public string OutputFileLocation {
            get {
                return this.outputFileLocationField;
            }
            set {
                this.outputFileLocationField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
        
        /// <remarks/>
        public string StagerFileLocation {
            get {
                return this.stagerFileLocationField;
            }
            set {
                this.stagerFileLocationField = value;
            }
        }
        
        /// <remarks/>
        public string AsperaFileLocation {
            get {
                return this.asperaFileLocationField;
            }
            set {
                this.asperaFileLocationField = value;
            }
        }
        
        /// <remarks/>
        public string StatusMessage {
            get {
                return this.statusMessageField;
            }
            set {
                this.statusMessageField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class DRMTask : Task {
        
        private System.Guid mediaInstanceIdField;
        
        private bool isDRMRequiredField;
        
        /// <remarks/>
        public System.Guid MediaInstanceId {
            get {
                return this.mediaInstanceIdField;
            }
            set {
                this.mediaInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public bool IsDRMRequired {
            get {
                return this.isDRMRequiredField;
            }
            set {
                this.isDRMRequiredField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class TaskStatus {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Store {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Role {
        
        private int idField;
        
        private string nameField;
        
        private int sortOrderField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PreviewMediaInstanceType {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaRelationshipType {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ImageSize {
        
        private int idField;
        
        private string nameField;
        
        private int widthField;
        
        private int heightField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public int Width {
            get {
                return this.widthField;
            }
            set {
                this.widthField = value;
            }
        }
        
        /// <remarks/>
        public int Height {
            get {
                return this.heightField;
            }
            set {
                this.heightField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ImageFormat {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Locale {
        
        private int lCIDField;
        
        private string localeCodeField;
        
        private int defaultLCIDField;
        
        private string countryCodeField;
        
        private string collationField;
        
        private string internalNameField;
        
        /// <remarks/>
        public int LCID {
            get {
                return this.lCIDField;
            }
            set {
                this.lCIDField = value;
            }
        }
        
        /// <remarks/>
        public string LocaleCode {
            get {
                return this.localeCodeField;
            }
            set {
                this.localeCodeField = value;
            }
        }
        
        /// <remarks/>
        public int DefaultLCID {
            get {
                return this.defaultLCIDField;
            }
            set {
                this.defaultLCIDField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string Collation {
            get {
                return this.collationField;
            }
            set {
                this.collationField = value;
            }
        }
        
        /// <remarks/>
        public string InternalName {
            get {
                return this.internalNameField;
            }
            set {
                this.internalNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ClientType {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class AudioEncoding {
        
        private int idField;
        
        private string nameField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoEncoding {
        
        private int idField;
        
        private string nameField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorRelationship {
        
        private System.Guid relatedContributorIdField;
        
        private int contributorRelationshipTypeIdField;
        
        private int roleIdField;
        
        private bool isPrimaryField;
        
        private int sortOrderField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid RelatedContributorId {
            get {
                return this.relatedContributorIdField;
            }
            set {
                this.relatedContributorIdField = value;
            }
        }
        
        /// <remarks/>
        public int ContributorRelationshipTypeId {
            get {
                return this.contributorRelationshipTypeIdField;
            }
            set {
                this.contributorRelationshipTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public int RoleId {
            get {
                return this.roleIdField;
            }
            set {
                this.roleIdField = value;
            }
        }
        
        /// <remarks/>
        public bool IsPrimary {
            get {
                return this.isPrimaryField;
            }
            set {
                this.isPrimaryField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorLocaleMap {
        
        private int lcidField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorLocale {
        
        private int lcidField;
        
        private string displayNameField;
        
        private ContributorLocaleMap[] targetingLocalesField;
        
        private DataChangeType modifiedField;
        
        private string sortNameField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayName {
            get {
                return this.displayNameField;
            }
            set {
                this.displayNameField = value;
            }
        }
        
        /// <remarks/>
        public ContributorLocaleMap[] TargetingLocales {
            get {
                return this.targetingLocalesField;
            }
            set {
                this.targetingLocalesField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
        
        /// <remarks/>
        public string SortName {
            get {
                return this.sortNameField;
            }
            set {
                this.sortNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorCategory {
        
        private int categoryIdField;
        
        private int sortOrderField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int CategoryId {
            get {
                return this.categoryIdField;
            }
            set {
                this.categoryIdField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorAlias {
        
        private System.Guid idField;
        
        private string aliasField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Alias {
            get {
                return this.aliasField;
            }
            set {
                this.aliasField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorArticle {
        
        private System.Guid articleIdField;
        
        private int sortOrderField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid ArticleId {
            get {
                return this.articleIdField;
            }
            set {
                this.articleIdField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Contributor {
        
        private System.Guid idField;
        
        private int metadataProviderIdField;
        
        private System.DateTime birthDateField;
        
        private string displayBirthDateField;
        
        private string birthPlaceField;
        
        private System.DateTime deathDateField;
        
        private string displayDeathDateField;
        
        private string deathPlaceField;
        
        private bool isGroupField;
        
        private ContributorArticle[] articlesField;
        
        private ContributorAlias[] aliasesField;
        
        private ContributorCategory[] categoriesField;
        
        private ContributorLocale[] localesField;
        
        private ContributorRelationship[] relationshipsField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int MetadataProviderId {
            get {
                return this.metadataProviderIdField;
            }
            set {
                this.metadataProviderIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime BirthDate {
            get {
                return this.birthDateField;
            }
            set {
                this.birthDateField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayBirthDate {
            get {
                return this.displayBirthDateField;
            }
            set {
                this.displayBirthDateField = value;
            }
        }
        
        /// <remarks/>
        public string BirthPlace {
            get {
                return this.birthPlaceField;
            }
            set {
                this.birthPlaceField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime DeathDate {
            get {
                return this.deathDateField;
            }
            set {
                this.deathDateField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayDeathDate {
            get {
                return this.displayDeathDateField;
            }
            set {
                this.displayDeathDateField = value;
            }
        }
        
        /// <remarks/>
        public string DeathPlace {
            get {
                return this.deathPlaceField;
            }
            set {
                this.deathPlaceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsGroup {
            get {
                return this.isGroupField;
            }
            set {
                this.isGroupField = value;
            }
        }
        
        /// <remarks/>
        public ContributorArticle[] Articles {
            get {
                return this.articlesField;
            }
            set {
                this.articlesField = value;
            }
        }
        
        /// <remarks/>
        public ContributorAlias[] Aliases {
            get {
                return this.aliasesField;
            }
            set {
                this.aliasesField = value;
            }
        }
        
        /// <remarks/>
        public ContributorCategory[] Categories {
            get {
                return this.categoriesField;
            }
            set {
                this.categoriesField = value;
            }
        }
        
        /// <remarks/>
        public ContributorLocale[] Locales {
            get {
                return this.localesField;
            }
            set {
                this.localesField = value;
            }
        }
        
        /// <remarks/>
        public ContributorRelationship[] Relationships {
            get {
                return this.relationshipsField;
            }
            set {
                this.relationshipsField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Article {
        
        private System.Guid idField;
        
        private int lcidField;
        
        private int providerIdField;
        
        private string textField;
        
        private string authorField;
        
        private System.DateTime authoredDateField;
        
        private bool isHiddenField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public int ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string Text {
            get {
                return this.textField;
            }
            set {
                this.textField = value;
            }
        }
        
        /// <remarks/>
        public string Author {
            get {
                return this.authorField;
            }
            set {
                this.authorField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime AuthoredDate {
            get {
                return this.authoredDateField;
            }
            set {
                this.authoredDateField = value;
            }
        }
        
        /// <remarks/>
        public bool IsHidden {
            get {
                return this.isHiddenField;
            }
            set {
                this.isHiddenField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class RatingDescriptor {
        
        private int idField;
        
        private string nameField;
        
        private string descriptionField;
        
        private int ratingSystemIdField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public int RatingSystemId {
            get {
                return this.ratingSystemIdField;
            }
            set {
                this.ratingSystemIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class RatingValue {
        
        private int idField;
        
        private string nameField;
        
        private string descriptionField;
        
        private int ratingSystemIdField;
        
        private System.Guid imageMediaIdField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public int RatingSystemId {
            get {
                return this.ratingSystemIdField;
            }
            set {
                this.ratingSystemIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ImageMediaId {
            get {
                return this.imageMediaIdField;
            }
            set {
                this.imageMediaIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class RatingSystem {
        
        private int idField;
        
        private string nameField;
        
        private string[] countriesField;
        
        private RatingValue[] valuesField;
        
        private RatingDescriptor[] descriptorsField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string[] Countries {
            get {
                return this.countriesField;
            }
            set {
                this.countriesField = value;
            }
        }
        
        /// <remarks/>
        public RatingValue[] Values {
            get {
                return this.valuesField;
            }
            set {
                this.valuesField = value;
            }
        }
        
        /// <remarks/>
        public RatingDescriptor[] Descriptors {
            get {
                return this.descriptorsField;
            }
            set {
                this.descriptorsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class CategoryLocaleMap {
        
        private int fromLcidField;
        
        private int toLcidField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int FromLcid {
            get {
                return this.fromLcidField;
            }
            set {
                this.fromLcidField = value;
            }
        }
        
        /// <remarks/>
        public int ToLcid {
            get {
                return this.toLcidField;
            }
            set {
                this.toLcidField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class UriBuilder {
        
        private string fragmentField;
        
        private string hostField;
        
        private string passwordField;
        
        private string pathField;
        
        private int portField;
        
        private string queryField;
        
        private string schemeField;
        
        private string userNameField;
        
        /// <remarks/>
        public string Fragment {
            get {
                return this.fragmentField;
            }
            set {
                this.fragmentField = value;
            }
        }
        
        /// <remarks/>
        public string Host {
            get {
                return this.hostField;
            }
            set {
                this.hostField = value;
            }
        }
        
        /// <remarks/>
        public string Password {
            get {
                return this.passwordField;
            }
            set {
                this.passwordField = value;
            }
        }
        
        /// <remarks/>
        public string Path {
            get {
                return this.pathField;
            }
            set {
                this.pathField = value;
            }
        }
        
        /// <remarks/>
        public int Port {
            get {
                return this.portField;
            }
            set {
                this.portField = value;
            }
        }
        
        /// <remarks/>
        public string Query {
            get {
                return this.queryField;
            }
            set {
                this.queryField = value;
            }
        }
        
        /// <remarks/>
        public string Scheme {
            get {
                return this.schemeField;
            }
            set {
                this.schemeField = value;
            }
        }
        
        /// <remarks/>
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(CategoryCorporationLocale))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class CategoryLocale {
        
        private int categoryIdField;
        
        private int lcidField;
        
        private string nameField;
        
        private int[] lcidMapsField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int CategoryId {
            get {
                return this.categoryIdField;
            }
            set {
                this.categoryIdField = value;
            }
        }
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public int[] LcidMaps {
            get {
                return this.lcidMapsField;
            }
            set {
                this.lcidMapsField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class CategoryCorporationLocale : CategoryLocale {
        
        private string descriptionField;
        
        private string htmlDescriptionField;
        
        private UriBuilder webSiteField;
        
        private string rssFeaturesField;
        
        private string rssAnnouncementField;
        
        private string rssNewsField;
        
        private System.Guid logoImageIdField;
        
        private System.Guid backgroundImageIdField;
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public string HtmlDescription {
            get {
                return this.htmlDescriptionField;
            }
            set {
                this.htmlDescriptionField = value;
            }
        }
        
        /// <remarks/>
        public UriBuilder WebSite {
            get {
                return this.webSiteField;
            }
            set {
                this.webSiteField = value;
            }
        }
        
        /// <remarks/>
        public string RssFeatures {
            get {
                return this.rssFeaturesField;
            }
            set {
                this.rssFeaturesField = value;
            }
        }
        
        /// <remarks/>
        public string RssAnnouncement {
            get {
                return this.rssAnnouncementField;
            }
            set {
                this.rssAnnouncementField = value;
            }
        }
        
        /// <remarks/>
        public string RssNews {
            get {
                return this.rssNewsField;
            }
            set {
                this.rssNewsField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid LogoImageId {
            get {
                return this.logoImageIdField;
            }
            set {
                this.logoImageIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid BackgroundImageId {
            get {
                return this.backgroundImageIdField;
            }
            set {
                this.backgroundImageIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Category {
        
        private int idField;
        
        private int categorySystemIdField;
        
        private System.Nullable<int> parentCategoryIdField;
        
        private Category[] categoriesField;
        
        private CategoryLocale[] localesField;
        
        private CategoryLocaleMap[] categoryLocaleMapField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int CategorySystemId {
            get {
                return this.categorySystemIdField;
            }
            set {
                this.categorySystemIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> ParentCategoryId {
            get {
                return this.parentCategoryIdField;
            }
            set {
                this.parentCategoryIdField = value;
            }
        }
        
        /// <remarks/>
        public Category[] Categories {
            get {
                return this.categoriesField;
            }
            set {
                this.categoriesField = value;
            }
        }
        
        /// <remarks/>
        public CategoryLocale[] Locales {
            get {
                return this.localesField;
            }
            set {
                this.localesField = value;
            }
        }
        
        /// <remarks/>
        public CategoryLocaleMap[] CategoryLocaleMap {
            get {
                return this.categoryLocaleMapField;
            }
            set {
                this.categoryLocaleMapField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class CategorySystem {
        
        private int idField;
        
        private string nameField;
        
        private bool isCorporationField;
        
        private Category[] categoriesField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public bool IsCorporation {
            get {
                return this.isCorporationField;
            }
            set {
                this.isCorporationField = value;
            }
        }
        
        /// <remarks/>
        public Category[] Categories {
            get {
                return this.categoriesField;
            }
            set {
                this.categoriesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Currency {
        
        private string codeField;
        
        private string nameField;
        
        /// <remarks/>
        public string Code {
            get {
                return this.codeField;
            }
            set {
                this.codeField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Country {
        
        private string codeField;
        
        private string nameField;
        
        /// <remarks/>
        public string Code {
            get {
                return this.codeField;
            }
            set {
                this.codeField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorRelationshipType {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaChild {
        
        private System.Guid mediaIdField;
        
        private string mediaTitleField;
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaOffer {
        
        private int mediaTypeIdField;
        
        private string mediaTypeNameField;
        
        private string mediaTitleField;
        
        private MediaChild[] mediaChildsField;
        
        private OfferInstanceMediaType[] mediaTypesField;
        
        /// <remarks/>
        public int MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTypeName {
            get {
                return this.mediaTypeNameField;
            }
            set {
                this.mediaTypeNameField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public MediaChild[] MediaChilds {
            get {
                return this.mediaChildsField;
            }
            set {
                this.mediaChildsField = value;
            }
        }
        
        /// <remarks/>
        public OfferInstanceMediaType[] MediaTypes {
            get {
                return this.mediaTypesField;
            }
            set {
                this.mediaTypesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class OfferInstanceMediaType {
        
        private string audioTrackLangField;
        
        private string subTitleLocaleField;
        
        private string videoDefNameField;
        
        private string idField;
        
        private string audioChannelField;
        
        private string previewCountryCodeField;
        
        private string videoAspectRatioField;
        
        private string videoResolutionField;
        
        private string nameField;
        
        private bool isAdSupportedField;
        
        private int videoDefinitionIdField;
        
        private string languageCodeField;
        
        private bool enabledField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public string AudioTrackLang {
            get {
                return this.audioTrackLangField;
            }
            set {
                this.audioTrackLangField = value;
            }
        }
        
        /// <remarks/>
        public string SubTitleLocale {
            get {
                return this.subTitleLocaleField;
            }
            set {
                this.subTitleLocaleField = value;
            }
        }
        
        /// <remarks/>
        public string VideoDefName {
            get {
                return this.videoDefNameField;
            }
            set {
                this.videoDefNameField = value;
            }
        }
        
        /// <remarks/>
        public string Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string AudioChannel {
            get {
                return this.audioChannelField;
            }
            set {
                this.audioChannelField = value;
            }
        }
        
        /// <remarks/>
        public string PreviewCountryCode {
            get {
                return this.previewCountryCodeField;
            }
            set {
                this.previewCountryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string VideoAspectRatio {
            get {
                return this.videoAspectRatioField;
            }
            set {
                this.videoAspectRatioField = value;
            }
        }
        
        /// <remarks/>
        public string VideoResolution {
            get {
                return this.videoResolutionField;
            }
            set {
                this.videoResolutionField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public bool IsAdSupported {
            get {
                return this.isAdSupportedField;
            }
            set {
                this.isAdSupportedField = value;
            }
        }
        
        /// <remarks/>
        public int VideoDefinitionId {
            get {
                return this.videoDefinitionIdField;
            }
            set {
                this.videoDefinitionIdField = value;
            }
        }
        
        /// <remarks/>
        public string LanguageCode {
            get {
                return this.languageCodeField;
            }
            set {
                this.languageCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool Enabled {
            get {
                return this.enabledField;
            }
            set {
                this.enabledField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Promotion {
        
        private System.Guid idField;
        
        private string nameField;
        
        private System.DateTime startDateTimeField;
        
        private System.DateTime endDateTimeField;
        
        private decimal priceField;
        
        private decimal reportingRetailValueField;
        
        private int priorityField;
        
        private System.Nullable<decimal> promotionalWholesalePriceField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDateTime {
            get {
                return this.startDateTimeField;
            }
            set {
                this.startDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDateTime {
            get {
                return this.endDateTimeField;
            }
            set {
                this.endDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public decimal Price {
            get {
                return this.priceField;
            }
            set {
                this.priceField = value;
            }
        }
        
        /// <remarks/>
        public decimal ReportingRetailValue {
            get {
                return this.reportingRetailValueField;
            }
            set {
                this.reportingRetailValueField = value;
            }
        }
        
        /// <remarks/>
        public int Priority {
            get {
                return this.priorityField;
            }
            set {
                this.priorityField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<decimal> PromotionalWholesalePrice {
            get {
                return this.promotionalWholesalePriceField;
            }
            set {
                this.promotionalWholesalePriceField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ProviderTermGameContentInstanceAsset {
        
        private int assetIdField;
        
        private int quantityField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int AssetId {
            get {
                return this.assetIdField;
            }
            set {
                this.assetIdField = value;
            }
        }
        
        /// <remarks/>
        public int Quantity {
            get {
                return this.quantityField;
            }
            set {
                this.quantityField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ProviderTermGameContentInstance {
        
        private int licenseExtensionBitsField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int LicenseExtensionBits {
            get {
                return this.licenseExtensionBitsField;
            }
            set {
                this.licenseExtensionBitsField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ProviderTermMediaInstanceClientType {
        
        private int clientTypeIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int ClientTypeId {
            get {
                return this.clientTypeIdField;
            }
            set {
                this.clientTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ProviderTermMediaInstance {
        
        private System.Guid mediaInstanceIdField;
        
        private int licenseTypeIdField;
        
        private System.Nullable<System.DateTime> expirationDateField;
        
        private ProviderTermMediaInstanceClientType[] clientTypesField;
        
        private ProviderTermGameContentInstance[] gameContentInstancesField;
        
        private ProviderTermGameContentInstanceAsset[] gameContentAssetInstancesField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid MediaInstanceId {
            get {
                return this.mediaInstanceIdField;
            }
            set {
                this.mediaInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public int LicenseTypeId {
            get {
                return this.licenseTypeIdField;
            }
            set {
                this.licenseTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> ExpirationDate {
            get {
                return this.expirationDateField;
            }
            set {
                this.expirationDateField = value;
            }
        }
        
        /// <remarks/>
        public ProviderTermMediaInstanceClientType[] ClientTypes {
            get {
                return this.clientTypesField;
            }
            set {
                this.clientTypesField = value;
            }
        }
        
        /// <remarks/>
        public ProviderTermGameContentInstance[] GameContentInstances {
            get {
                return this.gameContentInstancesField;
            }
            set {
                this.gameContentInstancesField = value;
            }
        }
        
        /// <remarks/>
        public ProviderTermGameContentInstanceAsset[] GameContentAssetInstances {
            get {
                return this.gameContentAssetInstancesField;
            }
            set {
                this.gameContentAssetInstancesField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ProviderTerm {
        
        private System.Guid idField;
        
        private System.Guid mediaIdField;
        
        private System.DateTime startDateTimeField;
        
        private System.DateTime endDateTimeField;
        
        private decimal wholesalePriceField;
        
        private string wholesalePriceCurrencyCodeField;
        
        private string countryCodeField;
        
        private int providerIdField;
        
        private string externalProviderContentIdField;
        
        private int dRMLicenseIssuerIdField;
        
        private string externalDRMLicenseIssuerContentIdField;
        
        private bool automaticallyGenerateOfferField;
        
        private string modifiedByField;
        
        private ProviderTermMediaInstance[] mediaInstancesField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDateTime {
            get {
                return this.startDateTimeField;
            }
            set {
                this.startDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDateTime {
            get {
                return this.endDateTimeField;
            }
            set {
                this.endDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public decimal WholesalePrice {
            get {
                return this.wholesalePriceField;
            }
            set {
                this.wholesalePriceField = value;
            }
        }
        
        /// <remarks/>
        public string WholesalePriceCurrencyCode {
            get {
                return this.wholesalePriceCurrencyCodeField;
            }
            set {
                this.wholesalePriceCurrencyCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public int ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalProviderContentId {
            get {
                return this.externalProviderContentIdField;
            }
            set {
                this.externalProviderContentIdField = value;
            }
        }
        
        /// <remarks/>
        public int DRMLicenseIssuerId {
            get {
                return this.dRMLicenseIssuerIdField;
            }
            set {
                this.dRMLicenseIssuerIdField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalDRMLicenseIssuerContentId {
            get {
                return this.externalDRMLicenseIssuerContentIdField;
            }
            set {
                this.externalDRMLicenseIssuerContentIdField = value;
            }
        }
        
        /// <remarks/>
        public bool AutomaticallyGenerateOffer {
            get {
                return this.automaticallyGenerateOfferField;
            }
            set {
                this.automaticallyGenerateOfferField = value;
            }
        }
        
        /// <remarks/>
        public string ModifiedBy {
            get {
                return this.modifiedByField;
            }
            set {
                this.modifiedByField = value;
            }
        }
        
        /// <remarks/>
        public ProviderTermMediaInstance[] MediaInstances {
            get {
                return this.mediaInstancesField;
            }
            set {
                this.mediaInstancesField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class OfferInstanceUserType {
        
        private int userTypeIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int UserTypeId {
            get {
                return this.userTypeIdField;
            }
            set {
                this.userTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class OfferInstance {
        
        private System.Guid idField;
        
        private string skuField;
        
        private int pricingRuleIdField;
        
        private int paymentTypeIdField;
        
        private decimal priceField;
        
        private string priceCurrencyCodeField;
        
        private decimal reportingRetailValueField;
        
        private string reportingRetailValueCurrencyCodeField;
        
        private System.DateTime startDateTimeField;
        
        private System.DateTime endDateTimeField;
        
        private string countryCodeField;
        
        private string externalOfferInstanceIdField;
        
        private int visibilityLevelIdField;
        
        private OfferInstanceMediaType[] mediaTypesField;
        
        private OfferInstanceUserType[] userTypesField;
        
        private ProviderTerm[] providerTermsField;
        
        private Promotion[] promotionsField;
        
        private int visibilityStatusIdField;
        
        private InsertDataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Sku {
            get {
                return this.skuField;
            }
            set {
                this.skuField = value;
            }
        }
        
        /// <remarks/>
        public int PricingRuleId {
            get {
                return this.pricingRuleIdField;
            }
            set {
                this.pricingRuleIdField = value;
            }
        }
        
        /// <remarks/>
        public int PaymentTypeId {
            get {
                return this.paymentTypeIdField;
            }
            set {
                this.paymentTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public decimal Price {
            get {
                return this.priceField;
            }
            set {
                this.priceField = value;
            }
        }
        
        /// <remarks/>
        public string PriceCurrencyCode {
            get {
                return this.priceCurrencyCodeField;
            }
            set {
                this.priceCurrencyCodeField = value;
            }
        }
        
        /// <remarks/>
        public decimal ReportingRetailValue {
            get {
                return this.reportingRetailValueField;
            }
            set {
                this.reportingRetailValueField = value;
            }
        }
        
        /// <remarks/>
        public string ReportingRetailValueCurrencyCode {
            get {
                return this.reportingRetailValueCurrencyCodeField;
            }
            set {
                this.reportingRetailValueCurrencyCodeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDateTime {
            get {
                return this.startDateTimeField;
            }
            set {
                this.startDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDateTime {
            get {
                return this.endDateTimeField;
            }
            set {
                this.endDateTimeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalOfferInstanceId {
            get {
                return this.externalOfferInstanceIdField;
            }
            set {
                this.externalOfferInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public int VisibilityLevelId {
            get {
                return this.visibilityLevelIdField;
            }
            set {
                this.visibilityLevelIdField = value;
            }
        }
        
        /// <remarks/>
        public OfferInstanceMediaType[] MediaTypes {
            get {
                return this.mediaTypesField;
            }
            set {
                this.mediaTypesField = value;
            }
        }
        
        /// <remarks/>
        public OfferInstanceUserType[] UserTypes {
            get {
                return this.userTypesField;
            }
            set {
                this.userTypesField = value;
            }
        }
        
        /// <remarks/>
        public ProviderTerm[] ProviderTerms {
            get {
                return this.providerTermsField;
            }
            set {
                this.providerTermsField = value;
            }
        }
        
        /// <remarks/>
        public Promotion[] Promotions {
            get {
                return this.promotionsField;
            }
            set {
                this.promotionsField = value;
            }
        }
        
        /// <remarks/>
        public int VisibilityStatusId {
            get {
                return this.visibilityStatusIdField;
            }
            set {
                this.visibilityStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public InsertDataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public enum InsertDataChangeType {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        Add,
        
        /// <remarks/>
        Update,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class OfferStore {
        
        private int storeIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int StoreId {
            get {
                return this.storeIdField;
            }
            set {
                this.storeIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Offer {
        
        private System.Guid idField;
        
        private string nameField;
        
        private System.Guid mediaIdField;
        
        private OfferMode offerTypeField;
        
        private OfferStore[] storesField;
        
        private OfferInstance[] instancesField;
        
        private InsertDataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public OfferMode OfferType {
            get {
                return this.offerTypeField;
            }
            set {
                this.offerTypeField = value;
            }
        }
        
        /// <remarks/>
        public OfferStore[] Stores {
            get {
                return this.storesField;
            }
            set {
                this.storesField = value;
            }
        }
        
        /// <remarks/>
        public OfferInstance[] Instances {
            get {
                return this.instancesField;
            }
            set {
                this.instancesField = value;
            }
        }
        
        /// <remarks/>
        public InsertDataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public enum OfferMode {
        
        /// <remarks/>
        Standalone,
        
        /// <remarks/>
        VideoSeason,
        
        /// <remarks/>
        StandaloneAllEpisodeSeason,
        
        /// <remarks/>
        VideoSeries,
        
        /// <remarks/>
        StandaloneAllEpisodeSeries,
        
        /// <remarks/>
        Game,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Publishing {
        
        private PublishingVisiblityStatus visibilityStatusField;
        
        private System.Guid[] offerInstanceIDsField;
        
        private DataChangeType modifiedField;
        
        private System.Nullable<System.DateTime> offerinstanceStartDateTimeField;
        
        private System.Nullable<System.DateTime> offerinstanceEndDateTimeField;
        
        /// <remarks/>
        public PublishingVisiblityStatus VisibilityStatus {
            get {
                return this.visibilityStatusField;
            }
            set {
                this.visibilityStatusField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid[] OfferInstanceIDs {
            get {
                return this.offerInstanceIDsField;
            }
            set {
                this.offerInstanceIDsField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> OfferinstanceStartDateTime {
            get {
                return this.offerinstanceStartDateTimeField;
            }
            set {
                this.offerinstanceStartDateTimeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> OfferinstanceEndDateTime {
            get {
                return this.offerinstanceEndDateTimeField;
            }
            set {
                this.offerinstanceEndDateTimeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public enum PublishingVisiblityStatus {
        
        /// <remarks/>
        Live,
        
        /// <remarks/>
        Withdraw,
        
        /// <remarks/>
        NoChange,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ExternalFeedMapping {
        
        private string externalIdField;
        
        private System.Nullable<int> catalogIdField;
        
        private int externalFeedSourceIdField;
        
        private int externalFeedmappingObjectIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public string ExternalId {
            get {
                return this.externalIdField;
            }
            set {
                this.externalIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> CatalogId {
            get {
                return this.catalogIdField;
            }
            set {
                this.catalogIdField = value;
            }
        }
        
        /// <remarks/>
        public int ExternalFeedSourceId {
            get {
                return this.externalFeedSourceIdField;
            }
            set {
                this.externalFeedSourceIdField = value;
            }
        }
        
        /// <remarks/>
        public int ExternalFeedmappingObjectId {
            get {
                return this.externalFeedmappingObjectIdField;
            }
            set {
                this.externalFeedmappingObjectIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ExternalFeedMappingObject {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ExternalFeedSource {
        
        private int idField;
        
        private string nameField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DRMLicenseIssuer))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(MetadataProvider))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Provider))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Entity {
        
        private int idField;
        
        private string nameField;
        
        private string contactInfoField;
        
        private string accountNumberField;
        
        private string externalEntityIdField;
        
        private bool isProviderField;
        
        private bool isMetadataProviderField;
        
        private bool isDrmLicenseIssuerField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string ContactInfo {
            get {
                return this.contactInfoField;
            }
            set {
                this.contactInfoField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalEntityId {
            get {
                return this.externalEntityIdField;
            }
            set {
                this.externalEntityIdField = value;
            }
        }
        
        /// <remarks/>
        public bool IsProvider {
            get {
                return this.isProviderField;
            }
            set {
                this.isProviderField = value;
            }
        }
        
        /// <remarks/>
        public bool IsMetadataProvider {
            get {
                return this.isMetadataProviderField;
            }
            set {
                this.isMetadataProviderField = value;
            }
        }
        
        /// <remarks/>
        public bool IsDrmLicenseIssuer {
            get {
                return this.isDrmLicenseIssuerField;
            }
            set {
                this.isDrmLicenseIssuerField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class DRMLicenseIssuer : Entity {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MetadataProvider : Entity {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Provider : Entity {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameContentAvatarItem {
        
        private int avatarBodyTypeIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int AvatarBodyTypeId {
            get {
                return this.avatarBodyTypeIdField;
            }
            set {
                this.avatarBodyTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameCapabilityCountryMap {
        
        private string countryCodeField;
        
        private string countryCodeMapField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCodeMap {
            get {
                return this.countryCodeMapField;
            }
            set {
                this.countryCodeMapField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameCapabilityCountry {
        
        private System.Guid gameMediaIdField;
        
        private string countryCodeField;
        
        private System.Nullable<int> offlinePlayersMinField;
        
        private System.Nullable<int> offlinePlayersMaxField;
        
        private System.Nullable<int> offlineCoopPlayersMinField;
        
        private System.Nullable<int> offlineCoopPlayersMaxField;
        
        private System.Nullable<bool> offlineCoopHardDriveRequiredField;
        
        private System.Nullable<int> offlineCoopHardDriveStorageAmountField;
        
        private System.Nullable<int> offlineCoopHardDriveStorageAmountUnitIdField;
        
        private System.Nullable<int> offlineSaveStorageAmountField;
        
        private System.Nullable<int> offlineSaveStorageAmountUnitIdField;
        
        private System.Nullable<int> offlineSystemLinkMinField;
        
        private System.Nullable<int> offlineSystemLinkMaxField;
        
        private System.Nullable<int> offlineMaxHDTVModeIdField;
        
        private System.Nullable<bool> offlineVoiceCommandsField;
        
        private System.Nullable<bool> offlinePeripheralWheelField;
        
        private System.Nullable<bool> offlinePeripheralGamePadField;
        
        private System.Nullable<bool> offlinePeripheralArcadeStickField;
        
        private System.Nullable<bool> offlinePeripheralFlightStickField;
        
        private System.Nullable<bool> offlinePeripheralDancePadField;
        
        private System.Nullable<bool> offlinePeripheralForceFeedbackWheelField;
        
        private System.Nullable<bool> offlinePeripheralCameraField;
        
        private System.Nullable<bool> offlineCustomSoundtracksField;
        
        private System.Nullable<bool> offlineDolbyDigitalField;
        
        private System.Nullable<int> onlineMultiplayerMinField;
        
        private System.Nullable<int> onlineMultiplayerMaxField;
        
        private System.Nullable<bool> onlineMultiplayerHardDriveRequiredField;
        
        private System.Nullable<int> onlineCoopPlayersMinField;
        
        private System.Nullable<int> onlineCoopPlayersMaxField;
        
        private System.Nullable<bool> onlineCoopHardDriveRequiredField;
        
        private System.Nullable<int> onlineCoopHardDriveStorageAmountField;
        
        private System.Nullable<int> onlineCoopHardDriveStorageAmountUnitIdField;
        
        private System.Nullable<bool> onlineHardDriveRequiredField;
        
        private System.Nullable<int> onlinePlayStorageAmountField;
        
        private System.Nullable<int> onlinePlayStorageAmountUnitIdField;
        
        private System.Nullable<bool> onlineContentDownloadField;
        
        private System.Nullable<bool> onlineLeaderboardsField;
        
        private System.Nullable<bool> onlineSpectatorModeField;
        
        private System.Nullable<bool> onlineVoiceField;
        
        private System.Nullable<bool> onlineOnlyField;
        
        private GameCapabilityCountryMap[] gameCapabilityCountryMapsField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid GameMediaId {
            get {
                return this.gameMediaIdField;
            }
            set {
                this.gameMediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflinePlayersMin {
            get {
                return this.offlinePlayersMinField;
            }
            set {
                this.offlinePlayersMinField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflinePlayersMax {
            get {
                return this.offlinePlayersMaxField;
            }
            set {
                this.offlinePlayersMaxField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineCoopPlayersMin {
            get {
                return this.offlineCoopPlayersMinField;
            }
            set {
                this.offlineCoopPlayersMinField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineCoopPlayersMax {
            get {
                return this.offlineCoopPlayersMaxField;
            }
            set {
                this.offlineCoopPlayersMaxField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflineCoopHardDriveRequired {
            get {
                return this.offlineCoopHardDriveRequiredField;
            }
            set {
                this.offlineCoopHardDriveRequiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineCoopHardDriveStorageAmount {
            get {
                return this.offlineCoopHardDriveStorageAmountField;
            }
            set {
                this.offlineCoopHardDriveStorageAmountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineCoopHardDriveStorageAmountUnitId {
            get {
                return this.offlineCoopHardDriveStorageAmountUnitIdField;
            }
            set {
                this.offlineCoopHardDriveStorageAmountUnitIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineSaveStorageAmount {
            get {
                return this.offlineSaveStorageAmountField;
            }
            set {
                this.offlineSaveStorageAmountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineSaveStorageAmountUnitId {
            get {
                return this.offlineSaveStorageAmountUnitIdField;
            }
            set {
                this.offlineSaveStorageAmountUnitIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineSystemLinkMin {
            get {
                return this.offlineSystemLinkMinField;
            }
            set {
                this.offlineSystemLinkMinField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineSystemLinkMax {
            get {
                return this.offlineSystemLinkMaxField;
            }
            set {
                this.offlineSystemLinkMaxField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OfflineMaxHDTVModeId {
            get {
                return this.offlineMaxHDTVModeIdField;
            }
            set {
                this.offlineMaxHDTVModeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflineVoiceCommands {
            get {
                return this.offlineVoiceCommandsField;
            }
            set {
                this.offlineVoiceCommandsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralWheel {
            get {
                return this.offlinePeripheralWheelField;
            }
            set {
                this.offlinePeripheralWheelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralGamePad {
            get {
                return this.offlinePeripheralGamePadField;
            }
            set {
                this.offlinePeripheralGamePadField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralArcadeStick {
            get {
                return this.offlinePeripheralArcadeStickField;
            }
            set {
                this.offlinePeripheralArcadeStickField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralFlightStick {
            get {
                return this.offlinePeripheralFlightStickField;
            }
            set {
                this.offlinePeripheralFlightStickField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralDancePad {
            get {
                return this.offlinePeripheralDancePadField;
            }
            set {
                this.offlinePeripheralDancePadField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralForceFeedbackWheel {
            get {
                return this.offlinePeripheralForceFeedbackWheelField;
            }
            set {
                this.offlinePeripheralForceFeedbackWheelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflinePeripheralCamera {
            get {
                return this.offlinePeripheralCameraField;
            }
            set {
                this.offlinePeripheralCameraField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflineCustomSoundtracks {
            get {
                return this.offlineCustomSoundtracksField;
            }
            set {
                this.offlineCustomSoundtracksField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OfflineDolbyDigital {
            get {
                return this.offlineDolbyDigitalField;
            }
            set {
                this.offlineDolbyDigitalField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlineMultiplayerMin {
            get {
                return this.onlineMultiplayerMinField;
            }
            set {
                this.onlineMultiplayerMinField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlineMultiplayerMax {
            get {
                return this.onlineMultiplayerMaxField;
            }
            set {
                this.onlineMultiplayerMaxField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineMultiplayerHardDriveRequired {
            get {
                return this.onlineMultiplayerHardDriveRequiredField;
            }
            set {
                this.onlineMultiplayerHardDriveRequiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlineCoopPlayersMin {
            get {
                return this.onlineCoopPlayersMinField;
            }
            set {
                this.onlineCoopPlayersMinField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlineCoopPlayersMax {
            get {
                return this.onlineCoopPlayersMaxField;
            }
            set {
                this.onlineCoopPlayersMaxField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineCoopHardDriveRequired {
            get {
                return this.onlineCoopHardDriveRequiredField;
            }
            set {
                this.onlineCoopHardDriveRequiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlineCoopHardDriveStorageAmount {
            get {
                return this.onlineCoopHardDriveStorageAmountField;
            }
            set {
                this.onlineCoopHardDriveStorageAmountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlineCoopHardDriveStorageAmountUnitId {
            get {
                return this.onlineCoopHardDriveStorageAmountUnitIdField;
            }
            set {
                this.onlineCoopHardDriveStorageAmountUnitIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineHardDriveRequired {
            get {
                return this.onlineHardDriveRequiredField;
            }
            set {
                this.onlineHardDriveRequiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlinePlayStorageAmount {
            get {
                return this.onlinePlayStorageAmountField;
            }
            set {
                this.onlinePlayStorageAmountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> OnlinePlayStorageAmountUnitId {
            get {
                return this.onlinePlayStorageAmountUnitIdField;
            }
            set {
                this.onlinePlayStorageAmountUnitIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineContentDownload {
            get {
                return this.onlineContentDownloadField;
            }
            set {
                this.onlineContentDownloadField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineLeaderboards {
            get {
                return this.onlineLeaderboardsField;
            }
            set {
                this.onlineLeaderboardsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineSpectatorMode {
            get {
                return this.onlineSpectatorModeField;
            }
            set {
                this.onlineSpectatorModeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineVoice {
            get {
                return this.onlineVoiceField;
            }
            set {
                this.onlineVoiceField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<bool> OnlineOnly {
            get {
                return this.onlineOnlyField;
            }
            set {
                this.onlineOnlyField = value;
            }
        }
        
        /// <remarks/>
        public GameCapabilityCountryMap[] GameCapabilityCountryMaps {
            get {
                return this.gameCapabilityCountryMapsField;
            }
            set {
                this.gameCapabilityCountryMapsField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameLocale {
        
        private int lcidField;
        
        private string customGenreField;
        
        private string developerField;
        
        private string publisherField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public string CustomGenre {
            get {
                return this.customGenreField;
            }
            set {
                this.customGenreField = value;
            }
        }
        
        /// <remarks/>
        public string Developer {
            get {
                return this.developerField;
            }
            set {
                this.developerField = value;
            }
        }
        
        /// <remarks/>
        public string Publisher {
            get {
                return this.publisherField;
            }
            set {
                this.publisherField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PodcastEpisode {
        
        private string titleField;
        
        private System.Nullable<System.DateTime> publishedDateField;
        
        private string enclosureUrlField;
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> PublishedDate {
            get {
                return this.publishedDateField;
            }
            set {
                this.publishedDateField = value;
            }
        }
        
        /// <remarks/>
        public string EnclosureUrl {
            get {
                return this.enclosureUrlField;
            }
            set {
                this.enclosureUrlField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaRatingDescriptor {
        
        private int ratingDescriptorIdField;
        
        private double levelField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int RatingDescriptorId {
            get {
                return this.ratingDescriptorIdField;
            }
            set {
                this.ratingDescriptorIdField = value;
            }
        }
        
        /// <remarks/>
        public double Level {
            get {
                return this.levelField;
            }
            set {
                this.levelField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaRating {
        
        private int ratingValueIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int RatingValueId {
            get {
                return this.ratingValueIdField;
            }
            set {
                this.ratingValueIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaRelationship {
        
        private string dataField;
        
        private System.Guid relatedMediaIdField;
        
        private string relatedMediaTitleField;
        
        private int mediaRelationshipTypeIdField;
        
        private int sortOrderField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public string Data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid RelatedMediaId {
            get {
                return this.relatedMediaIdField;
            }
            set {
                this.relatedMediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string RelatedMediaTitle {
            get {
                return this.relatedMediaTitleField;
            }
            set {
                this.relatedMediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public int MediaRelationshipTypeId {
            get {
                return this.mediaRelationshipTypeIdField;
            }
            set {
                this.mediaRelationshipTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaLocaleMap {
        
        private int lcidField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaLocale {
        
        private int lcidField;
        
        private MediaLocaleMap[] mappedLcidsField;
        
        private string titleField;
        
        private string titleSortField;
        
        private string reducedTitleField;
        
        private string descriptionField;
        
        private string reducedDescriptionField;
        
        private string copyrightField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public MediaLocaleMap[] MappedLcids {
            get {
                return this.mappedLcidsField;
            }
            set {
                this.mappedLcidsField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public string TitleSort {
            get {
                return this.titleSortField;
            }
            set {
                this.titleSortField = value;
            }
        }
        
        /// <remarks/>
        public string ReducedTitle {
            get {
                return this.reducedTitleField;
            }
            set {
                this.reducedTitleField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public string ReducedDescription {
            get {
                return this.reducedDescriptionField;
            }
            set {
                this.reducedDescriptionField = value;
            }
        }
        
        /// <remarks/>
        public string Copyright {
            get {
                return this.copyrightField;
            }
            set {
                this.copyrightField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoFile {
        
        private System.Guid idField;
        
        private string fileUrlField;
        
        private long sizeField;
        
        private System.Nullable<int> durationField;
        
        private int indexField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string FileUrl {
            get {
                return this.fileUrlField;
            }
            set {
                this.fileUrlField = value;
            }
        }
        
        /// <remarks/>
        public long Size {
            get {
                return this.sizeField;
            }
            set {
                this.sizeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> Duration {
            get {
                return this.durationField;
            }
            set {
                this.durationField = value;
            }
        }
        
        /// <remarks/>
        public int Index {
            get {
                return this.indexField;
            }
            set {
                this.indexField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSubtitle {
        
        private string languageCodeField;
        
        private string fileUrlField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public string LanguageCode {
            get {
                return this.languageCodeField;
            }
            set {
                this.languageCodeField = value;
            }
        }
        
        /// <remarks/>
        public string FileUrl {
            get {
                return this.fileUrlField;
            }
            set {
                this.fileUrlField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoAudioTrackLanguage {
        
        private int lcidField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameContentInstanceFile {
        
        private System.Guid idField;
        
        private string fileUrlField;
        
        private int sortOrderField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public string FileUrl {
            get {
                return this.fileUrlField;
            }
            set {
                this.fileUrlField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameContentInstanceEncryptedKey {
        
        private byte[] encryptedSymKeyField;
        
        private byte[] encryptedPublicKeyField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] EncryptedSymKey {
            get {
                return this.encryptedSymKeyField;
            }
            set {
                this.encryptedSymKeyField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] EncryptedPublicKey {
            get {
                return this.encryptedPublicKeyField;
            }
            set {
                this.encryptedPublicKeyField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PreviewMediaInstance {
        
        private int previewMediaInstanceTypeIdField;
        
        private System.Nullable<int> requiredUserTypeIdField;
        
        private System.Nullable<System.DateTime> startDateField;
        
        private System.Nullable<System.DateTime> endDateField;
        
        private string countryCodeField;
        
        private int providerIdField;
        
        private string licenserContentIdField;
        
        private int dRMLicenseIssuerIdField;
        
        private InsertDataChangeType modifiedField;
        
        /// <remarks/>
        public int PreviewMediaInstanceTypeId {
            get {
                return this.previewMediaInstanceTypeIdField;
            }
            set {
                this.previewMediaInstanceTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> RequiredUserTypeId {
            get {
                return this.requiredUserTypeIdField;
            }
            set {
                this.requiredUserTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public int ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string LicenserContentId {
            get {
                return this.licenserContentIdField;
            }
            set {
                this.licenserContentIdField = value;
            }
        }
        
        /// <remarks/>
        public int DRMLicenseIssuerId {
            get {
                return this.dRMLicenseIssuerIdField;
            }
            set {
                this.dRMLicenseIssuerIdField = value;
            }
        }
        
        /// <remarks/>
        public InsertDataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ImageInstance))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoInstance))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GameContentInstance))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public abstract partial class MediaInstance {
        
        private System.Guid idField;
        
        private bool isAcquirableField;
        
        private bool isAdSupportedField;
        
        private bool isPreviewField;
        
        private PreviewMediaInstance previewField;
        
        private InsertDataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public bool IsAcquirable {
            get {
                return this.isAcquirableField;
            }
            set {
                this.isAcquirableField = value;
            }
        }
        
        /// <remarks/>
        public bool IsAdSupported {
            get {
                return this.isAdSupportedField;
            }
            set {
                this.isAdSupportedField = value;
            }
        }
        
        /// <remarks/>
        public bool IsPreview {
            get {
                return this.isPreviewField;
            }
            set {
                this.isPreviewField = value;
            }
        }
        
        /// <remarks/>
        public PreviewMediaInstance Preview {
            get {
                return this.previewField;
            }
            set {
                this.previewField = value;
            }
        }
        
        /// <remarks/>
        public InsertDataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ImageInstance : MediaInstance {
        
        private int lcidField;
        
        private string fileUrlField;
        
        private System.Nullable<int> imageFormatIdField;
        
        private int imageSizeIdField;
        
        private System.Nullable<int> fileSizeField;
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
        
        /// <remarks/>
        public string FileUrl {
            get {
                return this.fileUrlField;
            }
            set {
                this.fileUrlField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> ImageFormatId {
            get {
                return this.imageFormatIdField;
            }
            set {
                this.imageFormatIdField = value;
            }
        }
        
        /// <remarks/>
        public int ImageSizeId {
            get {
                return this.imageSizeIdField;
            }
            set {
                this.imageSizeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> FileSize {
            get {
                return this.fileSizeField;
            }
            set {
                this.fileSizeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoInstance : MediaInstance {
        
        private bool isDRMField;
        
        private int audioEncodingIdField;
        
        private string audioChannelField;
        
        private System.Nullable<int> audioSamplingRateField;
        
        private bool audioCCField;
        
        private System.Nullable<int> burntInSubtitleLcidField;
        
        private System.Nullable<int> audioBitRateField;
        
        private int videoDefinitionIdField;
        
        private string videoAspectRatioField;
        
        private string videoResolutionField;
        
        private int videoEncodingIdField;
        
        private int videoBitRateField;
        
        private System.Nullable<int> videoFrameField;
        
        private VideoAudioTrackLanguage[] audioTrackLanguagesField;
        
        private VideoSubtitle[] subtitlesField;
        
        private VideoFile[] videoFilesField;
        
        private bool enabledField;
        
        /// <remarks/>
        public bool IsDRM {
            get {
                return this.isDRMField;
            }
            set {
                this.isDRMField = value;
            }
        }
        
        /// <remarks/>
        public int AudioEncodingId {
            get {
                return this.audioEncodingIdField;
            }
            set {
                this.audioEncodingIdField = value;
            }
        }
        
        /// <remarks/>
        public string AudioChannel {
            get {
                return this.audioChannelField;
            }
            set {
                this.audioChannelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> AudioSamplingRate {
            get {
                return this.audioSamplingRateField;
            }
            set {
                this.audioSamplingRateField = value;
            }
        }
        
        /// <remarks/>
        public bool AudioCC {
            get {
                return this.audioCCField;
            }
            set {
                this.audioCCField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> BurntInSubtitleLcid {
            get {
                return this.burntInSubtitleLcidField;
            }
            set {
                this.burntInSubtitleLcidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> AudioBitRate {
            get {
                return this.audioBitRateField;
            }
            set {
                this.audioBitRateField = value;
            }
        }
        
        /// <remarks/>
        public int VideoDefinitionId {
            get {
                return this.videoDefinitionIdField;
            }
            set {
                this.videoDefinitionIdField = value;
            }
        }
        
        /// <remarks/>
        public string VideoAspectRatio {
            get {
                return this.videoAspectRatioField;
            }
            set {
                this.videoAspectRatioField = value;
            }
        }
        
        /// <remarks/>
        public string VideoResolution {
            get {
                return this.videoResolutionField;
            }
            set {
                this.videoResolutionField = value;
            }
        }
        
        /// <remarks/>
        public int VideoEncodingId {
            get {
                return this.videoEncodingIdField;
            }
            set {
                this.videoEncodingIdField = value;
            }
        }
        
        /// <remarks/>
        public int VideoBitRate {
            get {
                return this.videoBitRateField;
            }
            set {
                this.videoBitRateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> VideoFrame {
            get {
                return this.videoFrameField;
            }
            set {
                this.videoFrameField = value;
            }
        }
        
        /// <remarks/>
        public VideoAudioTrackLanguage[] AudioTrackLanguages {
            get {
                return this.audioTrackLanguagesField;
            }
            set {
                this.audioTrackLanguagesField = value;
            }
        }
        
        /// <remarks/>
        public VideoSubtitle[] Subtitles {
            get {
                return this.subtitlesField;
            }
            set {
                this.subtitlesField = value;
            }
        }
        
        /// <remarks/>
        public VideoFile[] VideoFiles {
            get {
                return this.videoFilesField;
            }
            set {
                this.videoFilesField = value;
            }
        }
        
        /// <remarks/>
        public bool Enabled {
            get {
                return this.enabledField;
            }
            set {
                this.enabledField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameContentInstance : MediaInstance {
        
        private long installSizeField;
        
        private long packageSizeField;
        
        private byte[] liveContentIdField;
        
        private int supportedGameRegionMaskIdField;
        
        private int packageTypeIdField;
        
        private GameContentInstanceEncryptedKey encryptedKeyField;
        
        private GameContentInstanceFile[] gameContentInstanceFilesField;
        
        /// <remarks/>
        public long InstallSize {
            get {
                return this.installSizeField;
            }
            set {
                this.installSizeField = value;
            }
        }
        
        /// <remarks/>
        public long PackageSize {
            get {
                return this.packageSizeField;
            }
            set {
                this.packageSizeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] LiveContentId {
            get {
                return this.liveContentIdField;
            }
            set {
                this.liveContentIdField = value;
            }
        }
        
        /// <remarks/>
        public int SupportedGameRegionMaskId {
            get {
                return this.supportedGameRegionMaskIdField;
            }
            set {
                this.supportedGameRegionMaskIdField = value;
            }
        }
        
        /// <remarks/>
        public int PackageTypeId {
            get {
                return this.packageTypeIdField;
            }
            set {
                this.packageTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public GameContentInstanceEncryptedKey EncryptedKey {
            get {
                return this.encryptedKeyField;
            }
            set {
                this.encryptedKeyField = value;
            }
        }
        
        /// <remarks/>
        public GameContentInstanceFile[] GameContentInstanceFiles {
            get {
                return this.gameContentInstanceFilesField;
            }
            set {
                this.gameContentInstanceFilesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaContributor {
        
        private System.Guid contributorIdField;
        
        private string contributorNameField;
        
        private int roleIdField;
        
        private string characterField;
        
        private int sortOrderField;
        
        private bool isPrimaryField;
        
        private System.Nullable<System.Guid> contributorAliasIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid ContributorId {
            get {
                return this.contributorIdField;
            }
            set {
                this.contributorIdField = value;
            }
        }
        
        /// <remarks/>
        public string ContributorName {
            get {
                return this.contributorNameField;
            }
            set {
                this.contributorNameField = value;
            }
        }
        
        /// <remarks/>
        public int RoleId {
            get {
                return this.roleIdField;
            }
            set {
                this.roleIdField = value;
            }
        }
        
        /// <remarks/>
        public string Character {
            get {
                return this.characterField;
            }
            set {
                this.characterField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public bool IsPrimary {
            get {
                return this.isPrimaryField;
            }
            set {
                this.isPrimaryField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> ContributorAliasId {
            get {
                return this.contributorAliasIdField;
            }
            set {
                this.contributorAliasIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaCategory {
        
        private int categoryIdField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public int CategoryId {
            get {
                return this.categoryIdField;
            }
            set {
                this.categoryIdField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class MediaArticle {
        
        private System.Guid articleIdField;
        
        private int sortOrderField;
        
        private DataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid ArticleId {
            get {
                return this.articleIdField;
            }
            set {
                this.articleIdField = value;
            }
        }
        
        /// <remarks/>
        public int SortOrder {
            get {
                return this.sortOrderField;
            }
            set {
                this.sortOrderField = value;
            }
        }
        
        /// <remarks/>
        public DataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GameContent))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Game))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSeries))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSeason))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Video))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Podcast))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(Image))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public abstract partial class Media {
        
        private System.Guid idField;
        
        private int mediaTypeIdField;
        
        private string mediaTitleField;
        
        private int metadataProviderIdField;
        
        private System.Nullable<System.DateTime> visibilityDateField;
        
        private System.Nullable<System.DateTime> originalReleaseDateField;
        
        private string displayOriginalReleaseDateField;
        
        private bool geoCheckPolicyField;
        
        private int visibilityStatusIdField;
        
        private MediaArticle[] articlesField;
        
        private MediaCategory[] categoriesField;
        
        private MediaContributor[] contributorsField;
        
        private MediaInstance[] instancesField;
        
        private MediaLocale[] localesField;
        
        private MediaRelationship[] relationshipsField;
        
        private MediaRating[] ratingValuesField;
        
        private MediaRatingDescriptor[] ratingDescriptorsField;
        
        private InsertDataChangeType modifiedField;
        
        /// <remarks/>
        public System.Guid Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public int MetadataProviderId {
            get {
                return this.metadataProviderIdField;
            }
            set {
                this.metadataProviderIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> VisibilityDate {
            get {
                return this.visibilityDateField;
            }
            set {
                this.visibilityDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> OriginalReleaseDate {
            get {
                return this.originalReleaseDateField;
            }
            set {
                this.originalReleaseDateField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayOriginalReleaseDate {
            get {
                return this.displayOriginalReleaseDateField;
            }
            set {
                this.displayOriginalReleaseDateField = value;
            }
        }
        
        /// <remarks/>
        public bool GeoCheckPolicy {
            get {
                return this.geoCheckPolicyField;
            }
            set {
                this.geoCheckPolicyField = value;
            }
        }
        
        /// <remarks/>
        public int VisibilityStatusId {
            get {
                return this.visibilityStatusIdField;
            }
            set {
                this.visibilityStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public MediaArticle[] Articles {
            get {
                return this.articlesField;
            }
            set {
                this.articlesField = value;
            }
        }
        
        /// <remarks/>
        public MediaCategory[] Categories {
            get {
                return this.categoriesField;
            }
            set {
                this.categoriesField = value;
            }
        }
        
        /// <remarks/>
        public MediaContributor[] Contributors {
            get {
                return this.contributorsField;
            }
            set {
                this.contributorsField = value;
            }
        }
        
        /// <remarks/>
        public MediaInstance[] Instances {
            get {
                return this.instancesField;
            }
            set {
                this.instancesField = value;
            }
        }
        
        /// <remarks/>
        public MediaLocale[] Locales {
            get {
                return this.localesField;
            }
            set {
                this.localesField = value;
            }
        }
        
        /// <remarks/>
        public MediaRelationship[] Relationships {
            get {
                return this.relationshipsField;
            }
            set {
                this.relationshipsField = value;
            }
        }
        
        /// <remarks/>
        public MediaRating[] RatingValues {
            get {
                return this.ratingValuesField;
            }
            set {
                this.ratingValuesField = value;
            }
        }
        
        /// <remarks/>
        public MediaRatingDescriptor[] RatingDescriptors {
            get {
                return this.ratingDescriptorsField;
            }
            set {
                this.ratingDescriptorsField = value;
            }
        }
        
        /// <remarks/>
        public InsertDataChangeType Modified {
            get {
                return this.modifiedField;
            }
            set {
                this.modifiedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameContent : Media {
        
        private System.Guid gameMediaIdField;
        
        private int contentBitFilterField;
        
        private int effectiveLiveTitleIdField;
        
        private bool consumableField;
        
        private int liveTitleAssetIdField;
        
        private bool inheritRatingField;
        
        private GameContentAvatarItem avatarItemField;
        
        /// <remarks/>
        public System.Guid GameMediaId {
            get {
                return this.gameMediaIdField;
            }
            set {
                this.gameMediaIdField = value;
            }
        }
        
        /// <remarks/>
        public int ContentBitFilter {
            get {
                return this.contentBitFilterField;
            }
            set {
                this.contentBitFilterField = value;
            }
        }
        
        /// <remarks/>
        public int EffectiveLiveTitleId {
            get {
                return this.effectiveLiveTitleIdField;
            }
            set {
                this.effectiveLiveTitleIdField = value;
            }
        }
        
        /// <remarks/>
        public bool Consumable {
            get {
                return this.consumableField;
            }
            set {
                this.consumableField = value;
            }
        }
        
        /// <remarks/>
        public int LiveTitleAssetId {
            get {
                return this.liveTitleAssetIdField;
            }
            set {
                this.liveTitleAssetIdField = value;
            }
        }
        
        /// <remarks/>
        public bool InheritRating {
            get {
                return this.inheritRatingField;
            }
            set {
                this.inheritRatingField = value;
            }
        }
        
        /// <remarks/>
        public GameContentAvatarItem AvatarItem {
            get {
                return this.avatarItemField;
            }
            set {
                this.avatarItemField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Game : Media {
        
        private int liveTitleIdField;
        
        private GameLocale[] gameLocalesField;
        
        private GameCapabilityCountry[] gameCountriesField;
        
        /// <remarks/>
        public int LiveTitleId {
            get {
                return this.liveTitleIdField;
            }
            set {
                this.liveTitleIdField = value;
            }
        }
        
        /// <remarks/>
        public GameLocale[] GameLocales {
            get {
                return this.gameLocalesField;
            }
            set {
                this.gameLocalesField = value;
            }
        }
        
        /// <remarks/>
        public GameCapabilityCountry[] GameCountries {
            get {
                return this.gameCountriesField;
            }
            set {
                this.gameCountriesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSeries : Media {
        
        private string productionCompanyField;
        
        private bool isOrderBySeasonField;
        
        /// <remarks/>
        public string ProductionCompany {
            get {
                return this.productionCompanyField;
            }
            set {
                this.productionCompanyField = value;
            }
        }
        
        /// <remarks/>
        public bool IsOrderBySeason {
            get {
                return this.isOrderBySeasonField;
            }
            set {
                this.isOrderBySeasonField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSeason : Media {
        
        private bool isCompleteField;
        
        private int seasonNumberField;
        
        /// <remarks/>
        public bool IsComplete {
            get {
                return this.isCompleteField;
            }
            set {
                this.isCompleteField = value;
            }
        }
        
        /// <remarks/>
        public int SeasonNumber {
            get {
                return this.seasonNumberField;
            }
            set {
                this.seasonNumberField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Video : Media {
        
        private string cridField;
        
        private string isanField;
        
        private string upcField;
        
        private string subtitleField;
        
        private System.Nullable<int> durationField;
        
        private string productionCompanyField;
        
        private System.Nullable<int> spokenLanguageField;
        
        private System.Nullable<int> episodeNumberField;
        
        private MediaRelationship[] reverseRelationshipsField;
        
        private string productionIdField;
        
        /// <remarks/>
        public string Crid {
            get {
                return this.cridField;
            }
            set {
                this.cridField = value;
            }
        }
        
        /// <remarks/>
        public string Isan {
            get {
                return this.isanField;
            }
            set {
                this.isanField = value;
            }
        }
        
        /// <remarks/>
        public string Upc {
            get {
                return this.upcField;
            }
            set {
                this.upcField = value;
            }
        }
        
        /// <remarks/>
        public string Subtitle {
            get {
                return this.subtitleField;
            }
            set {
                this.subtitleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> Duration {
            get {
                return this.durationField;
            }
            set {
                this.durationField = value;
            }
        }
        
        /// <remarks/>
        public string ProductionCompany {
            get {
                return this.productionCompanyField;
            }
            set {
                this.productionCompanyField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> SpokenLanguage {
            get {
                return this.spokenLanguageField;
            }
            set {
                this.spokenLanguageField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> EpisodeNumber {
            get {
                return this.episodeNumberField;
            }
            set {
                this.episodeNumberField = value;
            }
        }
        
        /// <remarks/>
        public MediaRelationship[] ReverseRelationships {
            get {
                return this.reverseRelationshipsField;
            }
            set {
                this.reverseRelationshipsField = value;
            }
        }
        
        /// <remarks/>
        public string ProductionId {
            get {
                return this.productionIdField;
            }
            set {
                this.productionIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Podcast : Media {
        
        private string rssUrlField;
        
        private string ownerEmailField;
        
        private string ownerNameField;
        
        private string creatorNameField;
        
        private string imageUrlField;
        
        private string websiteUrlField;
        
        private byte starRatingField;
        
        private bool isItemSortAscField;
        
        private bool isExplicitField;
        
        private PodcastContentType contentTypeField;
        
        private string iTunesKeywordsField;
        
        private bool iTunesBlockField;
        
        private string[] iTunesCategoriesField;
        
        private PodcastEpisode[] episodesField;
        
        /// <remarks/>
        public string RssUrl {
            get {
                return this.rssUrlField;
            }
            set {
                this.rssUrlField = value;
            }
        }
        
        /// <remarks/>
        public string OwnerEmail {
            get {
                return this.ownerEmailField;
            }
            set {
                this.ownerEmailField = value;
            }
        }
        
        /// <remarks/>
        public string OwnerName {
            get {
                return this.ownerNameField;
            }
            set {
                this.ownerNameField = value;
            }
        }
        
        /// <remarks/>
        public string CreatorName {
            get {
                return this.creatorNameField;
            }
            set {
                this.creatorNameField = value;
            }
        }
        
        /// <remarks/>
        public string ImageUrl {
            get {
                return this.imageUrlField;
            }
            set {
                this.imageUrlField = value;
            }
        }
        
        /// <remarks/>
        public string WebsiteUrl {
            get {
                return this.websiteUrlField;
            }
            set {
                this.websiteUrlField = value;
            }
        }
        
        /// <remarks/>
        public byte StarRating {
            get {
                return this.starRatingField;
            }
            set {
                this.starRatingField = value;
            }
        }
        
        /// <remarks/>
        public bool IsItemSortAsc {
            get {
                return this.isItemSortAscField;
            }
            set {
                this.isItemSortAscField = value;
            }
        }
        
        /// <remarks/>
        public bool IsExplicit {
            get {
                return this.isExplicitField;
            }
            set {
                this.isExplicitField = value;
            }
        }
        
        /// <remarks/>
        public PodcastContentType ContentType {
            get {
                return this.contentTypeField;
            }
            set {
                this.contentTypeField = value;
            }
        }
        
        /// <remarks/>
        public string ITunesKeywords {
            get {
                return this.iTunesKeywordsField;
            }
            set {
                this.iTunesKeywordsField = value;
            }
        }
        
        /// <remarks/>
        public bool ITunesBlock {
            get {
                return this.iTunesBlockField;
            }
            set {
                this.iTunesBlockField = value;
            }
        }
        
        /// <remarks/>
        public string[] ITunesCategories {
            get {
                return this.iTunesCategoriesField;
            }
            set {
                this.iTunesCategoriesField = value;
            }
        }
        
        /// <remarks/>
        public PodcastEpisode[] Episodes {
            get {
                return this.episodesField;
            }
            set {
                this.episodesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public enum PodcastContentType {
        
        /// <remarks/>
        Unknown,
        
        /// <remarks/>
        Audio,
        
        /// <remarks/>
        Video,
        
        /// <remarks/>
        AudioAndVideo,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class Image : Media {
        
        private string creatorField;
        
        private string issuerField;
        
        /// <remarks/>
        public string Creator {
            get {
                return this.creatorField;
            }
            set {
                this.creatorField = value;
            }
        }
        
        /// <remarks/>
        public string Issuer {
            get {
                return this.issuerField;
            }
            set {
                this.issuerField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSeriesSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ImageSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(TaskSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DRMTaskSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PublishingSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GameOfferSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GameTitleSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamePublisherSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PodcastSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ContributorResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OfferSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(VideoSeasonSearchResponse))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public abstract partial class Response {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSeriesSearchResponse : Response {
        
        private System.Guid mediaIdField;
        
        private string titleField;
        
        private string localeField;
        
        private System.Nullable<System.DateTime> availableDateField;
        
        private string visibilityStatusField;
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableDate {
            get {
                return this.availableDateField;
            }
            set {
                this.availableDateField = value;
            }
        }
        
        /// <remarks/>
        public string VisibilityStatus {
            get {
                return this.visibilityStatusField;
            }
            set {
                this.visibilityStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ImageSearchResponse : Response {
        
        private string descriptionField;
        
        private string urlField;
        
        private Image resultImageField;
        
        private string titleField;
        
        private System.Guid mediaIdField;
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        public string Url {
            get {
                return this.urlField;
            }
            set {
                this.urlField = value;
            }
        }
        
        /// <remarks/>
        public Image ResultImage {
            get {
                return this.resultImageField;
            }
            set {
                this.resultImageField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DRMTaskSearchResponse))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class TaskSearchResponse : Response {
        
        private int taskStatusIdField;
        
        private string fileNameField;
        
        private string inputFileLocationField;
        
        private string stagerFileLocationField;
        
        private string outputFileLocationField;
        
        private string statusMessageField;
        
        private System.DateTime lastUpdatedDateField;
        
        private System.Guid taskInstanceIdField;
        
        private string taskStatusNameField;
        
        /// <remarks/>
        public int TaskStatusId {
            get {
                return this.taskStatusIdField;
            }
            set {
                this.taskStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public string FileName {
            get {
                return this.fileNameField;
            }
            set {
                this.fileNameField = value;
            }
        }
        
        /// <remarks/>
        public string InputFileLocation {
            get {
                return this.inputFileLocationField;
            }
            set {
                this.inputFileLocationField = value;
            }
        }
        
        /// <remarks/>
        public string StagerFileLocation {
            get {
                return this.stagerFileLocationField;
            }
            set {
                this.stagerFileLocationField = value;
            }
        }
        
        /// <remarks/>
        public string OutputFileLocation {
            get {
                return this.outputFileLocationField;
            }
            set {
                this.outputFileLocationField = value;
            }
        }
        
        /// <remarks/>
        public string StatusMessage {
            get {
                return this.statusMessageField;
            }
            set {
                this.statusMessageField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastUpdatedDate {
            get {
                return this.lastUpdatedDateField;
            }
            set {
                this.lastUpdatedDateField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid TaskInstanceId {
            get {
                return this.taskInstanceIdField;
            }
            set {
                this.taskInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string TaskStatusName {
            get {
                return this.taskStatusNameField;
            }
            set {
                this.taskStatusNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class DRMTaskSearchResponse : TaskSearchResponse {
        
        private System.Guid mediaInstanceIdField;
        
        private string titleField;
        
        private string descriptionField;
        
        /// <remarks/>
        public System.Guid MediaInstanceId {
            get {
                return this.mediaInstanceIdField;
            }
            set {
                this.mediaInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PublishingSearchResponse : Response {
        
        private bool selectedField;
        
        private System.DateTime offerStartDateField;
        
        private System.DateTime offerEndDateField;
        
        private int providerIdField;
        
        private string mediaTitleField;
        
        private string offerTitleField;
        
        private string countryCodeField;
        
        private System.Guid offerIdField;
        
        private System.Guid mediaIdField;
        
        private System.Guid offerInstanceGuidField;
        
        private System.Nullable<int> seasonNumberField;
        
        private System.Nullable<int> episodeNumberField;
        
        /// <remarks/>
        public bool Selected {
            get {
                return this.selectedField;
            }
            set {
                this.selectedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime OfferStartDate {
            get {
                return this.offerStartDateField;
            }
            set {
                this.offerStartDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime OfferEndDate {
            get {
                return this.offerEndDateField;
            }
            set {
                this.offerEndDateField = value;
            }
        }
        
        /// <remarks/>
        public int ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public string OfferTitle {
            get {
                return this.offerTitleField;
            }
            set {
                this.offerTitleField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid OfferInstanceGuid {
            get {
                return this.offerInstanceGuidField;
            }
            set {
                this.offerInstanceGuidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> SeasonNumber {
            get {
                return this.seasonNumberField;
            }
            set {
                this.seasonNumberField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> EpisodeNumber {
            get {
                return this.episodeNumberField;
            }
            set {
                this.episodeNumberField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameOfferSearchResponse : Response {
        
        private string mediaTitleField;
        
        private string offerTitleField;
        
        private int mediaTypeIdField;
        
        private int clientTypeIdField;
        
        private System.Guid offerIdField;
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public string OfferTitle {
            get {
                return this.offerTitleField;
            }
            set {
                this.offerTitleField = value;
            }
        }
        
        /// <remarks/>
        public int MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public int ClientTypeId {
            get {
                return this.clientTypeIdField;
            }
            set {
                this.clientTypeIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameTitleSearchResponse : Response {
        
        private System.Guid gameMediaIdField;
        
        private string mediaTitleField;
        
        private int clientTypeIdField;
        
        /// <remarks/>
        public System.Guid GameMediaId {
            get {
                return this.gameMediaIdField;
            }
            set {
                this.gameMediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public int ClientTypeId {
            get {
                return this.clientTypeIdField;
            }
            set {
                this.clientTypeIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GamePublisherSearchResponse : Response {
        
        private int decimalTitleIdField;
        
        private string mediaTitleField;
        
        private int clientTypeIdField;
        
        /// <remarks/>
        public int DecimalTitleId {
            get {
                return this.decimalTitleIdField;
            }
            set {
                this.decimalTitleIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public int ClientTypeId {
            get {
                return this.clientTypeIdField;
            }
            set {
                this.clientTypeIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PodcastSearchResponse : Response {
        
        private System.Guid mediaIdField;
        
        private string titleField;
        
        private string localeField;
        
        private System.DateTime availableDateField;
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime AvailableDate {
            get {
                return this.availableDateField;
            }
            set {
                this.availableDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorResponse : Response {
        
        private System.Guid contributorIdField;
        
        private string nameField;
        
        private string displayBirthDateField;
        
        private string[] mediaTitlesField;
        
        /// <remarks/>
        public System.Guid ContributorId {
            get {
                return this.contributorIdField;
            }
            set {
                this.contributorIdField = value;
            }
        }
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string DisplayBirthDate {
            get {
                return this.displayBirthDateField;
            }
            set {
                this.displayBirthDateField = value;
            }
        }
        
        /// <remarks/>
        public string[] MediaTitles {
            get {
                return this.mediaTitlesField;
            }
            set {
                this.mediaTitlesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class OfferSearchResponse : Response {
        
        private System.Guid offerIdField;
        
        private string offerNameField;
        
        private System.Guid mediaIdField;
        
        private string mediaTitleField;
        
        private string countryField;
        
        private string seasonNumberField;
        
        private string endDateField;
        
        private string visibilityStatusNameField;
        
        /// <remarks/>
        public System.Guid OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string OfferName {
            get {
                return this.offerNameField;
            }
            set {
                this.offerNameField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public string Country {
            get {
                return this.countryField;
            }
            set {
                this.countryField = value;
            }
        }
        
        /// <remarks/>
        public string SeasonNumber {
            get {
                return this.seasonNumberField;
            }
            set {
                this.seasonNumberField = value;
            }
        }
        
        /// <remarks/>
        public string EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string VisibilityStatusName {
            get {
                return this.visibilityStatusNameField;
            }
            set {
                this.visibilityStatusNameField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSearchResponse : Response {
        
        private System.Guid mediaIdField;
        
        private string titleField;
        
        private string localeField;
        
        private System.Nullable<System.DateTime> availableDateField;
        
        private string visibilityStatusField;
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableDate {
            get {
                return this.availableDateField;
            }
            set {
                this.availableDateField = value;
            }
        }
        
        /// <remarks/>
        public string VisibilityStatus {
            get {
                return this.visibilityStatusField;
            }
            set {
                this.visibilityStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSeasonSearchResponse : Response {
        
        private System.Guid mediaIdField;
        
        private string titleField;
        
        private string localeField;
        
        private System.DateTime availableDateField;
        
        private int seasonNumberField;
        
        private string visibilityStatusField;
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime AvailableDate {
            get {
                return this.availableDateField;
            }
            set {
                this.availableDateField = value;
            }
        }
        
        /// <remarks/>
        public int SeasonNumber {
            get {
                return this.seasonNumberField;
            }
            set {
                this.seasonNumberField = value;
            }
        }
        
        /// <remarks/>
        public string VisibilityStatus {
            get {
                return this.visibilityStatusField;
            }
            set {
                this.visibilityStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PublishingSearchRequest : Request {
        
        private System.DateTime minOfferStartDateField;
        
        private System.DateTime maxOfferStartDateField;
        
        private System.DateTime minOfferEndDateField;
        
        private System.DateTime maxOfferEndDateField;
        
        private int providerIdField;
        
        private string titleField;
        
        private int videoDefinitionField;
        
        private int videoVisibilityStatusIdField;
        
        private int offerVisibilityStatusIdField;
        
        /// <remarks/>
        public System.DateTime MinOfferStartDate {
            get {
                return this.minOfferStartDateField;
            }
            set {
                this.minOfferStartDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime MaxOfferStartDate {
            get {
                return this.maxOfferStartDateField;
            }
            set {
                this.maxOfferStartDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime MinOfferEndDate {
            get {
                return this.minOfferEndDateField;
            }
            set {
                this.minOfferEndDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime MaxOfferEndDate {
            get {
                return this.maxOfferEndDateField;
            }
            set {
                this.maxOfferEndDateField = value;
            }
        }
        
        /// <remarks/>
        public int ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public int VideoDefinition {
            get {
                return this.videoDefinitionField;
            }
            set {
                this.videoDefinitionField = value;
            }
        }
        
        /// <remarks/>
        public int VideoVisibilityStatusId {
            get {
                return this.videoVisibilityStatusIdField;
            }
            set {
                this.videoVisibilityStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public int OfferVisibilityStatusId {
            get {
                return this.offerVisibilityStatusIdField;
            }
            set {
                this.offerVisibilityStatusIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class PodcastSearchRequest : Request {
        
        private System.Nullable<System.Guid> mediaIdField;
        
        private string mediaTitleField;
        
        private string podcastUrlField;
        
        private int[] subcategoryIdsField;
        
        private System.Nullable<System.DateTime> submittedAfterField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        public string PodcastUrl {
            get {
                return this.podcastUrlField;
            }
            set {
                this.podcastUrlField = value;
            }
        }
        
        /// <remarks/>
        public int[] SubcategoryIds {
            get {
                return this.subcategoryIdsField;
            }
            set {
                this.subcategoryIdsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> SubmittedAfter {
            get {
                return this.submittedAfterField;
            }
            set {
                this.submittedAfterField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DRMTaskSearchRequest))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class TaskSearchRequest : Request {
        
        private System.Nullable<int> taskStatusIdField;
        
        private string inputLocationField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> TaskStatusId {
            get {
                return this.taskStatusIdField;
            }
            set {
                this.taskStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public string InputLocation {
            get {
                return this.inputLocationField;
            }
            set {
                this.inputLocationField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class DRMTaskSearchRequest : TaskSearchRequest {
        
        private string mediaTitleField;
        
        private System.Nullable<int> mediaTypeField;
        
        private System.Nullable<System.Guid> mediaInstanceIdField;
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaType {
            get {
                return this.mediaTypeField;
            }
            set {
                this.mediaTypeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaInstanceId {
            get {
                return this.mediaInstanceIdField;
            }
            set {
                this.mediaInstanceIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameOfferSearchRequest : Request {
        
        private string titleField;
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GameTitleSearchRequest : Request {
        
        private string titleField;
        
        private int lcidField;
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public int Lcid {
            get {
                return this.lcidField;
            }
            set {
                this.lcidField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class GamePublisherSearchRequest : Request {
        
        private string publisherIdField;
        
        /// <remarks/>
        public string PublisherId {
            get {
                return this.publisherIdField;
            }
            set {
                this.publisherIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ImageSearchRequest : Request {
        
        private int[] dimensionsField;
        
        private System.Nullable<System.Guid> mediaIdField;
        
        private string titleField;
        
        private int[] localeField;
        
        /// <remarks/>
        public int[] Dimensions {
            get {
                return this.dimensionsField;
            }
            set {
                this.dimensionsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        public int[] Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class ContributorRequest : Request {
        
        private string nameField;
        
        private System.Guid contributorIdField;
        
        private System.Guid relatedContributorIdField;
        
        private System.Guid mediaIdField;
        
        private int isGroupField;
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ContributorId {
            get {
                return this.contributorIdField;
            }
            set {
                this.contributorIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid RelatedContributorId {
            get {
                return this.relatedContributorIdField;
            }
            set {
                this.relatedContributorIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public int IsGroup {
            get {
                return this.isGroupField;
            }
            set {
                this.isGroupField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class OfferSearchRequest : Request {
        
        private System.Nullable<int> mediaTypeIdField;
        
        private System.Nullable<System.Guid> mediaIdField;
        
        private string mediaTitleField;
        
        private System.Nullable<int> mediaStatusIdField;
        
        private System.Nullable<int> providerIdField;
        
        private string offerNameField;
        
        private bool includeExpiredField;
        
        private System.Nullable<System.DateTime> startDateField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaStatusId {
            get {
                return this.mediaStatusIdField;
            }
            set {
                this.mediaStatusIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> ProviderId {
            get {
                return this.providerIdField;
            }
            set {
                this.providerIdField = value;
            }
        }
        
        /// <remarks/>
        public string OfferName {
            get {
                return this.offerNameField;
            }
            set {
                this.offerNameField = value;
            }
        }
        
        /// <remarks/>
        public bool IncludeExpired {
            get {
                return this.includeExpiredField;
            }
            set {
                this.includeExpiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSearchRequest : Request {
        
        private System.Nullable<int> metadataProviderIdField;
        
        private System.Nullable<int> mediaStatusIdField;
        
        private System.Nullable<int> mediaTypeIdField;
        
        private System.Nullable<System.Guid> mediaIdField;
        
        private string mediaTitleField;
        
        private System.Nullable<System.DateTime> availableFromDateField;
        
        private System.Nullable<System.DateTime> availableToDateField;
        
        private int[] categoryIdsField;
        
        private string productionIdField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MetadataProviderId {
            get {
                return this.metadataProviderIdField;
            }
            set {
                this.metadataProviderIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaStatusId {
            get {
                return this.mediaStatusIdField;
            }
            set {
                this.mediaStatusIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableFromDate {
            get {
                return this.availableFromDateField;
            }
            set {
                this.availableFromDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableToDate {
            get {
                return this.availableToDateField;
            }
            set {
                this.availableToDateField = value;
            }
        }
        
        /// <remarks/>
        public int[] CategoryIds {
            get {
                return this.categoryIdsField;
            }
            set {
                this.categoryIdsField = value;
            }
        }
        
        /// <remarks/>
        public string ProductionId {
            get {
                return this.productionIdField;
            }
            set {
                this.productionIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSeasonSearchRequest : Request {
        
        private string sortDescField;
        
        private System.Nullable<int> metadataProviderIdField;
        
        private System.Nullable<int> mediaStatusIdField;
        
        private System.Nullable<int> mediaTypeIdField;
        
        private System.Nullable<System.Guid> mediaIdField;
        
        private string mediaTitleField;
        
        private System.Nullable<System.DateTime> availableFromDateField;
        
        private System.Nullable<System.DateTime> availableToDateField;
        
        private System.Nullable<int> seasonNumberField;
        
        /// <remarks/>
        public string SortDesc {
            get {
                return this.sortDescField;
            }
            set {
                this.sortDescField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MetadataProviderId {
            get {
                return this.metadataProviderIdField;
            }
            set {
                this.metadataProviderIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaStatusId {
            get {
                return this.mediaStatusIdField;
            }
            set {
                this.mediaStatusIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableFromDate {
            get {
                return this.availableFromDateField;
            }
            set {
                this.availableFromDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableToDate {
            get {
                return this.availableToDateField;
            }
            set {
                this.availableToDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> SeasonNumber {
            get {
                return this.seasonNumberField;
            }
            set {
                this.seasonNumberField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.microsoft.com/ems/CatalogWebService/")]
    public partial class VideoSeriesSearchRequest : Request {
        
        private System.Nullable<int> metadataProviderIdField;
        
        private System.Nullable<int> mediaStatusIdField;
        
        private System.Nullable<int> mediaTypeIdField;
        
        private System.Nullable<System.Guid> mediaIdField;
        
        private string mediaTitleField;
        
        private System.Nullable<System.DateTime> availableFromDateField;
        
        private System.Nullable<System.DateTime> availableToDateField;
        
        private int[] categoryIdsField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MetadataProviderId {
            get {
                return this.metadataProviderIdField;
            }
            set {
                this.metadataProviderIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaStatusId {
            get {
                return this.mediaStatusIdField;
            }
            set {
                this.mediaStatusIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> MediaTypeId {
            get {
                return this.mediaTypeIdField;
            }
            set {
                this.mediaTypeIdField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.Guid> MediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public string MediaTitle {
            get {
                return this.mediaTitleField;
            }
            set {
                this.mediaTitleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableFromDate {
            get {
                return this.availableFromDateField;
            }
            set {
                this.availableFromDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<System.DateTime> AvailableToDate {
            get {
                return this.availableToDateField;
            }
            set {
                this.availableToDateField = value;
            }
        }
        
        /// <remarks/>
        public int[] CategoryIds {
            get {
                return this.categoryIdsField;
            }
            set {
                this.categoryIdsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PingCompletedEventHandler(object sender, PingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SearchCompletedEventHandler(object sender, SearchCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SearchCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SearchCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Response[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Response[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCatalogIdCompletedEventHandler(object sender, GetCatalogIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCatalogIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCatalogIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetExternalIdCompletedEventHandler(object sender, GetExternalIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetExternalIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetExternalIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetEntityCompletedEventHandler(object sender, GetEntityCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetEntityCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetEntityCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Entity Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Entity)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetEntity1CompletedEventHandler(object sender, GetEntity1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetEntity1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetEntity1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Entity[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Entity[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableEntityIdCompletedEventHandler(object sender, GetAvailableEntityIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableEntityIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableEntityIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableCategoryIdCompletedEventHandler(object sender, GetAvailableCategoryIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableCategoryIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableCategoryIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableCategorySystemIdCompletedEventHandler(object sender, GetAvailableCategorySystemIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableCategorySystemIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableCategorySystemIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableRatingSystemIdCompletedEventHandler(object sender, GetAvailableRatingSystemIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableRatingSystemIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableRatingSystemIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableRatingValueIdCompletedEventHandler(object sender, GetAvailableRatingValueIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableRatingValueIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableRatingValueIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableRatingDescriptorIdCompletedEventHandler(object sender, GetAvailableRatingDescriptorIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableRatingDescriptorIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableRatingDescriptorIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableLicenseTypeIdCompletedEventHandler(object sender, GetAvailableLicenseTypeIdCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableLicenseTypeIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableLicenseTypeIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetExternalFeedSourceCompletedEventHandler(object sender, GetExternalFeedSourceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetExternalFeedSourceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetExternalFeedSourceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ExternalFeedSource Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ExternalFeedSource)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetExternalFeedSource1CompletedEventHandler(object sender, GetExternalFeedSource1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetExternalFeedSource1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetExternalFeedSource1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ExternalFeedSource[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ExternalFeedSource[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetExternalFeedMappingObjectCompletedEventHandler(object sender, GetExternalFeedMappingObjectCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetExternalFeedMappingObjectCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetExternalFeedMappingObjectCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ExternalFeedMappingObject Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ExternalFeedMappingObject)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetExternalFeedMappingObject1CompletedEventHandler(object sender, GetExternalFeedMappingObject1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetExternalFeedMappingObject1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetExternalFeedMappingObject1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ExternalFeedMappingObject[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ExternalFeedMappingObject[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveExternalFeedMappingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveEntityCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetImageCompletedEventHandler(object sender, GetImageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetImageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetImageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Image Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Image)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveImageCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SavePublishingBatchRequestCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetOfferCompletedEventHandler(object sender, GetOfferCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetOfferCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetOfferCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Offer Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Offer)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMediaOfferCompletedEventHandler(object sender, GetMediaOfferCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMediaOfferCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMediaOfferCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MediaOffer Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MediaOffer)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPodcastCompletedEventHandler(object sender, GetPodcastCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPodcastCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPodcastCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Podcast Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Podcast)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPodcast1CompletedEventHandler(object sender, GetPodcast1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPodcast1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPodcast1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Podcast Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Podcast)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SavePodcastCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVideoCompletedEventHandler(object sender, GetVideoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVideoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVideoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Video Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Video)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveVideoCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVideoSeasonCompletedEventHandler(object sender, GetVideoSeasonCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVideoSeasonCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVideoSeasonCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VideoSeason Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VideoSeason)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveVideoSeasonCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVideoSeriesCompletedEventHandler(object sender, GetVideoSeriesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVideoSeriesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVideoSeriesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VideoSeries Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VideoSeries)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveVideoSeriesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetContributorRelationshipTypeCompletedEventHandler(object sender, GetContributorRelationshipTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetContributorRelationshipTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetContributorRelationshipTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ContributorRelationshipType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ContributorRelationshipType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCountryCompletedEventHandler(object sender, GetCountryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCountryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCountryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Country Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Country)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCountry1CompletedEventHandler(object sender, GetCountry1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCountry1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCountry1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Country[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Country[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCurrencyCompletedEventHandler(object sender, GetCurrencyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCurrencyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCurrencyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Currency Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Currency)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCurrency1CompletedEventHandler(object sender, GetCurrency1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCurrency1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCurrency1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Currency[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Currency[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCategorySystemCompletedEventHandler(object sender, GetCategorySystemCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCategorySystemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCategorySystemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CategorySystem Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CategorySystem)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCategorySystem1CompletedEventHandler(object sender, GetCategorySystem1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCategorySystem1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCategorySystem1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CategorySystem[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CategorySystem[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveCategoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingSystemCompletedEventHandler(object sender, GetRatingSystemCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingSystemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingSystemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public RatingSystem Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RatingSystem)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingSystem1CompletedEventHandler(object sender, GetRatingSystem1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingSystem1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingSystem1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public RatingSystem[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RatingSystem[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetArticleCompletedEventHandler(object sender, GetArticleCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetArticleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetArticleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Article Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Article)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetArticle1CompletedEventHandler(object sender, GetArticle1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetArticle1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetArticle1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Article[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Article[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetContributorCompletedEventHandler(object sender, GetContributorCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetContributorCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetContributorCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Contributor Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Contributor)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetContributor1CompletedEventHandler(object sender, GetContributor1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetContributor1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetContributor1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Contributor[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Contributor[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveVideoEncodingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveAudioEncodingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveContributorCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAudioEncodingCompletedEventHandler(object sender, GetAudioEncodingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAudioEncodingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAudioEncodingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AudioEncoding[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AudioEncoding[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetClientTypeCompletedEventHandler(object sender, GetClientTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetClientTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetClientTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ClientType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ClientType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLocaleCompletedEventHandler(object sender, GetLocaleCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLocaleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLocaleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Locale[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Locale[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetImageFormatCompletedEventHandler(object sender, GetImageFormatCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetImageFormatCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetImageFormatCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ImageFormat[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ImageFormat[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetImageSizeCompletedEventHandler(object sender, GetImageSizeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetImageSizeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetImageSizeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ImageSize[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ImageSize[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMediaRelationshipTypeCompletedEventHandler(object sender, GetMediaRelationshipTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMediaRelationshipTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMediaRelationshipTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MediaRelationshipType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MediaRelationshipType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPreviewMediaInstanceTypeCompletedEventHandler(object sender, GetPreviewMediaInstanceTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPreviewMediaInstanceTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPreviewMediaInstanceTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PreviewMediaInstanceType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PreviewMediaInstanceType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRoleCompletedEventHandler(object sender, GetRoleCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRoleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRoleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Role[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Role[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetStoreCompletedEventHandler(object sender, GetStoreCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStoreCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetStoreCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Store[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Store[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTaskStatusCompletedEventHandler(object sender, GetTaskStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTaskStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTaskStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public TaskStatus[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TaskStatus[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTasksByStatusCompletedEventHandler(object sender, GetTasksByStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTasksByStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTasksByStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Task[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Task[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTasksCompletedEventHandler(object sender, GetTasksCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTasksCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTasksCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Task[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Task[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAvailableTaskAsXMLCompletedEventHandler(object sender, GetAvailableTaskAsXMLCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAvailableTaskAsXMLCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAvailableTaskAsXMLCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurgeTaskQueueCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveTaskCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveDRMTaskCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveTask1CompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserTypeCompletedEventHandler(object sender, GetUserTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVideoDefinitionCompletedEventHandler(object sender, GetVideoDefinitionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVideoDefinitionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVideoDefinitionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VideoDefinition[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VideoDefinition[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVideoEncodingCompletedEventHandler(object sender, GetVideoEncodingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVideoEncodingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVideoEncodingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VideoEncoding[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VideoEncoding[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVisibilityLevelCompletedEventHandler(object sender, GetVisibilityLevelCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVisibilityLevelCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVisibilityLevelCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VisibilityLevel[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VisibilityLevel[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetVisibilityStatusCompletedEventHandler(object sender, GetVisibilityStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetVisibilityStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetVisibilityStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VisibilityStatus[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VisibilityStatus[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetProviderCompletedEventHandler(object sender, GetProviderCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetProviderCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetProviderCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Provider Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Provider)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetProvider1CompletedEventHandler(object sender, GetProvider1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetProvider1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetProvider1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Provider[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Provider[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMetadataProviderCompletedEventHandler(object sender, GetMetadataProviderCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMetadataProviderCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMetadataProviderCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MetadataProvider Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MetadataProvider)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMetadataProvider1CompletedEventHandler(object sender, GetMetadataProvider1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMetadataProvider1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMetadataProvider1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MetadataProvider[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MetadataProvider[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDRMLicenseIssuerCompletedEventHandler(object sender, GetDRMLicenseIssuerCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDRMLicenseIssuerCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetDRMLicenseIssuerCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DRMLicenseIssuer Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DRMLicenseIssuer)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDRMLicenseIssuer1CompletedEventHandler(object sender, GetDRMLicenseIssuer1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDRMLicenseIssuer1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetDRMLicenseIssuer1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public DRMLicenseIssuer[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DRMLicenseIssuer[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLicenseTypeCompletedEventHandler(object sender, GetLicenseTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLicenseTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLicenseTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LicenseType Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseType)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLicenseType1CompletedEventHandler(object sender, GetLicenseType1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLicenseType1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLicenseType1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LicenseType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveLicenseTypeCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLicenseClassCompletedEventHandler(object sender, GetLicenseClassCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLicenseClassCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLicenseClassCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LicenseClass Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseClass)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLicenseClass1CompletedEventHandler(object sender, GetLicenseClass1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLicenseClass1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLicenseClass1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public LicenseClass[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseClass[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPricingRuleCompletedEventHandler(object sender, GetPricingRuleCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPricingRuleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPricingRuleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PricingRule Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PricingRule)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPricingRule1CompletedEventHandler(object sender, GetPricingRule1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPricingRule1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPricingRule1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PricingRule[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PricingRule[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SavePricingRuleCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMediaTypeCompletedEventHandler(object sender, GetMediaTypeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMediaTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMediaTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MediaType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MediaType[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveGameCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetGameCompletedEventHandler(object sender, GetGameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetGameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetGameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Game Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Game)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveGameContentCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetGameContentCompletedEventHandler(object sender, GetGameContentCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetGameContentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetGameContentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GameContent Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GameContent)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentMethodCompletedEventHandler(object sender, GetPaymentMethodCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentMethodCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPaymentMethodCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PaymentType Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PaymentType)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentMethod1CompletedEventHandler(object sender, GetPaymentMethod1CompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentMethod1CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPaymentMethod1CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PaymentType[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PaymentType[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\postbuild\makefile.inc ===
#
# Package Cloud Services Files
#

LEET_DEPLOY=$(_NTTREE)\Deploy
CLOUD_SERVICE_DESTINATION=$(_NTTREE)\Deploy-CloudServices

PackageCloudServices:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\Documentation\TestSource\Common\Library\makefile.inc ===
$(OBJ_PATH)\$(O)\$(HELPFILENAME).chm:
   set OBJ_PATH=$(OBJ_PATH)
   @echo BUILDMSG: Generating $@
   sandcastlebuilder.cmd $(HELPFILENAME).shfb -outputpath=$(OBJ_PATH)\$(O) -HtmlHelpName=$(HELPFILENAME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\ReplaceXml\ReplaceXml\ReplaceXml.cs ===
﻿namespace ReplaceXml
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml;
    using System.Xml.XPath;

    public class ReplaceXml
    {

        internal class FileSet
        {
            public bool CaseSensitive = false;     // set as default
            public bool ErrorOnUnusedKeys = false;   // set as default
            public string FileType = "text";        // set as default
            public bool UseRegEx = false;           // set as default

            public string InputFileName = string.Empty;
            public string OutputFileName = string.Empty;
            public List<string> Parameters;
            private Dictionary<string, int> UsedValuesCounter;

            public FileSet()
            {
                Parameters = new List<string>();
                UsedValuesCounter = new Dictionary<string, int>();
            }
        }

        private static List<FileSet> FileSets = new List<FileSet>();

        // Main function
        [STAThread]
        public static int Main(string[] args)
        {
            int ReturnNumber = ParseInputParameters(args);

            //Validate each file:
            int ValidateReturn;
            for (int i = 0; i < FileSets.Count; i++)
            {
                ValidateReturn = Validate_GlobalSettings(i);
                if (0 == ReturnNumber)
                {
                    ReturnNumber = ValidateReturn;
                }
            }

            if (0 == ReturnNumber)
            {
                int ReplaceReturn = 0;
                for (int k = 0; k < FileSets.Count; k++)
                {
                    Console.WriteLine("Processing File '{0}' --> '{1}'", FileSets[k].InputFileName, FileSets[k].OutputFileName);
                    Console.WriteLine("  FileType is '{0}'", FileSets[k].FileType);
                    switch (FileSets[k].FileType)
                    {
                        case "text":
                            ReplaceReturn = ReplaceFileContents_Text(k);
                            break;
                        case "xml":
                            ReplaceReturn = ReplaceFileContents_XML(k);
                            break;
                        default:
                            Console.WriteLine("Developer error, FileType is defined as '{0}'", FileSets[k].FileType);
                            ReplaceReturn = 1334;
                            break;
                    }
                    if (ReturnNumber == 0)
                    {
                        ReturnNumber = ReplaceReturn;
                    }
                }
            }
            return ReturnNumber;
        }

        // other functions
        private static int ParseInputParameters(string[] args)
        {
            int FileIndex;
            bool FileType_Set, Case_Set, Unused_Set, Expression_Set;

            //initialize local vars.
            CreateNewFileSet(out FileIndex);
            FileType_Set = false;
            Case_Set = false;
            Unused_Set = false;
            Expression_Set = false;

            Console.WriteLine("New File Set");
            foreach (string s in args)
            {
                if ("ReplaceXml.exe" == s)
                {
                    continue;
                }
                switch (s.ToLower())
                {
                    case "/?":
                    case "-?":
                    case "/help":
                    case "-help":
                        DisplayUsage_Pendandic();
                        return 1;
                    case "/xml":
                    case "-xml":
                        if (FileType_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of /xml or /Text");
                            return 4;
                        }
                        FileType_Set = true;
                        FileSets[FileIndex].FileType = "xml";
                        FileSets[FileIndex].CaseSensitive = true;
                        break;
                    case "/text":
                    case "-text":
                        if (FileType_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of /xml or /Text");
                            return 4;
                        }
                        FileType_Set = true;
                        FileSets[FileIndex].FileType = "text";
                        break;
                    case "/sensitive":
                    case "-sensitive":
                        if (Case_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of -Sensitive or -Insensitive");
                            return 4;
                        }
                        Case_Set = true;
                        FileSets[FileIndex].CaseSensitive = true;
                        break;
                    case "/insensitive":
                    case "-insensitive":
                        if (Case_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of -Sensitive or -Insensitive");
                            return 4;
                        }
                        Case_Set = true;
                        FileSets[FileIndex].CaseSensitive = false;
                        break;
                    case "/strict":
                    case "-strict":
                        if (Unused_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of -Ignore or -Strict");
                            return 4;
                        }
                        Unused_Set = true;
                        FileSets[FileIndex].ErrorOnUnusedKeys = true;
                        break;
                    case "/ignore":
                    case "-ignore":
                        if (Unused_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of -Ignore or -Strict");
                            return 4;
                        }
                        Unused_Set = true;
                        FileSets[FileIndex].ErrorOnUnusedKeys = false;
                        break;
                    case "/regex":
                    case "-regex":
                        if (Expression_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of -Stdex or -Regex");
                            return 4;
                        }
                        Expression_Set = true;
                        FileSets[FileIndex].UseRegEx = true;
                        break;
                    case "/stdex":
                    case "-stdex":
                        if (Expression_Set)
                        {
                            DisplayUsage("Parsing error: You can have only one of -Stdex or -Regex");
                            return 4;
                        }
                        Expression_Set = true;
                        FileSets[FileIndex].UseRegEx = false;
                        break;
                    case "/nextfile":
                    case "-nextfile":
                        Console.WriteLine("New File Set");
                        CreateNewFileSet(out FileIndex);
                        FileType_Set = false;
                        Case_Set = false;
                        Unused_Set = false;
                        Expression_Set = false;
                        break;
                    default:
                        // File Names
                        if (string.Empty == FileSets[FileIndex].InputFileName)
                        {
                            FileSets[FileIndex].InputFileName = s;
                            Console.WriteLine(" InputFile: '{0}'", s);
                        }
                        else
                        {
                            if (string.Empty == FileSets[FileIndex].OutputFileName)
                            {
                                FileSets[FileIndex].OutputFileName = s;
                                Console.WriteLine(" OutputFile: '{0}'", s);
                            }
                            else
                            {
                                string TempString = s.Trim();
                                if (string.Empty != TempString)
                                {
                                    // Input strings that are not switches
                                    Console.WriteLine("  Parameter: '{0}'", TempString);
                                    FileSets[FileIndex].Parameters.Add(TempString);
                                }
                            }
                        }
                        break;
                } // switch (s.ToLower())
            } // foreach (string s in args)
            return 0;
        }

        private static void CreateNewFileSet(out int NewIndex)
        {
            FileSets.Add(new FileSet());
            NewIndex = FileSets.Count - 1;
            System.Diagnostics.Debug.Assert(0 <= NewIndex, "Failed to index correctly for FileSet Entry");
            return;
        }

        private static int Validate_GlobalSettings(int CurrentIndex)
        {
            FileSet fs = FileSets[CurrentIndex];

            Console.WriteLine("Validate FileSet... ");
            if (string.Empty == fs.InputFileName)
            {
                DisplayUsage("Error: Input file name is not provided.");
                return 1;
            }

            if (string.Empty == fs.OutputFileName)
            {
                DisplayUsage("Error: Output file name is not provided.");
                return 2;
            }

            switch (fs.FileType)
            {
                case "xml":
                    if (!fs.CaseSensitive)
                    {
                        DisplayUsage("Error: You cannot have '/Insensitive' and '/Xml' in the same command line.");
                        return 2;
                    }

                    if (fs.UseRegEx)
                    {
                        DisplayUsage("Error: You cannot have '/Regex' and '/Xml' in the same command line.");
                        return 2;
                    }
                    break;
                case "text":
                   
                    if ((fs.Parameters.Count % 2) != 0)
                    {
                        DisplayUsage("Error: You cannot have an odd number of input string for a Text replacement file.");
                        return 3;
                    }
                    else
                    {
                        int c = fs.Parameters.Count;
                        HashSet<string> FirstValues = new HashSet<string>();
                        bool DuplicateFound = false;
                        StringBuilder sb = new StringBuilder("Error: Duplicate string are not allowed for replacement values.\n");
                        for (int i = 0; i < c - 1; i += 2)
                        {
                            string value = fs.Parameters[i];
                            if (FirstValues.Contains(value))
                            {
                                DuplicateFound = true;
                                sb.AppendFormat("   Duplicate string found: '{0}'\n", value);
                            }
                            else
                            {
                                FirstValues.Add(value);
                            }
                        }
                        if (DuplicateFound)
                        {
                            DisplayUsage(sb.ToString());
                            return 7;
                        }
                    }
                    break;
                case "default":
                    Console.WriteLine("Error: Non standard file type specified.  Programmer error.");
                    return 5;
            }

            try
            {
                FileInfo FI = new FileInfo(fs.InputFileName);
                if (!FI.Exists)
                {
                    DisplayUsage(string.Format("Error: Input file of '{0}' does not exist", fs.InputFileName));
                    return 4;
                }

                FileInfo FO = new FileInfo(fs.OutputFileName);
                if (FO.Exists)
                {
                    if (FO.IsReadOnly)
                    {
                        DisplayUsage(string.Format("Error: Output file of '{0}' already exists and is marked read only", fs.OutputFileName));
                        return 6;
                    }
                }
            }
            catch (Exception e)
            {
                System.Console.WriteLine(e.ToString());
                if (e.InnerException != null)
                {
                    System.Console.WriteLine(e.InnerException.ToString());
                }
                return 9;
            }

            return 0;
        }

        private static int ReplaceFileContents_Text(int CurrentIndex)
        {
            Dictionary<string, int> UsedValuesCounter = new Dictionary<string, int>();
            Dictionary<string, string> ReplacementPairs = new Dictionary<string, string>();

            int c = FileSets[CurrentIndex].Parameters.Count;
            System.Diagnostics.Debug.Assert(c % 2 == 0, string.Format("The Count of string is not an even number: Count={0}", c));
            for (int i = 0; i < c - 1; i += 2)
            {
                ReplacementPairs.Add(FileSets[CurrentIndex].Parameters[i], FileSets[CurrentIndex].Parameters[i + 1]);
            }

            foreach (string s in ReplacementPairs.Keys)
            {
                Console.WriteLine("   '{0}'  -->  '{1}'", s, ReplacementPairs[s]);
                UsedValuesCounter.Add(s, 0);
            }

            if (FileSets[CurrentIndex].UseRegEx)
            {
                Console.WriteLine("  using Regex text replacement.");
            }
            else
            {
                Console.WriteLine("  using STD text replacement.");
            }

            try
            {
                List<string> StringList = new List<string>();

                // Open input file, read in line by line, and then save it modified.
                using (TextReader tr = File.OpenText(FileSets[CurrentIndex].InputFileName))
                {
                    string LineRead;
                    while (null != (LineRead = tr.ReadLine()))
                    {
                        if (ReplacementPairs.Count < 1)
                        {
                            StringList.Add(LineRead);
                        }
                        else
                        {
                            if (FileSets[CurrentIndex].UseRegEx)
                            {
                                foreach (string s in ReplacementPairs.Keys)
                                {
                                    string ReplacedString;
                                    Regex MyRegex = new Regex(s);
                                    ReplacedString = MyRegex.Replace(LineRead, ReplacementPairs[s]);

                                    if (LineRead != ReplacedString)
                                    {
                                        UsedValuesCounter[s] += 1;
                                        LineRead = ReplacedString;
                                    }
                                }
                                StringList.Add(LineRead);
                            }
                            else //(FileSets[CurrentIndex].UseRegEx)==False  //STX
                            {
                                if (FileSets[CurrentIndex].CaseSensitive)
                                {
                                    // Case sensitive search/replace

                                    foreach (string s in ReplacementPairs.Keys)
                                    {
                                        //stdex
                                        string ReplacedString;
                                        ReplacedString = LineRead.Replace(s, ReplacementPairs[s]);

                                        if (LineRead != ReplacedString)
                                        {
                                            UsedValuesCounter[s] += 1;
                                            LineRead = ReplacedString;
                                        }
                                    } 
                                    StringList.Add(LineRead);
                                } // if (FileSets[CurrentIndex].CaseSensitive)
                                else
                                { // (FileSets[CurrentIndex].CaseSensitive)==false
                                    foreach (string s in ReplacementPairs.Keys)
                                    {
                                        string ReplacedString = Helper_CaseInsensitiveReplacement(LineRead, s, ReplacementPairs[s]);

                                        if (LineRead != ReplacedString)
                                        {
                                            UsedValuesCounter[s] += 1;
                                            LineRead = ReplacedString;
                                        }
                                    }
                                    StringList.Add(LineRead);
                                }
                            } //else case of (FileSets[CurrentIndex].UseRegEx)==False    -->STX
                        } //else case of if (ReplacementPairs.Count < 1)
                    } //while (null != (LineRead = tr.ReadLine()))
                } //using (TextReader tr = File.OpenText(FileSets[CurrentIndex].InputFileName))

                // Write out to file, doing it this way allows us to replace the same file.
                using (TextWriter tw = File.CreateText(FileSets[CurrentIndex].OutputFileName))
                {
                    foreach (string s in StringList)
                    {
                        tw.WriteLine(s);
                    }
                }
            }
            catch (Exception e)
            {
                System.Console.WriteLine(e.ToString());
                if (e.InnerException != null)
                {
                    System.Console.WriteLine(e.InnerException.ToString());
                }
                return 12;
            }

            // Check for unused keys.
            {
                if (FileSets[CurrentIndex].ErrorOnUnusedKeys)
                {
                    bool FoundUnusedKey = false;
                    foreach (string m in UsedValuesCounter.Keys)
                    {
                        if (0 == UsedValuesCounter[m])
                        {
                            if (!FoundUnusedKey)
                            {
                                Console.WriteLine("Error: The following replacement values were never used:");
                            }
                            FoundUnusedKey = true;
                            Console.WriteLine("        '{0}'", m);
                        }
                    }

                    if (FoundUnusedKey)
                    {
                        return 14;
                    }
                }
            }
            return 0;
        }

        private static int ReplaceFileContents_XML(int CurrentIndex)
        {
            List<string> NotUsedValues = new List<string>();

            try
            {
                // Open XML file, read it entirely into memory.
                XmlDocument document = new XmlDocument();
                document.Load(FileSets[CurrentIndex].InputFileName);
                XPathNavigator navigator = document.CreateNavigator();

                XmlNamespaceManager manager = new XmlNamespaceManager(navigator.NameTable);

                // Apply each change from the dictionary to the entire document.
                bool KeyUsed = false;

                for (int i = 0; i < FileSets[CurrentIndex].Parameters.Count; i += 2)
                {
                    string s = FileSets[CurrentIndex].Parameters[i];
                    KeyUsed = false;
                    // it is possible that the same xpath can be applied more than once time in a given document.
                    foreach (XPathNavigator nav in navigator.Select(s, manager))
                    {
                        if (i + 1 < FileSets[CurrentIndex].Parameters.Count)
                        {
                            nav.SetValue(FileSets[CurrentIndex].Parameters[i + 1]);
                            KeyUsed = true;
                        }
                    }
                    if (!KeyUsed)
                    {
                        NotUsedValues.Add(s);
                    }
                }

                // Write out to file, doing it this way allows us to replace the same file.
                using (TextWriter tw = File.CreateText(FileSets[CurrentIndex].OutputFileName))
                {
                    XmlTextWriter xw = new XmlTextWriter(tw);
                    xw.Formatting = Formatting.Indented;
                    document.WriteTo(xw);
                    xw.Flush();
                }

                if (FileSets[CurrentIndex].ErrorOnUnusedKeys & (NotUsedValues.Count > 0))
                {
                    Console.WriteLine("Error: The following replacement values were never used:");
                    foreach (string s in NotUsedValues)
                    {
                        Console.WriteLine("        '{0}'", s);
                    }
                    return 13;
                }
            }
            catch (XmlException)
            {
                Console.WriteLine("Error: open input file '{0}' as an XML file.", FileSets[CurrentIndex].InputFileName);
                return 12;
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                if (e.InnerException != null)
                {
                    System.Console.WriteLine(e.InnerException.ToString());
                }
                return 12;
            }
            return 0;
        }

        private static string Helper_CaseInsensitiveReplacement(string original, string pattern, string replacement)
        {
            int count = 0;
            int Pos_0 = 0;
            int Pos_1 = 0;
            string Original_NoCase = original.ToLower();
            string Pattern_NoCase = pattern.ToLower();
            Debug.Assert(original.Length == Original_NoCase.Length, "Length of original.ToLower() is not the same as original");
            Debug.Assert(pattern.Length == Pattern_NoCase.Length, "Length of pattern.ToLower() is not the same as Pattern");

            int WindowSize = (original.Length / pattern.Length) * (replacement.Length - pattern.Length);
            char[] chars = new char[original.Length + Math.Max(0, WindowSize)];

            while ((Pos_1 = Original_NoCase.IndexOf(Pattern_NoCase, Pos_0)) != -1)
            {
                for (int i = Pos_0; i < Pos_1; ++i)
                {
                    chars[count++] = original[i];
                }
                for (int i = 0; i < replacement.Length; ++i)
                {
                    chars[count++] = replacement[i];
                }
                Pos_0 = Pos_1 + pattern.Length;
            }
            if (Pos_0 == 0)
            {
                return original;
            }
            for (int i = Pos_0; i < original.Length; ++i)
            {
                chars[count++] = original[i];
            }
            return new string(chars, 0, count);
        }

        private static void DisplayUsage(string MessageString)
        {
            Console.WriteLine(MessageString);
            DisplayUsage();
            Console.WriteLine(MessageString);
        }

        private static void DisplayUsage_Pendandic()
        {
            DisplayUsage();
            Console.WriteLine(
@"
  Switches: 
   /? or -? /Help or -Help  - displays this message of help.

   /Text - use standard search and replace for replacement logic. (default)
   /Xml  - use xpath query into an XML file for replacement logic.
 
   /Ignore - no error when a replacement pair is not used. (default)
   /strict - throws an error when a replacement pair is not used.

  Note The following switches can only used with /text switch
   /Insensitive - does case insensitive replacements. (default)
   /Sensitive   - does case sensitive replacements.

   /RegEx   - the find strings are regular expressions.
   /StdEx   - the find strings are not regular expressions. (default)

   /NextFile - Allows you to specify more than one file per run.  
            All settings are to default for each new file.
      

Examples:   
 ReplaceXml InputFile OutpuFile
 ReplaceXml /text /insensitive /ignore InputFile OutpuFile  (shown with all defaults switches)
  - Just copy file as text

 ReplaceXml /text InputFile OutpuFile [Value1 Value2]+ 
 ReplaceXml /text /insensitive InputFile OutpuFile [Value1 Value2]+ 
  - replace text as case insensitive with Value1 replaced with Value2.

 ReplaceXml /text /sensitive InputFile OutpuFile Value1 Value2
  - case sensistive replacement with VALUE1 replaced with VALUE2.

 ReplaceXml /regex In.xml Out.xml ""[ab].*ing"" ""xxxx""
  - any word containing 'a' or 'b', and followed by 'ing'  will be replaced.
     Thus aiming and bing will be replaced, but not coding or dante.

 ReplaceXml /regex In.xml Out.xml ""add key=\""environment\"" value=\"".*\"""" ""add key=\""environment\"" value=\""TestNet\"" ""
  - do a regular expression replacement with all values matching  Note that the .* means any number of characters 
     In this example: ' <add key=""environment"" value=""storax""> '  (the value 'storax' can be anything)
           becomes:   ' <add key=""environment"" value=""TestNet""> '

 Considering the following XML file...
 Sample XML (InXML.xml):
  <Root>
    <School name=""KV"">
      <Class ID=""MTH""> Mathematics </Class>
    </School>

    <School name=""MPG"">
      <Class ID=""CHM""> Chemistry</Class>
    </School>

    <School name=""STG"">
      <Class ID=""BIO""> Biology </Class>
    </School>
  </Root>

  1) Replace the value ""Chemistry"" of the Node ‘Class’ with attribute ID=""CHM""  to ""History"" 
  ReplaceXml.exe /xml  inxml.txt outxml.txt Root/School/Class[@ID='BIO']  History

  2) Replace the value of all the node which has the attribute ID  to ""Subject""
  ReplaceXml.exe /xml  inxml.txt outxml.txt Root/School/Class[@ID]  History
  

 ReplaceXml /xml env.xml outenv.xml ""configuration/appSettings/Active/[@key='environment']"" ""TestNet"" 
   <configuration>
     <appSettings>
        <Active>SOMEVALUE</Active>
     </appSettings>
   </configuration>
  - This Replaces SOMEVALUE with TestNet

Notes:
  Memory is limit for the number pairs you can include with any of the above.
  The input and output file can be the same file
  Files can be an external share path if needed.
  The output file must be not marked as read only.  
  Simple text replacements can also be done on XML file using /text.
  Switches are case insensitive, can be anywhere on commandline for a given file.
  You can choose to use dash or a slash (- /) symbol for switches.
  For each pair of files:
    The first non-switched parameter must be a file name.
    The second non-switched parameter must be a file name to be created.
");
        }

        private static void DisplayUsage()
        {
            Console.WriteLine(
@"ReplaceXml  -  Usage information:
This tool is used to replace text within the lines of a text or xml file.      
  Syntax:
  ReplaceXml [/text] [/Ignore | /strict] [/Insensitive | /Sensitive] [Regex | StdEx] In.File Out.File [V1 V2]*
  ReplaceXml [/xml ] In.File Out.File [ ""Xpath"" ""Replacement Value"" ]* 
  ReplaceXml /Help                  <-- Get full list of help.");
                }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Setup\ReplaceXml\ReplaceXml\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ReplaceXml")]
[assembly: AssemblyDescription("A tool to make replacements inside an XML file")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3a700a88-53ae-4745-8236-5d2a92940ac0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Common.sql\SqlCommandCache.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Specialized;

namespace Common.Sql
{
	/// <summary>
	/// <p>
	/// This class implements the Command Caching feature of the SqlWrapper class.  Command
	/// caching allows you to make SQL stored procedure calls without having to provide all
	/// of the stored procedure parameters' sizes, types and directions.  Parameter type
	/// information is retrieved and cached automatically.  This makes calling stored
	/// procedures easier, with less code, and more flexible to changes in the stored
	/// procedure later.
	/// </p>
	/// <p>
	/// Metadata about stored procedure parameters are stored internally in a hashtable.
	/// This class hooks into the PrepareSqlCommand event of the SqlWrapper class.  When the
	/// SqlWrapper fires this event, this class receives it and looks to see if it has cached
	/// datatype information about the stored procedure.  If it does, then it fills in the
	/// data type, size, direction, etc of each parameter to the stored procedure.  If it
	/// doesn't have this information yet, then it calls out to SQL Server, retrieves the
	/// stored procedure parameter type information, and caches it for subsequent uses.
	/// Only datatype information is cached, parameter values and SQL results are not
	/// stored.
	/// </p>
	/// <p>
	/// In this current implementation, the cache never expires.  For most applications this
	/// works fine because stored procedures rarely change.  If an incompatible change is
	/// made to a stored procedure then usually an error is thrown.  If a SQL error
	/// occurs when calling a stored procedure, the parameter metadata for that stored
	/// procedure is removed from the cache, forcing the next SQL call to that stored
	/// procedure to retrieve the new list of parameters.  A function is also provided to
	/// clear the cache if needed.
	/// </p>
	/// <p>
	/// This class works in conjunction with the SqlWrapper class, so there is rarely need
	/// to use this class directly.
	/// </p>
	/// </summary>
	public class SqlCommandCache
	{
		private static Hashtable m_cmdCache = Hashtable.Synchronized(CollectionsUtil.CreateCaseInsensitiveHashtable());

		/// <summary>
		/// Used to hook the SqlCommandCache to a SqlWrapper instance.
		/// </summary>
		/// <param name="sqlWrapper">The SqlWrapper to monitor</param>
		public static void RegisterSqlWrapper(SqlWrapper sqlWrapper)
		{
			sqlWrapper.PrepareSqlCommand += new SqlWrapper.PrepareSqlCommandEventHandler(sqlWrapper_PrepareSqlCommand);
			sqlWrapper.SqlException += new SqlWrapper.SqlExceptionEventHandler(sqlWrapper_SqlException);
		}

		/// <summary>
		/// Used to remove a hook between the SqlCommandCache and a SqlWrapper instance.
		/// </summary>
		/// <param name="sqlWrapper">The SqlWrapper to remove from monitoring</param>
		public static void UnregisterSqlWrapper(SqlWrapper sqlWrapper)
		{
			sqlWrapper.PrepareSqlCommand -= new SqlWrapper.PrepareSqlCommandEventHandler(sqlWrapper_PrepareSqlCommand);
			sqlWrapper.SqlException -= new SqlWrapper.SqlExceptionEventHandler(sqlWrapper_SqlException);
		}

		/// <summary>
		/// Clears all information from the cache
		/// </summary>
		public static void ClearCache()
		{
			m_cmdCache.Clear();
		}


		/// <summary>
		/// This is an event handler triggered by the SqlWrapper class.  This method
		/// intercepts stored procedure calls and implements command caching.
		/// </summary>
		/// <param name="sender">SqlWrapper object</param>
		/// <param name="args"></param>
		private static void sqlWrapper_PrepareSqlCommand(SqlWrapper sender, SqlWrapperEventArgs args)
		{
			// We can only cache and populate parameter information for stored procedures
			if (args.CommandType == CommandType.StoredProcedure)
			{
				// This is a hashtable within a hashtable.  This first-level hashtable
				// is keyed on connection string.
				Hashtable cacheTable = m_cmdCache[args.ConnectionString] as Hashtable;
				if (cacheTable == null)
				{
					cacheTable = Hashtable.Synchronized(CollectionsUtil.CreateCaseInsensitiveHashtable());
					m_cmdCache[args.ConnectionString] = cacheTable;
				}

				// The second-level hashtable is keyed on stored procedure name and
				// contains SqlCommand objects.
				// Lookup a SqlCommand object for the current stored procedure call.
				SqlCommand cachedCommand = cacheTable[args.Sql] as SqlCommand;
				if (cachedCommand == null)
				{
					bool isConnectionOpen = false;
					int retryAttempts = 0;
					bool succeeded = false;

					// Call SQL Server and fetch the list of parameters for this
					// stored procedure, then cache it in our hashtable.
					do
					{
						try
						{
							args.Command.Connection.Open();
							isConnectionOpen = true;
							SqlCommandBuilder.DeriveParameters(args.Command);
							cachedCommand = new SqlCommand();
							CopySqlParameters(args.Command, cachedCommand);
							cacheTable[args.Sql] = cachedCommand;
							succeeded = true;
						}
						catch (Exception e)
						{
							succeeded = false;
							if (!sender.HandleSqlError(e, args, retryAttempts++))
							{
								throw;
							}
						}
						finally
						{
							if (isConnectionOpen)
							{
								args.Command.Connection.Close();
								isConnectionOpen = false;
							}
						}
					} while (!succeeded);
				}
				else
				{
					// Copy parameter info from the cached command object
					CopySqlParameters(cachedCommand, args.Command);
				}
			}
		}

		/// <summary>
		/// When a SQL exception occurs this event handler checks to see if there is
		/// any cached data associated with the command and removes it, just in case
		/// the cached parameter info is out-of-date.  This will force the next call
		/// to the stored procedure to retrieve new parameter info.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="args"></param>
		private static void sqlWrapper_SqlException(SqlWrapper sender, SqlWrapperEventArgs args)
		{
			// We only cache stored procedures
			if (args.CommandType == CommandType.StoredProcedure)
			{
				// This is a hashtable within a hashtable.  This first-level hashtable
				// is keyed on connection string.
				lock (m_cmdCache.SyncRoot)
				{
					Hashtable cacheTable = m_cmdCache[args.ConnectionString] as Hashtable;
					if (cacheTable != null)
					{
						// Find the stored procedure cache and remove it
						if (cacheTable.ContainsKey(args.Sql))
							cacheTable.Remove(args.Sql);
					}
				}
			}
		}

		private static void CopySqlParameters(SqlCommand fromCommand, SqlCommand toCommand)
		{
			foreach (SqlParameter fromParam in fromCommand.Parameters)
			{
				if (toCommand.Parameters.Contains(fromParam.ParameterName))
				{
					SqlParameter toParam = toCommand.Parameters[fromParam.ParameterName];
					toParam.SqlDbType = fromParam.SqlDbType;
					toParam.Size = fromParam.Size;
					toParam.Direction = fromParam.Direction;
				}
				else
				{
					SqlParameter toParam = toCommand.Parameters.Add(fromParam.ParameterName, fromParam.SqlDbType, fromParam.Size);
					toParam.Direction = fromParam.Direction;
				}
			}
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Common.sql\AssemblyInfo.cs ===
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Common.Sql")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
#if (!RAZZLE_BUILD)
[assembly: ComVisible(false)]
#endif

//In order to begin building localizable applications, set 
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\IActiveAuthAdapter.cs ===
﻿namespace Leet.Authentication
{
    /// <summary>
    /// Interface for getting Puid and Xuid via the ActiveAuth Module
    /// </summary>
    public interface IActiveAuthAdapter
    {
        /// <summary>
        /// Gets the Puid
        /// </summary>
        ulong Puid { get; }

        /// <summary>
        /// Gets the Xuid
        /// </summary>
        ulong Xuid { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Common.sql\SqlWrapper.cs ===
using System;
using System.Data;
using System.Data.SqlClient;

namespace Common.Sql
{

	/// <summary>
	/// <p>
	/// The SqlWrapper class provides support functions for common SQL-related operations such
	/// as querying a database and calling stored procedures.
	/// </p>
	/// <p>
	/// This class also has a Command Caching feature. Command caching allows you to make SQL
	/// calls without having to provide all of the SQL parameters' sizes, types and directions.
	/// Parameter type information is retrieved and cached automatically.  This makes calling
	/// stored procedures easier, with less code, and more flexible to changes in the stored
	/// procedure later.
	/// </p>
	/// <p>
	/// This class provides event notification for each step in the SQL calling process, so you
	/// can easily add custom functionality without having to create a derived class.  If the
	/// functionality may be useful to others, you should consider adding it this library.
	/// </p>
	/// Example Code:
	/// <pre>
	///	SqlWrapper mySql = new SqlWrapper("initial catalog=Northwind;data source=localhost;integrated security=SSPI", true);
	///	SqlResult myResult = mySql.RunStoredProcQuery("CustOrderHist",
	///		new SqlParameter("@CustomerID", "BERGS"));
	///	Console.WriteLine(myResult.RowsAffected);
	///	</pre>
	/// </summary>
	public class SqlWrapper
	{
		// Private constants
		private const int SqlNetworkErrorCode = 11;		
		
		// Event delegate declarations
		public delegate void CreateSqlConnectionEventHandler(SqlWrapper sender, SqlWrapperEventArgs args);
		public delegate void CreateSqlCommandEventHandler(SqlWrapper sender, SqlWrapperEventArgs args);
		public delegate void PrepareSqlCommandEventHandler(SqlWrapper sender, SqlWrapperEventArgs args);
		public delegate void BeforeSqlExecuteEventHandler(SqlWrapper sender, SqlWrapperEventArgs args);
		public delegate void AfterSqlExecuteEventHandler(SqlWrapper sender, SqlWrapperEventArgs args);
		public delegate void SqlExceptionEventHandler(SqlWrapper sender, SqlWrapperEventArgs args);

		// Protected data members
		protected string m_connectionString;
		protected bool m_commandCachingEnabled;

		// Public Events
		public event CreateSqlConnectionEventHandler CreateSqlConnection;
		public event CreateSqlCommandEventHandler CreateSqlCommand;
		public event PrepareSqlCommandEventHandler PrepareSqlCommand;
		public event BeforeSqlExecuteEventHandler BeforeSqlExecute;
		public event AfterSqlExecuteEventHandler AfterSqlExecute;
		public event SqlExceptionEventHandler SqlException;

		// Public data members

		/// <summary>
		/// The maximum amount of time (in seconds) that the SqlWrapper will wait for
		/// a SQL statement or stored procedure to complete before giving up and
		/// throwing an exception.  The default value is 30 seconds.
		/// </summary>
		public int CommandTimeout = -1;


		/// <summary>
		/// The number of times the SqlWrapper will attempt to execute a SQL call
		/// before giving up and throwing an exception.  This setting only applies to
		/// a limited set of network errors -- it does not apply to SQL calls that
		/// return or trigger SQL errors.  Setting this property to 0 will turn off
		/// retries.
		/// </summary>
		public int RetryLimit = 3;


		/*
		 * Constructors
		 */

		public SqlWrapper()
		{
		}

		/// <summary>
		/// Creates a SqlWrapper object using the database connectionString provided
		/// and the option to enable/disable command caching.
		/// </summary>
		/// <param name="connectionString">Database connection string</param>
		/// <param name="enableCommandCaching">Enable/disable command caching functionality</param>
		public SqlWrapper(string connectionString, bool enableCommandCaching)
		{
			m_connectionString = connectionString;
			this.CommandCachingEnabled = enableCommandCaching;
		}


		/*
		 * Public Properties
		 */

		/// <summary>
		/// This property allows you to get or set the database connection
		/// string.
		/// </summary>
		public string ConnectionString
		{
			get
			{
				return m_connectionString;
			}

			set
			{
				m_connectionString = value;
			}
		}


		/// <summary>
		/// Enables/disables command caching. Command caching allows you to make SQL
		/// calls without having to provide all of the SQL parameters' sizes,
		/// types and directions.  Parameter type information is retrieved and
		/// cached automatically.
		/// </summary>
		public bool CommandCachingEnabled
		{
			get
			{
				return m_commandCachingEnabled;
			}

			set
			{
				if (value != m_commandCachingEnabled)
				{
					if (value == true)
					{
						SqlCommandCache.RegisterSqlWrapper(this);
					}
					else
					{
						SqlCommandCache.UnregisterSqlWrapper(this);
					}
					m_commandCachingEnabled = value;
				}
			}
		}


		/*
		 * Public Methods
		 */
		
		/// <summary>
		/// Calls the specified database stored procedure, but doesn't return any data rows.
		/// </summary>
		/// <param name="storedProcedureName">Name of the stored procedure</param>
		/// <returns>SqlResult object containing the return value and any output parameters
		/// resulting from the stored procedure call</returns>
		public SqlResult RunStoredProcNonQuery(string storedProcedureName)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(storedProcedureName, CommandType.StoredProcedure);
			return ExecuteNonQuery(args, null);
		}

		/// <summary>
		/// Calls the specified database stored procedure with the given parameters. No
		/// data rows are returned.
		/// </summary>
		/// <param name="storedProcedureName">Name of the stored procedure</param>
		/// <param name="sqlParameters">One or more SqlParameter objects</param>
		/// <returns>SqlResult object containing the return value and any output parameters
		/// resulting from the stored procedure call</returns>
		public SqlResult RunStoredProcNonQuery(string storedProcedureName, params SqlParameter[] sqlParameters)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(storedProcedureName, CommandType.StoredProcedure);
			return ExecuteNonQuery(args, sqlParameters);
		}


		/// <summary>
		/// Calls the specified database stored procedure, returning any and all data rows
		/// fetched by stored procedure.
		/// </summary>
		/// <param name="storedProcedureName">Name of the stored procedure</param>
		/// <returns>SqlResult object containing the return value, any output parameters
		/// and a DataSet containing the query results</returns>
		public SqlResult RunStoredProcQuery(string storedProcedureName)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(storedProcedureName, CommandType.StoredProcedure);
			return ExecuteQuery(args, null);
		}
		
		/// <summary>
		/// Calls the specified database stored procedure with the given parameters,
		/// returning any and all data rows fetched by the stored procedure.
		/// </summary>
		/// <param name="storedProcedureName">Name of the stored procedure</param>
		/// <param name="sqlParameters">One or more SqlParameter objects</param>
		/// <returns>SqlResult object containing the return value, any output parameters
		/// and a DataSet containing the query results</returns>
		public SqlResult RunStoredProcQuery(string storedProcedureName, params SqlParameter[] sqlParameters)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(storedProcedureName, CommandType.StoredProcedure);
			return ExecuteQuery(args, sqlParameters);
		}


		/// <summary>
		/// Executes the specified SQL statement.
		/// </summary>
		/// <param name="sql">SQL command text to execute</param>
		/// <returns>SqlResult object containing the number of rows affected</returns>
		public SqlResult RunSqlNonQuery(string sql)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(sql, CommandType.Text);
			return ExecuteNonQuery(args, null);
		}
		
		/// <summary>
		/// Executes the specified SQL statement with the given parameters.
		/// </summary>
		/// <param name="sql">SQL command text to execute</param>
		/// <param name="sqlParameters">One or more SqlParameter objects</param>
		/// <returns>SqlResult object containing the number of rows affected</returns>
		public SqlResult RunSqlNonQuery(string sql, params SqlParameter[] sqlParameters)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(sql, CommandType.Text);
			return ExecuteNonQuery(args, sqlParameters);
		}

		/// <summary>
		/// Executes the given SQL command
		/// </summary>
		/// <param name="command">A SqlCommand object specifying the SQL commmand to be executed.
		/// The SqlCommand does not require an existing connection, but it will use it if one is
		/// attached.</param>
		/// <returns>SqlResult object containing the number of rows affected</returns>
		public SqlResult RunSqlNonQuery(SqlCommand command)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(command.CommandText, command.CommandType);
			args.Command = command;
			
			return ExecuteNonQuery(args, null);
		}


		/// <summary>
		/// Executes the specified SQL query, returning any and all data rows.
		/// </summary>
		/// <param name="sql">SQL command text to execute</param>
		/// <returns>SqlResult object with a DataSet containing the query results</returns>
		public SqlResult RunSqlQuery(string sql)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(sql, CommandType.Text);
			return ExecuteQuery(args, null);
		}
		
		/// <summary>
		/// Executes the specified SQL query with the given parameters, returning any
		/// and all data rows.
		/// </summary>
		/// <param name="sql">SQL command text to execute</param>
		/// <param name="sqlParameters">One or more SqlParameter objects</param>
		/// <returns>SqlResult object with a DataSet containing the query results</returns>
		public SqlResult RunSqlQuery(string sql, params SqlParameter[] sqlParameters)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(sql, CommandType.Text);
			return ExecuteQuery(args, sqlParameters);
		}

		/// <summary>
		/// Executes the given SQL query command, returning any and all data rows.
		/// </summary>
		/// <param name="command">A SqlCommand object specifying the SQL query to be executed.
		/// The SqlCommand does not require an existing connection, but it will use it if one is
		/// attached.</param>
		/// <returns>SqlResult object with a DataSet containing the query results</returns>
		public SqlResult RunSqlQuery(SqlCommand command)
		{
			SqlWrapperEventArgs args = new SqlWrapperEventArgs(command.CommandText, command.CommandType);
			args.Command = command;
			
			return ExecuteQuery(args, null);
		}

		
		/*
		 * Protected Methods
		 */

		/// <summary>
		/// Execute a SQL command that doesn't return any data rows.
		/// </summary>
		/// <param name="args"></param>
		/// <param name="sqlParams"></param>
		/// <returns></returns>
		protected virtual SqlResult ExecuteNonQuery(SqlWrapperEventArgs args, SqlParameter[] sqlParams)
		{
			bool isConnectionOpen = false;
			int retryAttempts = 0;
			bool succeeded = false;

			// Initialize
			Init(args);

			// Create command with event notification
			CreateCommand(args);

			// Create connection with event notification
			CreateConnection(args);

			// Allow event handlers to modify command
			OnPrepareSqlCommand(args);

			// Assign SQL parameter values
			AssignSqlParameters(args.Command, sqlParams);
			
			// Notify event handlers we're about to execute
			OnBeforeSqlExecute(args);

			// Check if we got cached results from any of the event handlers
			if (args.Result != null)
			{
				return args.Result;
			}

			// Query the database
			SqlResult myResult = new SqlResult();

			do
			{
				try 
				{
					args.Command.Connection.Open();
					isConnectionOpen = true;
					myResult.RowsAffected = args.Command.ExecuteNonQuery();
					succeeded = true;
				}
				catch (Exception e)
				{
					succeeded = false;
					if (!HandleSqlError(e, args, retryAttempts++))
					{
						throw;
					}
				}
				finally
				{
					if (isConnectionOpen)
					{
						args.Command.Connection.Close();
						isConnectionOpen = false;
					}
				}
			} while (!succeeded);

			// Allow event handlers to read/modify results
			myResult.Params = args.Command.Parameters;
			args.Result = myResult;
			OnAfterSqlExecute(args);

			// Return object containing dataset, parameters and
			// other results
			return myResult;
		}


		/// <summary>
		/// Execute a SQL command that returns data rows and put them into a DataSet
		/// </summary>
		protected virtual SqlResult ExecuteQuery(SqlWrapperEventArgs args, SqlParameter[] sqlParams)
		{
			bool isConnectionOpen = false;
			int retryAttempts = 0;
			bool succeeded = false;

			// Initialize
			Init(args);

			// Create command with event notification
			CreateCommand(args);

			// Create connection with event notification
			CreateConnection(args);

			// Allow event handlers to modify command
			OnPrepareSqlCommand(args);

			// Assign SQL parameter values
			AssignSqlParameters(args.Command, sqlParams);
			
			// Create dataset to hold data rows
			SqlResult myResult = new SqlResult();
			myResult.DataSet = new DataSet();

			// Setup adapter to get data rows
			SqlDataAdapter myAdapter = new SqlDataAdapter();
			myAdapter.SelectCommand = args.Command;

			// Notify event handlers we're about to execute
			OnBeforeSqlExecute(args);

			// Check if we got cached results from any of the event handlers
			if (args.Result != null)
			{
				return args.Result;
			}

			// Query the database
			do
			{
				try 
				{
					args.Command.Connection.Open();
					isConnectionOpen = true;
					myResult.RowsAffected = myAdapter.Fill(myResult.DataSet);
					succeeded = true;
				}
				catch (Exception e)
				{
					succeeded = false;
					if (!HandleSqlError(e, args, retryAttempts++))
					{
						throw;
					}
				}
				finally
				{
					if (isConnectionOpen)
					{
						args.Command.Connection.Close();
						isConnectionOpen = false;
					}
				}
			} while (!succeeded);

			// Allow event handlers to read/modify results
			myResult.Params = args.Command.Parameters;
			args.Result = myResult;
			OnAfterSqlExecute(args);

			// Return object containing dataset, parameters and
			// other results
			return myResult;
		}


		protected virtual void Init(SqlWrapperEventArgs args)
		{
			args.ConnectionString = m_connectionString;
		}


		protected virtual void CreateConnection(SqlWrapperEventArgs args) 
		{
			// Create a connection object if we don't have one
			if (args.Command.Connection == null)
			{
				// Create a connection object
				SqlConnection connection = new SqlConnection(args.ConnectionString);
				args.Command.Connection = connection;

				// Fire CreateSqlConnection event
				OnCreateSqlConnection(args);
			}
		}

		protected virtual void CreateCommand(SqlWrapperEventArgs args)
		{
			if (args.Command == null)
			{
				// Create and initialize command object
				SqlCommand command = new SqlCommand(args.Sql);
				command.CommandType = args.CommandType;
				if (CommandTimeout != -1)
				{
					command.CommandTimeout = CommandTimeout;
				}
				args.Command = command;

				// Fire CreateSqlCommand event
				OnCreateSqlCommand(args);
			}
		}

		protected virtual void AssignSqlParameters(SqlCommand command, SqlParameter[] sqlParams)
		{
			if (sqlParams != null)
			{
				foreach (SqlParameter param in sqlParams)
				{
					if (command.Parameters.Contains(param.ParameterName))
					{
						command.Parameters[param.ParameterName].Value = param.Value;
					}
					else
					{
						command.Parameters.Add(param);
					}
				}
			}

			// If the parameter is Input-Output and no input value is provided
			// then change the direction to Output only.  This is needed because
			// DeriveParameters has no one to detect Output-only usage.
			foreach (SqlParameter param in command.Parameters)
			{
				if (param.Value == null)
				{
					if (param.Direction == ParameterDirection.InputOutput)
					{
						param.Direction = ParameterDirection.Output;
					}

					param.Value = DBNull.Value;
				}
			}
		}

		public bool HandleSqlError(Exception e, SqlWrapperEventArgs args, int retryAttempts)
		{
			// TODO: Add event logging to SqlWrapper
			// Record SQL error in the Event Log
			/*
			System.Diagnostics.EventLog.WriteEntry("SqlWrapper",
				"Attempt: " + retryAttempts + "\r\n" + e.ToString(),
				System.Diagnostics.EventLogEntryType.Error);
			*/

			// Check for network error and try again
			if (retryAttempts < this.RetryLimit)
			{
				if (e is SqlException)
				{
					SqlException sqlException = (SqlException)e;
					if (sqlException.Number == SqlNetworkErrorCode)
					{
						return true;
					}
				}
			}

			args.Exception = e;
			OnSqlException(args);
			return (args.Exception == null);
		}


		#region Event Methods

		protected virtual void OnCreateSqlConnection(SqlWrapperEventArgs args) 
		{
			// Invoke event handlers
			if (CreateSqlConnection != null) 
			{
				CreateSqlConnection(this, args); 
			}
		}

		protected virtual void OnCreateSqlCommand(SqlWrapperEventArgs args) 
		{
			// Invoke event handlers
			if (CreateSqlCommand != null) 
			{
				CreateSqlCommand(this, args); 
			}
		}

		protected virtual void OnPrepareSqlCommand(SqlWrapperEventArgs args)
		{
			// Invoke event handlers
			if (PrepareSqlCommand != null) 
			{
				PrepareSqlCommand(this, args); 
			}
		}

		protected virtual void OnBeforeSqlExecute(SqlWrapperEventArgs args)
		{
			// Invoke event handlers
			if (BeforeSqlExecute != null) 
			{
				BeforeSqlExecute(this, args); 
			}
		}

		protected virtual void OnAfterSqlExecute(SqlWrapperEventArgs args)
		{
			// Invoke event handlers
			if (AfterSqlExecute != null) 
			{
				AfterSqlExecute(this, args); 
			}
		}
		
		protected virtual void OnSqlException(SqlWrapperEventArgs args)
		{
			// Invoke event handlers
			if (SqlException != null) 
			{
				SqlException(this, args); 
			}
		}
		
		#endregion Event Methods


	}


	/// <summary>
	/// This class encapsulates the data, output parameters and other information
	/// returned by a SQL call.  This is a common return type used by the SQL
	/// methods of the SQLWrapper class.
	/// </summary>
	public class SqlResult
	{
		/// <summary>
		/// The number of rows affected by the SQL call.
		/// </summary>
		public int RowsAffected;

		/// <summary>
		/// A DataSet object containing the data returned from the SQL call.
		/// </summary>
		public DataSet DataSet;

		/// <summary>
		/// A collection containing the input and output parameters of the SQL call.
		/// </summary>
		public SqlParameterCollection Params;

		/// <summary>
		/// The return value from the stored procedure call, if applicable.
		/// </summary>
		public object ReturnValue
		{
			get
			{
				if (Params != null && Params.Contains("@RETURN_VALUE"))
					return Params["@RETURN_VALUE"].Value;
				else
					return null;
			}
		}
	}


	/// <summary>
	/// This class encapsulates the data related to a single SQL call.  This class is
	/// used internally and as an Event argument to provide current data to the methods
	/// and events being called.
	/// </summary>
	public class SqlWrapperEventArgs : EventArgs
	{
		/// <summary>
		/// This property allows you to get or set the database connection string.
		/// Event handlers can read and modify the connection string as needed.
		/// </summary>
		public string ConnectionString;

		/// <summary>
		/// The SQL command text or stored procedure to be executed.
		/// Event handlers can read and modify the SQL text as needed.
		/// </summary>
		public string Sql;

		/// <summary>
		/// Indicates if the SQL property represents a SQL statement or a
		/// stored procedure name.
		/// Event handlers can read and modify the CommandType as needed.
		/// </summary>
		public CommandType CommandType;

		/// <summary>
		/// The SqlCommand object created by the SqlWrapper for executing the current
		/// SQL call.
		/// Event handlers can read and modify the Command object as needed.
		/// </summary>
		public SqlCommand Command;

		/// <summary>
		/// The SqlResult object created by the SqlWrapper for returning SQL results.
		/// Event handlers can read and modify the SqlResult object as needed.
		/// </summary>
		public SqlResult Result;

		/// <summary>
		/// If an exception occurs, this property returns the Exception object.
		/// A SqlException event handler can be created to examine and handle errors
		/// before they are thrown back to the caller.
		/// </summary>
		public Exception Exception;

		/// <remarks>
		/// Disable the default constructor.  There is no reason at this time for anyone
		/// to be creating an instance of the object.
		/// </remarks>
		private SqlWrapperEventArgs()
		{
		}

		/// <summary>
		/// Internal constructor used by this library
		/// </summary>
		/// <param name="sql"></param>
		/// <param name="commandType"></param>
		internal SqlWrapperEventArgs(string sql, CommandType commandType)
		{
			this.Sql = sql;
			this.CommandType = commandType;
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\ActiveAuthAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.service;

namespace Leet.Authentication
{
    public class ActiveAuthAdapter : IActiveAuthAdapter
    {
        public ulong Puid { get; private set; }

        public ulong Xuid { get; private set; }

        public ActiveAuthAdapter()
        {
            // HttpContext required for AAInfo to be populated.
            AAInfo info = AAInfoInternetTier.Current;

            if (info != null)
            {
                this.Puid = info.PassportPuid;
                this.Xuid = info.LiveXuid;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\IdentityManager.cs ===
﻿using System;
using System.Security.Principal;
using System.Web;
using Leet.Core.IoCCo;

namespace Leet.Authentication
{
    [Leet.Core.IoCCo.PerWebRequestInstance]
    public class IdentityManager : IIdentityManager, IIdentity
    {
        private SocialIdentity primaryIdentity;
        private IWindowsLiveIdentity windowsLiveIdentity;
        private IXboxLiveIdentity xboxLiveIdentity;
        private string authenticationType = string.Empty;
        private bool isAuthenticated;
        private string name = string.Empty;

        /// <summary>
        /// Registers the IdentityManager and its dependencies with the
        /// provided IOC container.  Should be used when you want normal
        /// runtime behavior with no mocking.
        /// </summary>
        public static void RegisterWithIocContainer(IContainer container)
        {
            container.AddService<IIdentityManager, IdentityManager>();
            container.AddService<IWindowsLiveIdentity, WindowsLiveIdentity>();
            // Commenting out to remove RPS 6.0 dependency to allow Active Auth to work 
            // container.AddService<IWindowsLiveIdentityAdapter, WindowsLiveIdentityAdapter>();
        }

        public IdentityManager(IWindowsLiveIdentity windowsLiveIdentity)
        {
            this.windowsLiveIdentity = windowsLiveIdentity;
            this.authenticationType = this.windowsLiveIdentity.AuthenticationType;
            this.isAuthenticated = this.windowsLiveIdentity.IsAuthenticated;

            if (this.isAuthenticated)
            {
                this.name = this.windowsLiveIdentity.Name;

                // TODO: If SNID is cut then remove NetworkId, otherwise define constants
                // for the Microsoft networks Windows Live, Xbox Live.
                this.primaryIdentity.NetworkId = 1;
                this.primaryIdentity.UserId = this.windowsLiveIdentity.HexCid;
            }
        }

        public SocialIdentity PrimaryIdentity
        {
            get
            {
                return this.primaryIdentity;
            }
        }

        public IWindowsLiveIdentity WindowsLiveIdentity
        {
            get
            {
                return this.windowsLiveIdentity;
            }
        }

        public IXboxLiveIdentity XboxLiveIdentity
        {
            get
            {
                if (this.xboxLiveIdentity == null)
                {
                    // TBI
                    this.xboxLiveIdentity = Container.Instance.GetComponent<IXboxLiveIdentity>();
                }
                return this.xboxLiveIdentity;
            }
        }

        public SocialIdentity GetIdentity(int networkId)
        {
            return new SocialIdentity();
        }

        public string AuthenticationType
        {
            get
            {
                return this.authenticationType;
            }
        }

        public bool IsAuthenticated
        {
            get
            {
                return this.isAuthenticated;
            }
        }

        public string Name
        {
            get
            {
                return this.name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Authentication")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentity.#ProfileFlags")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1036:OverrideMethodsOnComparableTypes", Scope = "type", Target = "Leet.Authentication.Puid")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Leet.Authentication.Puid.#Value")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes", Scope = "type", Target = "Leet.Authentication.SocialIdentity")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Leet.Authentication.SocialIdentity.#NetworkId")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Leet.Authentication.SocialIdentity.#UserId")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1055:UriReturnValuesShouldNotBeStrings", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentity.#GetLogOnLogOffUrl()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentity.#GetLogOnLogOffUrl()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentity.#GetTextLinkForLoggingOnOrOff()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "URL", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentityAdapter.#GetNetworkURL(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1055:UriReturnValuesShouldNotBeStrings", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentityAdapter.#GetNetworkURL(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentityAdapter.#GetTextTag()")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\Puid.cs ===
using System;
using System.Globalization;

namespace Leet.Authentication
{
	public enum PuidFormat
	{
		Hexadecimal,
		DecimalPair,
		Decimal
	}

	/// <summary>
	/// Primitive class to give PUIDs more structure.
	/// Note -- Immutable
	/// </summary>
	public sealed class Puid : IComparable
	{
        
	    private static Puid unauthenticatedPuid = new Puid(0);
	    public static Puid UnauthenticatedPuid
        {
            get { return unauthenticatedPuid; }
        }
    
		public readonly UInt64 Value;

		public int High
		{
			get { return (int)(Value >> 32); }
		}

		public int Low
		{
			get { return (int)(Value & uint.MaxValue); }
		}

		public Puid(int high, int low)
		{
			this.Value = (((ulong)high << 32) | (uint) low);
		}

		public Puid(long value)
		{
			this.Value = (UInt64)value;
		}

		public Puid (string hexValue)
		{
			this.Value = Convert.ToUInt64(hexValue, 16);
		}

		public override bool Equals (object obj)
		{
			Puid puid2;
			if (obj == null || (puid2 = obj as Puid) == null)
			{
				return false;
			}

			return puid2.Value == Value;
		}

		public bool Equals(Puid puid2)
		{
			if (puid2 == null)
			{
				return false;
			}

			return puid2.Value == Value;
		}

		public static bool operator ==(Puid puidA, Puid puidB)
		{
			// If both are null, or both are same instance, return true.
			if (System.Object.ReferenceEquals(puidA, puidB))
			{
				return true;
			}

			// If one is null, but not both, return false.
			if ( ((object)puidA) == null || ((object)puidB) == null)
			{
				return false;
			}

			// Return true if the fields match:
			return puidA.Value == puidB.Value;
		}

		public static bool operator != ( Puid puidA, Puid puidB )
		{
			// optimize != comparison against nulls
			if ( ((object)puidA) == null && ((object)puidB) != null || ((object)puidB) == null && ((object)puidA) != null)
			{
				return true;
			}

			return ! ( puidA == puidB );
		}

		public int CompareTo(object obj)
		{
			// anything is > than null
			if (obj == null)
			{
				return 1;
			}
			
			Puid puid2 = obj as Puid;
			if (obj == null)
			{
				// not the right type
                throw new ArgumentNullException("obj");
			}

			int result = Value.CompareTo(puid2.Value);
			return result;
		}

		public override int GetHashCode ( )
		{
			return Value.GetHashCode();
		}

		/// <summary>
		/// Converts Puid to Int64 format
		/// </summary>
		/// <returns></returns>
		public Int64 ToInt64()
		{
			return (Int64)Value;
		}

		/// <summary>
		/// Converts Puid to Passport-readable hexadecimal representation
		/// with appropriate padding with zeros
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return Value.ToString("X16", CultureInfo.InvariantCulture);
		}

		public static explicit operator string(Puid puid)
		{
			return puid != null ? puid.ToString() : null;
		}

		// Parse the from a real puid (64bit hex number).
		// Returns true if parsing was successful.
		public static bool TryParse(string value, out Puid result)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}

			result = null;
			
			try
			{
				result = new Puid(value);
				return true;
			}
			catch(Exception e)
			{
				if(!(e is FormatException || e is OverflowException))
				{
					throw;
				}
			}
			
			return false;
		}


		/// <summary>
		/// Outputs Puid in a desired format. Supported formats:
		/// Hexadecimal format, with puidhigh/puidlow padded with zeros
		/// Decimal, human-readable format with puidHigh prepended with H:
		///		and puidLow prepended with L:
		/// </summary>
		/// <param name="format"></param>
		/// <returns></returns>
		public string ToString(PuidFormat format)
		{
			switch (format)
			{
				case PuidFormat.Hexadecimal: return this.ToString();
                case PuidFormat.Decimal: return Value.ToString("D", CultureInfo.InvariantCulture);
				case PuidFormat.DecimalPair: return string.Format(CultureInfo.InvariantCulture, "H:{0}, L:{1}", High, Low);
				default: throw new FormatException("Invalid format: " + format);
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\IWindowsLiveIdentity.cs ===
﻿using System;
using System.Security.Principal;

namespace Leet.Authentication
{
    public interface IWindowsLiveIdentity : IIdentity
    {
        Puid Puid { get; }
        Puid Cid { get; }
        string HexPuid { get; }
        string HexCid { get; }
        bool HasProfile();
        string FirstName { get; }
        string LastName { get; }
        string MemberName { get; }

        string GetTextLinkForLoggingOnOrOff();
        string GetLogOnLogOffUrl();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\IWindowsLiveIdentityAdapter.cs ===
﻿using System;
using System.Web;

namespace Leet.Authentication
{
    /// <summary>
    /// This interface defines our touch points with RPS and allows
    /// for mocking out the RPS dependency.  We use this interface
    /// to emulate RPS.
    /// </summary>
    public interface IWindowsLiveIdentityAdapter
    {
        bool IsAuthenticated { get; }
        bool HasTicket { get; }

        string PuidHex { get; }

        string FirstName { get; }
        string LastName { get; }
        string MemberName { get; }

        object this[string name] { get; }

        void Authenticate();
        string GetTextTag();
        string GetNetworkURL(string attributeName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\IXboxLiveIdentity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Permissions;
using System.Security.Principal;
using System.Web;

namespace Leet.Authentication
{
    public interface IXboxLiveIdentity : IIdentity
    {
        ulong Xuid { get; }
        string GamerTag { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\SocialIdentity.cs ===
﻿using System;

namespace Leet.Authentication
{
    [CLSCompliant(true)]
    public struct SocialIdentity
    {
        public int NetworkId;
        public string UserId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\IIdentityManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Security.Principal;
using System.Web;

namespace Leet.Authentication
{
    public interface IIdentityManager : IIdentity
    {
        SocialIdentity PrimaryIdentity { get; }
        IWindowsLiveIdentity WindowsLiveIdentity { get; }
        IXboxLiveIdentity XboxLiveIdentity { get; }
        SocialIdentity GetIdentity(int networkId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\WindowsLiveIdentityAdapter.cs ===
﻿using System;
using System.Web;
// using WindowsLiveID;

namespace Leet.Authentication
{
    /// <summary>
    /// This adapter class is a thin layer that simply puts an interface
    /// on top of WindowsLiveID.LiveIdentity.  We use this interface to
    /// emulate RPS.
    /// </summary>
    [Leet.Core.IoCCo.PerWebRequestInstance]
    public class WindowsLiveIdentityAdapter : IWindowsLiveIdentityAdapter
    {
        /*  Commenting out to remove RPS 6.0 dependency to allow Active Auth to work
        private static LiveIDAuthModule authModule = new LiveIDAuthModule();
        private WindowsLiveID.LiveIdentity liveIdentity;

        public WindowsLiveID.LiveIdentity LiveIdentity
        {
            get
            {
                if (this.liveIdentity == null)
                {
                    this.Authenticate();
                }
                return this.liveIdentity;
            }

            set
            {
                this.liveIdentity = value;
            }
        }

        public bool IsAuthenticated
        {
            get
            {
                if (this.LiveIdentity != null)
                {
                    return this.liveIdentity.IsAuthenticated;
                }
                else
                {
                    return false;
                }
            }
        }

        public bool HasTicket
        {
            get
            {
                return this.LiveIdentity.HasTicket;
            }
        }

        public string PuidHex
        {
            get
            {
                return this.LiveIdentity.PuidHex;
            }
        }

        public string FirstName
        {
            get
            {
                return this.LiveIdentity.Profile.FirstName;
            }
        }

        public string LastName
        {
            get
            {
                return this.LiveIdentity.Profile.LastName;
            }
        }

        public string MemberName
        {
            get
            {
                return this.LiveIdentity.Profile.MemberName;
            }
        }

        public object this[string name]
        {
            get
            {
                return this.LiveIdentity.Profile[name];
            }
        }

        public void Authenticate()
        {
            // Call the WindowsLiveAuthModule to authenticate the request.
            // This call will populate HttpApplication.User with a LiveIdentity object
            // if the user is logged in.
            HttpApplication app = HttpContext.Current.ApplicationInstance;
            WindowsLiveIdentityAdapter.authModule.OnAuthenticateRequest(app, new EventArgs());

            if ((app.User != null) && (app.User.Identity != null))
            {
                if (app.User.Identity is LiveIdentity)
                {
                    this.liveIdentity = app.User.Identity as LiveIdentity;
                }
            }
        }

        public string GetTextTag()
        {
            if (this.LiveIdentity != null)
            {
                return this.liveIdentity.GetTextTag();
            }
            else
            {
                return string.Empty;
            }
        }

        public string GetNetworkURL(string attributeName)
        {
            return this.liveIdentity.GetNetworkURL(attributeName);
        }
        */
        #region IWindowsLiveIdentityAdapter Members

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public bool IsAuthenticated
        {
            get { throw new NotImplementedException(); }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public bool HasTicket
        {
            get { throw new NotImplementedException(); }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public string PuidHex
        {
            get { throw new NotImplementedException(); }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public string FirstName
        {
            get { throw new NotImplementedException(); }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public string LastName
        {
            get { throw new NotImplementedException(); }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public string MemberName
        {
            get { throw new NotImplementedException(); }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public object this[string name]
        {
            get { throw new NotImplementedException(); }
        }

        public void Authenticate()
        {
            throw new NotImplementedException();
        }

        public string GetTextTag()
        {
            throw new NotImplementedException();
        }

        public string GetNetworkURL(string attributeName)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\WindowsLiveIdentity.cs ===
﻿using System;
using System.Globalization;

namespace Leet.Authentication
{
    [Leet.Core.IoCCo.PerWebRequestInstance]
    public class WindowsLiveIdentity : IWindowsLiveIdentity
    {
        private IWindowsLiveIdentityAdapter liveIdentity;

        public WindowsLiveIdentity(IWindowsLiveIdentityAdapter windowsLiveAdapter)
        {
            this.liveIdentity = windowsLiveAdapter;
            this.liveIdentity.Authenticate();
        }

        public Puid Cid
        {
            get { return new Puid(this.GetProfileProperty("HexCID")); }
        }

        public string FirstName
        {
            get { return this.liveIdentity.FirstName; }
        }

        public bool HasProfile()
        {
            return this.liveIdentity.HasTicket;
        }

        public string HexCid
        {
            get { return this.GetProfileProperty("HexCID"); }
        }

        public string HexPuid
        {
            get { return this.liveIdentity.PuidHex; }
        }

        public string LastName
        {
            get { return this.liveIdentity.LastName; }
        }

        public string MemberName
        {
            get { return this.liveIdentity.MemberName; }
        }

        public Puid Puid
        {
            get { return new Puid(this.liveIdentity.PuidHex); }
        }

        public string AuthenticationType
        {
            get { return "WindowsLive"; }
        }

        public bool IsAuthenticated
        {
            get { return this.liveIdentity.IsAuthenticated; }
        }

        public string Name
        {
            get { return this.liveIdentity.PuidHex; }
        }

        public string GetTextLinkForLoggingOnOrOff()
        {
            return this.liveIdentity.GetTextTag();
        }

        public string GetLogOnLogOffUrl()
        {
            return this.liveIdentity.GetNetworkURL("Auth");
        }

        private void AssertTicket()
        {
            if (!this.liveIdentity.HasTicket)
            {
                throw new InvalidOperationException("No Passport ticket.\r\nNote: RpsIdentity methods retrieving ticket properties only work if a user is signed in.");
            }
        }

        private string GetProfileProperty(string propertyName)
        {
            this.AssertTicket();
            object o = this.liveIdentity[propertyName];
            return Convert.ToString(o, CultureInfo.InvariantCulture);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\v2\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IAuthenticationManager.#GetUserIdentityFromCurrentContext()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1055:UriReturnValuesShouldNotBeStrings", Scope = "member", Target = "Leet.Authentication.IWebsiteAuthenticationManager.#GetLogOnLogOffUrl()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IWebsiteAuthenticationManager.#GetLogOnLogOffUrl()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IWebsiteAuthenticationManager.#GetTextLinkForLoggingOnOrOff()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "URL", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentityAdapter.#GetNetworkURL(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1055:UriReturnValuesShouldNotBeStrings", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentityAdapter.#GetNetworkURL(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Authentication.IWindowsLiveIdentityAdapter.#GetTextTag()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1028:EnumStorageShouldBeInt32", Scope = "type", Target = "Leet.Authentication.Puid")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Authentication")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\v2\IWindowsLiveIdentityAdapter.cs ===
﻿using System;

namespace Leet.Authentication
{
    /// <summary>
    /// This interface defines our touch points with RPS and allows
    /// for mocking out the RPS dependency.  We use this interface
    /// to emulate RPS.
    /// </summary>
    public interface IWindowsLiveIdentityAdapter
    {
        bool IsAuthenticated { get; }
        bool HasTicket { get; }

        string PuidHex { get; }

        string FirstName { get; }
        string LastName { get; }
        string MemberName { get; }

        object this[string name] { get; }

        void Authenticate();
        string GetTextTag();
        string GetNetworkURL(string attributeName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\v2\IUserIdentity.cs ===
﻿namespace Leet.Authentication
{
    /// <summary>
    /// List of valid profile Live tiers.
    /// </summary>
    public enum SubscriptionTier : int
    {
        Unknown = -1,
        None = 0,
        Silver = 3,
        Gold = 6
    }

    public interface IUserIdentity
    {
        long Puid { get; }
        long Cid { get; }
        ulong Xuid { get; }
        SubscriptionTier Tier { get; }
        string Gamertag { get; }
        //int ParentalControlGroup { get; }
        //uint[] Privileges { get; }
        string IdentityKey { get; }
        bool IsAuthenticated { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\v2\IAuthenticationManager.cs ===
﻿using System;

namespace Leet.Authentication
{
    public interface IAuthenticationManager
    {
        IUserIdentity GetUserIdentityFromCurrentContext();
        IUserIdentity CreateUserIdentityFromKey(string identityKey);
        IUserIdentity CreateUserIdentityFromPuid(ulong puid);
        IUserIdentity CreateUserIdentityFromXuid(ulong xuid);
    }

    public interface IWebsiteAuthenticationManager : IAuthenticationManager
    {
        string GetLogOnLogOffUrl();
        string GetTextLinkForLoggingOnOrOff();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Resources;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Authentication")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("934853db-09f5-4330-917f-d43c14f65dfa")]

[assembly: System.CLSCompliant(false)]

[assembly: NeutralResourcesLanguageAttribute("en")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\v2\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Resources;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Authentication")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("AA4853db-09f5-4330-917f-ff3c14f65dfa")]

[assembly: System.CLSCompliant(false)]

[assembly: NeutralResourcesLanguageAttribute("en")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication\v2\WindowsLiveIdentityAdapter.cs ===
﻿using System;
using System.Web;
using WindowsLiveID;

namespace Leet.Authentication
{
    /// <summary>
    /// This adapter class is a thin layer that simply puts an interface
    /// on top of WindowsLiveID.LiveIdentity.  We use this interface to
    /// emulate RPS.
    /// </summary>
    [Leet.Core.IoCCo.PerWebRequestInstance]
    public class WindowsLiveIdentityAdapter : IWindowsLiveIdentityAdapter
    {
        private static LiveIDAuthModule authModule = new LiveIDAuthModule();
        private WindowsLiveID.LiveIdentity liveIdentity;

        public WindowsLiveID.LiveIdentity LiveIdentity
        {
            get
            {
                if (this.liveIdentity == null)
                {
                    this.Authenticate();
                }
                return this.liveIdentity;
            }

            set
            {
                this.liveIdentity = value;
            }
        }

        public bool IsAuthenticated
        {
            get
            {
                if (this.LiveIdentity != null)
                {
                    return this.liveIdentity.IsAuthenticated;
                }
                else
                {
                    return false;
                }
            }
        }

        public bool HasTicket
        {
            get
            {
                return this.LiveIdentity.HasTicket;
            }
        }

        public string PuidHex
        {
            get
            {
                return this.LiveIdentity.PuidHex;
            }
        }

        public string FirstName
        {
            get
            {
                return this.LiveIdentity.Profile.FirstName;
            }
        }

        public string LastName
        {
            get
            {
                return this.LiveIdentity.Profile.LastName;
            }
        }

        public string MemberName
        {
            get
            {
                return this.LiveIdentity.Profile.MemberName;
            }
        }

        public object this[string name]
        {
            get
            {
                return this.LiveIdentity.Profile[name];
            }
        }

        public void Authenticate()
        {
            // Call the WindowsLiveAuthModule to authenticate the request.
            // This call will populate HttpApplication.User with a LiveIdentity object
            // if the user is logged in.
            HttpApplication app = HttpContext.Current.ApplicationInstance;
            WindowsLiveIdentityAdapter.authModule.OnAuthenticateRequest(app, new EventArgs());

            if ((app.User != null) && (app.User.Identity != null))
            {
                if (app.User.Identity is LiveIdentity)
                {
                    this.liveIdentity = app.User.Identity as LiveIdentity;
                }
            }
        }

        public string GetTextTag()
        {
            if (this.LiveIdentity != null)
            {
                return this.liveIdentity.GetTextTag();
            }
            else
            {
                return string.Empty;
            }
        }

        public string GetNetworkURL(string attributeName)
        {
            return this.liveIdentity.GetNetworkURL(attributeName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication.Test\IdentityManagerTests.cs ===
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Authentication.Test
{
    /// <summary>
    /// Unit tests for the IdentityManager class
    /// </summary>
    [TestClass]
    public class IdentityManagerTests
    {
        [TestMethod]
        public void IdentityManager_Handles_Unauthenticated_Request()
        {
            // Arrange
            IWindowsLiveIdentity wlid = new FakeWindowsLiveIdentity(false, false);
            
            // Act
            IIdentityManager identityMgr = new IdentityManager(wlid);
            bool isAuthenticated = identityMgr.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(false, isAuthenticated);
        }

        [TestMethod]
        public void IdentityManager_Handles_Authenticated_Request_Without_Profile()
        {
            // Arrange
            IWindowsLiveIdentity wlid = new FakeWindowsLiveIdentity(true, false);

            // Act
            IIdentityManager identityMgr = new IdentityManager(wlid);
            bool isAuthenticated = identityMgr.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(true, isAuthenticated);
            this.AssertIdentity(identityMgr, wlid);
        }

        [TestMethod]
        public void IdentityManager_Handles_Authenticated_Request_With_Profile()
        {
            // Arrange
            IWindowsLiveIdentity wlid = new FakeWindowsLiveIdentity(true, true);

            // Act
            IIdentityManager identityMgr = new IdentityManager(wlid);
            bool isAuthenticated = identityMgr.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(true, isAuthenticated);
            this.AssertIdentity(identityMgr, wlid);
            this.AssertProfile(identityMgr, wlid);
        }

        private void AssertIdentity(IIdentityManager identityMgr, IWindowsLiveIdentity wlid)
        {
            Assert.IsNotNull(identityMgr.WindowsLiveIdentity);
            Assert.AreEqual<Puid>(wlid.Puid, identityMgr.WindowsLiveIdentity.Puid);
            Assert.AreEqual<Puid>(wlid.Cid, identityMgr.WindowsLiveIdentity.Cid);
            Assert.AreEqual(wlid.HexPuid, identityMgr.WindowsLiveIdentity.HexPuid, true);
            Assert.AreEqual(wlid.HexCid, identityMgr.WindowsLiveIdentity.HexCid, true);
            Assert.AreEqual(wlid.HexPuid, identityMgr.Name);
        }

        private void AssertProfile(IIdentityManager identityMgr, IWindowsLiveIdentity wlid)
        {
            Assert.IsNotNull(identityMgr.WindowsLiveIdentity);
            Assert.AreEqual<bool>(true, identityMgr.WindowsLiveIdentity.HasProfile());
            Assert.AreEqual(wlid.FirstName, identityMgr.WindowsLiveIdentity.FirstName);
            Assert.AreEqual(wlid.LastName, identityMgr.WindowsLiveIdentity.LastName);
            Assert.AreEqual(wlid.MemberName, identityMgr.WindowsLiveIdentity.MemberName);
        }

    }

    public class FakeWindowsLiveIdentity : IWindowsLiveIdentity
    {
        private bool hasProfile;

        public FakeWindowsLiveIdentity(bool isAuthenticated, bool hasProfile)
        {
            this.IsAuthenticated = isAuthenticated;
            this.AuthenticationType = "WindowsLive";
            this.Name = string.Empty;

            if (isAuthenticated)
            {
                Random rand = new Random();
                int puidHigh = rand.Next(int.MinValue, int.MaxValue);
                int puidLow = rand.Next(int.MinValue, int.MaxValue);
                this.Puid = new Puid(puidHigh, puidLow);
                this.Cid = new Puid(puidLow, puidHigh);
                this.HexPuid = this.Puid.ToString();
                this.HexCid = this.Cid.ToString();
                this.Name = this.HexPuid;
                
                this.hasProfile = hasProfile;
                if (hasProfile)
                {
                    this.FirstName = "Test";
                    this.LastName = "User" + rand.Next();
                    this.MemberName = this.FirstName + this.LastName + "@hotmail.com";
                }
            }
        }

        public Puid Puid { get; set; }
        public Puid Cid { get; set; }
        public string HexPuid { get; set; }
        public string HexCid { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string MemberName { get; set; }
        public string AuthenticationType { get; set; }
        public bool IsAuthenticated { get; set; }
        public string Name { get; set; }

        public bool HasProfile()
        {
            return this.hasProfile;
        }

        public string GetTextLinkForLoggingOnOrOff()
        {
            throw new NotImplementedException();
        }

        public string GetLogOnLogOffUrl()
        {
            throw new NotImplementedException();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.Container.#AddService`2()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.Container.#AddServiceWithLocator`2()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.Container.#GetComponent`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.IContainer.#AddService`2()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.IContainer.#AddServiceWithLocator`2()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.IContainer.#GetComponent`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Core")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Co", Scope = "namespace", Target = "Leet.Core.IoCCo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Io", Scope = "namespace", Target = "Leet.Core.IoCCo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "npdb", Scope = "member", Target = "Leet.Core.Configuration.InMemoryConfigurationProvider.#LoadFromFile(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Core.Configuration")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Core.IoCCo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Core.IO")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Core.Caching")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Core.Utils")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Core.Wcf")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.IO")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "installutil", Scope = "member", Target = "Leet.Core.Configuration.Installer.#installutil")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "installutil", Scope = "member", Target = "Leet.Core.Configuration.Installer.#installutil")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "unspecified", Scope = "member", Target = "Leet.Core.Configuration.Installer.#unspecified")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "xblsvc", Scope = "member", Target = "Leet.Core.Configuration.Installer.#xblsvc")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xblsvc", Scope = "member", Target = "Leet.Core.Configuration.Installer.#xblsvc")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "bool", Scope = "member", Target = "Leet.Core.Configuration.IConfigurationProvider.#GetBoolSetting(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "long", Scope = "member", Target = "Leet.Core.Configuration.IConfigurationProvider.#GetLongSetting(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1720:IdentifiersShouldNotContainTypeNames", MessageId = "int", Scope = "member", Target = "Leet.Core.Configuration.IConfigurationProvider.#GetIntSetting(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.Caching")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.Utils")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Utils", Scope = "namespace", Target = "Leet.Core.Utils")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#Instance")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Livecache", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#LivecacheServiceEnabled")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#LivecacheServiceEnabled")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "EndPoint", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#LiveConnectEndPointConfigName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#LiveConnectEndPointConfigName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#LiveConnectServiceEnabled")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Core.Configuration.FeatureSettings.#UseTestImplementations")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.Configuration.ITestImplementationProvider.#Get`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Get", Scope = "member", Target = "Leet.Core.Configuration.ITestImplementationProvider.#Get`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.Configuration.TestImplementationProvider.#Get`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)", Scope = "member", Target = "Leet.Core.Configuration.TestImplementationProvider.#Get`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.Configuration.Utilities.#GetTestImplementationIfSpecified`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible", Scope = "member", Target = "Leet.Core.Configuration.CoreFeatureSettings.#Instance")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Core.Configuration.CoreFeatureSettings.#UseTestImplementations")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.TestSupport")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Core.TestSupport")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.TestSupport.ITestImplementationProvider.#GetTestImplementationType`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.TestSupport.TestImplementationProvider.#GetTestImplementationType`1()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes", Scope = "member", Target = "Leet.Core.Configuration.CoreFeatureSettings.#Instance")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "En", Scope = "type", Target = "Leet.Core.Utils.LIVEnException")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "LIV", Scope = "type", Target = "Leet.Core.Utils.LIVEnException")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "En", Scope = "type", Target = "Leet.Core.Utils.LIVEnExceptionError")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "LIV", Scope = "type", Target = "Leet.Core.Utils.LIVEnExceptionError")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.TestSupport.Extensions.#AddEmulatableService`2(Leet.Core.IoCCo.IContainer)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Emulatable", Scope = "member", Target = "Leet.Core.TestSupport.Extensions.#AddEmulatableService`2(Leet.Core.IoCCo.IContainer)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.Extensions.#AddEmulatableService`2(Leet.Core.IoCCo.IContainer)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Emulatable", Scope = "member", Target = "Leet.Core.IoCCo.Extensions.#AddEmulatableService`2(Leet.Core.IoCCo.IContainer)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\ValueTypeExtensions.cs ===
﻿namespace Leet.Core
{
    using System;
    using System.Globalization;

    public static class ValueTypeExtensions
    {
        public static string ToInvariantString(this IFormattable value)
        {
            return value.ToString(null, CultureInfo.InvariantCulture);
        }

        public static string ToInvariantString(this bool value)
        {
            return value.ToString(CultureInfo.InvariantCulture);
        }

        public static bool Contains(this string source, string toCheck, StringComparison comp) 
        { 
            return source.IndexOf(toCheck, comp) >= 0; 
        }

        public static bool IsNullOrEmpty(this Guid? guid)
        {
            if (guid.HasValue && guid.Value != Guid.Empty)
            {
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Authentication.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a2946c5f-035f-4367-8a21-6451dba7d865")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Authentication.Test\WindowsLiveIdentityTests.cs ===
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo;

namespace Leet.Authentication.Test
{
    /// <summary>
    /// Unit tests for the WindowsLiveIdentity class
    /// </summary>
    [TestClass]
    public class WindowsLiveIdentityTests
    {
        [TestMethod]
        public void WindowsLiveIdentity_Handles_Unauthenticated_Request()
        {
            // Arrange
            IWindowsLiveIdentityAdapter fakeAdapter = new FakeRpsAdapter(false, false);

            // Act
            IWindowsLiveIdentity windowsLiveIdentity = new WindowsLiveIdentity(fakeAdapter);
            bool isAuthenticated = windowsLiveIdentity.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(false, isAuthenticated);
            this.AssertAuthUrls(windowsLiveIdentity, fakeAdapter);
        }

        [TestMethod]
        public void WindowsLiveIdentity_Handles_Authenticated_Request_Without_Profile()
        {
            // Arrange
            IWindowsLiveIdentityAdapter fakeAdapter = new FakeRpsAdapter(true, false);

            // Act
            IWindowsLiveIdentity windowsLiveIdentity = new WindowsLiveIdentity(fakeAdapter);
            bool isAuthenticated = windowsLiveIdentity.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(true, isAuthenticated);
            this.AssertIdentity(windowsLiveIdentity, fakeAdapter);
            this.AssertAuthUrls(windowsLiveIdentity, fakeAdapter);
        }

        [TestMethod]
        public void WindowsLiveIdentity_Handles_Authenticated_Request_With_Profile()
        {
            // Arrange
            IWindowsLiveIdentityAdapter fakeAdapter = new FakeRpsAdapter(true, true);

            // Act
            IWindowsLiveIdentity windowsLiveIdentity = new WindowsLiveIdentity(fakeAdapter);
            bool isAuthenticated = windowsLiveIdentity.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(true, isAuthenticated);
            this.AssertIdentity(windowsLiveIdentity, fakeAdapter);
            this.AssertProfile(windowsLiveIdentity, fakeAdapter);
            this.AssertAuthUrls(windowsLiveIdentity, fakeAdapter);
        }

        private void AssertIdentity(IWindowsLiveIdentity identity, IWindowsLiveIdentityAdapter fakeAdapter)
        {
            Assert.AreEqual(fakeAdapter["HexCID"] as string, identity.Cid.ToString(), true);
            Assert.AreEqual(fakeAdapter["HexCID"] as string, identity.HexCid, true);
            Assert.AreEqual(fakeAdapter.PuidHex, identity.Puid.ToString(), true);
            Assert.AreEqual(fakeAdapter.PuidHex, identity.HexPuid, true);
            Assert.AreEqual(fakeAdapter.PuidHex, identity.Name);
        }

        private void AssertProfile(IWindowsLiveIdentity identity, IWindowsLiveIdentityAdapter fakeAdapter)
        {
            Assert.AreEqual<bool>(true, identity.HasProfile());
            Assert.AreEqual(fakeAdapter.FirstName, identity.FirstName);
            Assert.AreEqual(fakeAdapter.LastName, identity.LastName);
            Assert.AreEqual(fakeAdapter.MemberName, identity.MemberName);
        }

        private void AssertAuthUrls(IWindowsLiveIdentity identity, IWindowsLiveIdentityAdapter fakeAdapter)
        {
            Assert.AreEqual(fakeAdapter.GetTextTag(), identity.GetTextLinkForLoggingOnOrOff());
            Assert.AreEqual(fakeAdapter.GetNetworkURL("Auth"), identity.GetLogOnLogOffUrl());
        }
    }

    /// <summary>
    /// FakeRpsAdapter provides fake RPS data for unit testing
    /// </summary>
    internal class FakeRpsAdapter : IWindowsLiveIdentityAdapter
    {
        private Hashtable profile = new Hashtable();
        private bool authenticationState;
        private bool profileState;

        public FakeRpsAdapter(bool isAuthenticated, bool hasProfile)
        {
            this.authenticationState = isAuthenticated;
            this.profileState = hasProfile;
        }

        public bool IsAuthenticated { get; set; }
        public bool HasTicket { get; set; }
        public string PuidHex { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string MemberName { get; set; }

        public object this[string name]
        {
            get { return this.profile[name]; }
            set { this.profile[name] = value; }
        }

        public void Authenticate()
        {
            CreateFakeData(this.authenticationState, this.profileState);
        }

        public string GetTextTag()
        {
            return string.Format("<a href='{0}'>Login</a>", this.GetNetworkURL("Auth"));
        }

        public string GetNetworkURL(string attributeName)
        {
            return "http://" + attributeName;
        }

        private void CreateFakeData(bool isAuthenticated, bool hasProfile)
        {
            this.IsAuthenticated = isAuthenticated;

            if (isAuthenticated)
            {
                Random rand = new Random();
                int puidHigh = rand.Next(int.MinValue, int.MaxValue);
                int puidLow = rand.Next(int.MinValue, int.MaxValue);
                this.PuidHex = new Puid(puidHigh, puidLow).ToString();
                this["HexCID"] = new Puid(puidLow, puidHigh).ToString();
                this.HasTicket = true;

                if (hasProfile)
                {
                    this.FirstName = "Test";
                    this.LastName = "User" + rand.Next();
                    this.MemberName = this.FirstName + this.LastName + "@hotmail.com";
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\BI\BILog.cs ===
﻿using System;
using System.Collections.Generic;
using System.Threading;
using System.IO;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using System.Text;
using System.Diagnostics;
using System.Collections;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Leet.Core.Configuration;


namespace Leet.Core.BI
{
    [SingletonInstance]
    public class BILog : IBILog
    {

        // Default values
        const int MaxRetryCount = 5; // Number of time the failed writes should be tried again
        const int DefaultFileStreamBufferSize = 64*1024; // filestream buffer size
        const int DefaultMaxTotalBufferSize = 30 * 1024 * 1024;// max file size accpted by EDInsights 30MB
        const int DefaultMaxBIFileSize = 50 * 1024 * 1024;// max file size accepted by EDInsights BI team 50 MB
        const int DefaultMinBufferSize = 2 * 1024 * 1024;  // default Buffer size
        const int DefaultMaxIOBuffers = 2;// default Buffers
        const int DefaultLogCollectionInterval = 15 * 60 * 1000; // default log collection time in milliseconds (15 minutes)
        const string DefaultBILogFileExtension = "log"; //
        const string DefaultLogPath = @"c:\testlog"; //@".\";
        const string DefaultFieldDelimiter = "|";
        const int DefaultAverageLogLineSize = 80; // This is average logline size in characters
        const string BIPhoneServiceFormatTag = "LS-WPA"; // This is the format tag required by EDInsights, this is a fixed value for the the log format. 
                                                         // Per discussion with PM (Ruchit) this is something that should not change per EdInsights team and hence should not be configurable
        const string BIDefaultFieldValue = "0"; // THis is the default value to be written if string is empty or null

        /// <summary>
        /// Would be ideal for NPDB should have the below entires
        /// TODO: Discuss with PM and feature-team as to what goes into NPDB and add it
        /// </summary>
        /// 
        int FileStreamBufferSize;
        int LogCollectionInterval;
        string LogPath;
        int MaxBIFileSize;
        int MaxTotalBufferSize;
        string BILogFileExtension;
        string FieldDelimiter;
        int AverageLogLineSize;
        //////////////////


        private FileStream fs;
        private string FileName;
        private AsyncCallback asyncEndWriteCB;
        private Timer LogCollectionTimer;

        public static class WinAPIHelper
        {
            [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
            public static extern int GetCurrentProcessorNumber();
        }

        internal static ILogging DiagnosticsLogging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }

        public BILog()
        {
            InitSettings();
            CreateBILog();
            InitBuffer();
            CreateCollectionTimer();
        }

        void InitSettings()
        {
            IConfigurationProvider Config = Container.Instance.GetComponent<IConfigurationProvider>();

            // Get settings from NPDB
            // if NPDB is unavailable log the issue and resort to default values

            // LogPath
            try
            {
                LogPath = Config.GetSetting(Settings.BILogPath);
            }
            catch(Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Error, e, "Configuration provider or NPDB setting {0} is missing", Settings.BILogPath);
                LogPath = DefaultLogPath;
            }

            if (String.IsNullOrEmpty(LogPath))
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Error, "Configuration provider or NPDB setting {0} is missing", Settings.BILogPath);
                LogPath = DefaultLogPath;
            }

            // LogCollectionInterval
            try
            {
                LogCollectionInterval = Config.GetIntSetting(Settings.BILogCollectionInterval);
            }
            catch(Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BILogCollectionInterval);
                LogCollectionInterval = DefaultLogCollectionInterval;
            }

            if (LogCollectionInterval <= 0)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BILogCollectionInterval);
                LogCollectionInterval = DefaultLogCollectionInterval;
            }

            // LogCollectionInterval
            try
            {
                BILogFileExtension = Config.GetSetting(Settings.BILogFileExtension);
            }
            catch (Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BILogFileExtension);
                BILogFileExtension = DefaultBILogFileExtension;
            }

            if (String.IsNullOrEmpty(BILogFileExtension))
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BILogFileExtension);
                BILogFileExtension = DefaultBILogFileExtension;
            }

            // MaxBIFileSize
            try
            {
                MaxBIFileSize = Config.GetIntSetting(Settings.BIMaxFileSize);
            }
            catch (Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BIMaxFileSize);
                MaxBIFileSize = DefaultMaxBIFileSize;
            }

            if (MaxBIFileSize <= 0)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BIMaxFileSize);
                MaxBIFileSize = DefaultMaxBIFileSize;
            }

            // FieldDelimiter
            try
            {
                FieldDelimiter = Config.GetSetting(Settings.BIFieldDelimiter);
            }
            catch (Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BIFieldDelimiter);
                FieldDelimiter = DefaultFieldDelimiter;
            }

            if (String.IsNullOrEmpty(FieldDelimiter))
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BIFieldDelimiter);
                FieldDelimiter = DefaultFieldDelimiter;
            }

            // MaxTotalBufferSize
            try
            {
                MaxTotalBufferSize = Config.GetIntSetting(Settings.BIMaxTotalBufferSize);
            }
            catch (Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BIMaxTotalBufferSize);
                MaxTotalBufferSize = DefaultMaxTotalBufferSize;
            }

            if (MaxTotalBufferSize <= 0)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BIMaxTotalBufferSize);
                MaxTotalBufferSize = DefaultMaxTotalBufferSize;
            }

            // FileStreamBufferSize
            try
            {
                FileStreamBufferSize = Config.GetIntSetting(Settings.BIFileStreamBufferSize);
            }
            catch (Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BIFileStreamBufferSize);
                FileStreamBufferSize = DefaultFileStreamBufferSize;
            }

            if (FileStreamBufferSize <= 0)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BIFileStreamBufferSize);
                FileStreamBufferSize = DefaultFileStreamBufferSize;
            }

            // AverageLogLineSize
            try
            {
                AverageLogLineSize = Config.GetIntSetting(Settings.BIAverageLogLineSize);
            }
            catch (Exception e)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Configuration provider or NPDB setting {0} is missing", Settings.BIAverageLogLineSize);
                AverageLogLineSize = DefaultAverageLogLineSize;
            }

            if (AverageLogLineSize <= 0)
            {
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Configuration provider or NPDB setting {0} is missing", Settings.BIAverageLogLineSize);
                AverageLogLineSize = DefaultAverageLogLineSize;
            }

            // See if directory exists
            if (!Directory.Exists(LogPath))
            {
                // Log invalid directory as error
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "BI Log directory:{0} provided does not exist so using current directory for BI log collection", LogPath);

                DirectoryInfo dirInfo = null; ;
                try
                {
                    dirInfo = Directory.CreateDirectory(LogPath);
                }
                catch (Exception e)
                {
                    DiagnosticsLogging.LogTrace(TraceLevel.Error, e, "BI Log directory:{0} creation attempt failed", LogPath);
                }

                if (dirInfo == null || !dirInfo.Exists)
                {
                    // Log issue
                    DiagnosticsLogging.LogTrace(TraceLevel.Error, "BI Log directory:{0} creation attempt failed", LogPath);

                    // Use current dir, if creation fails
                    LogPath = Directory.GetCurrentDirectory();
                }
            }
        }

        void CreateBILog()
        {

            FileName = String.Format("{1}_{2}_{3}.{4}", LogPath, Environment.MachineName, Process.GetCurrentProcess().Id, DateTime.UtcNow.ToString("yyyy_MM_dd_HH_mm_ss_ffff"), BILogFileExtension);
            fs = new FileStream(Path.Combine(LogPath,FileName), FileMode.Append, FileAccess.Write, FileShare.None, FileStreamBufferSize, true);
            asyncEndWriteCB = new AsyncCallback(ProcessEndWrite);
        }

        void CreateCollectionTimer()
        {
            LogCollectionTimer = new Timer(new TimerCallback(CollectLogs), this, 0, LogCollectionInterval);
        }

        // This is used by the Timer Signal function to collect the logs, useful when activity is low
        private static void CollectLogs(object stateInfo)
        {
            BILog biLog = (BILog)stateInfo;

            try
            {
                biLog.ForceWriteAllBuffersToFile();
            }
            catch (Exception e)
            {
                // Log Error
                DiagnosticsLogging.LogTrace(TraceLevel.Info, e, "Timer Collection failed");

            }
        }

        private static object BackupAndCreateLock = new Object();

        private bool BackupAndCreateBILog()
        {
            bool success = true;
            try
            {
                lock (BackupAndCreateLock)
                {
                    // false mean we reuse existing log as it is already empty
                    if (CloseBILog())
                     { 
                        CreateBILog();

                        // Make sure we have a valid file
                        if (fs == null || !fs.CanWrite)
                        {
                            success = false;

                            // Log error
                            DiagnosticsLogging.LogTrace(TraceLevel.Error, "Creation of new BI log {0} failed", Path.Combine(LogPath, FileName));
                        }
                    }
                }
            }
            catch (Exception e)
            {
                // Log error
                DiagnosticsLogging.LogTrace(TraceLevel.Error, e, "Backup and create of new BI logs failed");

                success = false;
            }

            return success;
        }

        // Return true to indicate file can be reused
        private bool CloseBILog()
        {
            if (fs != null)
            {
                fs.Flush();
                if (fs.Length == 0)
                {
                    return false;
                }
                fs.Close();
                fs.Dispose();
                bufferIOFactory.FlushCount = 0;
                fs = null;

            }

            // if we  are here either there is a file or file has been closed
            return true;
        }

        static void ProcessEndWrite(IAsyncResult result)
        {
            AsyncWriteState writeState = (AsyncWriteState)result.AsyncState;
            try
            {
                writeState.BiLog.fs.EndWrite(result);
                Interlocked.Increment(ref writeState.BufferFactory.FlushCount);
            }
            catch (Exception e)
            {
                // Mostly IO specific exceptions should be rare
                // Log this and move on
                DiagnosticsLogging.LogTrace(TraceLevel.Error, e, "Async EndWrite call failed");
            }

            if (writeState.BufferFactory.FlushCount >= writeState.BufferFactory.CollectionFlushCount)
            {
                writeState.BiLog.ForceWriteAndCreateBILog();
            }
        }

        protected void ForceWriteAndCreateBILog()
        {
            bool backupDone = false;
            for (int i = 0; i < MaxRetryCount && !backupDone; i++)
                backupDone = BackupAndCreateBILog();
        }

        // change back to public
        public void ForceWriteAllBuffersToFile()
        {
            bool bytesToWrite = false;
            foreach (BufferIO bufferIO in bufferIOFactory.BufferIOList)
            {

                lock (bufferIO.BufferLock)
                {
                    bufferIO.FlushBufferForWrite();
                    if (bufferIO.FileWriteBuffer != null && bufferIO.FileWriteBufferOffset > 0)
                    {
                        WriteBufferToFile(bufferIO, bufferIOFactory, asyncEndWriteCB);
                        bytesToWrite = true;
                    }
                }
            }

            if (bytesToWrite)
                ForceWriteAndCreateBILog();
        }


        // Used by the Asynchrous I/O threads
        class AsyncWriteState
        {
            private int retryCount =0;
            public int RetryCount
            {
                get { return retryCount;}
                private set {retryCount = value;}
            }


            AsyncCallback asyncCallBack;
            public AsyncCallback AsyncCallBack
            {
                get { return asyncCallBack; }
                private set { asyncCallBack = value; }
            }

            BufferIOFactory bufferIOFactory;
            public BufferIOFactory BufferFactory
            {
                get { return bufferIOFactory; }
                private set { bufferIOFactory = value; }
            }

            BILog biLog;
            public BILog BiLog
            {
                get { return biLog; }
                private set { biLog = value; }
            }

            BufferIO buffer;
            public BufferIO Buffer
            {
                get { return buffer; }
                private set { buffer = value; }
            }

            public AsyncWriteState(BILog bi, BufferIO buffIO, BufferIOFactory buffIOFactory, AsyncCallback asyncCB)
            {
                Buffer = buffIO;
                BiLog = bi;
                BufferFactory = buffIOFactory;
                AsyncCallBack = asyncCB;
            }
        }

        private void WriteBufferToFile(BufferIO bufferIO, BufferIOFactory buffIOFactory, AsyncCallback asyncCB)
        {
            try
            {
                AsyncWriteState asyncWS = new AsyncWriteState(this, bufferIO, buffIOFactory, asyncCB);
                if (fs == null || !fs.CanWrite)
                {
                    // Log error
                    DiagnosticsLogging.LogTrace(TraceLevel.Info, "Creation of new BI log {0} failed", Path.Combine(LogPath, FileName));

                    // BackupAndCreateBILog must have failed Lets try again
                    ForceWriteAndCreateBILog();
                }

                if (fs == null || !fs.CanWrite)
                {

                    // Log critical error and move on. We are loosing some data at this point
                    // we should not cause any issues/stoppage to the client service(s)
                    DiagnosticsLogging.LogTrace(TraceLevel.Error, "Creation of new BI log {0} failed", Path.Combine(LogPath, FileName));

                }
                else
                {
                    fs.BeginWrite(asyncWS.Buffer.FileWriteBuffer, 0, asyncWS.Buffer.FileWriteBufferOffset, asyncWS.AsyncCallBack, asyncWS);
                    bufferIO.ClearWriteBuffer();
                }
            }
            catch (Exception e)
            {
                string str = e.Message;
                // Since these are non-IO exceptions no point retrying, most likely client call error
                // Log the exception
                DiagnosticsLogging.LogTrace(TraceLevel.Error, e, "WriteBufferToFile: Async write call failed");
            }
        }

        public void Log(BICredentials biCredentials, List<KeyValuePair<string, string>> activityValues)
        {
            // Check if biCredentials is null
            if (biCredentials == null)
            {
                // On null we simply return after doing the diagnostic logging
                DiagnosticsLogging.LogTrace(TraceLevel.Error, "Log: Invalid (null) BICredentials provided");
                return;
            }

            // Check if there are any key-values to log
            if (activityValues == null || activityValues.Count == 0)
            {
                // On null we simply return after doing the diagnostic logging
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Log: Activity Values empty or null for {0}", biCredentials.ToString());
                return;
            }

            // Do some checks to the extend we can
            // In case of errors, we still do BI logging after writing the errors to the Diagnostics log
            if (biCredentials.OriginatorID <= 0)
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Error, "Log: Invalid or empty ID provided for BICredentials - {0}", biCredentials.ToString());

            }

            if (biCredentials.Platform <= 0)
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Info, "Log: Invalid or empty Platform type provided for BICredentials - {0}", biCredentials.ToString());

            }

            if (String.IsNullOrEmpty(biCredentials.PlatformVersion))
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Verbose, "Log: Invalid or empty Platform version provided for BICredentials - {0}", biCredentials.ToString());


                // Set to default value to avoid EDInsight processing errors
                biCredentials.PlatformVersion = BIDefaultFieldValue;
            }

            if (biCredentials.TitleID <= 0)
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Error, "Log: Invalid or empty TitleID provided for BICredentials - {0}", biCredentials.ToString());

            }

            if (String.IsNullOrEmpty(biCredentials.ServiceName))
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Error, "Log: Invalid or empty ServiceName provided for BICredentials - {0}", biCredentials.ToString());


                // Set to default value to avoid EDInsight processing errors
                biCredentials.ServiceName = BIDefaultFieldValue;
            }

            if (String.IsNullOrEmpty(biCredentials.ServiceVersion))
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Verbose, "Log: Invalid or empty ServiceVersion provided for BICredentials - {0}", biCredentials.ToString());


                // Set to default value to avoid EDInsight processing errors
                biCredentials.ServiceVersion = BIDefaultFieldValue;
            }

            if (String.IsNullOrEmpty(biCredentials.CarrierName))
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Verbose, "Log: Invalid or empty CarrierName provided for BICredentials - {0}", biCredentials.ToString());


                // Set to default value to avoid EDInsight processing errors
                biCredentials.CarrierName = BIDefaultFieldValue;
            }

            if (String.IsNullOrEmpty(biCredentials.Location))
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Verbose, "Log: Invalid or empty Location provided for BICredentials - {0}", biCredentials.ToString());


                // Set to default value to avoid EDInsight processing errors
                biCredentials.Location = BIDefaultFieldValue;
            }

            if (String.IsNullOrEmpty(biCredentials.OEM))
            {
                // Log Specific Error
                DiagnosticsLogging.LogTrace(TraceLevel.Verbose, "Log: Invalid or empty OEM provided for BICredentials - {0}", biCredentials.ToString());

                // Set to default value to avoid EDInsight processing errors
                biCredentials.OEM = BIDefaultFieldValue;
            }


            // No size check to be done now
            // TODO: PM to get back on this after confirming if this is fine with EDInsights BI team for their DB size

            // TODO: PM to get back what needs to done if field delimters are in the strings


            StringBuilder strbuilder = new StringBuilder(AverageLogLineSize * activityValues.Count);
            foreach (KeyValuePair<string, string> activityValue in activityValues)
            {
                // Log if we have a valid ActivityName
                // TODO: Should we do not do logging if ActivityValue is empty?
                if (!String.IsNullOrEmpty(activityValue.Key))
                {
                    string keyValue = activityValue.Value;
                    if (String.IsNullOrEmpty(keyValue))
                    {
                        // Log Specific issue
                        DiagnosticsLogging.LogTrace(TraceLevel.Verbose, "Log: Invalid or empty ActivityValue provided for ActivitName:{0} BICredentials - {1}", activityValue.Key, biCredentials.ToString());

                        // Set to default value to avoid EDInsight processing errors
                        keyValue = BIDefaultFieldValue;
                    }

                    //Log line Format: TimeStamp(in UTC)|LS-WPA|OriginatorType|OriginatorID|Platform|PlatformVersion|CarrierName|OEM|Location|TitleID|ServiceName|ServiceVersion|ActivityName|ActivityValue\n
                    strbuilder.Append(DateTime.UtcNow.ToString());
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(BIPhoneServiceFormatTag);
                    strbuilder.Append(FieldDelimiter); 
                    strbuilder.Append(biCredentials.OriginatorType.ToString());
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.OriginatorID.ToString("X"));
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.Platform);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.PlatformVersion);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.CarrierName);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.OEM);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.Location);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.TitleID.ToString("X"));
                    strbuilder.Append(FieldDelimiter);          
                    strbuilder.Append(biCredentials.ServiceName);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(biCredentials.ServiceVersion);
                    strbuilder.Append(FieldDelimiter);          
                    strbuilder.Append(activityValue.Key);
                    strbuilder.Append(FieldDelimiter);
                    strbuilder.Append(keyValue);
                    strbuilder.Append(Environment.NewLine);

                    InternalLog(strbuilder.ToString());
                }
                else
                {
                    // Log Specific Error
                    DiagnosticsLogging.LogTrace(TraceLevel.Error, "Log: Invalid or empty ActivityName provided by BICredentails - ", biCredentials.ToString());
                }
            }
        }

        private void InternalLog(string str)
        {
            try
            {
                int bufferToUse = WinAPIHelper.GetCurrentProcessorNumber() % bufferIOFactory.BufferIOList.Count;
                byte[] utf8Bytes = Encoding.UTF8.GetBytes(str);
                int utf8ByteCount = Encoding.UTF8.GetByteCount(str);
                BufferIO bufferIO = ((BufferIO)bufferIOFactory.BufferIOList[bufferToUse]);
                lock (bufferIO.BufferLock)
                {
                    if (bufferIO.WriteToBuffer(utf8Bytes, utf8ByteCount))
                    {
                        WriteBufferToFile(bufferIO, bufferIOFactory, asyncEndWriteCB);
                    }
                }
            }
            catch (Exception e)
            {
                str = e.Message;
                // These are mostly non-IO exceptions
                // Log the exception
                DiagnosticsLogging.LogTrace(TraceLevel.Error, e, "InternalLog call failed");
            }
        }

        private class BufferIO
        {
            private int currentOffset;
            private int bufferSize;
            private byte[] currentBuffer;
            private byte[] writeFileBuffer;
            private bool writeBufferReady;

            int buffer1Offset;
            int buffer2Offset;
            private byte[] buffer1;
            private byte[] buffer2;

            //Lock per Buffer IO instance, which is per processor
            private object bufferLock;

            public object BufferLock
            {
                get { return bufferLock; }
            }

            public byte[] Buffer
            {
                get { return currentBuffer; }
            }

            public int Offset
            {
                get { return currentOffset; }
                set
                {
                    currentOffset = value;
                    if (currentBuffer == buffer1)
                        buffer1Offset = value;
                    else
                        buffer2Offset = value;
                }
            }

            public byte[] FileWriteBuffer
            {
                get
                {
                    if (writeBufferReady)
                        return writeFileBuffer;
                    else
                        return null;
                }
            }

            public int FileWriteBufferOffset
            {
                get
                {
                    if (writeBufferReady)
                    {
                        if (writeFileBuffer == buffer1)
                            return buffer1Offset;
                        else
                            return buffer2Offset;
                    }
                    else
                        return -1;
                }

                set
                {
                    if (writeBufferReady)
                    {
                        if (writeFileBuffer == buffer1)
                            buffer1Offset = value;
                        else
                            buffer2Offset = value;
                    }
                }
            }

            public int OffsetMax
            {
                get { return bufferSize; }
            }

            public bool WriteToBuffer(byte[] bytes, int byteCount)
            {
                bool IsSwapped = false;

                if (OffsetMax < (byteCount + currentOffset))
                {
                    bool flushed = false;
                    int i;
                    for (i = 0; i < BILog.MaxRetryCount && !flushed; i++)
                        flushed = FlushBufferForWrite();
                    if (i == MaxRetryCount && !flushed)
                        IsSwapped = false;
                    else
                        IsSwapped = true;
                }

                if (OffsetMax > (byteCount + currentOffset))
                {
                    Array.Copy(bytes, 0, Buffer, Offset, byteCount);
                    Offset = Offset + byteCount;
                }

                return IsSwapped;
            }

            public bool FlushBufferForWrite()
            {
                if (writeBufferReady)
                    return false;

                if (currentOffset > 0)
                {
                    SwapBuffer();
                    return true;
                }

                return false;
            }

            private void SwapBuffer()
            {
                writeFileBuffer = currentBuffer;
                if (currentBuffer == buffer1)
                {
                    currentBuffer = buffer2;
                    currentOffset = buffer2Offset;
                }
                else
                {
                    currentBuffer = buffer1;
                    currentOffset = buffer1Offset;
                }

                writeBufferReady = true;
            }

            // This should only called after write to the file
            // For Aysnc this should be called on EndWrite
            public void ClearWriteBuffer()
            {
                if (writeBufferReady)
                {
                    Array.Clear(writeFileBuffer, 0, FileWriteBufferOffset);
                    FileWriteBufferOffset = 0;
                    writeBufferReady = false;
                }
            }

            public BufferIO(int buffSize)
            {
                currentOffset = 0;
                bufferSize = buffSize;
                bufferLock = new object();

                buffer1Offset = 0;
                buffer2Offset = 0;
                buffer1 = new byte[bufferSize];
                buffer2 = new byte[bufferSize];
                currentBuffer = buffer1;
            }
        }

        protected class BufferIOFactory
        {
            ArrayList bufferIOList;
            // Incremented everytime a buffer is written to the file
            public int FlushCount = 0;
            // Only set during inititialization
            private int collectionFlushCount = 0;

            public ArrayList BufferIOList
            {
                get { return bufferIOList; }
            }


            // Only set during inititialization
            public int CollectionFlushCount
            {
                get { return collectionFlushCount; }
                set { collectionFlushCount = value; }
            }

            public BufferIOFactory()
            {
                bufferIOList = new ArrayList();
            }
        }

        BufferIOFactory bufferIOFactory;

        void InitBuffer()
        {
            bufferIOFactory = new BufferIOFactory();

            int bufferSize = 0;
            int bufferCount = 0;
            if (Environment.ProcessorCount > 0)
            {
                bufferCount = Environment.ProcessorCount;
                bufferSize = MaxTotalBufferSize / (bufferCount * 2);
            }
            else
            {
                bufferCount = DefaultMaxIOBuffers;
                bufferSize = MaxTotalBufferSize / (bufferCount * 2);
            }

            if (bufferSize < DefaultMinBufferSize)
                bufferSize = DefaultMinBufferSize;

            int tempCollectionCount = MaxBIFileSize / bufferSize;
            bufferIOFactory.CollectionFlushCount = (bufferCount > tempCollectionCount) ? bufferCount : tempCollectionCount;

            for (int i = 0; i < bufferCount; i++)
            {
                BufferIO bufferIO = new BufferIO(bufferSize);
                bufferIOFactory.BufferIOList.Add(bufferIO);
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\BI\IBILog.cs ===
﻿using System;
using System.Collections.Generic;

namespace Leet.Core.BI
{
    public interface IBILog
    {
        void Log(BICredentials biCredentials, List<KeyValuePair<string, string>> activityValues);
    }

    public class BICredentials
    {
        private ulong originatorID;
        private OriginatorIDType originatorType;
        private short platformType;
        private string platformVersion;
        private ulong titleID;
        private string serviceName;
        private string serviceVersion;
        private string carrierName;
        private string geolocation;
        private string Oem;

        public BICredentials(ulong originatorId, OriginatorIDType originatortype, short platformtype, string platformversion, ulong titleid, string servicename, string serviceversion, string carriername, string oem, string location)
        {
            originatorID = originatorId;
            originatorType = originatortype;
            platformType = platformtype;
            platformVersion = platformversion;
            titleID = titleid;
            serviceName = servicename;
            serviceVersion = serviceversion;
            carrierName = carriername;
            geolocation = location;
            Oem = oem;
        }

        public ulong OriginatorID
        {
            get { return originatorID; }
            set { originatorID = value; }
        }

        public OriginatorIDType OriginatorType
        {
            get { return originatorType; }
            set { originatorType = value; }
        }

        public short Platform
        {
            get { return platformType; }
            set { platformType = value; }
        }

        public string PlatformVersion
        {
            get { return platformVersion; }
            set { platformVersion = value; }
        }

        public ulong TitleID
        {
            get { return titleID; }
            set { titleID = value; }
        }

        public string ServiceName
        {
            get { return serviceName; }
            set { serviceName = value; }
        }
        public string ServiceVersion
        {
            get { return serviceVersion; }
            set { serviceVersion = value; }
        }

        public string CarrierName
        {
            get { return carrierName; }
            set { carrierName = value; }
        }

        public string Location
        {
            get { return geolocation; }
            set { geolocation = value; }
        }

        public string OEM
        {
            get { return Oem; }
            set { Oem = value; }
        }

        public override string ToString()
        {
            try
            {
                return string.Format("OriginatorType:{0} OriginatorID:{1} Platform ID:{2} PlatformVersion:{3} CarrierName:{4} OEM:{5} Location:{6} TitleID:{7} ServiceName:{8} ServiceVersion:{9}", OriginatorType, OriginatorID, Platform, PlatformVersion, CarrierName, OEM, Location, TitleID, ServiceName, ServiceVersion); 
            }
            catch
            {
                return base.ToString();
            }
        }
    }

    public enum OriginatorIDType
    {
        Xbox = 1, // for Xuid
        Partner = 2 // for PartnerID
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Caching\ICacheProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web.Caching;

namespace Leet.Core.Caching
{
    public interface ICacheProvider
    {
        object GetObject(string key);
        void Insert(string key, object value, DateTime expirationDate);
        void Insert(string key, object value, CacheDependency dependencies);
        void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration);
        void Clear();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\ConfigurationProviderBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Text;
using Leet.Core.IoCCo;
using System.Globalization;

namespace Leet.Core.Configuration
{
    public abstract class ConfigurationProviderBase
    {
        public virtual string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
        {
            var config = Container.Instance.GetComponent<IConfigurationProvider>();

            // Each application that has a secure endpoint should have a second
            // interface defined with the same name, and _secure appended to it
            // containing the correct port number
            if (useSecureEndpoint)
            {
                interfaceName += "_secure";
            }

            var interfaceInfo = config.GetInterface(System.Environment.MachineName, interfaceName);

            UriBuilder builder = new UriBuilder();
            builder.Scheme = useSecureEndpoint ? "https" : "http";
            if (String.IsNullOrEmpty(interfaceInfo.Info1))
            {
                builder.Port = interfaceInfo.Port;
                builder.Host = config.GetSingleServerForInterface(interfaceName);
                if (String.IsNullOrEmpty(builder.Host))
                {
                    throw new ConfigurationErrorsException(
                        String.Format("No server is registered for the interface '{0}'.", interfaceName));
                }
            }
            else
            {
                builder.Host = interfaceInfo.Info1;
            }

            return builder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Caching\AspNetCacheAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Collections;

namespace Leet.Core.Caching
{
    public class AspNetCacheAdapter : ICacheProvider
    {
        public object GetObject(string key)
        {
            return HttpRuntime.Cache.Get(key);
        }

        public void Insert(string key, object value, DateTime expirationDate)
        {
            HttpRuntime.Cache.Insert(key, value, null, expirationDate, Cache.NoSlidingExpiration);
        }
        public void Insert(string key, object value, CacheDependency dependencies)
        {
            HttpRuntime.Cache.Insert(key, value, dependencies);
        }
        public void Insert(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration)
        {
            HttpRuntime.Cache.Insert(key, value, dependencies, absoluteExpiration, slidingExpiration);
        }

        public void Clear()
        {
            var keys = HttpRuntime.Cache.Cast<DictionaryEntry>().Select(entry => entry.Key);
            foreach (string key in keys)
            {
                HttpRuntime.Cache.Remove(key);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\IConfigurationProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.Configuration
{
    public delegate void SettingChangedEventHandler(object sender, SettingChangedEventArgs args);
    public delegate void MultiSettingChangedEventHandler(object sender, MultiSettingChangedEventArgs args);

    public interface IConfigurationProvider
    {
        event SettingChangedEventHandler SettingChanged;
        event MultiSettingChangedEventHandler MultiSettingChanged;

        string GetSetting(string settingName);
        bool GetBoolSetting(string settingName);
        int GetIntSetting(string settingName);
        long GetLongSetting(string settingName);
        double GetDoubleSetting(string settingName);

        string[] GetMultiSetting(string settingName);

        string GetConnectionString(string interfaceName);
        string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint);

        string Environment { get; }
        string ComponentName { get; }
        string Server { get; }
        IInterfaceInfo GetSingleInterface(string interfaceName);
        IInterfaceInfo GetInterface(string computerName, string interfaceName);
        IVirtualInterfaceInfo GetVirtualInterface(string interfaceType);

        string GetSingleServerForInterface(string interfaceName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\IInterfaceInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;

namespace Leet.Core.Configuration
{
    public interface IInterfaceInfo
    {
        int VSiteId { get; }
        int Port { get; }
        string Info1 { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\AppSettingsConfigurationProvider.cs ===
﻿using System;
using System.Configuration;
using System.Globalization;

namespace Leet.Core.Configuration
{
    public class AppSettingsConfigurationProvider : ConfigurationProviderBase, IConfigurationProvider
    {
        #region IConfigurationProvider Members
        /// <summary>
        /// This is ignored, changing the app.config file resets the app domain
        /// </summary>
        public event SettingChangedEventHandler SettingChanged { add { } remove { } }

        /// <summary>
        /// This is ignored, changing the app.config file resets the app domain
        /// </summary>
        public event MultiSettingChangedEventHandler MultiSettingChanged { add { } remove { } }


        public string GetConnectionString(string interfaceName)
        {
            if (ConfigurationManager.ConnectionStrings[interfaceName] != null)
            {
                return ConfigurationManager.ConnectionStrings[interfaceName].ConnectionString;
            }
            else
            {
                throw new ConfigurationErrorsException("Value for connection string setting named " + interfaceName + " has not been defined.");
            }
        }

        public string GetSetting(string settingName)
        {
            if (ConfigurationManager.AppSettings[settingName] != null)
            {
                return ConfigurationManager.AppSettings[settingName];
            }
            else
            {
                throw new ConfigurationErrorsException("Value for application setting named " + settingName + " has not been defined.");
            }
        }

        public bool GetBoolSetting(string settingName)
        {
            return HandleInvalidConfigSetting<bool>(settingName,
                () => bool.Parse(GetSetting(settingName))
            );
        }

        public int GetIntSetting(string settingName)
        {
            return HandleInvalidConfigSetting<int>(settingName,
                () => int.Parse(GetSetting(settingName), CultureInfo.InvariantCulture)
            );
        }

        public long GetLongSetting(string settingName)
        {
            return HandleInvalidConfigSetting<long>(settingName,
                () => long.Parse(GetSetting(settingName), CultureInfo.InvariantCulture)
            );
        }

        public double GetDoubleSetting(string settingName)
        {
            return HandleInvalidConfigSetting<double>(settingName,
                () => double.Parse(GetSetting(settingName), CultureInfo.InvariantCulture)
            );
        }

        public string Environment
        {
            get { return ConfigurationManager.AppSettings["config.environment"]; }
        }

        public IInterfaceInfo GetSingleInterface(string interfaceName)
        {
            string interfaceData = ConfigurationManager.AppSettings["interface." + interfaceName];
            if (String.IsNullOrEmpty(interfaceData))
            {
                throw new ConfigurationErrorsException("The appSettings value [interface." + interfaceName + "] does not exist.");
            }
            string[] properties = interfaceData.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);

            InterfaceInfo interfaceInfo = new InterfaceInfo();
            foreach (string property in properties)
            {
                string[] propertyValues = property.Split('=');
                if (propertyValues.Length != 2)
                {
                    throw new ConfigurationErrorsException("The interface property [" + property + "] is not well-formed.  It should be in the format name=value;");
                }

                switch (propertyValues[0])
                {
                    case "Name":
                        interfaceInfo.Name = propertyValues[1];
                        break;

                    case "Info1":
                        interfaceInfo.Info1 = propertyValues[1];
                        break;

                    case "Port":
                        interfaceInfo.Port = Int32.Parse(propertyValues[1], CultureInfo.InvariantCulture);
                        break;

                    case "VSiteId":
                        interfaceInfo.VSiteId = Int32.Parse(propertyValues[1], CultureInfo.InvariantCulture);
                        break;
                }
            }

            return interfaceInfo;
        }

        public IInterfaceInfo GetInterface(string computerName, string interfaceName)
        {
            return GetSingleInterface(interfaceName);
        }

        public string ComponentName
        {
            get { return ConfigurationManager.AppSettings["config.component"]; }
        }

        public string Server
        {
            get { return ConfigurationManager.AppSettings["config.server"]; }
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
        {
            throw new NotImplementedException();
        }

        public string GetSingleServerForInterface(string interfaceName)
        {
            return ConfigurationManager.AppSettings["interface." + interfaceName + ".server"];
        }

        public string[] GetMultiSetting(string settingName)
        {
            return GetSetting(settingName).Split(new char[] { '|' });
        }
        #endregion

        private static T HandleInvalidConfigSetting<T>(string settingName, Func<T> function)
        {
            try
            {
                return function();
            }
            catch (FormatException ex)
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " cannot be converted to a " + typeof(T).ToString(), ex);
            }
            catch (OverflowException ex)
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " is out of range for a " + typeof(T).ToString(), ex);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic")]
        public string GetOptionalSetting(string settingName)
        {
            return ConfigurationManager.AppSettings[settingName];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\ConfigurationSelector.cs ===
﻿using System;
using System.Configuration;
using System.Globalization;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Microsoft.Win32;

namespace Leet.Core.Configuration
{
    public static class ConfigurationSelector
    {
        private const string CommonConfigRegistryKey = "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\";
        private const string ConfigurationFilePath = "FILE";
        private const string ConfigurationServerName = "Server";

        
        public static void RegisterProvider(string componentName)
        {
            RegisterProvider(componentName, null);
        }

        public static void RegisterProvider(string componentName, string configurationSet)
        {
            var registryProvider = Container.Instance.GetComponent<IRegistryProvider>();
            var commonConfigKey = registryProvider.OpenSubKey(Registry.LocalMachine, CommonConfigRegistryKey);
            if (commonConfigKey != null)
            {
                if (!String.IsNullOrEmpty(configurationSet))
                {
                    var configurationSetKey = registryProvider.OpenSubKey(commonConfigKey, configurationSet);
                    if (configurationSetKey != null)
                    {
                        string configFileName = (string)registryProvider.GetValue(configurationSetKey, ConfigurationFilePath);
                        if (!String.IsNullOrEmpty(configFileName))
                        {
                            Container.Instance.AddService<IConfigurationProvider, InMemoryConfigurationProvider>();
                            InMemoryConfigurationProvider configProvider = (InMemoryConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>();
                            configProvider.Initialize(componentName);

                            InMemoryConfigurationXmlLoader.Load(configurationSet);
                            return;
                        }
                        else
                        {
                            string serverName = (string)registryProvider.GetValue(configurationSetKey, ConfigurationServerName);
                            if (!String.IsNullOrEmpty(serverName))
                            {
                                Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
                                NpdbConfigurationProvider configProvider = (NpdbConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>();
                                configProvider.Initialize(configurationSet, componentName);
                            return;
                            }
                        }
                    }
                }
                else
                {
                    Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
                    NpdbConfigurationProvider configProvider = (NpdbConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>();
                    configProvider.Initialize(configurationSet, componentName);
                            return;
                }
            }

            Container.Instance.AddService<IConfigurationProvider, AppSettingsConfigurationProvider>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\InMemoryConfigurationProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Core.Configuration
{
    [SingletonInstance]
    public class InMemoryConfigurationProvider : ConfigurationProviderBase, IConfigurationProvider
    {
        private static Dictionary<string, string> connectionStringDictionary = new Dictionary<string, string>();
        private static Dictionary<string, string> settingDictionary = new Dictionary<string, string>();
        private static Dictionary<string, string[]> multiSettingDictionary = new Dictionary<string, string[]>();
        private static Dictionary<string, IInterfaceInfo> interfaceDictionary = new Dictionary<string, IInterfaceInfo>();
        private static Dictionary<string, string> interfaceServerDictionary = new Dictionary<string, string>();

        #region Helper Methods
        public static void SetConnectionString(string interfaceName, string connectionString)
        {
            connectionStringDictionary[interfaceName] = connectionString;
        }

        public static void SetSetting(string settingName, string value)
        {
            settingDictionary[settingName] = value;
        }

        public static void Clear()
        {
            connectionStringDictionary.Clear();
            settingDictionary.Clear();
            interfaceDictionary.Clear();
            interfaceServerDictionary.Clear();
        }

        public static void AddInterface(InterfaceInfo interfaceInfo)
        {
            interfaceDictionary.Add(interfaceInfo.Name, interfaceInfo);
        }

        public static void AddInterfaceServer(string interfaceName, string server)
        {
            interfaceServerDictionary.Add(interfaceName, server);
        }

        public void Initialize(string componentName)
        {
            ComponentName = componentName;
        }

        public static void SetMultiSetting(string settingName, string[] value)
        {
            multiSettingDictionary[settingName] = value;
        }
        #endregion

        #region IConfigurationProvider Members
        /// <summary>
        /// This is ignored.  No notifications for the InMemoryConfigurationProvider
        /// </summary>
        public event SettingChangedEventHandler SettingChanged { add { } remove { } }

        /// <summary>
        /// This is ignored.  No notifications for the InMemoryConfigurationProvider
        /// </summary>
        public event MultiSettingChangedEventHandler MultiSettingChanged { add { } remove { } }


        public string GetConnectionString(string interfaceName)
        {
            string connectionString = null;
            if (!connectionStringDictionary.TryGetValue(interfaceName, out connectionString))
            {
                throw new ConfigurationErrorsException("Connection string for interface " + interfaceName + " has not been defined using InMemoryConfigurationProvider.AddConnectionString.");
            }

            return connectionString;
        }

        public string GetSetting(string settingName)
        {
            string setting = null;
            if (!settingDictionary.TryGetValue(settingName, out setting))
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " has not been defined using InMemoryConfigurationProvider.AddSetting.");
            }

            return setting;
        }

        public bool GetBoolSetting(string settingName)
        {
            bool setting = false;
            if (!Boolean.TryParse(GetSetting(settingName), out setting))
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " cannot be converted to a bool.");
            }

            return setting;
        }

        public int GetIntSetting(string settingName)
        {
            int setting = 0;
            if (!Int32.TryParse(GetSetting(settingName), out setting))
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " cannot be converted to an int.");
            }

            return setting;
        }

        public long GetLongSetting(string settingName)
        {
            long setting = 0;
            if (!Int64.TryParse(GetSetting(settingName), out setting))
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " cannot be converted to an long.");
            }

            return setting;
        }

        public double GetDoubleSetting(string settingName)
        {
            double setting = 0;
            if (!Double.TryParse(GetSetting(settingName), out setting))
            {
                throw new ConfigurationErrorsException("Value for setting named " + settingName + " cannot be converted to an double.");
            }

            return setting;
        }

        public IInterfaceInfo GetSingleInterface(string interfaceName)
        {
            IInterfaceInfo interfaceInfo = null;
            if (!interfaceDictionary.TryGetValue(interfaceName, out interfaceInfo))
            {
                throw new ConfigurationErrorsException("The interface named " + interfaceName + " has not been defined using InMemoryConfigurationProvider.AddInterface.");
            }

            return interfaceInfo;
        }

        public IInterfaceInfo GetInterface(string computerName, string interfaceName)
        {
            //NOTE: There is currently no need to support any server information in this call.
            return GetSingleInterface(interfaceName);
        }

        public string GetSingleServerForInterface(string interfaceName)
        {
            if (interfaceServerDictionary.ContainsKey(interfaceName))
            {
                return interfaceServerDictionary[interfaceName];
            }
            else
            {
                return String.Empty;
            }
        }

        ///TODO: Remove the suppression when implemented
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        public string Environment { get; private set; }
        public string ComponentName { get; private set; }
        public string Server { get; private set; }

        public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
        {
            throw new NotImplementedException();
        }

        public string[] GetMultiSetting(string settingName)
        {
            return multiSettingDictionary[settingName];
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\InMemoryConfigurationXmlLoader.cs ===
﻿using System;
using System.Globalization;
using System.Xml;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Microsoft.Win32;
using System.Configuration;

namespace Leet.Core.Configuration
{
    public static class InMemoryConfigurationXmlLoader
    {
        private const string CommonConfigRegistryKey = "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\";
        private const string ConfigurationFilePath = "FILE";
        private const string ConfigurationOverrideFilePath = "OVERRIDE";


        public static void Load(string configurationSetName)
        {
            // Load the configuration file created in the build
            string fileName = GetConfigurationFileName(configurationSetName, false);
            LoadConfigurationFile(fileName);

            // Load the overrides (usually in the developers enlistment)
            fileName = GetConfigurationFileName(configurationSetName, true);
            LoadConfigurationFile(fileName);
        }

        private static void FromXml(string configurationXml, string fileName)
        {
            XmlDocument configurationDocument = new XmlDocument();
            configurationDocument.LoadXml(configurationXml);

            ReadSettingsFromXml(fileName, configurationDocument);
            ReadConnectionStringsFromXml(fileName, configurationDocument);
            ReadInterfacesFromXml(fileName, configurationDocument);
        }

        private static void ReadInterfacesFromXml(string fileName, XmlDocument configurationDocument)
        {
            foreach (XmlElement interfaceElement in configurationDocument.SelectNodes("//Configuration/Interfaces/Interface"))
            {
                if (interfaceElement.Attributes["name"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing name attribute.  File: {0}.  Element: {1}", fileName, interfaceElement.OuterXml));
                }
                string name = interfaceElement.Attributes["name"].Value;

                if (interfaceElement.Attributes["virtualSiteId"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing virtualSiteId attribute.  File: {0}.  Element: {1}", fileName, interfaceElement.OuterXml));
                }
                ushort virtualSiteId = 0;
                if (!UInt16.TryParse(interfaceElement.Attributes["virtualSiteId"].Value, out virtualSiteId))
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Invalid virtualSiteId attribute.  File: {0}.  Element: {1}", fileName, interfaceElement.OuterXml));
                }

                if (interfaceElement.Attributes["port"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing port attribute.  File: {0}.  Element: {1}", fileName, interfaceElement.OuterXml));
                }
                ushort port = 0;
                if (!UInt16.TryParse(interfaceElement.Attributes["port"].Value, out port))
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Invalid port attribute.  File: {0}.  Element: {1}", fileName, interfaceElement.OuterXml));
                }

                InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = name, VSiteId = virtualSiteId, Port = port });

                var serverNode = interfaceElement.SelectSingleNode("./Server");
                if (serverNode != null)
                {
                    if (serverNode.Attributes["name"] == null)
                    {
                        throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing name attribute.  File: {0}.  Element: {1}", fileName, serverNode.OuterXml));
                    }
                    string serverName = serverNode.Attributes["name"].Value;

                    InMemoryConfigurationProvider.AddInterfaceServer(name, serverName);
                }
            }
        }

        private static void ReadConnectionStringsFromXml(string fileName, XmlDocument configurationDocument)
        {
            foreach (XmlElement connectionStringElement in configurationDocument.SelectNodes("//Configuration/ConnectionStrings/ConnectionString"))
            {
                if (connectionStringElement.Attributes["interface"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing interface attribute.  File: {0}.  Element: {1}", fileName, connectionStringElement.OuterXml));
                }
                string iface = connectionStringElement.Attributes["interface"].Value;

                if (connectionStringElement.Attributes["value"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing value attribute.  File: {0}.  Element: {1}", fileName, connectionStringElement.OuterXml));
                }
                string value = connectionStringElement.Attributes["value"].Value;
                InMemoryConfigurationProvider.SetConnectionString(iface, value);
            }
        }

        private static void ReadSettingsFromXml(string fileName, XmlDocument configurationDocument)
        {
            foreach (XmlElement settingElement in configurationDocument.SelectNodes("//Configuration/Settings/Setting"))
            {
                if (settingElement.Attributes["name"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing name attribute.  File: {0}.  Element: {1}", fileName, settingElement.OuterXml));
                }
                string name = settingElement.Attributes["name"].Value;

                if (settingElement.Attributes["value"] == null)
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "Missing value attribute.  File: {0}.  Element: {1}", fileName, settingElement.OuterXml));
                }
                string value = settingElement.Attributes["value"].Value;
                InMemoryConfigurationProvider.SetSetting(name, value);
            }
        }

        private static string GetConfigurationFileName(string configurationSet, bool getOverride)
        {
            var registryProvider = Container.Instance.GetComponent<IRegistryProvider>();

            RegistryKey key = registryProvider.OpenSubKey(Registry.LocalMachine, CommonConfigRegistryKey);
            if (key != null)
            {
                key = registryProvider.OpenSubKey(key, configurationSet);
                if (key != null)
                {
                    string fileName = null;

                    if (!getOverride)
                    {
                        fileName = (string)registryProvider.GetValue(key, ConfigurationFilePath);
                    }
                    else
                    {
                        fileName = (string)registryProvider.GetValue(key, ConfigurationOverrideFilePath);
                    }

                    return fileName;
                }
                else
                {
                    throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The registry key {0}{1} does not exist.", CommonConfigRegistryKey, configurationSet));
                }
            }
            else
            {
                throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The registry key {0} does not exist.", CommonConfigRegistryKey));
            }
        }

        private static void LoadConfigurationFile(string fileName)
        {
            if (!String.IsNullOrEmpty(fileName))
            {
                var fileProvider = Container.Instance.GetComponent<IFileSystem>();
                string fileContents = fileProvider.ReadAllText(fileName);
                if (!String.IsNullOrEmpty(fileContents))
                {
                    FromXml(fileContents, fileName);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\Installer.cs ===
﻿
namespace Leet.Core.Configuration
{
    public enum Installer
    {
        unspecified = 0,
        installutil = 1,
        xblsvc = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\MultiSettingChangedEventArgs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.Configuration
{
    public class MultiSettingChangedEventArgs
    {
        public MultiSettingChangedEventArgs(string component, string environment, string server, string setting, int siteId, string[] valueOld, string[] valueNew)
        {
            Component = component;
            Environment = environment;
            Server = server;
            Setting = setting;
            SiteId = siteId;
            ValueNew = valueNew;
            ValueOld = valueOld;
        }

        public string Component { get; private set; }
        public string Environment { get; private set; }
        public string Server { get; private set; }
        public string Setting { get; private set; }
        public int SiteId { get; private set; }
        public string[] ValueNew { get; private set; }
        public string[] ValueOld { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\InterfaceInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.Configuration
{
    public class InterfaceInfo : IInterfaceInfo
    {
        public string Name { get; set; }
        public int VSiteId { get; set; }
        public int Port { get; set; }
        public string Info1 { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\IVirtualInterfaceInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.Configuration
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1040:AvoidEmptyInterfaces")]
    public interface IVirtualInterfaceInfo
    {
        ///Because IisRunner could use this interface, I've created it so that 
        ///I don't have to remove generic functionality.  As values are needed 
        ///from the virtual interface, they should be implemented here.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\SettingChangedEventArgs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.Configuration
{
    public class SettingChangedEventArgs
    {
        public SettingChangedEventArgs(string component, string environment, string server, string setting, int siteId, string valueOld, string valueNew)
        {
            Component = component;
            Environment = environment;
            Server = server;
            Setting = setting;
            SiteId = siteId;
            ValueNew = valueNew;
            ValueOld = valueOld;
        }

        public string Component { get; private set; }
        public string Environment { get; private set; }
        public string Server { get; private set; }
        public string Setting { get; private set; }
        public int SiteId { get; private set; }
        public string ValueNew { get; private set; }
        public string ValueOld { get; private set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\Events.cs ===
﻿using System;
using System.Diagnostics;

namespace Leet.Core.Diagnostics
{
    ///NOTE: All events should be declared in this file.  They should have the
    ///event id statically bound through the constructor.  Because we are using
    ///serialization, every event must have a default constructor defined.


    /// <summary>
    /// This event represents trace information, and should be used for logging
    /// troubleshooting information.
    /// </summary>
    public class TraceEvent : BaseEvent
    {
        public TraceEvent()
            : this(101, TraceLevel.Off)
        {
        }

        public TraceEvent(TraceLevel traceLevel)
            : this(101, traceLevel)
        {
            InitTraceEvent(traceLevel, TraceEventType.Verbose);
        }

        public TraceEvent(int id, TraceLevel traceLevel)
            : base(id)
        {
            InitTraceEvent(traceLevel, TraceEventType.Verbose);
        }

        public TraceEvent(int id, TraceEventType traceEventType, TraceLevel traceLevel)
            : base(id)
        {
            InitTraceEvent(traceLevel, traceEventType);

        }

        void InitTraceEvent(TraceLevel traceLevel, TraceEventType traceEventType)
        {
            IsTrace = true;
            TraceEventType = traceEventType;
            base.TraceLevel = traceLevel;
        }
    }

    /// <summary>
    /// This event is used to create transactional logging information.
    /// </summary>
    public class TransactionEvent : TraceEvent
    {
        public string TransactionId { get; set; }
        public string TransactionType { get; set; }
        public string Action { get; set; }

        public TransactionEvent()
            : base(102, TraceLevel.Info)
        {
        }
    }

    /// <summary>
    /// This event is used whenever a component is not registered in the IoC Container and it is expected to have been
    /// </summary>
    public class ComponentNotRegisteredEvent : BaseEvent
    {
        public ComponentNotRegisteredEvent()
            : base(103, TraceEventType.Critical)
        {
            Message = System.String.Format("A component was not registered in the IoC container and it was expected to have been \r\n Event Type: {0} \r\n Event Id: {1} \r\n Event Source: {2} Machine Name: {3}", GetType(), Id, Source, Environment.MachineName);
        }
    }
    public class AvailableCulturesEvent : BaseEvent
    {
        public AvailableCulturesEvent() : base(104, System.Diagnostics.TraceEventType.Critical)
        {
            Message = "An exception occured while processing supported cultures";
        }
    }
    public class RPSConfigurationEvent : BaseEvent
    {
        public RPSConfigurationEvent()
            : base(105, System.Diagnostics.TraceEventType.Warning)
        {
            Message = "Could not locate an instance of xboxcom_live from which to build the current site name for RPS, falling back to using settings.";
        }
    }
    public class AvailableCulturesMappingEvent : BaseEvent
    {
        public AvailableCulturesMappingEvent(string cultureName)
            : base(106, System.Diagnostics.TraceEventType.Warning)
        {
            Message = string.Format("The same culture was mapped to more than one base culture: {0}", cultureName);
        }
    }
    public class NotificationEvent : BaseEvent
    {
        public NotificationEvent()
            : base(107, TraceEventType.Warning)
        {
        }
    }

    public class UnhandledExceptionEvent : BaseEvent
    {
        public UnhandledExceptionEvent()
            : base(108, TraceEventType.Error)
        {
            Message = "An unhandled exception occured";
        }
    }

    /// <summary>
    /// This event is used whenever a NPDB is not reachable on uninitialized
    /// </summary>
    public class NPDBNotIntializedEvent : BaseEvent
    {
        public NPDBNotIntializedEvent()
            : base(108, TraceEventType.Critical)
        {
            Message = System.String.Format("NPDB is not intitialized or reachable \r\n Event Type: {0} \r\n Event Id: {1} \r\n Event Source: {2} Machine Name: {3}", GetType(), Id, Source, Environment.MachineName);
        }
    }

    /// <summary>
    /// This event is used whenever a configuration provider is uninitialized or null
    /// </summary>
    public class ConfigProviderErrorEvent : BaseEvent
    {
        public ConfigProviderErrorEvent()
            : base(109, System.Diagnostics.TraceEventType.Error)
        {
            Message = System.String.Format("Configuration Provider is not intitialized or null \r\n Event Type: {0} \r\n Event Id: {1} \r\n Event Source: {2} Machine Name: {3}", GetType(), Id, Source, Environment.MachineName);
        }
    }

    /// <summary>
    /// This event is used whenever a Container Instance is invalid or null
    /// </summary>
    public class ContainerInstanceInvalidEvent : BaseEvent
    {
        public ContainerInstanceInvalidEvent()
            : base(110, TraceEventType.Critical)
        {
            Message = System.String.Format("Container Instance is invalid or null \r\n Event Type: {0} \r\n Event Id: {1} \r\n Event Source: {2} Machine Name: {3}", GetType(), Id, Source, Environment.MachineName);
        }
    }

    /// <summary>
    /// This event is used whenever a Service is not Registered
    /// </summary>
    public class ServiceNotRegisteredEvent : BaseEvent
    {
        public ServiceNotRegisteredEvent()
            : base(111, TraceEventType.Critical)
        {
            Message = System.String.Format("Service is not Registered \r\n Event Type: {0} \r\n Event Id: {1} \r\n Event Source: {2} Machine Name: {3}", GetType(), Id, Source, Environment.MachineName);
        }
    }

    /// <summary>
    /// This event is used for generic errors
    /// Message is kept empty for consumers to fill in
    /// </summary>
    public class GenericErrorEvent : BaseEvent
    {
        public GenericErrorEvent()
            : base(112, System.Diagnostics.TraceEventType.Error)
        {
        }
    }

    public class LoggingConfigurationFailedEvent : BaseEvent
    {
        public LoggingConfigurationFailedEvent()
            : base(113, System.Diagnostics.TraceEventType.Error, "Logging library configuration failure")
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\ILogFormatter.cs ===
﻿using System;

namespace Leet.Core.Diagnostics
{
    public interface ILogFormatter
    {
        string Format(BaseEvent evt, string message, Exception exception);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Configuration\NpdbConfigurationProvider.cs ===
﻿using System;
using System.Configuration;
using System.Data.SqlClient;
using System.Globalization;
using System.Net;

using Leet.Core.IO;
using Leet.Core.IoCCo;
using Microsoft.Win32;
using xonline.common.config;

namespace Leet.Core.Configuration
{
    public static class NpdbExtensions
    {
        public static string BuildUpSqlConnectionString(this xonline.common.config.IInterfaceInfo iface, string failoverPartnerDataSource)
        {
            if ((iface.Protocol == null) || (iface.Protocol != "sql"))
            {
                var message = string.Format("InterfaceInfo.SqlConnectionString: Interface {0} does not have a Protocol of 'sql'.", iface.Interface);
                var ae = new ApplicationException(message);
                throw ae;
            }
            if (string.IsNullOrEmpty(iface.DBName))
            {
                var message = string.Format("InterfaceInfo.SqlConnectionString: Interface {0} does not have a database name specified.", iface.Interface);
                var ae = new ApplicationException(message);
                throw ae;
            }
            var scsb = new SqlConnectionStringBuilder
            {
                DataSource = GetDataSource(iface),
                InitialCatalog = iface.DBName,
                IntegratedSecurity = true,
                ApplicationName = Config.ComponentName,
                ConnectTimeout = iface.Timeout / 1000
            };
            if (iface.MinConnectionPoolSize.HasValue)
            {
                scsb.MinPoolSize = iface.MinConnectionPoolSize.Value;
            }
            if (iface.MaxConnectionPoolSize.HasValue)
            {
                scsb.MaxPoolSize = iface.MaxConnectionPoolSize.Value;
            }
            if (iface.LoadBalanceTimeout.HasValue)
            {
                int loadBalanceTimeout = iface.LoadBalanceTimeout.Value / 1000;
                if (loadBalanceTimeout > 0)
                {
                    scsb.LoadBalanceTimeout = loadBalanceTimeout;
                }
            }
            if (!String.IsNullOrEmpty(failoverPartnerDataSource))
            {
                scsb.FailoverPartner = failoverPartnerDataSource;
            }

            return scsb.ToString().Replace("Integrated Security=True", "Integrated Security=SSPI");
        }

        private static string GetDataSource(xonline.common.config.IInterfaceInfo iface)
        {
            if (string.IsNullOrEmpty(iface.Info1))
            {
                if ((iface.IPAddress == null) || (iface.IPAddress == IPAddress.None))
                {
                    var message = string.Format("InterfaceInfo.SqlConnectionString: Interface {0} does not have a DNS Entry in Info1 field or valid IP address.", iface.Interface);
                    var ae = new ApplicationException(message);
                    throw ae;
                }
                return iface.IPAddressString;
            }
            return iface.Info1;
        }

        public static string GetFailoverPartner(this xonline.common.config.IInterfaceInfo iface)
        {
            if ((iface.Protocol == null) || (iface.Protocol != "sql"))
            {
                var message = string.Format("InterfaceInfo.FailoverPartner: Interface {0} does not have a Protocol of 'sql'.", iface.Interface);
                var ae = new ApplicationException(message);
                throw ae;
            }
            if (string.IsNullOrEmpty(iface.DBName))
            {
                var message = string.Format("InterfaceInfo.FailoverPartner: Interface {0} does not have a database name specified.", iface.Interface);
                var ae = new ApplicationException(message);
                throw ae;
            }

            return GetDataSource(iface);
        }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Npdb")]
    [SingletonInstance]
    public class NpdbConfigurationProvider : ConfigurationProviderBase, IConfigurationProvider
    {
        private const string CommonConfigRegistryKey = "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\";
        private const string ConfigurationServer = "Server";
        private const string ConfigurationDatabase = "Database";

        public event SettingChangedEventHandler SettingChanged;
        public event MultiSettingChangedEventHandler MultiSettingChanged;

        private ConfigInstance config;

        #region Helper Methods
        public void Initialize(string configurationSet, string componentName)
        {
            string server;
            string database;

            var registryProvider = Container.Instance.GetComponent<IRegistryProvider>();
            var key = registryProvider.OpenSubKey(Registry.LocalMachine, CommonConfigRegistryKey);
            if (key != null)
            {
                if (!String.IsNullOrEmpty(configurationSet))
                {
                    key = registryProvider.OpenSubKey(key, configurationSet);
                    if (key != null)
                    {
                        // Get the server and database values at the configuration set level, for the specific NPDB
                        server = (string)registryProvider.GetValue(key, ConfigurationServer);
                        if (String.IsNullOrEmpty(server))
                        {
                            throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The value {0} in registry key {1}{2} does not exist.", ConfigurationServer, CommonConfigRegistryKey, configurationSet));
                        }

                        database = (string)registryProvider.GetValue(key, ConfigurationDatabase);
                        if (String.IsNullOrEmpty(database))
                        {
                            throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The value {0} in registry key {1}{2} does not exist.", ConfigurationDatabase, CommonConfigRegistryKey, configurationSet));
                        }
                    }
                    else
                    {
                        throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The registry key {0}{1} does not exist.", CommonConfigRegistryKey, configurationSet));
                    }
                }
                else
                {
                    // Get the server and database values at the CommonConfig level, for the Platform's NPDB
                    server = (string)registryProvider.GetValue(key, ConfigurationServer);
                    if (String.IsNullOrEmpty(server))
                    {
                        throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The value {0} in registry key {1}{2} does not exist.", ConfigurationServer, CommonConfigRegistryKey, configurationSet));
                    }

                    database = (string)registryProvider.GetValue(key, ConfigurationDatabase);
                    if (String.IsNullOrEmpty(database))
                    {
                        throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The value {0} in registry key {1}{2} does not exist.", ConfigurationDatabase, CommonConfigRegistryKey, configurationSet));
                    }
                }
            }
            else
            {
                throw new ConfigurationErrorsException(String.Format(CultureInfo.InvariantCulture, "The registry key {0} does not exist.", CommonConfigRegistryKey));
            }

            config = ConfigInstance.Create(server, database);
            config.ComponentName = componentName;
            config.SettingChange += SettingChangedHandler;
            config.MultiSettingChange += MultiSettingChangedHandler;
        }
        #endregion

        #region Setting Change Notification Events
        public void SettingChangedHandler(object sender, SettingChangeEventArgs args)
        {
            SettingChangedEventArgs newArgs = new SettingChangedEventArgs
            (
                args.Component,
                args.Environment,
                args.Server,
                args.Setting,
                args.SiteId,
                args.ValueOld,
                args.ValueNew
            );

            if (SettingChanged != null)
            {
                SettingChanged(sender, newArgs);
            }
        }

        public void MultiSettingChangedHandler(object sender, MultiSettingChangeEventArgs args)
        {
            MultiSettingChangedEventArgs newArgs = new MultiSettingChangedEventArgs
            (
                args.Component,
                args.Environment,
                args.Server,
                args.MultiSetting,
                args.SiteId,
                args.ValueOld,
                args.ValueNew
            );

            if (MultiSettingChanged != null)
            {
                MultiSettingChanged(sender, newArgs);
            }
        }
        #endregion

        #region IConfigurationProvider
        public string GetSetting(string settingName)
        {
            return ExceptionTranslatingCallToConfigInstance(() => config.GetSetting(settingName));
        }

        public bool GetBoolSetting(string settingName)
        {
            return ExceptionTranslatingCallToConfigInstance(() => config.GetBoolSetting(settingName));
        }

        public int GetIntSetting(string settingName)
        {
            return ExceptionTranslatingCallToConfigInstance(() => config.GetIntSetting(settingName));
        }

        public long GetLongSetting(string settingName)
        {
            return ExceptionTranslatingCallToConfigInstance(() => config.GetLongSetting(settingName));
        }

        public double GetDoubleSetting(string settingName)
        {
            return ExceptionTranslatingCallToConfigInstance(() => config.GetDoubleSetting(settingName));
        }

        public string GetConnectionString(string interfaceName)
        {
            // Identify if a failover partner interface is registered and, if so, include it in the connection string
            string failoverPartInterfaceName = interfaceName + "_FailoverPartner";
            string failoverServerName = String.Empty;
            string failoverDataSource = String.Empty;
            try
            {
                failoverServerName = GetSingleServerForInterface(failoverPartInterfaceName);
            }
            catch (ConfigurationErrorsException)
            {
                failoverServerName = String.Empty;
            }

            if (!String.IsNullOrEmpty(failoverServerName))
            {
                xonline.common.config.IInterfaceInfo failoverInterface = ExceptionTranslatingCallToConfigInstance(() => config.GetSingleInterface(failoverPartInterfaceName));
                failoverDataSource = failoverInterface.GetFailoverPartner();
            }
            
            xonline.common.config.IInterfaceInfo iface = ExceptionTranslatingCallToConfigInstance(() => config.GetSingleInterface(interfaceName));
            return iface.BuildUpSqlConnectionString(failoverDataSource);
        }

        public string Environment
        {
            get { return ExceptionTranslatingCallToConfigInstance(() => config.Environment); }
        }

        public string ComponentName
        {
            get { return ExceptionTranslatingCallToConfigInstance(() => config.ComponentName); }
        }

        public string Server
        {
            get { return ExceptionTranslatingCallToConfigInstance(() => config.Server); }
        }

        public IInterfaceInfo GetSingleInterface(string interfaceName)
        {
            return BuildInterfaceInfo(interfaceName, ExceptionTranslatingCallToConfigInstance(() => config.GetSingleInterface(interfaceName)));
        }

        public IInterfaceInfo GetInterface(string computerName, string interfaceName)
        {
            return BuildInterfaceInfo(interfaceName, ExceptionTranslatingCallToConfigInstance(() => config.GetInterface(computerName, interfaceName)));
        }

        public override string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
        {
            string[] servers = ExceptionTranslatingCallToConfigInstance(() => config.GetServerListByInterface(interfaceName));
            if (servers.Length < 1)
            {
                throw new ConfigurationErrorsException("There are no servers configured for interface '" + interfaceName + "'.");
            }

            var interfaceInfo = GetInterface(servers[0], interfaceName);

            UriBuilder builder = new UriBuilder();
            builder.Scheme = useSecureEndpoint ? "https" : "http";
            if (String.IsNullOrEmpty(interfaceInfo.Info1))
            {
                builder.Port = interfaceInfo.Port;
                builder.Host = servers[0];
            }
            else
            {
                builder.Host = interfaceInfo.Info1;
            }

            return builder.ToString();
        }

        private static InterfaceInfo BuildInterfaceInfo(string interfaceName, xonline.common.config.IInterfaceInfo iface)
        {
            var outputInterface = new InterfaceInfo
                                      {
                Name = interfaceName,
                Port = iface.Port,
                VSiteId = iface.VSiteId,
                Info1 = iface.Info1
            };

            return outputInterface;
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
        {
            throw new NotImplementedException();
        }

        public string GetSingleServerForInterface(string interfaceName)
        {
            string[] servers = ExceptionTranslatingCallToConfigInstance(() => config.GetServerListByInterface(interfaceName));
            if (servers.Length > 1)
            {
                throw new ConfigurationErrorsException("The interface [" + interfaceName + "] has more than one server registered to it.");
            }

            if (servers.Length == 0)
            {
                return String.Empty;
            }
            else
            {
                return servers[0];
            }
        }

        public string[] GetMultiSetting(string settingName)
        {
            return ExceptionTranslatingCallToConfigInstance(() => config.GetMultiSetting(settingName));
        }
        #endregion

        private TResult ExceptionTranslatingCallToConfigInstance<TResult>(Func<TResult> configCallDelegate)
        {
            try
            {
                return configCallDelegate();
            }
            catch (SqlException ex)
            {
                throw new ConfigurationErrorsException("Config call failed for a SQL exception, check inner exception for details", ex);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\ILogging.cs ===
﻿using System;
using System.Diagnostics;

namespace Leet.Core.Diagnostics
{
    public interface ILogging
    {
        void RegisterMetadata(string name, Func<String> value);

        void LogEvent(BaseEvent evt);
        void LogEvent(BaseEvent evt, string formattedMessage, params object[] args);
        void LogEvent(BaseEvent evt, Exception ex);
        void LogEvent(BaseEvent evt, Exception ex, string formattedMessage, params object[] args);

        void LogTrace(TraceLevel traceLevel, string formattedMessage, params object[] args);
        void LogTrace(TraceLevel traceLevel, Exception ex);
        void LogTrace(TraceLevel traceLevel, Exception ex, string formattedMessage, params object[] args);

        void LogTransaction(string transactionId, string transactionType, string action);
        void LogTransaction(string transactionId, string transactionType, string action, string formattedMessage, params object[] args);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\BaseEvent.cs ===
﻿using System.Collections.Generic;
using System.Diagnostics;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System;

namespace Leet.Core.Diagnostics
{
    [Serializable]
    public abstract class BaseEvent
    {
        public int Id { get; set; }
        public string Message { get; set; }
        public Metadata Metadata { get; set; }
        
        public bool IsTrace
        {
            get;
            set; 
        }
        public TraceLevel TraceLevel
        {
            get;
            set;
        }

        private TraceEventType _traceEventType = TraceEventType.Verbose;
        public TraceEventType TraceEventType
        {
            get
            {
                return _traceEventType;
            }
            set
            {
                _traceEventType = value;
            }
        }

        /// <summary>
        /// The name of the machine that the event is generated from.  This
        /// value will be set automatically by the system.  Any value specified
        /// by the developer will be modified before the event is written.
        /// </summary>
        public string MachineName { get; set; }

        /// <summary>
        /// The source of the event.  This value will be set automatically by
        /// the system.  Any value specified by the developer will be modified
        /// before the event is written.
        /// </summary>
        public string Source { get; set; }

        protected  BaseEvent()
        {
        }

        protected BaseEvent(int id, TraceEventType type, string message)
        {
            Id = id;
            TraceEventType = type;
            Message = message;

            Metadata = new Metadata();
        }

        protected BaseEvent(int id, TraceEventType type)
        {
            Id = id;
            TraceEventType = type;

            Metadata = new Metadata();
        }

        protected BaseEvent(int id)
        {
            Id = id;

            Metadata = new Metadata();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\LeetEventTypeFilter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace Leet.Core.Diagnostics
{
    public class LeetEventTypeFilter : EventTypeFilter
    {
        public LeetEventTypeFilter(SourceLevels level)
            : base(level)
        {
        }

        public override bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, object[] args, object data1, object[] data)
        {
            try
            {
                //if we have a BaseEvent and it is a TraceEvent then we will not trace this
                if (args != null && args.Length > 0)
                {
                    BaseEvent baseEvent = args[0] as BaseEvent;
                    if (baseEvent != null && baseEvent.IsTrace)
                    {
                        return false;
                    }
                }

                return base.ShouldTrace(cache, source, eventType, id, formatOrMessage, args, data1, data);
            }
            catch
            {
                // On any exception set shouldTrace to true
                return true;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\LeetTraceLevelFilter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace Leet.Core.Diagnostics
{
    public class LeetTraceLevelFilter : TraceFilter
    {
        public SourceLevels FilterEventLevel { get; set; }
        public TraceLevel FilterTraceLevel { get; set; }

        public LeetTraceLevelFilter()
            :this(TraceLevel.Off, SourceLevels.All)
        {
           
        }

        public LeetTraceLevelFilter(TraceLevel traceLevel)
            : this(traceLevel, SourceLevels.All)
        {
          
        }

        public LeetTraceLevelFilter(TraceLevel traceLevel, SourceLevels eventLevel)
        {
            FilterTraceLevel = traceLevel;
            FilterEventLevel = eventLevel;
        }

        public override bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, object[] args, object data1, object[] data)
        {
            bool shouldTrace = false;
            try
            {
                // args is either null or has one entry of type BaseEvent
                if (args != null && args.Length == 1 && args[0] != null)
                {
                    BaseEvent baseEvent = (BaseEvent)args[0];

                    if (baseEvent.IsTrace)
                    {
                        if(baseEvent.TraceLevel <= FilterTraceLevel )
                        {
                            shouldTrace = true;
                        }
                    }
                    else
                    {
                        if (((int)baseEvent.TraceEventType & (int)FilterEventLevel) > 0)
                        {
                            shouldTrace = true;
                        }
                    }
                }
            }
            catch
            {
                // On any exception set shouldTrace to true
                shouldTrace = true;
            }

            return shouldTrace;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\Metadata.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Xml;

namespace Leet.Core.Diagnostics
{
    public class Metadata : Dictionary<String, String>, IXmlSerializable
    {
        #region IXmlSerializable Members

        public XmlSchema GetSchema()
        {
            return null;
        }

        public void ReadXml(XmlReader reader)
        {
            //Will implement later. Currently need it to not throw an exception, but will need this when metadata starts being used
        }

        public void WriteXml(XmlWriter writer)
        {
            foreach (string name in Keys)
            {
                writer.WriteElementString(name, this[name]);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IO\IFileSystem.cs ===
﻿using System;

namespace Leet.Core.IO
{
    public interface IFileSystem
    {
        void WriteAllText(string path, string contents);
        string ReadAllText(string path);
        bool Exists(string path);

        bool DirectoryExists(string path);
        string[] GetFiles(string path, string pattern);

        string[] GetDirectories(string rootDirectoryPath);

        string GetTempFileName();
        void DeleteFile(string path);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IO\IRegistryKeyData.cs ===
﻿using Microsoft.Win32;

namespace Leet.Core.IO
{
    public interface IRegistryKeyData
    {
        string Name { get; }
        string[] GetValueNames();
        int ValueCount{ get; }
        object GetValue(string valueName);
        RegistryKey RegistryKey { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\SqlListener.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Core.Diagnostics
{
    public class SqlListener : TraceListener
    {
        public override void Write(string message)
        {
            TraceEvent(null, null, TraceEventType.Information, -1, message);
        }

        public override void WriteLine(string message)
        {
            TraceEvent(null, null, TraceEventType.Information, -1, message);
        }

        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message, object[] args)
        {
            if (this.Filter == null || this.Filter.ShouldTrace(eventCache, Name, eventType, id, message, args, null, null))
            {
                String normalizedLevel = eventType.ToString();

                if (args != null && args.Length == 1 && args[0] != null)
                {
                    BaseEvent baseEvent = (BaseEvent)args[0];
                    if (baseEvent.IsTrace)
                    {
                        normalizedLevel = baseEvent.TraceLevel.ToString();
                    }
                }

                EventData eventData = new EventData()
                {
                    Id = id,
                    Level = normalizedLevel,
                    Source = source,
                    Message = message
                };

                //DispatchEventData will execute on a background ThreadPool thread.
                System.Threading.ThreadPool.QueueUserWorkItem(new WaitCallback(DispatchEventData), eventData);               
            }
        }

        private void DispatchEventData(Object eventData)
        {
            System.Diagnostics.Debug.Assert(eventData != null, "eventData != null");
            
            EventData data = eventData as EventData;

            if (data == null)
            {
                return;
            }

            try
            {
                string connectionString = IoC.Get<IConfigurationProvider>().GetConnectionString("lest_diagnostics_db");
                using (SqlConnection connection = new SqlConnection(connectionString))
                {
                    using (SqlCommand command = new SqlCommand())
                    {
                        command.Connection = connection;

                        command.CommandType = System.Data.CommandType.StoredProcedure;
                        command.CommandText = "AddEvent";
                        command.Parameters.AddWithValue("@EventId", data.Id);
                        command.Parameters.AddWithValue("@Level", data.Level);
                        command.Parameters.AddWithValue("@Source", data.Source);
                        command.Parameters.AddWithValue("@Message", data.Message);

                        connection.Open();
                        command.ExecuteNonQuery();
                    }
                }
            }
            catch (SqlException sqlEx)
            {
                WriteEventLog(data.Source,
                    String.Format(System.Globalization.CultureInfo.CurrentCulture, "Sql Exception when writing event data to diagnostic database: {0}", sqlEx.ToString()),
                    EventLogEntryType.Error, 23);
            }
            catch (Exception ex)
            {
                WriteEventLog(data.Source,
                    String.Format(System.Globalization.CultureInfo.CurrentCulture, "Unknown error when writing event data to diagnostic database: {0}", ex.ToString()), 
                    EventLogEntryType.Error, 21);
            }
        }

        private void WriteEventLog(String source, String message, EventLogEntryType eventLogEntryType, Int32 messageId)
        {
            try
            {
                EventLog.WriteEntry(source, message, eventLogEntryType, messageId);
            }
            catch(Exception)
            { 
                //this call can be made from a background thread eat exception since we cannot do anything here
            }
        }

        class EventData
        {
            public int Id { get; set; }
            public string Level { get; set; }
            public string Source { get; set; }
            public string Message { get; set; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\LogFormatter.cs ===
﻿using System;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace Leet.Core.Diagnostics
{
    /// <summary>
    /// This class is used to format the message for every event to ensure
    /// standard formatting across the board.
    /// </summary>
    public class LogFormatter : ILogFormatter
    {
        private const string NewLineCharacter = "\r\n";

        public string Format(BaseEvent evt, string message, Exception exception)
        {
            if (!String.IsNullOrEmpty(message))
            {
                evt.Message += NewLineCharacter + message;
            }

            if (exception != null)
            {
                String exceptionString = exception.ToString();
                StripFormattingCharacters(ref exceptionString); //remove formatting characters from exception message
                evt.Message += NewLineCharacter + exceptionString;
            }

            XmlSerializer serializer = new XmlSerializer(evt.GetType());

            StringBuilder formattedMessageBuilder = new StringBuilder();
            StringWriter writer = new StringWriter(formattedMessageBuilder);
            serializer.Serialize(writer, evt);

            string formattedMessage = formattedMessageBuilder.ToString();
            return formattedMessage.Substring(formattedMessage.IndexOf("?>") + 2);
        }

        /// <summary>
        /// This methods removes characters that will cause String.Format to fail.
        /// </summary>
        /// <param name="messageToBeStripped">Message to be stripped</param>
        private void StripFormattingCharacters(ref String messageToBeStripped)
        {
            char[] charatersToBeStripped = new Char[] { '{', '}'}; //strip curly braces

            if (String.IsNullOrEmpty(messageToBeStripped))
            {
                return;
            }
            
            foreach(char c in charatersToBeStripped)
            {
                if (messageToBeStripped.IndexOf(c) > 0) 
                {
                    messageToBeStripped = messageToBeStripped.Replace(c, ' ');
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IO\IRegistryProvider.cs ===
﻿
using Microsoft.Win32;
namespace Leet.Core.IO
{
    public interface IRegistryProvider
    {
        void SetValue(string keyName, string valueName, object value);
        object GetValue(string keyName, string valueName, object defaultValue);
        
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
        RegistryKey OpenSubKey(RegistryKey key, string subKeyName);
        object GetValue(RegistryKey key, string valueName);

        IRegistryKeyData CurrentUserHive { get; }
        IRegistryKeyData GetRegistryKeyData(IRegistryKeyData hive, string keyName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IO\FileSystem.cs ===
﻿using System.IO;

namespace Leet.Core.IO
{
    public class FileSystem : IFileSystem
    {
        public void WriteAllText(string path, string contents)
        {
            File.WriteAllText(path, contents);
        }

        public string ReadAllText(string path)
        {
            return File.ReadAllText(path);
        }

        public bool Exists(string path)
        {
            return File.Exists(path);
        }

        public bool DirectoryExists(string path)
        {
            return Directory.Exists(path);
        }

        public string[] GetFiles(string path, string pattern)
        {
            return Directory.GetFiles(path, pattern);
        }

        public string[] GetDirectories(string rootDirectoryPath)
        {
            return Directory.GetDirectories(rootDirectoryPath);
        }

        public string GetTempFileName()
        {
            return Path.GetTempFileName();
        }

        public void DeleteFile(string path)
        {
            File.Delete(path);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Diagnostics\Logging.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Xml;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using System.Xml.Serialization;
using System.IO;

namespace Leet.Core.Diagnostics
{
    [SingletonInstance]
    public class Logging : ILogging
    {
        private ILogFormatter formatter;
        private IConfigurationProvider configurationProvider;
        private Dictionary<String, Func<String>> metadata = new Dictionary<string, Func<string>>();
        private TraceSource traceSource;
        private const String SQLLISTENER = "SqlListener";
        private const String EVENTLOGLISTENER = "EventLogListener";

        // Initialized status of Logging, if everything went well in terms of initialization this is set to true
        bool Initialized = false;

        //Lock mainly for intialization
        private static object syncLoggingLock = new Object();

        // Deafult component name
        private const string DefaultComponentName = "Application";

        // Default Event source
        private const string DefaultEventSource = "Application Error";

        public Logging(IConfigurationProvider configProvider, ILogFormatter logFormatter)
        {
            formatter = null;
            configurationProvider = null;
            Initialized = false;

            // check if configuration provider is set , provide we have a valid formatter
            if ((configurationProvider == null) && (configProvider == null))
            {
                ConfigProviderErrorEvent evt = new ConfigProviderErrorEvent();
                WriteEventLog(String.Format("{0}\r\n{1}", evt.Message, Environment.StackTrace), EventLogEntryType.Error, evt.Id);
                return;
            }
            configurationProvider = configProvider;

            //formatter can be null here which is a valid case
            formatter = logFormatter;
           
            // Add check here for component name
            if (String.IsNullOrEmpty(configurationProvider.ComponentName))
            {
                ComponentNotRegisteredEvent evt = new ComponentNotRegisteredEvent();
                WriteEventLog(String.Format("{0}\r\n{1}", evt.Message, Environment.StackTrace), EventLogEntryType.Error, evt.Id);

                traceSource = new TraceSource(DefaultComponentName);
            }
            else
            {
                traceSource = new TraceSource(configurationProvider.ComponentName);
            }
      
            try
            {
                ConfigureLogging();
                configProvider.SettingChanged += new SettingChangedEventHandler(ConfigurationSettingChanged);
                // Set initialized to true
                Initialized = true;
            }
            catch (Exception ex)
            {
                // We failed to configure logging library
                LoggingConfigurationFailedEvent evt = new LoggingConfigurationFailedEvent();
                WriteEventLog(String.Format("{0}\r\nException: {1}", evt.Message, ex.ToString()), EventLogEntryType.Error, evt.Id);
            }
        }

        #region Configuration
        
        private void ConfigurationSettingChanged(object sender, SettingChangedEventArgs args)
        {
            //This is an event handler. Expected to be called from a background thread. Handle any exceptions
            try
            {
                IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
                if (args != null && String.Compare(args.Environment, configProvider.Environment, true) == 0)
                {
                    if (args.Setting == Settings.TraceLevel)
                    {
                        LeetTraceLevelFilter traceFilter = this.traceSource.Listeners[SQLLISTENER].Filter as LeetTraceLevelFilter;
                        if (traceFilter != null)
                        {
                            traceFilter.FilterTraceLevel = (TraceLevel)Enum.Parse(typeof(TraceLevel), args.ValueNew);
                        }

                        return;
                    }

                    if (args.Setting == Settings.EventLevel)
                    {
                        LeetTraceLevelFilter traceFilter = this.traceSource.Listeners[SQLLISTENER].Filter as LeetTraceLevelFilter;
                        if (traceFilter != null)
                        {
                            traceFilter.FilterEventLevel = (SourceLevels)Enum.Parse(typeof(SourceLevels), args.ValueNew);
                        }

                        LeetEventTypeFilter eventFilter = this.traceSource.Listeners[EVENTLOGLISTENER].Filter as LeetEventTypeFilter;
                        if (eventFilter != null)
                        {
                            eventFilter.EventType = (SourceLevels)Enum.Parse(typeof(SourceLevels), args.ValueNew);
                        }

                        return;
                    }
                }
            }
            catch (Exception ex)
            {
                LoggingConfigurationFailedEvent evt = new LoggingConfigurationFailedEvent();
                WriteEventLog(String.Format("{0}\r\nException: {1}", "Failed to apply new settings to the logging listeners", 
                    ex.ToString()), EventLogEntryType.Error, evt.Id);
            }
        }

        private void ConfigureLogging()
        {
                //we might see exceptions when configure logging. However we will leave it to the caller to catch and handle the exceptions
                
                traceSource.Listeners.Clear(); //clear all default trace listeners.

                SourceLevels eventSourceLevel = (SourceLevels)Enum.Parse(typeof(SourceLevels), this.configurationProvider.GetSetting(Settings.EventLevel));
                TraceLevel traceSourceLevel = (TraceLevel)Enum.Parse(typeof(TraceLevel), this.configurationProvider.GetSetting(Settings.TraceLevel));

                SqlListener sqlListener = new SqlListener();
                sqlListener.Name = SQLLISTENER;
                sqlListener.Filter = new LeetTraceLevelFilter(traceSourceLevel, eventSourceLevel);

                EventLogTraceListener eventLogTraceListener = new EventLogTraceListener(configurationProvider.ComponentName);
                eventLogTraceListener.Name = EVENTLOGLISTENER;
                eventLogTraceListener.Filter = new LeetEventTypeFilter(eventSourceLevel);
                
                traceSource.Listeners.Add(sqlListener);
                traceSource.Listeners.Add(eventLogTraceListener);
                traceSource.Switch = new SourceSwitch(configurationProvider.ComponentName + ".Default", "All");
        }

        #endregion

        #region Public Methods

        public void RegisterMetadata(string name, Func<String> value)
        {
            metadata.Add(name, value);
        }

        public void LogEvent(BaseEvent evt)
        {
            LogEvent(evt, null, String.Empty);
        }

        public void LogEvent(BaseEvent evt, string formattedMessage, params object[] args)
        {
            LogEvent(evt, null, formattedMessage, args);
        }

        public void LogEvent(BaseEvent evt, Exception ex)
        {
            LogEvent(evt, ex, String.Empty);
        }

        public void LogEvent(BaseEvent evt, Exception ex, string formattedMessage, params object[] args)
        {
            string message = null;

            try
            {
                AttachMetadata(evt);
                if (formatter != null)
                {
                    // some of the calls will be with args.Length = 0
                    if (args == null || args.Length == 0) 
                    {
                        message = formatter.Format(evt, formattedMessage, ex);
                    }
                    else
                    {
                        message = formatter.Format(evt, String.Format(CultureInfo.CurrentCulture, formattedMessage, args), ex);
                    }
                }
            }

            catch (Exception e)
            {
                message = String.Format("Unable to serialize event. \r\n Event Type: {0}\r\n Event Id: {1}\r\n Event Source: {2}\r\n Exception: {3}", evt.GetType(), evt.Id, evt.Source, e.ToString());
                WriteEventLog(String.Format("{0}\r\n{1}", message, e.ToString()), EventLogEntryType.Warning, 1);
            }

            InternalLogEvent(evt, message);
        }

        public void LogTrace(TraceLevel traceLevel, string formattedMessage, params object[] args)
        {
            TraceEvent evt = new TraceEvent(traceLevel);
            LogEvent(evt, formattedMessage, args);
        }

        public void LogTrace(TraceLevel traceLevel, Exception ex)
        {
            TraceEvent evt = new TraceEvent(traceLevel);
            LogEvent(evt, ex);
        }

        public void LogTrace(TraceLevel traceLevel, Exception ex, string formattedMessage, params object[] args)
        {
            TraceEvent evt = new TraceEvent(traceLevel);
            LogEvent(evt, ex, formattedMessage, args);
        }

        public void LogTransaction(string transactionId, string transactionType, string action)
        {
            TransactionEvent evt = new TransactionEvent()
            {
                TransactionId = transactionId,
                TransactionType = transactionType,
                Action = action
            };
            LogEvent(evt);
        }

        public void LogTransaction(string transactionId, string transactionType, string action, string formattedMessage, params object[] args)
        {
            TransactionEvent evt = new TransactionEvent()
            {
                TransactionId = transactionId,
                TransactionType = transactionType,
                Action = action
            };
            LogEvent(evt, formattedMessage, args);
        }

        private void InternalLogEvent(BaseEvent evt, string message)
        {
            // check if Logging is initialized before logging
            if (Initialized)
            {
                if (String.IsNullOrEmpty(message))
                {
                    // log the fact that and 
                    WriteEventLog(String.Format("Empty or Null message provided for logging\r\nMessage:{0}\r\n{1}", message, Environment.StackTrace), EventLogEntryType.Error, 1);
                }
                else
                {
                    try
                    {
                        object[] objArray = new object[1] { evt };
                        traceSource.TraceEvent(evt.TraceEventType, evt.Id, message, objArray);
                    }
                    catch (Exception ex)
                    {
                        WriteEventLog(String.Format("Unable to log event\r\n Message:{0}\r\n{1}", message, ex.ToString()), EventLogEntryType.Error, 1);
                    }
                }
            }
            else
            {
                //if logging not initialized log the fact that logging is not initialized
                WriteEventLog(String.Format("Logging is not initialized\r\nMachine Name:{0}\r\n{1}", Environment.MachineName, Environment.StackTrace), EventLogEntryType.Error, 108);

                //See if there is valid formatted message. If so log that in the eventlog as error if not indicate a null/emplty message is being logged
                if (String.IsNullOrEmpty(message))
                {
                    WriteEventLog(String.Format("Empty or Null message provided for logging\r\nMessage:{0}\r\n{1}", message, Environment.StackTrace), EventLogEntryType.Error, 1);
                }
                else
                {
                    WriteEventLog(message, EventLogEntryType.Error, evt.Id);
                }
            }
        }

        private void AttachMetadata(BaseEvent evt)
        {
            // Ensure certain values are set by the system.
            evt.MachineName = Environment.MachineName;
            if (configurationProvider != null)
                evt.Source = configurationProvider.ComponentName;

            foreach (string name in metadata.Keys)
            {
                evt.Metadata.Add(name, metadata[name]());
            }
        }

        private void WriteEventLog(string errorMsg, EventLogEntryType entryType, int msgID)
        {
            try
            {
                String source = "Application";
                if (this.configurationProvider != null && !String.IsNullOrEmpty(configurationProvider.ComponentName))
                {
                    source = configurationProvider.ComponentName;
                }
                EventLog.WriteEntry(source, errorMsg, entryType, msgID);
            }
            catch (Exception)
            {
                //this call can be made from a background thread eat exception since we cannot do anything here
            }
        }

        #endregion

        #region Static Helpers

        public static void TraceInformation(string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Info, formattedMessage, args);
        }

        public static void TraceWarning(string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Warning, formattedMessage, args);
        }

        public static void TraceWarning(Exception ex, string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Warning, ex, formattedMessage, args);
        }

        public static void TraceError(string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Error, formattedMessage, args);
        }

        public static void TraceError(Exception ex, string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Error, ex, formattedMessage, args);
        }

        public static void TraceVerbose(string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Verbose, formattedMessage, args);
        }

        public static void TraceVerbose(Exception ex, string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Verbose, ex, formattedMessage, args);
        }

        public static void TraceException(Exception ex, string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Error, ex, formattedMessage, args);
        }

        public static void TraceException(Exception ex)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogTrace(TraceLevel.Error, ex);
        }

        public static void WriteEvent(BaseEvent evt)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(evt);
        }

        public static void WriteEvent(BaseEvent evt, string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(evt, formattedMessage, args);
        }

        public static void WriteEvent(BaseEvent evt, Exception ex)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(evt, ex);
        }

        public static void WriteEvent(BaseEvent evt, Exception ex, string formattedMessage, params object[] args)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(evt, ex, formattedMessage, args);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IO\RegistryKeyData.cs ===
﻿using Microsoft.Win32;

namespace Leet.Core.IO
{
    public class RegistryKeyData : IRegistryKeyData 
    {
        public RegistryKeyData(RegistryKey registryKey)
        {
            this.registryKey = registryKey;
        }

        #region Implementation of IRegistryKeyData

        public string Name
        {
            get { return this.RegistryKey.Name; }
        }

        public string[] GetValueNames()
        {
            return this.RegistryKey.GetValueNames();
        }

        public int ValueCount
        {
            get { return RegistryKey.ValueCount; }
        }

        public object GetValue(string valueName)
        {
            return this.RegistryKey.GetValue(valueName);
        }

        private readonly RegistryKey registryKey;
        public RegistryKey RegistryKey
        {
            get { return registryKey; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\IBehavior.cs ===
using System;

namespace Leet.Core.IoCCo
{
    public interface IBehavior
    {
        void InvokeMethod(object component, Action nextCall, ProxiedCallInfo proxiedCallInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IO\RegistryProvider.cs ===
﻿using Microsoft.Win32;

namespace Leet.Core.IO
{
    public class RegistryProvider : IRegistryProvider
    {
        #region Implementation of IRegistryProvider
        private readonly IRegistryKeyData currentUserHive = new RegistryKeyData(Registry.CurrentUser);
        public IRegistryKeyData CurrentUserHive
        {
            get { return currentUserHive; }
        }

        //TODO: get rid of this, replace with IRegistryKeyData OpenSubKey(IRegistryKeyData key, string subKeyName)
        public RegistryKey OpenSubKey(RegistryKey key, string subKeyName)
        {
            return key.OpenSubKey(subKeyName);
        }

        //TODO: get rid of this, replace with GetValue(IRegistryKeyData key, string valueName)
        public object GetValue(RegistryKey key, string valueName)
        {
            return key.GetValue(valueName);
        }

        public IRegistryKeyData GetRegistryKeyData(IRegistryKeyData hive, string keyName)
        {
            RegistryKey requestedKey = hive.RegistryKey.OpenSubKey(keyName);

            if (requestedKey == null)
            {
                return null;
            }
            return new RegistryKeyData(requestedKey);
        }

        public object GetValue(string keyName, string valueName, object defaultValue)
        {
            return Registry.GetValue(keyName, valueName, defaultValue);
        }

        public void SetValue(string registryKeyDataName, string valueName, object value)
        {
            Registry.SetValue(registryKeyDataName, valueName, value);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\Container.cs ===
﻿using System;
using System.Collections.Generic;

namespace Leet.Core.IoCCo
{
    public class Container : IContainer
    {
        private static IContainer instance = new Container();
        public static IContainer Instance { get { return instance; } }

        readonly Dictionary<Type, ComponentInfo> serviceRegistry = new Dictionary<Type, ComponentInfo>();

        public T GetComponent<T>()
        {
            return (T)GetComponent(typeof(T));
        }

        public object GetComponent(Type serviceType)
        {
            ComponentInfo componentInfo;
            try
            {
                componentInfo = serviceRegistry[serviceType];
            }
            catch (KeyNotFoundException)
            {
                throw new ServiceNotRegisteredException("Interface '" + serviceType + "' was not registered with the IoC container.");
            }

            var component = componentInfo.GetComponent();

            return component;
        }

        public void DisposeSingletons()
        {
            ComponentInfo.DisposeSingletons();
        }

        public void SetBehaviorsForService<TService>(params IBehavior[] behaviors)
        {
            SetBehaviorsForServiceInternal(typeof (TService), behaviors);
        }

        private void SetBehaviorsForServiceInternal(Type serviceType, IBehavior[] behaviors)
        {
            ComponentInfo componentInfo;
            try
            {
                componentInfo = serviceRegistry[serviceType];
            }
            catch (KeyNotFoundException)
            {
                throw new ServiceNotRegisteredException("Interface '" + serviceType + "' was not registered with the IoC container.");
            }

            componentInfo.SetServiceBehaviors(behaviors);
        }

        public void SetLifeCycleForService<TService>(LifeCycleMode lifeCycleMode)
        {
            SetLifeCycleForServiceInternal(typeof(TService), lifeCycleMode);
        }

        private void SetLifeCycleForServiceInternal(Type serviceType, LifeCycleMode lifeCycleMode)
        {
            ComponentInfo componentInfo;
            try
            {
                componentInfo = serviceRegistry[serviceType];
            }
            catch (KeyNotFoundException)
            {
                throw new ServiceNotRegisteredException("Interface '" + serviceType + "' was not registered with the IoC container.");
            }
            componentInfo.LifeCycleMode = lifeCycleMode;
        }

        public IContainer AddService<TService, TComponent>() where TComponent : TService
        {
            Type serviceType = typeof(TService);
            Type componentType = typeof(TComponent);

            return AddService(serviceType, componentType);
        }

        private IContainer AddService(Type serviceType, Type componentType)
        {
            if (serviceRegistry.ContainsKey(serviceType))
            {
                ComponentInfo componentInfo = serviceRegistry[serviceType];
                if (componentInfo.ComponentType != componentType)
                {
                    throw new ArgumentException(
                        String.Format(
                            "Attempting to register implementation of '{0}' as '{1}' but it's already registered as '{2}'.",
                            serviceType.FullName, componentType.FullName, componentInfo.ComponentType.FullName),
                        "serviceType");
                }
            }
            else
            {
                serviceRegistry.Add(serviceType, new ComponentInfo(this, serviceType, componentType));
            }

            return this;
        }

        public IContainer AddServiceWithLocator<TService, TLocator>() where TLocator : ILocator<TService> where TService : class
        {
            Type serviceType = typeof(TService);
            Type locatorType = typeof(TLocator);

            return AddService(serviceType, locatorType);
        }

        public IContainer AddServiceWithInstance<TService>(TService instance)
        {
            Type serviceType = typeof(TService);
            if (!serviceRegistry.ContainsKey(serviceType))
            {
                serviceRegistry.Add(serviceType, new ComponentInfo(this, serviceType, instance));
            }
            else
            {
                throw new InvalidOperationException(
                    String.Format("Attempting to register instance for '{0}' but it's already regsitered with '{1}'",
                    serviceType.FullName, serviceRegistry[serviceType].ComponentType.FullName));
            }

            return this;
        }

        public static void UseLocalContainer(IContainer localContainer)
        {
            instance = localContainer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\ILocator.cs ===
namespace Leet.Core.IoCCo
{
    public interface ILocator
    {
        object LocateComponent();
    }

    public interface ILocator<TService> : ILocator 
    {
        new TService LocateComponent();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\ComponentInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Web;

namespace Leet.Core.IoCCo
{
    public enum LifeCycleMode
    {
        Instance,
        Singleton,
        PerWebRequest
    }

    internal class ComponentInfo
    {
        private IContainer Container { get; set; }
        internal Type ServiceType { get; set; }
        internal Type ComponentType { get; set; }
        internal Type ProxyType { get; set; }
        internal ParameterInfo[] ConstructorParameters { get; set; }
        internal LifeCycleMode LifeCycleMode { get; set; }
        protected IBehavior[] Behaviors { get; set; }

        private delegate object InstantiatorSignature();
        private delegate object InstantiatorSignatureWithParams(object[] dependencies);
        private delegate object ProxyInstantiatorSignature(object component, object[] behaviors);
        private InstantiatorSignature InstantiatorDelegate { get; set; }
        private InstantiatorSignatureWithParams InstantiatorDelegateWithParams { get; set; }
        private ProxyInstantiatorSignature ProxyInstantiatorDelegate { get; set; }
        private object ComponentInstance { get; set; }

        internal string ComponentKey { get; private set; }

        private static readonly Dictionary<Type, object> singletonInstances = new Dictionary<Type, object>();
        private static readonly object singletonLock = new object();

        /// <summary>
        /// This constructor does the majority of the work to prepare for object creation later.
        /// Constructor structure is inspected and parameter types are cached. 
        /// The constructor then generates DynamicMethods to instantiate the component with
        /// or without parameters (two cases are hendled separately for clarity and performance).
        /// </summary>
        /// <param name="container">The container is used to resolve dependencies during creation.</param>
        /// <param name="serviceType">Type of the service.</param>
        /// <param name="componentType">Type of the component to create the wrapper for.</param>
        internal ComponentInfo(IContainer container, Type serviceType, Type componentType)
        {
            Container = container;
            ServiceType = serviceType;
            ComponentType = componentType;

            ComponentKey = String.Format(CultureInfo.InvariantCulture, "IoCCo_{0}_Instance", componentType.FullName);

            CreateInstantiatorDelegate(componentType);

            DetermineDefaultLifecycleMode();
        }

        internal ComponentInfo(IContainer container, Type serviceType, object instance) : this(container, serviceType, instance.GetType())
        {
            ComponentInstance = instance;
            // Override the Lifecycle mode.  Components with a specific instance should always be singletons.
            LifeCycleMode = LifeCycleMode.Singleton;
        }

        private void DetermineDefaultLifecycleMode()
        {
            if (HasCustomAttribute<SingletonInstanceAttribute>())
            {
                LifeCycleMode = LifeCycleMode.Singleton;
            }
            else if (HasCustomAttribute<PerWebRequestInstanceAttribute>())
            {
                LifeCycleMode = LifeCycleMode.PerWebRequest;
            }
            else
            {
                LifeCycleMode = LifeCycleMode.Instance;
            }
        }

        private void CreateInstantiatorDelegate(Type componentType)
        {
            var constructors = componentType.GetConstructors();

            if (constructors.Length != 1)
            {
                throw new ArgumentException("Components must have one and only one public constructor.", "componentType");
            }

            var constructor = constructors[0];
            var parameters = constructor.GetParameters();

            if (parameters.Length == 0)
            {
                // This is where the magic happens for parameterless construction.
                // A method is emitted and a delegate for it is created. The method simply creates a new instance
                // of the component. Later calls to the delegate are fast.
                // this is all done to avoid using Reflection at creation time (Activator specifically).
                CreateParameterlessInstantiator(componentType, constructor);
            }
            else
            {
                InstantiatorDelegate = null;

                // This is where the magic happens for construction with dependencies.
                // A method is emitted and a delegate for it is created. The method expects an array of objects.
                // It then pushes each element of the array onto the stack to be used as parameters to the constructor
                // and calls the constructor of the component. 
                // Since we know parameter count, no loop is necessary and it is unrolled.
                // this is all done to avoid using Reflection at creation time (Activator with parameters 
                // is especially expensive).
                CreateParameterizedInstantiator(componentType, constructor, parameters);
            }
        }

        private void CreateParameterizedInstantiator(Type componentType, ConstructorInfo constructor, ParameterInfo[] parameters)
        {
            var instantiatorMethod =
                new DynamicMethod("CreateInstance_Of_" + componentType.Name,
                                  componentType,
                                  new Type[] { typeof(object[]) },
                                  typeof(ComponentInfo));
            {
                var generator = instantiatorMethod.GetILGenerator();

                // the loop basicaly outputs 
                //      PUSH argumentArray[0]
                //      PUSH argumentArray[1]
                // etc...
                for (int index = 0; index < parameters.Length; index++)
                {
                    // put reference to the array onto the stack (argument 0)
                    generator.Emit(OpCodes.Ldarg_0);
                    // put next parameter index onto the stack
                    //generator.
                    generator.LoadInt32Constant(index);
                    // dereference the array (1 back on the stack) element with index on top of the stack
                    generator.Emit(OpCodes.Ldelem_Ref);
                }
                // calling the contructor puts a reference to the new onject onto the stack
                generator.Emit(OpCodes.Newobj, constructor);
                // return newly created object reference
                generator.Emit(OpCodes.Ret);
            }

            ConstructorParameters = parameters;
            InstantiatorDelegateWithParams = (InstantiatorSignatureWithParams)instantiatorMethod.CreateDelegate(typeof(InstantiatorSignatureWithParams));
        }

        private void CreateParameterlessInstantiator(Type componentType, ConstructorInfo constructor)
        {
            var instantiatorMethod = new DynamicMethod("CreateInstance", componentType, null);
            var generator = instantiatorMethod.GetILGenerator();

            // calling the contructor puts a reference to the new onject onto the stack
            generator.Emit(OpCodes.Newobj, constructor);
            // return newly created object reference
            generator.Emit(OpCodes.Ret);

            InstantiatorDelegate = (InstantiatorSignature)instantiatorMethod.CreateDelegate(typeof(InstantiatorSignature));
        }

        private void CreateProxyInstantiator()
        {
            var constructor = ProxyType.GetConstructor(new Type[] {ServiceType, typeof (IBehavior[])});

            var instantiatorMethod =
                new DynamicMethod("CreateProxyInstance",
                                  ProxyType,
                                  new Type[] {typeof (object), typeof (object[])},
                                  typeof (ComponentInfo));
            {
                var generator = instantiatorMethod.GetILGenerator();

                generator.Emit(OpCodes.Ldarg_0);
                generator.Emit(OpCodes.Ldarg_1);
                // calling the contructor puts a reference to the new onject onto the stack
                generator.Emit(OpCodes.Newobj, constructor);
                // return newly created object reference
                generator.Emit(OpCodes.Ret);
            }

            ProxyInstantiatorDelegate = (ProxyInstantiatorSignature)instantiatorMethod.CreateDelegate(typeof(ProxyInstantiatorSignature));
        }

        private bool HasCustomAttribute<T>() where T : Attribute
        {
            if (ComponentType.GetCustomAttributes(typeof(T), false).Length > 0)
            {
                return true;
            }
            return false;
        }

        private object GetObjectInstance()
        {
            object instance;

            if (ComponentInstance != null)
            {
                instance = ComponentInstance;
            }
            else if (InstantiatorDelegate != null)
            {
                instance = InstantiatorDelegate();
            }
            else
            {
                var parameters = ConstructorParameters;
                var parameterValues = new object[parameters.Length];
                for (int index = 0; index < parameters.Length; index++)
                {
                    parameterValues[index] = Container.GetComponent(parameters[index].ParameterType);
                } 
                instance = InstantiatorDelegateWithParams(parameterValues);
            }

            var locator = instance as ILocator;

            if (locator != null)
            {
                instance = locator.LocateComponent();
            }

            if (ProxyType != null)
            {
                instance = ProxyInstantiatorDelegate(instance, Behaviors);
            }
            return instance;
        }

        private object GetPerWebRequestInstance()
        {
            if (HttpContext.Current.Items[ComponentKey] == null)
            {
                lock (singletonLock)
                {
                    if (HttpContext.Current.Items[ComponentKey] == null)
                    {
                        object instance = GetObjectInstance();
                        HttpContext.Current.Items[ComponentKey] = instance;
                        return instance;
                    }
                }
            }
            return HttpContext.Current.Items[ComponentKey];
        }

        private object GetSingletonInstance()
        {
            if (!singletonInstances.ContainsKey(ComponentType))
            {
                lock (singletonLock)
                {
                    if (!singletonInstances.ContainsKey(ComponentType))
                    {
                        object instance = GetObjectInstance();
                        singletonInstances.Add(ComponentType, instance);
                        return instance;
                    }
                }
            }
            return singletonInstances[ComponentType];
        }

        public object GetComponent()
        {
            if (LifeCycleMode == LifeCycleMode.Singleton)
            {
                return GetSingletonInstance();
            }
            if (LifeCycleMode == LifeCycleMode.PerWebRequest)
            {
                return GetPerWebRequestInstance();
            }
            return GetObjectInstance();
        }

        internal static void DisposeSingletons()
        {
            lock (singletonLock)
            {
                foreach (var singletonInstance in singletonInstances)
                {
                    var disposable = singletonInstance.Value as IDisposable;
                    if (disposable != null)
                    {
                        disposable.Dispose();
                    }
                }
                singletonInstances.Clear();
            }
        }

        internal void SetServiceBehaviors(IBehavior[] behaviors)
        {
            if (ProxyType == null)
            {
                GenerateProxyType();
            }

            Behaviors = behaviors;
        }

        private void GenerateProxyType()
        {
            if (ComponentType.GetInterfaces().Any(i => i.FullName == typeof(ILocator).FullName) == false)
            {
                ProxyType = DynamicProxyGenerator.CreateInterfaceProxy(ServiceType, ComponentType);
            } 
            else
            {
                ProxyType = DynamicProxyGenerator.CreateInterfaceProxy(ServiceType, null);
                
            }
            CreateProxyInstantiator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\ILHelpers.cs ===
﻿using System.Reflection.Emit;

namespace Leet.Core.IoCCo
{
    internal static class ILHelpers
    {
        public static void LoadInt32Constant(this ILGenerator generator, int constant)
        {
            switch (constant)
            {
                case 0:
                    generator.Emit(OpCodes.Ldc_I4_0);
                    break;
                case 1:
                    generator.Emit(OpCodes.Ldc_I4_1);
                    break;
                case 2:
                    generator.Emit(OpCodes.Ldc_I4_2);
                    break;
                case 3:
                    generator.Emit(OpCodes.Ldc_I4_3);
                    break;
                case 4:
                    generator.Emit(OpCodes.Ldc_I4_4);
                    break;
                case 5:
                    generator.Emit(OpCodes.Ldc_I4_5);
                    break;
                case 6:
                    generator.Emit(OpCodes.Ldc_I4_6);
                    break;
                case 7:
                    generator.Emit(OpCodes.Ldc_I4_7);
                    break;
                case 8:
                    generator.Emit(OpCodes.Ldc_I4_8);
                    break;
                default:
                    generator.Emit(OpCodes.Ldc_I4, constant);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\IContainer.cs ===
﻿using System;

namespace Leet.Core.IoCCo
{
    public interface IContainer
    {
        IContainer AddService<TService, TComponent>() where TComponent : TService;
        IContainer AddServiceWithLocator<TService, TLocator>()
            where TLocator : ILocator<TService>
            where TService : class;
        IContainer AddServiceWithInstance<TService>(TService instance);
        T GetComponent<T>();
        object GetComponent(Type serviceType);
        void DisposeSingletons();
        void SetBehaviorsForService<TService>(params IBehavior[] behaviors);
        void SetLifeCycleForService<TService>(LifeCycleMode lifeCycleMode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\IoC.cs ===
namespace Leet.Core.IoCCo
{
    public static class IoC
    {
        public static TService Get<TService>()
        {
            return Container.Instance.GetComponent<TService>();
        }

        public static IServiceRegistrationOptions<TService> Register<TService, TComponent>() where TComponent : TService
        {
            Container.Instance.AddService<TService, TComponent>();

            return new ServiceRegistrationOptions<TService>();
        }

        public static void RegisterWithInstance<TService>(TService instance)
        {
            Container.Instance.AddServiceWithInstance<TService>(instance);
        }

        public static void RegisterWithLocator<TService, TLocator>()
            where TLocator : ILocator<TService>
            where TService : class
        {
            Container.Instance.AddServiceWithLocator<TService, TLocator>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\IServiceRegistrationOptions.cs ===
namespace Leet.Core.IoCCo
{
    public interface IServiceRegistrationOptions<TService>
    {
        IServiceRegistrationOptions<TService> With<TBehavior>() where TBehavior : IBehavior, new();
        IServiceRegistrationOptions<TService> WithLifeCycleMode(LifeCycleMode lifeCycleMode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\PerWebRequestInstanceAttribute.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo
{
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class PerWebRequestInstanceAttribute : Attribute
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\InterfaceProxyBase.cs ===
using System;

namespace Leet.Core.IoCCo
{
    public class MethodInvokeResult
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        public object Result;
    }

    public class InterfaceProxyBase<TService>
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        protected TService Component;
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        protected IBehavior[] Behaviors;

        public InterfaceProxyBase(TService component, IBehavior[] behaviors)
        {
            Component = component;
            Behaviors = behaviors;
        }

        protected void WrapAndCall(Action call, ProxiedCallInfo callInfo)
        {
            Action wrappedCall = call;
            if (Behaviors != null && Behaviors.Length > 0)
            {
                wrappedCall = WrapACall(0, call, callInfo);
            }
            wrappedCall();
        }

        private Action WrapACall(int behaviorIndex, Action call, ProxiedCallInfo callInfo)
        {
            if (behaviorIndex == Behaviors.Length - 1)
            {
                return () => Behaviors[behaviorIndex].InvokeMethod(Component, call, callInfo);
            }
            return () => Behaviors[behaviorIndex].InvokeMethod(Component, WrapACall(behaviorIndex + 1, call, callInfo), callInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\ProxiedCallInfo.cs ===
﻿using System;
using System.Reflection;

namespace Leet.Core.IoCCo
{
    public abstract class ProxiedCallInfo
    {
        public abstract object Component { get; }
        public abstract object ReturnValue { get; }
        public abstract object[] MethodAttributes { get; }
        public abstract MethodInfo SourceMethod { get; }
        public abstract MethodInfo TargetMethod { get; }
        public abstract ParameterInfo[] TargetMethodParameters { get; }

        public abstract object[] GetArguments();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\DynamicProxyGenerator.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace Leet.Core.IoCCo
{
    public static class DynamicProxyGenerator
    {
        /// <summary>
        /// Generates a new <see cref="System.Type"/> that implements an interface specified by the interfaceType parameter.
        /// <para>
        /// This function emits a new dynamic assembly, module and a set of classes. The main emitted class is the proxy around another object
        /// and implements the interface specified by the interfaceType parameter. 
        /// The proxy class derives from the <see cref="InterfaceProxyBase{TService}"/> class which stores references to the wrapped
        /// component in the <see cref="InterfaceProxyBase{TService}.Component"/> field and a list of behaviors to wrap the call with in
        /// the <see cref="InterfaceProxyBase{TService}.Behaviors"/> field.
        /// </para>
        /// </summary>
        /// <param name="interfaceType"> <see cref="System.Type"/> representing the interface to create a proxy for.</param>
        /// <param name="targetType"> <see cref="System.Type"/> representing the type of the intended proxy target.</param>
        /// <remarks>
        /// <para>
        /// The basic structure of each interface member is as follows:
        /// 
        /// <code>
        /// ...
        /// // for members that have void return type
        /// public void MemberName(parameters)
        /// {
        ///     var call = () => { Component.MemberName(parameters); };
        ///     WrapAndCall(call);
        /// }
        /// 
        /// // for members that return a value
        /// public T MemberName(parameters)
        /// {
        ///     var result = new MethodInvokeResult();
        ///     var call = () => { result.Result = Component.MemberName(parameters); };
        ///     WrapAndCall(call);
        ///     retrun reult.Result
        /// }
        /// ...
        /// </code>
        /// </para>
        /// </remarks>
        /// <returns></returns>
        public static Type CreateInterfaceProxy(Type interfaceType, Type targetType)
        {
            if (!interfaceType.IsInterface)
            {
                throw new ArgumentException("Creation of proxies is supported for Interface types only.", "interfaceType");
            }

            // the context is used to pass values around and to simplify the signatures for methods
            var context = new ProxyGenerationContext(interfaceType, targetType);

            InitializeProxyGenerationContext(interfaceType, context);

            // define dynamic assembly, module and the proxy type
            CreateProxyTypeBuilder(context);

            // the proxy class needs a contructor with 2 parameters (wrapped object and set of behaviors) that is a base
            // class constructor passthrough.
            DefineProxyConstructor(context);

            foreach (var memberInfo in GetMembersToProxy(interfaceType))
            {
                GenerateProxyMemberDefinition(context, memberInfo);
            }

            var type = context.typeBuilder.CreateType();

            return type;
        }

        public static Type CreateInterfaceProxy(Type interfaceType)
        {
            return CreateInterfaceProxy(interfaceType, null);
        }

        private static IEnumerable<MemberInfo> GetMembersToProxy(Type interfaceType)
        {
            var inheritedMembers = interfaceType.GetInterfaces().SelectMany(iface => iface.GetMembers());
            return interfaceType.GetMembers().Union(inheritedMembers).ToArray();
        }

        private static void InitializeProxyGenerationContext(Type interfaceType, ProxyGenerationContext context)
        {
            // build up the type of the proxy class' base class.
            // this is equivalent to typeof(InterfaceProxyBase<TService>)
            context.proxyBaseClass = typeof(InterfaceProxyBase<>).MakeGenericType(interfaceType);

            // store pointers to some well known fields/methods
            context.proxyBaseComponentField = context.proxyBaseClass.GetField("Component", BindingFlags.NonPublic | BindingFlags.Instance);
            context.proxyBaseWrapACallMethod = context.proxyBaseClass.GetMethod("WrapAndCall", BindingFlags.NonPublic | BindingFlags.Instance);
            context.methodInvokeResult_ResultField = typeof(MethodInvokeResult).GetField("Result",
                                                                                         BindingFlags.Public |
                                                                                         BindingFlags.Instance);
        }

        private static void GenerateProxyMemberDefinition(ProxyGenerationContext context, MemberInfo memberInfo)
        {
            switch (memberInfo.MemberType)
            {
                case MemberTypes.Method:
                    // Everything in an interface is really a method. Properties and events have get_/set_ and add_/remove_ accessors
                    // so most of the work is done here
                    GenerateMethodProxy(context, memberInfo);
                    break;

                case MemberTypes.Property:
                    var propertyInfo = (PropertyInfo)memberInfo;
                    context.typeBuilder.DefineProperty(propertyInfo.Name,
                                                       propertyInfo.Attributes,
                                                       propertyInfo.PropertyType,
                                                       propertyInfo.GetIndexParameters()
                                                           .Select(pi => pi.ParameterType)
                                                           .ToArray());
                    break;
                case MemberTypes.Event:
                    var eventInfo = (EventInfo)memberInfo;
                    context.typeBuilder.DefineEvent(eventInfo.Name,
                                                    eventInfo.Attributes,
                                                    eventInfo.EventHandlerType);
                    break;
                default:
                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "'{0}' member type is not yet supported.", memberInfo.MemberType));
            }
        }

        private static void GenerateMethodProxy(ProxyGenerationContext context, MemberInfo memberInfo)
        {
            // To completely understand how this works you will need some familiarity how lambda funtions and closures are implemented.
            // This essentially creates another class which is used to store all parameters passed into the method as well as the result.
            // The effect of closure is achieved by instantiating this class and using it's fields to pass around
            // the variables used in a lambda expressions. Basic structure of an enclosure class is as follows:
            //
            // public sealed closure_for_#MemberName#_#GUID1#
            // {
            //      public TService Component_#GUID2#;
            //      public MethodInvokeResult Result_#GUID3#;
            //      public TParam1 param1;
            //      public TParam2 param2;
            //      ...
            //      public void #MemberName#_#GUID4#()
            //      {
            //          Result_#GUID3#.Result = Component_#GUID2#.#MemberName#(param1, param2, ...);
            //      }
            //  }
            //
            // The Result is only emitted and is only used if the wrapped method is not void

            var methodInfo = (MethodInfo)memberInfo;
            var parameterInfos = methodInfo.GetParameters();

            var closureFields = new Dictionary<ParameterInfo, FieldInfo>();

            // define the closure class
            GenerateClosureType(methodInfo, context, parameterInfos, closureFields);

            // if the method was generic, then the closure class is generic as well. 
            // we then need to update all calls into the closure class to use the method's generic parameters.
            if (methodInfo.IsGenericMethod)
            {
                closureFields = UpdateClosureReferencesForGenericMethod(methodInfo, context, closureFields);
            }

            // define method
            MethodBuilder methodBuilder = GenerateWrapperMethodIL(methodInfo, context, parameterInfos, closureFields);
            context.typeBuilder.DefineMethodOverride(methodBuilder, methodInfo);
        }

        private static void GenerateClosureType(MethodInfo methodInfo, ProxyGenerationContext context, ParameterInfo[] parameterInfos, Dictionary<ParameterInfo, FieldInfo> closureFields)
        {
            MatchToTargetMethodIfNecessary(methodInfo, context);

            var id = GetGuidBasedId();
            var closureDataClassName = "ClosureData_for_" + methodInfo.Name + "_" + id;
            var closureClassName = "Closure_for_" + methodInfo.Name + "_" + id;

            Type closureDataClassType = GenerateClosureDataType(context, closureDataClassName);

            SetClosureDataClassValues(methodInfo, context, closureDataClassType);

            var closureClassBuilder =
                context.dynamicModule.DefineType(
                    closureClassName,
                    TypeAttributes.Sealed | TypeAttributes.Public,
                    typeof(ProxiedCallInfo));
            {
                GenericTypeParameterBuilder[] nestedGenericParameterTypes = null;
                if (methodInfo.IsGenericMethod)
                {
                    nestedGenericParameterTypes = CloneGenericParameters(methodInfo, "P_", closureClassBuilder.DefineGenericParameters);
                }

                // gotta have a default constructor
                context.nestedConstructor = closureClassBuilder.DefineDefaultConstructor(MethodAttributes.Public);
                // create a filed to store the refernece to the proxied component
                context.nestedComponentField = closureClassBuilder.DefineField("Component_" + GetGuidBasedId(),
                                                                               context.interfaceType,
                                                                               FieldAttributes.Public);
                // create a field for each parameter to the proxied function
                var parameterNumber = 0;
                foreach (var parameterInfo in parameterInfos)
                {
                    var parameterType = parameterInfo.ParameterType;
                    if (methodInfo.IsGenericMethod && parameterType.IsGenericParameter)
                    {
                        var type = parameterType;
                        parameterType =
                            nestedGenericParameterTypes.Where(gpt => gpt.Name == "P_" + type.Name).First();
                    }
                    var closureField = closureClassBuilder.DefineField("parameter_" + parameterNumber,
                                                                       parameterType,
                                                                       FieldAttributes.Public);
                    closureFields.Add(parameterInfo, closureField);

                    parameterNumber++;
                }

                // create a field to store the MethodInvokeResult
                context.nestedResultField = closureClassBuilder.DefineField("Result_" + GetGuidBasedId(),
                                                                            typeof(MethodInvokeResult),
                                                                            FieldAttributes.Public);

                // create the method to call the proxied method on the Component
                CreateProxyCallToComponentMethod(methodInfo, context, closureClassBuilder, parameterInfos, nestedGenericParameterTypes, closureFields);

                // implement GetArguments() from base abstract ProxiedCallInfo
                ImplementGetArgumentsMethod(methodInfo, closureClassBuilder, parameterInfos, nestedGenericParameterTypes, closureFields);

                ImplementAbstractMembersFromBaseClass(context, closureClassBuilder);
            }
            context.closureType = closureClassBuilder.CreateType();
        }

        private static void ImplementAbstractMembersFromBaseClass(ProxyGenerationContext context, TypeBuilder closureClassBuilder)
        {
            // implement get_Component from base abstract ProxiedCallInfo
            ImplementComponentProperty(context, closureClassBuilder);

            // implement get_ReturnValue from base abstract ProxiedCallInfo
            ImplementReturnValueProperty(context, closureClassBuilder);

            // implement GetTargetAttributes() from base abstract ProxiedCallInfo
            ImplementClosureDataAccessorField(closureClassBuilder, "get_MethodAttributes", typeof(object[]), context.targetAttributesField);

            // implement get_SourceMethod from base abstract ProxiedCallInfo
            ImplementClosureDataAccessorField(closureClassBuilder, "get_SourceMethod", typeof(MethodInfo), context.sourceMethodField);

            // implement get_TargetMethod from base abstract ProxiedCallInfo
            ImplementClosureDataAccessorField(closureClassBuilder, "get_TargetMethod", typeof(MethodInfo), context.targetMethodField);

            // implement get_TargetMethodParameters from base abstract ProxiedCallInfo
            ImplementClosureDataAccessorField(closureClassBuilder, "get_TargetMethodParameters", typeof(ParameterInfo[]), context.targetMethodParametersField);
        }

        private static void SetClosureDataClassValues(MethodInfo methodInfo, ProxyGenerationContext context, Type closureDataClassType)
        {
            closureDataClassType.GetField("targetAttributes").SetValue(null, GetTargetMethodAttributes(context, methodInfo));
            closureDataClassType.GetField("sourceMethod").SetValue(null, methodInfo);
            closureDataClassType.GetField("targetMethod").SetValue(null, context.targetMethod);
            if (context.targetMethod != null)
            {
                closureDataClassType
                    .GetField("targetMethodParameters")
                    .SetValue(null, context.targetMethod.GetParameters());
            }
        }

        private static Type GenerateClosureDataType(ProxyGenerationContext context, string closureDataClassName)
        {
            var closureDataClassBuilder = 
                context.dynamicModule.DefineType(
                    closureDataClassName,
                    TypeAttributes.Sealed | TypeAttributes.Public,
                    typeof(object));
            {
                context.targetAttributesField =
                    closureDataClassBuilder.DefineField("targetAttributes",
                                                        typeof(object[]),
                                                        FieldAttributes.Static | FieldAttributes.Public);

                context.sourceMethodField =
                    closureDataClassBuilder.DefineField("sourceMethod",
                                                        typeof(MethodInfo),
                                                        FieldAttributes.Static | FieldAttributes.Public);

                context.targetMethodField =
                    closureDataClassBuilder.DefineField("targetMethod",
                                                        typeof(MethodInfo),
                                                        FieldAttributes.Static | FieldAttributes.Public);

                context.targetMethodParametersField =
                    closureDataClassBuilder.DefineField("targetMethodParameters",
                                                        typeof(ParameterInfo[]),
                                                        FieldAttributes.Static | FieldAttributes.Public);
            }

            return closureDataClassBuilder.CreateType();
        }

        private static void MatchToTargetMethodIfNecessary(MethodInfo methodInfo, ProxyGenerationContext context)
        {
            if (context.targetType == null)
            {
                context.targetMethod = null;
            }
            else
            {
                context.targetMethod = MatchMethodOnTargetType(context.interfaceType, context.targetType, methodInfo);
            }
        }

        private static MethodInfo MatchMethodOnTargetType(Type sourceType, Type targetType, MethodInfo methodInfo)
        {
            var members =
                targetType.GetMembers();

            var matchingMethods = members.OfType<MethodInfo>().Where(m =>
                                                                     m.Name == methodInfo.Name &&
                                                                     DoMethodSignaturesMatch(m, methodInfo));

            if (matchingMethods.Count() == 0)
            {
                throw new ArgumentException(
                    String.Format(
                        "Error matching a method on target for '{0}'->'{1}'. No target method on '{2}' matched the source method. This most likely indicates a deficiency in the Dynamic Proxy method matching logic.",
                        sourceType.FullName, methodInfo.Name, targetType.FullName));
            }

            if (matchingMethods.Count() > 1)
            {
                throw new ArgumentException(
                    String.Format(
                        "Error matching a method on target for '{0}'->'{1}'. More than one target method on '{2}' matched the source method. This most likely indicates a deficiency in the Dynamic Proxy method matching logic.",
                        sourceType.FullName, methodInfo.Name, targetType.FullName));
            }

            return matchingMethods.First();
        }

        private static void ImplementClosureDataAccessorField(TypeBuilder closureClassBuilder, string methodName, Type returnType, FieldBuilder field)
        {
            var getTargetAttributesMethod =
                closureClassBuilder.DefineMethod(methodName,
                                                 MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final,
                                                 returnType,
                                                 Type.EmptyTypes);
            {
                var generator = getTargetAttributesMethod.GetILGenerator();

                generator.Emit(OpCodes.Ldsfld, field);
                generator.Emit(OpCodes.Ret);
            }
        }

        private static object[] GetTargetMethodAttributes(ProxyGenerationContext context, MethodInfo methodInfo)
        {
            if (context.targetType == null)
            {
                return null;
            }

            return context.targetMethod.GetCustomAttributes(true).Union(methodInfo.GetCustomAttributes(true)).ToArray();
        }

        private static bool DoMethodSignaturesMatch(MethodInfo targetMethod, MethodInfo sourceMethod)
        {
            return
                targetMethod.Name == sourceMethod.Name &&
                targetMethod.ReturnType.FullName == sourceMethod.ReturnType.FullName &&
                sourceMethod
                    .GetParameters()
                    .OrderBy(p => p.Position)
                    .IsEqualTo(targetMethod.GetParameters().OrderBy(p => p.Position),
                               (sourceParameter, targetParameter) =>
                               sourceParameter.Name == targetParameter.Name &&
                               sourceParameter.ParameterType.FullName == targetParameter.ParameterType.FullName);
        }

        public static bool IsEqualTo<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> target, Func<TSource, TSource, bool> comparer)
        {
            var sourceArray = source.ToArray();
            var targetArray = source.ToArray();

            if (sourceArray.Length != targetArray.Length)
            {
                return false;
            }

            for (int position = 0; position < sourceArray.Length; position++)
            {
                if (!comparer(sourceArray[position], targetArray[position]))
                {
                    return false;
                }
            }

            return true;
        }

        private static void CreateProxyCallToComponentMethod(MethodInfo methodInfo, ProxyGenerationContext context, TypeBuilder closureClassBuilder, ParameterInfo[] parameterInfos, GenericTypeParameterBuilder[] nestedGenericParameterTypes, Dictionary<ParameterInfo, FieldInfo> closureFields)
        {
            context.nestedCallToProxiedComponent =
                closureClassBuilder.DefineMethod(methodInfo.Name + "_" + GetGuidBasedId(),
                                                 MethodAttributes.Public,
                                                 typeof(void),
                                                 Type.EmptyTypes);
            {
                var nestedCallGenerator = (context.nestedCallToProxiedComponent as MethodBuilder).GetILGenerator();
                    
                if (methodInfo.ReturnType != typeof (void))
                {
                    // put the MethodInvokeResult instance from the Result field on the stack. 
                    // This is needed later to store the result value in there.
                    nestedCallGenerator.Emit(OpCodes.Ldarg_0);
                    nestedCallGenerator.Emit(OpCodes.Ldfld, context.nestedResultField);
                }
                // put the Component on the stack so we can make a call on it
                nestedCallGenerator.Emit(OpCodes.Ldarg_0);
                nestedCallGenerator.Emit(OpCodes.Ldfld, context.nestedComponentField);
                // put all arguments onto the stack to prepare for the call
                foreach (var parameterInfo in parameterInfos)
                {
                    nestedCallGenerator.Emit(OpCodes.Ldarg_0);
                    nestedCallGenerator.Emit(OpCodes.Ldfld, closureFields[parameterInfo]);
                }
                // call the proxied call
                if (methodInfo.IsGenericMethod)
                {
                    var nestedGenericCall = methodInfo.MakeGenericMethod(nestedGenericParameterTypes);
                    nestedCallGenerator.Emit(OpCodes.Callvirt, nestedGenericCall);
                }
                else
                {
                    nestedCallGenerator.Emit(OpCodes.Callvirt, methodInfo);
                }

                if (methodInfo.ReturnType != typeof (void))
                {
                    // now store result of last call into Result field of MethodInvokeResult instance that was put on the stack before
                    if (methodInfo.ReturnType.IsValueType)
                    {
                        nestedCallGenerator.Emit(OpCodes.Box, methodInfo.ReturnType);
                    }
                    nestedCallGenerator.Emit(OpCodes.Stfld,
                                             context.methodInvokeResult_ResultField);
                }
                // and return
                nestedCallGenerator.Emit(OpCodes.Ret);
            }
        }

        private static void ImplementGetArgumentsMethod(MethodInfo methodInfo, TypeBuilder closureClassBuilder, ParameterInfo[] parameterInfos, GenericTypeParameterBuilder[] nestedGenericParameterTypes, Dictionary<ParameterInfo, FieldInfo> closureFields)
        {
            var getArgumentsMethod =
                closureClassBuilder.DefineMethod("GetArguments",
                                                 MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final,
                                                 typeof(object[]),
                                                 Type.EmptyTypes);
            {
                var nestedCallGenerator = getArgumentsMethod.GetILGenerator();

                nestedCallGenerator.DeclareLocal(typeof(object[]));
                nestedCallGenerator.LoadInt32Constant(parameterInfos.Length);
                nestedCallGenerator.Emit(OpCodes.Newarr, typeof(object));
                nestedCallGenerator.Emit(OpCodes.Stloc_0);

                var parameterNumber = 0;
                foreach (var parameterInfo in parameterInfos)
                {
                    nestedCallGenerator.Emit(OpCodes.Ldloc_0);
                    nestedCallGenerator.LoadInt32Constant(parameterNumber);
                    nestedCallGenerator.Emit(OpCodes.Ldarg_0);
                    nestedCallGenerator.Emit(OpCodes.Ldfld, closureFields[parameterInfo]);

                    if (parameterInfo.ParameterType.IsValueType)
                    {
                        nestedCallGenerator.Emit(OpCodes.Box, parameterInfo.ParameterType);
                    }
                    else if (methodInfo.IsGenericMethod && parameterInfo.ParameterType.IsGenericParameter)
                    {
                        var parameterType =
                            nestedGenericParameterTypes.First(gpt => gpt.Name == "P_" + parameterInfo.ParameterType.Name);
                        nestedCallGenerator.Emit(OpCodes.Box, parameterType);
                    }

                    nestedCallGenerator.Emit(OpCodes.Stelem_Ref);

                    parameterNumber++;
                }

                nestedCallGenerator.Emit(OpCodes.Ldloc_0);

                nestedCallGenerator.Emit(OpCodes.Ret);
            }
        }

        private static void ImplementReturnValueProperty(ProxyGenerationContext context, TypeBuilder closureClassBuilder)
        {
            var getReturnValueMethod =
                closureClassBuilder.DefineMethod("get_ReturnValue",
                                                 MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final,
                                                 typeof(object),
                                                 Type.EmptyTypes);
            {
                var nestedCallGenerator = getReturnValueMethod.GetILGenerator();

                // return this.Result_#GUID#.Result;

                nestedCallGenerator.DeclareLocal(typeof(object));

                // put the MethodInvokeResult instance from the Result field on the stack. 
                nestedCallGenerator.Emit(OpCodes.Ldarg_0);                                        // this
                nestedCallGenerator.Emit(OpCodes.Ldfld, context.nestedResultField);               // .Result_#GUID#
                nestedCallGenerator.Emit(OpCodes.Ldfld, context.methodInvokeResult_ResultField);  // .Result_#GUID#

                nestedCallGenerator.Emit(OpCodes.Ret);
            }
        }

        private static void ImplementComponentProperty(ProxyGenerationContext context, TypeBuilder closureClassBuilder)
        {
            var getComponentMethod =
                closureClassBuilder.DefineMethod("get_Component",
                                                 MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final,
                                                 typeof (object),
                                                 Type.EmptyTypes);
            {
                var nestedCallGenerator = getComponentMethod.GetILGenerator();

                // return this.Component;
                nestedCallGenerator.Emit(OpCodes.Ldarg_0);                              // this
                nestedCallGenerator.Emit(OpCodes.Ldfld, context.nestedComponentField);  // .Component_#GUID#

                nestedCallGenerator.Emit(OpCodes.Ret);
            }
        }

        private static GenericTypeParameterBuilder[] CloneGenericParameters(MethodInfo methodInfo, string prefix, Func<string[], GenericTypeParameterBuilder[]> lambdaDefineGenericParameters)
        {
            var methodGenericArguments = methodInfo.GetGenericArguments();
            var genericParameterNames =
                methodGenericArguments.Select(gpt => prefix + gpt.Name).ToArray();
            var genericParameterTypes = lambdaDefineGenericParameters(genericParameterNames);

            return genericParameterTypes;
        }

        private static MethodBuilder GenerateWrapperMethodIL(MethodInfo methodInfo, ProxyGenerationContext context, ParameterInfo[] parameterInfos, Dictionary<ParameterInfo, FieldInfo> closureFields)
        {
            var methodBuilder =
                context.typeBuilder.DefineMethod(
                    methodInfo.Name,
                    methodInfo.Attributes & ~MethodAttributes.Abstract, // original attributes but drop Abstract (original AND NOT Abstract)
                    methodInfo.ReturnType,
                    parameterInfos
                        .Select(parameterInfo => parameterInfo.ParameterType)
                        .ToArray());
            {
                if (methodInfo.IsGenericMethod)
                {
                    CloneGenericParameters(methodInfo, "I_", methodBuilder.DefineGenericParameters);
                }

                var generator = methodBuilder.GetILGenerator();

                // declare locals
                generator.DeclareLocal(typeof(Action));                 // [0] Action call
                generator.DeclareLocal(typeof(Action));                 // [1] Action wrappedCall
                generator.DeclareLocal(context.closureType);            // [2] TClosure closure
                generator.DeclareLocal(typeof(MethodInvokeResult));     // [3] MethodInvokeResult result

                // create result class                                  result = new MethodInvokeResult();
                
                generator.Emit(OpCodes.Newobj, typeof(MethodInvokeResult).GetConstructors()[0]);
                generator.Emit(OpCodes.Stloc_3);

                // create the closure class and populate its fields     closure = new TClosure();
                
                generator.Emit(OpCodes.Newobj, context.nestedConstructor); // new nested_closure_class();
                generator.Emit(OpCodes.Stloc_2); // closure = <result from above>

                // set Component to point at proxy class' Component 
                // field as inherited from ProxyBase                    closure.Component_#GUID# = this.Component;
                generator.Emit(OpCodes.Ldloc_2); // closure
                generator.Emit(OpCodes.Ldarg_0); // { this
                generator.Emit(OpCodes.Ldfld, context.proxyBaseComponentField); //      .Component }
                generator.Emit(OpCodes.Stfld, context.nestedComponentField);
                // .Component_##### = <result from above>
                
                // map arguments to input fields                        closure.argumentN = argumentN
                var argumentCounter = 1;
                foreach (var parameterInfo in parameterInfos)
                {
                    generator.Emit(OpCodes.Ldloc_2); // put reference to closure on the stack
                    generator.Emit(OpCodes.Ldarg, argumentCounter); // put next argument on the stack
                    generator.Emit(OpCodes.Stfld, closureFields[parameterInfo]); // set closure field to value

                    argumentCounter++;
                }

                // set result field to point at our result local        closure.result = result;
                generator.Emit(OpCodes.Ldloc_2); // closure
                generator.Emit(OpCodes.Ldloc_3); // reult
                generator.Emit(OpCodes.Stfld, context.nestedResultField); // closure.Result = result

                // create a delegate for nested call                    call = new Action(closure.nestedCallToProxiedComponent);
                // put closure on the stack
                generator.Emit(OpCodes.Ldloc_2);
                // put the pointer to the proxy method on stack
                generator.Emit(OpCodes.Ldftn, context.nestedCallToProxiedComponent);
                // create an Action pointing at that method
                generator.Emit(OpCodes.Newobj,
                               typeof(Action).GetConstructor(new Type[] { typeof(object), typeof(IntPtr) }));
                // store the action in local variable
                generator.Emit(OpCodes.Stloc_0);

                // call WrapAndCall                                     WrapAndCall(call, closure);
                // put 'this' pointer on the stack
                generator.Emit(OpCodes.Ldarg_0);
                // put 'call' local variable on  the stack
                generator.Emit(OpCodes.Ldloc_0);
                // put 'closure' on the stack
                generator.Emit(OpCodes.Ldloc_2);
                // call into 'WrapAndCall' which is inherited form the base class
                generator.Emit(OpCodes.Callvirt, context.proxyBaseWrapACallMethod);

                if (methodInfo.ReturnType != typeof(void))
                {
                    // if method is not void                            return result.Result;
                    generator.Emit(OpCodes.Ldloc_3);
                    generator.Emit(OpCodes.Ldfld, context.methodInvokeResult_ResultField);
                    if (methodInfo.ReturnType.IsValueType)
                    {
                        generator.Emit(OpCodes.Unbox_Any, methodInfo.ReturnType);
                    }
                }

                generator.Emit(OpCodes.Ret);
            }
            return methodBuilder;
        }

        private static Dictionary<ParameterInfo, FieldInfo> UpdateClosureReferencesForGenericMethod(MethodInfo methodInfo, ProxyGenerationContext context, Dictionary<ParameterInfo, FieldInfo> closureFields)
        {
            context.closureType = context.closureType.MakeGenericType(methodInfo.GetGenericArguments());

            context.nestedConstructor = context.closureType.GetConstructors()[0];
            context.nestedCallToProxiedComponent = context.closureType.GetMethod(context.nestedCallToProxiedComponent.Name);
            context.nestedComponentField = context.closureType.GetField(context.nestedComponentField.Name);
            var closureGenericFields = new Dictionary<ParameterInfo, FieldInfo>();
            foreach (var closureField in closureFields)
            {
                closureGenericFields.Add(closureField.Key, context.closureType.GetField(closureField.Value.Name));
            }
            closureFields = closureGenericFields;
            context.nestedResultField = context.closureType.GetField(context.nestedResultField.Name);
            return closureFields;
        }

        private static string GetGuidBasedId()
        {
            return Guid.NewGuid().ToString("N");
        }

        private static void CreateProxyTypeBuilder(ProxyGenerationContext context)
        {
            context.assemblyName = "proxyAssembly_" + context.interfaceType.Name + "_" + GetGuidBasedId();
            context.moduleName = "proxyModule_" + context.interfaceType.Name + "_" + GetGuidBasedId();
            context.typeName = "proxy_" + context.interfaceType.Name + "_" + GetGuidBasedId();

            var appDomain = AppDomain.CurrentDomain;
            context.dynamicAssembly = appDomain.DefineDynamicAssembly(new AssemblyName(context.assemblyName), AssemblyBuilderAccess.RunAndSave);
            context.dynamicModule = context.dynamicAssembly.DefineDynamicModule(context.moduleName, context.moduleName + ".dll");


            context.typeBuilder =
                context.dynamicModule.DefineType(
                    context.typeName,
                    TypeAttributes.Public,
                    context.proxyBaseClass);

            context.typeBuilder.AddInterfaceImplementation(context.interfaceType);
        }

        private static void DefineProxyConstructor(ProxyGenerationContext context)
        {
            var baseConstructor = context.proxyBaseClass.GetConstructors()[0];

            context.constructorBuilder =
                context.typeBuilder.DefineConstructor(
                    MethodAttributes.Public,
                    CallingConventions.Standard,
                    new Type[]
                        {
                            context.interfaceType, typeof (IBehavior[])
                        });
            {
                var constructorILGenerator = context.constructorBuilder.GetILGenerator();

                constructorILGenerator.Emit(OpCodes.Ldarg_0);
                constructorILGenerator.Emit(OpCodes.Ldarg_1);
                constructorILGenerator.Emit(OpCodes.Ldarg_2);
                constructorILGenerator.Emit(OpCodes.Call, baseConstructor);
                constructorILGenerator.Emit(OpCodes.Ret);
            }
        }

        private class ProxyGenerationContext
        {
            public Type interfaceType;
            public Type targetType;
            public Type proxyBaseClass;
            public FieldInfo proxyBaseComponentField;
            public MethodInfo proxyBaseWrapACallMethod;
            public TypeBuilder typeBuilder;
            public string assemblyName;
            public string moduleName;
            public string typeName;
            public AssemblyBuilder dynamicAssembly;
            public ModuleBuilder dynamicModule;
            public ConstructorBuilder constructorBuilder;
            public FieldInfo methodInvokeResult_ResultField;
            public Type closureType;
            public ConstructorInfo nestedConstructor;
            public FieldInfo nestedComponentField;
            public MethodInfo nestedCallToProxiedComponent;
            public FieldInfo nestedResultField;
            public FieldBuilder targetAttributesField;
            public FieldBuilder sourceMethodField;
            public MethodInfo targetMethod;
            public FieldBuilder targetMethodField;
            public FieldBuilder targetMethodParametersField;

            public ProxyGenerationContext(Type interfaceType, Type targetType)
            {
                this.interfaceType = interfaceType;
                this.targetType = targetType;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\ServiceRegistrationOptions.cs ===
using System.Collections.Generic;

namespace Leet.Core.IoCCo
{
    public class ServiceRegistrationOptions<TService> : IServiceRegistrationOptions<TService>
    {
        private List<IBehavior> AddedBehaviors { get; set; }

        public ServiceRegistrationOptions()
        {
            AddedBehaviors = new List<IBehavior>();
        }

        public IServiceRegistrationOptions<TService> With<TBehavior>() where TBehavior : IBehavior, new()
        {
            AddedBehaviors.Add(new TBehavior());
            Container.Instance.SetBehaviorsForService<TService>(AddedBehaviors.ToArray());

            return this;
        }

        public IServiceRegistrationOptions<TService> WithLifeCycleMode(LifeCycleMode lifeCycleMode)
        {
            Container.Instance.SetLifeCycleForService<TService>(lifeCycleMode);
            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\ServiceNotRegisteredException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo
{
    [global::System.Serializable]
    public class ServiceNotRegisteredException : Exception
    {
        public ServiceNotRegisteredException() { }
        public ServiceNotRegisteredException(string message) : base(message) { }
        public ServiceNotRegisteredException(string message, Exception inner) : base(message, inner) { }
        protected ServiceNotRegisteredException(
          System.Runtime.Serialization.SerializationInfo info,
          System.Runtime.Serialization.StreamingContext context)
            : base(info, context) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\IoCCo\SingletonInstanceAttribute.cs ===
﻿using System;

namespace Leet.Core.IoCCo
{
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class SingletonInstanceAttribute : Attribute
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Core")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f3194126-0797-4796-a5c4-9f1ddaa9cde4")]

[assembly: System.CLSCompliant(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Utils\DebugUtil.cs ===
//-------------------------------------------------------------------
// <copyright file="DebugUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="feichen">
//     Fei Chen
// </author>
//
// <summary>
//  Defines DsDebug class.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="02/26/2008">
//     Class created
// </history>
//-------------------------------------------------------------------

// Disable warning CS0414: The private field '...' is assigned but its value is never used.
#pragma warning disable 0414

namespace Microsoft.DeviceServices.Utility
{
    using System;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    /// <summary>
    /// Define the debug log levels.
    /// </summary>
    public enum DebugLevel
    {
        /// <summary>
        /// Debug log level 1.
        /// </summary>
        DL_1 = 1,

        /// <summary>
        /// Debug log level 2.
        /// </summary>     
        DL_2,

        /// <summary>
        /// Debug log level 3.
        /// </summary>
        DL_3,

        /// <summary>
        /// Debug log level 4.
        /// </summary>
        DL_4,

        /// <summary>
        /// Debug log level 5.
        /// </summary>
        DL_5
    }
     
    /// <summary>
    /// DsDebug is a public class that exposes some methods for debugging.
    /// Note, DsDebug methods are conditionally compiled when DEBUG is defined. 
    /// </summary> 
    public static class DsDebug
    {
        /// <summary>
        /// Current debug log level.
        /// </summary>
        private static DebugLevel currentDebugLevel = DebugLevel.DL_3;

        /// <summary>
        /// Gets or sets the current debug log level property.
        /// </summary>
        public static DebugLevel CurrentDebugLevel 
        {
           [MethodImplAttribute(MethodImplOptions.NoInlining)]
           get 
           {
              return currentDebugLevel; 
           }

           [MethodImplAttribute(MethodImplOptions.NoInlining)]
           set 
           {
              currentDebugLevel = value; 
           }
        }

        /// <summary>
        /// This method outputs a line of debug message.
        /// </summary>
        /// <param name="debugLevel">Trace leve of this message.</param>
        /// <param name="componentName">Name of the component.</param>
        /// <param name="message">Message to be output.</param> 
        [ConditionalAttribute("DEBUG")]
        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        public static void WriteLine(
            DebugLevel debugLevel,
            string componentName,
            string message)
        {         
            if (ShouldWriteDebugInfo(debugLevel))
            {
                // Output to the trace. 
                Trace.WriteLine(DateTime.Now.ToString("o") + " " +
                    componentName + "] " + message);
            }           
        }

        /// <summary>
        /// This method outputs a line of debug message.
        /// </summary>
        /// <param name="debugLevel">Trace leve of this message.</param>
        /// <param name="componentName">Name of the component.</param>
        /// <param name="message">Array of objects to be converted to strings and concated and then written to the debug log.</param>
        public static void WriteLine(
            DebugLevel debugLevel,
            string componentName,
            params object[] objectList)
        {
            if (ShouldWriteDebugInfo(debugLevel))
            {
                string message = null;
                           
                if (objectList != null)
                {
                    message = string.Concat(objectList);                   
                }                          
                
                // Output to the trace.
                Trace.WriteLine(DateTime.Now.ToString("o") + " " +
                    componentName + "] " + message);
            }
        }

        /// <summary>
        /// Common assert method that should be used for all DeviceServices projects.
        /// </summary>
        /// <param name="condition">Assert condition.</param>      
        [ConditionalAttribute("DEBUG")]
        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        public static void Assert(bool condition)
        {           
            DoAssert(condition, "Assert failed");
        }

        /// <summary>
        /// Common assert method that should be used for all DeviceServices projects.
        /// </summary>
        /// <param name="condition">Assert condition.</param>
        /// <param name="message">Assert message.</param>        
        [ConditionalAttribute("DEBUG")]
        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        public static void Assert(bool condition, string message)
        {  
            DoAssert(condition, message);
        }
        
        /// <summary>
        /// Helper method used by Assert() methods.
        /// </summary>
        /// <param name="condition">Assert condition.</param>              
        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        private static void DoAssert(bool condition, string message)
        {           
            if (!condition)
            {
                string str = message + new StackTrace(true).ToString();
                WriteLine(DebugLevel.DL_1, "DsDebug Assertion", str);
                
                Process currentProcess = Process.GetCurrentProcess();
                string moduleName = currentProcess.MainModule.ModuleName;

                //
                // Popup a dialog box to give user a chance to attach the debugger.
                //
                DialogResult result = 
                    MessageBox.Show(str + "\n \"Abort\": terminate process (except for w3wp.exe)\n \"Retry\": break into debugger\n \"Ignore\": continue", 
                                    "DsDebug Assertion in " + moduleName +
                                    " (pid=" + Process.GetCurrentProcess().Id + ")", 
                                    MessageBoxButtons.AbortRetryIgnore, 
                                    MessageBoxIcon.Question, 
                                    MessageBoxDefaultButton.Button2, 
                                    MessageBoxOptions.ServiceNotification);

                
                if (result == DialogResult.Abort)
                {                   
                    // TODO: Might change this later. It should be ok to even kill the w3wp.
                    // For now just don't allow users to kill it just to be on the safe side.
                    if (string.Compare(moduleName, "w3wp.exe", true) != 0)  // Skip certain known processes.
                    {
                        currentProcess.Kill();
                    }                    
                }
                else if (result == DialogResult.Retry)
                {
                    Debugger.Break();
                }
            }
        }

        /// <summary>
        /// Returns true when the log level is below or at the current log level.
        /// </summary>
        /// <param name="debugLevel">Debug log level of this message.</param>
        /// <returns>TRUE when the log level is below or at the current log level.</returns>
        [MethodImplAttribute(MethodImplOptions.NoInlining)]
        private static bool ShouldWriteDebugInfo(DebugLevel debugLevel)
        {           
            return debugLevel <= currentDebugLevel;
        }  
    }

    /// <summary>
    /// TimeoutMessageBox provides a messagebox with the timeout.
    /// </summary> 
    public static class TimeoutMessageBox
    {
        /// <summary>
        /// Imported function from user32.dl
        /// </summary>
        [DllImport("user32.dll", CallingConvention=CallingConvention.Cdecl)]
        public static extern int MessageBoxTimeout(
           int hWnd,
           string lpText,
           string lpCaption,
           uint uType,
           short wLanguageId,
           uint dwMilliseconds);

        /// <summary>
        /// Show a messagebox with the timeout.
        /// </summary> 
        public static int Show(string caption, string text, uint uType, int timeoutSeconds)
        {
            return MessageBoxTimeout(0,      // hWnd
                                     text, 
                                     caption + " (This window will be closed automatically in " + timeoutSeconds + " seconds.)", 
                                     uType,
                                     0,      // wLanguageId
                                     (uint)timeoutSeconds * 1000); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\TestSupport\Extensions.cs ===
﻿using System;
using System.Configuration;
using System.Reflection;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.TestSupport;

namespace Leet.Core.IoCCo
{
    public static class Extensions
    {
        public static void AddEmulatableService<TService, TComponent>(this IContainer container)
            where TComponent : TService
            where TService : class
        {
            // check config for the global switch for using emulators
            bool useTestImplementations = false;
            try
            {
                IConfigurationProvider configSettings =
                    container.GetComponent<IConfigurationProvider>();

                useTestImplementations =
                    configSettings.GetBoolSetting(Settings.UseTestImplementations);
            }
            catch (ConfigurationErrorsException)
            {
                useTestImplementations = false;
            }

            if (useTestImplementations)
            {
                ITestImplementationProvider provider =
                    container.GetComponent<ITestImplementationProvider>();

                Type testImplementationType =
                    provider.GetTestImplementationType<TService>();

                if (testImplementationType != null)
                {
                    MethodInfo addServiceMethod =
                        typeof(IContainer).GetMethod("AddService");
                    addServiceMethod =
                        addServiceMethod.MakeGenericMethod(typeof(TService), testImplementationType);

                    addServiceMethod.Invoke(container, null);

                    // we've added the service and the test implementation to the container
                    // so return
                    return;
                }
            }

            // if we got here, then either the test implementation was not configured or there 
            // was a problem adding it to the container, so go with the default, real service
            container.AddService<TService, TComponent>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Platforms\PlatformType.cs ===
﻿using System;

namespace Leet.Core.Platforms
{
#if !SILVERLIGHT && !WINDOWS_PHONE
    [CLSCompliant(false)]
#endif
    public enum PlatformType : uint
    {
        Xbox1 = 0,
        XboxCom = 1,
        Xbox360 = 2,
        Marketplace = 3,
        PC = 4,
        Mobile = 5,
        WebGames = 6,
    }
    public enum PlatformBitMask :uint
    {
        /// <summary>
        ///  No platform.
        /// </summary>
        None = 0x0,

        /// <summary>
        ///  Windows mobile.
        /// </summary>
        WindowsPhone = 0x1,

        /// <summary>
        ///  Windows PC.
        /// </summary>
        Web = 0x2,

        /// <summary>
        ///  Console
        /// </summary>
        XboxConsole = 0x4,

        // <summary>
        ///  PC
        /// </summary>
        WindowsPc = 0x8,



        /// <summary>
        ///  All platforms.
        /// </summary>
        All = WindowsPhone | Web | XboxConsole | WindowsPc,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\TestSupport\ITestImplementationProvider.cs ===
﻿using System;

namespace Leet.Core.TestSupport
{
    public interface ITestImplementationProvider
    {
        Type GetTestImplementationType<T>() where T : class;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\TestSupport\TestImplementationProvider.cs ===
﻿using System;
using System.Configuration;
using System.Reflection;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Core.TestSupport
{
    public class TestImplementationProvider : ITestImplementationProvider
    {
        /// <summary>
        /// Gets the type of the test implementation for the specified interface, based on configuration.
        /// 
        /// An example of a config setting is:
        ///   key: "leet_LiveWeb_Web_Interfaces_ILocalizedStringProvider" 
        ///   value: "FakeLocalization.FakeLocalizedStringProvider, FakeLocalization"
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns>
        /// Type of test implementation, or null if test implementation was not specified
        /// </returns>
        public Type GetTestImplementationType<T>() where T : class
        {
            string interfaceName = 
                "lest_" + typeof(T).ToString().Replace('.', '_');
            string testTypeName = GetTestType(interfaceName);
            
            if (string.IsNullOrEmpty(testTypeName))
            {
                interfaceName = "lest_" + typeof(T).Name;
                testTypeName = GetTestType(interfaceName);
            }

            if (string.IsNullOrEmpty(testTypeName))
            {
                return null;
            }
            else
            {
                Type type = Type.GetType(testTypeName);
                if (null == type)
                {
                    throw new TypeLoadException(
                        "Could not load type '" + testTypeName + "'. Make sure DLL containing test implementation is present along with any dependencies and there are no spelling errors in the configuration setting specifying this test implementation.");
                }

                return type;
            }
        }
        
        private static string GetTestType(string interfaceName)
        {
            string testTypeName = string.Empty;
            IConfigurationProvider config = 
                Container.Instance.GetComponent<IConfigurationProvider>();

            try
            {
                testTypeName = config.GetSetting(interfaceName);
            }
            catch (ConfigurationErrorsException) // this means we were unable to find this setting in config
            {}
            catch (ApplicationException) // this means we were unable to find this setting in config
            {}

            return testTypeName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\ClientChannelConfiguration.cs ===
﻿using System;
using System.ComponentModel;

namespace Leet.Core.Wcf
{
    public interface IClientChannelConfiguration : INotifyPropertyChanged
    {
        long MaxReceivedMessageSize { get; set; }
        long MaxBufferPoolSize { get; set; }
        TimeSpan OpenTimeout { get; set; }
        TimeSpan CloseTimeout { get; set; }
        TimeSpan ReceiveTimeout { get; set; }
        TimeSpan SendTimeout { get; set; }
        bool ReliableSessionEnabled { get; set; }
        TimeSpan ReliableSessionTimeout { get; set; }
        bool ReliableSessionOrdered { get; set; }
    }

    public class ClientChannelConfiguration : IClientChannelConfiguration
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        private long maxReceivedMessageSize = 204800;
        public virtual long MaxReceivedMessageSize
        {
            get
            {
                return maxReceivedMessageSize;
            }
            set
            {
                maxReceivedMessageSize = value;
                OnPropertyChanged("MaxReceivedMessageSize");
            }
        }


        private long maxBufferPoolSize = 204800;
        public virtual long MaxBufferPoolSize
        {
            get { return maxBufferPoolSize; }
            set
            {
                maxBufferPoolSize = value;
                OnPropertyChanged("MaxBufferPoolSize");
            }
        }

        private TimeSpan openTimeout = new TimeSpan(0, 0, 30);
        public virtual TimeSpan OpenTimeout
        {
            get { return openTimeout; }
            set
            {
                openTimeout = value;
                OnPropertyChanged("OpenTimeout");
            }
        }

        private TimeSpan closeTimeout = new TimeSpan(0, 1, 0);
        public virtual TimeSpan CloseTimeout
        {
            get { return closeTimeout; }
            set
            {
                closeTimeout = value;
                OnPropertyChanged("CloseTimeout");
            }
        }

        private TimeSpan receiveTimeout = new TimeSpan(0, 15, 0);
        public virtual TimeSpan ReceiveTimeout
        {
            get { return receiveTimeout; }
            set
            {
                receiveTimeout = value;
                OnPropertyChanged("ReceiveTimeout");
            }
        }

        private TimeSpan sendTimeout = new TimeSpan(0,2,0);
        public virtual TimeSpan SendTimeout
        {
            get { return sendTimeout; }
            set
            {
                sendTimeout = value;
                OnPropertyChanged("SendTimeout");
            }
        }

        private bool reliableSessionEnabled;
        public virtual bool ReliableSessionEnabled
        {
            get { return reliableSessionEnabled; }
            set
            {
                reliableSessionEnabled = value;
                OnPropertyChanged("ReliableSessionEnabled");
            }
        }

        private TimeSpan reliableSessionTimeout = new TimeSpan(1, 0, 0);
        public virtual TimeSpan ReliableSessionTimeout
        {
            get { return reliableSessionTimeout; }
            set
            {
                reliableSessionTimeout = value;
                OnPropertyChanged("ReliableSessionTimeout");
            }
        }

        private bool reliableSessionOrdered = true;
        public virtual bool ReliableSessionOrdered
        {
            get { return reliableSessionOrdered; }
            set
            {
                reliableSessionOrdered = value;
                OnPropertyChanged("ReliableSessionOrdered");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\ClientProxyFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using Leet.Core.IoCCo;
using System.ComponentModel;

namespace Leet.Core.Wcf
{
    /// <summary>
    /// A WCF Proxy Factory suitable for single user smart client usage. A single channel will be used for all service communication and be
    /// cached between calls.
    /// 
    /// All sends that result in a CommunicationFailureException will be retried to allow for recovery from channel timeouts or other short term 
    /// communication failures.
    /// </summary>
    [SingletonInstance]
    public class ClientProxyFactory<TContract> : IWcfProxyFactory<TContract>, IDisposable where TContract : class
    {
        private readonly object syncObject = new object();


        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Configurator")]
        public ClientProxyFactory(IEndpointConfigurator<TContract> endpointConfigurator)
        {
            if (endpointConfigurator == null)
            {
                throw new ArgumentNullException("endpointConfigurator");
            }

            Configurator = endpointConfigurator;
            endpointConfigurator.PropertyChanged += ClientConfigurationChanged;

        }

        public IEndpointConfigurator<TContract> Configurator { get; private set; }

        private ChannelFactory<TContract> channelFactory;
        protected ChannelFactory<TContract> ChannelFactory
        {
            get
            {
                return channelFactory;
            }
            set
            {
                lock (syncObject)
                {
                    ChannelFactory<TContract> oldFactory = channelFactory;

                    channelFactory = value;

                    if (channelFactory != null)
                    {
                        channelFactory.Faulted += ChannelFactory_Faulted;
                    }

                    Channel = null;

                    if (oldFactory != null)
                    {
                        oldFactory.Faulted -= ChannelFactory_Faulted;

                        try
                        {
                            ((IDisposable)oldFactory).Dispose();
                        }
                        catch (CommunicationException)
                        {
                            oldFactory.Abort();
                        }
                        catch (TimeoutException)
                        {
                            oldFactory.Abort();
                        }
                        catch (Exception)
                        {
                            oldFactory.Abort();
                            throw;
                        }
                    }
                }
            }
        }

        private TContract channel;
        protected TContract Channel
        {
            get
            {
                return channel;
            }
            set
            {
                lock (syncObject)
                {
                    ICommunicationObject oldChannel = (ICommunicationObject)channel;

                    channel = value;

                    if (channel != null)
                    {
                        ICommunicationObject proxy = (ICommunicationObject)channel;
                        proxy.Faulted += Channel_Faulted;
                    }

                    if (oldChannel != null)
                    {
                        oldChannel.Faulted -= Channel_Faulted;

                        try
                        {
                            ((IDisposable)oldChannel).Dispose();
                        }
                        catch (CommunicationException)
                        {
                            oldChannel.Abort();
                        }
                        catch (TimeoutException)
                        {
                            oldChannel.Abort();
                        }
                        catch (Exception)
                        {
                            oldChannel.Abort();
                            throw;
                        }
                    }
                }
            }
        }

        private void ClientConfigurationChanged(object sender, PropertyChangedEventArgs e)
        {
            // if the configuration changed, force the creation of a new ChannelFactory
            ChannelFactory = null;
        }

        protected TContract Proxy
        {
            get
            {
                if (disposed)
                {
                    throw new InvalidOperationException("A new Proxy was requested after the ClientProxyFactory has been disposed.");
                }

                if (Channel == null)
                {
                    if (ChannelFactory == null)
                    {
                        ChannelFactory = new ChannelFactory<TContract>(Configurator.GetEndpoint());
                    }

                    Channel = ChannelFactory.CreateChannel();
                }

                return Channel;
            }
        }

        public virtual TResult Send<TResult>(Func<TContract, TResult> serviceCallDelegate)
        {
            try
            {
                return serviceCallDelegate(Proxy);
            }
            catch (CommunicationException comEx)
            {
                FaultException faultEx = comEx as FaultException;
                if (faultEx != null)
                {
                    throw;
                }

                // use the proxy again here, if it throws, let it }
                return serviceCallDelegate(Proxy);
            }
        }

        public virtual void Send(Action<TContract> serviceCallDelegate)
        {
            try
            {
                serviceCallDelegate(Proxy);
            }
            catch (CommunicationException comEx)
            {
                FaultException faultEx = comEx as FaultException;
                if (faultEx != null)
                {
                    throw;
                }

                // use the proxy again here, if it throws, let it }
                serviceCallDelegate(Proxy);
            }
        }

        private void Channel_Faulted(object sender, System.EventArgs e)
        {
            ICommunicationObject proxy = (ICommunicationObject)sender;
            if (proxy == (ICommunicationObject)Channel)
            {
                Channel = null;
            }
        }

        private void ChannelFactory_Faulted(object sender, System.EventArgs e)
        {
            ICommunicationObject factory = (ICommunicationObject)sender;
            if (factory == ChannelFactory)
            {
                ChannelFactory = null;
            }
        }

        #region IDisposable Members

        // Track whether Dispose has been called.
        private bool disposed = false;

        // Implement IDisposable.
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                ChannelFactory = null;
            }
            disposed = true;
        }


        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\ConfigurationFileEndpointConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel.Description;
using System.ServiceModel;
using System.ComponentModel;
using System.Globalization;

namespace Leet.Core.Wcf
{
    /// <summary>
    /// Provides a configurator that loads the endpoint configuration for the specified Contract from the web.config/app.config. The name of the
    /// endpoint in the configuration file should be &lt;Contract Name&gt;_Endpoint.
    /// Optionally, the Uri Authority information for the endpoint can be specified through the ServiceHostUri property.
    /// </summary>
    /// <typeparam name="TContract"></typeparam>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Configurator")]
    public class ConfigurationFileEndpointConfigurator<TContract> : IEndpointConfigurator<TContract> where TContract: class
    {
        #region IEndpointConfigurator<TContract> Members

        public System.ServiceModel.Description.ServiceEndpoint GetEndpoint()
        {
            var configName = String.Format(CultureInfo.InvariantCulture, "{0}_Endpoint", typeof(TContract).Name);
            var configurationFactory = new ChannelFactory<TContract>(configName);

            var endpoint = configurationFactory.Endpoint;

            if (serviceHostUri != null)
            {
                UriBuilder builder = new UriBuilder(endpoint.Address.Uri);
                builder.Scheme = serviceHostUri.Scheme;
                builder.Host = serviceHostUri.Host;
                builder.Port = serviceHostUri.Port;
                endpoint.Address = new EndpointAddress(
                    builder.Uri, 
                    endpoint.Address.Identity, 
                    endpoint.Address.Headers, 
                    endpoint.Address.GetReaderAtMetadata(), 
                    endpoint.Address.GetReaderAtExtensions());
            }

            return endpoint;
        }

        private Uri serviceHostUri = null;
        public Uri ServiceHostUri
        {
            get
            {
                return serviceHostUri;
            }
            set
            {
                serviceHostUri = new Uri(value.GetLeftPart(UriPartial.Authority));
                OnPropertyChanged("ServiceHostUri");
            }
        }

        #endregion

        #region INotifyPropertyChanged Members

        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\ConfigurableServiceHostFactory.cs ===
﻿using System;
using System.ServiceModel;
using System.ServiceModel.Description;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Core.Wcf
{
    /// <summary>
    /// Creates the correct endpoints based on existing configuration values
    /// configured during installation.  If the interface does not have an
    /// info1 defined, then only one endpoint with the machine name and high
    /// port is created.  If info1 is defined, a second endpoint using info1 as
    /// the FQDN is also created.
    /// 
    /// This relies on having three configuration settings defined as well
    /// &lt;TContract&gt;_Binding is the name of the binding defined in
    /// web.config, &lt;TContract&gt;_Endpoint is the name of the interface
    /// that defines where the service is exposed, and
    /// &lt;TContract&gt;_Endpoint_Path is the relative path of thr Uri to
    /// the service.
    /// 
    /// For example:
    /// IPublishingService_Binding = 'CosmosPublishingServiceWSHttpBindingConfig'
    /// IPublishingService_Endpoint = 'cosmos_authoring'
    /// IPublishingService_Endpoint_Path = 'PublishingService.svc'
    /// 
    /// NOTE: This class only supports WSHttpBindings and non-SSL endpoints.
    /// </summary>
    /// <typeparam name="ContractType">The interface being exposed as a service.</typeparam>
    public class ConfigurableServiceHostFactory<TContract> : MultipleBindingServiceHostFactory
    {
        protected override void ConfigureEndpoints()
        {
            var config = Container.Instance.GetComponent<IConfigurationProvider>();

            var contract = ContractDescription.GetContract(typeof(TContract));
            var bindingName = config.GetSetting(contract.Name + "_Binding");
            var ifaceName = config.GetSetting(contract.Name + "_Endpoint");
            var relativePath = new Uri(config.GetSetting(contract.Name + "_Endpoint_Path"), UriKind.Relative);

            var binding = new WSHttpBinding(bindingName);

            var address = config.GetInterfaceEndpoint(ifaceName, false);
            var endpointAddressUri = new Uri(new Uri(address), relativePath);
            var endpointAddress = new EndpointAddress(endpointAddressUri);
            var endpoint = new ServiceEndpoint(contract, binding, endpointAddress);
            Host.Description.Endpoints.Add(endpoint);

            var iface = config.GetInterface(Environment.MachineName, ifaceName);
            if (!String.IsNullOrEmpty(iface.Info1))
            {
                var secondAddress = new UriBuilder("http", Environment.MachineName, iface.Port).Uri;
                var secondEndpointAddress = new EndpointAddress(new Uri(secondAddress, relativePath));
                var secondEndpoint = new ServiceEndpoint(contract, binding, secondEndpointAddress);
                Host.Description.Endpoints.Add(secondEndpoint);
            }

            SetAddressForMetadataPublishing(endpointAddressUri);
        }

        private void SetAddressForMetadataPublishing(Uri endpointAddressUri)
        {
            var metadataBehavior = Host.Description.Behaviors.Find<ServiceMetadataBehavior>();
            if (metadataBehavior != null)
            {
                metadataBehavior.HttpGetUrl = endpointAddressUri;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\IEndpointConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.ServiceModel.Description;

namespace Leet.Core.Wcf
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Configurator")]
    public interface IEndpointConfigurator<TContract> : INotifyPropertyChanged where TContract: class
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification="Operation could be expensive, guidelines state it should remain a method")]
        ServiceEndpoint GetEndpoint();
        Uri ServiceHostUri { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\obj\Debug\Configuration\ConfigItemClasses.cs ===
// This is a generated file. Please don't modify directly.
//
// This file defines a number of classes which provide a symbolic way to 
// reference instances of configuration items (e.g. Interfaces, Settings, 
// etc.). 
//
// It is generated from the /product/SharedSource/Configuration/configItems.xml 
// file. Please update that file and this code will get updated automatically 
// by the build.

using System.Runtime.InteropServices;
using System.CodeDom.Compiler;

namespace Leet.Core.Configuration
{
  

    // Components
    [ComVisible(false)]
    [GeneratedCode("ConfigItemClasses.xsl", "1.0.0.0")]
    [type: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    public static class Components
    {
  

        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        public const string unknown = "unknown";
    }

    // Interfaces
    [ComVisible(false)]
    [GeneratedCode("ConfigItemClasses.xsl", "1.0.0.0")]
    [type: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    public static class Interfaces
    {
    
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        public const string None = "None";
    }

    // VirtualInterfaces
    [ComVisible(false)]
    [GeneratedCode("ConfigItemClasses.xsl", "1.0.0.0")]
    [type: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    public static class VirtualInterfaces
    {
    
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
        [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
        public const string None = "None";
    }

    // Settings
    [ComVisible(false)]
    [GeneratedCode("ConfigItemClasses.xsl", "1.0.0.0")]
    [type: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    public static class Settings
    {
    
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ABCHApplicationId = "lest_ABCHApplicationId";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ABCHServiceUrl = "lest_ABCHServiceUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarAssetFilterEnableUpdate = "lest_AvatarAssetFilterEnableUpdate";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarAssetFilterFileFullPath = "lest_AvatarAssetFilterFileFullPath";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarAssetFilterUpdateIntervalInSeconds = "lest_AvatarAssetFilterUpdateIntervalInSeconds";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarAssetURIMarketAward = "lest_AvatarAssetURIMarketAward";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarAssetURIStock = "lest_AvatarAssetURIStock";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarBackgroundImagesLocationUri = "lest_AvatarBackgroundImagesLocationUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarCloset_AudienceUri = "lest_AvatarCloset_AudienceUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarCloset_EnableCannedAssets = "lest_AvatarCloset_EnableCannedAssets";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarManRead_AudienceUri = "lest_AvatarManRead_AudienceUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarManRead_EnableCannedManifest = "lest_AvatarManRead_EnableCannedManifest";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarManRead_MaxManifestsPerRequest = "lest_AvatarManRead_MaxManifestsPerRequest";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarManWrite_AudienceUri = "lest_AvatarManWrite_AudienceUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarManWrite_MaxGamerpicBackgroundIndex = "lest_AvatarManWrite_MaxGamerpicBackgroundIndex";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarPictureSecureUriRoot = "lest_AvatarPictureSecureUriRoot";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarPictureUriRoot = "lest_AvatarPictureUriRoot";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRDiagnosticImageWriteUri = "lest_AvatarSSRDiagnosticImageWriteUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMaxFieldOfView = "lest_AvatarSSRGamerpicMaxFieldOfView";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMaxXOffset = "lest_AvatarSSRGamerpicMaxXOffset";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMaxYOffset = "lest_AvatarSSRGamerpicMaxYOffset";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMaxZOffset = "lest_AvatarSSRGamerpicMaxZOffset";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMinFieldOfView = "lest_AvatarSSRGamerpicMinFieldOfView";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMinXOffset = "lest_AvatarSSRGamerpicMinXOffset";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMinYOffset = "lest_AvatarSSRGamerpicMinYOffset";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRGamerpicMinZOffset = "lest_AvatarSSRGamerpicMinZOffset";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AvatarSSRMaxConcurrentThreads = "lest_AvatarSSRMaxConcurrentThreads";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AzureBlobStorageEndPoint = "lest_AzureBlobStorageEndPoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AzureQueueStorageEndPoint = "lest_AzureQueueStorageEndPoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AzureRetryCount = "lest_AzureRetryCount";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string AzureTableStorageEndPoint = "lest_AzureTableStorageEndPoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BIAverageLogLineSize = "lest_BIAverageLogLineSize";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BIFieldDelimiter = "lest_BIFieldDelimiter";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BIFileStreamBufferSize = "lest_BIFileStreamBufferSize";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BILogCollectionInterval = "lest_BILogCollectionInterval";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BILogFileExtension = "lest_BILogFileExtension";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BILogPath = "lest_BILogPath";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BIMaxFileSize = "lest_BIMaxFileSize";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string BIMaxTotalBufferSize = "lest_BIMaxTotalBufferSize";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string CloudDirectoryProfileApplicationId = "lest_CloudDirectoryProfileApplicationId";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string CloudDirectoryProfileServiceUrl = "lest_CloudDirectoryProfileServiceUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string DefaultGameUrl = "lest_DefaultGameUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string DefaultLoggingSourceLevel = "lest_DefaultLoggingSourceLevel";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string DefaultProfilePicUrl = "lest_DefaultProfilePicUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string EventLevel = "lest_EventLevel";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_GameRedirectionUrlFormat = "lest_GameMetadata_GameRedirectionUrlFormat";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_GameSessionRedirectionUrlFormat = "lest_GameMetadata_GameSessionRedirectionUrlFormat";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_ProfileRedirectionUrlFormat = "lest_GameMetadata_ProfileRedirectionUrlFormat";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_CacheTTLMinutes = "lest_GameMetadata_Redirection_CacheTTLMinutes";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_Game_Mobile = "lest_GameMetadata_Redirection_Game_Mobile";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_Game_Web = "lest_GameMetadata_Redirection_Game_Web";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_GameSession_Mobile = "lest_GameMetadata_Redirection_GameSession_Mobile";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_GameSession_Web = "lest_GameMetadata_Redirection_GameSession_Web";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_Profile_Mobile = "lest_GameMetadata_Redirection_Profile_Mobile";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_Profile_Web = "lest_GameMetadata_Redirection_Profile_Web";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Redirection_WindowsMobileMinVersion = "lest_GameMetadata_Redirection_WindowsMobileMinVersion";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Service_CacheMaximumTTLMinutes = "lest_GameMetadata_Service_CacheMaximumTTLMinutes";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Service_RedirectionUrlHostOverride = "lest_GameMetadata_Service_RedirectionUrlHostOverride";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GameMetadata_Service_UseRedirectionUrlHostOverride = "lest_GameMetadata_Service_UseRedirectionUrlHostOverride";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GamerPictureSecureUriRoot = "lest_GamerPictureSecureUriRoot";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GamerPictureUriRoot = "lest_GamerPictureUriRoot";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GarbageCollectorService_DaysToWaitBeforeCleaningNotificat = "lest_GarbageCollectorService_DaysToWaitBeforeCleaningNotificat";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GarbageCollectorService_DaysToWaitBeforeCleaningSessions = "lest_GarbageCollectorService_DaysToWaitBeforeCleaningSessions";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GarbageCollectorService_MaxConcurrentSessionsToProcess = "lest_GarbageCollectorService_MaxConcurrentSessionsToProcess";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string GarbageCollectorService_RunInTestMode = "lest_GarbageCollectorService_RunInTestMode";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Healthcheck_executionPeriodInSeconds = "lest_Healthcheck_executionPeriodInSeconds";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Healthcheck_Gamertag = "lest_Healthcheck_Gamertag";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IClosetPartService_Endpoint = "IClosetPartService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IClosetPartService_Endpoint_Path = "IClosetPartService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IClosetPvtService_Endpoint = "IClosetPvtService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IClosetPvtService_Endpoint_Path = "IClosetPvtService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameMetadataService_Binding = "IGameMetadataService_Binding";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameMetadataService_Endpoint = "IGameMetadataService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameMetadataService_Endpoint_Path = "IGameMetadataService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameSessionService_Endpoint = "IGameSessionService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameSessionService_Endpoint_Path = "IGameSessionService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameStateService_Endpoint = "IGameStateService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IGameStateService_Endpoint_Path = "IGameStateService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IIngestionService_Binding = "IIngestionService_Binding";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IIngestionService_Endpoint = "IIngestionService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IIngestionService_Endpoint_Path = "IIngestionService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IManifestReadService_Endpoint = "IManifestReadService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IManifestReadService_Endpoint_Path = "IManifestReadService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IManifestWritePartService_Endpoint = "IManifestWritePartService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IManifestWritePartService_Endpoint_Path = "IManifestWritePartService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IManifestWritePvtService_Endpoint = "IManifestWritePvtService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IManifestWritePvtService_Endpoint_Path = "IManifestWritePvtService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IncludeExceptionDetailInErrorMessage = "lest_IncludeExceptionDetailInErrorMessage";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string INotificationFrontEnd_Endpoint = "INotificationFrontEnd_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string INotificationFrontEnd_Endpoint_Path = "INotificationFrontEnd_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string INotificationFrontEnd_Private_Endpoint = "INotificationFrontEnd_Private_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string INotificationFrontEnd_Private_Endpoint_Path = "INotificationFrontEnd_Private_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IPartnerService_Endpoint = "IPartnerService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IPartnerService_Endpoint_Path = "IPartnerService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IPdlcService_Endpoint = "IPdlcService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IPdlcService_Endpoint_Path = "IPdlcService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IProfileService_Endpoint = "IProfileService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IProfileService_Endpoint_Path = "IProfileService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IRewardsService_Endpoint = "IRewardsService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IRewardsService_Endpoint_Path = "IRewardsService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ISecureTokenService_Endpoint = "ISecureTokenService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ISecureTokenService_Endpoint_Path = "ISecureTokenService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IStatisticsService_Endpoint = "IStatisticsService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IStatisticsService_Endpoint_Path = "IStatisticsService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IUserDataService_Endpoint = "IUserDataService_Endpoint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string IUserDataService_Endpoint_Path = "IUserDataService_Endpoint_Path";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Leet_Identity_ActiveAuth_IActiveAuthAdapter = "lest_Leet_Identity_ActiveAuth_IActiveAuthAdapter";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Leet_Identity_WindowsLiveAuth_IWindowsLiveIdentityAdapter = "lest_Leet_Identity_WindowsLiveAuth_IWindowsLiveIdentityAdapter";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Leet_Profile_IAbchContactsProvider = "lest_Leet_Profile_IAbchContactsProvider";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Leet_Profile_ICloudDirectoryProfileProvider = "lest_Leet_Profile_ICloudDirectoryProfileProvider";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string LivecacheLocalCachingEnabled = "lest_LivecacheLocalCachingEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string LivecachePerUserThrottleEnabled = "lest_LivecachePerUserThrottleEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string LivecacheServiceEnabled = "lest_LivecacheServiceEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string LiveConnectAPIThrottle = "lest_LiveConnectAPIThrottle";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string logroot = "lest_logroot";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Notification_DependencyRetryDurationMin = "lest_Notification_DependencyRetryDurationMin";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Notification_FRGameIdIsLivApp = "lest_Notification_FRGameIdIsLivApp";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Notification_MPNSCertName = "lest_Notification_MPNSCertName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Notification_SMTPRetryDurationMin = "lest_Notification_SMTPRetryDurationMin";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_AzureStorageAccount = "lest_NotificationFE_AzureStorageAccount";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_AzureStorageToken = "lest_NotificationFE_AzureStorageToken";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_DataBlobMaxCchLength = "lest_NotificationFE_DataBlobMaxCchLength";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_FriendRequestUrl = "lest_NotificationFE_FriendRequestUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_InviteQuotaPerHour = "lest_NotificationFE_InviteQuotaPerHour";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_LiveAppFRMobileSmallUrl = "lest_NotificationFE_LiveAppFRMobileSmallUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_LiveAppMessageMobileSmallUrl = "lest_NotificationFE_LiveAppMessageMobileSmallUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_LiveAppSupportedLocales = "lest_NotificationFE_LiveAppSupportedLocales";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_RedNotificationQueueSize = "lest_NotificationFE_RedNotificationQueueSize";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_SpotlightCacheExpiryInMinutes = "lest_NotificationFE_SpotlightCacheExpiryInMinutes";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_SpotlightFeedPath = "lest_NotificationFE_SpotlightFeedPath";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_XblIconMobileLargeUrl = "lest_NotificationFE_XblIconMobileLargeUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_XblIconMobileSmallUrl = "lest_NotificationFE_XblIconMobileSmallUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_XblIconWebLargeUrl = "lest_NotificationFE_XblIconWebLargeUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_XblIconWebSmallUrl = "lest_NotificationFE_XblIconWebSmallUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationFE_YellowNotificationQueueSize = "lest_NotificationFE_YellowNotificationQueueSize";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationInternal_AppName = "lest_NotificationInternal_AppName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationInternal_AuditingEnabled = "lest_NotificationInternal_AuditingEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationInternal_InputThrottleTimeInMilliseconds = "lest_NotificationInternal_InputThrottleTimeInMilliseconds";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationInternal_MaxThreadCount = "lest_NotificationInternal_MaxThreadCount";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationInternal_PushPayloadMax = "lest_NotificationInternal_PushPayloadMax";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationInternal_SqlErrorEventsThrottleTimeInMinutes = "lest_NotificationInternal_SqlErrorEventsThrottleTimeInMinutes";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_Account = "lest_NotificationSMTPProvider_Account";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_DisplayName = "lest_NotificationSMTPProvider_DisplayName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_Domain = "lest_NotificationSMTPProvider_Domain";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_EmailAddress = "lest_NotificationSMTPProvider_EmailAddress";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_HostName = "lest_NotificationSMTPProvider_HostName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_MaxRecipientCount = "lest_NotificationSMTPProvider_MaxRecipientCount";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_Password = "lest_NotificationSMTPProvider_Password";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string NotificationSMTPProvider_TemplatePath = "lest_NotificationSMTPProvider_TemplatePath";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_AudienceUri = "lest_Pdlc_AudienceUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_AvatarMarketplaceUrl = "lest_Pdlc_AvatarMarketplaceUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_GamerContextExpiresInHours = "lest_Pdlc_GamerContextExpiresInHours";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_GetAssetsMediaTypeIds = "lest_Pdlc_GetAssetsMediaTypeIds";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_GetAssetsStoreIds = "lest_Pdlc_GetAssetsStoreIds";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_GetPurchaseHistoryMaskingTitle = "lest_Pdlc_GetPurchaseHistoryMaskingTitle";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_InternalXblMarketplaceCatalogUrl = "lest_Pdlc_InternalXblMarketplaceCatalogUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_MOPageAddPointsUrl = "lest_Pdlc_MOPageAddPointsUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_MOPageSetupBillingUrl = "lest_Pdlc_MOPageSetupBillingUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_MOPageTouUrl = "lest_Pdlc_MOPageTouUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_PurchaseAudienceUri = "lest_Pdlc_PurchaseAudienceUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_SupportedMediaTypeIds = "lest_Pdlc_SupportedMediaTypeIds";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_XblMarketplaceCatalogUrl = "lest_Pdlc_XblMarketplaceCatalogUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_XblmNameSpace = "lest_Pdlc_XblmNameSpace";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_XblmVersionProductPath = "lest_Pdlc_XblmVersionProductPath";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string PDLCResponseSigningCertSubjectName = "lest_PDLCResponseSigningCertSubjectName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string PpsaCertThumbprint = "lest_PpsaCertThumbprint";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string PpsaCredentialUrl = "lest_PpsaCredentialUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string PpsaSiteId = "lest_PpsaSiteId";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ProxyAddress = "lest_ProxyAddress";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_ContractName = "lest_RewardsService_Config_ContractName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_InitiatorJailQueue = "lest_RewardsService_Config_InitiatorJailQueue";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_InitiatorJailService = "lest_RewardsService_Config_InitiatorJailService";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_InitiatorQueue = "lest_RewardsService_Config_InitiatorQueue";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_InitiatorService = "lest_RewardsService_Config_InitiatorService";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_ReplyMessageType = "lest_RewardsService_Config_ReplyMessageType";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_RequestMessageType = "lest_RewardsService_Config_RequestMessageType";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_TargetJailService = "lest_RewardsService_Config_TargetJailService";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_TargetQueue = "lest_RewardsService_Config_TargetQueue";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsService_Config_TargetService = "lest_RewardsService_Config_TargetService";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RewardsZestTitleIDWhiteList = "lest_RewardsZestTitleIDWhiteList";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RPSReturnUrl = "lest_RPSReturnUrl";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RPSSiteName = "lest_RPSSiteName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RulesServiceMaxConcurrentThreads = "lest_RulesServiceMaxConcurrentThreads";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string RulesServiceMinIdleThreads = "lest_RulesServiceMinIdleThreads";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SessionFE_AudienceUri = "lest_SessionFE_AudienceUri";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SessionFE_AzureStorageAccount = "lest_SessionFE_AzureStorageAccount";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SessionFE_AzureStorageToken = "lest_SessionFE_AzureStorageToken";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SessionFE_MaxCreateSessionsAllowedPerUser = "lest_SessionFE_MaxCreateSessionsAllowedPerUser";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string StsAddedTokenExpirationMinutes = "lest_StsAddedTokenExpirationMinutes";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string StsCertificateSubject = "lest_StsCertificateSubject";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SystemNudgeService_DaysToProcess = "lest_SystemNudgeService_DaysToProcess";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SystemNudgeService_MaxTasksToEnqueue = "lest_SystemNudgeService_MaxTasksToEnqueue";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SystemNudgeService_MinutesToWaitBetweenPasses = "lest_SystemNudgeService_MinutesToWaitBetweenPasses";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SystemNudgeService_RunInTestMode = "lest_SystemNudgeService_RunInTestMode";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string SystemNudgeService_StartingDay = "lest_SystemNudgeService_StartingDay";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string TestLiveID = "lest_TestLiveID";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string TilesDomainName = "lest_TilesDomainName";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string TraceLevel = "lest_TraceLevel";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string UdsPartnerTitleIDWhiteList = "lest_UdsPartnerTitleIDWhiteList";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string UdsPartnerUpdatePresenceTitleBlocklist = "lest_UdsPartnerUpdatePresenceTitleBlocklist";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string UserDataScatterFactor = "lest_UserDataScatterFactor";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string UseTestImplementations = "lest_UseTestImplementations";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string WebStsClientCertificateIssuer = "lest_WebStsClientCertificateIssuer";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string WebStsClientCertificateSubject = "lest_WebStsClientCertificateSubject";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string WebStsEnabled = "lest_WebStsEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string WebStsForWplcEnabled = "lest_WebStsForWplcEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string WebTicketEncryptionKey = "lest_WebTicketEncryptionKey";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string XboxAvatarBodyURL = "lest_XboxAvatarBodyURL";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ZestPurchaseVerificationEnabled = "lest_ZestPurchaseVerificationEnabled";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string ZestUrl = "lest_ZestUrl";
		
    }

    // MultiSettings
    [ComVisible(false)]
    [GeneratedCode("ConfigItemClasses.xsl", "1.0.0.0")]
    [type: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
    public static class MultiSettings
    {
    
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Diagnostics = "lest_Diagnostics";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string Pdlc_GetPurchaseHistoryMaskedTitles = "lest_Pdlc_GetPurchaseHistoryMaskedTitles";
		
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores")]
            [field: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly")]
			public const string WebStsBlockedTitles = "lest_WebStsBlockedTitles";
		
    }
    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\IWcfProxyFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.Wcf
{
    public interface IWcfProxyFactory<TContract> : IDisposable where TContract : class
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Configurator")]
        IEndpointConfigurator<TContract> Configurator { get; }

        TResult Send<TResult>(Func<TContract, TResult> serviceCallDelegate);
        void Send(Action<TContract> serviceCallDelegate);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\EndpointConfigurator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.ServiceModel;
using Leet.Core.Configuration;
using System.Globalization;

namespace Leet.Core.Wcf
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Configurator")]
    public class EndpointConfigurator<TContract> : IEndpointConfigurator<TContract> where TContract : class
    {
        #region IEndpointConfigurator<TContract> Members

        public System.ServiceModel.Description.ServiceEndpoint GetEndpoint()
        {
            var configName = String.Format(CultureInfo.InvariantCulture, "{0}_Endpoint", typeof(TContract).Name);
            var configurationFactory = new ChannelFactory<TContract>(configName);

            // First read the configuration out of the .config file for
            // everything except the address, which we'll override below
            var endpoint = configurationFactory.Endpoint;

            // This requires two settings to be created, one called <configName>
            // which contains the name of the interface to use to generate the
            // domain portion of the url, and <configName>_Path which contains
            // the path portion of the url.
            var config = Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>();
            var interfaceName = config.GetSetting(configName);
            var baseAddress = config.GetInterfaceEndpoint(interfaceName, false);
            var path = config.GetSetting(configName + "_Path");
            var endpointUri = new Uri(new Uri(baseAddress), new Uri(path, UriKind.Relative));

            endpoint.Address = new EndpointAddress(endpointUri);

            return endpoint;
        }

        // This will be ignored completely in this implementation.  This value is read from NPDB.
        public Uri ServiceHostUri { get; set; }

        #endregion

        #region INotifyPropertyChanged Members

        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\ServerProxyFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Threading;
using Leet.Core.IoCCo;
using System.ComponentModel;

namespace Leet.Core.Wcf
{
    /// <summary>
    /// A WCF Proxy Factory suitable for server to server web service calls. A new channel will be created for all service communication.
    /// 
    /// All sends handle disposing of the Proxy channel properly. If the Proxy is requested directly, the caller is responsible for properly 
    /// closing/disposing it.
    /// </summary>
    [SingletonInstance]
    public class ServerProxyFactory<TContract> : IWcfProxyFactory<TContract>, IDisposable where TContract : class
    {
        private readonly object syncObject = new object();

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Configurator")]
        public ServerProxyFactory(IEndpointConfigurator<TContract> endpointConfigurator)
        {
            if (endpointConfigurator == null)
            {
                throw new ArgumentNullException("endpointConfigurator");
            }

            Configurator = endpointConfigurator;
            endpointConfigurator.PropertyChanged += ClientConfigurationChanged;

        }

        public IEndpointConfigurator<TContract> Configurator { get; private set; }

        private ChannelFactory<TContract> channelFactory;
        protected ChannelFactory<TContract> ChannelFactory
        {
            get
            {
                return channelFactory;
            }
            set
            {
                lock (syncObject)
                {
                    ChannelFactory<TContract> oldFactory = channelFactory;

                    channelFactory = value;

                    if (channelFactory != null)
                    {
                        channelFactory.Faulted += ChannelFactory_Faulted;
                    }

                    if (oldFactory != null)
                    {
                        oldFactory.Faulted -= ChannelFactory_Faulted;

                        try
                        {
                            ((IDisposable)oldFactory).Dispose();
                        }
                        catch (CommunicationException)
                        {
                            oldFactory.Abort();
                        }
                        catch (TimeoutException)
                        {
                            oldFactory.Abort();
                        }
                        catch (Exception)
                        {
                            oldFactory.Abort();
                            throw;
                        }
                    }
                }
            }
        }

        private void ClientConfigurationChanged(object sender, PropertyChangedEventArgs e)
        {
            // if the configuration changed, force the creation of a new ChannelFactory
            ChannelFactory = null;
        }

        protected TContract Proxy
        {
            get
            {
                TContract returnProxy= null;
                if (disposed)
                {
                    throw new InvalidOperationException("A new Proxy was requested after the ServerProxyFactory has been disposed.");
                }


                int tryAgainCounter = 10; // some random number…
                do
                {
                    if (ChannelFactory == null)
                    {
                        ChannelFactory = new ChannelFactory<TContract>(Configurator.GetEndpoint());
                    }

                    try
                    {
                        returnProxy = ChannelFactory.CreateChannel();
                        break;
                        
                    }

                    catch (ObjectDisposedException)
                    {
                        // Another thread has disposed the object. This will happen if another thread  ended up calling ChannelFactory_Faulted()
                        // Absorb this exception if more attempts are left in the loop otherwise t
                        if (tryAgainCounter == 1)
                        {
                            throw;
                        }
                    }

                    catch (NullReferenceException)
                    {
                        // Another thread has disposed the object and set ChannelFactory to null. This will happen if another thread  ended up calling ChannelFactory_Faulted()
                        // Absorb this exception if more attempts are left in the loop otherwise t
                        if (tryAgainCounter == 1)
                        {
                            throw;
                        }
                    }
                }
                while (tryAgainCounter-- > 0);
                
                return returnProxy;
                
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        public virtual TResult Send<TResult>(Func<TContract, TResult> serviceCallDelegate)
        {
            TResult result;
            TContract proxy = Proxy;
            try
            {
                result = serviceCallDelegate(proxy);
            }
            finally
            {
                if (proxy != null)
                {
                    try
                    {
                        ((IDisposable)proxy).Dispose();
                    }
                    catch (CommunicationException)
                    {
                        ((ICommunicationObject)proxy).Abort();
                    }
                    catch (TimeoutException)
                    {
                        ((ICommunicationObject)proxy).Abort();
                    }
                }
            }

            return result;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        public virtual void Send(Action<TContract> serviceCallDelegate)
        {
            TContract proxy = Proxy;
            try
            {
                serviceCallDelegate(proxy);
            }
            finally
            {
                if (proxy != null)
                {
                    try
                    {
                        ((IDisposable)proxy).Dispose();
                    }
                    catch (CommunicationException)
                    {
                        ((ICommunicationObject)proxy).Abort();
                    }
                    catch (TimeoutException)
                    {
                        ((ICommunicationObject)proxy).Abort();
                    }
                }
            }
        }

        private void ChannelFactory_Faulted(object sender, System.EventArgs e)
        {
            ICommunicationObject factory = (ICommunicationObject)sender;
            if (factory == ChannelFactory)
            {
                ChannelFactory = null;
            }
        }

        #region IDisposable Members

        // Track whether Dispose has been called.
        private bool disposed = false;

        // Implement IDisposable.
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                ChannelFactory = null;
            }
            disposed = true;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core\Wcf\MultipleBindingServiceHostFactory.cs ===
﻿using System;
using System.ServiceModel;
using System.ServiceModel.Activation;

namespace Leet.Core.Wcf
{
    /// <summary>
    /// WCF does not initialize correctly if IIS has more than one binding
    /// defined.  This class removes all base addresses (derived from the
    /// IIS bindings), allowing multiple bindings to be configured.  Each
    /// endpoint then must be defined using an absolute URL in web.config.
    /// 
    /// Deriving from this class allows the definition of endpoints through
    /// code instead of using web.config.
    /// </summary>
    public class MultipleBindingServiceHostFactory : ServiceHostFactory
    {
        public ServiceHost Host { get; set; }

        protected override System.ServiceModel.ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            Host = GetServiceHost(serviceType, baseAddresses);
            ConfigureEndpoints();
            return Host;
        }

        protected virtual void ConfigureEndpoints()
        {
        }

        protected virtual ServiceHost GetServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            return base.CreateServiceHost(serviceType, new Uri[0]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.IoCCo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope = "namespace", Target = "Leet.Core.IoCCo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope = "namespace", Target = "Leet.Core.IoCCo.Test")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", Scope = "namespace", Target = "Leet.Core.IoCCo.Test.TestServices")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Core.IoCCo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.IoCCo.Test")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Core.IoCCo.Test")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.ContainerTestExtensions.#RegisterWithCreateMock`1(Leet.Core.IoCCo.IContainer,Rhino.Mocks.MockRepository)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter", Scope = "member", Target = "Leet.Core.IoCCo.ContainerTestExtensions.#RegisterWithDynamicMock`1(Leet.Core.IoCCo.IContainer,Rhino.Mocks.MockRepository)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Constrctor", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_A_Component_With_More_Than_One_Constrctor_Throws()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_A_Component_With_One_Public_Constrctor_Works()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_Two_Different_Implementations_Of_Same_Service_Throws()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "OK", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_Two_Same_Implementations_Of_Same_Service_Is_OK()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_Two_Same_Implementations_Of_Same_Service_Is_OK()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#AddService_Returns_Container_Itself()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Components_Marked_As_Singleton_Are_Returned_One_Per_AppDomain()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Components_Marked_PerWebRequest_Are_Instantiated_Properly()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.IO.StringWriter.#ctor", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Components_Marked_PerWebRequest_Are_Instantiated_Properly()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Constructor_Parameters_That_Are_Services_Are_Mapped_Correctly()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Inhjections", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Generic_Parameter_Inhjections_Are_Supported()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Generic_Parameter_Inhjections_Are_Supported()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#GetComponent_For_Unregistered_Service_Throws_Helpful_Exception()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#GetComponent_For_Unregistered_Service_Throws_Helpful_Exception()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "component", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#GetComponent_For_Unregistered_Service_Throws_Helpful_Exception()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#GetComponent_Returns_An_Instance_Of_The_Registered_Service()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Getting_Component_With_Missing_Dependency_Throws()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Getting_Component_With_Missing_Dependency_Throws()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#NonGeneric_GetComponent_Returns_An_Instance_Of_The_Registered_Service()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "SetUp", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#SetUp()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Singleton_Instances_From_Different_Containers_Are_The_Same()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Activator_Instantiations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "component", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Activator_Instantiations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Container_Creations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Container_NonGeneric_Creations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "s", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Container_NonGeneric_Creations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Container_NonGeneric_With_Dependency_Creations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "Leet.Core.IoCCo.Test.TestServices.TestServiceComponent", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Direct_Instantiations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Time_Direct_Instantiations()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#UseLocal_Overrides_The_Instance()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "container", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#UseLocal_Overrides_The_Instance()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "container", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#UseLocal_Overrides_The_Instance()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "OK", Scope = "member", Target = "Leet.Core.IoCCo.Test.LocatorTests.#Adding_Two_Identical_Locators_For_Same_Service_Is_OK()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.LocatorTests.#Adding_Two_Identical_Locators_For_Same_Service_Is_OK()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.LocatorTests.#Container_Allows_Registering_A_Locator_For_Service()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations", Scope = "member", Target = "Leet.Core.IoCCo.Test.TestServices.GenericServiceWithDependency`1.#TestService")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1040:AvoidEmptyInterfaces", Scope = "type", Target = "Leet.Core.IoCCo.Test.TestServices.ITestService")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Multi", Scope = "type", Target = "Leet.Core.IoCCo.Test.TestServices.TestServiceMultiConstructorComponent")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "test", Scope = "member", Target = "Leet.Core.IoCCo.Test.TestServices.TestServiceMultiConstructorComponent.#.ctor(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Multi", Scope = "type", Target = "Leet.Core.IoCCo.Test.TestServices.TestServiceMultiConstructorComponentTwo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Leet.Core.IoCCo.Test.TestServices.TestServiceMultiConstructorComponentTwo.#.ctor(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "test", Scope = "member", Target = "Leet.Core.IoCCo.Test.TestServices.TestServiceMultiConstructorComponentTwo.#.ctor(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetBoolSetting_ReturnsCorrectValueForFalse()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetBoolSetting_ReturnsCorrectValueForTrue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetBoolSetting_ThrowsOnSettingValueNotABool()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetBoolSetting_ThrowsOnSettingValueNotABool()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetConnectionString_NotDefined()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetConnectionString_NotDefined()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetConnectionString_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetDoubleSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetDoubleSetting_UnderlyingSettingNotADouble()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetDoubleSetting_UnderlyingSettingNotADouble()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetIntSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetIntSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetIntSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetLongSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "ALong", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetLongSetting_UnderlyingSettingNotALong()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetLongSetting_UnderlyingSettingNotALong()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetLongSetting_UnderlyingSettingNotALong()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetSettingTest_SettingNotPresent()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetSettingTest_SettingNotPresent()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.AppSettingsConfigurationProviderTest.#GetSettingTest_SettingPresent()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Cofiguration", Scope = "type", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "result", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#ClearTest()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetBoolSetting_ReturnsCorrectValueForFalse()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetBoolSetting_ReturnsCorrectValueForTrue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetBoolSetting_ThrowsOnSettingValueNotABool()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetConnectionString_NotDefined()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetConnectionString_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetDoubleSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Double.ToString", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetDoubleSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetDoubleSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetDoubleSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetIntSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int32.ToString", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetIntSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetIntSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetIntSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetLongSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.ToString", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetLongSetting_ReturnsCorrectValue()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetLongSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "actual", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetLongSetting_UnderlyingSettingNotAnInt()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetSettingTest_SettingNotPresent()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetSettingTest_SettingPresent()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#LoadXml_Populates_Settings()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Io", Scope = "namespace", Target = "Leet.Core.IoCCo.Test.TestServices")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Core.IoCCo.Test.TestServices")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Core.Test")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Core.Test")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Core.Test.Configuration")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_A_Component_With_More_Than_One_Constrctor_Throws()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Constrctor", Scope = "member", Target = "Leet.Core.IoCCo.Test.ContainerTests.#Adding_A_Component_With_One_Public_Constrctor_Works()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetInterface_Returns_Correct_InterfaceInfo()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetInterface_Throws_When_Not_Defined()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetSingleInterface_Returns_Correct_InterfaceInfo()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Core.Test.Configuration.InMemoryCofigurationProviderTest.#GetSingleInterface_Throws_When_Not_Defined()")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\BI\BiLogTest.cs ===
﻿using System;
using System.Diagnostics;
using Leet.Core.Configuration;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.TestUtilities;
using Leet.Core.Diagnostics;
//using Rhino.Mocks;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Core.BI;
using System.Collections;
using System.Collections.Generic;

namespace Leet.Core.BI.Test
{
    
    [TestClass]
    public class BILogTest
    {
        [TestInitialize]
        public void TestInitialize()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void TestBILog_Valid_Test()
        {
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCredAvatar = new BICredentials(1, OriginatorIDType.Xbox, 5, "1.0.0", 1001, "Avatar", "1.0.0.0", "AT&T", "HTC", "Bothell");
            List<KeyValuePair<string, string>> avatarKVP = new List<KeyValuePair<string, string>>();
            avatarKVP.Add(new KeyValuePair<string, string>("High Score", "20"));
            avatarKVP.Add(new KeyValuePair<string, string>("UsageTime", "3 minutes"));
            avatarKVP.Add(new KeyValuePair<string, string>("UsageCount", "20"));
            biLog.Log(biCredAvatar, avatarKVP);
        }

        [TestMethod]
        public void TestBILog_Null_KVP()
        {

            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCred = new BICredentials(1, OriginatorIDType.Xbox, 5, "1.0.0", 1001, "Avatar", "1.0.0.0", "AT&T", "HTC", "Bothell");
            biLog.Log(biCred, null);
        }

        [TestMethod]
        public void TestBILog_Null_BICredentail()
        {

            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCred = null;
            List<KeyValuePair<string, string>> avatarKVP = new List<KeyValuePair<string, string>>();
            avatarKVP.Add(new KeyValuePair<string, string>("High Score", "20"));
            avatarKVP.Add(new KeyValuePair<string, string>("UsageTime", "3 minutes"));
            avatarKVP.Add(new KeyValuePair<string, string>("UsageCount", "20"));
            biLog.Log(biCred, avatarKVP);
        }

        [TestMethod]
        public void TestBILog_Invalid_BICredential_Values()
        {

            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCredAvatar = new BICredentials(0, OriginatorIDType.Xbox, -1, "", 0, "", "", "", "", "");
            List<KeyValuePair<string, string>> avatarKVP = new List<KeyValuePair<string, string>>();
            avatarKVP.Add(new KeyValuePair<string, string>("High Score", "20"));
            avatarKVP.Add(new KeyValuePair<string, string>("UsageTime", "3 minutes"));
            avatarKVP.Add(new KeyValuePair<string, string>("UsageCount", "20"));
            biLog.Log(biCredAvatar, avatarKVP);
        }

        [TestMethod]
        public void TestBILog_Null_BICredential_Values()
        {

            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCredAvatar2 = new BICredentials(0, OriginatorIDType.Xbox, 0, null, 1001, null, null, null, null, null);
            List<KeyValuePair<string, string>> avatarKVP2 = new List<KeyValuePair<string, string>>();
            avatarKVP2.Add(new KeyValuePair<string, string>("High Score", "20"));
            avatarKVP2.Add(new KeyValuePair<string, string>("UsageTime", "3 minutes"));
            avatarKVP2.Add(new KeyValuePair<string, string>("UsageCount", "20"));
            biLog.Log(biCredAvatar2, avatarKVP2);
        }

        [TestMethod]
        public void TestBILog_Invalid_KVP()
        {

            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCredAvatar2 = new BICredentials(0, OriginatorIDType.Xbox, 0, null, 1001, null, null, null, null, null);
            List<KeyValuePair<string, string>> avatarKVP3 = new List<KeyValuePair<string, string>>();
            avatarKVP3.Add(new KeyValuePair<string, string>(null, null));
            biLog.Log(biCredAvatar2, avatarKVP3);

            List<KeyValuePair<string, string>> avatarKVP4 = new List<KeyValuePair<string, string>>();
            avatarKVP4.Add(new KeyValuePair<string, string>("", ""));
            biLog.Log(biCredAvatar2, avatarKVP4);

            List<KeyValuePair<string, string>> avatarKVP5 = new List<KeyValuePair<string, string>>();
            avatarKVP5.Add(new KeyValuePair<string, string>("", "20"));
            biLog.Log(biCredAvatar2, avatarKVP5);

            List<KeyValuePair<string, string>> avatarKVP6 = new List<KeyValuePair<string, string>>();
            avatarKVP6.Add(new KeyValuePair<string, string>(null, "20"));
            biLog.Log(biCredAvatar2, avatarKVP6);
        }

        [TestMethod]
        public void TestBILog_KVP_Invalid_Values()
        {
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCredAvatar2 = new BICredentials(0, OriginatorIDType.Xbox, 0, null, 1001, null, null, null, null, null);
            List<KeyValuePair<string, string>> avatarKVP7 = new List<KeyValuePair<string, string>>();
            avatarKVP7.Add(new KeyValuePair<string, string>("High Score", ""));
            biLog.Log(biCredAvatar2, avatarKVP7);

            List<KeyValuePair<string, string>> avatarKVP8 = new List<KeyValuePair<string, string>>();
            avatarKVP8.Add(new KeyValuePair<string, string>("High Score", null)); 
            biLog.Log(biCredAvatar2, avatarKVP8);

        }

        [TestMethod]
        public void TestBILog_BICred_ToString_Test()
        {

            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            BICredentials biCredAvatar = new BICredentials(1, OriginatorIDType.Xbox, 5, "1.0.0", 1001, "Avatar", "1.0.0.0", "AT&T", "HTC", "Bothell");
            string str = biCredAvatar.ToString();
        }

        [TestMethod]
        public void TestBILog_Valid_Loop()
        {
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            Container.Instance.AddService<IBILog, BILog>();
            ConfigurationSelector.RegisterProvider("BI_core_unit_test", "LEET");
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            for (int i = 0; i < 100; i++)
            {
                BICredentials biCredAvatar1 = new BICredentials(32, OriginatorIDType.Xbox, 5, "1.0.0", 1001, (String.Format("Avatar{0}", i)), "1.0.0.0", "AT&T", "Samsung", "Seattle");
                List<KeyValuePair<string, string>> avatar1KVP = new List<KeyValuePair<string, string>>();
                avatar1KVP.Add(new KeyValuePair<string, string>(String.Format("{0}{1}", "High Score", i), "20"));
                avatar1KVP.Add(new KeyValuePair<string, string>(String.Format("{0}{1}", "UsageTime", i), "3 minutes"));
                avatar1KVP.Add(new KeyValuePair<string, string>(String.Format("{0}{1}", "UsageCount", i), "20"));
                biLog.Log(biCredAvatar1, avatar1KVP);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Caching\AspNetCacheAdapterTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.Caching;

namespace Leet.Core.Test.Caching
{

    [TestClass]
    public class AspNetCacheAdapterTest
    {
        [TestMethod]
        public void Clear_Clears_The_Cache()
        {
            // Arrange
            var cache = new AspNetCacheAdapter();
            cache.Insert("a", "w", DateTime.UtcNow.AddSeconds(100));
            cache.Insert("b", "x", DateTime.UtcNow.AddSeconds(100));
            cache.Insert("c", "y", DateTime.UtcNow.AddSeconds(100));
            cache.Insert("d", "z", DateTime.UtcNow.AddSeconds(100));

            Assert.IsNotNull(cache.GetObject("a"));
            Assert.IsNotNull(cache.GetObject("b"));
            Assert.IsNotNull(cache.GetObject("c"));
            Assert.IsNotNull(cache.GetObject("d"));

            // Act
            cache.Clear();

            // Assert
            Assert.IsNull(cache.GetObject("a"));
            Assert.IsNull(cache.GetObject("b"));
            Assert.IsNull(cache.GetObject("c"));
            Assert.IsNull(cache.GetObject("d"));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Configuration\AppSettingsConfigurationProviderTest.cs ===
﻿using Leet.Core.Configuration;
using System.Globalization;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Core.Test
{
    // The unit tests in this class require that there be an app.config file with the
    // following settings
    // 
    // <configuration>
    //    <connectionStrings>
    //        <add name="TestConnection" connectionString="Valid connection string"/>
    //    </connectionStrings>
    //    <appSettings>
    //        <add key="ValidStringSetting" value="Test value"/>
    //        <!-- <add key="MissingStringSetting" value="Test value"/> -->
    //        <add key="ValidIntSetting" value="-123"/>
    //        <add key="InvalidIntSetting" value="xxx"/>
    //        <add key="ValidLongSetting" value="-1234567890"/>
    //        <add key="InvalidLongSetting" value="xxx"/>
    //        <add key="ValidDoubleSetting" value="-3.14159265"/>
    //        <add key="InvalidDoubleSetting" value="xxx"/>
    //        <add key="ValidTrueBoolSetting" value="true"/>
    //        <add key="ValidFalseBoolSetting" value="False"/>
    //        <add key="InvalidBoolSetting" value="xxx"/>
    //    </appSettings>
    // </configuration>

    /// <summary>
    ///This is a test class for AppSettingsConfigurationProviderTest and is intended
    ///to contain all AppSettingsConfigurationProviderTest Unit Tests
    ///</summary>
    [TestClass()]
    public class AppSettingsConfigurationProviderTest
    {
        [TestInitialize()]
        public void MyTestInitialize()
        {
        }

        [TestCleanup()]
        public void MyTestCleanup()
        {
        }

        [TestMethod()]
        public void GetSettingTest_SettingPresent()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "ValidStringSetting";
            string expected = "Test value";
            string actual;

            actual = config.GetSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetSettingTest_SettingNotPresent()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            
            string actual = config.GetSetting("MissingStringSetting");
            
            Assert.Fail("GetSetting returned a value for a non-existent setting. An exception was expected.");
        }

        [TestMethod()]
        public void GetIntSetting_ReturnsCorrectValue()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "ValidIntSetting";
            int expected = -123;
            int actual;

            actual = config.GetIntSetting(settingName);
            
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetIntSetting_UnderlyingSettingNotAnInt()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "InvalidIntSetting";
            
            int actual = config.GetIntSetting(settingName);
            
            Assert.Fail("GetIntSetting returned a value for an invalid setting. An exception was expected.");
        }

        [TestMethod()]
        public void GetLongSetting_ReturnsCorrectValue()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "ValidLongSetting";
            long expected = -1234567890;
            
            long actual = config.GetLongSetting(settingName);
            
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetLongSetting_UnderlyingSettingNotALong()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "InvalidLongSetting";
            
            long actual = config.GetLongSetting(settingName);
            
            Assert.Fail("GetLongSetting returned a value for an invalid setting. An exception was expected.");
        }

        [TestMethod()]
        public void GetDoubleSetting_ReturnsCorrectValue()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "ValidDoubleSetting";
            double expected = -3.14159265;
            
            double actual = config.GetDoubleSetting(settingName);
            
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetDoubleSetting_UnderlyingSettingNotADouble()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "InvalidDoubleSetting";
            
            double actual = config.GetDoubleSetting(settingName);
            
            Assert.Fail("GetDoubleSetting returned a value for an invalid setting. An exception was expected.");
        }

        [TestMethod()]
        public void GetConnectionString_ReturnsCorrectValue()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string interfaceName = "TestConnection";
            string expected = "Valid connection string";

            string actual = config.GetConnectionString(interfaceName);
            
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetConnectionString_NotDefined()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            
            string actual = config.GetConnectionString("NonExistentSetting");
            
            Assert.Fail("GetConnectionString returned a value for a non-existent setting. An exception was expected.");
        }

        [TestMethod()]
        public void GetBoolSetting_ReturnsCorrectValueForTrue()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "ValidTrueBoolSetting";
            bool expected = true;

            bool actual = config.GetBoolSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        public void GetBoolSetting_ReturnsCorrectValueForFalse()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "ValidFalseBoolSetting";
            bool expected = false;

            bool actual = config.GetBoolSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetBoolSetting_ThrowsOnSettingValueNotABool()
        {
            AppSettingsConfigurationProvider config = new AppSettingsConfigurationProvider();
            string settingName = "InvalidBoolSetting";

            bool actual = config.GetBoolSetting(settingName);

            Assert.Fail("GetBoolSetting returned a value for an invalid setting. An exception was expected.");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Configuration\ConfigurationProviderBaseTest.cs ===
﻿using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.Configuration;
using Rhino.Mocks;
using System;

namespace Leet.Core.Test.Configuration
{
    [TestClass]
    public class ConfigurationProviderBaseTest
    {
        [TestMethod]
        public void GetInterfaceEndpoint_Calls_GetInterface_From_ConfigurationProvider()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var configProvider = stubber.RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(c => c.GetInterface(Arg<string>.Is.Anything, Arg<string>.Is.Anything)).Return(new InterfaceInfo() { Name = "test_interface" });
            configProvider.Stub(c => c.GetSingleServerForInterface(Arg<string>.Is.Anything)).Return("test_server");

            InMemoryConfigurationProvider config = new InMemoryConfigurationProvider();

            // Act
            config.GetInterfaceEndpoint("test_interface", false);

            // Assert
            configProvider.AssertWasCalled(c => c.GetInterface(System.Environment.MachineName, "test_interface"));
        }

        public void GetInterfaceEndpoint_UseSecureEndpoint_Calls_GetInterface_For_Secure_Interface_From_ConfigurationProvider()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var configProvider = stubber.RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(c => c.GetInterface(Arg<string>.Is.Anything, Arg<string>.Is.Anything)).Return(new InterfaceInfo() { Name = "test_interface" });

            InMemoryConfigurationProvider config = new InMemoryConfigurationProvider();

            // Act
            config.GetInterfaceEndpoint("test_interface", true);

            // Assert
            configProvider.AssertWasCalled(c => c.GetInterface(System.Environment.MachineName, "test_interface_secure"));
        }

        [TestMethod]
        public void GetInterfaceEndpoint_Retuns_MachineName_If_Info1_Is_Blank()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var configProvider = stubber.RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(c => c.GetInterface(Arg<string>.Is.Anything, Arg<string>.Is.Anything)).Return(new InterfaceInfo() { Name = "test_interface", Port=12 });
            configProvider.Stub(c => c.GetSingleServerForInterface("test_interface")).Return("server1");

            InMemoryConfigurationProvider config = new InMemoryConfigurationProvider();

            // Act
            var endpoint = config.GetInterfaceEndpoint("test_interface", false);

            // Assert
            Assert.AreEqual("http://server1:12/", endpoint);
        }

        [TestMethod]
        public void GetInterfaceEndpoint_Retuns_Info1_With_No_Port()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var configProvider = stubber.RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(c => c.GetInterface(Arg<string>.Is.Anything, Arg<string>.Is.Anything)).Return(new InterfaceInfo() { Name = "test_interface", Info1 = "www.test.com" });

            InMemoryConfigurationProvider config = new InMemoryConfigurationProvider();

            // Act
            var endpoint = config.GetInterfaceEndpoint("test_interface", false);

            // Assert
            Assert.AreEqual("http://www.test.com/", endpoint);
        }

        [TestMethod]
        public void GetInterfaceEndpoint_UseSecureEndpoint_Retuns_MachineName_If_Info1_Is_Blank()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var configProvider = stubber.RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(c => c.GetInterface(Arg<string>.Is.Anything, Arg<string>.Is.Anything)).Return(new InterfaceInfo() { Name = "test_interface_secure", Port=12 });
            configProvider.Stub(c => c.GetSingleServerForInterface("test_interface_secure")).Return("server1");

            InMemoryConfigurationProvider config = new InMemoryConfigurationProvider();

            // Act
            var endpoint = config.GetInterfaceEndpoint("test_interface", true);

            // Assert
            Assert.AreEqual("https://server1:12/", endpoint);
        }

        [TestMethod]
        public void GetInterfaceEndpoint_UseSecureEndpoint_Retuns_Info1_With_No_Port()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var configProvider = stubber.RegisterWithContainer<IConfigurationProvider>();
            configProvider.Stub(c => c.GetInterface(Arg<string>.Is.Anything, Arg<string>.Is.Anything)).Return(new InterfaceInfo() { Name = "test_interface", Info1 = "www.test.com" });

            InMemoryConfigurationProvider config = new InMemoryConfigurationProvider();

            // Act
            var endpoint = config.GetInterfaceEndpoint("test_interface", true);

            // Assert
            Assert.AreEqual("https://www.test.com/", endpoint);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Configuration\InMemoryCofigurationProviderTest.cs ===
﻿using System;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;

namespace Leet.Core.Test.Configuration
{
    [TestClass]
    public class InMemoryCofigurationProviderTest
    {
        [TestInitialize()]
        public void MyTestInitialize()
        {
            InMemoryConfigurationProvider.Clear();
        }

        [TestCleanup()]
        public void MyTestCleanup()
        {
            InMemoryConfigurationProvider.Clear();
        }

        [TestMethod()]
        public void GetSettingTest_SettingPresent()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "TestSetting";
            string expected = "Pass";
            string actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected);
            actual = target.GetSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetSettingTest_SettingNotPresent()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "TestSetting";
            string expected = "Pass";
            string actual;

            InMemoryConfigurationProvider.SetSetting("Not" + settingName, expected);
            actual = target.GetSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        public void GetIntSetting_ReturnsCorrectValue()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "IntSetting";
            int expected = 5;
            int actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected.ToString());
            actual = target.GetIntSetting(settingName);
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetIntSetting_UnderlyingSettingNotAnInt()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "IntSetting";
            int actual;

            InMemoryConfigurationProvider.SetSetting(settingName, "Not an int");
            actual = target.GetIntSetting(settingName);
        }

        [TestMethod()]
        public void GetConnectionString_ReturnsCorrectValue()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "MyInterface";
            string expected = "A connection string";
            string actual;

            InMemoryConfigurationProvider.SetConnectionString(interfaceName, expected);
            actual = target.GetConnectionString(interfaceName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetConnectionString_NotDefined()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "MyInterface";
            string expected = "A connection string";
            string actual;

            InMemoryConfigurationProvider.SetConnectionString("Not" + interfaceName, expected);
            actual = target.GetConnectionString(interfaceName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        public void GetBoolSetting_ReturnsCorrectValueForFalse()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");

            string settingName = "BoolSetting";
            bool expected = false;
            bool actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected.ToString());
            actual = target.GetBoolSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        public void GetBoolSetting_ReturnsCorrectValueForTrue()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");

            string settingName = "BoolSetting";
            bool expected = true;
            bool actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected.ToString());
            actual = target.GetBoolSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetBoolSetting_ThrowsOnSettingValueNotABool()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");

            string settingName = "BoolSetting";
            bool expected = true;
            bool actual;

            InMemoryConfigurationProvider.SetSetting(settingName, "Not a bool");
            actual = target.GetBoolSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        public void GetLongSetting_ReturnsCorrectValue()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "IntSetting";
            long expected = 5;
            long actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected.ToString());
            actual = target.GetLongSetting(settingName);
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetLongSetting_UnderlyingSettingNotAnInt()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "IntSetting";
            long actual;

            InMemoryConfigurationProvider.SetSetting(settingName, "Not an int");
            actual = target.GetLongSetting(settingName);
        }

        [TestMethod()]
        public void GetDoubleSetting_ReturnsCorrectValue()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "IntSetting";
            double expected = 5;
            double actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected.ToString());
            actual = target.GetDoubleSetting(settingName);
            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetDoubleSetting_UnderlyingSettingNotAnInt()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "IntSetting";
            double actual;

            InMemoryConfigurationProvider.SetSetting(settingName, "Not an int");
            actual = target.GetDoubleSetting(settingName);
        }

        [TestMethod]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetSingleInterface_Throws_When_Not_Defined()
        {
            // Arrange
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "leet_interface";

            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = "xboxcom_interface" });

            // Act
            target.GetSingleInterface(interfaceName);
        }

        [TestMethod]
        public void GetSingleInterface_Returns_Correct_InterfaceInfo()
        {
            // Arrange
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "leet_interface";
            int virtualSiteId = 10101;
            int port = 10102;

            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = interfaceName, VSiteId = virtualSiteId, Port = port });

            // Act
            var interfaceInfo = target.GetSingleInterface(interfaceName);

            // Assert
            Assert.AreEqual(virtualSiteId, interfaceInfo.VSiteId);
            Assert.AreEqual(port, interfaceInfo.Port);
        }

        [TestMethod]
        [ExpectedException(typeof(System.Configuration.ConfigurationErrorsException))]
        public void GetInterface_Throws_When_Not_Defined()
        {
            // Arrange
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "leet_interface";

            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = "xboxcom_interface" });

            // Act
            target.GetInterface("bogusComputer", interfaceName);
        }

        [TestMethod]
        public void GetInterface_Returns_Correct_InterfaceInfo()
        {
            // Arrange
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "leet_interface";
            int virtualSiteId = 10101;
            int port = 10102;

            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = interfaceName, VSiteId = virtualSiteId, Port = port });

            // Act
            var interfaceInfo = target.GetInterface("bogusComputer", interfaceName);

            // Assert
            Assert.AreEqual(virtualSiteId, interfaceInfo.VSiteId);
            Assert.AreEqual(port, interfaceInfo.Port);
        }

        [TestMethod()]
        public void ClearSettingsTest()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            InMemoryConfigurationProvider.SetSetting("testClear", "hasValue");

            Assert.AreEqual("hasValue", target.GetSetting("testClear"));

            InMemoryConfigurationProvider.Clear();

            bool gotException = false;
            try
            {
                target.GetSetting("testClear");
            }
            catch (System.Configuration.ConfigurationErrorsException)
            {
                gotException = true;
            }

            Assert.IsTrue(gotException);
        }

        [TestMethod()]
        public void ClearConnectionStringsTest()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            InMemoryConfigurationProvider.SetConnectionString("leet_test", "SERVER=test;DATABASE=test;");

            Assert.AreEqual("SERVER=test;DATABASE=test;", target.GetConnectionString("leet_test"));

            InMemoryConfigurationProvider.Clear();

            bool gotException = false;
            try
            {
                target.GetConnectionString("leet_test");
            }
            catch (System.Configuration.ConfigurationErrorsException)
            {
                gotException = true;
            }

            Assert.IsTrue(gotException);
        }

        [TestMethod()]
        public void ClearInterfacesTest()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = "leet_test", Port = 10101, VSiteId = 10102 });

            Assert.AreEqual(10101, target.GetSingleInterface("leet_test").Port);

            InMemoryConfigurationProvider.Clear();

            bool gotException = false;
            try
            {
                target.GetSingleInterface("leet_test");
            }
            catch (System.Configuration.ConfigurationErrorsException)
            {
                gotException = true;
            }

            Assert.IsTrue(gotException);
        }

        [TestMethod]
        public void Clear_ClearsServerInterfaceAssociations()
        {
            // Arrange
            var interfaceName = Guid.NewGuid().ToString();
            var serverName = Guid.NewGuid().ToString();


            var target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = interfaceName, Port = 10101, VSiteId = 10102 });
            InMemoryConfigurationProvider.AddInterfaceServer(interfaceName, serverName);

            var repository = new MockRepository();
            var container = repository.StrictMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Stub(c => c.GetComponent<IConfigurationProvider>()).Return(target);
            container.Replay();

            // Act & Assert
            InMemoryConfigurationProvider.Clear();
            InMemoryConfigurationProvider.AddInterface(new InterfaceInfo() { Name = interfaceName, Port = 10101, VSiteId = 10102 });
            AssertException.Expect<System.Configuration.ConfigurationErrorsException>(
                () => target.GetInterfaceEndpoint(interfaceName, false));
        }

        [TestMethod()]
        public void AddSettingTest()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string settingName = "TestSetting";
            string expected = "Pass";
            string actual;

            InMemoryConfigurationProvider.SetSetting(settingName, expected);
            actual = target.GetSetting(settingName);

            Assert.AreEqual(expected, actual);
        }

        [TestMethod()]
        public void AddConnectionStringTest()
        {
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize("testComponent");
            string interfaceName = "MyInterface";
            string expected = "A connection string";
            string actual;

            InMemoryConfigurationProvider.SetConnectionString(interfaceName, expected);
            actual = target.GetConnectionString(interfaceName);

            Assert.AreEqual(expected, actual);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void Initialize_Sets_Properties()
        {
            // Arrange
            var componentName = "unitTestComponent";

            // Act
            InMemoryConfigurationProvider target = new InMemoryConfigurationProvider();
            target.Initialize(componentName);

            // Assert
            Assert.AreEqual(componentName, target.ComponentName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Configuration\ConfigurationSelectorTest.cs ===
﻿using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Win32;
using Rhino.Mocks;
using System.Configuration;

namespace Leet.Core.Test.Configuration
{
    [TestClass]
    public class ConfigurationSelectorTest
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void RegisterProvider_Loads_InMemoryConfigurationProvider_When_File_Specified_In_Registry()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.RegisterKeys();
            stubs.RegisterFileValues();

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "LEET");

            // Assert
            var configurationProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            Assert.IsInstanceOfType(configurationProvider, typeof(InMemoryConfigurationProvider));
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Doesnt"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void RegisterProvider_Loads_AppSettingsConfigurationProvider_If_RegistryKey_Doesnt_Exist()
        {
            // Arrange
            Stubs stubs = new Stubs();

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "LEET");

            // Assert
            var configurationProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            Assert.IsInstanceOfType(configurationProvider, typeof(AppSettingsConfigurationProvider));
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void RegisterProvider_Registers_AppSettingsConfigurationProvider_If_File_And_Server_Not_Specified_In_Registry()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.RegisterKeys();

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "LEET");

            // Assert
            var configurationProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            Assert.IsInstanceOfType(configurationProvider, typeof(AppSettingsConfigurationProvider));
        }

        [TestMethod]
        public void RegisterProvider_Registers_AppSettingsConfigurationProvider_If_ConfigurationSet_Not_In_Registry()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.RegistryProvider.Stub(
                rp => rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                    .Return(Registry.Users);

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "LEET");

            // Assert
            var configurationProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            Assert.IsInstanceOfType(configurationProvider, typeof(AppSettingsConfigurationProvider));
        }

        [TestMethod]
        public void RegistryProvider_Loads_NpdbConfigurationProvider_For_ConfigurationSet()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.RegisterKeys();
            stubs.RegisterConfigurationSetNpdbValues();

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "LEET");

            // Assert
            var configurationProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            Assert.IsInstanceOfType(configurationProvider, typeof(NpdbConfigurationProvider));
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException))]
        public void RegistryProvider_Throws_Exception_If_NpdbConfigurationProvider_Server_Not_In_Registry_For_Platform()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.RegisterKeys();

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "");
        }

        [TestMethod]
        public void RegistryProvider_Loads_NpdbConfigurationProvider_For_Platform()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.RegisterKeys();
            stubs.RegisterPlatformNpdbValues();

            // Act
            ConfigurationSelector.RegisterProvider("test_component", "");

            // Assert
            var configurationProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            Assert.IsInstanceOfType(configurationProvider, typeof(NpdbConfigurationProvider));
        }


        class Stubs
        {
            public IRegistryProvider RegistryProvider;
            public IFileSystem FileSystem;

            public Stubs()
            {
                Stubber stubber = new Stubber();
                RegistryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
                FileSystem = stubber.RegisterWithContainer<IFileSystem>();
            }

            public void RegisterKeys()
            {
                RegistryProvider.Stub(
                    rp => rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                        .Return(Registry.Users);
                RegistryProvider.Stub(
                    rp => rp.OpenSubKey(Registry.Users, "LEET"))
                        .Return(Registry.CurrentConfig);
            }

            public void RegisterFileValues()
            {
                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.CurrentConfig, "FILE"))
                    .Return("LEET_FILE.xml");
            }

            public void RegisterConfigurationSetNpdbValues()
            {
                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.CurrentConfig, "Server"))
                    .Return("LeetServer");
                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.CurrentConfig, "Database"))
                    .Return("LeetDatabase");
            }

            public void RegisterPlatformNpdbValues()
            {
                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.Users, "Server"))
                    .Return("LeetServer");
                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.Users, "Database"))
                    .Return("LeetDatabase");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Configuration\InMemoryConfigurationXmlLoaderTest.cs ===
﻿using System.Configuration;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Win32;
using Rhino.Mocks;

namespace Leet.Core.Test.Configuration
{
    [TestClass]
    public class InMemoryConfigurationXmlLoaderTest
    {
        [TestInitialize()]
        public void MyTestInitialize()
        {
            InMemoryConfigurationProvider.Clear();
        }

        [TestCleanup()]
        public void MyTestCleanup()
        {
            InMemoryConfigurationProvider.Clear();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void Load_No_Files_In_Registry_Never_Tries_To_Load_Files()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.RegistryProvider.Stub(
                rp => rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            stubs.RegistryProvider.Stub(
                rp => rp.OpenSubKey(Registry.Users, "LEET"))
                .Return(Registry.CurrentConfig);

            // Act
            InMemoryConfigurationXmlLoader.Load("LEET");

            // Assert
            stubs.FileProvider.AssertWasNotCalled(fp => fp.ReadAllText(Arg<string>.Is.Anything));
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void Load_Common_File_In_Registry_Calls_Load_Files_Once()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.RegistryProvider.Stub(
                rp => rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            stubs.RegistryProvider.Stub(
                rp => rp.OpenSubKey(Registry.Users, "LEET"))
                .Return(Registry.CurrentConfig);
            stubs.RegistryProvider.Stub(
                rp => rp.GetValue(Registry.CurrentConfig, "FILE"))
                .Return("LEET_FILE.xml");

            // Act
            InMemoryConfigurationXmlLoader.Load("LEET");

            // Assert
            stubs.FileProvider.AssertWasCalled(fp => fp.ReadAllText("LEET_FILE.xml"));
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void Load_Loads_Common_File()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();
            stubs.StubFileContents();

            InMemoryConfigurationProvider configProvider = new InMemoryConfigurationProvider();
            configProvider.Initialize("testComponent");

            // Act
            InMemoryConfigurationXmlLoader.Load("LEET");

            // Assert
            Assert.AreEqual("Value1", configProvider.GetSetting("Cosmos_Setting2"));
            Assert.AreEqual("SERVER=.", configProvider.GetConnectionString("db"));
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void Load_Loads_Common_And_Override_File()
        {
            // Arrange
            InMemoryConfigurationProvider configProvider = new InMemoryConfigurationProvider();
            configProvider.Initialize("testComponent");
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();
            stubs.StubFileContents();

            // Act
            InMemoryConfigurationXmlLoader.Load("LEET");

            // Assert
            Assert.AreEqual("Value2", configProvider.GetSetting("Cosmos_Setting1"));
            Assert.AreEqual("SERVER=.", configProvider.GetConnectionString("db"));
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores"), TestMethod]
        public void Load_Gets_Interface()
        {
            // Arrange
            InMemoryConfigurationProvider configProvider = new InMemoryConfigurationProvider();
            configProvider.Initialize("testComponent");
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();
            stubs.StubFileContents();

            // Act
            InMemoryConfigurationXmlLoader.Load("LEET");

            // Assert
            Assert.AreEqual(10101, configProvider.GetSingleInterface("cosmos_authoring").VSiteId);
            Assert.AreEqual(10101, configProvider.GetSingleInterface("cosmos_authoring").Port);
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\ does not exist.")]
        public void Load_Throws_Exception_If_CommonConfig_Not_In_Registry()
        {
            LoadStubs stubs = new LoadStubs();
            InMemoryConfigurationXmlLoader.Load("LEET");
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\LEET does not exist.")]
        public void Load_Throws_Exception_If_ConfigurationSet_Not_In_Registry()
        {
            LoadStubs stubs = new LoadStubs();
            stubs.RegistryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);

            InMemoryConfigurationXmlLoader.Load("LEET");
        }

        [TestMethod]
        public void Setting_Name_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Settings>" +
                        "<Setting value=\"Value1\" />" +
                    "</Settings>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing name attribute.  File: LEET_FILE.xml.  Element: <Setting value=\"Value1\" />", actual.Message);
        }

        [TestMethod]
        public void Setting_Value_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Settings>" +
                        "<Setting name=\"Name1\" />" +
                    "</Settings>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing value attribute.  File: LEET_FILE.xml.  Element: <Setting name=\"Name1\" />", actual.Message);
        }

        [TestMethod]
        public void ConnectionString_Interface_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<ConnectionStrings>" +
                        "<ConnectionString value=\"Value1\" />" +
                    "</ConnectionStrings>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing interface attribute.  File: LEET_FILE.xml.  Element: <ConnectionString value=\"Value1\" />", actual.Message);
        }

        [TestMethod]
        public void ConnectionString_Value_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<ConnectionStrings>" +
                        "<ConnectionString interface=\"Interface1\" />" +
                    "</ConnectionStrings>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing value attribute.  File: LEET_FILE.xml.  Element: <ConnectionString interface=\"Interface1\" />", actual.Message);
        }

        [TestMethod]
        public void Interface_Name_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Interfaces>" +
                        "<Interface port=\"111\" virtualSiteId=\"111\" />" +
                    "</Interfaces>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing name attribute.  File: LEET_FILE.xml.  Element: <Interface port=\"111\" virtualSiteId=\"111\" />", actual.Message);
        }

        [TestMethod]
        public void Interface_Port_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Interfaces>" +
                        "<Interface interface=\"Interface1\" virtualSiteId=\"111\" name=\"Interface1\" />" +
                    "</Interfaces>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing port attribute.  File: LEET_FILE.xml.  Element: <Interface interface=\"Interface1\" virtualSiteId=\"111\" name=\"Interface1\" />", actual.Message);
        }

        [TestMethod]
        public void Interface_Port_Invalid_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Interfaces>" +
                        "<Interface port=\"99999\" virtualSiteId=\"111\" name=\"Interface1\" />" +
                    "</Interfaces>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Invalid port attribute.  File: LEET_FILE.xml.  Element: <Interface port=\"99999\" virtualSiteId=\"111\" name=\"Interface1\" />", actual.Message);
        }

        [TestMethod]
        public void Interface_VirtualSiteId_Missing_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Interfaces>" +
                        "<Interface port=\"111\" name=\"Interface1\" />" +
                    "</Interfaces>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Missing virtualSiteId attribute.  File: LEET_FILE.xml.  Element: <Interface port=\"111\" name=\"Interface1\" />", actual.Message);
        }

        [TestMethod]
        public void Interface_VirtualSiteId_Invalid_Throws_Exception()
        {
            // Arrange
            LoadStubs stubs = new LoadStubs();
            stubs.StubRegistryValues();

            stubs.FileProvider.Stub(
                fp => fp.ReadAllText("LEET_FILE.xml"))
                .Return(
                "<Configuration>" +
                    "<Interfaces>" +
                        "<Interface port=\"111\" virtualSiteId=\"99999\" name=\"Interface1\" />" +
                    "</Interfaces>" +
                "</Configuration>");

            // Act
            ConfigurationErrorsException actual = null;
            try
            {
                InMemoryConfigurationXmlLoader.Load("LEET");
            }
            catch (ConfigurationErrorsException ex)
            {
                actual = ex;
            }

            // Assert
            Assert.IsNotNull(actual);
            Assert.AreEqual("Invalid virtualSiteId attribute.  File: LEET_FILE.xml.  Element: <Interface port=\"111\" virtualSiteId=\"99999\" name=\"Interface1\" />", actual.Message);
        }


        class LoadStubs
        {
            public IRegistryProvider RegistryProvider { get; set; }
            public IFileSystem FileProvider { get; set; }

            public LoadStubs()
            {
                Stubber stubber = new Stubber();

                RegistryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
                FileProvider = stubber.RegisterWithContainer<IFileSystem>();
            }

            public void StubRegistryValues()
            {
                RegistryProvider.Stub(
                    rp => rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                    .Return(Registry.Users);
                RegistryProvider.Stub(
                    rp => rp.OpenSubKey(Registry.Users, "LEET"))
                    .Return(Registry.CurrentConfig);

                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.CurrentConfig, "FILE"))
                    .Return("LEET_FILE.xml");
                RegistryProvider.Stub(
                    rp => rp.GetValue(Registry.CurrentConfig, "OVERRIDE"))
                    .Return("LEET_OVERRIDE.xml");
            }

            public void StubFileContents()
            {
                FileProvider.Stub(
                    fp => fp.ReadAllText("LEET_FILE.xml"))
                    .Return(
                    "<Configuration>" +
                        "<Settings>" +
                            "<Setting name=\"Cosmos_Setting1\" value=\"Value1\" />" +
                            "<Setting name=\"Cosmos_Setting2\" value=\"Value1\" />" +
                        "</Settings>" +
                        "<ConnectionStrings>" +
                            "<ConnectionString interface=\"db\" value=\"SERVER=.\" />" +
                        "</ConnectionStrings>" +
                        "<Interfaces>" +
                            "<Interface name=\"cosmos_authoring\" virtualSiteId=\"10101\" port=\"10101\" />" +
                        "</Interfaces>" +
                    "</Configuration>");

                FileProvider.Stub(
                    fp => fp.ReadAllText("LEET_OVERRIDE.xml"))
                    .Return(
                    "<Configuration>" +
                        "<Settings>" +
                            "<Setting name=\"Cosmos_Setting1\" value=\"Value2\" />" +
                        "</Settings>" +
                    "</Configuration>");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Diagnostics\LogFormatterTest.cs ===
﻿using System;
using System.Diagnostics;
using System.Web;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Core.Diagnostics.Test
{
    [TestClass]
    public class LogFormatterTest
    {
        [TestMethod]
        public void Format_Event_No_Message_No_Exception_Returns_Formatted_Message()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            // Act
            var actual = formatter.Format(new TestEvent(), String.Empty, null);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>13</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A test error has occurred.</Message>"));
        }

        [TestMethod]
        public void Format_Event_No_Message_No_Exception_With_Metadata_Returns_Formatted_Message()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();
            TestEvent evt = new TestEvent();
            evt.Metadata["Area"] = "LogFormatterTest";

            // Act
            var actual = formatter.Format(evt, String.Empty, null);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>13</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A test error has occurred.</Message>"));
            Assert.IsTrue(actual.Contains("<Area>LogFormatterTest</Area>"));
        }

        [TestMethod]
        public void Format_Event_Message_No_Exception_Returns_Formatted_Message()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            Guid guid = Guid.NewGuid();

            // Act
            var actual = formatter.Format(new TestEvent(), guid.ToString(), null);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>13</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A test error has occurred."));
            Assert.IsTrue(actual.Contains(guid.ToString()));
        }

        [TestMethod]
        public void Format_Event_No_Message_Exception_Returns_Formatted_Message()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            Exception ex = new Exception("Format_Event_No_Message_Exception_Returns_Formatted_Message");

            // Act
            var actual = formatter.Format(new TestEvent(), String.Empty, ex);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>13</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A test error has occurred."));
            Assert.IsTrue(actual.Contains(ex.ToString()));
            Assert.IsTrue(actual.Contains("Format_Event_No_Message_Exception_Returns_Formatted_Message"));
        }

        [TestMethod]
        public void Format_Event_No_Message_Exception_With_Inner_Exceptions_Returns_Formatted_Message()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            Exception ex3 = new Exception("ex3");
            Exception ex2 = new Exception("ex2", ex3);
            Exception ex1 = new Exception("ex1", ex2);

            // Act
            var actual = formatter.Format(new TestEvent(), String.Empty, ex1);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>13</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A test error has occurred."));
            Assert.IsTrue(actual.Contains(HttpUtility.HtmlEncode(ex1.ToString())));
            Assert.IsTrue(actual.Contains("ex3"));
            Assert.IsTrue(actual.Contains("ex2"));
            Assert.IsTrue(actual.Contains("ex1"));
        }

        [TestMethod]
        public void Format_Event_Message_And_Exception_Returns_Formatted_Message()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            Exception ex3 = new Exception("ex3");
            Exception ex2 = new Exception("ex2", ex3);
            Exception ex1 = new Exception("ex1", ex2);

            Guid guid = Guid.NewGuid();

            // Act
            var actual = formatter.Format(new TestEvent(), guid.ToString(), ex1);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>13</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A test error has occurred."));
            Assert.IsTrue(actual.Contains(HttpUtility.HtmlEncode(ex1.ToString())));
            Assert.IsTrue(actual.Contains("ex3"));
            Assert.IsTrue(actual.Contains("ex2"));
            Assert.IsTrue(actual.Contains("ex1"));
            Assert.IsTrue(actual.Contains(guid.ToString()));
        }

        [TestMethod]
        public void Format_Returns_Custom_Event_Data()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            // Act
            var actual = formatter.Format(new CustomEvent(), String.Empty, null);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>1313</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A custom event has occurred.</Message>"));
            Assert.IsTrue(actual.Contains("<Custom1>Custom data 1.</Custom1>"));
            Assert.IsTrue(actual.Contains("<Custom2>Custom data 2.</Custom2>"));
            Assert.IsTrue(actual.Contains("<Custom3>Custom data 3.</Custom3>"));
        }

        [TestMethod]
        public void Format_Returns_Custom_Data_From_Parent_Classes()
        {
            // Arrange
            LogFormatter formatter = new LogFormatter();

            // Act
            var actual = formatter.Format(new MoreCustomEvent(), String.Empty, null);

            // Assert
            Assert.IsTrue(actual.Contains("<Id>131313</Id>"));
            Assert.IsTrue(actual.Contains("<TraceEventType>Information</TraceEventType>"));
            Assert.IsTrue(actual.Contains("<Message>A more custom event has occurred.</Message>"));
            Assert.IsTrue(actual.Contains("<Custom1>Custom data 1.</Custom1>"));
            Assert.IsTrue(actual.Contains("<Custom2>Custom data 2.</Custom2>"));
            Assert.IsTrue(actual.Contains("<Custom3>Custom data 3.</Custom3>"));
            Assert.IsTrue(actual.Contains("<MoreCustom1>More custom data 1.</MoreCustom1>"));
            Assert.IsTrue(actual.Contains("<MoreCustom2>More custom data 2.</MoreCustom2>"));
        }
    }

    public class CustomEvent : BaseEvent
    {
        public string Custom1 { get { return "Custom data 1."; } set { } }
        public string Custom2 { get { return "Custom data 2."; } set { } }
        public string Custom3 { get { return "Custom data 3."; } set { } }

        public CustomEvent()
            : base(1313, TraceEventType.Information, "A custom event has occurred.")
        {
        }

        public CustomEvent(int id, TraceEventType eventType, string message)
            : base (id, eventType, message)
        {
        }
    }

    public class MoreCustomEvent : CustomEvent
    {
        public string MoreCustom1 { get { return "More custom data 1."; } set { } }
        public string MoreCustom2 { get { return "More custom data 2."; } set { } }

        public MoreCustomEvent()
            : base(131313, TraceEventType.Information, "A more custom event has occurred.")
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Diagnostics\LeetTraceLevelFilterTest.cs ===
﻿using System.Diagnostics;
using System.IO;
using System.Text;
using System.Xml.Serialization;
using Leet.Core.Diagnostics;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Core.Test.Diagnostics
{
    [TestClass]
    public class LeetTraceLevelFilterTest
    {
        [TestMethod]
        public void ShouldTrace_True_For_All_Levels_When_TraceLevel_Verbose()
        {
            // Arrange
            LeetTraceLevelFilter filter = new LeetTraceLevelFilter(TraceLevel.Verbose);
            TraceEvent verboseTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Verbose);
            TraceEvent exceptionTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Error);
            TraceEvent informationTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Info);

            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);
            XmlSerializer serializer = new XmlSerializer(typeof(TraceEvent));

            // Act
            serializer.Serialize(writer, verboseTraceEvent);
            bool verboseShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            builder.Length = 0;
            serializer.Serialize(writer, informationTraceEvent);
            bool informationShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            builder.Length = 0;
            serializer.Serialize(writer, exceptionTraceEvent);
            bool exceptionShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            // Assert
            Assert.IsTrue(verboseShouldTrace);
            Assert.IsTrue(informationShouldTrace);
            Assert.IsTrue(exceptionShouldTrace);
        }

        [TestMethod]
        public void ShouldTrace_True_For_Exception_And_Information_When_TraceLevel_Information()
        {
            // Arrange
            LeetTraceLevelFilter filter = new LeetTraceLevelFilter(TraceLevel.Info);
            TraceEvent verboseTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Verbose);
            TraceEvent exceptionTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Error);
            TraceEvent informationTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Info);

            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);
            XmlSerializer serializer = new XmlSerializer(typeof(TraceEvent));

            // Act
            serializer.Serialize(writer, verboseTraceEvent);
            bool verboseShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            builder.Length = 0;
            serializer.Serialize(writer, informationTraceEvent);
            bool informationShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            builder.Length = 0;
            serializer.Serialize(writer, exceptionTraceEvent);
            bool exceptionShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            // Assert
            Assert.IsFalse(verboseShouldTrace);
            Assert.IsTrue(informationShouldTrace);
            Assert.IsTrue(exceptionShouldTrace);
        }

        [TestMethod]
        public void ShouldTrace_True_For_Exception_When_TraceLevel_Exception()
        {
            // Arrange
            LeetTraceLevelFilter filter = new LeetTraceLevelFilter(TraceLevel.Error);
            TraceEvent verboseTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Verbose);
            TraceEvent exceptionTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Error);
            TraceEvent informationTraceEvent = new TraceEvent(1, TraceEventType.Verbose, TraceLevel.Info);

            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);
            XmlSerializer serializer = new XmlSerializer(typeof(TraceEvent));

            // Act
            serializer.Serialize(writer, verboseTraceEvent);
            bool verboseShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            builder.Length = 0;
            serializer.Serialize(writer, informationTraceEvent);
            bool informationShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            builder.Length = 0;
            serializer.Serialize(writer, exceptionTraceEvent);
            bool exceptionShouldTrace = filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Verbose, 1, null, null, builder.ToString(), null);

            // Assert
            Assert.IsFalse(verboseShouldTrace);
            Assert.IsFalse(informationShouldTrace);
            Assert.IsTrue(exceptionShouldTrace);
        }

        [TestMethod]
        public void ShouldTrace_True_If_TraceEventType_Not_Verbose()
        {
            // Arrange
            LeetTraceLevelFilter filter = new LeetTraceLevelFilter(TraceLevel.Error);

            // Act & Assert
            Assert.IsTrue(filter.ShouldTrace(null, "LeetTraceLevelFilterTest", TraceEventType.Information, 1, null, null, null, null));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Diagnostics\LoggingTest.cs ===
﻿using System;
using System.Diagnostics;
using Leet.Core.Configuration;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using Leet.TestUtilities;
using Leet.Core.IO;
using Leet.Core.IoCCo;

namespace Leet.Core.Diagnostics.Test
{
    [TestClass]
    public class LoggingTest
    {

        // Commented out obselete test
        // Leaving it here for the new infrastructure test owner to work with Infrastructure team to evaluate what are valid/invalid cases.
        //[TestMethod]
        //[ExpectedException(typeof(InvalidOperationException))]
        //public void LogEvent_With_Event_Parameter_Throws_If_Source_Not_Set()
        //{
        //    // Arrange
        //    Stubs stubs = new Stubs();
        //    var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

        //    // Act
        //    actual.LogEvent(new TestEvent());
        //}

        //[TestMethod]
        //[ExpectedException(typeof(InvalidOperationException))]
        //public void LogEvent_With_Event_Parameter_And_Exception_Throws_If_Source_Not_Set()
        //{
        //    // Arrange
        //    Stubs stubs = new Stubs();
        //    var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

        //    // Act
        //    actual.LogEvent(new TestEvent(), new Exception());
        //}

        //[TestMethod]
        //[ExpectedException(typeof(InvalidOperationException))]
        //public void LogEvent_With_Event_Parameter_And_Formatted_Message_Throws_If_Source_Not_Set()
        //{
        //     Arrange
        //    Stubs stubs = new Stubs();
        //    var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

        //     Act
        //    actual.LogEvent(new TestEvent(), "");
        //}

        //[TestMethod]
        //[ExpectedException(typeof(InvalidOperationException))]
        //public void LogEvent_With_Event_Parameter_And_Exception_And_Formatted_Message_Throws_If_Source_Not_Set()
        //{
        //    // Arrange
        //    Stubs stubs = new Stubs();
        //    var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

        //    // Act
        //    actual.LogEvent(new TestEvent(), new Exception(), "");
        //}

        [TestMethod]
        public void LogEvent_With_Event_Parameter_Formats_Message()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();

            // Act
            actual.LogEvent(evt);

            // Asserrt
            stubs.Formatter.AssertWasCalled(f => f.Format(evt, String.Empty, null));
        }

        [TestMethod]
        public void LogEvent_With_Event_Parameter_And_Exception_Formats_Message()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();
            Exception ex = new Exception();

            // Act
            actual.LogEvent(evt, ex);

            // Asserrt
            stubs.Formatter.AssertWasCalled(f => f.Format(evt, String.Empty, ex));
        }

        [TestMethod]
        public void LogEvent_With_Event_Parameter_And_Formatted_Message_Formats_Message()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();

            // Act
            actual.LogEvent(evt, "{0}", "test");

            // Asserrt
            stubs.Formatter.AssertWasCalled(f => f.Format(evt, "test", null));
        }

        [TestMethod]
        public void LogEvent_With_Event_Parameter_And_Exception_And_Formatted_Message_Formats_Message()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();
            Exception ex = new Exception();

            // Act
            actual.LogEvent(evt, ex, "{0}", "test");

            // Asserrt
            stubs.Formatter.AssertWasCalled(f => f.Format(evt, "test", ex));
        }

        [TestMethod]
        public void RegisterMetadata_Values_Are_Added_To_Message_No_Exception_No_FormattedMessage()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();

            // Act
            actual.RegisterMetadata("Area", () => "LoggingTest");
            actual.LogEvent(evt);

            // Assert
            var arguments = stubs.Formatter.GetArgumentsForCallsMadeOn(f => f.Format(Arg<BaseEvent>.Is.Anything, Arg<String>.Is.Anything, Arg<Exception>.Is.Anything));
            BaseEvent actualEvent = (BaseEvent)(arguments[0][0]);
            Assert.IsTrue(actualEvent.Metadata.ContainsKey("Area"));
            Assert.IsTrue(actualEvent.Metadata["Area"] == "LoggingTest");
        }

        [TestMethod]
        public void RegisterMetadata_Values_Are_Added_To_Message_No_Exception_FormattedMessage()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();

            // Act
            actual.RegisterMetadata("Area", () => "LoggingTest");
            actual.LogEvent(evt, "{0}", "test this!");

            // Assert
            var arguments = stubs.Formatter.GetArgumentsForCallsMadeOn(f => f.Format(Arg<BaseEvent>.Is.Anything, Arg<String>.Is.Anything, Arg<Exception>.Is.Anything));
            BaseEvent actualEvent = (BaseEvent)(arguments[0][0]);
            Assert.IsTrue(actualEvent.Metadata.ContainsKey("Area"));
            Assert.IsTrue(actualEvent.Metadata["Area"] == "LoggingTest");
        }

        [TestMethod]
        public void RegisterMetadata_Values_Are_Added_To_Message_Exception_No_FormattedMessage()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();
            Exception ex = new Exception();

            // Act
            actual.RegisterMetadata("Area", () => "LoggingTest");
            actual.LogEvent(evt, ex);

            // Assert
            var arguments = stubs.Formatter.GetArgumentsForCallsMadeOn(f => f.Format(Arg<BaseEvent>.Is.Anything, Arg<String>.Is.Anything, Arg<Exception>.Is.Anything));
            BaseEvent actualEvent = (BaseEvent)(arguments[0][0]);
            Assert.IsTrue(actualEvent.Metadata.ContainsKey("Area"));
            Assert.IsTrue(actualEvent.Metadata["Area"] == "LoggingTest");
        }

        [TestMethod]
        public void RegisterMetadata_Values_Are_Added_To_Message_Exception_FormattedMessage()
        {
            // Arrange
            Stubs stubs = new Stubs();
            stubs.ConfigurationProvider.Stub(cp => cp.ComponentName).Return("test_source");
            var actual = new Logging(stubs.ConfigurationProvider, stubs.Formatter);

            TestEvent evt = new TestEvent();
            Exception ex = new Exception();

            // Act
            actual.RegisterMetadata("Area", () => "LoggingTest");
            actual.LogEvent(evt, ex, "{0}", "test this too!");

            // Assert
            var arguments = stubs.Formatter.GetArgumentsForCallsMadeOn(f => f.Format(Arg<BaseEvent>.Is.Anything, Arg<String>.Is.Anything, Arg<Exception>.Is.Anything));
            BaseEvent actualEvent = (BaseEvent)(arguments[0][0]);
            Assert.IsTrue(actualEvent.Metadata.ContainsKey("Area"));
            Assert.IsTrue(actualEvent.Metadata["Area"] == "LoggingTest");
        }

        

        class Stubs
        {
            public ILogFormatter Formatter { get; set; }
            public IConfigurationProvider ConfigurationProvider { get; set; }

            public Stubs()
            {
                Formatter = MockRepository.GenerateStub<ILogFormatter>();
                ConfigurationProvider = MockRepository.GenerateStub<IConfigurationProvider>();
                ConfigurationProvider.Stub(cp => cp.GetSetting("leet_DefaultLoggingSourceLevel")).Return("Warning");
            }
        }
    }

    public class TestEvent : BaseEvent
    {
        public TestEvent()
            : base(13, TraceEventType.Information, "A test error has occurred.")
        {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Configuration\NpdbConfigurationProviderTest.cs ===
﻿using System;
using System.Configuration;
using System.Data.SqlClient;
using System.Net;

using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Win32;
using Rhino.Mocks;

namespace Leet.Core.Test.Configuration
{
    [TestClass]
    public class NpdbConfigurationProviderTest
    {
        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\ does not exist.")]
        public void Initialize_Throws_Exception_If_CommonConfig_Key_Not_In_Registry()
        {
            // Arrange
            Stubber stubber = new Stubber();
            stubber.RegisterWithContainer<IRegistryProvider>();

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("LEET", "test_component");
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\LEET does not exist.")]
        public void Initialize_Throws_Exception_If_ConfigurationSet_Key_Not_In_Registry()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp => 
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("LEET", "test_component");
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The value Server in registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\LEET does not exist.")]
        public void Initialize_Throws_Exception_If_Server_Not_In_Registry_ConfigurationSet()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.Users, "LEET"))
                .Return(Registry.CurrentConfig);

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("LEET", "test_component");
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The value Database in registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\LEET does not exist.")]
        public void Initialize_Throws_Exception_If_Database_Not_In_Registry_ConfigurationSet()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.Users, "LEET"))
                .Return(Registry.CurrentConfig);
            registryProvider.Stub(rp =>
                rp.GetValue(Registry.CurrentConfig, "Server"))
                .Return("Server");

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("LEET", "test_component");
        }

        [TestMethod]
        public void Initialize_Doesnt_Throw_Exception_If_Server_And_Database_In_Registry_ConfigurationSet()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.Users, "LEET"))
                .Return(Registry.CurrentConfig);
            registryProvider.Stub(rp =>
                rp.GetValue(Registry.CurrentConfig, "Server"))
                .Return("Server");
            registryProvider.Stub(rp =>
                rp.GetValue(Registry.CurrentConfig, "Database"))
                .Return("Database");

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("LEET", "test_component");
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The value Server in registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\LEET does not exist.")]
        public void Initialize_Throws_Exception_If_Server_Not_In_Registry_Platform()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("", "test_component");
        }

        [TestMethod]
        [ExpectedException(typeof(ConfigurationErrorsException), "The value Database in registry key HKLM\\SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\LEET does not exist.")]
        public void Initialize_Throws_Exception_If_Database_Not_In_Registry_Platform()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            registryProvider.Stub(rp =>
                rp.GetValue(Registry.Users, "Server"))
                .Return("Server");

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("", "test_component");
        }

        [TestMethod]
        public void Initialize_Doesnt_Throw_Exception_If_Server_And_Database_In_Registry_Platform()
        {
            // Arrange
            Stubber stubber = new Stubber();
            var registryProvider = stubber.RegisterWithContainer<IRegistryProvider>();
            registryProvider.Stub(rp =>
                rp.OpenSubKey(Registry.LocalMachine, "SOFTWARE\\Microsoft\\XboxLive\\CommonConfig\\"))
                .Return(Registry.Users);
            registryProvider.Stub(rp =>
                rp.GetValue(Registry.Users, "Server"))
                .Return("Server");
            registryProvider.Stub(rp =>
                rp.GetValue(Registry.Users, "Database"))
                .Return("Database");

            var target = new NpdbConfigurationProvider();

            // Act
            target.Initialize("", "test_component");
        }

        [TestMethod]
        public void BuildUpSqlConnectionString_UsesInfo1ForDataSource_IfInfo1IsNotBlank()
        {
            // Arrange
            var mockIface = MockRepository.GenerateStub<xonline.common.config.IInterfaceInfo>();

            var expectedDnsName = Guid.NewGuid().ToString();
            mockIface.Stub(i => i.Protocol).Return("sql");
            mockIface.Stub(i => i.DBName).Return("db");
            mockIface.Stub(i => i.Info1).Return(expectedDnsName);

            // Act
            var connString = mockIface.BuildUpSqlConnectionString(String.Empty);
            var builder = new SqlConnectionStringBuilder(connString);

            // Assert
            Assert.AreEqual(builder.DataSource, expectedDnsName);
        }

        [TestMethod]
        public void BuildUpSqlConnectionString_UsesIPAddressStringForDataSource_IfInfo1IsBlank()
        {
            // Arrange
            var mockIface = MockRepository.GenerateStub<xonline.common.config.IInterfaceInfo>();

            var expectedDnsName = Guid.NewGuid().ToString();
            mockIface.Stub(i => i.Protocol).Return("sql");
            mockIface.Stub(i => i.DBName).Return("db");
            mockIface.Stub(i => i.IPAddress).Return(IPAddress.Any);
            mockIface.Stub(i => i.IPAddressString).Return(expectedDnsName);

            // Act
            var connString = mockIface.BuildUpSqlConnectionString(String.Empty);
            var builder = new SqlConnectionStringBuilder(connString);

            // Assert
            Assert.AreEqual(builder.DataSource, expectedDnsName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\ContainerTests.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Core.Test.TestServices;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo.Test.TestServices;
using System.Web;
using System.IO;
using Rhino.Mocks;
using Leet.TestUtilities;

namespace Leet.Core.Test.IoCCo
{
    [TestClass]
    public class ContainerTests
    {
        [TestMethod]
        public void GetComponent_For_Unregistered_Service_Throws_Helpful_Exception()
        {
            var expectedExceptionMessage = "Interface '" + typeof (ITestService) + "' was not registered with the IoC container.";
            
            AssertException.Expect<ServiceNotRegisteredException>(() => container.GetComponent<ITestService>(),
                                                                  expectedExceptionMessage,
                                                                  false);
        }

        private static IContainer GetTestContainer()
        {
            IContainer container = new Container();
            return container;
        }

        IContainer container;
        IContainer anotherContainer;

        [TestInitialize]
        public void SetUp()
        {
            container = GetTestContainer();
            anotherContainer = GetTestContainer();
        }

        [TestCleanup]
        public void CleanUp()
        {
            container.DisposeSingletons();
            anotherContainer.DisposeSingletons();
            container = null;
            anotherContainer = null;
        }

        [TestMethod]
        public void GetComponent_Returns_An_Instance_Of_The_Registered_Service()
        {
            container.AddService<ITestService, TestServiceComponent>();

            var component = container.GetComponent<ITestService>();

            Assert.IsInstanceOfType(component, typeof(ITestService));
        }

        [TestMethod]
        public void Components_Marked_As_Singleton_Are_Returned_One_Per_AppDomain()
        {
            container.AddService<ITestService, TestServiceSingletonComponent>();

            var componentOne = container.GetComponent<ITestService>();
            var componentTwo = container.GetComponent<ITestService>();

            Assert.AreSame(componentOne, componentTwo);
        }

        [TestMethod]
        public void Singleton_Instances_From_Different_Containers_Are_The_Same()
        {
            container.AddService<ITestService, TestServiceSingletonComponent>();
            anotherContainer.AddService<ITestService, TestServiceSingletonComponent>();

            var componentOne = container.GetComponent<ITestService>();
            var componentTwo = anotherContainer.GetComponent<ITestService>();

            Assert.AreSame(componentOne, componentTwo);
        }

        [TestMethod]
        public void LifeCycle_Can_Be_Set_During_Component_Registration()
        {
            container.AddService<ITestService, TestServiceComponent>();
            container.SetLifeCycleForService<ITestService>(LifeCycleMode.Singleton);

            var componentOne = container.GetComponent<ITestService>();
            var componentTwo = container.GetComponent<ITestService>();

            Assert.AreSame(componentOne, componentTwo);
        }

        [TestMethod]
        public void LifeCycle_Set_During_Component_Registration_Overrides_LifeCycle_Attribute()
        {
            container.AddService<ITestService, TestServiceSingletonComponent>();
            container.SetLifeCycleForService<ITestService>(LifeCycleMode.Instance);

            var componentOne = container.GetComponent<ITestService>();
            var componentTwo = container.GetComponent<ITestService>();

            Assert.AreNotSame(componentOne, componentTwo);
        }

        [TestMethod]
        public void Constructor_Parameters_That_Are_Services_Are_Mapped_Correctly()
        {
            container
                .AddService<ITestService, TestServiceComponent>()
                .AddService<IServiceWithDependency, TestServiceWithDependency>();

            var component = container.GetComponent<IServiceWithDependency>();

            Assert.IsInstanceOfType(component.TestService, typeof(TestServiceComponent));
        }

        [TestMethod]
        public void NonGeneric_GetComponent_Returns_An_Instance_Of_The_Registered_Service()
        {
            container.AddService<ITestService, TestServiceComponent>();

            var component = (ITestService)container.GetComponent(typeof(ITestService));

            Assert.IsInstanceOfType(component, typeof(ITestService));
        }

        [TestMethod]
        public void AddService_Returns_Container_Itself()
        {
            IContainer returnContainer = container.AddService<ITestService, TestServiceSingletonComponent>();

            Assert.AreSame(container, returnContainer);
        }

        [TestMethod]
        public void Getting_Component_With_Missing_Dependency_Throws()
        {
            Exception actualException = null;
            container.AddService<IServiceWithDependency, TestServiceWithDependency>();
            try
            {
                container.GetComponent<IServiceWithDependency>();
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.AreEqual(typeof(ServiceNotRegisteredException), actualException.GetType());
            Assert.AreEqual("Interface '" + typeof(ITestService) + "' was not registered with the IoC container.", actualException.Message);
        }

        [TestMethod]
        public void Adding_Two_Same_Implementations_Of_Same_Service_Is_OK()
        {
            container
                .AddService<ITestService, TestServiceComponent>()
                .AddService<ITestService, TestServiceComponent>();
        }


        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void Adding_Two_Different_Implementations_Of_Same_Service_Throws()
        {
            container
                .AddService<ITestService, TestServiceComponent>()
                .AddService<ITestService, TestPerWebRequestComponent>();
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void Adding_A_Component_With_More_Than_One_Constrctor_Throws()
        {
            container.AddService<ITestService, TestServiceMultiConstructorComponent>();
        }

        [TestMethod]
        public void Adding_A_Component_With_One_Public_Constrctor_Works()
        {
            container.AddService<ITestService, TestServiceMultiConstructorComponentTwo>();
        }

        [TestMethod]
        public void UseLocal_Overrides_The_Instance()
        {
            IContainer localContainer = new Container();

            Container.UseLocalContainer(localContainer);

            Assert.AreSame(localContainer, Container.Instance);
        }

        [TestMethod]
        public void Generic_Parameter_Inhjections_Are_Supported()
        {
            container.AddService<ITestService, TestServiceComponent>();
            container.AddService<IServiceWithDependency, GenericServiceWithDependency<ITestService>>();

            IServiceWithDependency component = container.GetComponent<IServiceWithDependency>();

            Assert.IsNotNull(((GenericServiceWithDependency<ITestService>)component).Dependency);
        }

        [TestMethod]
        public void Components_Marked_PerWebRequest_Are_Instantiated_Properly()
        {
            container.AddService<ITestService, TestPerWebRequestComponent>();

            var context = new HttpContext(new HttpRequest("", "http://localhost", ""), new HttpResponse(new StringWriter()));
            HttpContext.Current = context;

            var component1 = container.GetComponent<ITestService>();
            var component2 = container.GetComponent<ITestService>();

            Assert.AreSame(component1, component2);

            context = new HttpContext(new HttpRequest("", "http://localhost", ""), new HttpResponse(new StringWriter()));
            HttpContext.Current = context;

            component2 = container.GetComponent<ITestService>();

            Assert.AreNotSame(component1, component2);
        }

        [TestMethod]
        public void DisposeSingletons_Clears_SingletonsCollection()
        {
            // Arrange
            container.AddService<ITestService, TestServiceSingletonComponent>();

            var originalInstance = container.GetComponent<ITestService>();

            // Act
            container.DisposeSingletons();

            // Assert
            var anotherInstance = container.GetComponent<ITestService>();

            Assert.AreNotEqual(originalInstance, anotherInstance);
        }

        [TestMethod]
        public void DisposeSingletons_Calls_Dispose_On_IDisposables()
        {
            container.AddService<ITestService, TestServiceSingletonComponent>();

            var originalInstance = container.GetComponent<ITestService>();

            // Act
            container.DisposeSingletons();

            // Assert
            Assert.IsTrue(((TestServiceSingletonComponent) originalInstance).IsDisposed,
                          "An IDisposable singleton component should be Disposed by DisposeSingletons.");
        }

        [TestMethod]
        public void Calls_To_Component_Registered_With_Behaviors_Proxies_Calls_Via_The_Behaviors()
        {
            // Arrange
            var behavior1 = MockRepository.GenerateStub<IBehavior>();
            var behavior2 = MockRepository.GenerateStub<IBehavior>();

            StubSimpleBehavior(behavior1);
            StubSimpleBehavior(behavior2);

            // Act
            container.AddService<ITestProxyServiceWithGenerics<object>, TestGenericService>();
            container.SetBehaviorsForService<ITestProxyServiceWithGenerics<object>>(behavior1, behavior2);

            var service = container.GetComponent<ITestProxyServiceWithGenerics<object>>();
            service.GenericMethod(null);

            //Assert
            behavior1.AssertWasCalled(b => b.InvokeMethod(null, null, null), options => options.IgnoreArguments());
            behavior2.AssertWasCalled(b => b.InvokeMethod(null, null, null), options => options.IgnoreArguments());
        }


        [TestMethod]
        public void Calls_To_Located_Component_Registered_With_Behaviors_Proxies_Calls_Via_The_Behaviors()
        {
            // Arrange
            var behavior1 = MockRepository.GenerateStub<IBehavior>();
            var behavior2 = MockRepository.GenerateStub<IBehavior>();

            StubSimpleBehavior(behavior1);
            StubSimpleBehavior(behavior2);

            InstanceLocator<ITestProxyServiceWithGenerics<object>>.InstanceToReturn = new TestGenericService();

            // Act
            container.AddServiceWithLocator<ITestProxyServiceWithGenerics<object>, InstanceLocator<ITestProxyServiceWithGenerics<object>>>();
            container.SetBehaviorsForService<ITestProxyServiceWithGenerics<object>>(behavior1, behavior2);

            var service = container.GetComponent<ITestProxyServiceWithGenerics<object>>();
            service.GenericMethod(null);

            //Assert
            behavior1.AssertWasCalled(b => b.InvokeMethod(null, null, null), options => options.IgnoreArguments());
            behavior2.AssertWasCalled(b => b.InvokeMethod(null, null, null), options => options.IgnoreArguments());
        }

        private static void StubSimpleBehavior(IBehavior behavior1)
        {
            behavior1
                .Stub(b => b.InvokeMethod(null, null, null))
                .IgnoreArguments()
                .Do(new Action<object, Action, ProxiedCallInfo>((component, call, callInfo) => call()));
        }

        [TestMethod]
        public void RegisterWithInstance_Creates_A_Singleton()
        {
            // Arrange
            TestServiceComponent component = new TestServiceComponent();
            container.AddServiceWithInstance<ITestService>(component);

            // Act
            var instanceFromContainer = container.GetComponent<ITestService>();

            // Assert
            Assert.AreSame(component, instanceFromContainer);
        }

        [TestMethod]
        public void AddServiceWithInstance_Always_Returns_The_Same_Instance()
        {
            // Arrange
            TestServiceComponent component = new TestServiceComponent();
            container.AddServiceWithInstance<ITestService>(component);

            // Act
            var instanceFromContainer = container.GetComponent<ITestService>();
            var instanceFromContainer2 = container.GetComponent<ITestService>();

            // Assert
            Assert.AreSame(component, instanceFromContainer);
            Assert.AreSame(component, instanceFromContainer2);
        }

        [TestMethod]
        [ExpectedException(typeof(InvalidOperationException))]
        public void AddServiceWithInstance_Throws_When_Service_Is_Already_Registered()
        {
            // Arrange
            container.AddService<ITestService, TestServiceComponent>();

            // Act
            container.AddServiceWithInstance<ITestService>(new TestServiceComponent());

            // Assert
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\ContainerTestExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Rhino.Mocks;

namespace Leet.Core.IoCCo
{
    public static class ContainerTestExtensions
    {
        public static T RegisterWithCreateMock<T>(this IContainer container, MockRepository mockery)
        {
            T mock = mockery.StrictMock<T>();
            Expect.Call(container.GetComponent<T>()).Return(mock);
            return mock;
        }

        public static T RegisterWithDynamicMock<T>(this IContainer container, MockRepository mockery) where T : class
        {
            T mock = mockery.DynamicMock<T>();
            SetupResult.For(container.GetComponent<T>()).Return(mock);
            return mock;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\ContainerTimingTests.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Core.IoCCo.Test.TestServices;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Core.Test.IoCCo
{
    [TestClass]
    public class ContainerTimingTests
    {
        private const int TestCreationCount = 100000;

        private static IContainer GetTestContainer()
        {
            IContainer container = new Container();
            return container;
        }

        IContainer container;

        [TestInitialize]
        public void SetUp()
        {
            container = GetTestContainer();
        }

        [TestCleanup]
        public void CleanUp()
        {
            container = null;
        }

        [TestMethod]
        public void Time_Container_Creations()
        {
            container.AddService<ITestService, TestServiceComponent>();

            for (int i = 0; i < TestCreationCount; i++)
            {
                container.GetComponent<ITestService>();
            }
        }

        [TestMethod]
        public void Time_Container_NonGeneric_Creations()
        {
            container.AddService<ITestService, TestServiceComponent>();

            for (int i = 0; i < TestCreationCount; i++)
            {
                var s = (ITestService)container.GetComponent(typeof(ITestService));
            }
        }

        [TestMethod]
        public void Time_Container_NonGeneric_With_Dependency_Creations()
        {
            container.AddService<ITestService, TestServiceComponent>();
            container.AddService<IServiceWithDependency, TestServiceWithDependency>();

            for (int i = 0; i < TestCreationCount; i++)
            {
                container.GetComponent(typeof(IServiceWithDependency));
            }
        }

        [TestMethod]
        public void Time_Activator_Instantiations()
        {
            for (int i = 0; i < TestCreationCount; i++)
            {
                var component = (TestServiceComponent)Activator.CreateInstance(typeof(TestServiceComponent));
            }
        }

        [TestMethod]
        public void Time_Direct_Instantiations()
        {
            for (int i = 0; i < TestCreationCount; i++)
            {
                new TestServiceComponent();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Diagnostics\MetadataTest.cs ===
﻿using Leet.Core.Diagnostics;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Text;
using System.IO;
using System.Xml;

namespace Leet.Core.Test.Diagnostics
{
    [TestClass]
    public class MetadataTest
    {
        [TestMethod]
        public void GetSchema_Returns_Null()
        {
            // Arrange
            Metadata metadata = new Metadata();

            // Assert
            Assert.IsNull(metadata.GetSchema());
        }

        [TestMethod]
        public void WriteXml_Adds_Empty_Tag_With_No_Data()
        {
            // Arrange
            Metadata metadata = new Metadata();

            StringBuilder output = new StringBuilder();
            StringWriter stringWriter = new StringWriter(output);
            XmlTextWriter writer = new XmlTextWriter(stringWriter);

            // Act
            metadata.WriteXml(writer);

            // Assert
            string actual = output.ToString();
            Assert.AreEqual(0, actual.Length);
        }

        [TestMethod]
        public void WriteXml_Writes_One_Entry()
        {
            // Arrange
            Metadata metadata = new Metadata();
            metadata["Area"] = "MetadataTest";

            StringBuilder output = new StringBuilder();
            StringWriter stringWriter = new StringWriter(output);
            XmlTextWriter writer = new XmlTextWriter(stringWriter);

            // Act
            metadata.WriteXml(writer);

            // Assert
            string actual = output.ToString();
            Assert.IsTrue(actual.Contains("<Area>MetadataTest</Area>"));
        }

        [TestMethod]
        public void WriteXml_Writes_Multiple_Entries()
        {
            // Arrange
            Metadata metadata = new Metadata();
            metadata["Area"] = "MetadataTest";
            metadata["SubArea"] = "WriteXml_Writes_Multiple_Entries";
            metadata["Test"] = "123";

            StringBuilder output = new StringBuilder();
            StringWriter stringWriter = new StringWriter(output);
            XmlTextWriter writer = new XmlTextWriter(stringWriter);

            // Act
            metadata.WriteXml(writer);

            // Assert
            string actual = output.ToString();
            Assert.IsTrue(actual.Contains("<Area>MetadataTest</Area>"));
            Assert.IsTrue(actual.Contains("<SubArea>WriteXml_Writes_Multiple_Entries</SubArea>"));
            Assert.IsTrue(actual.Contains("<Test>123</Test>"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\DynamicProxyGeneratorTests.cs ===
﻿using System;
using System.Collections;
using System.Linq;
using Leet.Core.IoCCo;
using Leet.Core.Test.TestServices;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;

namespace Leet.Core.Test.IoCCo
{
    [TestClass]
    public class DynamicProxyGeneratorTests
    {
        [TestMethod]
        public void CreateInterfaceProxy_Creates_An_Implementation_Of_The_Interface()
        {
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestServiceForProxy));

            Assert.IsTrue(proxy.GetInterfaces().Contains(typeof(ITestServiceForProxy)));
        }

        [TestMethod]
        public void Generating_Proxy_For_Class_Throws()
        {
            AssertException.Expect<ArgumentException>(
                () => DynamicProxyGenerator.CreateInterfaceProxy(typeof(Object)));
        }

        [TestMethod]
        public void Proxy_Calls_Into_Underlying_Object()
        {
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestServiceForProxy));

            var service = MockRepository.GenerateStub<ITestServiceForProxy>();

            var proxiedService = (ITestServiceForProxy)Activator.CreateInstance(proxy, service, new IBehavior[] { });

            proxiedService.UppercaseAString();

            service.AssertWasCalled(s => s.UppercaseAString());
        }

        [TestMethod]
        public void Proxy_Calls_Into_Properties()
        {
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestServiceForProxy));

            var service = MockRepository.GenerateStub<ITestServiceForProxy>();

            var proxiedService = (ITestServiceForProxy)Activator.CreateInstance(proxy, service, new IBehavior[] { });

            proxiedService.SampleProperty = 100;

            Assert.AreEqual(100, proxiedService.SampleProperty);
        }

        [TestMethod]
        public void Proxy_Passes_Through_Event_Subscriptions()
        {
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestServiceForProxy));

            var service = MockRepository.GenerateStub<ITestServiceForProxy>();

            var proxiedService = (ITestServiceForProxy)Activator.CreateInstance(proxy, service, new IBehavior[] { });
            var wasCalled = false;
            proxiedService.SampleEvent += (sender, args) => { wasCalled = true; };

            service.Raise(s => s.SampleEvent += null, service, null);

            Assert.IsTrue(wasCalled);
        }

        [TestMethod]
        public void Proxy_Wraps_Calls_To_Component_With_Specified_Behaviors()
        {
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestServiceForProxy));

            var service = MockRepository.GenerateStub<ITestServiceForProxy>();

            var behavior = MockRepository.GenerateMock<IBehavior>();

            var proxiedService = (ITestServiceForProxy)Activator.CreateInstance(proxy, service, new IBehavior[] { behavior });

            proxiedService.VoidMethod();
            proxiedService.UppercaseAString();
            proxiedService.SampleProperty = 100;
            proxiedService.SampleEvent += (sender, args) => { };

            behavior.AssertWasCalled(b => b.InvokeMethod(null, null, null),
                                     options => options.IgnoreArguments().Repeat.Times(4));
        }

        [TestMethod]
        public void ProxyGenerator_Supports_Generic_Interfaces()
        {
            DynamicProxyGenerator.CreateInterfaceProxy(typeof(ISimpleGenericInterface<object>));
        }

        [TestMethod]
        public void ProxyGenerator_Supports_Generic_Methods()
        {
            DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>));
        }

        [TestMethod]
        public void ProxyGenerator_Supports_Generic_Methods_For_Calls()
        {
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>));

            var service = new TestGenericService();

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxy, service, new IBehavior[] { });

            proxiedService.AnotherGenericMethod<object, object>("5");

            Assert.IsTrue(service.WasCalled);
        }

        [TestMethod]
        public void Proxied_Calls_Pass_Return_Values_Back()
        {
            // Arrange
            var proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>));

            var service = new TestGenericService();

            var behavior = MockRepository.GenerateMock<IBehavior>();

            behavior
                .Stub(b => b.InvokeMethod(null, null, null))
                .IgnoreArguments()
                .Do(new Action<object, Action, ProxiedCallInfo>((component, call, callInfo) => call()));

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxy, service, new IBehavior[] { behavior });

            var expectedInput1 = new object();
            var expectedInput2 = Guid.NewGuid().ToString();

            // Act
            var result = proxiedService.PartiallyGeneric(expectedInput1, expectedInput2, null);
            var result2 = service.PartiallyGeneric(expectedInput1, expectedInput2, null);

            // Assert
            Assert.AreEqual(result2, result);
        }

        [TestMethod]
        public void Behaviors_Have_Access_To_The_InvocationArgumentsAndResult()
        {
            // Arrange
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>));

            var service = new TestGenericService();

            var behavior = MockRepository.GenerateMock<IBehavior>();

            ProxiedCallInfo actuallCallInfo = null;

            behavior
                .Stub(b => b.InvokeMethod(null, null, null))
                .IgnoreArguments()
                .Do(new Action<object, Action, ProxiedCallInfo>((component, call, callInfo) =>
                {
                    actuallCallInfo = callInfo;
                    call();
                }));

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxy, service, new IBehavior[] { behavior });

            var expectedInput1 = 5;
            var expectedInput2 = Guid.NewGuid().ToString();
            var expectedInput3 = new Hashtable();

            // Act
            var result = proxiedService.PartiallyGeneric(expectedInput1, expectedInput2, expectedInput3);

            // Assert
            Assert.IsNotNull(actuallCallInfo);
            Assert.AreSame(service, actuallCallInfo.Component);
            Assert.AreEqual(result, actuallCallInfo.ReturnValue);

            var arguments = actuallCallInfo.GetArguments();

            Assert.AreEqual(3, arguments.Length);
            Assert.AreEqual(expectedInput1, arguments[0]);
            Assert.AreEqual(expectedInput2, arguments[1]);
            Assert.AreEqual(expectedInput3, arguments[2]);
        }

        [TestMethod]
        public void Behaviors_Have_Access_To_The_InvocationTargetAttributes()
        {
            // Arrange
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>), typeof(TestGenericService));

            var service = new TestGenericService();

            var behavior = MockRepository.GenerateMock<IBehavior>();

            ProxiedCallInfo actuallCallInfo = null;

            behavior
                .Stub(b => b.InvokeMethod(null, null, null))
                .IgnoreArguments()
                .Do(new Action<object, Action, ProxiedCallInfo>((component, call, callInfo) =>
                {
                    actuallCallInfo = callInfo;
                    call();
                }));

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxy, service, new IBehavior[] { behavior });

            // Act
            proxiedService.PartiallyGeneric(0, "", null);

            // Assert
            Assert.IsNotNull(actuallCallInfo);

            var targetAttributes = actuallCallInfo.MethodAttributes;

            Assert.IsNotNull(targetAttributes);

            var targetAttributeCount =
                targetAttributes.OfType<SampleMethodAttribute>().Where(
                    a => a.NamedInt == 200 && a.PositionalString == "Implementation_PartiallyGeneric").Count();

            Assert.AreEqual(1, targetAttributeCount);
        }

        [TestMethod]
        public void Behaviors_Have_Access_To_The_InvocationSourceAttributes()
        {
            // Arrange
            Type proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>), typeof(TestGenericService));

            var service = new TestGenericService();

            var behavior = MockRepository.GenerateMock<IBehavior>();

            ProxiedCallInfo actuallCallInfo = null;

            behavior
                .Stub(b => b.InvokeMethod(null, null, null))
                .IgnoreArguments()
                .Do(new Action<object, Action, ProxiedCallInfo>((component, call, callInfo) =>
                {
                    actuallCallInfo = callInfo;
                    call();
                }));

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxy, service, new IBehavior[] { behavior });

            // Act
            proxiedService.PartiallyGeneric(0, "", null);

            // Assert
            Assert.IsNotNull(actuallCallInfo);

            var targetAttributes = actuallCallInfo.MethodAttributes;

            Assert.IsNotNull(targetAttributes);

            var targetAttributeCount =
                targetAttributes.OfType<SampleMethodAttribute>().Where(
                    a => a.NamedInt == 100 && a.PositionalString == "Interface_PartiallyGeneric").Count();

            Assert.AreEqual(1, targetAttributeCount);
        }

        [TestMethod]
        public void Behaviors_Have_Access_To_The_InvocationSourceMethodInfo()
        {
            // Arrange
            // Arrange & Act
            var interfaceType = typeof(ITestProxyServiceWithGenerics<object>);
            var targetType = typeof(TestGenericService);
            var expectedSourceMethod = interfaceType.GetMethod("PartiallyGeneric");

            ProxiedCallInfo actuallCallInfo = CallGenericMethodOnProxiedService(interfaceType, targetType);

            // Assert
            Assert.IsNotNull(actuallCallInfo);

            var sourceMethod = actuallCallInfo.SourceMethod;

            Assert.AreEqual(expectedSourceMethod, sourceMethod);
        }

        [TestMethod]
        public void Behaviors_Have_Access_To_The_InvocationTargetMethodInfo()
        {
            // Arrange & Act
            var interfaceType = typeof(ITestProxyServiceWithGenerics<object>);
            var targetType = typeof(TestGenericService);
            var expectedTargetMethod = targetType.GetMethod("PartiallyGeneric");

            ProxiedCallInfo actuallCallInfo = CallGenericMethodOnProxiedService(interfaceType, targetType);

            // Assert
            Assert.IsNotNull(actuallCallInfo);

            var targetMethod = actuallCallInfo.TargetMethod;

            Assert.AreEqual(expectedTargetMethod, targetMethod);
        }

        [TestMethod]
        public void Behaviors_Have_Access_To_The_InvocationTargetMethod_ParameterInfos()
        {
            // Arrange & Act
            var interfaceType = typeof(ITestProxyServiceWithGenerics<object>);
            var targetType = typeof(TestGenericService);
            var expectedTargetMethod = targetType.GetMethod("PartiallyGeneric");

            ProxiedCallInfo actuallCallInfo = CallGenericMethodOnProxiedService(interfaceType, targetType);

            // Assert
            Assert.IsNotNull(actuallCallInfo);

            var targetParameterInfos = actuallCallInfo.TargetMethodParameters;

            Assert.IsTrue(targetParameterInfos.IsEqualTo(expectedTargetMethod.GetParameters(),
                                                         (p1, p2) =>
                                                         p1.Name == p2.Name &&
                                                         p1.ParameterType.FullName == p2.ParameterType.FullName),
                          "Parameter Collection passed to the behavior didn't match parameter collection of the target type's method.");
        }

        [TestMethod]
        public void InvocationTargetMethodInfo_Is_Null_When_No_Target_Type_Is_Specified()
        {
            // Arrange & Act
            var interfaceType = typeof(ITestProxyServiceWithGenerics<object>);

            ProxiedCallInfo actuallCallInfo = CallGenericMethodOnProxiedService(interfaceType, null);

            // Assert
            Assert.IsNotNull(actuallCallInfo);

            var targetMethod = actuallCallInfo.TargetMethod;

            Assert.IsNull(targetMethod);
        }

        private static ProxiedCallInfo CallGenericMethodOnProxiedService(Type interfaceType, Type targetType)
        {
            var proxyType = DynamicProxyGenerator.CreateInterfaceProxy(interfaceType, targetType);
            var service = new TestGenericService();
            var behavior = MockRepository.GenerateMock<IBehavior>();

            ProxiedCallInfo actuallCallInfo = null;
            behavior
                .Stub(b => b.InvokeMethod(null, null, null))
                .IgnoreArguments()
                .Do(new Action<object, Action, ProxiedCallInfo>((component, call, callInfo) =>
                                                                    {
                                                                        actuallCallInfo = callInfo;
                                                                        call();
                                                                    }));

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxyType, service, new IBehavior[] { behavior });

            // Act
            proxiedService.PartiallyGeneric(0, "", null);
            return actuallCallInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\LocatorTests.cs ===
﻿using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo.Test.TestServices;

namespace Leet.Core.IoCCo.Test
{
    [TestClass]
    public class LocatorTests
    {
        [TestMethod]
        public void Container_Allows_Registering_A_Locator_For_Service()
        {
            TestServiceLocator.Called = false;
            TestServiceLocator.ServiceToReturn = new TestServiceComponent();

            Container.Instance.AddServiceWithLocator<ITestService, TestServiceLocator>();
            ITestService component = Container.Instance.GetComponent<ITestService>();

            Assert.IsTrue(TestServiceLocator.Called);
            Assert.AreSame(TestServiceLocator.ServiceToReturn, component);
        }

        [TestMethod]
        public void Adding_Two_Identical_Locators_For_Same_Service_Is_OK()
        {
            Container container = new Container();

            container.AddServiceWithLocator<ITestService, TestServiceLocator>();
            container.AddServiceWithLocator<ITestService, TestServiceLocator>();
           
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\DynamicProxyTimingTests.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Core.Test.TestServices;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Core.Test.IoCCo
{
    [TestClass]
    public class DynamicProxyTimingTests
    {
        private const int TestCallCount = 100000;

        [TestMethod]
        public void Time_Direct_Calls()
        {
            // Arrange
            var service = new TestGenericService();

            // Act
            for (var i = 0; i < TestCallCount; i++)
            {
                CallIntoService(service);
            }

        }

        private static void CallIntoService(ITestProxyServiceWithGenerics<object> service)
        {
            service.PartiallyGeneric(5, "test", null);
        }

        [TestMethod]
        public void Time_Proxy_Calls_With_No_Behaviors()
        {
            // Arrange
            var proxy = DynamicProxyGenerator.CreateInterfaceProxy(typeof(ITestProxyServiceWithGenerics<object>));

            var service = new TestGenericService();

            var proxiedService = (ITestProxyServiceWithGenerics<object>)Activator.CreateInstance(proxy, service, null);

            // Act
            for (var i = 0; i < TestCallCount; i++)
            {
                CallIntoService(proxiedService);
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Core.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("db6a1f0a-e0df-4e26-b9ed-146186c3d55c")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\ITestService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public interface ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\ITestServicesForProxy.cs ===
using System;

namespace Leet.Core.Test.TestServices
{
    public interface ITestServiceForProxy
    {
        int SampleProperty { get; set; }
        event EventHandler<EventArgs> SampleEvent;

        void VoidMethod();
        string UppercaseAString();
    }

    public interface ISimpleGenericInterface<T>
    {
    }

    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    internal sealed class SampleMethodAttribute : Attribute
    {
        public SampleMethodAttribute()
        {
        }

        public string PositionalString { get; set; }

        // This is a named argument
        public int NamedInt { get; set; }
    }

    public interface ITestProxyServiceWithGenerics<T> : IDisposable, ISimpleGenericInterface<T>
    {
        T GenericProperty { get; set; }
        T GenericPropertyGetOnly { get; }
        T GenericPropertySetOnly { set; }
        void GenericMethod(T input);
        V AnotherGenericMethod<U, V>(U input);// where V : U, new() where U : new();

        [SampleMethod(NamedInt=100, PositionalString="Interface_PartiallyGeneric")]
        int PartiallyGeneric<U>(U input, string input2, object input3);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\GenericServiceWithDependency.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public class GenericServiceWithDependency<TDependency> : IServiceWithDependency
    {
        public TDependency Dependency { get; internal set; }

        public GenericServiceWithDependency(TDependency dependency)
        {
            this.Dependency = dependency;
        }
        #region IServiceWithDependency Members

        public ITestService TestService
        {
            get { throw new NotImplementedException(); }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\IServiceWithDependency.cs ===
﻿using System;
using System.Text;
using System.Data;
using System.Data.Common;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public interface IServiceWithDependency
    {
        ITestService TestService { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\SimpleBehavior.cs ===
using System;
using Leet.Core.IoCCo;

namespace Leet.Core.Test.TestServices
{
    public class SimpleBehavior : IBehavior
    {
        public void InvokeMethod(object component, Action nextCall, ProxiedCallInfo proxiedCallInfo)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\IUnknownService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    interface IUnknownService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\IoCCo\FluentInterfaceTests.cs ===
﻿using Leet.Core.IoCCo;
using Leet.Core.IoCCo.Test.TestServices;
using Leet.Core.Test.TestServices;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using Rhino.Mocks.Constraints;

namespace Leet.Core.Test.IoCCo
{
    [TestClass]
    public class IoC_FluentInterfaceTests
    {

        [TestMethod]
        public void Get_GetsComponentFromContainer()
        {
            // Arrange
            var repository = new MockRepository();
            var container = repository.DynamicMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Expect(c => c.GetComponent<ITestService>()).Return(null);
            repository.ReplayAll();

            // Act
            IoC.Get<ITestService>();

            // Assert
            repository.VerifyAll();
        }

        [TestMethod]
        public void Register__RegistersServiceWithTheContainer()
        {
            // Arrange
            var repository = new MockRepository();
            var container = repository.DynamicMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Expect(c => c.AddService<ITestService, TestServiceComponent>()).Return(null);
            repository.ReplayAll();

            // Act
            IoC.Register<ITestService, TestServiceComponent>();

            // Assert
            repository.VerifyAll();
        }

        [TestMethod]
        public void RegisterWithLocator__RegistersServiceWithTheContainer()
        {
            // Arrange
            var repository = new MockRepository();
            var container = repository.DynamicMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Expect(c => c.AddServiceWithLocator<ITestService, TestServiceLocator>()).Return(null);
            repository.ReplayAll();

            // Act
            IoC.RegisterWithLocator<ITestService, TestServiceLocator>();

            // Assert
            repository.VerifyAll();
        }

        [TestMethod]
        public void RegisterWithLocator__Allows()
        {
            // Arrange
            var repository = new MockRepository();
            var container = repository.DynamicMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Expect(c => c.AddServiceWithLocator<ITestService, TestServiceLocator>()).Return(null);
            repository.ReplayAll();

            // Act
            IoC.RegisterWithLocator<ITestService, TestServiceLocator>();

            // Assert
            repository.VerifyAll();
        }

        [TestMethod]
        public void With_Behavior__RegistersBehaviors__WhenCalledOnce()
        {
            var repository = new MockRepository();
            var container = repository.DynamicMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Stub(c => c.AddService<ITestService, TestServiceComponent>()).Return(null);
            container
                .Expect(c => c.SetBehaviorsForService<ITestService>(null))
                .IgnoreArguments()
                .Constraints(Is.Matching<IBehavior[]>(b => b.Length == 1 && b[0] is SimpleBehavior))
                .Message("Missing an expected second call with the behavior.");
            repository.ReplayAll();

            // Act
            IoC.Register<ITestService, TestServiceComponent>()
                .With<SimpleBehavior>();

            // Assert
            repository.VerifyAll();
        }

        [TestMethod]
        public void With_Behavior__RegistersBehaviors__WhenCalledSuccesively()
        {
            var repository = new MockRepository();
            var container = repository.DynamicMockWithRemoting<IContainer>();
            Container.UseLocalContainer(container);
            container.Stub(c => c.AddService<ITestService, TestServiceComponent>()).Return(null);
            container
                .Expect(c => c.SetBehaviorsForService<ITestService>(null))
                .IgnoreArguments()
                .Constraints(Is.Matching<IBehavior[]>(b => b.Length == 1 && b[0] is SimpleBehavior))
                .Repeat.Once()
                .Message("Missing an expected second call with first behavior.");
            container
                .Expect(c => c.SetBehaviorsForService<ITestService>(null))
                .IgnoreArguments()
                .Constraints(Is.Matching<IBehavior[]>(b => b.Length == 2 && b[0] is SimpleBehavior && b[1] is SimpleBehavior))
                .Message("Missing an expected second call with compounded set of behaviors.");
            repository.ReplayAll();

            // Act
            IoC.Register<ITestService, TestServiceComponent>()
                .With<SimpleBehavior>()
                .With<SimpleBehavior>();

            // Assert
            repository.VerifyAll();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestGenericService.cs ===
using System;
using Leet.Core.Test.TestServices;

namespace Leet.Core.Test.IoCCo
{
    public class TestGenericService : ITestProxyServiceWithGenerics<object>
    {
        public bool WasCalled { get; private set; }
        public object GenericProperty
        {
            get { throw new NotImplementedException(); }
            set { throw new NotImplementedException(); }
        }

        public object GenericPropertyGetOnly
        {
            get { throw new NotImplementedException(); }
        }

        public object GenericPropertySetOnly
        {
            set { throw new NotImplementedException(); }
        }

        public void GenericMethod(object input)
        {

        }

        public V AnotherGenericMethod<U, V>(U input)// where V : U, new() where U : new()
        {
            WasCalled = true;
            return default(V);
        }

        [SampleMethod(NamedInt = 200, PositionalString = "Implementation_PartiallyGeneric")]
        public int PartiallyGeneric<U>(U input, string input2, object input3)
        {
            object o = input;
            Guid.NewGuid().ToString().ToUpper().ToLower().Replace("-", "."); // this is here to make the function call take time
            return 500;
        }

        public void Dispose()
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestPerWebRequestComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    [PerWebRequestInstance]
    public class TestPerWebRequestComponent : ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestServiceWithDependency.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public class TestServiceWithDependency : IServiceWithDependency
    {
        public ITestService TestService { get; private set; }

        public TestServiceWithDependency(ITestService testService)
        {
            TestService = testService;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestServiceComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public class TestServiceComponent : ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestServiceLocator.cs ===
using System.Collections.Generic;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public class TestServiceLocator : ILocator<ITestService>
    {
        public static bool Called { get; set; }
        public static ITestService ServiceToReturn { get; set; }

        public ITestService LocateComponent()
        {
            Called = true;

            return ServiceToReturn;
        }

        object ILocator.LocateComponent()
        {
            Called = true;

            return ServiceToReturn;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestServiceSingletonComponent.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Core.IoCCo.Test.TestServices;

namespace Leet.Core.Test.TestServices
{
    [SingletonInstance]
    public class TestServiceSingletonComponent : ITestService, IDisposable
    {
        public bool IsDisposed { get; set; }

        public TestServiceSingletonComponent()
        {
            IsDisposed = false;
        }

        public void Dispose()
        {
            IsDisposed = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestServiceMultiConstructorComponentTwo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public class TestServiceMultiConstructorComponentTwo : ITestService
    {
        public TestServiceMultiConstructorComponentTwo()
        {
        }

        private TestServiceMultiConstructorComponentTwo(string test)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestServices\TestServiceMultiConstructorComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Core.IoCCo.Test.TestServices
{
    public class TestServiceMultiConstructorComponent : ITestService
    {
        public TestServiceMultiConstructorComponent()
        {
        }

        public TestServiceMultiConstructorComponent(string test)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestSupport\TestImplementationProviderTest.cs ===
﻿using System;
using System.Configuration;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.TestSupport;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;

namespace Leet.Core.Test
{
    public interface ITestInterface
    {
        int SomeMethod();
    }

    public class TestImplementation : ITestInterface
    {
        public int SomeMethod()
        {
            return 1;
        }
    }

    public class TestImplementation2 : ITestInterface
    {
        public int SomeMethod()
        {
            return 1;
        }
    }

    [TestClass]
    public class TestImplementationProviderTest
    {
        private readonly MockRepository mockRepository;
        private readonly IContainer container;
        private readonly IConfigurationProvider configProvider;

        public TestImplementationProviderTest()
        {
            this.mockRepository = new MockRepository();

            this.container = this.mockRepository.StrictMockWithRemoting<IContainer>();
            this.configProvider = this.mockRepository.DynamicMock<IConfigurationProvider>();
            Container.UseLocalContainer(container);
        }

        [TestMethod]
        public void TestImplementationProviderCanBeInstantiated()
        {
            ITestImplementationProvider provider = new TestImplementationProvider();
        }

        [TestMethod]
        public void GetTestImplementationTypeWorksAsExpectedWithValidParameters()
        {
            ITestImplementationProvider provider = new TestImplementationProvider();

            using (this.mockRepository.Record())
            {
                SetupResult.For(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                Expect.Call(this.configProvider.GetSetting("leet_Leet_Core_Test_ITestInterface"))
                    .Return("Leet.Core.Test.TestImplementation, Leet.Core.Test");
            }

            using (this.mockRepository.Playback())
            {
                Type testType = provider.GetTestImplementationType<ITestInterface>();
                Assert.AreEqual(typeof(TestImplementation), testType);
            }
        }

        [TestMethod]
        public void GetTestImplementationTypeWorksAsExpectedWithValidParameters_LongInterfaceName()
        {
            ITestImplementationProvider provider = new TestImplementationProvider();

            using (this.mockRepository.Record())
            {
                SetupResult.For(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                Expect.Call(this.configProvider.GetSetting("leet_Leet_Core_Test_ITestInterface"))
                    .Throw(new ApplicationException());
                Expect.Call(this.configProvider.GetSetting("leet_ITestInterface"))
                    .Return("Leet.Core.Test.TestImplementation, Leet.Core.Test");
            }

            using (this.mockRepository.Playback())
            {
                Type testType = provider.GetTestImplementationType<ITestInterface>();
                Assert.AreEqual(typeof(TestImplementation), testType);
            }
        }

        [TestMethod]
        public void GetTestImplementationTypeReturnsNullIfInterfaceNotSpecifiedInConfig()
        {
            ITestImplementationProvider provider = new TestImplementationProvider();
            
            using (this.mockRepository.Record())
            {
                SetupResult.For(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                SetupResult.For(this.configProvider.GetSetting(""))
                    .IgnoreArguments()
                    .Throw(new ApplicationException());
            }

            using (this.mockRepository.Playback())
            {
                Type testObject = provider.GetTestImplementationType<ITestInterface>();
                Assert.IsNull(testObject);
            }
        }

        [TestMethod]
        [ExpectedException(typeof(TypeLoadException))]
        public void GetTestImplementationTypeThrowsIfTestClassIsMisconfigured()
        {
            ITestImplementationProvider provider = new TestImplementationProvider();

            using (this.mockRepository.Record())
            {
                SetupResult.For(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                Expect.Call(this.configProvider.GetSetting(""))
                    .IgnoreArguments()
                    .Return("BadTestClassName");
            }

            using (this.mockRepository.Playback())
            {
                provider.GetTestImplementationType<ITestInterface>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\TestSupport\EmulatableServiceTest.cs ===
﻿using System;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.TestSupport;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;

namespace Leet.Core.Test
{
    [TestClass]
    public class EmulatableServiceTest
    {
        private readonly MockRepository mockRepository;
        private readonly IContainer container;
        private IConfigurationProvider configProvider;
        private readonly ITestImplementationProvider testImplementationProvider;

        public EmulatableServiceTest()
        {
            this.mockRepository = new MockRepository();

            this.container = this.mockRepository.StrictMockWithRemoting<IContainer>();
            this.configProvider = this.mockRepository.DynamicMock<IConfigurationProvider>();
            this.testImplementationProvider = this.mockRepository.StrictMock<ITestImplementationProvider>();

            Container.UseLocalContainer(this.container);
        }

        [TestMethod]
        public void AddEmulatableServiceAddsRegularImplementationIfTestImplementationsAreOff()
        {
            using (this.mockRepository.Record())
            {
                Expect.Call(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                Expect.Call(this.configProvider.GetBoolSetting("")) // Call to get UseTestImplementations setting
                    .IgnoreArguments()
                    .Return(false); 
                Expect.Call(Container.Instance.AddService<ITestInterface, TestImplementation>())
                    .Return(Container.Instance);
            }

            using (this.mockRepository.Playback())
            {
                Container.Instance.AddEmulatableService<ITestInterface, TestImplementation>();
            }
        }

        [TestMethod]
        public void AddEmulatableServiceAddsRegularImplementationIfTestImplementationNotConfigured()
        {
            using (this.mockRepository.Record())
            {
                Expect.Call(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                Expect.Call(this.configProvider.GetBoolSetting(""))  // Call to get UseTestImplementations setting
                    .IgnoreArguments()
                    .Return(true);
                Expect.Call(Container.Instance.GetComponent<ITestImplementationProvider>())
                    .Return(this.testImplementationProvider);
                Expect.Call(this.testImplementationProvider.GetTestImplementationType<ITestInterface>())
                    .Return(null);  // means no test implementation configured

                // the test is actually the expectation below
                Expect.Call(Container.Instance.AddService<ITestInterface, TestImplementation>())
                    .Return(Container.Instance);
            }

            using (this.mockRepository.Playback())
            {
                Container.Instance.AddEmulatableService<ITestInterface, TestImplementation>();
            }
        }

        [TestMethod]
        public void AddEmulatableServiceAddsTestImplementationIfSoConfigured()
        {
            this.configProvider = this.mockRepository.DynamicMock<IConfigurationProvider>();

            using (this.mockRepository.Record())
            {
                Expect.Call(Container.Instance.GetComponent<IConfigurationProvider>())
                    .Return(this.configProvider);
                Expect.Call(this.configProvider.GetBoolSetting(""))  // Call to get UseTestImplementations setting
                    .IgnoreArguments()
                    .Return(true);
                Expect.Call(Container.Instance.GetComponent<ITestImplementationProvider>())
                    .Return(this.testImplementationProvider);
                Expect.Call(this.testImplementationProvider.GetTestImplementationType<ITestInterface>())
                    .Return(Type.GetType("Leet.Core.Test.TestImplementation2"));

                // the test is actually the expectation below
                Expect.Call(Container.Instance.AddService<ITestInterface, TestImplementation2>())
                    .Return(null);
            }

            using (this.mockRepository.Playback())
            {
                Container.Instance.AddEmulatableService<ITestInterface, TestImplementation>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.FriendManager\ParentalControlPermissionDenied.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ParentalControlPermissionDenied.cs" company="Microsoft" author="shaken">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>Exception for when a user does not have the Parental control permission.</summary>
//-------------------------------------------------------------------------------------------------
namespace Leet.FriendManager
{
    using System;

    /// <summary>
    /// Required privileges missing due to parental control
    /// </summary>
    public class ParentalControlPermissionDenied : Exception
    {
        private byte privilege;

        public ParentalControlPermissionDenied(byte privilege)
        {
            this.privilege = privilege;
        }

        public byte Privilege
        {
            get { return this.privilege; }
            set { this.privilege = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.FriendManager.Test\FriendManagerTest.cs ===
﻿namespace Leet.FriendManager.Test
{    
    using System;
    using System.Text;
    using System.Collections.Generic;
    using System.Linq;
    using Leet.FriendManager;
    using Leet.Identity.ActiveAuth;
    using Leet.Live.Livecache.DataAccess;
    using Leet.TestUtilities;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Rhino.Mocks;

    /// <summary>
    /// Unit tests for the FriendManager project
    /// </summary>
    [TestClass]
    public class FriendManagerTest
    {
        private IFriendManager friendManager;
        private IPresenceDataAccess presenseDataAccess;
        private IActiveAuthAdapter activeAuthAdapter;
        private ulong userXuid = 12345;
        private ulong newFriendXuid = 67890;

        /// <summary>
        /// Initialize the test data
        /// </summary>
        [TestInitialize]
        public void Initialize()
        {
            friendManager = new FriendManager();

            // Create Stubs
            var stubber = new Stubber();

            this.presenseDataAccess = stubber.RegisterWithContainer<IPresenceDataAccess>();
            this.activeAuthAdapter = stubber.RegisterWithContainer<IActiveAuthAdapter>();
        }

        /// <summary>
        /// Ensure the argument exception if the userXuid is 0
        /// </summary>
        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void AddFriend_ArgumentException_UserXuid()
        {
            friendManager.AddFriend(0, newFriendXuid);
        }

        /// <summary>
        /// Ensure the argument exception if the targetXuid is 0
        /// </summary>
        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void AddFriend_ArgumentException_TargetXuid()
        {
            friendManager.AddFriend(userXuid, 0);
        }

        /// <summary>
        /// Verify the call when priveleges are present
        /// </summary>
        [TestMethod]
        public void AddFriend_ValidCase()
        {
            bool response = false;

            // Arrange
            this.presenseDataAccess.Stub(x => x.AddFriend(0, 0))
                .IgnoreArguments();
            this.activeAuthAdapter.Stub(x => x.HasPrivilege(0))
                .IgnoreArguments()
                .Return(true);

            // Act
            response = this.friendManager.AddFriend(userXuid, newFriendXuid);

            // Assert
            Assert.IsTrue(response);
        }

        /// <summary>
        /// Verify the call when privileges are false
        /// </summary>
        [TestMethod]
        [ExpectedException(typeof(ParentalControlPermissionDenied))]
        public void AddFriend_NoPrivelege()
        {
            // Arrange
            this.activeAuthAdapter.Stub(x => x.HasPrivilege(0))
                .IgnoreArguments()
                .Return(false);

            // Act
            this.friendManager.AddFriend(userXuid, newFriendXuid);            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.FriendManager\IFriendManager.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="IFriendManager.cs" company="Microsoft" author="shaken">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>IFriendManager interface.</summary>
//-------------------------------------------------------------------------------------------------
namespace Leet.FriendManager
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// IFriendManager Interface
    /// </summary>
    public interface IFriendManager
    {
        /// <summary>
        /// AddFriend method attempts to send a friend request to newFriendXuid from userXuid.
        /// </summary>
        /// <param name="userXuid"></param>
        /// <param name="newFriendXuid"></param>
        /// <returns></returns>
        bool AddFriend(ulong userXuid, ulong newFriendXuid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\BaseHealthRequest.cs ===
using System;
using System.IO;
using System.Text;
using System.Web;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Reflection;
using System.Net;
using Leet.Core;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Utils;
using Leet.Utils;
using Leet.Core.Diagnostics;

namespace Leet.Health.Common
{

    // --------------------------------------------------------------------------------------
    //
    // Entry point for the healthcheck request. This is provided in HealthCheckCommon dll. 
    // Calling this handler doesn't mean the real application can be loaded. 
    // Another way of doing this is to implement an IHttpHandler in the application, let it 
    // invoke Leet.Health.Common.HealthEngine.ProcessRequest() and pass in the config name. 
    // This needs to compile into the application, 
    // since we want ProcessRequest() to load the application, not hit the xblhealthcheck.dll 
    // directly. 
    //
    // --------------------------------------------------------------------------------------

    public class BaseHealthRequest : IHttpHandler
    {
        // IHttpHandler method
        public virtual void ProcessRequest(HttpContext ctx)
        {
            if (this.CheckRequestPermission(ctx) == false)
            {
                return;
            }

            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            // Have to pass in everything that lives in this assembly/component
            HealthcheckEngine.ProcessRequest(
                ctx,
                config.ComponentName);
        }

        // IHttpHandler method
        public bool IsReusable
        {
            get { return true; }
        }

        /// <summary>
        /// Check if the request has the permission to get the health check information. 
        /// </summary>
        /// <param name="ctx">The current http context. </param>
        /// <returns>Boolean to indicate if the caller has permission or not. </returns>
        private bool CheckRequestPermission(HttpContext ctx)
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            IInterfaceInfo healthInterface = null;
            try
            {
                string healthInterfaceName = ConfigurationManager.AppSettings["HealthCheckInterface"];
                if (!string.IsNullOrEmpty(healthInterfaceName))
                {
                    healthInterface = config.GetInterface(Environment.MachineName, healthInterfaceName);
                }

                if (healthInterface != null)
                {
                    if (ctx.Request.Url.Port != healthInterface.Port)
                    {
                        Logging.TraceInformation("{0} > {1}{2}",
                            "HealthCheck",
                            "request denied ",
                            ctx.Request.Url.ToString());

                        ctx.Response.StatusCode = (int)HttpStatusCode.Forbidden;
                        return false;
                    }
                }

                return true;
            }
            catch (Exception ex)
            {
                Logging.TraceException(ex, "HealthCheck");

                // the health check interface is not registered properly, let the request go through. 
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthBlockLiveCache\Block_LiveCacheAccess.cs ===
//
// Block_LiveCacheAccess.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// 
//
// Common healthblock implementation.
//
// Author: a-gamavi 4/2010
//         
//

using System;
using System.Collections.Specialized;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Health.Common;
using Leet.Identity;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Account;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Exceptions;
using xonline.common.webplatform.livecache;

namespace Leet.Health.BlockLiveCache
{
// --------------------------------------------------------------------------------------
// LiveCacheAccess - Verifies that XCache and LiveCache can be accessed
//
// Must add a key TestLiveID with a valid Live ID in the web.config file
// <add key="TestLiveID" value="livenops@live-int.com"/>
//
// --------------------------------------------------------------------------------------
internal class LiveCacheAccess : IHealthBlock
{
    public ResourceTypeEnum ResourceType
    {
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

        LiveCacheAccessReport myReport = new LiveCacheAccessReport();
        report.ExtendedReport = myReport;

        // Fill out component and extended message
        myReport.Component = config.ComponentName;

        try
        {
            string gamertag = config.GetSetting(Settings.Healthcheck_Gamertag);

            if (!LeetLivecacheClient.IsInitialized)
            {
                LeetLivecacheClient.RegisterServiceInterfacesAndInitialize(config.ComponentName);
            }

            // Test XCache
            // TODO (note):  Ideally, we'd have a set of usable accounts for every environment, but at this point we don't.
            // Since that's the case, the XCache check will run but not influence the outcome of the health report since
            // many environments (testnet, int2, partnernet) don't have consistant accounts to use at this time.
            IXCacheDataAccess xda = Container.Instance.GetComponent<IXCacheDataAccess>();
            ulong livePuid = 0;
            bool xCacheResult = xda.GetPuidByGamerTag(gamertag, out livePuid);

            // Test livecache
            bool lcResult = false;
            lcResult = DoReserveGamertagHealthCheck(myReport);

            if(lcResult == false)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                return;
            }

            report.HealthStatus = HealthStatusEnum.Green;
        }
        catch (Exception ex)
        {
            // Write the exception to the health report
            myReport.Message = ex.ToString();
            report.HealthStatus = HealthStatusEnum.Red;
        }
    }

    private bool DoReserveGamertagHealthCheck(LiveCacheAccessReport myReport)
    {
        const int US_COUNTRY_ID = 103;
        bool success = true;
        ulong randomMachineId = GetRandomULong() & 0x0000ffffffffffff | 0xfc00000000000000;

        // Hand crank one of these so we don't mess up the IoC Container
        ILcAccountCreation lcAccountCreation = new LcAccountCreation(LivecacheClientType.LIVEn, LivecacheConstants.WEB_TITLE_ID, true);
        IAccountCreationDataAccess acda = new AccountCreationDataAccess(lcAccountCreation);

        try
        {
            acda.ReserveGamerTag(randomMachineId, US_COUNTRY_ID, "LEHealth");
        }
        catch (LeetLivecacheResponseException ex)
        {
            myReport.Message = ex.ToString();
            success = false;
        }

        myReport.Message = "Verified the access to Livecache using ReserveGamertag";
        return success;
    }

    private static ulong GetRandomULong()
    {
        Random rnd = new Random();
        int i = rnd.Next();
        int j = rnd.Next();
        return (((ulong)i) << 32) + (ulong)j;
    }
}

// --------------------------------------------------------------------------------------
// LiveCacheAccessReport - health report
// --------------------------------------------------------------------------------------
public class LiveCacheAccessReport : IExtendedHealthReport
{
    /// <summary>
    /// The component name.
    /// </summary>
    public string Component { get; set; }

    /// <summary>
    /// The extended message. 
    /// </summary>
    public string Message { get; set; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.FriendManager\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.FriendManager")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("911450f2-b672-4dee-b932-1a7b99560c14")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.FriendManager\FriendManager.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="FriendManager.cs" company="Microsoft" author="shaken">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>FriendManager implementation.</summary>
//-------------------------------------------------------------------------------------------------
namespace Leet.FriendManager
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Leet.Core.IoCCo;
    using Leet.Identity.ActiveAuth;
    using Leet.Live.Livecache.DataAccess;
    using xonline.common.service;

    /// <summary>
    /// FriendManager class
    /// </summary>
    [SingletonInstance]
    public class FriendManager : IFriendManager
    {
        public static void RegisterWithIocContainer(IContainer container)
        {
            container.AddEmulatableService<IFriendManager, FriendManager>();
        }
        
        /// <summary>
        /// This method will attempt to Add a friend if you have the permission to do so.  Will throw a
        /// ParentalControlPermissionDenied exception if the user does not have the XPRIVILEGE_ADD_FRIEND  
        /// privilege.
        /// </summary>
        /// <param name="userXuid">Calling user's Xuid</param>
        /// <param name="newFriendXuid">target Friend's Xuid</param>
        /// <returns>true if the AddFriend call is made, false if the user cannot send the request or the target is the caller</returns>
        public bool AddFriend(ulong userXuid, ulong newFriendXuid)
        {
            if (userXuid == 0)
            {
                throw new ArgumentException("userXuid is 0");
            }

            if (newFriendXuid == 0)
            {
                throw new ArgumentException("newFriendXuid is 0");
            }

            if (userXuid != newFriendXuid)
            {
                // check if caller has permission to add a friend.  Throws exception if no permission.
                this.CheckPermissionForAdd();

                var presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();

                // make livecache AddFriend call.
                presenceDataAccess.AddFriend(userXuid, newFriendXuid);

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Checks if the current caller has the Add Friend Permission.  Throws a ParentalControlPermissionDenied exception
        /// if the user does not have permission to add friends.
        /// </summary>
        private void CheckPermissionForAdd()
        {
            IActiveAuthAdapter activeAuthAdapter = Container.Instance.GetComponent<IActiveAuthAdapter>();
            bool hasPermission = activeAuthAdapter.HasPrivilege(XOn.XPRIVILEGE_ADD_FRIEND);

            if (!hasPermission)
            {
                throw new ParentalControlPermissionDenied(XOn.XPRIVILEGE_ADD_FRIEND);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Core.Test\Wcf\ClientChannelConfigurationTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.Wcf;

namespace Leet.Core.Test.Wcf
{
    [TestClass]
    public class ClientChannelConfigurationTest
    {
        [TestMethod]
        public void MaxReceivedMessageSize_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.MaxReceivedMessageSize = 20;

            // Assert
            Assert.AreEqual(20, target.MaxReceivedMessageSize);
            Assert.IsTrue(propertiesChanged.Contains("MaxReceivedMessageSize"));
        }

        [TestMethod]
        public void MaxBufferPoolSize_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.MaxBufferPoolSize = 40;

            // Assert
            Assert.AreEqual(40, target.MaxBufferPoolSize);
            Assert.IsTrue(propertiesChanged.Contains("MaxBufferPoolSize"));
        }

        [TestMethod]
        public void OpenTimeout_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.OpenTimeout = new TimeSpan(1, 0, 0);

            // Assert
            Assert.AreEqual(1, target.OpenTimeout.Hours);
            Assert.AreEqual(0, target.OpenTimeout.Minutes);
            Assert.AreEqual(0, target.OpenTimeout.Seconds);
            Assert.IsTrue(propertiesChanged.Contains("OpenTimeout"));
        }

        [TestMethod]
        public void CloseTimeout_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.CloseTimeout = new TimeSpan(2, 3, 4);

            // Assert
            Assert.AreEqual(2, target.CloseTimeout.Hours);
            Assert.AreEqual(3, target.CloseTimeout.Minutes);
            Assert.AreEqual(4, target.CloseTimeout.Seconds);
            Assert.IsTrue(propertiesChanged.Contains("CloseTimeout"));
        }

        [TestMethod]
        public void ReceiveTimeout_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.ReceiveTimeout = new TimeSpan(5, 6, 7);

            // Assert
            Assert.AreEqual(5, target.ReceiveTimeout.Hours);
            Assert.AreEqual(6, target.ReceiveTimeout.Minutes);
            Assert.AreEqual(7, target.ReceiveTimeout.Seconds);
            Assert.IsTrue(propertiesChanged.Contains("ReceiveTimeout"));
        }

        [TestMethod]
        public void SendTimeout_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.SendTimeout = new TimeSpan(7, 6, 5);

            // Assert
            Assert.AreEqual(7, target.SendTimeout.Hours);
            Assert.AreEqual(6, target.SendTimeout.Minutes);
            Assert.AreEqual(5, target.SendTimeout.Seconds);
            Assert.IsTrue(propertiesChanged.Contains("SendTimeout"));
        }

        [TestMethod]
        public void ReliableSessionEnabled_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.ReliableSessionEnabled = true;

            // Assert
            Assert.AreEqual(true, target.ReliableSessionEnabled);
            Assert.IsTrue(propertiesChanged.Contains("ReliableSessionEnabled"));
        }

        [TestMethod]
        public void ReliableSessionTimeout_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.ReliableSessionTimeout = new TimeSpan(1234567);

            // Assert
            Assert.AreEqual(1234567, target.ReliableSessionTimeout.Ticks);
            Assert.IsTrue(propertiesChanged.Contains("ReliableSessionTimeout"));
        }

        [TestMethod]
        public void ReliableSessionOrdered_Notifies_When_Property_Changes()
        {
            // Arrange
            var target = new ClientChannelConfiguration();

            var propertiesChanged = new List<string>();
            target.PropertyChanged += (sender, eventArgs) => { propertiesChanged.Add(eventArgs.PropertyName); };

            // Act
            target.ReliableSessionOrdered = false;

            // Assert
            Assert.AreEqual(false, target.ReliableSessionOrdered);
            Assert.IsTrue(propertiesChanged.Contains("ReliableSessionOrdered"));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_CertInfo.cs ===
// 
// CertInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// This module implements a certificate common healthblock
// All the checks in the module are *local*
//
// Notes:
//  One could have used a X509CertificateValidator class. Unfortunately
//  none of the existing functionality provided by that class is readily
//  usable for our purposes. It is probably worth looking at it again if
//  implementing a network health check on proper certificate chaining.
//
//  The internal certificate member is of type X509Certificate2 as this
//  allows better access to certain properties (such as DateTime).
//
//  A note on how to treat non existance on checks that assume existence
//  of the certificate. There are two choices:
//    - treat existence as a prerequisite, so if the cert is not there
//    it's considered expired :-). This allows to effectively skip
//    existence blocks if other blocks are present. One could argue
//    this check should be hardcoded.
//    - arguably someone can make expiry mustpass, but existance CouldFail
//    trying to capture the semantics of requring a valid cert only if it
//    exists.
//
//  The code implements the later, mostly due to programmer preference.
//  The thinking was that all checks must be explicit, hence the former
//  argument was not seen as a strong one. In addition, checks can return
//  a fatal result which will stop further processing. Currently the
//  existence check does so. There is no guarantee that the existence check
//  comes first. Upon further review we decided to add defaults (and the 
//  ability to skip checks that might come from defaults with that) as a
//  mechanism to allow developers to easily use this blocks. That doesn't
//  change the requirement to account for non existence of the cert in
//  other checks.
//
//  Notes on validators:
//    - PrivateKey - the original scope for this check was to catch the
//    case where the key file is improperly ACL'ed or missing. Basic
//    testing has revelead that existence check fails too. The code
//    is still useful as a Report feature for troubleshooting though.
//
//    - Verify - this allows a modicum of local chain validation. Normally
//    we use certificates for authentication. Hence the validation
//    should really run on the *other party*, so local validation is not
//    really full proof. But X508Certificate2.Validate() makes it so
//    easily done so, given that arguably one can rely on the fact that
//    all of our servers are usually built similarly, a validation
//    failure on the client can indicate indicates a potential problem on
//    the server as well. However, experience has shown that chain
//    validations problems occur when [intermediate] trust roots are
//    not properly installed. This problem can potentially be solved better
//    by checking existence for known roots.
//
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using Leet.Core;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo; 
using Leet.Core.Utils;
using Leet.Utils; 


namespace Leet.Health.Common
{
    // ------------------------------------------------------------------------------------
    // Parameter description 
    // A certinfo health block requires a certificate ID, a list of certificate properties
    // and a list of certificate checks
    // A certificate ID can be one of the following:
    //      - SubjectName - this is the name in the Subject field of the certificate
    //      - SubjectNameSetting - this is the NPDB setting that contains the subject name
    //
    // The only certificate property supported as of now is the store location:
    //      - Store - User/Machine
    // 
    // A check can be defined as
    //      - MustPass - the health check will fail if this fails
    //      - CouldFail - the health check will show yellow if this fails
    //      - Report - this is for reporting purposes only
    // 
    // The list of checks we support are
    //      - UserStore - the cert exists in the User Store
    //      - MachineStore - the cert exists in the Machine Store
    //      - Expiry - the cert has a valid date
    //      - PrivateKey - the cert has a private key attached and accessible
    //
    // Here are the two XML simplified formats
    // 
    // <vc_params>SubjectName = int-rps.xboxlive.com, Store = Machine, Existence = MustPass, Expiry = CouldFail, PrivateKey = Report</vc_params>
    // <vc_params>SubjectNameSetting = ups_clientCertName, Store = User, Existence = MustPass, Expiry = MustPass, PrivateKey = CouldFail</vc_params>
    // 
    // ------------------------------------------------------------------------------------
    static class CertificateCheckFactory
    {
        public static List<CertificateCheck> CreateCertificateChecks(X509Certificate2 Certificate)
        {
            //
            // in normal cases we don't have more than 4 checks
            //
            List<CertificateCheck> checkList = new List<CertificateCheck>(4);

            //
            // The defaults for the checks are described below
            //
            checkList.Add(new ExistenceCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.MustPass));
            checkList.Add(new ExpiryCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.MustPass));
            checkList.Add(new VerifyCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.MustPass));
            checkList.Add(new PrivateKeyCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.CouldFail));

            return checkList;
        }

        public static void UpdateCertificateChecks(List<CertificateCheck> checkList,
                                                   string Type,
                                                   string[] Parameters)
        {
            CertificateCheck check = null;
            string Parameter = null;
            CertificateCheck.CheckTypeEnum checkType = CertificateCheck.CheckTypeEnum.Undefined;

            //
            // if there is more than one Parameter this is an error
            //
            if (Parameters.Length != 1)
            {
                //
                // This will result in an invalid paramter error
                //
                Parameter = String.Format("Duplicated parameters: {0}", Parameters.ToString()); 
            }
            else
            {
                Parameter = Parameters[0];
            }

            switch (Parameter.Trim().ToLower())
            { 
                case Value_MustPass:
                    checkType = CertificateCheck.CheckTypeEnum.MustPass;
                    break;

                case Value_CouldFail:
                    checkType = CertificateCheck.CheckTypeEnum.CouldFail;
                    break;

                case Value_ReportOnly:
                    checkType = CertificateCheck.CheckTypeEnum.ReportOnly;
                    break;

                case Value_Skip:
                    checkType = CertificateCheck.CheckTypeEnum.Skip;
                    break;

                default:
                    //
                    // could leave the default, but don't want silent failures
                    //
                    checkType = CertificateCheck.CheckTypeEnum.Undefined;
                    break;
            }

            //
            // if we decide to increase the number of checks, having a
            // mapping from name to objects may be better. Seems overkill
            // for now.
            //
            if (checkType != CertificateCheck.CheckTypeEnum.Undefined)
            {
                switch (Type.Trim().ToLower())
                {
                    case Value_Existence:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(ExistenceCertificateCheck)); });
                        break;
                    case Value_Expiry:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(ExpiryCertificateCheck)); });
                        break;
                    case Value_Verify:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(VerifyCertificateCheck)); });
                        break;
                    case Value_PrivateKey:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(PrivateKeyCertificateCheck)); });
                        break;
                    default:
                        // check is null;
                        break;
                }
            }

            if (check != null)
            {
                //
                // Update the check type
                //
                check.CheckType = checkType;
            }
            else
            {
                //
                // add an invalid block check type so we report the failure
                //
                check = new InvalidBlockCertificateCheck(Type, Parameter);
                checkList.Add(check);
            }
        }

        //
        // values - note they are lowercased to match the checks.
        //
        private const string Value_MustPass = "mustpass";
        private const string Value_CouldFail = "couldfail";
        private const string Value_ReportOnly = "reportonly";
        private const string Value_Skip = "skip";

        private const string Value_Existence = "existence";
        private const string Value_Expiry = "expiry";
        private const string Value_PrivateKey = "privatekey";
        private const string Value_Verify = "verify";
    }

    public class CertInfo : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager,
                            NameValueCollection blockParams,
                            HealthReport report)
        {
            string SubjectName = null;
            bool userStore = false;
            X509Certificate certificate = null;
            Exception certificateException = null;

            CertInfoReport myReport = new CertInfoReport();
        
            report.ExtendedReport = myReport;

            //
            // we trim the subject names, even if this means potential
            // loss of functionality. Names with leading or trailing spaces
            // are totally uncommon. If it happens, remove the trim call.
            //
            if (blockParams[Keyword_SubjectName] != null)
            {
                SubjectName = blockParams[Keyword_SubjectName].Trim();
            }
            else if (blockParams[Keyword_SubjectNameSetting] != null)
            {
                try
                {
                    IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>(); 
                    SubjectName = config.GetSetting(blockParams[Keyword_SubjectNameSetting].Trim()).Trim();
                }
                catch (Exception e)
                {
                    report.ErrorDetails = String.Format("Cannot retrieve SubjectName from {0}\n. Exception: {1}",
                                                        blockParams[Keyword_SubjectNameSetting],
                                                        e);
                    SubjectName = null;
                }
            }

            if (SubjectName == null)
            {
                //
                // Taking servers out of production because of an operator error
                // seems too harsh.
                //
                report.ErrorDetails += "SubjectName is not specified";
                report.HealthStatus = HealthStatusEnum.Yellow;
                return;
            }

            //
            // Future improvement: Ideally we should have a store enumaration here.
            // When the CertUtil gets upgraded this should be too.
            //
            if (blockParams[Keyword_Store] != null)
            {
                if (String.Equals(blockParams[Keyword_Store].Trim().ToLower(), Value_User, StringComparison.OrdinalIgnoreCase))
                {
                    userStore = true;
                }
                else if (String.Equals(blockParams[Keyword_Store].Trim().ToLower(), Value_Machine, StringComparison.OrdinalIgnoreCase))
                {
                    userStore = false;
                }
                else
                {
                    report.ErrorDetails = "Cannot retrieve Store type from the block parameters.\n";
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    return;
                }
            }


            //
            // start with a known good values - Green is optimistic, but
            // helps bootstrapping.
            //
            StringBuilder sb = new StringBuilder();
            report.HealthStatus = HealthStatusEnum.Green;

            //
            // get the certificate (defaults to machine for now if none specified)
            //
            try
            {
                if( userStore )
                {
                    certificate = CertUtil.GetCurrentUserCertificate(SubjectName);
                }
                else
                {
                    certificate = CertUtil.GetLocalMachineCertificate(SubjectName);
                }
            }
            catch (Exception e)
            {
                //
                // the validators need do their part on a null certificate
                //
                certificate = null;
                certificateException = e;
            }

            myReport.SerializableCertificate = new SerializableX509Certificate2();
            myReport.HealthBlockId = SubjectName;
            myReport.HealthBlockStore = blockParams[Keyword_Store];

            if (certificate != null)
            {
                myReport.SerializableCertificate.Certificate = new X509Certificate2(certificate);
            }

            if (certificateException != null)
            {
                myReport.SerializableCertificate.CertificateException = certificateException;
            }

            List<CertificateCheck> checkList = 
                CertificateCheckFactory.CreateCertificateChecks(myReport.SerializableCertificate.Certificate);

            for(int i = 0; i < blockParams.Count; i++)
            {
                if (String.Equals(blockParams.GetKey(i), Keyword_SubjectName, StringComparison.OrdinalIgnoreCase) ||
                    String.Equals(blockParams.GetKey(i), Keyword_SubjectNameSetting, StringComparison.OrdinalIgnoreCase) ||
                    String.Equals(blockParams.GetKey(i), Keyword_Store, StringComparison.OrdinalIgnoreCase))
                {
                    //
                    // these keywords do not correspond to validators
                    //
                    continue;
                }
                CertificateCheckFactory.UpdateCertificateChecks(checkList,
                                                                blockParams.GetKey(i),
                                                                blockParams.GetValues(i));
            }

            foreach(CertificateCheck check in checkList)
            {
                string ErrorDetails = null;

                CertificateCheck.CheckResultEnum result = check.PerformCheck(out ErrorDetails,
                                                                             myReport);

                report.HealthStatus = check.UpdateHealthStatus(report.HealthStatus, result);

                if (ErrorDetails != null)
                {
                    sb.AppendLine(ErrorDetails);
                }
            }

            report.ErrorDetails = sb.ToString();
        }

        //
        // keywords
        //
        private const string Keyword_SubjectName          = "SubjectName";
        private const string Keyword_SubjectNameSetting   = "SubjectNameSetting";
        private const string Keyword_Store                = "Store";

        private const string Value_Machine                = "machine";
        private const string Value_User                   = "user";
    }

    abstract class CertificateCheck
    {
        public enum CheckTypeEnum
        {
            Undefined,
            MustPass,
            CouldFail,
            ReportOnly,
            Skip
        }

        public enum CheckResultEnum
        {
            Success,
            Warning,
            Failure
        }

        public CheckTypeEnum CheckType
        {
            get
            {
                return _checkType;
            }
            set
            {
                _checkType = value;
            }
        }

        public CertificateCheck(X509Certificate2 Certificate, CheckTypeEnum CheckType)
        {
            _certificate = Certificate;

            _checkType = CheckType;
        }

        public abstract CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport);


        public HealthStatusEnum UpdateHealthStatus(HealthStatusEnum CurrentHealthStatus,
                                                   CheckResultEnum Result)
        {
            HealthStatusEnum newStatus = CurrentHealthStatus;

            //
            // This logic is global
            //  Failure -> Red if Must Pass or otherwise Yellow if not already Red
            //  Warning -> if MustPuss/CouldFail Yellow if not already Red
            //  Success -> Preserve current status
            //
            if (Result == CheckResultEnum.Failure)
            {
                if (_checkType == CheckTypeEnum.MustPass)
                {
                    newStatus = HealthStatusEnum.Red;
                }

                if (_checkType == CheckTypeEnum.CouldFail)
                {
                    if (CurrentHealthStatus == HealthStatusEnum.Green)
                    {
                        newStatus = HealthStatusEnum.Yellow;
                    }
                }
            }
            else if (Result == CheckResultEnum.Warning)
            {
                if ((_checkType == CheckTypeEnum.CouldFail) ||
                     (_checkType == CheckTypeEnum.MustPass))
                {
                    if (CurrentHealthStatus == HealthStatusEnum.Green)
                    {
                        newStatus = HealthStatusEnum.Yellow;
                    }
                }
            }
            // else nothing

            return newStatus;
        }

        protected X509Certificate2 _certificate;
        protected CheckTypeEnum    _checkType;
    }

    class ExistenceCertificateCheck : CertificateCheck
    {
        public ExistenceCertificateCheck(X509Certificate2 Certificate,
                                         CheckTypeEnum CheckType) : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate == null)
            {
                ErrorDetailsString = "Existence check: Certificate is not present.";
                result = CheckResultEnum.Failure;
            }

            return result;
        }
    }

    class ExpiryCertificateCheck : CertificateCheck
    {
        public ExpiryCertificateCheck(X509Certificate2 Certificate,
                                      CheckTypeEnum CheckType) : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate != null)
            {
                DateTime current = DateTime.Now;
                DateTime notAfter = _certificate.NotAfter;
                DateTime notBefore = _certificate.NotBefore;

                if ((current < notBefore) || (current > notAfter))
                {
                    result = CheckResultEnum.Failure;

                    StringBuilder sb = new StringBuilder("Expiry check: Valid from: ");
                    sb.Append(notBefore.ToString());
                    sb.Append(". Valid to: ");
                    sb.Append(notAfter.ToString());
                    sb.AppendLine(".");
                    ErrorDetailsString = sb.ToString();
                }
                else
                {
                    TimeSpan ExpiryGracePeriod = new TimeSpan(30, 0, 0, 0); // 30 days 
                    DateTime delta = current.Add(ExpiryGracePeriod);

                    if (delta > notAfter)
                    {
                        result = CheckResultEnum.Warning;

                        StringBuilder sb = new StringBuilder("Expiry check: Expiry date ");
                        sb.Append(notAfter.ToString());
                        sb.Append(" is less than ");
                        sb.Append(ExpiryGracePeriod.Days.ToString());
                        sb.AppendLine(" days in the future.");
                        ErrorDetailsString = sb.ToString();
                    }
                }
            }
            // else nothing

            return result;
        }
    }

    class VerifyCertificateCheck : CertificateCheck
    {
        public VerifyCertificateCheck(X509Certificate2 Certificate,
                                      CheckTypeEnum CheckType)
            : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate != null)
            {
                try
                {
                    if (!_certificate.Verify())
                    {
                        //
                        // unfortunately this is the best we get apparently.
                        //
                        result = CheckResultEnum.Failure;
                        ErrorDetailsString = "Verify check: Certificate verification failed.";
                    }
                }
                catch (Exception e)
                {
                    result = CheckResultEnum.Failure;

                    ErrorDetailsString = "Verify check: Certificate verification threw an exception.";
                    CIReport.SerializableCertificate.VerificationException = e;
                }

            }
            // else nothing

            if (result != CheckResultEnum.Success)
            {
                CIReport.VerifyResult = false;
            }
            else
            {
                CIReport.VerifyResult = true;
            }

            return result;
        }
    }


    class PrivateKeyCertificateCheck : CertificateCheck
    {
        public PrivateKeyCertificateCheck(X509Certificate2 Certificate,
                                          CheckTypeEnum CheckType) : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate != null)
            {
                try
                {
                    string keyfileName = CertUtil.GetKeyFileName(_certificate);

                    CIReport.KeyFileName = keyfileName;
                }
                catch (Exception e)
                {
                    result = CheckResultEnum.Failure;

                    //
                    // if we get here the certificate is non null so there should be
                    // no exception to overwrite!
                    //
                    CIReport.SerializableCertificate.CertificateException = e;

                    ErrorDetailsString = "Private Key check: Retrieval failed.";
                }

            }
            // else nothing

            return result;
        }
    }

    class InvalidBlockCertificateCheck : CertificateCheck
    {
        public InvalidBlockCertificateCheck(string Type, string Parameter) :
                    base(null, CheckTypeEnum.CouldFail)
        {
            //
            // Use CouldFail as we don't want to take servers out of VIP
            // due to wrong configuration
            //
            _type = Type;
            _parameter = Parameter;
        }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            //
            // if we get here it means we failed to parse the check
            //
            ErrorDetailsString = String.Format("Incorrect block - Type: {0}, Parameter: {1}\n",
                                               _type,
                                               _parameter);

            //
            // return fail to allow others to continue, even if one check is wrong
            //
            return CheckResultEnum.Failure;
        }

        private string _type;
        private string _parameter;
    }

    //
    // X509Certificate* cannot be serialized by itself -- so we cheat
    // Same goes for System.Exception
    //
    public class SerializableX509Certificate2 : IXmlSerializable
    {
        public SerializableX509Certificate2()
        {
            _certificate = null;
            _certificateException = null;
            _verificationException = null;
        }

        public X509Certificate2 Certificate
        {
            get
            {
                return _certificate;
            }
            set
            {
                _certificate = value;
            }
        }

        public Exception CertificateException
        {
            get
            {
                return _certificateException;
            }
            set
            {
                _certificateException = value;
            }
        }

        public Exception VerificationException
        {
            get
            {
                return _verificationException;
            }
            set
            {
                _verificationException = value;
            }
        }

        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        public void ReadXml(XmlReader reader)
        {
            // we don't support deserialization
            throw new NotSupportedException();
        }

        public void WriteXml(System.Xml.XmlWriter writer)
        {
            if (_certificate != null)
            {
                string[] properties = {
                        "Archived",
                        "FriendlyName",
                        "HasPrivateKey",
                        "Issuer",
                        "NotAfter",
                        "NotBefore",
                        "SerialNumber",
                        "Subject",
                        "Thumbprint",
                        "Version"
                        };

                foreach (string property in properties)
                {
                    try
                    {
                        PropertyInfo propInfo = _certificate.GetType().GetProperty(property);

                        writer.WriteElementString(property, propInfo.GetGetMethod().Invoke(_certificate, null).ToString());
                    }
                    catch (Exception e)
                    {
                        writer.WriteElementString("Error", e.ToString());
                    }
                }
            }

            if (_certificateException != null)
            {
                writer.WriteElementString("CertificateException", _certificateException.ToString());
            }

            if (_verificationException != null)
            {
                writer.WriteElementString("VerificationException", _verificationException.ToString());
            }
        }

        //
        // We need not xml serialize the fields (they can't be really)
        // Programmer preference for simplyfing the code results in
        // the exceptions being bundled with the cert (implement WriteXml
        // once).
        //
        [XmlIgnore]
        private X509Certificate2 _certificate;

        [XmlIgnore]
        private Exception _certificateException;

        [XmlIgnore]
        private Exception _verificationException;

    }

    public class CertInfoReport : IExtendedHealthReport
    {
        //
        // this is for reporting cert parameters
        //
        public string HealthBlockId;
        public string HealthBlockStore;

        //
        // this is for the cert (and bundled exceptions)
        //
        public SerializableX509Certificate2 SerializableCertificate;

        //
        // private key file (not path!)
        //
        public string KeyFileName;

        //
        // X509Certificate.Veirfy() result
        //
        public bool VerifyResult;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_DatabaseAccess.cs ===
﻿// Block_DiagnosticDBAccess.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Database Access Healthcheck Module
// 
// Author: mhorstma 09/2010
//

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Specialized;
using Leet.Core.Configuration;
using Leet.Core.IoCCo; 

namespace Leet.Health.Common
{
    /// <summary>
    /// Common class used to check the availability of a database
    /// </summary>
    public class DatabaseAccess : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager blockManager,
            NameValueCollection blockParams,
            HealthReport report)
        {
            DatabaseAccessReport extendedAccessReport = new DatabaseAccessReport();
            report.ExtendedReport = extendedAccessReport;

            string sqlConnectionString = String.Empty;
            string databaseInterface = blockParams["InterfaceName"];

            if (String.IsNullOrEmpty(databaseInterface))
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails += "Database interface name is not specified";
                return;
            }

            try
            {
                sqlConnectionString = IoC.Get<IConfigurationProvider>().GetConnectionString(databaseInterface);
            }
            catch(Exception ex)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails += ex.ToString();
                return;
            }

            if (String.IsNullOrEmpty(sqlConnectionString))
            {
                report.HealthStatus = HealthStatusEnum.Red;
                extendedAccessReport.Message = "Cannot obtain connection string for interface " + databaseInterface;
                return;
            }


            SqlConnection connection = new SqlConnection(sqlConnectionString);

            try
            {
                // All's healthy case
                connection.Open();
                report.HealthStatus = HealthStatusEnum.Green;
                extendedAccessReport.Message = "Successfully connected to database interface '" + databaseInterface + "'";
            }
            catch (SqlException sqlEx)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                extendedAccessReport.Message = sqlEx.ToString();
            }
            catch (Exception ex)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                extendedAccessReport.Message = ex.ToString();
            }
            finally
            {
                if (connection != null && (connection.State & ConnectionState.Open) == ConnectionState.Open)
                {
                    connection.Close();
                }
            }

        }


        /// <summary>
        /// Extended health report details
        /// </summary>
        public class DatabaseAccessReport : IExtendedHealthReport
        {
            public String Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_InternetAccess.cs ===
// InternetAccess.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: fgao 04/2010

namespace Leet.Health.Common
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Net;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    // --------------------------------------------------------------------------------------
    // Internet access - initialize and check if the service can access internet resources. 
    //
    // PARAMETERS:
    //
    // "Services" : the services that need internet access.
    internal class InternetAccess : IHealthBlock
    {
        public enum MonitoredService
        {
            // The session service.
            Session,

            // The notification service.
            Notification
        }

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            InternetAccessReport myReport = new InternetAccessReport();
            report.ExtendedReport = myReport;
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            string environment = config.Environment;

            string[] servicesToMonitor = blockParams.GetValues("Services");
            if (servicesToMonitor == null || servicesToMonitor.Length == 0)
            {
                // No services were listed
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = "No value specified for Services. Health status is unknown.";
                return;
            }

            List<MonitoredService>monitoredServices = new List<MonitoredService>();
            foreach (string service in servicesToMonitor)
            {
                MonitoredService monitoredService;
                try
                {
                    monitoredService = (MonitoredService)Enum.Parse(typeof(MonitoredService), service, false);
                }
                catch (Exception ex)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    report.ErrorDetails = ex.Message;
                    return;
                }
                
                monitoredServices.Add(monitoredService);
            }

            string[] urls = GetUrls(monitoredServices);
            WebProxy proxy = null;
            string proxyAddress = config.GetSetting(Settings.ProxyAddress);
            if (!String.IsNullOrEmpty(proxyAddress))
            {
                proxy = new WebProxy(proxyAddress);
                myReport.Message += "Proxy used : " + proxyAddress;
            }
            else
            {
                myReport.Message += "No proxy is set in NPDB ";
            }

            try
            {
                foreach (string url in urls)
                {
                    myReport.Url += "\nRequested URL : " + url;
                    Uri uri = new Uri(url);
                    WebRequest request = WebRequest.Create(uri);
                    request.Proxy = proxy;
                    WebResponse resp = null;
                    try
                    {
                        resp = request.GetResponse();
                    }
                    catch (WebException webEx)
                    {
                        HttpStatusCode responseHttpStatusCode = ((HttpWebResponse) webEx.Response).StatusCode;
                        myReport.Message += String.Format("\nURL: {0} Response: {1}", url, responseHttpStatusCode);
                        if (responseHttpStatusCode == HttpStatusCode.BadRequest)
                        {
                            // It is OK to get HTTP BadRequest (400) since it shows that we have internet access.
                        }
                        else
                        {
                            throw;
                        }
                    }

                    if (resp != null)
                    {
                        resp.Close();
                    }
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.Message;
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }

        /// <summary>
        /// Gets the internet Urls that must be accessible for the monitored services.
        /// </summary>
        /// <param name="monitoredServices">Enumerable list of monitored services.</param>
        /// <returns>Array of urls that must be accessible.</returns>
        private static string[] GetUrls(IEnumerable<MonitoredService> monitoredServices)
        {
            string[] urls = new string[0];
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            foreach (var service in monitoredServices)
            {
                switch (service)
                {
                    case MonitoredService.Session:
                        UriBuilder sessionTableUri = new UriBuilder(config.GetSetting(Settings.AzureTableStorageEndPoint));
                        sessionTableUri.Host = config.GetSetting(Settings.SessionFE_AzureStorageAccount) + "." + sessionTableUri.Host;

                        UriBuilder sessionBlobUri = new UriBuilder(config.GetSetting(Settings.AzureBlobStorageEndPoint));
                        sessionBlobUri.Host = config.GetSetting(Settings.SessionFE_AzureStorageAccount) + "." + sessionBlobUri.Host;

                        urls = new string[] { sessionTableUri.ToString(), sessionBlobUri.ToString() };

                        break;
                    case MonitoredService.Notification:
                        UriBuilder notificationTableUri = new UriBuilder(config.GetSetting(Settings.AzureTableStorageEndPoint));
                        notificationTableUri.Host = config.GetSetting(Settings.NotificationFE_AzureStorageAccount) + "." + notificationTableUri.Host;

                        urls = new string[] { notificationTableUri.ToString() };

                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            return urls;
        }
    }

    // --------------------------------------------------------------------------------------
    // InternetAccessReport - health report
    // --------------------------------------------------------------------------------------
    public class InternetAccessReport : IExtendedHealthReport
    {
        public string Url;
        public string Message;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_InternalNetworkAccess.cs ===
// InternalNetworkAccess.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: fgao 04/2010
namespace Leet.Health.Common
{
    using System;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.IO;
    using System.Net;
    using System.Text;
    using System.Web;
    using Leet.Core;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    /// <summary>
    /// The internalNetworkAccess class. 
    /// </summary>
    internal class InternalNetworkAccess : IHealthBlock
    {
        /// <summary>
        /// Gets the resource type. 
        /// </summary>
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        /// <summary>
        /// Implement the DoCheck method defined in IHealthBlock interface. 
        /// </summary>
        /// <param name="blockManager">The block manager. </param>
        /// <param name="blockParams">The parameters. </param>
        /// <param name="report">The health report. </param>
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            InternalNetworkAccessReport myReport = new InternalNetworkAccessReport();
            report.ExtendedReport = myReport;
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            string environment = config.Environment;

            string[] interfaces = blockParams.GetValues("Interface");
            string[] path = blockParams.GetValues("Path"); 
            if (interfaces == null || interfaces.Length == 0)
            {
                // no checks were able to be performed
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = "No value specified for interfaces.  Health status is unknown.";
                return;
            }
            if (interfaces.Length != path.Length)
            {
                // no checks were able to be performed
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = "Invalid parameters. Make sure one path for each interface specified in order. Health status is unknown.";
                return;
            }

            try
            {
                for(int i=0; i<interfaces.Length; i++)
                {
                    string interfaceEndpoint = config.GetInterfaceEndpoint(interfaces[i], false);
                    if (interfaceEndpoint.EndsWith("/"))
                    {
                        interfaceEndpoint = interfaceEndpoint.TrimEnd('/');
                    }

                    // BUG: read the protocol from NPDB. Fix this after expose protocol in InterfaceInfo.
                    string url = interfaceEndpoint + path[i]; // "http://" + info.Info1 + path[i];
                    myReport.Url += " Interface: " + interfaces[i] + " URL: " + url;  
                    Uri uri = new Uri(url);
                    WebRequest request = WebRequest.Create(uri);
                    WebResponse resp = request.GetResponse();
                    resp.Close(); 
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.Message;
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    /// <summary>
    /// The extended healthport class for internal network access. 
    /// </summary>
    public class InternalNetworkAccessReport : IExtendedHealthReport
    {
        /// <summary>
        /// The URL of the requested resources. 
        /// </summary>
        public string Url;

        /// <summary>
        /// The extended message. 
        /// </summary>
        public string Message;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_DiagnosticDBAccess.cs ===
﻿// Block_DiagnosticDBAccess.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Diagnostic DB Access Healthcheck Module
// 
// Author: sujeetv 06/2010
//

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Specialized;
using Leet.Core.Configuration;
using Leet.Core.IoCCo; 

namespace Leet.Health.Common
{

    // --------------------------------------------------------------------------------------
    // DiagnosticDBAccess - Tries to open a connection to the Diagnostics Db.
    // --------------------------------------------------------------------------------------
    public class DiagnosticDBAccess : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager blockManager,
            NameValueCollection blockParams,
            HealthReport report)
        {
            //get the connection string from NPDB
            String sqlConnectionString = IoC.Get<IConfigurationProvider>().GetConnectionString("lest_diagnostics_db");
            if (String.IsNullOrEmpty(sqlConnectionString))
            {
                report.HealthStatus = HealthStatusEnum.Red;
                DiagnosticDBAccessReport diagnosticDbReport = new DiagnosticDBAccessReport();
                diagnosticDbReport.Message = "Cannot obtain connection string from NPDB setting lest_diagnostics_db";
                report.ExtendedReport = diagnosticDbReport;
                return;
            }

            SqlConnection connection = new SqlConnection(sqlConnectionString);
            
            try
            {
                connection.Open();
                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (SqlException sqlEx)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                DiagnosticDBAccessReport diagnosticDbReport = new DiagnosticDBAccessReport();
                diagnosticDbReport.Message = sqlEx.ToString();
                report.ExtendedReport = diagnosticDbReport;
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                DiagnosticDBAccessReport diagnosticDbReport = new DiagnosticDBAccessReport();
                diagnosticDbReport.Message = e.ToString();
                report.ExtendedReport = diagnosticDbReport;
            }
            finally
            { 
                if(connection != null && (connection.State & ConnectionState.Open) == ConnectionState.Open)
                {
                    connection.Close();
                }
            }
            
        }


        // --------------------------------------------------------------------------------------
        // DiagnosticDBAccessReport - health report
        // --------------------------------------------------------------------------------------
        public class DiagnosticDBAccessReport : IExtendedHealthReport
        {
            public String Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_HttpModule.cs ===
// 
// Block_HttpModule.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation for verifying the presence and health of an arbitrary 
// HttpModule, like the AAModule.
// 
// Author: kgoodier 5/2008
//         fgao modified for LIVEN 3/10/2009
//

using System;
using System.Configuration; 
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Web;
using System.Xml.Serialization;

using Microsoft.Web.Administration;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// HttpModule - checks for proper configuration and existence of an HttpModule.
//
// PARAMETERS:
//
// "name" : the friendly name of the module to look for. This is configured in the 
// web.config.
//
// Example: "ActiveAuthModule"
// 
// "type" : the full type name of the module. This is a partial string match.
//
// Example: "xonline.server.activeauth.module.ActiveAuthModule"
// Example: "Version=7.0.0.0"
// Example: "aamodule, Version=7.0.0.0"
//
// You must specify either "name" or "type" or both. "name" is a strict, case-insensitive 
// match. "type" is a partial substring, case-insensitive, match.
//
// If no parameters are supplied, this simply generates a report of all dependent modules 
// without performing any validation.
// 
// --------------------------------------------------------------------------------------
internal class HttpModule : IHealthBlock
{
    public ResourceTypeEnum ResourceType 
    { 
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        string[] p;
        p = blockParams.GetValues("name");
        string paramName = p != null ? p[0] : null;
        p = blockParams.GetValues("type");
        string paramType = p != null ? p[0] : null;

        HttpModuleReport myReport = new HttpModuleReport(paramName, paramType);
        report.ExtendedReport = myReport;

        string name, type;
        ConfigurationElement cfgElem ;

        // We need Config info to navigate Microsoft.Web.Administration
        // Using the component name here because it works for all (catalog, authsg) cases that use this healhcheck
        // To be really correct there probably needs to be a way to enumerate the interfaces for a component 
        // and then we would have to pick (the first?) one of the interfaces for the check.
        IInterfaceInfo iInfo = Config.GetInterface( Config.ComponentName );

        // Get the application configuration
        ServerManager sm = new ServerManager();
        Configuration cfg = sm.GetWebConfiguration( iInfo.VSite, iInfo.VDir );
        ConfigurationSection cfgSect = cfg.GetSection( "system.webServer/modules" );
        ConfigurationElementCollection cfgElems = cfgSect.GetCollection();

        // Expecting something like:
        // Name: ActiveAuthModule
        // Type: xonline.server.activeauth.module.ActiveAuthModule, aamodule, Version=7.0.0.0, Culture=neutral, PublicKeyToken=1c793896f4718871

        for ( int i = 0; i < cfgElems.Count; i ++ )
        {
            cfgElem = cfgElems[i]; 
            Object obj = cfgElem.GetAttributeValue( "name" );
            name = obj.ToString();
            obj = cfgElem.GetAttributeValue( "type" );
            type = obj.ToString();
            myReport.AddModule( name, type );
        }

        if (!myReport.Validating || myReport.FoundMatch)
        {
            report.HealthStatus = HealthStatusEnum.Green;
        }
        else
        {
            report.HealthStatus = HealthStatusEnum.Red;
            report.ErrorDetails = "No matching HttpModule found";
        }


    }
}

public class HttpModuleReport : IExtendedHealthReport
{
    public class HttpModuleInfo 
    {
        [XmlAttribute]
        public string Name;
        [XmlAttribute]
        public string Type;

        public HttpModuleInfo(string n, string t)
        {
            Name = n;
            Type = t;
        }

        public HttpModuleInfo()
        {
            Name = null;
            Type = null;
        }
    }

    public bool     Validating;
    public string   ValidatingName;
    public string   ValidatingType;
    public bool     FoundMatch;
    public List<HttpModuleInfo> HttpModules;

    public HttpModuleReport(string paramName, string paramType)
    {
        ValidatingName = paramName;
        ValidatingType = paramType;
        Validating = paramName != null || paramType != null;
        FoundMatch = false;
        HttpModules = new List<HttpModuleInfo>();
    }

    public HttpModuleReport()
    {
    }

    public void AddModule(string moduleName, string moduleType)
    {
        HttpModules.Add(new HttpModuleInfo(moduleName, moduleType));
            
        if (!FoundMatch && Validating)
        {
            bool bFoundName = ValidatingName != null ? false : true; 
            bool bFoundType = ValidatingType != null ? false : true; 
            if (!bFoundName)
            {
                bFoundName = String.Compare(ValidatingName, moduleName, true) == 0;
            }
            if (!bFoundType)
            {
                bFoundType = moduleType.IndexOf(ValidatingType, StringComparison.OrdinalIgnoreCase) != -1;
            }
            FoundMatch = bFoundName && bFoundType;
        }

    }
}





}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_NpdbSettings.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// 
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//         fgao     3/10/2010 added reflection to find the all the settings. 
//

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection; 
using System.Xml.Serialization;
using Leet.Core;
using Leet.Core.Configuration;
using Leet.Core.IoCCo; 

namespace Leet.Health.Common
{

// --------------------------------------------------------------------------------------
// NpdbSettings - checks dependent NPDB settings. Returns their value. No validation.
//
// PARAMETERS:
//
// "prefix" : 1 or more setting prefix for this component. Example: "prefix=lest_Notification" will
// load all npdb settings matching "lest_Notification*".
//
// "setting" : 1 or more exact setting names to retrieve the value of. Example:
// "setting=lest_ProxyAddress,setting=lest_PpasPassportSiteId"
//
// --------------------------------------------------------------------------------------
internal class NpdbSettings : IHealthBlock
{
    public static string NpdbSettingsPrefix = null;

    public ResourceTypeEnum ResourceType
    {
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        // Set output param immediately
        NpdbSettingsReport myReport = new NpdbSettingsReport();
        report.ExtendedReport = myReport;
        IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>(); 

        // Parse params
        string[] npdbSettingPrefixes = blockParams.GetValues("prefix");
        string[] extraSettings = blockParams.GetValues("setting");

        // fill out the setting names. 
        string[] staticSettingNames = this.GetStaticSettingNames();
        string[] staticMultiSettingNames = this.GetStaticMultiSettingNames(); 

        // Fill out report
        myReport.Component = config.ComponentName;
        
        // TODO: expose these two properties in IConfigurationProvider. 
        //myReport.Server = config.Server;
        //myReport.Site = config.SiteId;

        // First do all settings found by searching for the setting prefix
        if (npdbSettingPrefixes != null)
        {
            FetchSettingsForNamesAndAddToReport(
                    FindStringsStartingWith(staticSettingNames, npdbSettingPrefixes),
                    FindIdenticalStrings(staticMultiSettingNames, npdbSettingPrefixes),
                    myReport,
                    config);
        }

        // Now do any other settings specified in the params
        if (extraSettings != null)
        {
            FetchSettingsForNamesAndAddToReport(
                    FindStringsStartingWith(staticSettingNames, extraSettings),
                    FindIdenticalStrings(staticMultiSettingNames, extraSettings),
                    myReport,
                    config);
        }

        // Wrap it up
        report.HealthStatus = HealthStatusEnum.Green;  // we always succeed
    }

    /// <summary>
    /// Get the static value names of all the settings in Leet.Core.Configuration.Settings
    /// </summary>
    /// <returns>An array of setting value names</returns>
    private string[] GetStaticSettingNames()
    {
        List<string> names = new List<string> (); 
        Type settingType = typeof(Leet.Core.Configuration.Settings);
        FieldInfo[] staticFields = settingType.GetFields(BindingFlags.Public | BindingFlags.Static); 
        foreach (FieldInfo fieldInfo in staticFields) 
        {
            string value = (string) fieldInfo.GetValue(null);
            names.Add(value); 
        }

        return names.ToArray(); 
    }

    /// <summary>
    /// Gets the static value names of all the settings in 
    /// Leet.Core.Configuration.MultiSettings
    /// </summary>
    /// <returns></returns>
    private string[] GetStaticMultiSettingNames()
    {
        List<string> names = new List<string>();
        Type settingType = typeof(Leet.Core.Configuration.MultiSettings);
        foreach (FieldInfo fieldInfo in settingType.GetFields(BindingFlags.Static))
        {
            string value = (string)fieldInfo.GetValue(null);
            names.Add(value);
        }

        return names.ToArray();
    }

    /// <summary>
    /// Finds all strings in the lookupArray, that startsWith any of the matchArray entries.
    /// </summary>
    /// <param name="lookupArray"></param>
    /// <param name="matchArray"></param>
    /// <returns></returns>
    private string[] FindStringsStartingWith(string[] lookupArray, string[] matchArray)
    {
        // Static settings
        return Array.FindAll(
                      lookupArray,
                      delegate(string s)
                      {
                          return Array.Exists(
                                  matchArray,
                                  delegate(string prefix)
                                  {
                                      return s.StartsWith(prefix, StringComparison.OrdinalIgnoreCase);
                                  });
                      });
    }

    /// <summary>
    /// Finds ALL lookupArray members that are identical to matchArray.
    /// </summary>
    /// <param name="lookupArray"></param>
    /// <param name="matchArray"></param>
    /// <returns></returns>
    private string[] FindIdenticalStrings(string [] lookupArray, string [] matchArray)
    {
        return Array.FindAll( 
                    lookupArray,
                    delegate(string s)
                    {
                        return Array.Exists(
                                   matchArray,
                                   delegate(string extraSetting) 
                                   { 
                                       return String.Compare(s, extraSetting, true) == 0; 
                                   });
                    });
    }

    /// <summary>
    /// For given settingNames we fetch the values from the config and add it to report
    /// </summary>
    /// <param name="settingNames"></param>
    /// <param name="myReport"></param>
    /// <param name="config"></param>
    private void AddSettingArrayToReport(string[] settingNames, NpdbSettingsReport myReport, IConfigurationProvider config)
    {
        foreach (string settingName in settingNames)
        {
            myReport.AddSetting(settingName, config.GetSetting(settingName), false);
        }
    }

    /// <summary>
    /// For given settingNames we fetch the MultiValues from the config and add it to report
    /// </summary>
    /// <param name="settingNames"></param>
    /// <param name="myReport"></param>
    /// <param name="config"></param>
    private void AddMultiSettingArrayToReport(string[] settingNames, NpdbSettingsReport myReport, IConfigurationProvider config)
    {
        foreach (string settingName in settingNames)
        {
            myReport.AddMultiSetting(settingName, config.GetMultiSetting(settingName));
        }
    }

    /// <summary>
    /// For given setting and multisetting name arrays, we add fetch config values and add it to report
    /// </summary>
    /// <param name="settingNames"></param>
    /// <param name="multiSettingNames"></param>
    /// <param name="myReport"></param>
    /// <param name="config"></param>
    private void FetchSettingsForNamesAndAddToReport(string [] settingNames, string [] multiSettingNames, NpdbSettingsReport myReport, IConfigurationProvider config)
    {
        if (settingNames != null)
        {
            AddSettingArrayToReport(settingNames, myReport, config);
        }
        
        if (multiSettingNames != null)
        {
            AddMultiSettingArrayToReport(multiSettingNames, myReport, config);
        }
    }
}

// --------------------------------------------------------------------------------------
// NpdbSettingsReport - health report
// --------------------------------------------------------------------------------------
public class NpdbSettingsReport : IExtendedHealthReport
{
    public string Component;
    public string Server;
    public int Site;

    public List<NameValuePair> DynamicSettings;
    public List<NameValuePair> StaticSettings;
    public List<NameValuePair> MultiSettings;

    public NpdbSettingsReport()
    {
        DynamicSettings = new List<NameValuePair>();
        StaticSettings = new List<NameValuePair>();
        MultiSettings = new List<NameValuePair>();
    }

    public void AddSetting(string n, string v, bool isDynamic)
    {
        NameValuePair info = new NameValuePair();
        info.Name = n;
        info.Value = v;

        if (isDynamic)
            DynamicSettings.Add(info);
        else
            StaticSettings.Add(info);
    }

    public void AddMultiSetting(string n, string[] vs)
    {
        foreach (string v in vs)
        {
            NameValuePair info = new NameValuePair();
            info.Name = n;
            info.Value = v;

            MultiSettings.Add(info);
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_PassportIdSapi.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//         fgao 04/2010 adopted for LIVEN. 
//

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Specialized;
using Leet.Core;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Health.Common
{
    // --------------------------------------------------------------------------------------
    // PassportIdSapi - initialize and check health of the Passport ID SAPI web services.
    //
    // PARAMETERS:
    //
    // "puid" : 1 or more puids that exist in the Passport INT environment to perform a member
    //          name lookup on verify.  Passport exposes a discovery service but just because
    //          that responds does not mean the actual services are healthy.
    //
    // "prodnetPuid" : 1 or more puids that exist in the Passport INT environment to perform
    //          a member name lookup on verify.  Passport exposes a discovery service but just
    //          because that responds does not mean the actual services are healthy.
    //
    // --------------------------------------------------------------------------------------
    internal class PassportIdSapi : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            PassportIdSapiReport myReport = new PassportIdSapiReport();
            report.ExtendedReport = myReport;
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

            myReport.PartnerUrl = config.GetSetting(Settings.PpsaCredentialUrl);
            myReport.SiteId = config.GetSetting(Settings.PpsaSiteId);
            myReport.SiteAddress = config.GetSetting(Settings.RPSSiteName);
            myReport.ClientCertSubject = config.GetSetting(Settings.PpsaCertThumbprint);

            string environment = config.Environment;

            string[] liveids = blockParams.GetValues(environment + "LiveId");
            string[] passwds = blockParams.GetValues(environment + "Password");

            if (liveids == null || liveids.Length == 0)
            {
                liveids = blockParams.GetValues("LiveId");
                passwds = blockParams.GetValues("password");

                if (liveids == null || liveids.Length == 0)
                {
                    // no checks were able to be performed
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    report.ErrorDetails = "No value specified for LiveId parameter.  Health status is unknown.";
                    return;
                }
            }

            // instantiate the PassportClientGlobal singleton and resolve the member names
            // for any puids in the parameter block
            try
            {
                throw new NotImplementedException("Passport verification not completed "); 
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = e.Message;
                return;
            }

            // if we made it this far, things are good to go
            // report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // PassportIdSapiReport - health report
    // --------------------------------------------------------------------------------------
    public class PassportIdSapiReport : IExtendedHealthReport
    {
        public string PartnerUrl;
        public string SiteId;
        public string SiteAddress;
        public string SitePolicy;
        public string SiteAddressMsn;
        public string SitePolicyMsn;
        public string ClientCertSubject;
        public string BillingProxy;
        public string DefaultProfileServiceUrl;
        public string DefaultCredentialServiceUrl;
        public string DefaultEncryptedProxiedAuthUrl;
        public string MemberName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_PlatformNpdbAccess.cs ===
//
// Block_PlatformNpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// 
//
// Common healthblock implementation.
//
// Author: a-gamavi 4/2010
//         
//

using System;
using System.IO;
using System.Text;
using System.Data;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;
using System.Configuration; 
using System.Xml.Serialization;
using System.Data.SqlClient;
using Leet.Core;
using Leet.Core.IO;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Microsoft.Win32;

namespace Leet.Health.Common
{

// --------------------------------------------------------------------------------------
// PlatformNpdbAccess - Verifies that Platform NPDB can be accessed
// Make sure to add this key to your Web.Config file to prevent it hard coded in C# code 
//  <appSettings>
//    <add key="npdb_setting" value="aamodule_Rps_site"/>
//  </appSettings>
//
// --------------------------------------------------------------------------------------
internal class PlatformNpdbAccess : IHealthBlock
{
    public ResourceTypeEnum ResourceType
    {
        get { return ResourceTypeEnum.Remote; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        const string CommonConfigRegistryKey = @"SOFTWARE\Microsoft\XboxLive\CommonConfig\";
        const string ConfigurationServer = "Server";
        const string ConfigurationDatabase = "Database";

        IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

        PlatformNpdbAccessReport myReport = new PlatformNpdbAccessReport();
        report.ExtendedReport = myReport;

        // Fill out component and extended message
        myReport.Component = config.ComponentName;

        string NPDBServer = String.Empty;   // NPDB server
        string NPDBDatabase = String.Empty; // platform NPDB database

        try
        {
            // retrieve the registry values for platform NPDB server and database
            IRegistryProvider registryProvider = Container.Instance.GetComponent<IRegistryProvider>();
            RegistryKey key = registryProvider.OpenSubKey(Registry.LocalMachine, CommonConfigRegistryKey);

            if (key != null)
            {
                // Get the server and database values at the CommonConfig level, for the Platform's NPDB
                NPDBServer = (string)registryProvider.GetValue(key, ConfigurationServer);
                if (String.IsNullOrEmpty(NPDBServer))
                {
                    throw new ApplicationException(String.Format("The value {0} in registry key {1} does not exist.", ConfigurationServer, CommonConfigRegistryKey));
                }

                NPDBDatabase = (string)registryProvider.GetValue(key, ConfigurationDatabase);
                if (String.IsNullOrEmpty(NPDBDatabase))
                {
                    throw new ApplicationException(String.Format("The value {0} in registry key {1} does not exist.", ConfigurationDatabase, CommonConfigRegistryKey));
                }
            }
            else
            {
                throw new ApplicationException(String.Format("The registry key {0} does not exist.",  CommonConfigRegistryKey));
            }


            // get the npdb_setting value from Web.config
            string npdb_setting = ConfigurationManager.AppSettings["npdb_setting"];
            if (String.IsNullOrEmpty(npdb_setting))
            {
                npdb_setting = "aamodule_Rps_site"; // if this is not specified in Web.config, set it
            }

            // try to fetch aamodule_Rps_site from t_settings which should always exist
            using (SqlConnection sqlConnection = new SqlConnection(GetSqlConnectionString(NPDBServer, NPDBDatabase)))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = sqlConnection;
                    sqlConnection.Open();
                    command.CommandText = "dbo.p_config_get_setting";
                    command.Parameters.Add("@vc_setting", SqlDbType.NVarChar).Value = npdb_setting;  
                    command.CommandType = CommandType.StoredProcedure;

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        if (reader == null || !reader.Read())
                        {
                            throw new ApplicationException(String.Format("Couldn't fetch {0} from settings table of platform NPDB database", npdb_setting));
                        }
                    }
                }
            }

            // If no exception is thrown, database can be accessed
            myReport.Message = "Verified the access to Platform NPDB database";
            report.HealthStatus = HealthStatusEnum.Green;  // no exceptions thrown
        }
        catch (Exception ex)
        {
            // Write the exception to the health report
            myReport.Message = ex.ToString();
            report.HealthStatus = HealthStatusEnum.Red;
        }
    }

    private string GetSqlConnectionString(string server, string database)
    {
        SqlConnectionStringBuilder connectionBuilder = new SqlConnectionStringBuilder()
        {
            DataSource = server,
            InitialCatalog = database,
            IntegratedSecurity = true,
            ConnectTimeout = 100
        };

        return connectionBuilder.ToString(); 
    }
}

// --------------------------------------------------------------------------------------
// PlatformNpdbAccessReport - health report
// --------------------------------------------------------------------------------------
public class PlatformNpdbAccessReport : IExtendedHealthReport
{
    /// <summary>
    /// The component name.
    /// </summary>
    public string Component { get; set; }

    /// <summary>
    /// The extended message. 
    /// </summary>
    public string Message { get; set; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\DtcStatus.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace xonline.common.health
{
    internal enum AUTHENTICATION_LEVEL : uint
    {
        NO_AUTHENTICATION_REQUIRED = 0,
        INCOMING_AUTHENTICATION_REQUIRED = 1,
        MUTUAL_AUTHENTICATION_REQUIRED = 2
    };

    internal sealed class DtcStatus
    {
        #region Native DTC interface declarations
        [ComImport()]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        [Guid("9797C15D-A428-4291-87B6-0995031A678D")]
        interface IDtcNetworkAccessConfig2
        {
            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetAnyNetworkAccess();

            void SetAnyNetworkAccess([MarshalAs(UnmanagedType.Bool)] bool bAnyNetworkAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkAdministrationAccess();

            void SetNetworkAdministrationAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkAdministrationAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkTransactionAccess();

            void SetNetworkTransactionAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkTransactionAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkClientAccess();

            void SetNetworkClientAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkClientAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkTIPAccess();

            void SetNetworkTIPAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkTIPAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetXAAccess();

            void SetXAAccess([MarshalAs(UnmanagedType.Bool)] bool bXAAccess);

            void RestartDtcService();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkInboundAccess();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkOutboundAccess();

            void SetNetworkInboundAccess([MarshalAs(UnmanagedType.Bool)] bool bInbound);

            void SetNetworkOutboundAccess([MarshalAs(UnmanagedType.Bool)] bool bOutbound);

            AUTHENTICATION_LEVEL GetAuthenticationLevel();

            void SetAuthenticationLevel(AUTHENTICATION_LEVEL AuthLevel);
        }

        static Guid IID_IDtcNetworkAccessConfig2 = typeof(IDtcNetworkAccessConfig2).GUID;

        [DllImport("xolehlp.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]
        static extern Int32 DtcGetTransactionManagerEx(
            string pszHost,
            string pszTmName,
            ref Guid riid,
            int grfOptions,
            IntPtr pvConfigParams,
            [MarshalAs(UnmanagedType.IUnknown)] out object ppvObject);

        #endregion

        IDtcNetworkAccessConfig2 pConfig = null;

        public DtcStatus()
            : this(null)
        {
        }

        public DtcStatus(string machineName)
        {
            object obj;
            int res = DtcGetTransactionManagerEx(machineName, null, ref IID_IDtcNetworkAccessConfig2, 0, IntPtr.Zero, out obj);
            if (res < 0)
                throw new COMException("Could not connect to Transaction Manager on " + (String.IsNullOrEmpty(machineName) ? "localhost" : machineName), res);
            pConfig = (IDtcNetworkAccessConfig2)obj;

            try
            {
                pConfig.GetAnyNetworkAccess();
            }
            catch (COMException)
            {
                Marshal.ReleaseComObject(pConfig);
                pConfig = null;
            }
        }

        public bool NetworkDtcEnabled
        {
            get { return pConfig != null ? pConfig.GetAnyNetworkAccess() : false; }
        }

        public bool RemoteTxnAdminEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkAdministrationAccess() : false; }
        }

        public bool RemoteTxnClientsEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkClientAccess() : false; }
        }

        public bool NetworkTransactionsEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkTransactionAccess() : false; }
        }

        public bool TIPEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkTIPAccess() : false; }
        }

        public bool XAEnabled
        {
            get { return pConfig != null ? pConfig.GetXAAccess() : false; }
        }

        public bool NetworkInboundAccessEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkInboundAccess() : false; }
        }

        public bool NetworkOutboundAccessEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkOutboundAccess() : false; }
        }

        public AUTHENTICATION_LEVEL AuthenticationLevel
        {
            get { return pConfig != null ? pConfig.GetAuthenticationLevel() : AUTHENTICATION_LEVEL.MUTUAL_AUTHENTICATION_REQUIRED; }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_XBancInfo.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for XbancInfo
    /// </summary>
    public class XBancInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                string[] servers = Config.GetServerListByInterface(Interface.xbanc);

                XBanc xb = new XBanc();
                uint[] hrs = xb.Health();

                if (servers.Length != hrs.Length)
                {
                    throw new ApplicationException("XBancInfoHealthBlock: config server list does not match Xbanc server list!");
                }

                uint cFailed = 0;
               
                for (uint iServer = 0; iServer < hrs.Length; iServer++)
                {
                    if (HResult.Failed(hrs[iServer]))
                    {
                        cFailed++;
                        report.ErrorDetails += "\r\nServer " + servers[iServer] + " returned hr = " + ((HResult) hrs[iServer]);
                    }
                }

                report.HealthStatus = (cFailed >= hrs.Length) ? HealthStatusEnum.Red : (cFailed > 0) ? HealthStatusEnum.Yellow : HealthStatusEnum.Green;
            }
            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthBlock.cs ===
// 
// IHealthBlock.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Collection of interfaces needed to implement a healthblock, the fundamental unit of 
// work for a healthcheck.
// 
// Author: kgoodier 3/2008
//         fgao     3/2010 modified for LIVEN
//
namespace Leet.Health.Common
{
    using System;
    using System.Collections.Specialized;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Serialization;
    using System.Runtime.InteropServices;


    // --------------------------------------------------------------------------------------
    // HealthStatusEnum - the stoplight analogy makes sense, no?
    //
    // Green - all good!
    //
    // Yellow - questionable. This will get someone's attention but otherwise cause no action.
    //
    // Red - failed. Server may be taken out of the VIP depending on resource type.
    // --------------------------------------------------------------------------------------

    [ComVisible(true)]
    public enum HealthStatusEnum
    {
        Green,
        Yellow,
        Red
    }

    // --------------------------------------------------------------------------------------
    // ResourceTypeEnum - what kind of resource is your healthblock checking?
    //
    // Local - if the resource is only on the current machine. If this fails, the server may 
    // be taken out of the VIP.
    //
    // Remote - if the resource is shared across servers, like UODB or Passport. If this 
    // fails, we don't want to take the server out of the VIP or else no servers will be left.
    // --------------------------------------------------------------------------------------

    [ComVisible(true)]
    public enum ResourceTypeEnum
    {
        Unknown,  // really try not to use this, k?
        Local,
        Remote
    }


    // --------------------------------------------------------------------------------------
    // IHealthBlock
    //
    // Implement this to build an atomic unit health checkiness.
    //
    // ResourceType - see ResourceTypeEnum comments.
    //
    // blockManager - provided as a way to communicate with the execution engine. If your 
    // healthblock needs to dynamically schedule new healthblocks to run, there is a method 
    // here to do that.
    //
    // blockParams - arbitrary key/value pairs of input parameters. May commonly be used for 
    // only keys with no value, or even keys with multiple values. 
    //
    // *** PLEASE DOCUMENT THE PARAMETERS FOR EVERY IHEALTHBLOCK IMPLEMENTATION. ***
    //
    // report - you MUST set the fields in this appropriately:
    // 1. HealthStatus    - (required) Green, Yellow, or Red
    // 3. ErrorDetails    - (optional) string with additional error info
    // 4. ExtendedReport  - (optional) custom class that implements IExtendedHealthReport with 
    // xml serializable fields.
    //
    // --------------------------------------------------------------------------------------

    public interface IHealthBlock
    {
        ResourceTypeEnum ResourceType { get; }

        void DoCheck(
            HealthBlockManager blockManager,
            NameValueCollection blockParams,
            HealthReport report);

    }


    // --------------------------------------------------------------------------------------
    // IExtendedHealthReport
    // 
    // Implement this to provide consistent, but detailed, results of running the healthcheck 
    // for your block. Please provide useful public fields here - they will be converted to 
    // XML. Private and protected fields will not be serialized.
    //
    // *** IMPORTANT NOTES ***
    //
    // Your class must be public, and any serializable fields must be public. Private & 
    // protected members won't be serialized.
    //
    // Some types can't be xml serialized.  Basic types, arrays, List<>, and even custom 
    // objects are ok. But Dictionary<> is NOT ok, though, among others. See  
    // SerializableDictionary<> in HealthUtils.cs for a solution. MAKE SURE YOU TEST YOUR 
    // HEALTHBLOCK!
    // --------------------------------------------------------------------------------------

    public interface IExtendedHealthReport
    {
        // ummm, yeah, nothing here. still good to use one in case it changes in the future.

        // put whatever other fields you want here

    }


    // --------------------------------------------------------------------------------------
    // HealthReport 
    //
    // Helper that implements only the basic fields. Used internally and by very simple 
    // blocks.
    // --------------------------------------------------------------------------------------

    public class HealthReport : IXmlSerializable
    {

        // ----------------------------------------------------------------------------------
        // HealthStatus - Green if all good, Yellow if questionably good (cache is still 
        // loading, but service is usable, for instance), and Red if bad.
        // ----------------------------------------------------------------------------------
        public HealthStatusEnum HealthStatus
        {
            get { return _HealthStatus; }
            set { _HealthStatus = value; }
        }

        // ----------------------------------------------------------------------------------
        // ErrorDetails - optional, please fill in whatever details are relevant if an error 
        // occurs.
        // ----------------------------------------------------------------------------------
        public string ErrorDetails
        {
            get { return _ErrorDetails; }
            set { _ErrorDetails = value; }
        }

        // ----------------------------------------------------------------------------------
        // ExtendedReport - optional, please set with a custom class full of yummy public 
        // fields that will be xml serialized and provided in the overall health report.
        // ----------------------------------------------------------------------------------
        public IExtendedHealthReport ExtendedReport
        {
            get { return _ExtendedReport; }
            set { _ExtendedReport = value; }
        }



        // ----------------------------------------------------------------------------------
        // Everything else...
        // ----------------------------------------------------------------------------------

        // needed for XmlSerializer, don't use
        public HealthReport()
        {
        }

        // "real" constructor
        public HealthReport(
            string friendlyName,
            string fullName,
            ResourceTypeEnum resourceType,
            bool critical)
        {
            _HealthStatus = HealthStatusEnum.Red;
            _ErrorDetails = null;
            _ExtendedReport = null;

            _FriendlyName = friendlyName;
            _FullName = fullName;
            _ResourceType = resourceType;
            _Critical = critical;

            Start();
            Stop();
        }

        // ----------------------------------------------------------------------------------
        // Fail - helper for failing a check and reporting info
        // ----------------------------------------------------------------------------------
        public void Fail(string errorDetails)
        {
            _HealthStatus = HealthStatusEnum.Red;
            _ErrorDetails = errorDetails;
        }

        // ----------------------------------------------------------------------------------
        // DowngradeStatus - sets healthreport status to input value, but only if new status 
        // is worse than previous status. Static helper method.
        // ----------------------------------------------------------------------------------
        public static HealthStatusEnum DowngradeStatus(HealthStatusEnum baseHealthStatus, HealthStatusEnum newHealthStatus)
        {
            if ((baseHealthStatus == HealthStatusEnum.Green) ||
                (newHealthStatus == HealthStatusEnum.Red))
            {
                // Green to Yellow
                //   or
                // Green or Yellow to Red
                return newHealthStatus;
            }
            else
            {
                return baseHealthStatus;
            }
        }

        // ----------------------------------------------------------------------------------
        // DowngradeStatus - sets healthreport status to input value, but only if new status 
        // is worse than previous status.
        // ----------------------------------------------------------------------------------
        public void DowngradeStatus(HealthStatusEnum s)
        {
            this.HealthStatus = DowngradeStatus(this.HealthStatus, s);
        }

        // ----------------------------------------------------------------------------------
        // FriendlyName - should be the name of the healthblock this report corresponds to.
        // ----------------------------------------------------------------------------------
        public string FriendlyName
        {
            get { return _FriendlyName; }
        }

        // ----------------------------------------------------------------------------------
        // FullName - should be the full class name of the healthblock.
        // ----------------------------------------------------------------------------------
        public string FullName
        {
            get { return _FullName; }
        }

        // ----------------------------------------------------------------------------------
        // ResourceType - what kind of resource did this healthblock check?
        // ----------------------------------------------------------------------------------
        public ResourceTypeEnum ResourceType
        {
            get { return _ResourceType; }
            set { _ResourceType = value; }
        }

        // ----------------------------------------------------------------------------------
        // Critical - does the component have a critical dependency on this healthblock, or is 
        // it more informational?  If it returns RED but is not critical, the status will be 
        // rolled up as YELLOW.
        // ----------------------------------------------------------------------------------
        public bool Critical
        {
            get { return _Critical; }
        }

        // ----------------------------------------------------------------------------------
        // Xml Serialization infrastructure
        // ----------------------------------------------------------------------------------

        public void WriteXml(XmlWriter w)
        {
            w.WriteAttributeString("Name", FriendlyName);
            w.WriteAttributeString("HealthStatus", HealthStatus.ToString());

            w.WriteElementString("FullName", FullName);
            w.WriteElementString("ResourceType", ResourceType.ToString());
            w.WriteElementString("Critical", Critical.ToString());
            w.WriteElementString("ElapsedTime", ElapsedTime.ToString());

            if (ErrorDetails != null)
            {
                w.WriteElementString("ErrorDetails", ErrorDetails);
            }

            if (ExtendedReport != null)
            {
                try
                {
                    // no more "xmlns:xsi" and "xmlns:xsd" attributes
                    XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
                    xsn.Add(String.Empty, String.Empty);
                    XmlSerializer serializer = new XmlSerializer(ExtendedReport.GetType());

                    serializer.Serialize(w, ExtendedReport, xsn);
                }
                catch (Exception e)
                {
                    // Seriously, why won't .net give me the REAL exception text instead of a 
                    // "can't serialize to XML" generic text?
                    w.WriteElementString("Error", e.ToString());
                }

            }

        }

        public void ReadXml(XmlReader reader)
        {
            // we don't support deserialization
        }

        public XmlSchema GetSchema()
        {
            return null;
        }

        // ----------------------------------------------------------------------------------
        // ElapsedTime - how long the health block took to execute. Limited to system timer 
        // granularity, about 15 milliseconds.
        // ----------------------------------------------------------------------------------
        internal TimeSpan ElapsedTime
        {
            get { return _StopTime - _StartTime; }
        }

        internal void Start() { _StartTime = DateTime.UtcNow; }
        internal void Stop() { _StopTime = DateTime.UtcNow; }

        // ----------------------------------------------------------------------------------
        // Private members
        // ----------------------------------------------------------------------------------

        private HealthStatusEnum _HealthStatus;
        private string _ErrorDetails;
        private IExtendedHealthReport _ExtendedReport;

        private string _FriendlyName;
        private string _FullName;
        private ResourceTypeEnum _ResourceType;
        private bool _Critical;
        private DateTime _StartTime;
        private DateTime _StopTime;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_XCacheInfo.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for XCacheInfo
    /// </summary>
    public class XCacheInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                XCacheUserResponseData xcurd = XCache.LookupUserByXUID(0);

                if (xcurd.szGamertag != XCache.InvalidGamertag)
                {
                    throw new ApplicationException("XCacheInfoHealthBlock: got a valid gamertag for userid 0: " + xcurd.szGamertag);
                }

                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthBlockConfigurationSection.cs ===
﻿//-----------------------------------------------------------------------------
// <copyright file="HealthBlockConfigurationSection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//     This file contains the class for retrieving custom-defined config settings in
//     ProviderConfiguration section
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="03/10/2009">
//     Class Created
// </history>
//-----------------------------------------------------------------------------
namespace Leet.Health.Common
{
    using System;
    using System.Collections;
    using System.Collections.Generic; 
    using System.Configuration;
    using System.Xml;
    using Leet.Core;
    using Leet.Core.Utils;
    using Leet.Utils;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// Custom Handler to access the custom-defined Configuration Section.
    /// </summary>
    public class HealthBlockConfigSectionHandler : IConfigurationSectionHandler
    {
        /// <summary>
        /// Creates a custom-defined object that contains the custom-defined settings.
        /// </summary>
        /// <param name="parent">Parent object in web.config.</param>
        /// <param name="configContext">Configuration context object.</param>
        /// <param name="section">Specified Section XML node.</param>
        /// <returns>The object created by the handler.</returns>
        object IConfigurationSectionHandler.Create(
          object parent, object configContext, XmlNode section)
        {
            // Creates the configuration object that this method will return.
            List <HealthBlockDescription> descriptionList = new List <HealthBlockDescription>();

            foreach (XmlNode child in section.SelectNodes("add"))
            {
                if (XmlNodeType.Element == child.NodeType)
                {
                    try
                    {
                        HealthBlockDescription blockDescription = new HealthBlockDescription();
                        blockDescription.Name = child.Attributes["Name"].Value;
                        blockDescription.ClassName = child.Attributes["ClassName"].Value;
                        blockDescription.Params = child.Attributes["Params"].Value;
                        blockDescription.Critical = bool.Parse(child.Attributes["Critical"].Value);
                        descriptionList.Add(blockDescription);
                    }
                    catch(Exception ex)
                    {
                        Logging.TraceException(ex, 
                            "HealthBlockConfiguration: exception happend in parsing {0}",
                            child.ToString()); 
                    }

                }
            }

            return descriptionList; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthBlockDescription.cs ===
// 
// HealthBlockDescription.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// this class defines the necessary description schema of the healthblock information. 
// the information can be retreived from database or web.config. .
// 
//         fgao     3/10/2010
//
namespace Leet.Health.Common
{
    using System;
    using System.Collections.Specialized;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Serialization;
    using System.Runtime.InteropServices;

    /// <summary>
    /// A class used to describe the properties of a health block. 
    /// </summary>
    public class HealthBlockDescription
    {
        /// <summary>
        /// Gets or sets the name of the health block. 
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the name of the class that implements the healthblock. 
        /// </summary>
        public string ClassName{get; set; }

        /// <summary>
        /// Gets or sets the parameters used to initialize the healthblock class. 
        /// </summary>
        public string Params { get; set; }

        /// <summary>
        /// Gets or sets value indicates whether this healthblock is critical. 
        /// </summary>
        public bool Critical { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_QueueEnabled.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using System.Collections.Specialized;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;

namespace Leet.Health.Common
{
    public class Block_QueueEnabled : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager blockManager,
            NameValueCollection blockParams,
            HealthReport report)
        {

            DatabaseAccessReport extendedAccessReport = new DatabaseAccessReport();
            report.ExtendedReport = extendedAccessReport;

            string sqlConnectionString = String.Empty;
            string databaseInterface = blockParams["InterfaceName"];

            if (String.IsNullOrEmpty(databaseInterface))
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails += "Database interface name is not specified";
                return;
            }

            try
            {
                sqlConnectionString = IoC.Get<IConfigurationProvider>().GetConnectionString(databaseInterface);
            }
            catch (Exception ex)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails += ex.ToString();
                return;
            }

            if (String.IsNullOrEmpty(sqlConnectionString))
            {
                report.HealthStatus = HealthStatusEnum.Red;
                extendedAccessReport.Message = "Cannot obtain connection string for interface " + databaseInterface;
                return;
            }


            using (SqlConnection connection = new SqlConnection(sqlConnectionString))
            {
                const int QUEUE_NAME_FIELD = 0;
                const int IS_RECEIVE_ENABLED_FIELD = 1;

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = connection;
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = "SELECT name, is_receive_enabled FROM sys.service_queues";

                connection.Open();

                try
                {
                    SqlDataReader reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        if (reader.GetBoolean(IS_RECEIVE_ENABLED_FIELD) == false)
                        {
                            extendedAccessReport.DisabledQueues.Add(reader.GetString(QUEUE_NAME_FIELD));  // A queue is disabled
                        }
                        else
                        {
                            extendedAccessReport.EnabledQueues.Add(reader.GetString(QUEUE_NAME_FIELD));
                        }
                    }
                }
                catch (SqlException sqlEx)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    extendedAccessReport.Message = sqlEx.ToString();
                }
                catch (Exception ex)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    extendedAccessReport.Message = ex.ToString();
                }
            }


            if (extendedAccessReport.DisabledQueues.Count > 0)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                extendedAccessReport.Message = "DANGER!  At least one queue is currently disabled.";
            }
            else
            {
                report.HealthStatus = HealthStatusEnum.Green;
                extendedAccessReport.Message = "All queues are enabled.";
            }

        }

        /// <summary>
        /// Extended health report details
        /// </summary>
        public class DatabaseAccessReport : IExtendedHealthReport
        {
            public String Message;
            public List<String> EnabledQueues;
            public List<String> DisabledQueues;

            public DatabaseAccessReport()
            {
                EnabledQueues = new List<string>();
                DisabledQueues = new List<string>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\Block_XblmFASTAccess.cs ===
﻿using System;
using System.Web;
using System.Net;
using Leet.Core.Configuration;
using Leet.Core.IoCCo; 

namespace Leet.Health.Common
{
    /// <summary>
    /// Check the health of Marketplace FAST APIs
    /// </summary>
    public class XblmFASTAPIAccess : IHealthBlock
    {
        private static IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

        #region IHealthBlock Members

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager, System.Collections.Specialized.NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                report.HealthStatus = HealthStatusEnum.Red;

                //query marketplace FAST API for mobile pdlc and tier gold. All we care is if the response is 200.
                String query =
                    String.Format(System.Globalization.CultureInfo.CurrentUICulture, 
                    "{0}/{1}/en-Us?producttypes=59&tiers=2&stores=5&pagesize=1", XblmUrl.ToString(), XblmVersionProductPath);

                HttpWebRequest consumablesRequest = (HttpWebRequest)HttpWebRequest.Create(new Uri(query));
                consumablesRequest.Method = "GET";
                consumablesRequest.Headers.Add("Pragma", "no-cache"); //to instruct downstream nodes to not return cached data
                HttpWebResponse webResponse = consumablesRequest.GetResponse() as HttpWebResponse;
                if(webResponse.StatusCode == HttpStatusCode.OK)
                {
                    report.HealthStatus = HealthStatusEnum.Green;
                }
            }
            catch (Exception ex)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = ex.ToString();
            }

        }

        #endregion

        private static Uri XblmUrl
        {
            get 
            {
                return new Uri(configProvider.GetSetting(Settings.Pdlc_InternalXblMarketplaceCatalogUrl));
            }
        }

        private static String XblmVersionProductPath
        {
            get { return configProvider.GetSetting(Settings.Pdlc_XblmVersionProductPath); } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthEngineThread.cs ===
using System;
using System.Threading;
using System.Runtime.InteropServices;
using System.Runtime.ConstrainedExecution;
using System.Security.Permissions;
using System.Globalization;

namespace Leet.Health.Common 
{
   [ComVisible(false)]
   public sealed class EngineThread {
      public EngineThread(ParameterizedThreadStart start) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ParameterizedThreadStart(delegate(object obj) { ThreadWrapper(start, obj); })
         );
      }

      public EngineThread(ThreadStart start) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ThreadStart(delegate { ThreadWrapper(start); })
         );
      }
      
      public EngineThread(ParameterizedThreadStart start, int maxStackSize) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ParameterizedThreadStart(delegate(object obj) { ThreadWrapper(start, obj); }), 
            maxStackSize);
      }

      public EngineThread(ThreadStart start, int maxStackSize) {
         if (null == start)
            throw new ArgumentNullException("start");

         innerThread = new Thread(
            new ThreadStart(delegate { ThreadWrapper(start); }), 
            maxStackSize);
      }

      #region Arbitrated Thread Instance Members
      public void Abort() {
         InnerThread.Abort();
      }

      public void Abort(object stateInfo) {
         InnerThread.Abort(stateInfo);
      }

      public ApartmentState GetApartmentState() {
         return InnerThread.GetApartmentState();
      }

      [ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
      public CompressedStack GetCompressedStack() {
         return InnerThread.GetCompressedStack();
      }

      public void Interrupt() {
         InnerThread.Interrupt();
      }

      public void Join() {
         InnerThread.Join();
      }

      public bool Join(int millisecondsTimeout) {
         return InnerThread.Join(millisecondsTimeout);
      }

      public bool Join(TimeSpan timeout) {
         return InnerThread.Join(timeout);
      }

      [ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)]
      public void Resume() {
         InnerThread.Resume();
      }

      public void SetApartmentState(ApartmentState state) {
         InnerThread.SetApartmentState(state);
      }

      [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
      public void SetCompressedStack(CompressedStack stack) {
         InnerThread.SetCompressedStack(stack);
      }

      public void Start() {
         InnerThread.Start();
      }

      public void Start(Object parameter) {
         InnerThread.Start(parameter);
      }

      [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)]
      public void Suspend() {
         InnerThread.Suspend();
      }

      public bool TrySetApartmentState(ApartmentState state) {
         return InnerThread.TrySetApartmentState(state);
      }

      [ObsoleteAttribute("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)]
      public ApartmentState ApartmentState {
         get { return InnerThread.ApartmentState; }
         set { InnerThread.ApartmentState = value; }
      }

      public CultureInfo CurrentCulture {
         get { return InnerThread.CurrentCulture; }
         set { InnerThread.CurrentCulture = value; }
      }

      public CultureInfo CurrentUICulture {
         get { return InnerThread.CurrentUICulture; }
         set { InnerThread.CurrentUICulture = value; }
      }

      public ExecutionContext ExecutionContext {
         get { return InnerThread.ExecutionContext; }
      }

      public bool IsAlive {
         get { return InnerThread.IsAlive; }
      }

      public bool IsBackground {
         get { return InnerThread.IsBackground; }
         set { InnerThread.IsBackground = value; }
      }

      public bool IsThreadPoolThread {
         get { return InnerThread.IsThreadPoolThread; }
      }

      public int ManagedThreadId {
         get { return InnerThread.ManagedThreadId; }
      }

      public string Name {
         get { return InnerThread.Name; }
         set { InnerThread.Name = value; }
      }

      public ThreadPriority Priority {
         get { return InnerThread.Priority; }
         set { InnerThread.Priority = value; }
      }

      public ThreadState ThreadState {
         get { return InnerThread.ThreadState; }
      }
      #endregion

      #region Private Wrapper Members
      private void HandleException(Exception e) {
         try {
          //Xom.NtEvent(
          //     XEvent.Id.UNHANDLED_THREAD_EXCEPTION,
          //     "EngineThread - unhandled exception\n\n" +
          //     e.ToString());
         }
         catch (Exception) { /* crap */ }
      }

      private void ThreadWrapper(ThreadStart start) {
         try {
            start();
         }
         catch (ThreadAbortException) { throw; }
         catch (Exception e) {
            HandleException(threadException = e);
         }
      }

      private void ThreadWrapper(ParameterizedThreadStart start, object obj) {
         try {
            start(obj);
         }
         catch (ThreadAbortException) { throw; }
         catch (Exception e) {
            HandleException(threadException = e);
         }
      }
      #endregion

      public Thread InnerThread {
         get { return innerThread; }
      }

      public Exception ThreadException {
         get { return threadException; }
         set { threadException = value; }
      }

      private Thread innerThread;
      private Exception threadException;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\NameValuePair.cs ===
//
// NameValuePair.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Simple Class for exporting data suitable for a webpage
//

using System.Xml.Serialization;

namespace Leet.Health.Common
{

    // --------------------------------------------------------------------------------------
    // Name Value Pair
    // --------------------------------------------------------------------------------------
    public class NameValuePair
    {
        [XmlAttribute]
        public string Name;

        [XmlAttribute]
        public string Value;

        public NameValuePair()
        {
        }

        public NameValuePair(string n, string v)
        {
            Name = n;
            Value = v;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthBlockManager.cs ===
// 
// HealthBlockManager.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides common healthcheck implementation and utilities.
// 
// Author: kgoodier 3/2008
//         fgao     3/2010 modified for LIVEN removed dependency on platform NPDB
//                         modified to allow user to provide customer healthblocks not implemented in 
//                         calling assembly (HealthCheckCommon)
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using Leet.Core;
using Leet.Core.Utils;
using Leet.Utils;
using Leet.Core.Diagnostics;

namespace Leet.Health.Common
{

    // --------------------------------------------------------------------------------------
    // HealthBlockManager
    //
    // Helps in running healthblocks and returning reports.
    // --------------------------------------------------------------------------------------
    public class HealthBlockManager
    {
        static internal void StaticInit(Assembly callingAssembly)
        {
            HealthBlockCache.Init(callingAssembly);
        }

        internal HealthBlockManager()
        {
            _DynamicBlocksToRun = new List<RunnableHealthBlock>();
        }

        // ----------------------------------------------------------------------------------
        // AddBlockToRun - adds a new healthblock to the execution list. They will be run in 
        // breadth-first order.
        // ----------------------------------------------------------------------------------
        public void AddBlockToRun(
            string blockFriendlyName,
            string blockFullName,
            string blockParams,
            bool critical)
        {
            RunnableHealthBlock block = new RunnableHealthBlock(
                blockFriendlyName,
                blockFullName,
                blockParams,
                critical);
            _DynamicBlocksToRun.Add(block);
        }


        // Internal members below here


        // ----------------------------------------------------------------------------------
        // RunHealthBlock - executes the given healthblock. Will not throw an exception!
        // ----------------------------------------------------------------------------------
        internal HealthReport RunHealthBlock(
            RunnableHealthBlock rhb)
        {
            IHealthBlock block = null;
            HealthReport report = null;

            report = new HealthReport(rhb.Name, rhb.FullName, ResourceTypeEnum.Unknown, rhb.Critical);

            block = HealthBlockCache.GetHealthBlock(rhb.FullName);
            if (block == null)
            {
                // Not found.. Bad name?
                report.Fail(String.Format(
                    "No block found matching name \"{0}\", class \"{1}\"",
                    rhb.Name, rhb.FullName));
                return report;
            }

            // Set found resource type
            report.ResourceType = block.ResourceType;

            // Run it
            try
            {
                report.Start();
                block.DoCheck(this, rhb.Params, report);
            }
            catch (Exception e)
            {
                report.ErrorDetails = e.ToString();
                // Force a warning if the block "forgot" and returned Green
                if (report.HealthStatus == HealthStatusEnum.Green)
                {
                    report.HealthStatus = HealthStatusEnum.Yellow;
                }
            }
            finally
            {
                report.Stop();
            }
            return report;
        }

        // ----------------------------------------------------------------------------------
        // GetStaticBlocksToRun - returns a list of healthblocks to run from the database.
        // ----------------------------------------------------------------------------------
        internal List<RunnableHealthBlock> GetStaticBlocksToRun()
        {
            return HealthBlockCache.GetBlocksToRun();
        }

        // ----------------------------------------------------------------------------------
        // GetDynamicBlocksToRun - returns a list of healthblocks to run that were added 
        // dynamically by other healthblocks.
        // ----------------------------------------------------------------------------------
        internal List<RunnableHealthBlock> GetDynamicBlocksToRun()
        {
            List<RunnableHealthBlock> blocks = _DynamicBlocksToRun;
            _DynamicBlocksToRun = new List<RunnableHealthBlock>();
            return blocks;
        }

        private List<RunnableHealthBlock> _DynamicBlocksToRun;

    }



    // --------------------------------------------------------------------------------------
    // HealthBlockCache
    //
    // Handles finding and instantiating all healthblocks in this assembly and the calling 
    // assembly.  
    // --------------------------------------------------------------------------------------
    static internal class HealthBlockCache
    {
        static HealthBlockCache()
        {
            _HealthBlocksByFullName = new Dictionary<string, IHealthBlock>();
        }

        // ----------------------------------------------------------------------------------
        // Init - loads the caches. Expected to be called once.
        // ----------------------------------------------------------------------------------
        static internal void Init(Assembly callingAssembly)
        {
            // Reflect
            LoadHealthblocksFromAssembly(Assembly.GetExecutingAssembly());
            if (callingAssembly != null)
            {
                LoadHealthblocksFromAssembly(callingAssembly);
            }

            // load the healthblocks from the configuration file. 
            _HealthBlocksFromConfig = GetBlocksToRunFromConfig();
        }

        // ----------------------------------------------------------------------------------
        // RegisterHealthBlock - lets you manually add a new healthblock that is available for 
        // running. This should only be used by the native healthblocks, really, since all 
        // others are expected to be discovered via reflection.
        // ----------------------------------------------------------------------------------
        static internal void RegisterHealthBlock(IHealthBlock block, string fullName)
        {
            _HealthBlocksByFullName[fullName] = block;
        }

        // ----------------------------------------------------------------------------------
        // GetHealthBlock - returns a reference to the health block found in either our 
        // assembly or the calling assembly. This is what we execute. Returns NULL if the name 
        // was not found.
        // ----------------------------------------------------------------------------------
        static internal IHealthBlock GetHealthBlock(string blockFullName)
        {
            IHealthBlock block;
            if (!_HealthBlocksByFullName.TryGetValue(blockFullName, out block))
            {
                return null;
            }
            return block;
        }

        // ----------------------------------------------------------------------------------
        // GetBlocksToRun - returns the current cached list of healthblocks to run from the 
        // npdb..t_health_mappings table.
        // ----------------------------------------------------------------------------------
        static internal List<RunnableHealthBlock> GetBlocksToRun()
        {
            return _HealthBlocksFromConfig;
        }

        // ----------------------------------------------------------------------------------
        // GetBlocksToRunFromConfig - Read the configuration 
        // ----------------------------------------------------------------------------------
        static private List<RunnableHealthBlock> GetBlocksToRunFromConfig()
        {

            List<RunnableHealthBlock> returnList = new List<RunnableHealthBlock>();

            List<HealthBlockDescription> blockDescritpion =
                (List <HealthBlockDescription >) System.Configuration.ConfigurationManager.GetSection("HealthBlockDescription");

            foreach (HealthBlockDescription description in blockDescritpion)
            {
                RunnableHealthBlock rhb = new RunnableHealthBlock(
                    description.Name,
                    description.ClassName,
                    description.Params,
                    description.Critical); 

                // try to create an instance to the cache, GetBlocksToRunFromConfig is done after finding
                // all runnables from the calling assembly. 
                if (GetHealthBlock(rhb.FullName) == null)
                {
                    // this healthblock is not in the cache, create one
                    try
                    {
                        Type type = Type.GetType(rhb.FullName);
                        IHealthBlock block = Activator.CreateInstance(type) as IHealthBlock;
                        _HealthBlocksByFullName[rhb.FullName] = block;
                    }
                    catch (Exception ex)
                    {
                        Logging.TraceException(ex,
                            "HealBlockManager: failed to create instance {0}",
                            rhb.FullName);

                        // don't add this to the runnable list. 
                        continue; 
                    }
                }

                returnList.Add(rhb);
            }

            return returnList;
        }


        // ----------------------------------------------------------------------------------
        // LoadHealthblocksFromAssembly - reflect through assembly finding classes that 
        // implement IHealthBlock.
        // ----------------------------------------------------------------------------------
        static private void LoadHealthblocksFromAssembly(Assembly asm)
        {
            Type[] types = asm.GetTypes();
            foreach (Type t in types)
            {
                if (t.IsClass &&
                    !t.IsAbstract &&
                    t.GetInterface("IHealthBlock") != null)
                {
                    ConstructorInfo ci = t.GetConstructor(Type.EmptyTypes);
                    if (ci == null)
                    {
                        //Xom.NtEvent(XEvent.Id.HEALTH_INITIALIZE_BLOCK_FAILED, String.Format(
                        //          "Unable to find default constructor for type {0}",
                        //          t.FullName));
                        Logging.TraceError("HealthBlockManager: Unable to find default constructor for type {0}",
                                            t.FullName);

                        continue;
                    }

                    object o = null;
                    try
                    {
                        o = ci.Invoke(Type.EmptyTypes);
                    }
                    catch (Exception e)
                    {
                        //Xom.NtEvent(XEvent.Id.HEALTH_INITIALIZE_BLOCK_FAILED, String.Format(
                        //          "HealthBlock constructor {0}() has thrown an exception: {1}",
                        //          t.FullName, e.ToString()));
                        Logging.TraceException(e, 
                            "HealthBlockManager: HealthBlock constructor {0}",
                                  t.FullName);

                        continue;
                    }

                    // FullName or Name?  If Name, collisions?
                    _HealthBlocksByFullName[t.FullName] = (IHealthBlock)o;
                }
            }
        }

        static internal void GetHelpXml(XmlWriter w)
        {
            // Get local pointers since the global ones can get swapped out from underneath 
            // us.
            Dictionary<string, IHealthBlock> blocksByFullName = _HealthBlocksByFullName;
            List<RunnableHealthBlock> blocks = _HealthBlocksFromConfig;

            w.WriteStartElement("HealthBlocks");

            w.WriteStartElement("HealthBlocksAvailable");
            foreach (KeyValuePair<string, IHealthBlock> kvp in blocksByFullName)
            {
                w.WriteElementString("HealthBlock", kvp.Key);
            }
            w.WriteEndElement();  // HealthBlocksAvailable


            w.WriteStartElement("HealthBlocksToRun");
            foreach (RunnableHealthBlock rhb in blocks)
            {
                w.WriteElementString("HealthBlock", rhb.FullName);
            }
            w.WriteEndElement();  // HealthBlocksToRun 

            w.WriteEndElement();  // HealthBlocks
        }



        // From reflection, this originally contains all the allowed healthblocks
        // FGAO changed it to become a real cache (doesn't expire). 
        static private Dictionary<string, IHealthBlock> _HealthBlocksByFullName;

        // From the configuration. Currently it is from web.config. It is possible to 
        // get this from NPDB. if the name contains class name, it will override whatever in HealthCheckCommon
        static private volatile List<RunnableHealthBlock> _HealthBlocksFromConfig;
        // static private string _npdbConnectionString;

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthListener.cs ===
// 
// HealthListener.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides methods for accessing the healthcheck system from native code or managed code 
// that doesn't use IIS.
// 
// Author: kgoodier 1/2009
//

using System;
using System.Net;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Reflection;
using Leet.Core;
using Leet.Core.Utils;
using Leet.Utils;
using Leet.Core.Diagnostics;

namespace Leet.Health.Common
{

    // --------------------------------------------------------------------------------------
    // HealthListener - provides a non-IIS solution for handling healthcheck requests.  
    // Typically used by native components via HealthInterop, but can also be used by non-IIS 
    // managed services.
    // --------------------------------------------------------------------------------------

    public class HealthListener
    {
        private string _ExpectedPath;
        private ushort _ListenerPort;
        private string _ListenerUrlPrefix;
        private HttpListener _Listener;

        private static List<HealthListener> _HealthListeners;

        // Used for asynchronous I/O in HttpListener stuff 
        private class CallbackData
        {
            public HttpListener Listener;
            public string ExpectedPath;
        }

        static HealthListener()
        {
            _HealthListeners = new List<HealthListener>();
        }

        // ----------------------------------------------------------------------------------
        // Initialize - must call this to fire up the HttpListener to handle requests.
        // ----------------------------------------------------------------------------------
        public static void InitializeHealthListener(
            string component,
            ushort listnerPort  // port must be provided with the initialization
            )
        {
            HealthListener hl;
            hl = new HealthListener();
            hl.Initialize(component, listnerPort, Assembly.GetCallingAssembly());
            _HealthListeners.Add(hl);
        }

        // ----------------------------------------------------------------------------------
        // Initialize - must call this to fire up the HttpListener to handle requests.
        // ----------------------------------------------------------------------------------
        private void Initialize(
            string component,
            ushort listnerPort,
            Assembly callingAssembly
            )
        {
            // This is the only URL path we'll accept
            _ExpectedPath = String.Format("/{0}/health.ashx", component);

            // @@@kgoodier TODO: implement IP policies to only listen on internal NICs
            _ListenerPort = listnerPort;
            _ListenerUrlPrefix = String.Format("http://*:{0}/{1}/", _ListenerPort, component);

            _Listener = new HttpListener();
            _Listener.Prefixes.Add(_ListenerUrlPrefix);
            _Listener.Start();

            // Fire off async http request handler
            CallbackData cd = new CallbackData();
            cd.Listener = _Listener;
            cd.ExpectedPath = _ExpectedPath;
            IAsyncResult result = _Listener.BeginGetContext(new AsyncCallback(ListenerCallback), cd);


            // Doing it here:
            // - sets calling assembly to null, weird xml results
            // - explicit knowledge of errors
            // Not doing it here:
            // - sets calling assembly to "xblhealthcheck", good but dup xml results
            // - health engine errors get swallowed, maybe reported to human caller

            HealthcheckEngine.Initialize(component, callingAssembly);

        }

        // ----------------------------------------------------------------------------------
        // ListenerCallback - incoming http request callback
        // ----------------------------------------------------------------------------------
        public static void ListenerCallback(IAsyncResult result)
        {
            try
            {
                CallbackData cd = (CallbackData)result.AsyncState;
                HttpListenerContext context;

                try
                {
                    // Fire off new BeginGetContext; this MUST happen, so do it before any possibility 
                    // of an exception.
                    IAsyncResult resultNew = cd.Listener.BeginGetContext(new AsyncCallback(ListenerCallback), cd);

                    context = cd.Listener.EndGetContext(result);
                }
                catch (Exception e)
                {
                    //Xom.NtEvent(XEvent.Id.HEALTH_LISTENER_CALLBACK_REQUEST_FAILED,
                    //             "ListenerCallback (native) failed EndGetContext, exception: " + e.ToString());

                    Logging.TraceException(e,
                        "HealthListner: ListenerCallback (native) failed EndGetContext");


                    // Can't do anything without the context object
                    return;
                }

                // Check for validity
                if (0 != String.Compare(context.Request.Url.AbsolutePath, cd.ExpectedPath, true))
                {
                    WriteHttpResponse(
                        context,
                        (int)HttpStatusCode.NotFound,  // 404 
                        "Error",
                        "<h1>Invalid healthcheck URL.</h1><p>Only \"health.ashx\" is allowed.");
                    return;
                }

                // All good, feed to healthcheck engine. ProcessRequest is not expected to 
                // throw an exception.
                HealthcheckEngine.ProcessRequest(context);
            }
            catch (Exception e)
            {
                try
                {
                    //Xom.NtEvent(XEvent.Id.HEALTH_LISTENER_CALLBACK_FAILED,
                    //             "ListenerCallback (native) exception: " + e.ToString());
                    Logging.TraceException(e,
                        "HealthListner: ListenerCallback (native) failed EndGetContext");

                }
                catch { };
            }

        }


        // ----------------------------------------------------------------------------------
        // PRIVATE STUFF HERE
        // ----------------------------------------------------------------------------------


        // ----------------------------------------------------------------------------------
        // WriteHttpResponse - makes it easier to send responses using the HttpListener
        // ----------------------------------------------------------------------------------
        private static void WriteHttpResponse(
            HttpListenerContext context,
            int statusCode,
            string htmlTitle,
            string htmlBody)
        {
            string responseString = String.Format("<html><head><title>{0}</title></head><body>{1}</body></html>",
                                                  htmlTitle, htmlBody);
            byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);
            context.Response.StatusCode = statusCode;
            context.Response.ContentLength64 = buffer.Length;
            context.Response.OutputStream.Write(buffer, 0, buffer.Length);
            context.Response.OutputStream.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\Test\Global.asax.cs ===
//-------------------------------------------------------------------
// <copyright file="Global.asax.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Sample Health Check Global Application
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/08/2008">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace HealthCheckSample
{
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Data;
    using System.IO;
    using System.Web;
    using System.Xml;
    using System.Xml.XPath;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Utils;

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class Global : System.Web.HttpApplication
    {

        /// <summary>
        /// Component Name.
        /// </summary>
        private const string ComponentName = "SampleHealthCheck";


        /// <summary>
        /// Application OnStart event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_Start(object sender, EventArgs e)
        {
            // set the current directory, so customer healblock implmementations can be loaded. 
            System.IO.Directory.SetCurrentDirectory(System.AppDomain.CurrentDomain.BaseDirectory);
           
            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();

            ConfigurationSelector.RegisterProvider(ComponentName, "LEET");


            LIVEnTrace.WriteLine(
                TraceLevel.Info,
                ComponentName,
                "Service Application Started.");
        }

        /// <summary>
        /// Application OnEnd event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_End(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application BeginRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_BeginRequest(object sender, EventArgs e)
        {
            // TODO: add performance counter start 
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            HttpContext.Current.Response.Headers["Cache-Control"] = "no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
            // TODO: add performance counter stop.  
        }

        /// <summary>
        /// Application error handler. 
        /// </summary>
        /// <param name="sender">Sender object. </param>
        /// <param name="e">The event arguments. </param>
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            LIVEnTrace.WriteLine(
                TraceLevel.Error,
                ComponentName,
                ex.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Identity")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1055:UriReturnValuesShouldNotBeStrings", Scope = "member", Target = "Leet.Identity.IWebsiteAuthenticationManager.#GetLogOnLogOffUrl()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Identity.IWebsiteAuthenticationManager.#GetLogOnLogOffUrl()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Identity.IWebsiteAuthenticationManager.#GetTextLinkForLoggingOnOrOff()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Identity")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "parentalControlGroup", Scope = "member", Target = "Leet.Identity.UserIdentity.#populateXboxLiveDetails()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "privileges", Scope = "member", Target = "Leet.Identity.UserIdentity.#populateXboxLiveDetails()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "tier", Scope = "member", Target = "Leet.Identity.UserIdentity.#populateXboxLiveDetails()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope = "member", Target = "Leet.Identity.UserIdentity.#Equals(System.Object)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1028:EnumStorageShouldBeInt32", Scope = "type", Target = "Leet.Identity.AccountType")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xboxcom", Scope = "member", Target = "Leet.Identity.AccountType.#Xboxcom")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Scope = "member", Target = "Leet.Identity.IAudienceUriProvider.#AudienceUriList")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Identity.IAuthenticationManager.#GetClaims()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Leet.Identity.IdentityManager.#Log")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ppsa", Scope = "type", Target = "Leet.Identity.IPpsaCredentialProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "Signin", Scope = "member", Target = "Leet.Identity.IPpsaCredentialProvider.#GetNetIDsForSigninNames(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "IDs", Scope = "member", Target = "Leet.Identity.IPpsaCredentialProvider.#GetNetIDsForSigninNames(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1053:StaticHolderTypesShouldNotHaveConstructors", Scope = "type", Target = "Leet.Identity.LiveIdServiceSoapHeader")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "CID", Scope = "member", Target = "Leet.Identity.LiveNTokenClaimTypes.#CIDClaimSetType")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Leet.Identity.LiveNTokenClaimTypes.#DeviceIDClaimType")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Leet.Identity.LiveNTokenClaimTypes.#MachineIDClaimType")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Ppsa", Scope = "type", Target = "Leet.Identity.PpsaCredentialProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Leet.Identity.LiveNTokenClaimTypes.#PartnerIDClaimType")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes", Scope = "member", Target = "Leet.Identity.PpsaCredentialProvider.#GetX509Certificate()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate", Scope = "member", Target = "Leet.Identity.TokenClaimsHelper.#TryGetClaimValueFromAuthenticationToken(System.String,System.Object&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Leet.Identity.TokenClaimsHelper.#TryGetTokenTitleID(System.UInt32&)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthUtils.cs ===
// 
// HealthUtilities.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides common healthcheck implementation and utilities.
// 
// Author: kgoodier 3/2008
//
namespace Leet.Health.Common
{

using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.Serialization;
using System.Reflection;
using System.Net;

// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
public enum OperationEnum
{
    Status,
    Heartbeat,
    LastStatus,
    Help,
    Unknown
}

public enum XslEnum
{
    None,
    Default,
    Help
}

// --------------------------------------------------------------------------------------
// HealthUtils
//
// Handy AND dandy.
// --------------------------------------------------------------------------------------
static internal class HealthUtils
{
    // ----------------------------------------------------------------------------------
    // Constants
    // ----------------------------------------------------------------------------------

    internal const string REQPARAM_XSL          = "xsl";
    internal const string REQPARAM_OPERATION    = "op";
    internal const string REQPARAM_STYLESHEET   = "stylesheet";

    
    // ----------------------------------------------------------------------------------
    // ParseRequestParams
    // ----------------------------------------------------------------------------------
    internal static void ParseRequestParams(
        NameValueCollection nv, 
        out OperationEnum op,
        out XslEnum xsl,
        out bool useStylesheet)
    {
        string val;

        // Name: 
        // 
        //   op
        //
        // Values:  
        //
        //   status
        //   heartbeat
        //   laststatus [default]
        //   help
        //
        
        op = OperationEnum.LastStatus;
        val = nv[HealthUtils.REQPARAM_OPERATION];
        if (String.Compare(val, "status", true) == 0)
        {
            op = OperationEnum.Status;
        }
        else if (String.Compare(val, "heartbeat", true) == 0)
        {
            op = OperationEnum.Heartbeat;
        }
        else if (String.Compare(val, "laststatus", true) == 0)
        {
            op = OperationEnum.LastStatus;
        }
        else if (String.Compare(val, "help", true) == 0)
        {
            op = OperationEnum.Help;
        }
        else if (val != null)
        {
            op = OperationEnum.Unknown;
        }

        // Name: 
        // 
        //   xsl
        //
        // Values:  
        //
        //   <none> [default]
        //   default
        //   help
        //
        
        xsl = XslEnum.None;
        val = nv[HealthUtils.REQPARAM_XSL];
        if (String.Compare(val, "default", true) == 0)
        {
            xsl = XslEnum.Default;
        }
        else if (String.Compare(val, "help", true) == 0)
        {
            xsl = XslEnum.Help;
        }

        // Name: 
        // 
        //   stylesheet
        //
        // Values:  
        //
        //   yes [default]
        //   no
        //
        
        useStylesheet = true;
        val = nv[HealthUtils.REQPARAM_STYLESHEET];
        if (String.Compare(val, "no", true) == 0)
        {
            useStylesheet = false;
        }

    }

    internal static void GetHelpXml(XmlWriter w)
    {
        w.WriteStartElement("Parameters");
        
        // Param: OP
        w.WriteStartElement("Parameter");
        w.WriteAttributeString("Name", HealthUtils.REQPARAM_OPERATION);
        w.WriteElementString("Description", "Controls how the healthcheck is executed and returned to the caller.");

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.Status.ToString());
        w.WriteString("Triggers a healthcheck and waits for the response. Returns full XML. Always returns an HTTP 200.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.Heartbeat.ToString());
        w.WriteString("Asynchronously returns the last health status. Only returns an HTTP 200 or 500. No XML.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.LastStatus.ToString());
        w.WriteAttributeString("Default", "yes");
        w.WriteString("Asynchronously returns the last health status. Returns full XML. Always returns an HTTP 200.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.Help.ToString());
        w.WriteString("Returns this help XML for the healthcheck system.");
        w.WriteEndElement();

        w.WriteEndElement();  // Parameter


        // Param: STYLESHEET
        w.WriteStartElement("Parameter");
        w.WriteAttributeString("Name", HealthUtils.REQPARAM_STYLESHEET);
        w.WriteElementString("Description", "Used to enable or disable the use of a stylesheet.");
        
        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", "yes");
        w.WriteAttributeString("Default", "yes");
        w.WriteString("A stylesheet will be used for viewing this healthcheck.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", "no");
        w.WriteString("A stylesheet will not be used for viewing this healthcheck. Useful for viewing the raw XML.");
        w.WriteEndElement();

        w.WriteEndElement();  // Parameter

        
        // Param: XSL
        w.WriteStartElement("Parameter");
        w.WriteAttributeString("Name", HealthUtils.REQPARAM_XSL);
        w.WriteElementString("Description", "Used to retrieve XSL documents automatically by the browser. Not expected for human consumption.");
        
        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", "none");
        w.WriteAttributeString("Default", "yes");
        w.WriteString("When parameter is missing, the XML healthcheck is returned instead of the XSL document.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", XslEnum.Default.ToString());
        w.WriteString("Returns the default XSL document for making the standard healthcheck XML prettier.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", XslEnum.Help.ToString());
        w.WriteString("Returns the XSL document used for viewing the healthcheck \"help\" operation.");
        w.WriteEndElement();

        w.WriteEndElement();  // Parameter



        w.WriteEndElement();  // Parameters

    }


}


// --------------------------------------------------------------------------------------
// SerializableDictionary
//
// Basic generic Dictionary<,> that can be used with XmlSerialize. Borrowed from 
// http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx.
// --------------------------------------------------------------------------------------
public class SerializableDictionary<TKey, TValue>
    : Dictionary<TKey, TValue>, IXmlSerializable
{
    public System.Xml.Schema.XmlSchema GetSchema()
    {
        return null;
    }

    public void ReadXml(System.Xml.XmlReader reader)
    {
        XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
        XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

        bool wasEmpty = reader.IsEmptyElement;
        reader.Read();

        if (wasEmpty)
            return;

        while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
        {
            reader.ReadStartElement("item");

            reader.ReadStartElement("key");
            TKey key = (TKey)keySerializer.Deserialize(reader);
            reader.ReadEndElement();

            reader.ReadStartElement("value");
            TValue value = (TValue)valueSerializer.Deserialize(reader);
            reader.ReadEndElement();

            this.Add(key, value);

            reader.ReadEndElement();
            reader.MoveToContent();
        }
        reader.ReadEndElement();
    }

    public void WriteXml(System.Xml.XmlWriter writer)
    {
        XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
        XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

        foreach (TKey key in this.Keys)
        {
            writer.WriteStartElement("item");

            writer.WriteStartElement("key");
            keySerializer.Serialize(writer, key);
            writer.WriteEndElement();

            writer.WriteStartElement("value");
            TValue value = this[key];
            valueSerializer.Serialize(writer, value);
            writer.WriteEndElement();

            writer.WriteEndElement();
        }
    }
}


// --------------------------------------------------------------------------------------
// RunnableHealthBlock
//
// A list of these provides the execution plan for our healthcheck calls.
// --------------------------------------------------------------------------------------
internal class RunnableHealthBlock
{
    internal string              Name;
    internal string              FullName;
    internal NameValueCollection Params;
    internal string              ParamsString;
    internal bool                Critical;

    internal RunnableHealthBlock(
        string name, 
        string fullName, 
        string paramsString,
        bool critical)
    {
        Name = name;
        FullName = fullName;
        Params = new NameValueCollection();
        ParamsString = paramsString;
        Critical = critical;

        if (paramsString != null)
        {
            ParseStringToParams(paramsString, Params);
        }
    }

    internal static void ParseStringToParams(string paramsString, NameValueCollection nvParams)
    {
        string[] nameValueArray = paramsString.Split(new char[] { ',' });
        foreach (string nv in nameValueArray)
        {
            string[] s = nv.Split(new char[] { '=' });
            if (s.Length == 1)
            {
                nvParams.Add(s[0].Trim(), null);
            }
            else if (s.Length == 2)
            {
                nvParams.Add(s[0].Trim(), s[1].Trim());
            }
            // @@@ TODO: event here?
        }
    }

    // ----------------------------------------------------------------------------------
    // ParseParamsToString - used to marshal params for the native health blocks.  
    // CXomNameValuePairList is the intended parser of this.
    // ----------------------------------------------------------------------------------
    internal static string ParseParamsToString(NameValueCollection nvParams)
    {
        if (nvParams.AllKeys == null)
        {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        string sep = "";

        foreach (string key in nvParams.AllKeys)
        {

            if (nvParams.GetValues(key) == null)
            {
                sb.Append(sep);
                sep = ",";
                sb.Append(key);
                continue;
            }
            foreach (string val in nvParams.GetValues(key))
            {
                sb.Append(sep);
                sep = ",";
                sb.Append(key + "=" + val);
            }
        }

        return sb.ToString();
    }

}


// --------------------------------------------------------------------------------------
// IHttpContextAdapter {{{
//
// Provides a common interface in front of HttpContext and HttpListenerContext objects.  
// This is the bare set of what we need at the moment; please add more as needed.
// --------------------------------------------------------------------------------------
interface IHttpContextAdapter : IDisposable
{
    // Request
    NameValueCollection Params { get; }

    // Response
    int                 StatusCode { get; set; }
    string              ContentType { get; set; }
    TextWriter          Output { get; }

    void BinaryWrite(byte[] data);

}

// --------------------------------------------------------------------------------------
// IisContextAdapter
//
// Adapts the IIS HttpContext to the IHttpContextAdapter interface.
// --------------------------------------------------------------------------------------
internal class IisContextAdapter : IHttpContextAdapter
{
    private HttpContext _ctx;

    public IisContextAdapter(HttpContext ctx)
    {
        _ctx = ctx;
    }

    public void Dispose()
    {
        // nothing to do
    }

    public NameValueCollection Params
    {
        get 
        {
            return _ctx.Request.Params;
        }
    }

    public int StatusCode
    {
        get { return _ctx.Response.StatusCode; }
        set { _ctx.Response.StatusCode = value; }
    }

    public string ContentType
    {
        get { return _ctx.Response.ContentType; }
        set { _ctx.Response.ContentType = value; }
    }

    public TextWriter Output
    {
        get { return _ctx.Response.Output; }
    }

    public void BinaryWrite(byte[] data)
    {
        if (data != null)
        {
            // We want to avoid the use of _ctx.Response.BinaryWrite since that isn't 
            // allowed by .Net for local instances of HttpContext (i.e., ones constructed 
            // by the tests). So we'll work around it by converting our bytes to UTF8 
            // characters and writing those.
            
            int count = data.Length;
            char[] charData = new char[count];
            MemoryStream ms = new MemoryStream(data, 0, count);
            StreamReader sr = new StreamReader(ms, Encoding.UTF8, true);

            // Read all characters at once. Not ideal, but our stylesheets won't ever be 
            // *that* large. Some notes from Ian:
            //
            // note that according to 
            // http://msdn.microsoft.com/en-us/library/9kstw824(VS.80).aspx there is room 
            // for a performance improvement here by:
            //  1. specifying the size of the internal buffer in the Streamreader 
            //  constructor to some desired block size
            //  2. locking the output charData array to the same size as that internal 
            //  buffer and 
            //  3. repeatedly reading slightly fewer characters than will fit into that 
            //  destination array and writing the data to the response stream in multiple 
            //  passes until all the characters have been read from the StreamReader

            // read out up to count chars (the number of chars cannot exceed count since 
            // chars are at least 1 byte each)
            int charsRead = sr.Read(charData, 0, count);

            // write the retrieved chars out to the resopnse stream, using the real number 
            // of chars found in the UTF-8 stream rather than the number of bytes passed 
            // in initially. This avoid use of the HttpResponse.OutputStream (instead uses 
            // the Writer), and thus no exception for our tests.
            _ctx.Response.Write(charData, 0, charsRead);
        }
    }


}

// --------------------------------------------------------------------------------------
// HttpListenerContextAdapter
//
// Adapts the .Net HttpListenerContext to the IHttpContextAdapter interface.
// --------------------------------------------------------------------------------------
internal class HttpListenerContextAdapter : IHttpContextAdapter
{
    private HttpListenerContext _ctx;
    private MemoryStream        _OutputStorage;

    public HttpListenerContextAdapter(HttpListenerContext ctx)
    {
        _ctx = ctx;
        _OutputStorage = new MemoryStream();
    }

    public void Dispose()
    {
        CloseOutput();
    }

    public NameValueCollection Params
    {
        get 
        {
            return _ctx.Request.QueryString;
        }
    }

    public int StatusCode
    {
        get { return _ctx.Response.StatusCode; }
        set { _ctx.Response.StatusCode = value; }
    }

    public string ContentType
    {
        get { return _ctx.Response.ContentType; }
        set { _ctx.Response.ContentType = value; }
    }

    public TextWriter Output
    {
        get { return new StreamWriter(_OutputStorage); }  //return new StreamWriter(_ctx.Response.OutputStream); }
    }

    public void BinaryWrite(byte[] data)
    {
        if (data != null)
        {
            //_ctx.Response.OutputStream.Write(data, 0, data.Length);
            BinaryWriter bw = new BinaryWriter(_OutputStorage);
            bw.Write(data);
        }
    }

    // Extra method for annoying outputstream cleanup
    private void CloseOutput()
    {
        byte[] data = _OutputStorage.GetBuffer();
        long dataLength = _OutputStorage.Length;
        // data.Length is probably larger than _OutputStorage.Length, fyi. It represents 
        // the total buffer size.

        _ctx.Response.ContentLength64 = dataLength;
        _ctx.Response.OutputStream.Write(data, 0, (int)dataLength);
        _ctx.Response.OutputStream.Close();
    }



}

// Done with IHttpContextAdapter }}}
// --------------------------------------------------------------------------------------






}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\IAuthenticationManager.cs ===
﻿using System;
using Leet.Identity;
using System.IdentityModel.Claims;

namespace Leet.Identity
{
    public interface IAuthenticationManager : IIdentityManager
    {
        IUserIdentity CurrentUser { get; }
        bool IsAuthenticated { get; }
        ClaimSet GetClaims();
    }

    public interface IWebsiteAuthenticationManager : IAuthenticationManager
    {
        string GetLogOnLogOffUrl();
        string GetTextLinkForLoggingOnOrOff();
        void SetCurrentUser(IUserIdentity user);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\HealthCheackCommon\HealthMain.cs ===
// 
// HealthMain.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides common healthcheck implementation and utilities.
// 
// Author: kgoodier 3/2008
//

namespace Leet.Health.Common
{
    using System;
    using System.Text;
    using System.Threading;
    using System.Web;
    using System.Diagnostics;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Reflection;
    using System.Net;
    using System.IO;
    using System.Security.Principal;
    using Leet.Core;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Utils;
    using Leet.Core.Diagnostics;
    // --------------------------------------------------------------------------------------
    // HealthcheckEngine - main class for handling health requests
    // --------------------------------------------------------------------------------------
    public static class HealthcheckEngine
    {

        static HealthcheckEngine()
        {
            _CurrentReport = null;
            _EngineThread = null;
            _EngineStartEvent = null;
            _EngineDoneEvent = null;
            _EnginePeriodInSeconds = 0;
            _EngineRunning = false;
            _LockInitialize = new object();
            _IsInitialized = false;
            _NumberOfRequests = 0;
            _Stylesheets = new Dictionary<XslEnum, byte[]>();
        }

        // ----------------------------------------------------------------------------------
        // Entry point for IIS requests (front door healthchecks)
        // ----------------------------------------------------------------------------------
        public static void ProcessRequest(
            HttpContext ctx,
            string component)
        {
            // MUST call GetCallingAssembly from the entry point function, not nested in 
            // another function!
            Interlocked.Increment(ref _NumberOfRequests);
            Initialize(component, Assembly.GetCallingAssembly());

            // Exceptions here should be handled by FEAPP
            using (IisContextAdapter ctx2 = new IisContextAdapter(ctx))
            {
                ProcessRequest(ctx2);
            }
        }

        // ----------------------------------------------------------------------------------
        // Entry point for .Net HttpListener requests (native healthchecks)
        // ----------------------------------------------------------------------------------
        internal static void ProcessRequest(
            HttpListenerContext ctx)
        {
            Interlocked.Increment(ref _NumberOfRequests);
            // Don't need to call Initialize(), since we know the HealthListener has already 
            // done that (this is an internal call).

            using (HttpListenerContextAdapter ctx2 = new HttpListenerContextAdapter(ctx))
            {
                try
                {
                    // No FEAPP, must handle our own exceptions
                    ProcessRequest(ctx2);
                }
                catch (Exception e)
                {
                    Logging.TraceException(e,
                        "HealthMain: Fatal exception ");
                    // TODO: raise an event. 
                }
            }
        }

        // ----------------------------------------------------------------------------------
        // Private entry point for all requests. Does lots of work.
        // ----------------------------------------------------------------------------------
        private static void ProcessRequest(
            IHttpContextAdapter ctx)
        {
            //
            // Parse GET parameters
            //

            OperationEnum op;
            XslEnum xsl;
            bool useStylesheet;
            HealthUtils.ParseRequestParams(ctx.Params, out op, out xsl, out useStylesheet);

            if (op == OperationEnum.Help)
            {
                ProcessHelpRequest(ctx, useStylesheet);
                return;
            }

            if (op == OperationEnum.Unknown)
            {
                ctx.StatusCode = (int)HttpStatusCode.BadRequest;  // 400
                return;
            }

            // If an XSL was specified, this is actually IE making a request to us for a 
            // stylesheet. We should return that instead of any other healthcheck thing.
            if (xsl != XslEnum.None)
            {
                ProcessStylesheetRequest(ctx, xsl);
                return;
            }

            if (!_EngineRunning)
            {
                // well then. fire up the thread again? why did it die?
                // @@@ event?
                ctx.StatusCode = 500;
                return;
            }

            // 
            // Synchronous health check requested (first request always counts)?
            //
            if ((op == OperationEnum.Status) ||
                (op == OperationEnum.LastStatus && _CurrentReport.Info.NumberOfHealthcheckIterations == 0))
            {
                _EngineDoneEvent.Reset();
                WaitHandle.SignalAndWait(_EngineStartEvent, _EngineDoneEvent);
            }

            // Return results to client
            if (op == OperationEnum.Heartbeat)
            {
                switch (_CurrentReport.HealthStatus)
                {
                    case HealthStatusEnum.Green:
                    case HealthStatusEnum.Yellow:
                        ctx.StatusCode = 200;
                        break;
                    case HealthStatusEnum.Red:
                        ctx.StatusCode = 500;
                        break;
                }
            }
            else
            {
                ctx.ContentType = "text/xml";
                ctx.StatusCode = 200;  // want to see the output!

                // Serialize xml directly to http response
                XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
                xsn.Add(String.Empty, String.Empty);
                XmlSerializer serializer = new XmlSerializer(typeof(HealthReportCompilation));

                XmlWriterSettings xmlSettings = new XmlWriterSettings();
                xmlSettings.CheckCharacters = false;
                using (XmlWriter writer = XmlWriter.Create(ctx.Output, xmlSettings))
                {
                    // Style sheet
                    if (useStylesheet && _Stylesheets.ContainsKey(XslEnum.Default))
                    {
                        writer.WriteProcessingInstruction(
                            "xml-stylesheet",
                            "href='health.ashx?xsl=" + XslEnum.Default.ToString() + "' type='text/xsl'");
                    }

                    serializer.Serialize(writer, _CurrentReport, xsn);
                }
            }
        }

        // ----------------------------------------------------------------------------------
        // GetIdentityInfo
        // ----------------------------------------------------------------------------------
        public static void GetIdentityInfo(out WindowsIdentity id, out bool IsImpersonating)
        {
            id = WindowsIdentity.GetCurrent(true);
            if (id == null)
            {
                IsImpersonating = false;
                id = WindowsIdentity.GetCurrent(false);
            }
            else
            {
                IsImpersonating = true;
            }
        }

        public static Assembly CallingAssembly
        {
            get { return _CallingAssembly; }
        }

        // ----------------------------------------------------------------------------------
        // Private methods here 
        // ----------------------------------------------------------------------------------


        // ----------------------------------------------------------------------------------
        // Initialize - performs one-time initialization such as finding available 
        // healthblocks, firing up the background thread, reading settings, etc.
        // ----------------------------------------------------------------------------------
        internal static void Initialize(string component, Assembly callingAssembly)
        {
            if (_IsInitialized)
            {
                return;
            }

            lock (_LockInitialize)
            {
                if (_IsInitialized)
                {
                    return;
                }

                _CallingAssembly = callingAssembly;

                // Set initial (bad) report while thread spins up
                // BUGBUG: fix the system up time later. 
                HealthReportCompilation hrc = new HealthReportCompilation(
                    component,
                    _NumberOfRequests,
                    0,
                    new TimeSpan(10000));

                hrc.HealthStatus = HealthStatusEnum.Red;
                hrc.ReadyForService = false;
                hrc.Done();
                _CurrentReport = hrc;

                // Reset Config to point to calling component, not us, for overrides and such.
                // NOTE: this line is not necessary because in LIVEN ConfigurationProvider is
                // for the entire application. 
                //Config.ComponentName = component;

                // Load healthblock caches
                HealthBlockManager.StaticInit(callingAssembly);

                // Get settings
                // BUBUG: get this value from NPDB. 
                //_EnginePeriodInSeconds = Config.GetIntSetting(Settings.Healthcheck_executionPeriodInSeconds);
                _EnginePeriodInSeconds = 60;

                // Load xsl stylesheets from resources
                _Stylesheets = LoadStylesheets();

                // get the configuration provider. 
                Config = Container.Instance.GetComponent<IConfigurationProvider>();

                // Events
                _EngineStartEvent = new EventWaitHandle(true, EventResetMode.ManualReset);  // initially signalled
                _EngineDoneEvent = new EventWaitHandle(false, EventResetMode.ManualReset); // initially not signalled

                // Fire up background engine thread
                _EngineThread = new EngineThread(new ThreadStart(EngineFunction));
                _EngineThread.IsBackground = true;
                //_EngineThread.Priority = ThreadPriority.BelowNormal;
                _EngineThread.Start();
                _EngineRunning = true;

                // We now have a report set that will indicate failure. We can continue 
                // initializing now and let future requests come in. They'll return the bogus 
                // report until a real report is ready.
                _IsInitialized = true;
            }

        }


        // ----------------------------------------------------------------------------------
        // EngineFunction - this thread actually runs the healthchecks. It generally does so 
        // in the background, though it can be performed synchronously by using the 
        // _EngineStartEvent and _EngineDoneEvent events.
        //
        // It is expected this thread never terminates. It would be fatal for it to do so.
        //
        // Also keep in mind that because we run healthchecks on this thread, the 
        // HttpContext.Current is not necessarily available.
        // ----------------------------------------------------------------------------------
        private static void EngineFunction()
        {
            _EngineRunning = true;
            long numberOfIterations = 0;
            Random rand = new Random();
            const double jitterFraction = 0.1;

            while (true)
            {
                try
                {
                    // Either wait for the execution period to elapse or wait for an immediate 
                    // request.

                    int p = _EnginePeriodInSeconds;  // use the value atomically for this loop
                    TimeSpan waitTime = new TimeSpan(0, 0, p);

                    // A small random jitter on each period ensures that even if all 
                    // healthchecks are called at exactly the same time AND they all execute 
                    // in the same amount of time, they will be roughly out of sync. We'll add 
                    // between 0 and +/- EnginePeriod/20 seconds to the period. This is +/- 
                    // 10%.
                    TimeSpan jitter = TimeSpan.FromSeconds((rand.NextDouble() * p * jitterFraction) - (p * jitterFraction / 2));
                    waitTime = waitTime.Add(jitter);

                    _EngineStartEvent.WaitOne(waitTime, false);

                    try
                    {
                        HealthStatusEnum lastStatus = _CurrentReport.HealthStatus;
                        _CurrentReport = GenerateHealthReport(_NumberOfRequests, ++numberOfIterations);

                        // Don't log event on the very first iteration
                        if (_CurrentReport.HealthStatus != lastStatus && numberOfIterations > 1)
                        {
                            //  XEvent.Id eventId = 
                            //      _CurrentReport.HealthStatus == HealthStatusEnum.Green ? XEvent.Id.HEALTH_REPORT_GREEN :
                            //      _CurrentReport.HealthStatus == HealthStatusEnum.Yellow ? XEvent.Id.HEALTH_REPORT_YELLOW :
                            //      XEvent.Id.HEALTH_REPORT_RED;
                            //Xom.NtEvent(eventId, String.Format(
                            //          "Health status has changed from {0} to {1}.\r\n{2}",
                            //          lastStatus,
                            //          _CurrentReport.HealthStatus,
                            //          _CurrentReport.ToEventText()));
                        }
                    }
                    finally
                    {
                        _EngineStartEvent.Reset();
                        _EngineDoneEvent.Set();
                    }
                }
                catch (ThreadAbortException)
                {
                    // perfectly normal when app domain is being unloaded
                    _EngineRunning = false;
                    return;
                }
                catch (Exception e)
                {
                    //Xom.NtEvent(XEvent.Id.HEALTH_ENGINE_FAILURE, 
                    //             "Unexpected exception encountered during the healthcheck engine's execution. " +
                    //             "Please escalate to the dev team during normal business hours. Exception text:\r\n\r\n" +
                    //             e.ToString());
                    // resume executing and cross our fingers it wasn't the event that failed
                    // @@@ sanity check and/or reset things?  _EnginePeriodInSeconds, 
                    // _EngineStartEvent, _EngineDoneEvent?

                    Logging.TraceException(e, 
                        "HealthMain: Unexpected exception");
                }
            }
        }

        // ----------------------------------------------------------------------------------
        // GenerateHealthReport - loops through each healthblock and executes it, adding the 
        // report to the compilation.
        // ----------------------------------------------------------------------------------
        private static HealthReportCompilation GenerateHealthReport(
            long numberOfRequests,
            long numberOfIterations)
        {
            HealthBlockManager blockManager;
            List<RunnableHealthBlock> blocksToRun;

            blockManager = new HealthBlockManager();

            // Fresh results each time
            // BUGBUG, fix the time system up time later. 
            HealthReportCompilation hrc = new HealthReportCompilation(
                Config.ComponentName,
                numberOfRequests,
                numberOfIterations,
                new TimeSpan(10000));

            try
            {
                // Run all of the static (from the db) blocks first
                blocksToRun = blockManager.GetStaticBlocksToRun();
                while (blocksToRun.Count > 0)
                {
                    foreach (RunnableHealthBlock block in blocksToRun)
                    {
                        HealthReport report;
                        report = blockManager.RunHealthBlock(block);
                        hrc.AddReport(report);
                    }

                    // Run any dynamically added blocks until none are left
                    blocksToRun = blockManager.GetDynamicBlocksToRun();
                }
            }
            catch (Exception e)
            {
                hrc.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
            }

            hrc.Done();
            return hrc;
        }

        // ----------------------------------------------------------------------------------
        // ProcessStylesheetRequest - handles the request for a stylesheet
        // ----------------------------------------------------------------------------------
        private static void ProcessStylesheetRequest(IHttpContextAdapter ctx, XslEnum xsl)
        {
            if (xsl == XslEnum.None || !_Stylesheets.ContainsKey(xsl))
            {
                ctx.StatusCode = (int)HttpStatusCode.BadRequest;  // 400
                return;
            }

            // @@@ TEST ONLY, TAKE THIS OUT BEFORE CHECKIN. We don't want to hit the db on 
            // every request in production.
            // _Stylesheets = LoadStylesheets();

            ctx.ContentType = "text/xsl";
            ctx.StatusCode = 200;
            ctx.BinaryWrite(_Stylesheets[xsl]);
        }

        //// ----------------------------------------------------------------------------------
        //// LoadStylesheets - load the xsl blobs from t_config_blobs and map to the enum
        //// ----------------------------------------------------------------------------------
        private static Dictionary<XslEnum, byte[]> LoadStylesheets()
        {
            byte[] blob;
            Dictionary<XslEnum, byte[]> stylesheets = new Dictionary<XslEnum, byte[]>();
            string baseDir = System.AppDomain.CurrentDomain.BaseDirectory; 

            foreach (string item in Enum.GetNames(typeof(XslEnum)))
            {
                string setting = "healthcheck_xsl_" + item.ToLower();
                //TODO: replace with Config.GetBlogSetting once it is hooked up. 
                // The file based solution is temporary. 
                //blob = Config.GetBlobSetting(setting);

                bool fileExists = false;
                string filePath = baseDir + @"\bin\" + setting + ".dat";
                if (File.Exists(filePath))
                {
                    fileExists = true;
                }
                else
                {
                    // look in alternative directory
                    filePath = baseDir + @"\" + setting + ".dat";
                    if (File.Exists(filePath))
                    {
                        fileExists = true;
                    }
                }

                if (fileExists)
                {
                    try
                    {
                        using (FileStream fs = File.OpenRead(filePath))
                        {
                            blob = ReadEntireStream(fs);
                            if (blob != null)
                            {
                                stylesheets[(XslEnum)Enum.Parse(typeof(XslEnum), item)] = blob;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logging.TraceException(ex, 
                            "HealthMain: failed to open and read file {0}",
                            setting);
                    }
                }
            }

            return stylesheets;
        }


        /// <summary>
        /// A temporary helper method to read entire stream.This is not he best implementation, but we will replace this
        /// with IConfigurationProvider.GetBlobSetting(settingName); 
        /// </summary>
        /// <param name="stream">The stream to read data from. </param>
        /// <returns>The byte array of the data. </returns>
        private static byte[] ReadEntireStream(Stream stream)
        {
            byte[] buffer = new byte[32768];
            using (MemoryStream ms = new MemoryStream())
            {
                while (true)
                {
                    int read = stream.Read(buffer, 0, buffer.Length);
                    if (read <= 0)
                        return ms.ToArray();
                    ms.Write(buffer, 0, read);
                }
            }
        }

        // ----------------------------------------------------------------------------------
        // ProcessHelpRequest - handles the request for help
        // ----------------------------------------------------------------------------------
        private static void ProcessHelpRequest(IHttpContextAdapter ctx, bool useStylesheet)
        {
            ctx.ContentType = "text/xml";
            ctx.StatusCode = 200;  // want to see the output!

            XmlWriterSettings xmlSettings = new XmlWriterSettings();
            xmlSettings.CheckCharacters = false;
            using (XmlWriter w = XmlWriter.Create(ctx.Output, xmlSettings))
            {
                w.WriteStartDocument();
                if (useStylesheet && _Stylesheets.ContainsKey(XslEnum.Help))
                {
                    string x = "href='health.ashx?xsl=" + XslEnum.Help.ToString() + "' type='text/xsl'";
                    w.WriteProcessingInstruction("xml-stylesheet", x);
                }
                w.WriteStartElement("HealthcheckHelp");

                // Parameters
                HealthUtils.GetHelpXml(w);

                // Stylesheets
                w.WriteStartElement("Stylesheets");
                foreach (KeyValuePair<XslEnum, byte[]> kvp in _Stylesheets)
                {
                    w.WriteStartElement("Stylesheet");
                    w.WriteElementString("StylesheetName", kvp.Key.ToString());
                    w.WriteElementString("StylesheetSetting", "healthcheck_xsl_" + kvp.Key.ToString().ToLower());
                    w.WriteEndElement();
                }
                w.WriteEndElement();  // Stylesheets

                // Healthblocks
                HealthBlockCache.GetHelpXml(w);

                // Settings
                w.WriteStartElement("Settings");
                w.WriteElementString("IsInitialized", _IsInitialized.ToString());
                w.WriteElementString("EnginePeriodInSeconds", _EnginePeriodInSeconds.ToString());
                w.WriteEndElement();  // Settings

                w.WriteEndElement(); // HealthcheckHelp
                w.WriteEndDocument();
            }
        }


        private static volatile HealthReportCompilation _CurrentReport;

        private static object _LockInitialize;
        private static volatile bool _IsInitialized;
        private static long _NumberOfRequests;
        private static Assembly _CallingAssembly;

        private static EngineThread _EngineThread;
        private static volatile int _EnginePeriodInSeconds;
        private static EventWaitHandle _EngineStartEvent;
        private static EventWaitHandle _EngineDoneEvent;
        private static bool _EngineRunning;

        private static Dictionary<XslEnum, byte[]> _Stylesheets;

        private static IConfigurationProvider Config;


    }



    // --------------------------------------------------------------------------------------
    // HealthReportCompilation - holds aggregated results from all the healthblocks
    // --------------------------------------------------------------------------------------
    [XmlRoot("Healthcheck")]  //, Namespace="http://www.xboxlive.com", IsNullable=false)]
    public class HealthReportCompilation // : IXmlSerializable
    {
        [XmlAttribute]
        public string Name;
        [XmlAttribute]
        public string Server;
        [XmlAttribute]
        public HealthStatusEnum HealthStatus;
        [XmlAttribute]
        public bool ReadyForService;

        public string ExtraDetails;

        public HealthcheckExtendedInfo Info;
        public List<HealthReport> Reports;

        // ----------------------------------------------------------------------------------
        // Constructor (internal use only, for XmlSerializer)
        // ----------------------------------------------------------------------------------
        public HealthReportCompilation()
        {
        }

        public HealthReportCompilation(
            string name,
            long numRequests,
            long numIterations,
            TimeSpan upTime)
        {
            try
            {
                IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
                Name = name;
                Server = config.Server;
                ReadyForService = true;
                HealthStatus = HealthStatusEnum.Green;
                ExtraDetails = null;
                Info = new HealthcheckExtendedInfo();
                Reports = new List<HealthReport>();

                // Set extended info
                Info._StartTime = DateTime.Now;
                Info._ElapsedTime = new TimeSpan(0);

                Info.NumberOfRequests = numRequests;
                Info.NumberOfHealthcheckIterations = numIterations;
                Info.UpTime = upTime.ToString();
                Info.LastHealthcheckTime = Info._StartTime.ToString("G");
                Info.ElapsedTime = Info._ElapsedTime.ToString();
                Info.ProcessId = System.Diagnostics.Process.GetCurrentProcess().Id;

                // Assembly info

                Info.CallingAssemblyInfo = CreateAssemblyInfo(HealthcheckEngine.CallingAssembly, true);
                Info.HealthcheckAssemblyInfo = CreateAssemblyInfo(Assembly.GetExecutingAssembly(), true);

                Info.LoadedAssemblyInfo = new List<AssemblyExtendedInfo>();
                foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
                {
                    Info.LoadedAssemblyInfo.Add(CreateAssemblyInfo(asm, false));
                }

                // User identity and groups

                Info.IdentityInfo = CreateIdentityInfo();
            }
            catch (Exception e)
            {
                ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
                HealthStatus = HealthStatusEnum.Red;
            }
        }

        private AssemblyExtendedInfo CreateAssemblyInfo(Assembly asm, bool fIncludeReferencedAssemblies)
        {
            AssemblyExtendedInfo ex = new AssemblyExtendedInfo();

            try
            {
                if (asm == null)
                {
                    ex.Name = "Unknown";
                    ex.AssemblyFullname = "Unknown";
                    ex.Location = "";
                    ex.FileVersion = "0.0.0.0";
                    ex.ReferencedAssemblies = null;
                }
                else
                {
                    ex.Name = (new AssemblyName(asm.FullName)).Name;
                    ex.AssemblyFullname = asm.FullName;
                    if (!String.IsNullOrEmpty(asm.Location))
                    {
                        ex.Location = asm.Location;
                        ex.FileVersion = FileVersionInfo.GetVersionInfo(asm.Location).FileVersion;
                    }

                    if (fIncludeReferencedAssemblies)
                    {
                        AssemblyName[] refasms = asm.GetReferencedAssemblies();
                        ex.ReferencedAssemblies = Array.ConvertAll<AssemblyName, string>(
                            refasms,
                            delegate(AssemblyName an)
                            {
                                return an.FullName;
                            });
                    }
                    else
                    {
                        ex.ReferencedAssemblies = null;
                    }
                }
            }
            catch (Exception e)
            {
                ex.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
            }

            return ex;
        }

        private IdentityExtendedInfo CreateIdentityInfo()
        {
            IdentityExtendedInfo ex = new IdentityExtendedInfo();

            try
            {
                WindowsIdentity currentIdentity;
                HealthcheckEngine.GetIdentityInfo(out currentIdentity, out ex.IsImpersonating);

                if (currentIdentity == null)
                {
                    ex.UserContext = "Could not retrieve current Windows identity.";
                    return ex;
                }

                ex.Name = currentIdentity.Name;
                ex.UserContext = currentIdentity.Name;
                ex.UserGroups = new List<string>();

                if (currentIdentity.Groups != null)
                {
                    // currentIdentity.Groups is a collection of SecurityIdentifier instances.
                    foreach (IdentityReference idRef in currentIdentity.Groups)
                    {
                        NTAccount ntAccount = (NTAccount)idRef.Translate(typeof(NTAccount));
                        ex.UserGroups.Add(string.Format("{0} ({1})", ntAccount.Value, idRef.Value));
                    }
                }
            }
            catch (Exception e)
            {
                ex.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
            }

            return ex;
        }

        public void AddReport(HealthReport r)
        {
            // Store it
            Reports.Add(r);

            // Now update state

            // Downgrade overall health status
            //
            // 1. Remote resource, red    -> yellow, ready
            // 2. Remote resource, yellow -> yellow, ready
            // 3. Remote resource, green  -> green,  ready
            // 4. Local resource,  red    -> red,    not ready
            // 5. Local resource,  yellow -> yellow, ready
            // 6. Local resource,  green  -> green,  ready
            //
            // Any non-critical healthblock: red -> yellow
            //

            // Overrides for "red"
            if (r.HealthStatus == HealthStatusEnum.Red)
            {
                if (!r.Critical || r.ResourceType == ResourceTypeEnum.Remote)
                {
                    DowngradeStatus(HealthStatusEnum.Yellow);
                }
                else
                {
                    DowngradeStatus(HealthStatusEnum.Red);
                }
            }
            else
            {
                // We never remap green or yellow
                DowngradeStatus(r.HealthStatus);
            }

        }

        public void Done()
        {
            Info._ElapsedTime = DateTime.Now - Info._StartTime;
            Info.ElapsedTime = Info._ElapsedTime.ToString();
        }

        public string ToEventText()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("HealthCheck results for {0}\r\n", Name);
            sb.AppendFormat("HealthStatus: {0}\r\n", HealthStatus);
            sb.AppendFormat("NumberOfHealthcheckIterations: {0}\r\n", Info.NumberOfHealthcheckIterations);
            sb.AppendFormat("LastHealthcheckTime: {0}\r\n", Info.LastHealthcheckTime);
            sb.AppendFormat("ElapsedTime: {0}\r\n", Info.ElapsedTime);
            sb.AppendFormat("Reports:\r\n");
            foreach (HealthReport r in Reports)
            {
                sb.AppendFormat("{0}: {1} ({2})\r\n", r.FriendlyName, r.HealthStatus, r.ErrorDetails);
            }
            return sb.ToString();
        }

        private void DowngradeStatus(HealthStatusEnum s)
        {
            if (s == HealthStatusEnum.Yellow && this.HealthStatus == HealthStatusEnum.Green)
            {
                this.HealthStatus = s;
            }
            else if (s == HealthStatusEnum.Red)
            {
                this.HealthStatus = s;
                this.ReadyForService = false;
            }
        }
    }

    public class HealthcheckExtendedInfo
    {
        public long NumberOfRequests;
        public long NumberOfHealthcheckIterations;
        public string UpTime;
        public string LastHealthcheckTime;
        public string ElapsedTime;
        public int ProcessId;
        public AssemblyExtendedInfo CallingAssemblyInfo;
        public AssemblyExtendedInfo HealthcheckAssemblyInfo;
        public List<AssemblyExtendedInfo> LoadedAssemblyInfo;
        public IdentityExtendedInfo IdentityInfo;

        // XmlSerializer sux. It won't let me tweak the format of DateTime, and it won't show 
        // TimeSpan at all (?). It also won't serialize a public string accessor (seriously?).  
        // So we have to store these as duplicate strings and manually set those. 
        [XmlIgnore]
        public DateTime _StartTime;
        [XmlIgnore]
        public TimeSpan _ElapsedTime;
    }

    public class AssemblyExtendedInfo
    {
        [XmlAttribute]
        public string Name;
        public string AssemblyFullname;
        public string FileVersion;
        public string Location;
        public string[] ReferencedAssemblies;
        public string ExtraDetails;
    }

    public class IdentityExtendedInfo
    {
        [XmlAttribute]
        public string Name;
        public bool IsImpersonating;
        public string UserContext;
        public List<string> UserGroups;
        public string ExtraDetails;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Health\Tools\Program.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Tools for Leet.HealthCheckCommon. 
//  Currently only try to get the stylesheet from Platform NPDB and create .dat files for Leet.HealthCheckCommon
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace HealthCheckUtils
{
    using System;
    using System.Configuration; 
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Xml.Serialization;

    public enum XslEnum
    {
        None,
        Default,
        Help
    }

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            CreateBlobFiles(); 
        }

        private static void CreateBlobFiles()
        {
            string platformNPDBConnectionString = ConfigurationManager.AppSettings["PlatformNPDBConnectionString"]; 
            byte[] blob;
            foreach (string item in Enum.GetNames(typeof(XslEnum)))
            {
                string setting = "healthcheck_xsl_" + item.ToLower();
                blob = GetBlobSetting(setting, platformNPDBConnectionString);
                if (blob != null)
                {
                    using (FileStream fs = new FileStream(setting + ".dat", FileMode.Create))
                    {
                        fs.Write(blob, 0, blob.Length);
                    }
                }
            }
        }

        // Gets a setting from the blob table
        private static byte[] GetBlobSetting(string setting, string connectionString)
        {
            using (SqlConnection npdb = new SqlConnection(connectionString))
            {
                npdb.Open();

                // Read certificate template from npdb
                SqlCommand cmd = npdb.CreateCommand();
                cmd.CommandText = "dbo.p_config_blob_get";
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("@vc_config_blob_name", SqlDbType.NVarChar).Value = setting;

                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    if (reader == null || !reader.Read())
                    {
                        return null;
                    }

                    return reader.GetSqlBytes(0).Value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\IUserIdentity.cs ===
﻿using System;

namespace Leet.Identity
{
    /// <summary>
    /// List of valid profile Live tiers.
    /// </summary>
    public enum SubscriptionTier : int
    {
        Unknown = -1,
        None = 0,
        Silver = 3,
        Gold = 6
    }

    public enum AccountType : byte
    {
        None,
        NoAccount,
        Xbox1Linked,
        Xbox1Unlinked,
        Xbox360,
        Xboxcom,
        InProcess,
    }

    /// <summary>
    /// NOTE: Puid, Cid and Xuid are defined as longs instead of
    /// ulongs to avoid FXCop CLS-compliance warnings everywhere
    /// they are used.
    /// </summary>
    public interface IUserIdentity : IFormattable, IEquatable<IUserIdentity>
    {
        long Puid { get; set; }
        long Cid { get; set; }
        ulong Xuid { get; set; }
        SubscriptionTier Tier { get; set; }
        string Gamertag { get; set; }
        AccountType AccountType { get; }
        string IdentityKey { get; }
        bool IsAuthenticated { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\IPpsaCredentialProvider.cs ===
﻿using System;

namespace Leet.Identity
{
    public interface IPpsaCredentialProvider
    {
        string GetNetIDsForSigninNames(string emailAddress);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\IIdentityManager.cs ===
﻿using System;

namespace Leet.Identity
{
    public interface IIdentityManager
    {
        IUserIdentity CreateUserIdentityFromKey(string identityKey);
        IUserIdentity CreateUserIdentityFromPuid(long puid);
        IUserIdentity CreateUserIdentityFromXuid(ulong xuid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\IAudienceUriProvider.cs ===
﻿using System;
using System.Text;

namespace Leet.Identity
{
    public interface IAudienceUriProvider
    {
        string[] AudienceUriList { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\IdentityManager.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="IdentityManager.cs" company="Microsoft" author="roymo">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>IdentityManager</summary>
//-------------------------------------------------------------------------------------------------
namespace Leet.Identity
{
    using System;
    using System.Collections.Generic;
    using Leet.Core.IoCCo;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// IdentityManager class
    /// </summary>
    public class IdentityManager : IIdentityManager
    {
        /// <summary>
        /// Component Name for logging
        /// </summary>
        private const string ComponentName = "IdentityManager";

        /// <summary>
        /// Constant string representing node name returned from IDSAPI
        /// </summary>
        private const string SigninName = "SigninName";

        /// <summary>
        /// Register with IocContainer
        /// </summary>
        /// <param name="container">IContainer container</param>
        public static void RegisterWithIocContainer(IContainer container)
        {
            container.AddService<ILogging, Leet.Core.Diagnostics.Logging>();
            container.AddService<IIdentityManager, IdentityManager>();
            container.AddService<IPpsaCredentialProvider, PpsaCredentialProvider>();
        }

        /// <summary>
        /// accessor property for the ILogging component registered in the IoC container
        /// </summary>
        private static ILogging Log
        {
            get { return IoC.Get<ILogging>(); }
        }

        // TODO: Remove when multiplayer updtates to GetPuidFromEmailAdresses.  Leaving this in so they can update without breaking the build.
        /// <summary>
        /// Given an email address, return the puid if the email address is a valid live id. 0 otherwise.
        /// </summary>
        /// <param name="emailAddress">The email address.</param>
        /// <returns>The corresponding puid. 0 if the email address is not a live ID.</returns>
        public static long GetPuidFromEmailAddress(string emailAddress)
        {
            if (string.IsNullOrEmpty(emailAddress))
            {
                throw new ArgumentException("emailAddress is null or empty");
            }

            long puid = 0;

            var credentialService = Container.Instance.GetComponent<IPpsaCredentialProvider>();

            string credentialXMLString = null;
            System.Xml.XmlNode signinNameNode = null;

            try
            {
                // Call the GetNetIDsForSigninNames method, which returns an xml block of <Name2NETID> containing <SigninName NetID="xxxx">
                credentialXMLString = credentialService.GetNetIDsForSigninNames(emailAddress);

                System.Xml.XmlDocument credentialXML = new System.Xml.XmlDocument();

                // Load the SOAP response as an XmlDocument, so the Document Object Model (DOM)
                // can be used to examine the results.
                credentialXML.LoadXml(credentialXMLString);

                // Check whether we received any info in the Name2NETID node.
                signinNameNode = credentialXML.SelectSingleNode("/Name2NETID/SigninName");
            }
            catch (System.Web.Services.Protocols.SoapException ex)
            {
                // Log the error
                Logging.TraceException(ex,
                    "SoapException caught in method: IdentityManager::GetPuidFromEmailAddress. Exception Detail: {0}",
                    ex.Detail != null ? ex.Detail.OuterXml : string.Empty);
                throw;
            }

            // read the NetId from the response xml
            if (signinNameNode != null)
            {
                string netIdString = null;

                try
                {
                    netIdString = signinNameNode.Attributes["NetID"].InnerText;
                }
                catch (NullReferenceException ex)
                {
                    // Log that NetID attribute was not in the SigninName node
                   Logging.TraceException(ex,
                        "NullReferenceException caught in method: IdentityManager::GetPuidFromEmailAddress");
                }

                if (netIdString != null)
                {
                    try
                    {
                        puid = Convert.ToInt64(netIdString, 16);
                    }
                    catch (FormatException ex)
                    {
                        // Log Exception
                        Logging.TraceException(ex,
                            "FormatException caught in method: IdentityManager::GetPuidFromEmailAddress");
                    }
                    catch (OverflowException ex)
                    {
                        // Log Exception
                        Logging.TraceException(ex,
                            "OverflowException caught in method: IdentityManager::GetPuidFromEmailAddress");
                    }
                }
            }

            return puid;
        }

        /// <summary>
        /// Given a comma delimited string of up to 16 email addresses, finds the puid if the email address is a valid live id.
        /// </summary>
        /// <param name="emailAddresses">The email addresses in a comma deliminated string.</param>
        /// <returns>A dictionary of emailaddresses and puids. The email address and puid is not returned if it is a invalid WLID.</returns>
        public static IDictionary<string, long> GetPuidFromEmailAddresses(string emailAddresses)
        {
            if (string.IsNullOrEmpty(emailAddresses))
            {
                throw new ArgumentException("emailAddresses is null or empty");
            }

            Dictionary<string, long> puids = new Dictionary<string, long>();

            var credentialService = Container.Instance.GetComponent<IPpsaCredentialProvider>();

            string credentialXMLString = null;
            System.Xml.XmlDocument credentialXML = new System.Xml.XmlDocument();
            System.Xml.XmlNode namesNode = null;

            try
            {
                // Call the GetNetIDsForSigninNames method, which returns an xml block of <Name2NETID> containing <SigninName NetID="xxxx">
                credentialXMLString = credentialService.GetNetIDsForSigninNames(emailAddresses);

                // Load the SOAP response as an XmlDocument, so the Document Object Model (DOM)
                // can be used to examine the results.
                credentialXML.LoadXml(credentialXMLString);
                namesNode = credentialXML.SelectSingleNode("/Name2NETID");
            }
            catch (System.Web.Services.Protocols.SoapException ex)
            {
                // Log the error
                Logging.TraceException(ex,
                    "SoapException caught in method: IdentityManager::GetPuidFromEmailAddresses. Exception Detail: {0}",
                    ex.Detail != null ? ex.Detail.OuterXml : string.Empty);
                throw;
            }

            if (namesNode != null)
            {
                foreach (System.Xml.XmlNode signinNameNode in namesNode.ChildNodes)
                {
                    // if the child node is not a SigninName node continue to the next sibling
                    if (signinNameNode.Name != SigninName)
                    {
                        continue;
                    }

                    string netIdString = null;
                    string emailAddress = null;

                    try
                    {
                        netIdString = signinNameNode.Attributes["NetID"].InnerText;
                        emailAddress = signinNameNode.InnerText;
                    }
                    catch (NullReferenceException ex)
                    {
                        // Log that NetID attribute was not in the SigninName node
                        Logging.TraceException(ex,
                            "NullReferenceException caught in method: IdentityManager::GetPuidFromEmailAddresses");
                    }

                    // if the emailAddress or NetId is not available do not add it to the results
                    if (netIdString != null && emailAddress != null)
                    {
                        try
                        {
                            puids.Add(emailAddress.Trim(), Convert.ToInt64(netIdString, 16));
                        }
                        catch (FormatException ex)
                        {
                            // Log Exception
                            Logging.TraceException(ex,
                                "FormatException caught in method: IdentityManager::GetPuidFromEmailAddresses");
                        }
                        catch (OverflowException ex)
                        {
                            // Log Exception
                            Logging.TraceException(ex,
                                "OverflowException caught in method: IdentityManager::GetPuidFromEmailAddresses");
                        }
                    }
                }
            }

            return puids;
        }

        /// <summary>
        /// Creates a user identity from an identity Key
        /// </summary>
        /// <param name="identityKey">string containing hexXuid, hexPuid and hexCid</param>
        /// <returns>returns an IUserIdentity</returns>
        public IUserIdentity CreateUserIdentityFromKey(string identityKey)
        {
            return new UserIdentity(identityKey);
        }

        /// <summary>
        /// Creates a UserIdentity from a puid
        /// </summary>
        /// <param name="puid">long puid of the user</param>
        /// <returns>returns an IUserIdentity</returns>
        public IUserIdentity CreateUserIdentityFromPuid(long puid)
        {
            return new UserIdentity(puid);
        }

        /// <summary>
        /// Creates a UserIdentity from a Xuid
        /// </summary>
        /// <param name="xuid">ulong Xuid of the user</param>
        /// <returns>returns an IUserIdentity</returns>
        public IUserIdentity CreateUserIdentityFromXuid(ulong xuid)
        {
            return new UserIdentity(xuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthAdapter.cs ===
﻿

namespace Leet.Identity.ActiveAuth
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using xonline.common.service;

    public class ActiveAuthAdapter : IActiveAuthAdapter
    {
        public long Cid { get; private set; }

        public long Puid { get; private set; }

        public ulong Xuid { get; private set; }

        private AAInfo info = null; 
        /// <summary>
        /// ctor
        /// Initializes user info from the Active Auth Info context
        /// </summary>
        public ActiveAuthAdapter()
        {
            // HttpContext required for AAInfo to be populated.
            info = AAInfoInternetTier.Current;

            if (info != null)
            {
                this.Cid = (long)info.PassportCId;
                this.Puid = (long)info.PassportPuid;
                this.Xuid = info.LiveXuid;
            }
        }

        /// <summary>
        /// returns true if the privilege is allowed for the user
        /// </summary>
        /// <param name="privilege">int privilege</param>
        /// <returns>True if the current user has the privilege</returns>
        public bool HasPrivilege(int privilege)
        {
            if (info == null)
            {
                info = AAInfoInternetTier.Current;
            }

            return info.HasPrivilege(privilege);
        }

        /// <summary>
        /// Returns the underlying Saml Token. May return null if Active Auth info is missing
        /// </summary>
        public XblSamlToken SamlToken
        {
            get
            {
                if (info != null)
                {
                    return info.XblSamlToken;
                }
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\LiveIdServiceSoapHeader.cs ===
﻿using System;

namespace Leet.Identity
{
    public sealed class LiveIdServiceSoapHeader
    {
        public const string SoapHeaderTemplate =
            "<s:ppSoapHeader xmlns:s=\"http://schemas.microsoft.com/Passport/SoapServices/SoapHeader\" version=\"1.0\">" +
            "  <!-- Mutual SSL authentication SOAP header template -->" +
            "  <!-- <s:credentials /> -->" +
            "  <s:clientIP></s:clientIP>" +
            "  <s:lcid>{0}</s:lcid>" +
            "  <s:authorizationLicence />" +
            "  <s:auditInfo />" +
            "  <s:delegate />" +
            "  <s:sitetoken>" +
            "    <t:siteheader xmlns:t=\"http://schemas.microsoft.com/Passport/SiteToken\" id=\"{1}\" />" +
            "  </s:sitetoken>" +
            "</s:ppSoapHeader>";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\LiveNWebRequestClientIdentifierProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Providers;
using xonline.common.webplatform.livecache;
using xonline.common.service;

namespace Leet.Identity
{
    public class LiveNWebRequestClientIdentifierProvider : IWebRequestClientIdentifierProvider
    {
        #region ILivecacheClientIdentifierProvider Members

        public LivecacheClientType GetClientType()
        {
            return LivecacheClientType.LIVEn;
        }

        public uint GetClientTitleId()
        {
            uint tokenTitleId = XOn.WEB_TITLE_ID;
            try
            {
                //try to get the titleid from the token.
                if (!TokenClaimsHelper.TryGetTokenTitleID(out tokenTitleId))
                {
                    tokenTitleId = XOn.WEB_TITLE_ID;
                }
            }
            catch
            {
                //we ignore any exceptions here because we dont care if we don't have a titleid in the token.
                tokenTitleId = XOn.WEB_TITLE_ID;
            }
            return tokenTitleId;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\TokenClaimsHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.IdentityModel.Claims;
using Leet.Identity;
using Leet.Core.IoCCo;

namespace Leet.Identity
{
    /// <summary>
    /// Helper methods to get claims from the partner token
    /// </summary>
    public static class TokenClaimsHelper
    {
        /// <summary>
        /// Get the titleid from the token and parse it (title id in the token is in hex format)
        /// </summary>
        /// <param name="tokenTitleID"></param>
        /// <returns>returns false if title id is not present in the token or title id is not in the hex format. Otherwise returns true</returns>
        public static bool TryGetTokenTitleID(out UInt32 tokenTitleID)
        {
            Object titleIDObject = null;
            tokenTitleID = 0;
         
            //get the titleid from the token and parse it (title id in the token is in hex format)
            return TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.TitleIdClaimType, out titleIDObject) &&
                UInt32.TryParse(titleIDObject as String, System.Globalization.NumberStyles.HexNumber, System.Globalization.CultureInfo.CurrentUICulture, out tokenTitleID);
        }

        /// <summary>
        /// Get the titleid from the token and parse it (title id in the token is in hex format)
        /// </summary>
        /// <param name="tokenTitleID"></param>
        /// <returns>returns true if platform type is found. Otherwise returns false</returns>
        public static bool TryGetPlatformType(out UInt32 tokenPlatformType)
        {
            Object platformTypeObject = null;
            tokenPlatformType = 0;

            //get the titleid from the token and parse it (title id in the token is in hex format)
            return TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.PlatformClaimType, out platformTypeObject) &&
                UInt32.TryParse(platformTypeObject as String, out tokenPlatformType);
        }

        /// <summary>
        /// Get the list of audience uri's from the token
        /// </summary>
        /// <param name="audienceUris">Audience Uris to return</param>
        /// <returns>Returns true if the token contains any audience uris else returns false</returns>
        public static bool TryGetAudienceUris(out IList<Uri> audienceUris)
        {
            Object audienceUrisObject = null;
            audienceUris = null;

            //get the audience uri list from the token
            if (TryGetClaimValueFromAuthenticationToken(LiveNTokenClaimTypes.AudienceUriClaimType, out audienceUrisObject))
            {
                audienceUris = audienceUrisObject as IList<Uri>;
            }

            return (audienceUris != null);
        }

        /// <summary>
        /// Gets the claim value for a specified claim type from the Authnetication token CliamSet
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="claimType"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool TryGetClaimValueFromAuthenticationToken(String claimType, out Object value)
        {
            if (String.IsNullOrEmpty(claimType))
            {
                throw new ArgumentNullException("claimType");
            }

            IAuthenticationManager authenticationmanager = Container.Instance.GetComponent<IAuthenticationManager>();
            if (!authenticationmanager.IsAuthenticated ||
                authenticationmanager.CurrentUser == null ||
                !authenticationmanager.CurrentUser.IsAuthenticated)
            {
                throw new UnauthorizedAccessException();
            }

            ClaimSet claimSet = authenticationmanager.GetClaims();
            if (claimSet != null)
            {
                IList<Claim> claims = new List<Claim>(claimSet.FindClaims(claimType, Rights.PossessProperty));
                if (claims != null && claims.Count > 0)
                {
                    value = claims[0].Resource;
                    return true;
                }
            }

            value = null;
            return false;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\AuthenticationManager.cs ===
﻿using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.TestSupport;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Account;
using xonline.common.service;
using System.IdentityModel.Claims;
using System.IdentityModel.Tokens;

namespace Leet.Identity.ActiveAuth
{
    [PerWebRequestInstance]
    public class AuthenticationManager : IdentityManager, IAuthenticationManager, ILcAuthManager
    {
        const String PlatformTypeAtrribute = "PlatformType";
        private IActiveAuthAdapter activeAuth;
        private IUserIdentity currentUser;
        private ClaimSet claimSet;

        public AuthenticationManager(IActiveAuthAdapter activeAuthAdapter)
        {
            Debug.Assert(activeAuthAdapter != null, "activeAuthAdapter != null");
            this.activeAuth = activeAuthAdapter;
        }

        public static new void RegisterWithIocContainer(IContainer container)
        {
            IdentityManager.RegisterWithIocContainer(container);
            container.AddService<IAuthenticationManager, AuthenticationManager>();
            container.AddService<ILcAuthManager, AuthenticationManager>();
            container.AddEmulatableService<IActiveAuthAdapter, ActiveAuthAdapter>();
        }

        /// <summary>
        /// Returns the the IUserIdentity object
        /// </summary>
        public IUserIdentity CurrentUser
        {
            get
            {
                //lazy initialize
                if (this.currentUser == null)
                {
                    IUserIdentity user = base.CreateUserIdentityFromPuid(this.activeAuth.Puid);
                    user.Xuid = activeAuth.Xuid;
                    user.Cid = activeAuth.Cid;
                    user.IsAuthenticated = this.IsAuthenticated;
                    this.currentUser = user;
                }
                return this.currentUser;
            }
        }

        /// <summary>
        /// Returns the claimsSet associated with the Active Auth Saml token
        /// </summary>
        /// <returns></returns>
        public ClaimSet GetClaims()
        {
            //lazy initialize the claim set
            if (this.claimSet == null)
            {
                InitClaimSet();
            }

            return this.claimSet;
        }

        private void InitClaimSet()
        {
            XblSamlToken samlToken = this.activeAuth.SamlToken;
            List<Claim> allClaims = new List<Claim>();
            if (this.currentUser != null)
            {
                allClaims.Add(new Claim(LiveNTokenClaimTypes.XuidClaimSetType, this.currentUser, Rights.Identity));
            }
            if (samlToken != null)
            {
                foreach (SamlAttribute attribute in samlToken.Attributes)
                {
                    Claim newClaim = new Claim(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "http://xboxlive.com/claims/{0}", attribute.Name), attribute.AttributeValues[0], Rights.PossessProperty);
                    allClaims.Add(newClaim);
                }
            }
            this.claimSet = new DefaultClaimSet(allClaims);
        }

        public ILcAuthTicket GetAuthTicket()
        {
            return (ILcAuthTicket)this.CurrentUser;
        }

        public bool IsAuthenticated
        {
            get
            {
                long puid = this.activeAuth.Puid;
                return (puid != 0);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\PpsaCredentialProvider.cs ===
﻿
namespace Leet.Identity
{
    using System;
    using System.IO;
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    using System.Xml;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    /// <summary>
    /// PpsaCredentialProvider, implements IPpsaCredentialProvider
    /// </summary>
    [SingletonInstance]
    public class PpsaCredentialProvider : IPpsaCredentialProvider, IDisposable
    {
        bool disposed;

        /// <summary>
        /// private instance of CredentialServiceAPISoapServer
        /// </summary>
        private readonly CredentialServiceAPISoapServer credentialProxy;

        /// <summary>
        /// LCID for use with the SoapHeader
        /// </summary>
        private const string LCID = "1033";

        /// <summary>
        /// Initializes a new instance of the PpsaCredentialProvider class.
        /// </summary>
        public PpsaCredentialProvider()
        {
            var configProvider =
                Container.Instance.GetComponent<IConfigurationProvider>();

            this.credentialProxy =
                new CredentialServiceAPISoapServer();
            
            this.credentialProxy.WSSecurityHeader = new tagWSSECURITYHEADER();

            this.credentialProxy.WSSecurityHeader.ppSoapHeader25 = GenerateSoapHeader();

            this.credentialProxy.Url = 
                configProvider.GetSetting(Settings.PpsaCredentialUrl);

            this.credentialProxy.WSSecurityHeader.version = EnumSHVersion.eshHeader25;

            this.credentialProxy.ClientCertificates.Add(GetX509Certificate());

            if (!string.IsNullOrEmpty(configProvider.GetSetting(Settings.ProxyAddress)))
            {
                this.credentialProxy.Proxy = 
                    new WebProxy(
                        configProvider.GetSetting(Settings.ProxyAddress), 
                        true);
            }
        }

        /// <summary>
        /// Calls GetNetIDsForSigninNames in the PPSACredential Proxy.  
        /// </summary>
        /// <param name="emailAddress">The email address.</param>
        /// <returns>The corresponding puid. 0 if the email address is not a live ID.</returns>
        public string GetNetIDsForSigninNames(string emailAddress)
        {
            return this.credentialProxy.GetNetIDsForSigninNames(emailAddress);
        }

        /// <summary>
        /// Generates a SOAP header for use with the PPSACredential proxy
        /// </summary>
        /// <returns>string Soap Header</returns>
        private static string GenerateSoapHeader()
        {
            var configProvider =
                Container.Instance.GetComponent<IConfigurationProvider>();

            return string.Format(System.Globalization.CultureInfo.CurrentUICulture,
                LiveIdServiceSoapHeader.SoapHeaderTemplate, LCID, configProvider.GetSetting(Settings.PpsaSiteId)); 
        }

        /// <summary>
        /// Get a local x509 certificate
        /// </summary>
        /// <returns>a X509Certificate2 </returns>
        private static X509Certificate2 GetX509Certificate()
        {
            var configProvider =
                Container.Instance.GetComponent<IConfigurationProvider>();

            // Retrieve the thumbprint of the X.509 client certificate
            string certThumbprint = configProvider.GetSetting(Settings.PpsaCertThumbprint);

            // Use the Local Store
            X509Store store = new X509Store(StoreLocation.LocalMachine);

            // Get certificate by thumbprint
            store.Open(OpenFlags.ReadOnly);
            X509Certificate2Collection collection = store.Certificates.Find(X509FindType.FindByThumbprint, certThumbprint, false);
            store.Close();

            if (collection.Count == 1)
            {
                // If found, return the certificate
                return collection[0];
            }
            else
            {
                if (collection.Count > 1)
                {
                    // multiple certs found
                    throw new ApplicationException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "Multiple certs found with thumbprint \"{0}\"", certThumbprint));
                }
                else 
                {
                    // cert not found
                    throw new ApplicationException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "Certificate with thumbprint \"{0}\" not found found", certThumbprint));
                }
            }
        }

        #region IDisposable Members

        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;
                Dispose(true);
                GC.SuppressFinalize(this);
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (this.credentialProxy != null)
                {
                    this.credentialProxy.Dispose();
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\UserIdentity.cs ===
﻿using System;
using System.Globalization;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Account;
using Leet.Live.Livecache.DataAccess;
using xonline.common.protocol;

namespace Leet.Identity
{
    public class UserIdentity : IUserIdentity, ILcAuthTicket, IFormattable, IEquatable<IUserIdentity>
    {
        private IXCacheDataAccess xcache;
        private long puid;
        private long cid;
        private ulong xuid;
        private SubscriptionTier tier;
        private string gamertag = string.Empty;
        private bool isAuthenticated;
        uint[] privileges;
        byte parentalControlGroup;
        AccountType accountType;

        public UserIdentity()
        {
        }

        public UserIdentity(long puid)
        {
            if (puid == 0)
                throw new ArgumentException("Invalid argument creating UserIdentity. Puid cannot be zero.", "puid");

            this.puid = puid;
            this.populateXuidAndGamertag();
        }

        public UserIdentity(long puid, ulong xuid)
        {
            if (puid == 0)
                throw new ArgumentException("Invalid argument creating UserIdentity. Puid cannot be zero.", "puid");

            if (xuid == 0)
                throw new ArgumentException("Invalid argument creating UserIdentity. Xuid cannot be zero.", "xuid");

            this.puid = puid;
            this.xuid = xuid;
        }

        public UserIdentity(ulong xuid)
        {
            if (xuid == 0)
                throw new ArgumentException("Invalid argument creating UserIdentity. Xuid cannot be zero.", "xuid");

            this.xuid = xuid;
        }

        public UserIdentity(string identityKey)
        {
            if (identityKey == null)
            {
                throw new ArgumentNullException("identityKey");
            }
                
            if (identityKey.Length != 48)
            {
                throw new ArgumentException("Invalid identity key");
            }

            string hexXuid = identityKey.Substring(0, 16);
            string hexPuid = identityKey.Substring(16, 16);
            string hexCid = identityKey.Substring(32, 16);

            this.xuid = ulong.Parse(hexXuid, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
            this.puid = long.Parse(hexPuid, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
            this.cid = long.Parse(hexCid, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
        }

        public IXCacheDataAccess XCache
        {
            get
            {
                if (this.xcache == null)
                {
                    this.xcache = Container.Instance.GetComponent<IXCacheDataAccess>();
                }
                return this.xcache;
            }

            set
            {
                this.xcache = value;
            }
        }

        public long Puid
        {
            get
            {
                return this.puid;
            }

            set
            {
                this.puid = value;
            }
        }

        public long Cid
        {
            get
            {
                return this.cid;
            }

            set
            {
                this.cid = value;
            }
        }

        public ulong Xuid
        {
            get
            {
                if (this.xuid == 0)
                {
                    this.populateXuidAndGamertag();
                }
                return this.xuid;
            }

            set
            {
                this.xuid = value;
            }
        }

        public SubscriptionTier Tier
        {
            get
            {
                if (this.tier == SubscriptionTier.None)
                {
                    this.populateXboxLiveAccountInfo();
                }
                return this.tier;
            }

            set
            {
                this.tier = value;
            }
        }

        public AccountType AccountType
        {
            get
            {
                if (this.accountType == AccountType.None)
                {
                    this.populateXboxLiveAccountInfo();
                }
                return this.accountType;
            }

            set
            {
                this.accountType = value;
            }
        }

        public string Gamertag
        {
            get
            {
                if (string.IsNullOrEmpty(this.gamertag))
                {
                    this.populateXuidAndGamertag();
                }
                return this.gamertag;
            }

            set
            {
                this.gamertag = value;
            }
        }

        public string IdentityKey
        {
            get
            {
                return this.ToString("G", CultureInfo.InvariantCulture);
            }
        }

        public bool IsAuthenticated
        {
            get
            {
                return this.isAuthenticated;
            }

            set
            {
                this.isAuthenticated = value;
            }
        }

        ulong ILcAuthTicket.Puid
        {
            get { return (ulong)this.Puid; }
        }

        public uint[] Privileges
        {
            get
            {
                this.populateXboxLiveAccountInfo();
                return this.privileges;
            }
        }

        public ulong LivePuid
        {
            get { return this.Xuid; }
        }

        uint ILcAuthTicket.Tier
        {
            get { return (uint)this.Tier; }
        }

        public int ParentalControlGroup
        {
            get
            {
                this.populateXboxLiveAccountInfo();
                return this.parentalControlGroup;
            }
        }


// Methods to customize ToString functionality
//
// The multiplayer system needs .ToString to return a compact unique identifier
// for the user.
#region IFormattable

        public override string ToString()
        {
            return this.ToString("G", CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return this.ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (String.IsNullOrEmpty(format)) format = "G";
            if (formatProvider == null) formatProvider = CultureInfo.InvariantCulture;

            switch (format.ToUpperInvariant())
            {
                case "G":
                    return
                        this.xuid.ToString("X16", formatProvider) +
                        this.puid.ToString("X16", formatProvider) +
                        this.cid.ToString("X16", formatProvider);

                default:
                    throw new FormatException(String.Format(CultureInfo.CurrentCulture, "The '{0}' format string is not supported.", format));
            }

        }

#endregion

// Methods to customize .Equals functionality and == operators
//
// The multiplayer system needs .ToEquals to be able to compare two UserIdentity
// objects and indicate whether they represent the same user.
#region IEquatable

        public bool Equals(IUserIdentity other)
        {
            if (other == null)
                return base.Equals(other);

            if ((this.Xuid != 0) && (other.Xuid != 0))
                return (this.Xuid == other.Xuid);
            else
                return (this.Puid == other.Puid);
        }

        public override bool Equals(Object obj)
        {
            if (obj == null)
                return base.Equals(obj);

            if (obj is IUserIdentity)
                return Equals(obj as IUserIdentity);
            else
                return false;
        }

        public override int GetHashCode()
        {
            if (this.Xuid != 0)
                return this.xuid.GetHashCode();
            else
                return this.Puid.GetHashCode();
        }

#endregion


        private void populateXuidAndGamertag()
        {
            ulong xcXuid;
            string xcGamertag;

            if (this.puid != 0)
            {
                if (this.XCache.LookupWebID((ulong)this.puid, out xcXuid, out xcGamertag))
                {
                    this.xuid = xcXuid;
                    this.gamertag = xcGamertag;
                }
            }
            else if (this.xuid != 0)
            {
                if (this.XCache.GetGamertagByPuid(this.xuid, out xcGamertag))
                {
                    this.gamertag = xcGamertag;
                }
            }
        }

        private void populateXboxLiveAccountInfo()
        {
            if (this.privileges == null)
            {
                uint[] lcPrivileges = null;
                byte lcParentalControlGroup;
                uint lcTier;
                DateTime lcLastActivity;
                bool lcIsLightAcct;
                bool lcIsProvisioned;
                byte lcAccountType;
                bool isFreeGamertagChangeEligible;
                bool isParentallyControlled;

                IAccountCreationDataAccess acda = Container.Instance.GetComponent<IAccountCreationDataAccess>();
                acda.GetUserWebInfo(this.Xuid, ServiceTypeEnum.XboxLive, out lcTier, out lcPrivileges, out lcLastActivity, out lcParentalControlGroup, out lcIsLightAcct, out lcIsProvisioned, out lcAccountType, out isFreeGamertagChangeEligible, out isParentallyControlled);
                this.tier = (SubscriptionTier)lcTier;
                this.privileges = lcPrivileges;
                this.parentalControlGroup = lcParentalControlGroup;
                this.accountType = UserTypeToAccountType((xonline.common.user.UserTypeEnum)lcAccountType);
            }
        }

        private static AccountType UserTypeToAccountType(xonline.common.user.UserTypeEnum userType)
        {
            switch (userType)
            {
                case xonline.common.user.UserTypeEnum.Xbox1LinkedUser:
                    return AccountType.Xbox1Linked;
                case xonline.common.user.UserTypeEnum.Xbox1User:
                    return AccountType.Xbox1Unlinked;
                case xonline.common.user.UserTypeEnum.XenonUser:
                    return AccountType.Xbox360;
                case xonline.common.user.UserTypeEnum.XboxComUser:
                    return AccountType.Xboxcom;
                default:
                    return AccountType.None;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\LiveNTokenClaimTypes.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Identity
{
    public static class LiveNTokenClaimTypes
    {
        public const String IssuerClaimType = "http://xboxlive.com/claims/Issuer";
        public const String PartnerIDClaimType = "http://xboxlive.com/claims/PartnerID0";
        public const String PlatformClaimType = "http://xboxlive.com/claims/PlatformType";
        public const String XuidClaimSetType = "http://xboxlive.com/claims/Xuid0";
        public const String PuidClaimSetType = "http://xboxlive.com/claims/Puid0";
        public const String CIDClaimSetType = "http://xboxlive.com/claims/CID0";
        public const String SubjectNameClaimType = "http://xboxlive.com/claims/Subject";
        public const String MajorVersionClaimType = "http://xboxlive.com/claims/MajorVersion";
        public const String ClientVersionClaimType = "http://xboxlive.com/claims/ClientVersion";
        public const String MinorVersionClaimType = "http://xboxlive.com/claims/MinorVersion";
        public const String IssuerInstantClaimType = "http://xboxlive.com/claims/IssuerInstant";
        public const String TitleIdClaimType = "http://xboxlive.com/claims/TitleID";
        public const String TitleVersionClaimType = "http://xboxlive.com/claims/TitleVersion";
        public const String DeviceIDClaimType = "http://xboxlive.com/claims//DeviceID";
        public const String MachineIDClaimType = "http://xboxlive.com/claims//MachineID";
        public const String GamertagClaimType = "http://xboxlive.com/claims/Gamertag0";
        public const String CountryClaimType = "http://xboxlive.com/claims/Country0";
        public const String TierClaimType = "http://xboxlive.com/claims/Tier0";
        public const String PrivilegesClaimType = "http://xboxlive.com/claims/Privileges0";
        public const String AudienceUriClaimType = "http://xboxlive.com/claims/AudienceUri";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\AAWInfo.cs ===
﻿using System;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    public class AAWInfo
    {
        public AAWInfo(UInt64 xuid)
        {
            this.Xuid = xuid;
        }
        public UInt64 Xuid
        {
            get;
            internal set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Identity.ActiveAuth")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Identity.ActiveAuth.Wrapper")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Identity.ActiveAuth")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "AAW", Scope = "type", Target = "Leet.Identity.ActiveAuth.Wrapper.AAWInfo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "AAW", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthModuleWrapper.#AAWInfo")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperHttpApplication.#containedApplication")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#configProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#.cctor()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "UnAuthorized", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#CreateUnAuthorizedResponse(System.Web.HttpContext)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Un", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#CreateUnAuthorizedResponse(System.Web.HttpContext)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "AUTH", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#PASSPORT_AUTH_SCHEME_TOKEN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "PASSPORT", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#PASSPORT_AUTH_SCHEME_TOKEN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "SCHEME", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#PASSPORT_AUTH_SCHEME_TOKEN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "TOKEN", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#PASSPORT_AUTH_SCHEME_TOKEN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#PASSPORT_AUTH_SCHEME_TOKEN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "WWW", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ResponseHelper.#WWWAuthenticateHeader")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "System.UInt64.TryParse(System.String,System.UInt64@)", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.TokenRouter.#AuthenticateClientCertificate(System.Web.HttpApplication)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.TokenRouter.#AuthenticateClientCertificate(System.Web.HttpApplication)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "AAW", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#AAWInfoKey")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#GetClientCertificateIssuer()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#GetClientCertificateSubject()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#GetExpirationTimeSkew()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "PATTERN", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#XBL_PREFIX_PATTERN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "PREFIX", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#XBL_PREFIX_PATTERN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1707:IdentifiersShouldNotContainUnderscores", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#XBL_PREFIX_PATTERN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "XBL", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.ActiveAuthWrapperConfiguration.#XBL_PREFIX_PATTERN")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.ActiveAuth.Wrapper.TokenRouter.#AuthenticateClientCertificate(System.Web.HttpApplication)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Saml", Scope = "member", Target = "Leet.Identity.ActiveAuth.IActiveAuthAdapter.#SamlToken")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\IActiveAuthAdapter.cs ===
﻿namespace Leet.Identity.ActiveAuth
{
    /// <summary>
    /// Interface for getting Puid and Xuid via the ActiveAuth Module
    /// </summary>
    public interface IActiveAuthAdapter
    {
        /// <summary>
        /// Gets the Cid
        /// </summary>
        long Cid { get; }

        /// <summary>
        /// Gets the Puid
        /// </summary>
        long Puid { get; }

        /// <summary>
        /// Gets the Xuid
        /// </summary>
        ulong Xuid { get; }

        /// <summary>
        /// returns true if the privilege is allowed for the user
        /// </summary>
        /// <param name="privilege">int privilege</param>
        /// <returns>True if the current user has the privilege</returns>
        bool HasPrivilege(int privilege);

        /// <summary>
        /// Returns the underlying Saml Token
        /// </summary>
        xonline.common.service.XblSamlToken SamlToken
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\ActiveAuthWrapperHttpApplication.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    internal class ActiveAuthWrapperHttpApplication : HttpApplication
    {
        HttpApplication containedApplication;
        public ActiveAuthWrapperHttpApplication(HttpApplication httpApplication)
        {
            this.containedApplication = httpApplication;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\ActiveAuthModuleWrapper.cs ===
﻿using System;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Collections.Generic;
using System.Web;
using System.Text;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using xonline.server.activeauth.module;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    public sealed class ActiveAuthModuleWrapper : IHttpModule
    {
        private TokenRouter tokenRouter;
        private ActiveAuthModule aamodule;

        public ActiveAuthModuleWrapper()
        {
            aamodule = new ActiveAuthModule();
            this.tokenRouter = new TokenRouter(this.aamodule);
        }
        
        #region IHttpModule Members

        void IHttpModule.Dispose()
        {
            //TODO: Clean upww
        }

        void IHttpModule.Init(HttpApplication context)
        {
            Init(context);
        }
        
        #endregion

        void Init(HttpApplication context)
        {
            context.Error += new EventHandler(ApplicationContext_Error);
            context.BeginRequest += new EventHandler(ApplicationContext_BeginRequest);
            context.AuthenticateRequest += new EventHandler(ApplicationContext_AuthenticateRequest);
            context.EndRequest += new EventHandler(ApplicationContext_EndRequest);

            this.aamodule.Init(new ActiveAuthWrapperHttpApplication(context));
        }

        void ApplicationContext_BeginRequest(object sender, EventArgs e)
        {
        }

        void ApplicationContext_AuthenticateRequest(object sender, EventArgs e)
        {
            HttpApplication httpApplication = sender as HttpApplication;
            Debug.Assert(httpApplication != null, "httpApplication is null");
            this.tokenRouter.RouteAuthenticationToken(httpApplication, e);
        }

        void ApplicationContext_Error(object sender, EventArgs e)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(new UnhandledExceptionEvent());
        }

        void ApplicationContext_EndRequest(object sender, EventArgs e)
        {
            HttpApplication httpApplication = sender as HttpApplication;
            Debug.Assert(httpApplication != null, "httpApplication is null");
            this.tokenRouter.EndRequest(httpApplication, e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\ResponseHelper.cs ===
﻿using System;
using System.Web;
using System.Net;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    public static class ResponseHelper
    {
        public const String PASSPORT_AUTH_SCHEME_TOKEN = "WLID1.0";
        public const String AuthModuleVersion = "1.0";
        public const String Realm = "XboxLive";
        public const String WWWAuthenticateHeader = "WWW-Authenticate";

        public static void CreateUnAuthorizedResponse(HttpContext httpContext)
        {
            string wwwAuthenticateHeader = String.Format(System.Globalization.CultureInfo.CurrentUICulture,
                  "{0} realm=\"{1}\" ver=\"{2}\"",
                  PASSPORT_AUTH_SCHEME_TOKEN,
                  Realm,
                  AuthModuleVersion);

            httpContext.Response.ClearHeaders();
            httpContext.Response.StatusCode = (Int32)HttpStatusCode.Unauthorized; //401
            httpContext.Response.AddHeader(WWWAuthenticateHeader, wwwAuthenticateHeader); //this is needed as per http spec when status code is 401
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\ConfigurationProvider.cs ===
﻿using System;
using System.Configuration;
using System.Diagnostics;
using Leet.Core;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    public static class ActiveAuthWrapperConfiguration
    {
        private static IConfigurationProvider configProvider;
        private static ActiveAuthWrapperConfigurationSection wrapperConfigurationSection;

        public const String ActiveAuthWrapperConfigurationSection = "activeAuthWrapperConfigurationSection";
        public const String UserIdentityAuthenticationMode = "UserIdentity";
        
        public const String XBL_PREFIX_PATTERN = @"^XBL1.0 x=";
        public const String UserIdentityHeader = "X-Authorization";
        public const String XuidHeader = "X-Xuid";


        static ActiveAuthWrapperConfiguration()
        {
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            wrapperConfigurationSection =
                ConfigurationManager.GetSection(ActiveAuthWrapperConfigurationSection) as ActiveAuthWrapperConfigurationSection;
        }

        /// <summary>
        /// This will get client certificate subject from the config file
        /// </summary>
        /// <returns></returns>
        public static String GetClientCertificateSubject()
        {
            if (wrapperConfigurationSection != null && wrapperConfigurationSection.ClientCertificate != null)
            {
                return wrapperConfigurationSection.ClientCertificate.Subject;
            }
            return String.Empty;
        }

        /// <summary>
        /// This will get client certificate issuer from the config file
        /// </summary>
        /// <returns></returns>
        public static String GetClientCertificateIssuer()
        {
            if (wrapperConfigurationSection != null && wrapperConfigurationSection.ClientCertificate != null)
            {
                return wrapperConfigurationSection.ClientCertificate.Issuer;
            }
            return String.Empty;
        }

        public static Double GetExpirationTimeSkew()
        {
            if (wrapperConfigurationSection != null && wrapperConfigurationSection.ClientCertificate != null)
            {
                return wrapperConfigurationSection.ClientCertificate.ExpirationTimeSkew;
            }
            return (double)0;
        }
    }

    public class ActiveAuthWrapperConfigurationSection : ConfigurationSection
    {
        [ConfigurationProperty("clientCertificate")]
        public ClientCertificate ClientCertificate
        {
            get
            {
                return (ClientCertificate)this["clientCertificate"];
            }
            set
            {
                this["clientCertificate"] = value;
            }
        }
    }

    public class ClientCertificate : ConfigurationElement
    {
        [ConfigurationProperty("issuer")]
        public String Issuer
        {
            get
            {
                return (String)this["issuer"];
            }
            set
            {
                this["issuer"] = value;
            }

        }

        [ConfigurationProperty("subject")]
        public String Subject
        {
            get
            {
                return (String)this["subject"];
            }
            set
            {
                this["subject"] = value;
            }

        }

        [ConfigurationProperty("expirationTimeSkew")]
        public Double ExpirationTimeSkew
        {
            get
            {
                return (Double)this["expirationTimeSkew"];
            }
            set
            {
                this["expirationTimeSkew"] = value;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\ActiveAuthWrapperAuthManager.cs ===
﻿using System;
using System.Web;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.TestSupport;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Account;
using xonline.common.service;
using System.IdentityModel.Claims;
using System.IdentityModel.Tokens;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    [PerWebRequestInstance]
    public class ActiveAuthWrapperAuthManager : IdentityManager, IAuthenticationManager, ILcAuthManager
    {
        private IUserIdentity currentUser;
        private AAInfo info;
        private ClaimSet claimSet;

        public ActiveAuthWrapperAuthManager()
        {
            Init();
        }

        public static new void RegisterWithIocContainer(IContainer container)
        {
            IdentityManager.RegisterWithIocContainer(container);
            container.AddService<IAuthenticationManager, ActiveAuthWrapperAuthManager>();
            container.AddService<ILcAuthManager, ActiveAuthWrapperAuthManager>();
        }

        public IUserIdentity CurrentUser
        {
            get
            {
                return this.currentUser;
            }
        }

        public ILcAuthTicket GetAuthTicket()
        {
            return (ILcAuthTicket)this.currentUser;
        }

        public bool IsAuthenticated
        {
            get
            {
                return (this.currentUser != null && this.currentUser.IsAuthenticated);
            }
        }

        public System.IdentityModel.Claims.ClaimSet GetClaims()
        {
            return this.claimSet;
        }

        private void Init()
        {
            if (this.currentUser == null)
            {
                IUserIdentity user = null;

                // HttpContext required for AAInfo to be populated.
                info = AAInfoInternetTier.Current;
                if (info != null)
                {
                    user = base.CreateUserIdentityFromPuid((long)info.PassportPuid);
                    user.Cid = (long)info.PassportCId;
                    user.Xuid = info.LiveXuid;
                    user.IsAuthenticated = true;
                }
                else
                {
                    ulong xuid = 0;
                    if (ulong.TryParse(HttpContext.Current.Request.Headers[ActiveAuthWrapperConfiguration.XuidHeader], out xuid))
                    {
                        user = base.CreateUserIdentityFromXuid(xuid);
                        user.IsAuthenticated = true;
                        this.claimSet = InitClaimSet();
                    }
                }

                this.currentUser = user;
            }
        }

        //only for Active Auth
        private ClaimSet InitClaimSet()
        {
           
            List<Claim> allClaims = new List<Claim>();
            if (this.currentUser != null)
            {
                allClaims.Add(new Claim(LiveNTokenClaimTypes.XuidClaimSetType, this.currentUser, Rights.Identity));
            }
            
            if (this.info != null)
            {
                XblSamlToken samlToken = this.info.XblSamlToken;
                if (samlToken != null)
                {
                    foreach (SamlAttribute attribute in samlToken.Attributes)
                    {
                        Claim newClaim = new Claim(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "http://xboxlive.com/claims/{0}", attribute.Name), attribute.AttributeValues[0], Rights.PossessProperty);
                        allClaims.Add(newClaim);
                    }
                }
            }
            return new DefaultClaimSet(allClaims);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\ActiveAuthModuleWrapper\TokenRouter.cs ===
﻿using System;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Collections.Generic;
using System.Web;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using xonline.server.activeauth.module;

namespace Leet.Identity.ActiveAuth.Wrapper
{
    internal class TokenRouter
    {
        private MethodInfo authenticateRequestMethodInfo;
        private MethodInfo endRequestMethodInfo;
        private IHttpModule aamodule;
      
        public TokenRouter(ActiveAuthModule activeAuthModule)
        {
            this.aamodule = activeAuthModule;
            authenticateRequestMethodInfo = aamodule.GetType().GetMethod("Application_AuthenticateRequest", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public);
            endRequestMethodInfo = aamodule.GetType().GetMethod("Application_EndRequest", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public);
            Debug.Assert(authenticateRequestMethodInfo != null, "authenticateRequestMethodInfo");
            Debug.Assert(endRequestMethodInfo != null, "endRequestMethodInfo");
        }
        
        public void RouteAuthenticationToken(HttpApplication httpApplication, EventArgs e)
        {
            HttpRequest currentRequest = httpApplication.Context.Request;
            if ((currentRequest.Headers[ActiveAuthWrapperConfiguration.UserIdentityHeader] == null) &&
                (currentRequest.ClientCertificate != null && currentRequest.ClientCertificate.Certificate.Length > 0))
            {
                AuthenticateClientCertificate(httpApplication);
            }
            else
            {
                AuthenticateUserToken(httpApplication, e);
            }
        }

        public void EndRequest(HttpApplication application, EventArgs e)
        {
            Debug.Assert(endRequestMethodInfo != null, "endRequestMethodInfo");
            this.endRequestMethodInfo.Invoke(aamodule, new Object[] { application as Object, e });
        }

        private void AuthenticateClientCertificate(HttpApplication httpApplication)
        {
            bool passedValidation = false;

            try
            {
                HttpRequest currentRequest = httpApplication.Context.Request;
                
                UInt64 xuid = 0;
                UInt64.TryParse(currentRequest.Headers[ActiveAuthWrapperConfiguration.XuidHeader], out xuid);

                if (xuid == 0)
                {
                    passedValidation = false;
                    Logging.TraceInformation("X-Xuid header is either missing or the value is 0");
                    return;
                }

                HttpClientCertificate clientCertificate = currentRequest.ClientCertificate;
                Debug.Assert(clientCertificate != null);
                Debug.Assert(clientCertificate.Certificate.Length > 0);

                X509Certificate2 x509Certificate = new X509Certificate2(clientCertificate.Certificate);
                
                //right now we will only validate subject/issuer and time as per requirement.
                //Expiration checks 
                DateTime nowUtc = DateTime.UtcNow;
                if (nowUtc < (x509Certificate.NotBefore.AddMinutes(-ActiveAuthWrapperConfiguration.GetExpirationTimeSkew())) ||
                    nowUtc > (x509Certificate.NotAfter.AddMinutes(ActiveAuthWrapperConfiguration.GetExpirationTimeSkew())))
                {
                    passedValidation = false;
                    Logging.TraceInformation("Client certificate is expired");
                    return;
                }

                //validate subject
                String expectedSubject = ActiveAuthWrapperConfiguration.GetClientCertificateSubject();

                if (x509Certificate.SubjectName.Name.IndexOf(expectedSubject, StringComparison.OrdinalIgnoreCase) == -1)
                {
                    passedValidation = false;
                    Logging.TraceInformation("Certificate subject does not match expected subject");
                    return;
                }

                //validate issuer
                String expectedIssuer = ActiveAuthWrapperConfiguration.GetClientCertificateIssuer();

                if (x509Certificate.IssuerName.Name.IndexOf(expectedIssuer, StringComparison.OrdinalIgnoreCase) == -1)
                {
                    passedValidation = false;
                    Logging.TraceInformation("Certificate issuer does not match expected issuer");
                    return;
                }

                passedValidation = true;
            }
            catch (Exception ex)
            {
                passedValidation = false;
                Logging.TraceException(ex, "Unknown error. Failed request validation");
            }
            finally
            {
                if (!passedValidation)
                {
                    ResponseHelper.CreateUnAuthorizedResponse(httpApplication.Context);
                    httpApplication.CompleteRequest();
                }
            }
        }

        private void AuthenticateUserToken(HttpApplication httpApplication, EventArgs e)
        {
            Debug.Assert(endRequestMethodInfo != null, "endRequestMethodInfo");
            this.authenticateRequestMethodInfo.Invoke(aamodule, new Object[] { httpApplication as Object, e });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.ActiveAuth\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Resources;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.ActiveAuth")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("aa4853db-09f5-4330-917f-ff3c14f65dfa")]

[assembly: System.CLSCompliant(false)]

[assembly: NeutralResourcesLanguageAttribute("en")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.PartnerAuth\AuthenticationManager.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IdentityModel.Policy;
using System.IdentityModel.Claims;
using Leet.Core.TestSupport;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Account;
using Leet.Core.Configuration;
using Leet.Identity.TokenAuthentication.IdentityModel;

namespace Leet.Identity.PartnerAuth
{
    [PerWebRequestInstance]
    public class AuthenticationManager : IdentityManager, IAuthenticationManager, ILcAuthManager
    {
        private IPartnerAuthAdapter partnerAuthAdapter;
        AuthorizationContext partnerAuthContext;
        private IUserIdentity currentUser;
        ClaimSet partnerAuthClaimSet;

        public AuthenticationManager(IPartnerAuthAdapter partnerAuthAdapter)
        {
            this.partnerAuthAdapter = partnerAuthAdapter;
            InitClaimSet();
        }

        public static new void RegisterWithIocContainer(IContainer container)
        {
            IdentityManager.RegisterWithIocContainer(container);

            container.AddService<IAuthenticationManager, Leet.Identity.PartnerAuth.AuthenticationManager>();
            container.AddService<ILcAuthManager, Leet.Identity.PartnerAuth.AuthenticationManager>();
            container.AddEmulatableService<IPartnerAuthAdapter, PartnerAuthAdapter>();
        }

        #region IAuthenticationManager Members

        /// <summary>
        /// Returns a IUserIdentity object created by authenticating with a valid
        /// STS User Token.
        /// </summary>
        public IUserIdentity CurrentUser
        {
            get 
            {
                return this.currentUser;
            }
        }

        /// <summary>
        /// Returns true if user authenticates with a valid STS User Token
        /// </summary>
        public bool IsAuthenticated
        {
            get 
            {
                return (this.currentUser!= null && this.currentUser.IsAuthenticated);
            }
        }


        /// <summary>
        /// Returns Claims
        /// </summary>
        /// <returns></returns>
        public ClaimSet GetClaims()
        {
            return this.partnerAuthClaimSet;
        }

        #endregion

        #region ILcAuthManager Members

        public ILcAuthTicket GetAuthTicket()
        {
            return (ILcAuthTicket)this.CurrentUser;
        }

        #endregion

        private void InitClaimSet()
        {
            if (this.partnerAuthAdapter != null && 
                this.partnerAuthAdapter.PartnerTokenContext != null)
            {
                this.partnerAuthContext = this.partnerAuthAdapter.PartnerTokenContext;
                if (this.partnerAuthContext.ClaimSets != null && this.partnerAuthContext.ClaimSets.Count > 0)
                {
                    ClaimSet claimSet = this.partnerAuthContext.ClaimSets[0];
                    Claim identityClaim = LiveNTokenIdentityModel.FindIdentityClaim(claimSet);
                    UInt64 xuid = 0;
                    if (identityClaim != null && UInt64.TryParse(identityClaim.Resource as String, out xuid))
                    {
                        PartnerIdentity partnerIdentity = new PartnerIdentity(xuid);
                        partnerIdentity.IsAuthenticated = true;
                        this.currentUser = partnerIdentity as IUserIdentity;

                        SetUpIdentityValues(partnerIdentity, claimSet);
                    }

                    this.partnerAuthClaimSet = claimSet;
                }
            }
        }

        private static void SetUpIdentityValues(PartnerIdentity partnerIdentity, ClaimSet claimSet)
        {
             foreach (Claim claim in claimSet)
                {
                    switch (claim.ClaimType)
                    {
                        case (LiveNTokenClaimTypes.GamertagClaimType):
                            {
                                partnerIdentity.Gamertag = claim.Resource as String ?? String.Empty;
                                break;
                            }
                        case (LiveNTokenClaimTypes.TitleIdClaimType):
                            {
                                partnerIdentity.TitleId = claim.Resource as String ?? String.Empty;
                                break;
                            }
                        case (LiveNTokenClaimTypes.TitleVersionClaimType):
                            {
                                partnerIdentity.TitleVersion = claim.Resource as String ?? String.Empty;
                                break;
                            }
                    }

                }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.PartnerAuth\IPartnerIdentity.cs ===
﻿using System;
namespace Leet.Identity.PartnerAuth
{
    public interface IPartnerIdentity
    {
        UInt64 PartnerID { get; }
        
        string TitleVersion
        { get; }

        string TitleId
        { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.PartnerAuth\PartnerAuthAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Web;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Identity.PartnerAuth.Diagnostics;
using System.IdentityModel.Tokens;
using System.IdentityModel.Policy;
using Leet.Identity.TokenAuthentication;

namespace Leet.Identity.PartnerAuth
{
    public interface IPartnerAuthAdapter
    {
        AuthorizationContext PartnerTokenContext { get; }        
    }

    /// <summary>
    /// Return the current Security Context from the LiveNTokenAuthenticationModule
    /// </summary>
    public class PartnerAuthAdapter : IPartnerAuthAdapter
    {

        #region IPartnerAuthAdapter Members

        public AuthorizationContext PartnerTokenContext
        {
            get {
                return LiveNTokenAuthenticationModule.ServiceSecurityContext;   
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.PartnerAuth\Diagnostics\PartnerAuthEvents.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Leet.Core.Diagnostics;

namespace Leet.Identity.PartnerAuth.Diagnostics
{
    // TODO:  Rationalize these event IDs
    public class PartnerAuthEvents
    {
        public class AuthenticationFailure : BaseEvent
        {
            public AuthenticationFailure() :
                base(997, TraceEventType.Error)
            {}
        }

        public class InvalidArgument : BaseEvent
        {
            public InvalidArgument() :
                base(998, TraceEventType.Error)
            { }
        }

        public class SecurityTokenValidationFailure : BaseEvent
        {
            public SecurityTokenValidationFailure() :
                base(999, TraceEventType.Error)
            { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.PartnerAuth\PartnerIdentity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IdentityModel.Policy;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Identity.PartnerAuth
{
    public class PartnerIdentity : UserIdentity, IPartnerIdentity
    {
        public PartnerIdentity(UInt64 xuid)
            :base(xuid)
        {
            this.PartnerID = xuid;
            base.Cid = 0;
            base.Puid = 0;
            base.AccountType = AccountType.None;
            base.Tier = SubscriptionTier.Unknown;
        }

        #region IPartnerIdentity Members

        public UInt64 PartnerID 
        { get; internal set; }

        public string TitleVersion
        { get; internal set; }

        public string TitleId
        { get; internal set; }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.PartnerAuth\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.PartnerAuth")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d884f43c-555d-48d0-a935-30914da91be1")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\ResponseHelper.cs ===
﻿using System;
using System.Web;
using System.Net;
using Leet.Identity.TokenAuthentication.Diagnostics;

namespace Leet.Identity.TokenAuthentication
{
    public static class ResponseHelper
    {
        /// <summary>
        /// Sets up an unauthorized Response
        /// </summary>
        /// <param name="httpContext"></param>
        public static void CreateUnauthorizedResponse(HttpContext httpContext)
        {
            string wwwAuthenticateHeader = String.Format(System.Globalization.CultureInfo.CurrentUICulture,
                  "{0} realm=\"{1}\" ver=\"{2}\"",
                  Configuration.PASSPORT_AUTH_SCHEME_TOKEN,
                  Configuration.Realm,
                  Configuration.PartnerAuthModuleVersion);  //TODO: to make sure if values are correct here

            httpContext.Response.ClearHeaders();
            httpContext.Response.StatusCode = (Int32)HttpStatusCode.Unauthorized; //401
            httpContext.Response.AddHeader("WWW-Authenticate", wwwAuthenticateHeader); //this is needed as per http spec when status code is 401
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication.Diagnostics")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication.Diagnostics")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication.IdentityModel")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication.IdentityModel")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Leet.Identity.TokenAuthentication.LiveNTokenAuthenticationModule.#ValidateRequest(System.Web.HttpApplication)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.TokenAuthentication.LiveNTokenAuthenticationModule.#ValidateRequest(System.Web.HttpApplication)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Un", Scope = "member", Target = "Leet.Identity.TokenAuthentication.ResponseHelper.#CreateUnAuthorizedResponse(System.Web.HttpContext)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "UnHandled", Scope = "type", Target = "Leet.Identity.TokenAuthentication.Diagnostics.UnHandledExceptionEvent")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Un", Scope = "type", Target = "Leet.Identity.TokenAuthentication.Diagnostics.UnHandledExceptionEvent")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNPartnerTokenAuthenticator.#VerifyCritical(System.IdentityModel.Tokens.SamlSecurityToken)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNPartnerTokenAuthenticator+ThumbPrintValidator.#GetCertificateBySubjectName()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNPartnerTokenAuthenticator+TokenAuthorizationPolicy.#VerifyAndCreateClaim(System.String,System.String,System.String,System.String,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Saml", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNTokenIdentityModel.#ValidatePartnerSamlToken(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "saml", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNTokenIdentityModel.#ValidatePartnerSamlToken(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.Configuration.#.cctor()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication.Diagnostics")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Identity.TokenAuthentication.IdentityModel")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.TokenAuthentication.LiveNTokenAuthenticationModule.#OvverideAuthentication(System.Web.HttpRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1010:CollectionsShouldImplementGenericInterface", Scope = "type", Target = "Leet.Identity.TokenAuthentication.Diagnostics.PathOverridesElementCollection")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Scope = "type", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#.ctor(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#.ctor(System.String,System.Exception)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#.ctor(System.String,System.Exception)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "STS", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#CreateSTSCertificateNotFoundException()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "STS", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#CreateMultipleSTSCertificatesFoundException()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "STS", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#CreateMultipleSTSCertificatesFoundException(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "STS", Scope = "member", Target = "Leet.Identity.TokenAuthentication.Diagnostics.SecurityStoreConfigurationException.#CreateSTSCertificateNotFoundException(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNPartnerTokenAuthenticator+TokenAuthorizationPolicy.#GetAudiences(System.IdentityModel.Tokens.SamlSecurityToken)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames", MessageId = "samlToken", Scope = "member", Target = "Leet.Identity.TokenAuthentication.IdentityModel.LiveNPartnerTokenAuthenticator+TokenAuthorizationPolicy.#GetAudiences(System.IdentityModel.Tokens.SamlSecurityToken)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\Diagnostics\AuthEvents.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Leet.Core.Diagnostics;

namespace Leet.Identity.TokenAuthentication.Diagnostics
{
    /// <summary>
    /// Indicates a HttpApplication Error event. The event does not contain any information
    /// </summary>
    public class HttpApplicationErrorEvent : BaseEvent
    {
        public HttpApplicationErrorEvent() :
            base(990, TraceEventType.Error)
        { }
    }

    /// <summary>
    /// Thrown when unhandled exception is caught within the module.
    /// </summary>
    public class UnHandledExceptionEvent : BaseEvent
    {
        public UnHandledExceptionEvent() :
            base(991, TraceEventType.Error)
        { }
    }

    /// <summary>
    /// Thrown when we have an invalid certificate configuration like no sts cert or multiple certs with same subject name
    /// </summary>
    public class SecurityStoreInvalidConfigurationEvent : BaseEvent
    {
        public SecurityStoreInvalidConfigurationEvent() :
            base(999, TraceEventType.Error)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\LiveNTokenAuthenticationModule.cs ===
﻿using System;
using System.Collections;
using System.Reflection;
using System.Text.RegularExpressions;
using System.IdentityModel;
using System.IdentityModel.Tokens;
using System.IdentityModel.Policy;
using System.Diagnostics;
using System.Collections.Generic;
using System.Web;
using System.Text;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Identity.TokenAuthentication.Diagnostics;
using Leet.Identity.TokenAuthentication.IdentityModel;

namespace Leet.Identity.TokenAuthentication
{
    public sealed class LiveNTokenAuthenticationModule : IHttpModule
    {
        public LiveNTokenAuthenticationModule()
        {

        }
        
        #region IHttpModule Members

        void IHttpModule.Dispose()
        {
            //TODO: Clean upww
        }

        void IHttpModule.Init(HttpApplication context)
        {
            Init(context);
        }
        
        #endregion

        /// <summary>
        /// Returns the SecurityContext associated with the Request as a System.IdentityModel.Policy.AuthorizationContext object
        /// The AuthorizationContext contains claims associated with the incoming token
        /// Returns null if no security contect found
        /// </summary>
        public static AuthorizationContext ServiceSecurityContext
        {
            get
            {
                if (HttpContext.Current != null)
                {
                    return HttpContext.Current.Items[Configuration.ServiceSecurityContextKey] as AuthorizationContext;
                }
                else
                {
                    return null;
                }

            }
        }

        void Init(HttpApplication context)
        {
            //This is colled once by the ASP.NET infrastructure.
            //Register events here
            context.AuthenticateRequest += new EventHandler(ApplicationContext_AuthenticateRequest); 
        }

        void ApplicationContext_AuthenticateRequest(object sender, EventArgs e)
        {
            //We will do all validation here
            HttpApplication httpApplication = sender as HttpApplication;
            ValidateRequest(httpApplication);
        }

        void ValidateRequest(HttpApplication httpApplication)
        {
            bool passedValidation = false;
            ILogging logger = Container.Instance.GetComponent<ILogging>();

            //If authentication is not needed for this request then bail out
            if(OvverideAuthentication(httpApplication.Request))
            {
                return;
            }

            //we need to authenticate this request from here on
            try
            {
                AuthorizationContext authorizationContext = LiveNTokenIdentityModel.ValidateRequest(httpApplication);

                //At this point no Security exception is thrown so we have a valid context here.
                //Add it to the current request cache
                HttpContext.Current.Items[Configuration.ServiceSecurityContextKey] = authorizationContext;
                passedValidation = true;
            }
            catch (SecurityStoreConfigurationException configException)
            {
                passedValidation = false;
                logger.LogEvent(new SecurityStoreInvalidConfigurationEvent(), configException, configException.Message);
            }
            catch (SecurityTokenException secTokenEx)
            {
                passedValidation = false;
                Logging.TraceException(secTokenEx);
            }
            catch (Exception ex)
            {
                passedValidation = false;
                Logging.TraceException(ex, "LiveNTokenAuthenticationModule unhandled exception");
            }
            finally
            {
                if (!passedValidation)
                {
                    //We fail validation here. Create an UnAuthorized response and complete the request
                    ResponseHelper.CreateUnauthorizedResponse(httpApplication.Context);
                    httpApplication.CompleteRequest();
                }
            }
        }

        bool OvverideAuthentication(HttpRequest request)
        {
            Debug.Assert(request != null, "request != null");

            //check if authentication is disabled in the web.config
            if (Configuration.IsAuthenticationDisabled())
            {
                return true;
            }

            //check if the request path matches any overrides configured. If we  find one we will not authenticate this request
            bool ovveride = false;

            //help is a very special case here. Everything starting with help in the path will ovveride authentication
            if (request.Path.ToUpper(System.Globalization.CultureInfo.CurrentUICulture).Contains("/HELP/"))
            {
                ovveride = true;
            }
            else
            {
                List<String> pathOverrideList = Configuration.GetPathOverrides();
                if (pathOverrideList != null && pathOverrideList.Count > 0 && !String.IsNullOrEmpty(request.Path))
                {
                    foreach (String pathOverride in pathOverrideList)
                    {
                        if (request.Path.EndsWith(pathOverride, true, System.Globalization.CultureInfo.CurrentUICulture))
                        {
                            ovveride = true;
                            break;
                        }
                    }
                }
            }
            return ovveride;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\IdentityModel\LiveNTokenAuthenticator.cs ===
﻿using System;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.IdentityModel;
using System.IdentityModel.Claims;
using System.IdentityModel.Tokens;
using System.IdentityModel.Selectors;
using System.IdentityModel.Policy;
using System.Text;
using System.ServiceModel.Security;
using System.Security.Cryptography.X509Certificates;
using Leet.Identity.TokenAuthentication.Diagnostics;

namespace Leet.Identity.TokenAuthentication.IdentityModel
{
    /// <summary>
    /// Validates the saml token.
    /// 1. Verify signature and timestamp (expiration) of the token
    /// 2. Verify Audience Uri condition
    /// 3. Verify SubjectName, Issuer and Version
    /// 4. Create an Auththorization Policy based on the claims in the token
    /// </summary>
    public class LiveNPartnerTokenAuthenticator : SecurityTokenAuthenticator
    {
        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
        {
            if (!CanValidateToken(token))
            {
                return null;
            }

            List<IAuthorizationPolicy> uberPolicies = new List<IAuthorizationPolicy>();
            SamlSecurityToken samlToken = token as SamlSecurityToken; 
            
            //verify thumbprint, expiration and audience uri conditions
            VerifyCritical(samlToken);

            //verify SubjectName, Issuer and Version and set up policy based on claims
            uberPolicies.Add(TokenAuthorizationPolicy.CreateAuthorizationPolicy(samlToken));

            return new ReadOnlyCollection<IAuthorizationPolicy>(uberPolicies);
        }

        /// <summary>
        /// Validate only if this is a Saml token
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        protected override bool CanValidateTokenCore(SecurityToken token)
        {
            return token is SamlSecurityToken;
        }

        /// <summary>
        /// Verify signature, expiration and audience Uri
        /// </summary>
        /// <param name="token"></param>
        private void VerifyCritical(SamlSecurityToken token)
        {
            // There should be only one SamlStatement
            if (1 != token.Assertion.Statements.Count ||
                !(token.Assertion.Statements[0] is SamlAttributeStatement))
            {
                throw new SecurityTokenValidationException("Invalid SAML format");
            }

            //verify that the NotBefore is always less than notOnOrAfter. We need to do this because SamlSecurityTokenAuthenticator below does not seem to do that.
            if (token.Assertion.Conditions.NotBefore >= token.Assertion.Conditions.NotOnOrAfter)
            {
                throw new SecurityTokenValidationException("NotBefore should always be less than NotOnOrAfter");
            }

            X509SecurityTokenAuthenticator x509Authenticator = new X509SecurityTokenAuthenticator(new ThumbPrintValidator());
            SamlSecurityTokenAuthenticator samlAuthenticator =
                new SamlSecurityTokenAuthenticator(new SecurityTokenAuthenticator[] { x509Authenticator }, TimeSpan.FromMinutes(Configuration.StsAddedTokenExpirationMinutes));

            samlAuthenticator.AudienceUriMode = AudienceUriMode.Always;
            foreach (String audienceUri in Configuration.AudienceUris)
            {
                samlAuthenticator.AllowedAudienceUris.Add(audienceUri);
            }

            samlAuthenticator.ValidateToken(token);
        }

        /// <summary>
        /// Sets up and validates token claims
        /// </summary>
        class TokenAuthorizationPolicy : IAuthorizationPolicy
        {
            public static IAuthorizationPolicy CreateAuthorizationPolicy(SamlSecurityToken samlToken)
            {
                return new TokenAuthorizationPolicy(samlToken);
            }
            
            private Dictionary<string, string> tokenAttributes = new Dictionary<string, string>();
            private SamlSecurityToken samlToken;
            ClaimSet globalCliamSet;
            ClaimSet issuerClaimSet;

            Dictionary<Int32, Int32> stateObjectHash = new Dictionary<Int32, Int32>();

            TokenAuthorizationPolicy(SamlSecurityToken token)
            {
                Debug.Assert(token != null, "token");
                this.samlToken = token;
                ValidateTokenAndSetUpClaims();
            }
            
            #region IAuthorizationPolicy Members

            /// <summary>
            /// Add claims to the evaluation context. Eventually the infrastrure will use this to create an authorization context
            /// </summary>
            /// <param name="evaluationContext"></param>
            /// <param name="state"></param>
            /// <returns></returns>
            public bool Evaluate(EvaluationContext evaluationContext, ref object state)
            {
                Int32 stateValue = 0;
                if (state == null)
                {
                    state = new Object();
                }

                Int32 stateHash = state.GetHashCode();
                if (!this.stateObjectHash.TryGetValue(stateHash, out stateValue))
                {
                    evaluationContext.AddClaimSet(this, this.globalCliamSet);
                    this.stateObjectHash.Add(stateHash, 1);
                    return true;
                }

                return false;

            }

            /// <summary>
            /// Gets the Issuer ClaimSet of the token
            /// </summary>
            public System.IdentityModel.Claims.ClaimSet Issuer
            {
                get
                {
                    return this.issuerClaimSet;
                }
            }

            #endregion

            #region IAuthorizationComponent Members

            public string Id
            {
                get { return "TokenAuthorizationPolicy"; }
            }

            #endregion

            private void ValidateTokenAndSetUpClaims()
            {
                // Populate the dictionary from token Attributes
                foreach (SamlAttribute samlAttribute in
                    ((SamlAttributeStatement)samlToken.Assertion.Statements[0]).Attributes)
                {
                    this.tokenAttributes.Add(samlAttribute.Name, samlAttribute.AttributeValues[0]);
                }


                //verify asserts and set up claims
                Claim majorVersionClaim =
                    VerifyAndCreateClaim("MajorVersion", Configuration.TokenAttributeValues.SamlMajorVersion.ToString(System.Globalization.CultureInfo.CurrentUICulture).Trim(), samlToken.Assertion.MajorVersion.ToString(System.Globalization.CultureInfo.CurrentUICulture), LiveNTokenClaimTypes.MajorVersionClaimType, Rights.PossessProperty);

                Claim minorVersionClaim =
                    VerifyAndCreateClaim("MinorVersion", Configuration.TokenAttributeValues.SamlMinorVersion.ToString(System.Globalization.CultureInfo.CurrentUICulture).Trim(), samlToken.Assertion.MinorVersion.ToString(System.Globalization.CultureInfo.CurrentUICulture), LiveNTokenClaimTypes.MinorVersionClaimType, Rights.PossessProperty);
               
                String subjectName = ((SamlSubjectStatement)samlToken.Assertion.Statements[0]).SamlSubject.Name.Trim();
                Claim subjectNameClaim =
                    VerifyAndCreateClaim("Subject", Configuration.TokenAttributeValues.SubjectNamePartner, subjectName, LiveNTokenClaimTypes.SubjectNameClaimType, Rights.PossessProperty);

                this.issuerClaimSet =
                    new DefaultClaimSet(VerifyAndCreateClaim("Issuer", Configuration.TokenAttributeValues.SamlIssuer, samlToken.Assertion.Issuer.Trim(), LiveNTokenClaimTypes.IssuerClaimType, Rights.PossessProperty));

                Claim xuidClaim = new Claim(LiveNTokenClaimTypes.PartnerIDClaimType, this.tokenAttributes[Configuration.TokenAttributeValues.NameAttributePartnerid0].Trim(), Rights.Identity);

                Claim issuerInstantClaim = new Claim(LiveNTokenClaimTypes.IssuerInstantClaimType, samlToken.Assertion.IssueInstant, Rights.PossessProperty);
                Claim titleIdClaim = new Claim(LiveNTokenClaimTypes.TitleIdClaimType, this.tokenAttributes[Configuration.TokenAttributeValues.NameAttributeTitleId].Trim(), Rights.PossessProperty);
                Claim titleVersionClaim = new Claim(LiveNTokenClaimTypes.TitleVersionClaimType, this.tokenAttributes[Configuration.TokenAttributeValues.NameAttributeTitleVersion].Trim(), Rights.PossessProperty);

                Claim gamerTagClaim = new Claim(LiveNTokenClaimTypes.GamertagClaimType, this.tokenAttributes[Configuration.TokenAttributeValues.NameAttributeGamertag0].Trim(), Rights.PossessProperty);

                //combine all the claims
                List<Claim> finalClaims = new List<Claim>(new Claim[] {issuerInstantClaim, majorVersionClaim, 
                    minorVersionClaim, subjectNameClaim,
                    titleIdClaim, titleVersionClaim,
                    xuidClaim, gamerTagClaim});

                //add audience uri claim
                Claim audienceUriClaim = null;
                IList<Uri> audiences = GetAudiences();
                if (audiences != null && audiences.Count > 0)
                {
                    audienceUriClaim = new Claim(LiveNTokenClaimTypes.AudienceUriClaimType, audiences, Rights.PossessProperty);
                    finalClaims.Add(audienceUriClaim);
                }

                this.globalCliamSet = new DefaultClaimSet(issuerClaimSet, finalClaims);
            }

            private Claim VerifyAndCreateClaim(String claimName, String expectedClaimValue, String actualClaimValue, String claimType, String right)
            {
                if (String.Compare(expectedClaimValue, actualClaimValue, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    throw new SecurityTokenValidationException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "{0} failed validation. Expected Value {1}. Actual Value {2}", claimName,
                        expectedClaimValue, actualClaimValue));
                }
                return new Claim(claimType, actualClaimValue, right);
            }

            private IList<Uri> GetAudiences()
            {
                Debug.Assert(this.samlToken != null);
                IList<SamlCondition> conditions = this.samlToken.Assertion.Conditions.Conditions;
                if (conditions != null && conditions.Count > 0)
                {
                    for (Int32 count = 0; count < conditions.Count; count++)
                    {
                        if (conditions[count].GetType() == typeof(SamlAudienceRestrictionCondition))
                        {
                            return ((SamlAudienceRestrictionCondition)conditions[count]).Audiences;
                        }
                    }
                }
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\Diagnostics\SecurityStoreConfigurationException.cs ===
﻿using System;

namespace Leet.Identity.TokenAuthentication.Diagnostics
{
    /// <summary>
    /// Models exceptions that are related to security store configuration issues like sts cert not found or multiple certs are installed
    /// </summary>
    [Serializable]
    public sealed class SecurityStoreConfigurationException : Exception
    {
        const String STSCertificateNotFound = "LiveNTokenAuthenticationModule: STS certificate with subject name {0} not found in the local machine store";
        const String MultipleSTSCertificatesFound = "LiveNTokenAuthenticationModule: Multiple STS certificates with subject name {0} found in the certificate store";

        SecurityStoreConfigurationException(String message)
            :base(message)
        { 
                
        }

        SecurityStoreConfigurationException(String message, Exception innerException)
            : base(message, innerException)
        { }

        /// <summary>
        /// Creates an SecurityStoreConfigurationException indicating that no sts certificate found in the store
        /// </summary>
        /// <param name="stsCertificateSubjectName">Subject name of the certificate</param>
        /// <returns>SecurityStoreConfigurationException</returns>
        public static SecurityStoreConfigurationException CreateSTSCertificateNotFoundException(String stsCertificateSubjectName)
        {
            return new SecurityStoreConfigurationException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, STSCertificateNotFound, stsCertificateSubjectName));
        }

        /// <summary>
        /// Creates an SecurityStoreConfigurationException indicating that multiple sts certificates found in the store
        /// </summary>
        /// <param name="stsCertificateSubjectName">Subject Name of the certificate</param>
        /// <returns>SecurityStoreConfigurationException</returns>
        public static SecurityStoreConfigurationException CreateMultipleSTSCertificatesFoundException(String stsCertificateSubjectName)
        {
            return new SecurityStoreConfigurationException(
                String.Format(System.Globalization.CultureInfo.CurrentUICulture, MultipleSTSCertificatesFound, stsCertificateSubjectName));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\Diagnostics\ConfigurationProvider.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Diagnostics;
using Leet.Core;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Identity.TokenAuthentication.Diagnostics
{
    /// <summary>
    /// Helper class to centralize all configuration.
    /// </summary>
    internal static class Configuration
    {
        private static IConfigurationProvider configProvider;
        private static IAudienceUriProvider audienceUriProvider;
        private static LiveNTokenAuthenticationModuleConfiguration configSection;
        private static List<String> overridePathList = new List<String>();

        public const String ServiceSecurityContextKey = "xblServiceSecurityContextKey";
        public const String PartnerIdentityHeader = "X-PartnerAuthorization";
        public const String UserIdentityHeader = "X-Authorization";
        public const String XuidHeader = "X-Xuid";
        public const String PASSPORT_AUTH_SCHEME_TOKEN = "WLID1.0";
        public const String PartnerAuthModuleVersion = "1.0";
        public const String Realm = "XboxLive";
        public const String XBL_PREFIX_PATTERN = @"^XBL1.0 x=";

        public const string AuthenticateUserTokenSettings = "AuthenticateUserToken";
        public const string AuthenticatePartnerTokenSettings = "AuthenticatePartnerToken";


        static Configuration()
        {
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            audienceUriProvider = Container.Instance.GetComponent<IAudienceUriProvider>();
            configSection =  ConfigurationManager.GetSection("LiveNTokenAuthenticationModule") as LiveNTokenAuthenticationModuleConfiguration;
            
            //Init default override paths
            overridePathList.AddRange(new String[] { "/health.ashx", "/help", "/crossDomain.xml", "/clientAccessPolicy.xml" });
            if (configSection != null && configSection.PathOverrides != null)
            {
                foreach (PathOverride pathOverride in configSection.PathOverrides)
                {
                    String configuredPathOverride = pathOverride.Value;
                    if(!String.IsNullOrEmpty(configuredPathOverride))
                    {
                        overridePathList.Add(configuredPathOverride);
                    }
                }
            }
        }

        /// <summary>
        /// Returns whether to authenticate request with user tokens or not; defaults to true if not set
        /// </summary>
        public static bool AuthenticateWithUserToken
        {
            get
            {
                bool authenticateUserToken = true;
                if (ConfigurationSettings.AppSettings[AuthenticateUserTokenSettings] != null)
                {
                    authenticateUserToken = Boolean.Parse(System.Configuration.ConfigurationSettings.AppSettings[AuthenticateUserTokenSettings]);
                }
                return authenticateUserToken;
            }
        }

        /// <summary>
        /// Returns whether to authenticate request with partner tokens or not; defaults to true if not set
        /// </summary>
        public static bool AuthenticateWithPartnerToken
        {
            get
            {
                bool authenticatePartnerToken = true;

                if (ConfigurationSettings.AppSettings[AuthenticatePartnerTokenSettings] != null)
                {
                    authenticatePartnerToken = Boolean.Parse(System.Configuration.ConfigurationSettings.AppSettings[AuthenticatePartnerTokenSettings]);
                }
                return authenticatePartnerToken;
            }
        }

        /// <summary>
        /// true is authentication is disabled in the configuration file
        /// </summary>
        /// <returns></returns>
        public static bool IsAuthenticationDisabled()
        {
            return (configSection != null && configSection.Disabled == true);
        }

        /// <summary>
        /// Returns a list for paths for which no validation checks will be done
        /// </summary>
        /// <returns></returns>
        public static List<String> GetPathOverrides()
        {
            return overridePathList;
        }

        /// <summary>
        /// Returns the certificate subject name for thumb print validation. This setting is in NPDB
        /// </summary>
        public static String StsCertificateSubject
        {
            get
            {
                return configProvider.GetSetting(Settings.StsCertificateSubject);
            }
        }

        /// <summary>
        /// Returns the certificate expiration skew time that is allowed when validating certificate expiration. This setting is in NPDB
        /// </summary>
        public static Int32 StsAddedTokenExpirationMinutes
        {
            get
            {
                return configProvider.GetIntSetting(Settings.StsAddedTokenExpirationMinutes);
            }
        }

        /// <summary>
        /// Returns audience uris
        /// </summary>
        public static String[] AudienceUris
        {
            get
            {
                return audienceUriProvider.AudienceUriList;
            }
        }

        public struct TokenAttributeValues
        {
            //expected token attribute values
            public const String SamlIssuer = "http://sts.xboxlive.com";
            public const String SubjectNamePartner = "XboxLive Partner security ticket";
            public const String SubjectNameUser = "XboxLive User security ticket";
            public const String NameAttributePlatformType = "PlatformType";
            public const String NameAttributeMachineId = "MachineID";
            public const String NameAttributeDeviceId = "DeviceID";
            public const String NameAttributeClientVersion = "ClientVersion";
            public const String NameAttributeTitleId = "TitleID";
            public const String NameAttributeTitleVersion = "TitleVersion";
            public const String NameAttributePuid0 = "Puid0";
            public const String NameAttributeCid0 = "CID0";
            public const String NameAttributeXuid0 = "Xuid0";
            public const String NameAttributeGamertag0 = "Gamertag0";
            public const String NameAttributePartnerid0 = "PartnerID0";
            public const String NameAttributeTier0 = "Tier0";
            public const String NameAttributeCountry0 = "Country0";
            public const String NameAttributePrivileges0 = "Privileges0";
            public const Int32 SamlMajorVersion = 1;
            public const Int32 SamlMinorVersion = 1;
        }
    }


    /// <summary>
    /// web.config configuration Section for configuring token authention module.
    /// sample:
    /// <LiveNTokenAuthenticationModule disabled = "false">
	///	    <PathOverrides>
	///		    <PathOverride value="/Manifest.svc/help" />
	///		    <PathOverride value="/crossdomain.xml" />
	///		    <PathOverride value="/clientAccessPolicy.xml" />
	///	    </PathOverrides>
    /// </LiveNTokenAuthenticationModule>
    /// </summary>
    public class LiveNTokenAuthenticationModuleConfiguration : ConfigurationSection
    {
        [ConfigurationProperty("disabled")]
        public bool Disabled
        {
            get
            {
                return (bool)this["disabled"];
            }
            set
            {
                this["disabled"] = value;
            }
        }

        [ConfigurationProperty("PathOverrides")]
        [ConfigurationCollection(typeof(PathOverridesElementCollection))]
        public PathOverridesElementCollection PathOverrides
        {
            get
            {
                return (PathOverridesElementCollection)this["PathOverrides"];
            }
        }
    }

    /// <summary>
    /// Configuration element for configuring path ovverides
    /// </summary>
    public class PathOverridesElementCollection : ConfigurationElementCollection
    {
        protected override string ElementName
        {
            get
            {
                return "PathOverride";
            }
        }
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.BasicMap;
            }
        }
        protected override ConfigurationElement CreateNewElement()
        {
            return new PathOverride();
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            PathOverride path = element as PathOverride;
            return path.Value;
        }
    }

    public class PathOverride : ConfigurationElement
    {
        [ConfigurationProperty("value")]
        public String Value
        {
            get
            {
                return (String)this["value"];
            }
            set
            {
                this["value"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\IdentityModel\LiveNTokenIdentityModel.cs ===
﻿
namespace Leet.Identity.TokenAuthentication.IdentityModel
{
    using System;
    using System.Web;
    using System.Text.RegularExpressions;
    using System.IO;
    using System.Xml;
    using System.Collections.ObjectModel;
    using System.Collections.Generic;
    using System.IdentityModel.Claims;
    using System.IdentityModel.Tokens;
    using System.IdentityModel.Selectors;
    using System.IdentityModel.Policy;
    using System.ServiceModel.Security;
    using Leet.Identity.TokenAuthentication.Diagnostics;

    /// <summary>
    /// Defines methods to validate request
    /// </summary>
    public static class LiveNTokenIdentityModel
    {
        private static Regex xblPrefixRegex = new Regex(Configuration.XBL_PREFIX_PATTERN, RegexOptions.Compiled);

        public static AuthorizationContext ValidateRequest(HttpApplication httpApplication)
        {

            String userAuthHeader = httpApplication.Context.Request.Headers[Configuration.UserIdentityHeader];
            String partnerAuthHeader = httpApplication.Context.Request.Headers[Configuration.PartnerIdentityHeader];

            if(!string.IsNullOrEmpty(userAuthHeader) && !string.IsNullOrEmpty(partnerAuthHeader))
            {
                throw new SecurityTokenException("Request cannot contain more than one token.");
            }

            if (Configuration.AuthenticateWithUserToken)
            {
                if (!string.IsNullOrEmpty(userAuthHeader))
                {
                    return ValidateUserSamlToken(GetSamlTokenFromRequest(userAuthHeader));
                }
            }

            if (Configuration.AuthenticateWithPartnerToken)
            {
                if (!string.IsNullOrEmpty(partnerAuthHeader))
                {
                    return ValidatePartnerSamlToken(GetSamlTokenFromRequest(partnerAuthHeader));
                }
            }

            throw new SecurityTokenException("Authentication token must be provided.");
        }

        /// <summary>
        /// Validates the Partner Saml token
        /// </summary>
        /// <param name="samlToken"></param>
        /// <returns></returns>
        /// <exception cref="SecurityTokenValidationException">If validation fails</exception>
        public static AuthorizationContext ValidatePartnerSamlToken(String samlToken)
        {
            LiveNPartnerTokenAuthenticator tokenAuthenticator = new LiveNPartnerTokenAuthenticator();
            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies = tokenAuthenticator.ValidateToken(DeserializeSamlTokenSting(samlToken));
            return AuthorizationContext.CreateDefaultAuthorizationContext(authorizationPolicies);
        }

        /// <summary>
        /// Validates the User Saml token
        /// </summary>
        /// <param name="samlToken">User same token</param>
        /// <returns></returns>
        /// <exception cref="SecurityTokenValidationException">If validation fails</exception>
        public static AuthorizationContext ValidateUserSamlToken(String samlToken)
        {
            LiveNUserTokenAuthenticator tokenAuthenticator = new LiveNUserTokenAuthenticator();
            ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies = tokenAuthenticator.ValidateToken(DeserializeSamlTokenSting(samlToken));
            return AuthorizationContext.CreateDefaultAuthorizationContext(authorizationPolicies);
        }

        /// <summary>
        /// Given a claim set finds the root issuer claim set based on System.IdentityModel rules
        /// </summary>
        /// <param name="claimSet"></param>
        /// <returns>Root issuer claim set</returns>
        /// <exception cref="ArgumentNullException">If claim set is null</exception>
        public static ClaimSet FindRootIssuerClaimSet(ClaimSet claimSet)
        {
            if (claimSet == null)
            {
                throw new ArgumentNullException("claimSet");
            }

            ClaimSet rootIssuerClaimSet = claimSet;
            while (rootIssuerClaimSet.Issuer != null && !Object.ReferenceEquals(rootIssuerClaimSet, rootIssuerClaimSet.Issuer))
            {
                rootIssuerClaimSet = rootIssuerClaimSet.Issuer;
            }

            return rootIssuerClaimSet;
        }

        /// <summary>
        /// Given a claim set finds the identity claim (Whose claim right is Rights.Identity)
        /// </summary>
        /// <param name="claimSet">ClaimSet</param>
        /// <returns>Identity claim if found else returns null</returns>
        /// <exception cref="ArgumentNullException">If claimSet is null</exception>
        public static Claim FindIdentityClaim(ClaimSet claimSet)
        {
            if (claimSet == null)
            {
                throw new ArgumentNullException("claimSet");
            }

            foreach (Claim c in claimSet)
            {
                if (c.Right == Rights.Identity)
                {
                    return c;
                }
            }
            return null;
        }

        #region Helper Methods

        private static String GetSamlTokenFromRequest(String authHeader)
        {
            // Get rid of the prefix from the header to get the samlTicket.
            string samlTicket = xblPrefixRegex.Replace(authHeader, string.Empty, 1);

            if (String.IsNullOrEmpty(samlTicket))
            {
                throw new SecurityTokenValidationException("Authentication token cannot be null or empty");
            }

            return samlTicket;
        }

        private static SamlSecurityToken DeserializeSamlTokenSting(string samlToken)
        {
            //SamlUtilInit();
            SecurityTokenResolver outOfBandTokenResolver =
                SecurityTokenResolver.CreateDefaultSecurityTokenResolver(
                    new ReadOnlyCollection<SecurityToken>(new List<SecurityToken>()), false);
            SamlSerializer serializer = new SamlSerializer();

            using (XmlReader reader = XmlReader.Create(new StringReader(samlToken)))
            {
                //this validates the signature and time windows, as well as format of conditions and attributes
                return serializer.ReadToken(reader, WSSecurityTokenSerializer.DefaultInstance, outOfBandTokenResolver);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\IdentityModel\ThumbPrintValidator.cs ===
﻿

namespace Leet.Identity.TokenAuthentication.IdentityModel
{
    using System;
    using System.Collections.Generic;
    using System.IdentityModel.Selectors;
    using System.IdentityModel.Tokens;
    using System.Linq;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using Leet.Identity.TokenAuthentication.Diagnostics;

    /// <summary>
    ///  Validates the thumbprint of the token certificate with the sts.xboxlive.com cert from the cert store
    /// </summary>
    public class ThumbPrintValidator : X509CertificateValidator
    {
        public override void Validate(X509Certificate2 tokenCertificate)
        {
            // Get the certificate from the store. Handle all store config errors.
            X509Certificate2 validationCertificate = GetCertificateBySubjectName(tokenCertificate.Thumbprint);

            //TODO: Download the public key as required - waiting on XBL support for downloading the key
            //const string requiredPublicKey =
            //    "3082010A0282010100A8D0990E5604893C0244048F4241F8BB900DA4D93CE16B479040FB8332840B84E43A0F526675F3A3A5CDB4654921970DC9FC943C6ACAD825F6D59B50D5C44DED8203F709F643BB5EE7586F88C16AF81ADADE9153DA4AE98892CEE80930545944B2DCB5CDEEC06B2E95A18CEFAEE9255CC78FC47D255F727F6D5F30400E79194FB4E0F58C919D7C4CFCB6E9DD62864458001F091EC942E1CE45B4D514B24498EF6031909B24B936BBEC85FF949434E201E80577CEF2F3BB8C142C511B3388C3F14489F1E9974CC341AEEDFF4F4A6088C5E7808B3E76B9F93AEEB71BAF22ABCB4D56EDC6640A2D2FAF08C94677FF73BE3551FEFE70DC5E2148C17D3A620741789F0203010001";

            if (tokenCertificate.Thumbprint != validationCertificate.Thumbprint)
            {
                throw new SecurityTokenValidationException("Certificate Thumbprint validation failed");
            }
        }

        /// <summary>
        /// Loads the sts.xboxlive.com cert from the certificate store so it can be used
        /// to verify the key on the partner ticket
        /// </summary>
        /// <returns>X509Certificate2</returns>
        private X509Certificate2 GetCertificateBySubjectName(string certThumbprint)
        {
            X509Certificate2 certificate = null;
            X509Certificate2Collection matches;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);

            try
            {
                // Find the certificate that matches the subject
                matches = store.Certificates.Find(X509FindType.FindBySubjectName, Configuration.StsCertificateSubject, false);
            }
            finally
            {
                store.Close();
            }

            if (matches == null || matches.Count == 0)
            {
                //No matches found
                throw SecurityStoreConfigurationException.CreateSTSCertificateNotFoundException(Configuration.StsCertificateSubject);
            }

            if (matches.Count > 1)
            {
                //more than one match was found so check for the cert thumbprint.
                foreach (var match in matches)
                {
                    if (match.Thumbprint.Equals(certThumbprint))
                    {
                        certificate = match;
                        break;
                    }
                }
            }

            if (certificate == null)
            {
                certificate = matches[0];
            }

            return certificate;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\IdentityModel\LiveNUserTokenAuthenticator.cs ===
﻿

namespace Leet.Identity.TokenAuthentication.IdentityModel
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.IdentityModel.Policy;
    using System.IdentityModel.Selectors;
    using System.IdentityModel.Tokens;
    using Leet.Identity.TokenAuthentication.Diagnostics;

    /// <summary>
    /// Validates thumbprint, expiration, audience uri, subject name, issuer, and version
    /// </summary>
    public class LiveNUserTokenAuthenticator : SecurityTokenAuthenticator
    {
        private Dictionary<string, string> claims = new Dictionary<string, string>();

        /// <summary>
        /// Validate only if this is a Saml token
        /// </summary>
        /// <param name="token">The security token to be validated</param>
        /// <returns>Returns true if the token can be validated by this security token authenticator (ie. if it's a Saml token); otherwise, false.</returns>
        protected override bool CanValidateTokenCore(SecurityToken token)
        {
            return token is SamlSecurityToken;
        }

        /// <summary>
        /// Authenticates the specified security token and returns the set of authorization policies for the security token
        /// </summary>
        /// <param name="token"></param>
        /// <returns></returns>
        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
        {
            if (!CanValidateToken(token))
            {
                return null;
            }

            SamlSecurityToken samlToken = token as SamlSecurityToken;

            // Verify thumbprint, expiration and audience uri conditions
            VerifyCritical(samlToken);

            // Validate token
            ValidateToken(samlToken, string.Empty);

            // Set up policy based on claims
            List<IAuthorizationPolicy> allPolicies = new List<IAuthorizationPolicy>();
            allPolicies.Add(LiveNUserTokenAuthorizationPolicy.CreateAuthorizationPolicy(samlToken, this.claims));

            return new ReadOnlyCollection<IAuthorizationPolicy>(allPolicies);
        }

        /// <summary>
        /// Verify signature, expiration and audience Uri
        /// </summary>
        /// <param name="token"></param>
        private void VerifyCritical(SamlSecurityToken token)
        {
            // There should be only one SamlStatement
            if (1 != token.Assertion.Statements.Count)
            {
                throw new SecurityTokenValidationException(String.Format("SAML Statement count is {0}, but 1 is expected.", token.Assertion.Statements.Count));
            }

            // It should be of type SamlAttributeStatement
            if (!(token.Assertion.Statements[0] is System.IdentityModel.Tokens.SamlAttributeStatement))
            {
                throw new SecurityTokenValidationException(String.Format("SAML Statement type is {0}, but Type:System.IdentityModel.Tokens.SamlAttributeStatement is expected.", token.Assertion.Statements[0].GetType()));
            }

            // Verify that the NotBefore is always less than notOnOrAfter. We need to do this because SamlSecurityTokenAuthenticator below does not seem to do that.
            if (token.Assertion.Conditions.NotBefore >= token.Assertion.Conditions.NotOnOrAfter)
            {
                throw new SecurityTokenValidationException("NotBefore should always be less than NotOnOrAfter");
            }

            X509SecurityTokenAuthenticator x509Authenticator = new X509SecurityTokenAuthenticator(new ThumbPrintValidator());
            SamlSecurityTokenAuthenticator samlAuthenticator =
                new SamlSecurityTokenAuthenticator(new SecurityTokenAuthenticator[] { x509Authenticator }, TimeSpan.FromMinutes(Configuration.StsAddedTokenExpirationMinutes));

            samlAuthenticator.AudienceUriMode = AudienceUriMode.Always;
            foreach (String audienceUri in Configuration.AudienceUris)
            {
                samlAuthenticator.AllowedAudienceUris.Add(audienceUri);
            }

            samlAuthenticator.AllowedAudienceUris.Add(Configuration.TokenAttributeValues.SamlIssuer);

            samlAuthenticator.ValidateToken(token);
        }

        /// <summary>
        /// Validates the major version, minor version, subject name, and issuer of the token
        /// </summary>
        /// <param name="samlSecurityToken">The saml security token</param>
        /// <param name="certDeviceId">Certificate device Id</param>
        private void ValidateToken(SamlSecurityToken samlSecurityToken, string certDeviceId)
        {
            // Populate the dictionary from token Attributes
            foreach (SamlAttribute samlAttribute in
                ((SamlAttributeStatement)samlSecurityToken.Assertion.Statements[0]).Attributes)
            {
                this.claims.Add(samlAttribute.Name, samlAttribute.AttributeValues[0]);
            }

            // Does the client connection certificate match the device for which the token was issued
            //string deviceId;
            //if (!string.IsNullOrEmpty(certDeviceId) && this.TryGetAttributeValue(Configuration.TokenAttributeValues.NameAttributeDeviceId, out deviceId))
            //{
            //    if (deviceId != certDeviceId)
            //    {
            //        throw new SecurityTokenValidationException(
            //            "SAML Claim DeviceID does not match client certificate DeviceId. The token was not issued for this connection certificate.");
            //    }
            //}

            // General saml validation
            if (Configuration.TokenAttributeValues.SamlMajorVersion != samlSecurityToken.Assertion.MajorVersion)
            {
                throw new SecurityTokenValidationException(String.Format(
    "SAML MajorVersion attribute is {0}, but {1} is expected.", samlSecurityToken.Assertion.MajorVersion, Configuration.TokenAttributeValues.SamlMajorVersion));
            }

            if (Configuration.TokenAttributeValues.SamlMinorVersion != samlSecurityToken.Assertion.MinorVersion)
            {
                throw new SecurityTokenValidationException(String.Format("SAML MinorVersion attribute is {0}, but {1} is expected.", samlSecurityToken.Assertion.MinorVersion, Configuration.TokenAttributeValues.SamlMinorVersion));
            }

            if (string.Compare(Configuration.TokenAttributeValues.SamlIssuer, samlSecurityToken.Assertion.Issuer) != 0)
            {
                throw new SecurityTokenValidationException(String.Format("SAML Issuer attribute is {0}, but {1} is expected.", samlSecurityToken.Assertion.Issuer, Configuration.TokenAttributeValues.SamlIssuer));
            }

            String subjectName = ((SamlSubjectStatement)samlSecurityToken.Assertion.Statements[0]).SamlSubject.Name.Trim();
            if (string.Compare(Configuration.TokenAttributeValues.SubjectNameUser, subjectName) != 0 )
            {
                throw new SecurityTokenValidationException("SAML Subject is invalid.");
            }
        }

        public string GetAttributeValue(string name)
        {
            return this.claims[name];
        }

        public bool TryGetAttributeValue(string name, out string value)
        {
            return this.claims.TryGetValue(name, out value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\IdentityModel\LiveNUserTokenAuthorizationPolicy.cs ===
﻿
namespace Leet.Identity.TokenAuthentication.IdentityModel
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IdentityModel.Claims;
    using System.IdentityModel.Policy;
    using System.IdentityModel.Tokens;
    using Leet.Identity.TokenAuthentication.Diagnostics;
    
    /// <summary>
    /// Sets up the claims and evaluates that the claims exist (does not make any other assertions)
    /// </summary>
    public class LiveNUserTokenAuthorizationPolicy : IAuthorizationPolicy
    {
        private SamlSecurityToken samlToken;
        private string id;
        private ClaimSet globalClaimSet;
        ClaimSet issuerClaimSet;

        private Dictionary<string, string> claims;
        private Dictionary<Int32, Int32> stateObjectHash = new Dictionary<Int32, Int32>();

        public static IAuthorizationPolicy CreateAuthorizationPolicy(SamlSecurityToken samlToken, Dictionary<string, string> claims)
        {
            return new LiveNUserTokenAuthorizationPolicy(samlToken, claims);
        }

        LiveNUserTokenAuthorizationPolicy(SamlSecurityToken token, Dictionary<string, string> claims)
        {

                Debug.Assert(token != null, "token");
                this.samlToken = token;
                this.claims = claims;
                this.id = "LiveNUserTokenAuthorizationPolicy";
                SetUpClaims();
        }

        private void SetUpClaims()
        {
            List<Claim> finalClaims = new List<Claim>();


            Claim issuerInstantClaim = new Claim(LiveNTokenClaimTypes.IssuerInstantClaimType, samlToken.Assertion.IssueInstant, Rights.PossessProperty);

            Claim majorVersionClaim = new Claim(LiveNTokenClaimTypes.MajorVersionClaimType, samlToken.Assertion.MajorVersion.ToString(System.Globalization.CultureInfo.CurrentUICulture), Rights.PossessProperty);

            Claim minorVersionClaim = new Claim(LiveNTokenClaimTypes.MinorVersionClaimType, samlToken.Assertion.MinorVersion.ToString(System.Globalization.CultureInfo.CurrentUICulture), Rights.PossessProperty);

            String subjectName = ((SamlSubjectStatement)samlToken.Assertion.Statements[0]).SamlSubject.Name.Trim();
            Claim subjectNameClaim = new Claim(LiveNTokenClaimTypes.SubjectNameClaimType, subjectName, Rights.PossessProperty);

            finalClaims.Add(issuerInstantClaim);
            finalClaims.Add(majorVersionClaim);
            finalClaims.Add(minorVersionClaim);
            finalClaims.Add(subjectNameClaim);

            // Add XBL Claims
            Claim platformTypeClaim = new Claim(LiveNTokenClaimTypes.PlatformClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributePlatformType].Trim(), Rights.PossessProperty);

            Claim machineIdClaim = new Claim(LiveNTokenClaimTypes.MachineIDClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeMachineId].Trim(), Rights.PossessProperty);

            Claim deviceIdClaim = new Claim(LiveNTokenClaimTypes.DeviceIDClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeDeviceId].Trim(), Rights.PossessProperty);

            Claim clientVersionClaim = new Claim(LiveNTokenClaimTypes.ClientVersionClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeClientVersion].Trim(), Rights.PossessProperty);

            Claim titleIdClaim = new Claim(LiveNTokenClaimTypes.TitleIdClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeTitleId].Trim(), Rights.PossessProperty);

            Claim titleVersionClaim = new Claim(LiveNTokenClaimTypes.TitleVersionClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeTitleVersion].Trim(), Rights.PossessProperty);

            Claim puidClaim = new Claim(LiveNTokenClaimTypes.PuidClaimSetType, this.claims[Configuration.TokenAttributeValues.NameAttributePuid0].Trim(), Rights.PossessProperty);

            Claim cidClaim = new Claim(LiveNTokenClaimTypes.CIDClaimSetType, this.claims[Configuration.TokenAttributeValues.NameAttributeCid0].Trim(), Rights.PossessProperty);

            Claim xuidClaim = new Claim(LiveNTokenClaimTypes.XuidClaimSetType, this.claims[Configuration.TokenAttributeValues.NameAttributeXuid0].Trim(), Rights.Identity);

            Claim gamertagClaim = new Claim(LiveNTokenClaimTypes.GamertagClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeGamertag0].Trim(), Rights.PossessProperty);

            Claim tierClaim = new Claim(LiveNTokenClaimTypes.TierClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeTier0].Trim(), Rights.PossessProperty);

            Claim countryClaim = new Claim(LiveNTokenClaimTypes.CountryClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributeCountry0].Trim(), Rights.PossessProperty);

            Claim privilegesClaim = new Claim(LiveNTokenClaimTypes.PrivilegesClaimType, this.claims[Configuration.TokenAttributeValues.NameAttributePrivileges0].Trim(), Rights.PossessProperty);

            finalClaims.Add(platformTypeClaim);
            finalClaims.Add(machineIdClaim);
            finalClaims.Add(deviceIdClaim);
            finalClaims.Add(clientVersionClaim);
            finalClaims.Add(titleIdClaim);
            finalClaims.Add(titleVersionClaim);
            finalClaims.Add(puidClaim);
            finalClaims.Add(cidClaim);
            finalClaims.Add(xuidClaim);
            finalClaims.Add(gamertagClaim);
            finalClaims.Add(tierClaim);
            finalClaims.Add(countryClaim);
            finalClaims.Add(privilegesClaim);

            // Add audienceUri claim
            Claim audienceUriClaim = null;
            IList<Uri> audiences = GetAudiences();
            if (audiences != null && audiences.Count > 0)
            {
                audienceUriClaim = new Claim(LiveNTokenClaimTypes.AudienceUriClaimType, audiences, Rights.PossessProperty);
                finalClaims.Add(audienceUriClaim);
            }

            this.issuerClaimSet =
                new DefaultClaimSet(new Claim(LiveNTokenClaimTypes.IssuerClaimType, samlToken.Assertion.Issuer.Trim(),
                                              Rights.PossessProperty));

            this.globalClaimSet = new DefaultClaimSet(issuerClaimSet, finalClaims);
        }

        /// <summary>
        /// Gets a claim set that represents the issuer of this authorization policy
        /// </summary>
        public ClaimSet Issuer { get { return this.issuerClaimSet; } }

        /// <summary>
        /// Gets a string that idenitfies this authorization component
        /// </summary>
        public string Id { get { return this.id; } }

        /// <summary>
        /// Evaluates whether the user meets the requirements for this authorization policy. Also adds claims to the evaluation context
        /// </summary>
        /// <param name="context">Contains the claim set that the authorization policy evaluates</param>
        /// <param name="state">Represents the custom state for this authorization policy</param>
        /// <returns></returns>
        public bool Evaluate(EvaluationContext context, ref object state)
        {
            Int32 stateValue = 0;
            if (state == null)
            {
                state = new Object();
            }

            Int32 stateHash = state.GetHashCode();

            // Check to make sure the claims have not already been added
            if (!this.stateObjectHash.TryGetValue(stateHash, out stateValue))
            {
                context.AddClaimSet(this, this.globalClaimSet);
                this.stateObjectHash.Add(stateHash, 1);
                return true;
            }

            return false;
        }

        private IList<Uri> GetAudiences()
        {
            Debug.Assert(this.samlToken != null);
            IList<SamlCondition> conditions = this.samlToken.Assertion.Conditions.Conditions;
            if (conditions != null && conditions.Count > 0)
            {
                for (Int32 count = 0; count < conditions.Count; count++)
                {
                    if (conditions[count].GetType() == typeof(SamlAudienceRestrictionCondition))
                    {
                        return ((SamlAudienceRestrictionCondition)conditions[count]).Audiences;
                    }
                }
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.TokenAuthentication")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

[assembly: System.CLSCompliant(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f091bdbe-61c4-4854-b488-fa9be1c48fb6")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\UnitTests\AuthenticationManagersTest.cs ===
﻿using System;
using System.IdentityModel;
using System.IdentityModel.Policy;
using System.IdentityModel.Claims;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Text;
using System.IdentityModel.Tokens;
using Leet.Identity;
using System.Configuration;
using Leet.Identity.TokenAuthentication.IdentityModel;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using xonline.common.service;
using Leet.Live.Livecache.DataAccess;
using PA=Leet.Identity.PartnerAuth;

namespace Leet.Identity.TokenAuthentication.UnitTests
{
    [TestClass]
    [DeploymentItem("RPSTicketGenerator.dll.config")]
    public class AuthenticationManagersTests
    {
        private TestContext testContextInstance;
      
        static AuthenticationManagersTests()
        {
            Container.Instance.AddServiceWithInstance<IXCacheDataAccess>(new CustomXCacheDataAccess());
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(new CustomConfigurationProvider());
        }

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }
        
        [TestMethod]
        public void TestPartnerAuthAuthenticationManager()
        {
            CustomPartnerAuthAdapter cPa = new CustomPartnerAuthAdapter();
            cPa.CreateDefaultAuthorizationContext();
            PA.AuthenticationManager paAuthManager = new Leet.Identity.PartnerAuth.AuthenticationManager(cPa);
            Assert.IsTrue(paAuthManager.CurrentUser != null, "paAuthManager.CurrentUser");
            Assert.IsTrue(paAuthManager.IsAuthenticated, "paAuthManager.IsAuthenticated");

            PA.PartnerIdentity pi = paAuthManager.CurrentUser as PA.PartnerIdentity;
            Assert.IsTrue(pi != null, "paAuthManager.CurrentUser is PA.PartnerIdentity");
            Assert.IsTrue(pi.IsAuthenticated, "paAuthManager.CurrentUser is PA.PartnerIdentity");
            Assert.IsTrue(paAuthManager.IsAuthenticated, "paAuthManager.IsAuthenticated");
            Assert.IsTrue(pi.PartnerID > 0, "pi.PartnerID > 0");
            Assert.IsTrue(pi.Xuid > 0, "pi.Xuid > 0");
            Assert.IsTrue(pi.Gamertag.Length > 0, "pi.Gamertag.Length > 0");
            Assert.IsTrue(pi.TitleVersion.Length > 0, "pi.TitleVersion.Length > ");
            Assert.IsTrue(pi.TitleId.Length > 0, "pi.TitleID.Length > ");

            ClaimSet claimSet = paAuthManager.GetClaims();
            Assert.IsTrue(claimSet != null, "claimSet != null");
            Assert.IsTrue(claimSet.Count > 0, "claimSet.Count > 0");
            Claim identityClaim = LiveNTokenIdentityModel.FindIdentityClaim(claimSet);
            Assert.IsTrue(identityClaim != null, "No identity claim found");
            Assert.IsTrue(identityClaim.ClaimType == LiveNTokenClaimTypes.PartnerIDClaimType, "identity claim claim type is invalid");
            Assert.IsTrue(identityClaim.Right == Rights.Identity, "Claim rights must be Rights.Identity");
            Assert.IsTrue(pi.Xuid.ToString() == identityClaim.Resource.ToString());
        }

        [TestMethod]
        public void TestPartnerAuthManagerNoIdentityClaim()
        {
            CustomPartnerAuthAdapter cPa = new CustomPartnerAuthAdapter();
            cPa.CreateNoIdentityAuthContext();
            PA.AuthenticationManager paAuthManager = new Leet.Identity.PartnerAuth.AuthenticationManager(cPa);
            Assert.IsNull(paAuthManager.CurrentUser, "paAuthManager.CurrentUser is Null");
            Assert.IsFalse(paAuthManager.IsAuthenticated, "paAuthManager.IsAuthenticated");

            ClaimSet claimSet = paAuthManager.GetClaims();
            Assert.IsTrue(claimSet != null, "claimSet != null");
            Assert.IsTrue(claimSet.Count > 0, "claimSet.Count > 0");

            Claim identityClaim = LiveNTokenIdentityModel.FindIdentityClaim(claimSet);
            Assert.IsNull(identityClaim, "identityClaim is Null");
         
        }

        [TestMethod]
        public void TestPartnerAuthManagerNoClaimSet()
        {
            CustomPartnerAuthAdapter cPa = new CustomPartnerAuthAdapter();
            cPa.CreateNoClaimSetAuthContext();
            PA.AuthenticationManager paAuthManager = new Leet.Identity.PartnerAuth.AuthenticationManager(cPa);
            Assert.IsNull(paAuthManager.CurrentUser, "paAuthManager.CurrentUser is Null");
            Assert.IsFalse(paAuthManager.IsAuthenticated, "paAuthManager.IsAuthenticated");

            ClaimSet claimSet = paAuthManager.GetClaims();
            Assert.IsNull(claimSet, "claimSet is null");
        }

        [TestMethod]
        public void TestPartnerAuthManagerNullAuthContext()
        {
            CustomPartnerAuthAdapter cPa = new CustomPartnerAuthAdapter();
            PA.AuthenticationManager paAuthManager = new Leet.Identity.PartnerAuth.AuthenticationManager(cPa);
            Assert.IsNull(paAuthManager.CurrentUser, "paAuthManager.CurrentUser is Null");
            Assert.IsFalse(paAuthManager.IsAuthenticated, "paAuthManager.IsAuthenticated");

            ClaimSet claimSet = paAuthManager.GetClaims();
            Assert.IsNull(claimSet, "claimSet is null");
        }

        class CustomPartnerAuthAdapter : PA.IPartnerAuthAdapter
        {
            AuthorizationContext authContext;
            private static CustomAudienceUriProvider audienceUriProvider = new CustomAudienceUriProvider();
            
            static CustomPartnerAuthAdapter()
            {
                Container.Instance.AddServiceWithInstance<IAudienceUriProvider>(audienceUriProvider);
            }

            public void CreateDefaultAuthorizationContext()
            {
                String partnerTokenString = TokenHelper.GetPartnerToken();
                audienceUriProvider.Uris.Clear();
                audienceUriProvider.Uris.Add("http://xboxlive.com/avatar");
                authContext = LiveNTokenIdentityModel.ValidatePartnerSamlToken(partnerTokenString);

            }

            public void CreateNoIdentityAuthContext()
            {
                List<IAuthorizationPolicy> list = new List<IAuthorizationPolicy>();
                list.Add(new NoIdentityCliamTokenAuthorizationPolicy());
                this.authContext = AuthorizationContext.CreateDefaultAuthorizationContext(list);
            }

            public void CreateNoClaimSetAuthContext()
            {
                List<IAuthorizationPolicy> list = new List<IAuthorizationPolicy>();
                list.Add(new NoCliamSetPolicy());
                this.authContext = AuthorizationContext.CreateDefaultAuthorizationContext(list);
            }

            #region IPartnerAuthAdapter Members

            public AuthorizationContext PartnerTokenContext
            {
                get {
                    
                    return this.authContext;
                }
            }

            #endregion

            class NoIdentityCliamTokenAuthorizationPolicy : IAuthorizationPolicy
            {
                ClaimSet globalCliamSet;
                ClaimSet issuerClaimSet;

                public NoIdentityCliamTokenAuthorizationPolicy()
                {
                    SetUpClaims();
                }

                Dictionary<Int32, Int32> stateObjectHash = new Dictionary<Int32, Int32>();

                #region IAuthorizationPolicy Members

                public bool Evaluate(EvaluationContext evaluationContext, ref object state)
                {
                    Int32 stateValue = 0;
                    if (state == null)
                    {
                        state = new Object();
                    }

                    Int32 stateHash = state.GetHashCode();
                    if (!this.stateObjectHash.TryGetValue(stateHash, out stateValue))
                    {
                        evaluationContext.AddClaimSet(this, this.globalCliamSet);
                        this.stateObjectHash.Add(stateHash, 1);
                        return true;
                    }

                    return false;

                }

                public System.IdentityModel.Claims.ClaimSet Issuer
                {
                    get
                    {
                        return this.issuerClaimSet;
                    }
                }

                #endregion

                #region IAuthorizationComponent Members

                public string Id
                {
                    get { return "TokenAuthorizationPolicy"; }
                }

                #endregion

                private void SetUpClaims()
                {
                    ClaimSet issuerClaimSet =
                      new DefaultClaimSet(new Claim[] { new Claim(LiveNTokenClaimTypes.IssuerClaimType, "Issuer", Rights.PossessProperty) });

                    Claim majorVersionClaim = new Claim(LiveNTokenClaimTypes.MajorVersionClaimType, "1.0", Rights.PossessProperty);
                    Claim issuerInstantClaim = new Claim(LiveNTokenClaimTypes.IssuerInstantClaimType, "issuerInstant", Rights.PossessProperty);
                    Claim minorVersionClaim = new Claim(LiveNTokenClaimTypes.MinorVersionClaimType, "1.0", Rights.PossessProperty);
                    Claim titleIdClaim = new Claim(LiveNTokenClaimTypes.TitleIdClaimType, "titleID", Rights.PossessProperty);
                    Claim titleVersionClaim = new Claim(LiveNTokenClaimTypes.TitleVersionClaimType, "titleVersion", Rights.PossessProperty);

                    Claim gamerTagClaim = new Claim(LiveNTokenClaimTypes.GamertagClaimType, "gamerTagCliam", Rights.PossessProperty);

                    //combine all the claims
                    List<Claim> finalClaims = new List<Claim>(new Claim[] {issuerInstantClaim, majorVersionClaim, 
                    minorVersionClaim, titleIdClaim, titleVersionClaim,
                    gamerTagClaim});

                    this.globalCliamSet = new DefaultClaimSet(issuerClaimSet, finalClaims);
                }

            }

            class NoCliamSetPolicy: IAuthorizationPolicy
            {

                #region IAuthorizationPolicy Members

                public bool Evaluate(EvaluationContext evaluationContext, ref object state)
                {
                    return true;

                }

                public System.IdentityModel.Claims.ClaimSet Issuer
                {
                    get
                    {
                        return null;
                    }
                }

                #endregion

                #region IAuthorizationComponent Members

                public string Id
                {
                    get { return "NoCliamSetPolicy"; }
                }

                #endregion
            }
        }

        class CustomXCacheDataAccess : IXCacheDataAccess
        {

            #region IXCacheDataAccess Members

            public bool GetGamertagByPuid(ulong livePuid, out string gamertag)
            {
                gamertag = "VDTEST01";

                return true;

            }

            public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
            {
                throw new NotImplementedException();
            }

            public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
            {
                throw new NotImplementedException();
            }

            public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
            {
                livePuid = 1234567;
                gamertag = "VDTEST01";

                return true;
            }

            #endregion
        }
    }

    


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\UnitTests\TokenAuthenticationTests.cs ===
﻿using System;
using System.IdentityModel;
using System.IdentityModel.Policy;
using System.IdentityModel.Claims;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Text;
using System.IdentityModel.Tokens;
using Leet.Identity;
using System.Configuration;
using Leet.Identity.TokenAuthentication.IdentityModel;
using Leet.Identity.TokenAuthentication.Diagnostics;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using System.IO;

namespace Leet.Identity.TokenAuthentication.UnitTests
{
    [TestClass]
    [DeploymentItem("RPSTicketGenerator.dll.config")]
    [DeploymentItem("longValidPartnerToken.txt")]
    public class TokenAuthenticationTests
    {
        private TestContext testContextInstance;
        private static CustomAudienceUriProvider audienceUriProvider = new CustomAudienceUriProvider();
        private static CustomConfigurationProvider configProvider = new CustomConfigurationProvider();
        static TokenAuthenticationTests()
        {
            Container.Instance.AddServiceWithInstance<IAudienceUriProvider>(audienceUriProvider);
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(configProvider);
        }

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }
        
        [TestMethod]
        public void PartnerTokenAuthenticationTest()
        {
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://xboxlive.com/avatar");

            String partnerTokenString = TokenHelper.GetPartnerToken();
            AuthorizationContext context = LiveNTokenIdentityModel.ValidatePartnerSamlToken(partnerTokenString);
            Assert.IsNotNull(context, "AuthorizationContext is null");
            Assert.IsNotNull(context.ClaimSets, "context.ClaimSets");
            Claim identityClaim = LiveNTokenIdentityModel.FindIdentityClaim(context.ClaimSets[0]);
            Assert.IsTrue(identityClaim != null, "No identity claim found");
            Assert.IsTrue(identityClaim.ClaimType == LiveNTokenClaimTypes.PartnerIDClaimType, "identity claim claim type is invalid");
            Assert.IsTrue(identityClaim.Right == Rights.Identity, "Claim rights must be Rights.Identity");
            
        }

        [TestMethod]
        public void VerifyAudienceUriClaim()
        {
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://xboxlive.com/avatar");
            String partnerTokenString = File.ReadAllText("longValidPartnerToken.txt");
            AuthorizationContext context = LiveNTokenIdentityModel.ValidatePartnerSamlToken(partnerTokenString);
            Assert.IsNotNull(context, "AuthorizationContext is null");
            Assert.IsNotNull(context.ClaimSets, "context.ClaimSets");

            foreach (Claim claim in context.ClaimSets[0])
            {
                switch (claim.ClaimType)
                {
                    case (LiveNTokenClaimTypes.AudienceUriClaimType):
                        {
                            IList<Uri> audiences = claim.Resource as IList<Uri>;
                            Assert.IsNotNull(audiences);
                            Assert.IsTrue(audiences.Count == 1);
                            return;
                        }
                }

            }

            Assert.Fail();

        }

        [TestMethod]
        [ExpectedException(typeof(System.IdentityModel.Tokens.SecurityTokenValidationException))]
        public void PartnerTokenAuthenticationInvalidSubjectTest()
        {
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://sts.xboxlive.com/");
            String userTokenString = TokenHelper.GetUserToken();
            AuthorizationContext context = LiveNTokenIdentityModel.ValidatePartnerSamlToken(userTokenString);
        }

        [TestMethod]
        [ExpectedException(typeof(System.IdentityModel.Tokens.SecurityTokenException))]
        public void PartnerTokenAuthenticationExpiredTokenTest()
        {
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://xboxlive.com/avatar");
            AuthorizationContext context = LiveNTokenIdentityModel.ValidatePartnerSamlToken(TestSettings.Default.ExpiredToken);
        }

        [TestMethod]
        [ExpectedException(typeof(SecurityStoreConfigurationException))]
        public void PartnerTokenAuthenticationNoAndMultipleCertificatesTest()
        {
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://xboxlive.com/avatar");
            configProvider.SettingsDictionary[Settings.StsCertificateSubject] = "WillNeverExistsCertWithThisName";

            String partnerTokenString = TokenHelper.GetPartnerToken();
            AuthorizationContext context = LiveNTokenIdentityModel.ValidatePartnerSamlToken(partnerTokenString);
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\UnitTests\TestSettings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Leet.Identity.TokenAuthentication.UnitTests{
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class TestSettings : global::System.Configuration.ApplicationSettingsBase {
        
        private static TestSettings defaultInstance = ((TestSettings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new TestSettings())));
        
        public static TestSettings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("<?xml version=\"1.0\" encoding=\"utf-16\"?><saml:Assertion MajorVersion=\"1\" MinorVers" +
            "ion=\"1\" AssertionID=\"SamlSecurityToken-fd336d3c-d78f-41e5-9165-23d50679aaa9\" Iss" +
            "uer=\"http://sts.xboxlive.com\" IssueInstant=\"2010-07-12T18:55:35.700Z\" xmlns:saml" +
            "=\"urn:oasis:names:tc:SAML:1.0:assertion\"><saml:Conditions NotBefore=\"2010-07-12T" +
            "18:55:35.700Z\" NotOnOrAfter=\"2010-07-12T22:55:32.603Z\"><saml:AudienceRestriction" +
            "Condition><saml:Audience>http://xboxlive.com/avatar</saml:Audience></saml:Audien" +
            "ceRestrictionCondition></saml:Conditions><saml:AttributeStatement><saml:Subject>" +
            "<saml:NameIdentifier Format=\"/xboxlive/nameFormat\" NameQualifier=\"Microsoft-Name" +
            "Qualifier-domain\">XboxLive Partner security ticket</saml:NameIdentifier></saml:S" +
            "ubject><saml:Attribute AttributeName=\"TitleID\" AttributeNamespace=\"http://xboxli" +
            "ve.com/claims\"><saml:AttributeValue>584D07D6</saml:AttributeValue></saml:Attribu" +
            "te><saml:Attribute AttributeName=\"TitleVersion\" AttributeNamespace=\"http://xboxl" +
            "ive.com/claims\"><saml:AttributeValue>1</saml:AttributeValue></saml:Attribute><sa" +
            "ml:Attribute AttributeName=\"PartnerID0\" AttributeNamespace=\"http://xboxlive.com/" +
            "claims\"><saml:AttributeValue>2600292641994138</saml:AttributeValue></saml:Attrib" +
            "ute><saml:Attribute AttributeName=\"Gamertag0\" AttributeNamespace=\"http://xboxliv" +
            "e.com/claims\"><saml:AttributeValue>VDTest01</saml:AttributeValue></saml:Attribut" +
            "e></saml:AttributeStatement><Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#" +
            "\"><SignedInfo><CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-e" +
            "xc-c14n#\"></CanonicalizationMethod><SignatureMethod Algorithm=\"http://www.w3.org" +
            "/2000/09/xmldsig#rsa-sha1\"></SignatureMethod><Reference URI=\"#SamlSecurityToken-" +
            "fd336d3c-d78f-41e5-9165-23d50679aaa9\"><Transforms><Transform Algorithm=\"http://w" +
            "ww.w3.org/2000/09/xmldsig#enveloped-signature\"></Transform><Transform Algorithm=" +
            "\"http://www.w3.org/2001/10/xml-exc-c14n#\"></Transform></Transforms><DigestMethod" +
            " Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"></DigestMethod><DigestValue>" +
            "jji2SQoTMW3ip9NI+BiuhNicABk=</DigestValue></Reference></SignedInfo><SignatureVal" +
            "ue>CWMZEuv6WIvRX9cwAyhi7gwxoUBDK/NrtSX3orOcKnvOHwcaAIpgDaFPjFnBgJA/Ngiy7rMlgrTPH" +
            "2GnPTyCJvHUpvsUF60YSioIwI7L0xgI8vLhv/hs17s3HxQWfcRXRbQsPu5BTdkIw7By25bg+piyTMHVv" +
            "ZKpPxtQ7zrKXKk=</SignatureValue><KeyInfo><X509Data><X509Certificate>MIICJzCCAZSg" +
            "AwIBAgIQ7YujYuC55LtHk8DFyxqDQDAJBgUrDgMCHQUAMCAxHjAcBgNVBAMTFXN0cy50ZXN0Lnhib3hs" +
            "aXZlLmNvbTAeFw0wOTA3MTMxNTU3MzdaFw0zOTEyMzEyMzU5NTlaMCAxHjAcBgNVBAMTFXN0cy50ZXN0" +
            "Lnhib3hsaXZlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAgz0fPGlZa73r2TWmQsQy72aT" +
            "iKdkAcuW18TyPUL3326CF03eiP3MDUR51U8flfssgt7+2lkuTYALTnCCG4n4XuRVu8JHGdAsGjSmfUpY" +
            "+EGjxo6A3DuCDJF3Aa0uXzt72OShgF2IcX3+PMJnqryiMXyiPxi6/I1FEZ+i2FWdSYsCAwEAAaNqMGgw" +
            "EwYDVR0lBAwwCgYIKwYBBQUHAwEwUQYDVR0BBEowSIAQodN354CzBxTNqhzW0A3gWqEiMCAxHjAcBgNV" +
            "BAMTFXN0cy50ZXN0Lnhib3hsaXZlLmNvbYIQ7YujYuC55LtHk8DFyxqDQDAJBgUrDgMCHQUAA4GBAEeU" +
            "yfLsUMQ1o3v9KmC4GV+9N0WMbmnv5iPusd0BiqtfNp0xcWUbwm1ea5Gw65nTmF5YJKmDN3VEIH4LyTgw" +
            "TPHLP1QFq4XHY97GXYieeYLJluW+TQTk8rn2rPrYre9yWQDvkijCwERT8F6zV59RKHMAuv36b0oCtSqM" +
            "CH6hxTRZ</X509Certificate></X509Data></KeyInfo></Signature></saml:Assertion>")]
        public string ExpiredToken {
            get {
                return ((string)(this["ExpiredToken"]));
            }
            set {
                this["ExpiredToken"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.PartnetAuthentication.UnitTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]


// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("560ff78b-7ea4-4437-9f5c-13d6e6508b07")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\UnitTests\PartnerAuthenticationAudienceUriTests.cs ===
﻿using System;
using System.IdentityModel;
using System.IdentityModel.Policy;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Text;
using System.IdentityModel.Tokens;
using Leet.Identity;
using System.Configuration;
using Leet.Core.Configuration;
using Leet.Identity.TokenAuthentication;
using Leet.Core.IoCCo;
using Leet.Identity.TokenAuthentication.IdentityModel;

namespace Leet.Identity.TokenAuthentication.UnitTests
{
    [TestClass]
    [DeploymentItem("RPSTicketGenerator.dll.config")]
    public class PartnerAuthenticationAudienceUriTests
    {
        private TestContext testContextInstance;
        private static CustomAudienceUriProvider audienceUriProvider = new CustomAudienceUriProvider();

        static PartnerAuthenticationAudienceUriTests()
        {
            Container.Instance.AddServiceWithInstance<IAudienceUriProvider>(audienceUriProvider);
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(new CustomConfigurationProvider());
        }

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        [TestMethod]
        [ExpectedException(typeof(SecurityTokenException))]
        public void InvalidAudienceUriTest()
        {
            String partnerTokenString = TokenHelper.GetPartnerToken();
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://xboxlive.com/blah");
            AuthorizationContext context = LiveNTokenIdentityModel.ValidatePartnerSamlToken(partnerTokenString);
        }


        [TestMethod]
        public void TokenSingleTargetMultipleExpectedAudienceUri()
        {
            String partnerTokenString =TokenHelper.GetPartnerToken();
            audienceUriProvider.Uris.Clear();
            audienceUriProvider.Uris.Add("http://xboxlive.com/avatar");
            audienceUriProvider.Uris.Add("http://xboxlive.com/avatar/async");
            LiveNTokenIdentityModel.ValidatePartnerSamlToken(partnerTokenString);
        }


    }

   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.TokenAuthentication\UnitTests\TokenHelper.cs ===
﻿using System;
using System.IdentityModel;
using System.IdentityModel.Policy;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Text;
using System.IdentityModel.Tokens;
using Leet.Identity;
using Leet.Core.Configuration;
using System.Configuration;

namespace Leet.Identity.TokenAuthentication.UnitTests
{
    class TokenHelper
    {

        public static String GetPartnerToken()
        {
            String partnerToken = String.Empty;
            String rpsTicket = LIVEnAuthClient.LIVEnAuthClient.GetRPSTicket("VDTEST01@xboxtest.com", "supersecret", ConfigurationManager.AppSettings["LiveIDServiceTarget"]);

            String userToken = LIVEnAuthClient.LIVEnAuthClient.GenerateSTSTicket(rpsTicket, GetConfigSetting("STSUrl"),
                                                                                            GetConfigSetting("PlatformId"),
                                                                                            GetConfigSetting("TitleId"),
                                                                                            GetConfigSetting("TitleVersion"),
                                                                                            GetConfigSetting("ClientVersion"),
                                                                                            GetConfigSetting("DeviceId"));

            //String audienceUri = "http%3A%2F%2Fxboxlive.com/avatar";

            partnerToken = LIVEnAuthClient.LIVEnAuthClient.GeneratePartnerSTSTicket(GetConfigSetting("STSUrl"), userToken, GetConfigSetting("TitleId"),
                                                                                            GetConfigSetting("TitleVersion"), "http://xboxlive.com/avatar");

            return partnerToken;
        }

        public static String GetUserToken()
        {
            String rpsTicket = LIVEnAuthClient.LIVEnAuthClient.GetRPSTicket("VDTEST01@xboxtest.com", "supersecret", ConfigurationManager.AppSettings["LiveIDServiceTarget"]);

            String userToken = LIVEnAuthClient.LIVEnAuthClient.GenerateSTSTicket(rpsTicket, GetConfigSetting("STSUrl"),
                                                                                            GetConfigSetting("PlatformId"),
                                                                                            GetConfigSetting("TitleId"),
                                                                                            GetConfigSetting("TitleVersion"),
                                                                                            GetConfigSetting("ClientVersion"),
                                                                                            GetConfigSetting("DeviceId"));

            return userToken;
        }

        public static String GetConfigSetting(String key)
        {
            String value = ConfigurationManager.AppSettings[key];
            return value;
        }

    }

    class CustomAudienceUriProvider : IAudienceUriProvider
    {
        List<String> uris = new List<String>();
        public CustomAudienceUriProvider()
        {
            
        }

        public List<String> Uris
        {
            get { return this.uris; }
        }

        #region IAudienceUriProvider Members

        public string[] AudienceUriList
        {
            get { return this.uris.ToArray(); }
        }

        #endregion
    }

    class CustomConfigurationProvider : IConfigurationProvider
    {
        public Dictionary<String, String> SettingsDictionary = new Dictionary<String, String>();

        public CustomConfigurationProvider()
        {
            this.SettingsDictionary.Add(Settings.StsCertificateSubject, "sts.test.xboxlive.com");
        }
        
        #region IConfigurationProvider Members

        public event SettingChangedEventHandler SettingChanged;

        public event MultiSettingChangedEventHandler MultiSettingChanged;

        public string GetSetting(string settingName)
        {
            String settingValue = String.Empty;
            this.SettingsDictionary.TryGetValue(settingName, out settingValue);

            return settingValue;
        }

        public bool GetBoolSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public int GetIntSetting(string settingName)
        {
            switch (settingName)
            {
                case (Settings.StsAddedTokenExpirationMinutes):
                    {
                        return 10;
                    }
                default:
                    {
                        throw new ArgumentException("settingName", "settingName");
                    }
            }
        }

        public long GetLongSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public double GetDoubleSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public string[] GetMultiSetting(string settingName)
        {
            throw new NotImplementedException();
        }

        public string GetConnectionString(string interfaceName)
        {
            throw new NotImplementedException();
        }

        public string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
        {
            throw new NotImplementedException();
        }

        public string Environment
        {
            get { throw new NotImplementedException(); }
        }

        public string ComponentName
        {
            get { throw new NotImplementedException(); }
        }

        public string Server
        {
            get { throw new NotImplementedException(); }
        }

        public IInterfaceInfo GetSingleInterface(string interfaceName)
        {
            throw new NotImplementedException();
        }

        public IInterfaceInfo GetInterface(string computerName, string interfaceName)
        {
            throw new NotImplementedException();
        }

        public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
        {
            throw new NotImplementedException();
        }

        public string GetSingleServerForInterface(string interfaceName)
        {
            throw new NotImplementedException();
        }

        #endregion

        public bool DummyMethod()
        {
            if (SettingChanged.GetInvocationList().Length > 0 && MultiSettingChanged.GetInvocationList().Length > 0)
            {
                return true;
            }

            return false;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\AuthenticationManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.IoCCo;
using Leet.Core.TestSupport;
using Leet.Identity;
using Leet.Live.Livecache.Account;
using System.IdentityModel.Claims;

namespace Leet.Identity.WindowsLiveAuth
{
    [PerWebRequestInstance]
    public class AuthenticationManager : IdentityManager, IWebsiteAuthenticationManager, ILcAuthManager
    {
        private IWindowsLiveIdentity wlid;
        private IUserIdentity currentUser;

        public AuthenticationManager(IWindowsLiveIdentity wlid)
        {
            this.wlid = wlid;
        }

        public static new void RegisterWithIocContainer(IContainer container)
        {
            IdentityManager.RegisterWithIocContainer(container);
            container.AddService<IAuthenticationManager, AuthenticationManager>();
            container.AddService<IWebsiteAuthenticationManager, AuthenticationManager>();
            container.AddService<ILcAuthManager, AuthenticationManager>();
            container.AddService<IWindowsLiveIdentity, WindowsLiveIdentity>();
            container.AddEmulatableService<IWindowsLiveIdentityAdapter, WindowsLiveIdentityAdapter>();
        }

        public IUserIdentity CurrentUser
        {
            get
            {
                if (this.currentUser == null)
                {
                    IUserIdentity user = base.CreateUserIdentityFromPuid(this.wlid.Puid);
                    user.Cid = this.wlid.Cid;
                    user.IsAuthenticated = this.wlid.IsAuthenticated;
                    this.currentUser = user;
                }
                return this.currentUser;
            }
        }

        public void SetCurrentUser(IUserIdentity user)
        {
            if (this.currentUser != null)
            {
                throw new ApplicationException("currentUser has already been created!!!");
            }
            this.currentUser = user;
        }

        public ILcAuthTicket GetAuthTicket()
        {
            return (ILcAuthTicket)this.CurrentUser;
        }


        public string GetLogOnLogOffUrl()
        {
            return this.wlid.GetLogOnLogOffUrl();
        }

        public string GetTextLinkForLoggingOnOrOff()
        {
            return this.wlid.GetTextLinkForLoggingOnOrOff();
        }

        public bool IsAuthenticated
        {
            get
            {
                return this.CurrentUser.IsAuthenticated;
            }
        }

        public ClaimSet GetClaims()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\IWindowsLiveIdentityAdapter.cs ===
﻿using System;

namespace Leet.Identity.WindowsLiveAuth
{
    /// <summary>
    /// This interface defines our touch points with RPS and allows
    /// for mocking out the RPS dependency.  We use this interface
    /// to emulate RPS.
    /// </summary>
    public interface IWindowsLiveIdentityAdapter
    {
        bool IsAuthenticated { get; }
        bool HasTicket { get; }

        string PuidHex { get; }
        string CidHex { get; }

        DateTime IssueInstant { get; }
        DateTime NotAfter { get; }

        string FirstName { get; }
        string LastName { get; }
        string MemberName { get; }

        //object this[string name] { get; }

        void Authenticate();
        void Authenticate(string authPolicy);
        string GetTextTag();
        string GetNetworkURL(string attributeName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904", Scope = "namespace", Target = "Leet.Identity.WindowsLiveAuth")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\WindowsLiveIdentity.cs ===
﻿using System;
using System.Globalization;

namespace Leet.Identity.WindowsLiveAuth
{
    [Leet.Core.IoCCo.PerWebRequestInstance]
    public class WindowsLiveIdentity : IWindowsLiveIdentity
    {
        private IWindowsLiveIdentityAdapter liveIdentity;

        public WindowsLiveIdentity(IWindowsLiveIdentityAdapter windowsLiveAdapter)
        {
            this.liveIdentity = windowsLiveAdapter;
            this.liveIdentity.Authenticate();
        }

        public long Cid
        {
            get
            {
                //string hexCid = this.GetProfileProperty("HexCID");
                string hexCid = this.liveIdentity.CidHex;
                ulong cid = ulong.Parse(hexCid, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
                return (long)cid;
            }
        }

        public string FirstName
        {
            get { return this.liveIdentity.FirstName; }
        }

        public bool HasTicket()
        {
            return this.liveIdentity.HasTicket;
        }

        public string LastName
        {
            get { return this.liveIdentity.LastName; }
        }

        public string MemberName
        {
            get { return this.liveIdentity.MemberName; }
        }

        public long Puid
        {
            get
            {
                string hexPuid = this.liveIdentity.PuidHex;
                ulong puid = ulong.Parse(hexPuid, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
                return (long)puid;
            }
        }

        public DateTime IssueInstant
        {
            get
            {
                return this.liveIdentity.IssueInstant;
            }
        }

        public DateTime NotAfter
        {
            get
            {
                return this.liveIdentity.NotAfter;
            }
        }

        public bool IsAuthenticated
        {
            get { return this.liveIdentity.IsAuthenticated; }
        }

        public string GetTextLinkForLoggingOnOrOff()
        {
            return this.liveIdentity.GetTextTag();
        }

        public string GetLogOnLogOffUrl()
        {
            return this.liveIdentity.GetNetworkURL((this.IsAuthenticated) ? "Logout" : "Auth");
        }

        private void AssertTicket()
        {
            if (!this.liveIdentity.HasTicket)
            {
                throw new InvalidOperationException("No Passport ticket.\r\nNote: RpsIdentity methods retrieving ticket properties only work if a user is signed in.");
            }
        }

        /*
        private string GetProfileProperty(string propertyName)
        {
            this.AssertTicket();
            object o = this.liveIdentity[propertyName];
            return Convert.ToString(o, CultureInfo.InvariantCulture);
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\IWindowsLiveIdentity.cs ===
﻿using System;
using System.Security.Principal;

namespace Leet.Identity.WindowsLiveAuth
{
    public interface IWindowsLiveIdentity
    {
        bool IsAuthenticated { get; }

        long Puid { get; }
        long Cid { get; }

        DateTime IssueInstant { get; }
        DateTime NotAfter { get; }

        bool HasTicket();
        string FirstName { get; }
        string LastName { get; }
        string MemberName { get; }

        string GetTextLinkForLoggingOnOrOff();
        string GetLogOnLogOffUrl();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Resources;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("bb4853db-09f5-4330-917f-ee3c14f65dfa")]

[assembly: System.CLSCompliant(false)]

[assembly: NeutralResourcesLanguageAttribute("en")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Resources;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.WindowsLiveAuth")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("73f5d3f5-b7b2-4ee8-96c2-818e2d53c659")]

[assembly: System.CLSCompliant(false)]

[assembly: NeutralResourcesLanguageAttribute("en")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity.Test\Leet.Identity.WindowsLiveAuth\WindowsLiveIdentityTests.cs ===
﻿using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.IoCCo;

namespace Leet.Identity.WindowsLiveAuth.Test
{
    /// <summary>
    /// Unit tests for the WindowsLiveIdentity class
    /// </summary>
    [TestClass]
    public class WindowsLiveIdentityTests
    {
        [TestMethod]
        public void WindowsLiveIdentity_Handles_Unauthenticated_Request()
        {
            // Arrange
            IWindowsLiveIdentityAdapter fakeAdapter = new FakeRpsAdapter(false, false);

            // Act
            IWindowsLiveIdentity windowsLiveIdentity = new WindowsLiveIdentity(fakeAdapter);
            bool isAuthenticated = windowsLiveIdentity.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(false, isAuthenticated);
            this.AssertAuthUrls(windowsLiveIdentity, fakeAdapter);
        }

        [TestMethod]
        public void WindowsLiveIdentity_Handles_Authenticated_Request_Without_Profile()
        {
            // Arrange
            IWindowsLiveIdentityAdapter fakeAdapter = new FakeRpsAdapter(true, false);

            // Act
            IWindowsLiveIdentity windowsLiveIdentity = new WindowsLiveIdentity(fakeAdapter);
            bool isAuthenticated = windowsLiveIdentity.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(true, isAuthenticated);
            this.AssertIdentity(windowsLiveIdentity, fakeAdapter);
            this.AssertAuthUrls(windowsLiveIdentity, fakeAdapter);
        }

        [TestMethod]
        public void WindowsLiveIdentity_Handles_Authenticated_Request_With_Profile()
        {
            // Arrange
            IWindowsLiveIdentityAdapter fakeAdapter = new FakeRpsAdapter(true, true);

            // Act
            IWindowsLiveIdentity windowsLiveIdentity = new WindowsLiveIdentity(fakeAdapter);
            bool isAuthenticated = windowsLiveIdentity.IsAuthenticated;

            // Assert
            Assert.AreEqual<bool>(true, isAuthenticated);
            this.AssertIdentity(windowsLiveIdentity, fakeAdapter);
            this.AssertProfile(windowsLiveIdentity, fakeAdapter);
            this.AssertAuthUrls(windowsLiveIdentity, fakeAdapter);
        }

        private void AssertIdentity(IWindowsLiveIdentity identity, IWindowsLiveIdentityAdapter fakeAdapter)
        {
            Assert.AreEqual(fakeAdapter.CidHex, identity.Cid.ToString("X16", CultureInfo.InvariantCulture), true);
            Assert.AreEqual(fakeAdapter.PuidHex, identity.Puid.ToString("X16", CultureInfo.InvariantCulture), true);
        }

        private void AssertProfile(IWindowsLiveIdentity identity, IWindowsLiveIdentityAdapter fakeAdapter)
        {
            Assert.AreEqual<bool>(true, identity.HasTicket());
            Assert.AreEqual(fakeAdapter.FirstName, identity.FirstName);
            Assert.AreEqual(fakeAdapter.LastName, identity.LastName);
            Assert.AreEqual(fakeAdapter.MemberName, identity.MemberName);
        }

        private void AssertAuthUrls(IWindowsLiveIdentity identity, IWindowsLiveIdentityAdapter fakeAdapter)
        {
            Assert.AreEqual(fakeAdapter.GetTextTag(), identity.GetTextLinkForLoggingOnOrOff());
            Assert.AreEqual(fakeAdapter.GetNetworkURL("Auth"), identity.GetLogOnLogOffUrl());
        }
    }

    /// <summary>
    /// FakeRpsAdapter provides fake RPS data for unit testing
    /// </summary>
    internal class FakeRpsAdapter : IWindowsLiveIdentityAdapter
    {
        private bool authenticationState;
        private bool profileState;

        public FakeRpsAdapter(bool isAuthenticated, bool hasProfile)
        {
            this.authenticationState = isAuthenticated;
            this.profileState = hasProfile;
        }

        public bool IsAuthenticated { get; set; }
        public bool HasTicket { get; set; }
        public string PuidHex { get; set; }
        public string CidHex { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string MemberName { get; set; }

        public void Authenticate()
        {
            CreateFakeData(this.authenticationState, this.profileState);
        }

        public string GetTextTag()
        {
            return string.Format("<a href='{0}'>Login</a>", this.GetNetworkURL("Auth"));
        }

        public string GetNetworkURL(string attributeName)
        {
            return "http://" + attributeName;
        }

        public DateTime IssueInstant
        {
            get { throw new NotImplementedException(); }
        }

        public DateTime NotAfter
        {
            get { throw new NotImplementedException(); }
        }

        private void CreateFakeData(bool isAuthenticated, bool hasProfile)
        {
            this.IsAuthenticated = isAuthenticated;

            if (isAuthenticated)
            {
                Random rand = new Random();
                int puidHigh = rand.Next(int.MinValue, int.MaxValue);
                int puidLow = rand.Next(int.MinValue, int.MaxValue);
                this.PuidHex = puidHigh.ToString("X8", CultureInfo.InvariantCulture) + puidLow.ToString("X8", CultureInfo.InvariantCulture);
                this.CidHex = puidLow.ToString("X8", CultureInfo.InvariantCulture) + puidHigh.ToString("X8", CultureInfo.InvariantCulture);
                this.HasTicket = true;

                if (hasProfile)
                {
                    this.FirstName = "Test";
                    this.LastName = "User" + rand.Next();
                    this.MemberName = this.FirstName + this.LastName + "@hotmail.com";
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Leet.Identity.WindowsLiveAuth\WindowsLiveIdentityAdapter.cs ===
﻿using System;
using System.Configuration;
using System.Web;
using System.Text.RegularExpressions;
using System.Text;
using Microsoft.Passport.RPS;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;

namespace Leet.Identity.WindowsLiveAuth
{
    public static class RpsStatic
    {
        public static RPS RPS { get; set; }
        public static RPSDomainMap DomainMap { get; set; }

        static RpsStatic()
        {
            RPS = new RPS();
            RPS.Initialize("");
            DomainMap = (RPSDomainMap)RPS.GetObject("rps.net.domainmap");
        }
    }

    /// <summary>
    /// This class handles calling and interfacing with RPS APIs.
    /// We use this class and interface to abstract and emulate RPS.
    /// </summary>
    [Leet.Core.IoCCo.PerWebRequestInstance]
    public class WindowsLiveIdentityAdapter : IWindowsLiveIdentityAdapter
    {
        private const string HBI_AUTH_POLICY = "SAPI";
        private const string MBI_AUTH_POLICY = "MBI";
        private const string LBI_AUTH_POLICY = "LBI";
        private const string DEFAULT_AUTH_POLICY = "MBI";

        private const uint PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED = 0x8004922f;
        private const uint PP_E_RPS_INVALIDDATA = 0x80049217;
        private const uint PP_E_RPS_REASON_TIMEWINDOW_EXPIRED = 0x80049228;

        private HttpRequest _request;
        private RPSHttpAuth _rpsHttpAuth;
        private RPSTicket _rpsTicket;
        private IConfigurationProvider _config;
        private ILogging _logging;
        private string _siteName;
        private string _rpsResponseHeaders;
        private bool _hasValidTicket;
        private bool _ticketExpired;
        private string _authPolicy = DEFAULT_AUTH_POLICY;

        public WindowsLiveIdentityAdapter(IConfigurationProvider configurationProvider, ILogging logging)
        {
            _config = configurationProvider;
            _logging = logging;
        }


        private void Init()
        {
            if (_rpsHttpAuth != null)
            {
                return; // Init has already been called
            }

            // try and determine the rps site name by building up an interface reference:
            try
            {
                string endpoint = _config.GetInterfaceEndpoint("xboxcom_live", false);
                Uri u = new Uri(endpoint);
                _siteName = u.Host;
            }
            catch (ConfigurationErrorsException ce)
            {
                _logging.LogEvent(new RPSConfigurationEvent(), ce);
                _siteName = _config.GetSetting(Settings.RPSSiteName);
            }


            try
            {
                _rpsHttpAuth = new RPSHttpAuth(RpsStatic.RPS);
                _request = HttpContext.Current.Request;

                RPSPropBag propertyBag = GetPropertyBag();
                _rpsTicket = _rpsHttpAuth.Authenticate(_siteName, _request, propertyBag);
                _rpsResponseHeaders = propertyBag["RPSRespHeaders"].ToString();
            }
            catch (Exception ex)
            {
                HandleRpsError(ex);
            }
        }

        private bool ValidateTicket(string authPolicy)
        {
            _authPolicy = authPolicy;
            return ValidateTicket();
        }

        private bool ValidateTicket()
        {
            _hasValidTicket = false;

            if (_rpsTicket != null)
            {
                // validate rps ticket
                RPSPropBag param = GetPropertyBag();
                param["AuthPolicy"] = _authPolicy;

                try
                {
                    if (_rpsTicket.Validate(param))
                    {
                        _hasValidTicket = true;
                    }
                    else
                    {
                        uint hresult = (uint)(int)param["ReasonHR"]; // have to do double cast to handle "Can't unbox ReasonHR as uint" errors
                        _ticketExpired = (hresult == PP_E_RPS_REASON_TIMEWINDOW_EXPIRED);
                    }
                }
                catch (Exception ex)
                {
                    HandleRpsError(ex);
                }
            }

            return _hasValidTicket;
        }

        public void Authenticate()
        {
            Init();
            ValidateTicket();
        }

        public void Authenticate(string authPolicy)
        {
            Init();
            ValidateTicket(authPolicy);
        }

        public bool IsAuthenticated
        {
            get
            {
                return _hasValidTicket;
            }
        }

        public bool HasTicket
        {
            get
            {
                return (_rpsTicket != null);
            }
        }

        public bool IsTicketExpired
        {
            get
            {
                return _ticketExpired;  // Note: returns false if no ticket is available
            }
        }

        public ulong Puid
        {
            get
            {
                return ulong.Parse(this.PuidHex, System.Globalization.NumberStyles.HexNumber);
            }
        }

        public string PuidHex
        {
            get
            {
                if (!this.HasTicket)
                {
                    throw new InvalidOperationException("Must call Authenticate before using the PuidHex property.");
                }
                return _rpsTicket.Property["HexPUID"].ToString();
            }
        }

        public string CidHex
        {
            get
            {
                if (!this.HasTicket)
                {
                    throw new InvalidOperationException("Must call Authenticate before using the CidHex property.");
                }
                return _rpsTicket.Property["HexCID"].ToString();
            }
        }

        public DateTime IssueInstant
        {
            get
            {
                if (!this.HasTicket)
                {
                    throw new InvalidOperationException("Must call Authenticate before using the IssueInstant property.");
                }

                DateTime date19700101 = new DateTime(1970, 1, 1);
                return date19700101.AddSeconds((UInt32)_rpsTicket.Property["IssueInstant"]);
            }
        }

        public DateTime NotAfter
        {
            get
            {
                if (!this.HasTicket)
                {
                    throw new InvalidOperationException("Must call Authenticate before using the NotAfter property.");
                }

                DateTime date19700101 = new DateTime(1970, 1, 1);
                return date19700101.AddSeconds((UInt32)_rpsTicket.Property["NotAfter"]);
            }
        }

        public string FirstName
        {
            //get { return _rpsTicket.ProfileProperty["firstname"].ToString(); }
            get { throw new NotImplementedException(); }
        }

        public string LastName
        {
            //get { return _rpsTicket.ProfileProperty["lastname"].ToString(); }
            get { throw new NotImplementedException(); }
        }

        public string MemberName
        {
            //get { return _rpsTicket.ProfileProperty["membername"].ToString(); }
            get { throw new NotImplementedException(); }
        }

        public string LogoTag()
        {
            Init();
            string returnUrl = null;

            if (!this.IsAuthenticated)
            {
                returnUrl = this.SigninReturnUrl(_request.Url.ToString());
            }

            bool isSSL = _request.IsSecureConnection;
            return this.LogoTag(isSSL, -1, null, returnUrl);
        }

        public string LogoTag(bool secureImg, int lcid, string cobrandArgs, string returnUrl)
        {
            Init();

            RPSPropBag additionalParams = BuildPropertyBag(returnUrl, lcid, cobrandArgs);

            return _rpsHttpAuth.LogoTag(
                this.IsAuthenticated,
                secureImg,
                "Auth", // urlName,
                null, // domainName,
                _siteName,
                additionalParams
                ); 
        }

        public string GetNetworkURL(string attributeName)
        {
            Init();
            string returnUrl = null;

            if (!this.IsAuthenticated)
            {
                returnUrl = this.SigninReturnUrl(_request.Url.ToString());
            }

            return this.GetNetworkURL(attributeName, returnUrl, -1, null);
        }

        public string GetNetworkURL(string attributeName, string returnUrl, int lcid, string cobrandArgs)
        {
            Init();
            RPSPropBag propBag = BuildPropertyBag(returnUrl, lcid, cobrandArgs);
            return RpsStatic.DomainMap.ConstructURL(attributeName, _siteName, null, propBag);
        }

        public string GetTextTag()
        {
            return GetTextTag(null, -1, null);
        }
        
        public string GetTextTag(string returnUrl, int lcid, string cobrandArgs)
        {
            Init();

            string html = String.Empty;
            bool isSSL = _request.IsSecureConnection;

            RPSPropBag propBag = BuildPropertyBag(null, lcid, cobrandArgs);

            if (!this.IsAuthenticated)
            {
                if (returnUrl == null)
                {
                    returnUrl = _request.Url.ToString();
                }
                propBag["ReturnURL"] = this.SigninReturnUrl(returnUrl);
                html = _rpsHttpAuth.TextTag(true, isSSL, "Auth", null, _siteName, propBag);
            }
            else
            {
                html = _rpsHttpAuth.TextTag(false, isSSL, "Auth", null, _siteName, propBag);
                                
                Regex hrefRegex = new Regex("href=\".+\"", RegexOptions.Compiled);
                Match match = hrefRegex.Match(html);
                if (match.Success)
                {
                    string homeUrl = returnUrl ?? String.Concat(_config.GetInterfaceEndpoint("liveweb_www", false), "/home");
                    string linkHref = match.Value;

                    // TODO:  Switch to using a better URL Encode (IoSec?)
                    linkHref = String.Format("{0}&lru={1}\"", linkHref.TrimEnd('"'), HttpUtility.UrlEncode(homeUrl));

                    html = html.Replace(match.Value, linkHref);
                }
            }

            return html;
        }


        /// <summary>
        /// Helper method to construct the return URL for the RPS sign in
        /// </summary>
        /// <param name="realReturnUrl">URL the user wishes to return to after signing in</param>
        /// <returns></returns>
        private string SigninReturnUrl(string realReturnUrl)
        {
            string setPassportCookiesUrl;
            // try and determine the rps site name by building up an interface reference:
            try
            {
                string endpoint = _config.GetInterfaceEndpoint("xboxcom_live", true);
                UriBuilder setCookieBuilder = new UriBuilder(endpoint)
                                                  {
                                                      Path = "/xweb/live/passport/setCookies.ashx"
                                                  };
                setPassportCookiesUrl = setCookieBuilder.ToString();
            }
            catch (ConfigurationErrorsException ce)
            {
                _logging.LogEvent(new RPSConfigurationEvent(), ce);
                setPassportCookiesUrl = _config.GetSetting(Settings.RPSReturnUrl);
            }
            string encodedReturnUrl = UrlEncode2(realReturnUrl);

            return String.Format("{0}?rru={1}", setPassportCookiesUrl, encodedReturnUrl);
        }

        /// <summary>
        /// A custom URL encoding method that makes the the URL encoding proprietary so only we
        /// can decode it.
        /// This is required by the Xbox.com SetCookies.ashx handler for proper sign-in behavior.
        /// </summary>
        /// <param name="url">URL to encode</param>
        /// <returns></returns>
        private static string UrlEncode2(string url)
        {
            if (url == null) return null;

            byte[] utf8 = (new UTF8Encoding()).GetBytes(url);
            StringBuilder sb = new StringBuilder(150);
            const string hexDigit = "0123456789ABCDEF";
            for (int i = 0; i < utf8.Length; i++)
            {
                byte c = utf8[i];
                if ('0' <= c && c <= '9' || 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Y')
                {
                    sb.Append((char)c);
                }
                else
                {
                    sb.Append('Z');
                    sb.Append(hexDigit[c / 16]);
                    sb.Append(hexDigit[c % 16]);
                }
            }

            return sb.ToString();
        }

        private static RPSPropBag BuildPropertyBag(string returnUrl, int lcId, string cobrandArgs)
        {
            RPSPropBag propBag = GetPropertyBag();

            if (returnUrl != null)
            {
                propBag["ReturnURL"] = returnUrl;
            }

            if (lcId != -1)
            {
                propBag["LanguageID"] = lcId;
            }

            if (cobrandArgs != null)
            {
                propBag["CoBrandTemplate"] = cobrandArgs;
            }

            return propBag;
        }

        private static RPSPropBag GetPropertyBag()
        {
            RPSPropBag propBag;
            
            try
            {
                propBag = new RPSPropBag(RpsStatic.RPS);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Cannot initialize RPS property bag.", ex);
            }

            if (propBag == null)
            {
                throw new InvalidOperationException("Cannot initialize RPS property bag.");
            }

            return propBag;
        }

        private void HandleRpsError(Exception ex)
        {
            if (ex is System.Runtime.InteropServices.COMException)
            {
                System.Runtime.InteropServices.COMException comErr = ex as System.Runtime.InteropServices.COMException;
                HandleRpsComError(comErr);
            }
            else if (ex is ArgumentException)
            {
                //HttpContext.Current.Trace.Warn("RPS", "RPS config error", argErr);
                throw new HttpException(500, "RPS Config Error", ex);
            }
            else
            {
                //HttpContext.Current.Trace.Warn("RPS", "Unknown RPS error", ex);
                throw new HttpException(500, "Unknown RPS Error", ex);
            }
        }

        private void HandleRpsComError(System.Runtime.InteropServices.COMException ex)
        {
            uint hr = 0;
            try
            {
                hr = (uint)ex.ErrorCode;
            }
            catch { }

            //
            // assign special event IDs to distinguish common errors
            //
            if (hr == PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED || hr == PP_E_RPS_INVALIDDATA)
            {
                HttpContext ctx = HttpContext.Current;
                HttpRequest req = (ctx == null) ? null : ctx.Request;
                Uri urlref = (req == null) ? null : req.UrlReferrer;
                string referer = (urlref == null) ? null : urlref.Query;

                if (referer != null && referer.IndexOf("wreply=") >= 0)
                {
                    // request came from RPS login server
                    if (hr == PP_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED)
                    {
                        //throw new ExceptionWithEventId((XEvent.Id)WebSysEventId.SigninMgr_FErrorFromRPS, "RPS f code", ex);
                        //TODO - Handle and log error
                        //HttpContext.Current.Trace.Warn("RPS", "RPS F Error Encountered", ex);
                        throw new HttpException(500, "RPS F Error Encountered", ex);
                    }
                    else
                    {
                        //throw new ExceptionWithEventId((XEvent.Id)WebSysEventId.SigninMgr_BadTicketFromRPS, "Bad RPS ticket", ex);
                        //TODO - Handle and log error
                        //HttpContext.Current.Trace.Warn("RPS", "Bad RPS ticket", ex);
                        throw new HttpException(500, "Bad RPS ticket", ex);
                    }
                }
                else if (referer != null && referer.IndexOf("ru=") >= 0)
                {
                    // request came from PPM login server
                    //throw new ExceptionWithEventId((XEvent.Id)WebSysEventId.SigninMgr_ReturnFromPPM, "Bad PPM ticket", ex);
                    //TODO - Handle and log error
                    //HttpContext.Current.Trace.Warn("RPS", "Bad PPM ticket", ex);
                    throw new HttpException(500, "Bad PPM ticket", ex);
                }
                else
                {
                    // when a page expects a t or f parameter RPS will _always_ throw an exception, so we'll explicitly 
                    // avoid logging it here.
                }
            }
            else
            {
                //throw;
                //HttpContext.Current.Trace.Warn("RPS", "RPS COM Error", ex);
                throw new HttpException(500, "RPS COM Error", ex);
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity.Test\Leet.Identity.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("Leet.Identity.Test")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ab7381d5-fc07-4619-8ec7-1cd6475ef5da")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity.Test\Leet.Identity.WindowsLiveAuth\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Identity.WindowsLiveAuth.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a2946c5f-035f-4367-8a21-6451dba7d865")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity.Test\Leet.Identity.Test\UserIdentityTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Live.Livecache.DataAccess;
using Leet.Identity;
using Leet.Core.IoCCo;

namespace Leet.Identity.Test
{
    /// <summary>
    /// Summary description for UserIdentityTest
    /// </summary>
    [TestClass]
    public class UserIdentityTest
    {
        [TestMethod]
        public void UserIdentity_Can_Retrieve_Xuid_From_Puid()
        {
            // Arrange
            long puid = (long)UserIdentityTest.GenerateRandomId();
            FakeXCache fakeXCache = new FakeXCache(puid);
            UserIdentity user = new UserIdentity();
            user.XCache = fakeXCache;
            user.Puid = puid;

            // Act
            ulong xuid = user.Xuid;

            // Assert
            Assert.AreEqual(fakeXCache.Xuid, xuid);
        }

        [TestMethod]
        public void UserIdentity_Can_Retrieve_Gamertag_From_Puid()
        {
            // Arrange
            long puid = UserIdentityTest.GenerateRandomId();
            FakeXCache fakeXCache = new FakeXCache(puid);
            UserIdentity user = new UserIdentity();
            user.XCache = fakeXCache;
            user.Puid = puid;

            // Act
            string gamertag = user.Gamertag;

            // Assert
            Assert.AreEqual(fakeXCache.Gamertag, gamertag);
        }

        [TestMethod]
        public void UserIdentity_Can_Retrieve_Gamertag_From_Xuid()
        {
            // Arrange
            FakeXCache fakeXCache = new FakeXCache(0);
            UserIdentity user = new UserIdentity();
            user.XCache = fakeXCache;
            user.Xuid = fakeXCache.Xuid;

            // Act
            string gamertag = user.Gamertag;

            // Assert
            Assert.AreEqual(fakeXCache.Gamertag, gamertag);
        }

        [TestMethod]
        public void UserIdentity_Retrieves_Xuid_And_Gamertag_Only_Once()
        {
            // Arrange
            long puid = UserIdentityTest.GenerateRandomId();
            FakeXCache fakeXCache = new FakeXCache(puid);
            UserIdentity user = new UserIdentity();
            user.XCache = fakeXCache;
            user.Puid = puid;

            // Act
            ulong xuid1 = user.Xuid;
            string gamertag1 = user.Gamertag;
            
            // Change xuid and gamertag, which should have no effect
            // if UserIdentity is caching these fields
            fakeXCache.Xuid = (ulong)(xuid1 ^ 13);
            fakeXCache.Gamertag = "foo";

            // Re-retrieve the xuid and gamertag
            ulong xuid2 = user.Xuid;
            string gamertag2 = user.Gamertag;

            // Assert
            // Verify that xuid and gamertag are unchanged
            Assert.AreEqual(xuid1, xuid2);
            Assert.AreEqual(gamertag1, gamertag2);
            Assert.AreNotEqual(fakeXCache.Xuid, xuid2);
            Assert.AreNotEqual(fakeXCache.Gamertag, gamertag2);
        }

        [TestMethod]
        public void UserIdentity_Builds_Correct_IdentityKey()
        {
            // Arrange
            IUserIdentity user = new UserIdentity();
            user.Xuid = ulong.MaxValue;// FFFFFFFFFFFFFFFF
            user.Puid = -1234567890;   // FFFFFFFFB669FD2E
            user.Cid = 1234567890;     // 00000000499602D2

            // Act
            string identityKey = user.IdentityKey;

            // Assert
            Assert.IsNotNull(identityKey);
            Assert.AreEqual(48, identityKey.Length);
            Assert.AreEqual("FFFFFFFFFFFFFFFFFFFFFFFFB669FD2E00000000499602D2", identityKey);
        }

        [TestMethod]
        public void UserIdentity_Can_Be_Created_From_IdentityKey()
        {
            // Act
            IUserIdentity user = new UserIdentity("FFFFFFFFFFFFFFFFFFFFFFFFB669FD2E00000000499602D2");

            // Assert
            Assert.AreEqual(ulong.MaxValue, user.Xuid);
            Assert.AreEqual(-1234567890, user.Puid);
            Assert.AreEqual(1234567890, user.Cid);
        }

        [TestMethod]
        public void UserIdentity_ToString_Returns_IdentityKey()
        {
            // Arrange
            IUserIdentity user = new UserIdentity();
            user.Xuid = ulong.MaxValue;// FFFFFFFFFFFFFFFF
            user.Puid = -1234567890;   // FFFFFFFFB669FD2E
            user.Cid = 1234567890;     // 00000000499602D2

            // Act
            string toString = user.ToString();

            // Assert
            Assert.IsNotNull(toString);
            Assert.AreEqual(48, toString.Length);
            Assert.AreEqual("FFFFFFFFFFFFFFFFFFFFFFFFB669FD2E00000000499602D2", toString);
            Assert.AreEqual(user.IdentityKey, toString);
        }

        [TestMethod]
        public void UserIdentity_ToString_Returns_IdentityKey2()
        {
            // Arrange
            IContainer testContainer = new Container();
            testContainer.AddService<IXCacheDataAccess, FakeXCache>();
            Container.UseLocalContainer(testContainer);

            FakeXCache fakeXCache = (FakeXCache)testContainer.GetComponent<IXCacheDataAccess>();
            IUserIdentity user = new UserIdentity(fakeXCache.Puid);

            // Act
            string toStringValue = user.ToString();

            // Assert
            Assert.IsNotNull(toStringValue);
            Assert.IsTrue(toStringValue.Length > 0);
            Assert.AreEqual(user.IdentityKey, toStringValue);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void UserIdentity_Constructor_Throws_On_Null_Key()
        {
            new UserIdentity(null);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void UserIdentity_Constructor_Throws_On_Invalid_Key()
        {
            new UserIdentity("foo");
        }

        [TestMethod]
        public void IdentityKey_Is_Expected_Length_When_IDs_Are_Zero()
        {
            // Arrange
            IUserIdentity user = new UserIdentity();
            user.Xuid = 0;
            user.Puid = 0;
            user.Cid = 0;

            // Act
            string identityKey = user.IdentityKey;

            // Assert
            Assert.IsNotNull(identityKey);
            Assert.AreEqual(48, identityKey.Length);
            Assert.AreEqual("000000000000000000000000000000000000000000000000", identityKey);
        }

        [TestMethod]
        public void UserIdentities_Are_Equal_If_Underlying_Users_Are_The_Same()
        {
            // Arrange
            IContainer testContainer = new Container();
            testContainer.AddService<IXCacheDataAccess, FakeXCache>();
            Container.UseLocalContainer(testContainer);
            FakeXCache fakeXCache = (FakeXCache)testContainer.GetComponent<IXCacheDataAccess>();

            // Act
            IUserIdentity user1 = new UserIdentity(fakeXCache.Puid);
            IUserIdentity user2 = new UserIdentity(fakeXCache.Puid);

            // Assert
            Assert.IsTrue(user1.Equals(user2));
            Assert.IsTrue(user2.Equals(user1));
            Assert.IsTrue(user1.GetHashCode() == user2.GetHashCode());
        }

        [TestMethod]
        public void UserIdentities_Are_NOT_Equal_If_Underlying_Users_Are_Different()
        {
            // Arrange
            long puid = UserIdentityTest.GenerateRandomId();
            FakeXCache fakeXCache = new FakeXCache(puid);
            UserIdentity user1 = new UserIdentity();
            user1.XCache = fakeXCache;
            user1.Puid = puid;

            UserIdentity user2 = new UserIdentity();
            user2.XCache = fakeXCache;
            user2.Puid = -puid;

            // Assert
            Assert.IsFalse(user1.Equals(user2));
            Assert.IsFalse(user2.Equals(user1));
            Assert.IsFalse(user1.GetHashCode() == user2.GetHashCode());
        }

        [TestMethod]
        public void UserIdentity_Can_Retrieve_Xbox_Account_Info()
        {
            // Arrange
            long puid = UserIdentityTest.GenerateRandomId();
            ulong xuid = (ulong)UserIdentityTest.GenerateRandomId();
            UserIdentity user = new UserIdentity(puid, xuid);
            IContainer testContainer = new Container();
            testContainer.AddService<IAccountCreationDataAccess, FakeAccountCreationDataAccess>();
            Container.UseLocalContainer(testContainer);

            // Act
            SubscriptionTier tier = user.Tier;

            // Assert
            FakeAccountCreationDataAccess fakeAccountInfo = (FakeAccountCreationDataAccess)Container.Instance.GetComponent<IAccountCreationDataAccess>();
            Assert.AreEqual<uint>(fakeAccountInfo.Tier, (uint)tier);
            Assert.AreEqual(fakeAccountInfo.ParentalControlGroup, user.ParentalControlGroup);
            Assert.AreSame(fakeAccountInfo.Privileges, user.Privileges);
        }

        private static long GenerateRandomId()
        {
            Random rand = new Random();
            int high = rand.Next(int.MinValue, int.MaxValue);
            int low = rand.Next(int.MinValue, int.MaxValue);
            return ((high << 32) | low);
        }

        [SingletonInstance]
        public class FakeXCache : IXCacheDataAccess
        {
            public long Puid;
            public ulong Xuid;
            public string Gamertag;

            public FakeXCache()
            {
                this.Puid = UserIdentityTest.GenerateRandomId();
                this.Xuid = (ulong)UserIdentityTest.GenerateRandomId();
                this.Gamertag = "Gamertag " + UserIdentityTest.GenerateRandomId();
            }

            internal FakeXCache(long puid)
            {
                this.Puid = puid;
                this.Xuid = (ulong)UserIdentityTest.GenerateRandomId();
                this.Gamertag = "Gamertag " + UserIdentityTest.GenerateRandomId();
            }

            public bool GetGamertagByPuid(ulong xuid, out string gamertag)
            {
                if (xuid == this.Xuid)
                {
                    gamertag = this.Gamertag;
                    return true;
                }
                else
                {
                    gamertag = string.Empty;
                    return false;
                }
            }

            public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
            {
                throw new NotImplementedException();
            }

            public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
            {
                throw new NotImplementedException();
            }

            public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
            {
                if (passportPuid == (ulong)this.Puid)
                {
                    livePuid = this.Xuid;
                    gamertag = this.Gamertag;
                    return true;
                }
                else
                {
                    livePuid = 0;
                    gamertag = string.Empty;
                    return false;
                }
            }
        }

        [SingletonInstance]
        public class FakeAccountCreationDataAccess : IAccountCreationDataAccess
        {
            public uint Tier;
            public uint[] Privileges;
            public DateTime LastWebActivity;
            public byte ParentalControlGroup;
            public bool IsLightAccount;
            public bool IsProvisioned;
            public byte AccountType;

            public FakeAccountCreationDataAccess()
            {
                Random rand = new Random();
                this.Tier = (byte)((rand.Next(0, 2) == 0) ? 3 : 6); // 3 = Silver, 6 = Gold
                this.Privileges = new uint[16];
                for (int i = 0; i < this.Privileges.Length; i++)
                {
                    this.Privileges[i] = (uint)rand.Next();
                }
                this.LastWebActivity = DateTime.Now.Subtract(new TimeSpan(rand.Next(1,100), 0, 0));
                this.ParentalControlGroup = (byte)rand.Next(0, 16);
                this.IsLightAccount = (rand.Next(0, 2) == 0);
                this.IsProvisioned = (rand.Next(0, 2) == 0);
                this.AccountType = (byte)rand.Next(0, 4);
            }

            public void GetUserWebInfo(ulong livePuid, xonline.common.protocol.ServiceTypeEnum liveServiceType, out uint tier, out uint[] privileges, out DateTime lastWebActivity, out byte parentalControlGroup, out bool isLightAccount, out bool isProvisioned, out byte accountType)
            {
                tier = this.Tier;
                privileges = this.Privileges;
                lastWebActivity = this.LastWebActivity;
                parentalControlGroup = this.ParentalControlGroup;
                isLightAccount = this.IsLightAccount;
                isProvisioned = this.IsProvisioned;
                accountType = this.AccountType;
            }

            public void UpdateParentalControls(ulong livePuid, uint[] grantPrivileges, uint[] restrictPrivileges, string source)
            {
                throw new NotImplementedException();
            }

            public xonline.common.protocol.XePassportGetMemberNameResponse PassportGetMemberName(ulong livePuid)
            {
                throw new NotImplementedException();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DebugLivecacheLogger.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using System.Diagnostics;

namespace Leet.Live.Livecache
{
    /// <summary>
    /// Class to be used in development code.  Outputs log events to the debug window.
    /// </summary>
    public class DebugLivecacheLogger : ILivecacheLogger
    {
        public DebugLivecacheLogger(string area, string component)
        {

        }

        #region ILivecacheLogger Members

        public void LogError(Enum eventId, string format, params object[] args)
        {
            Debug.WriteLine("**Livecache Error**", "Livecache Error");
            Debug.WriteLine("Event Id: " + eventId.ToString(), "Livecache Error");
            Debug.WriteLine(String.Format(format, args), "Livecache Error");
        }

        public void LogError(Enum eventId, Exception ex, string format, params object[] args)
        {
            Debug.WriteLine("**Livecache Error**", "Livecache Error");
            Debug.WriteLine("Event Id: " + eventId.ToString(), "Livecache Error");
            Debug.WriteLine("Exception: " + ex.ToString(), "Livecache Error");
            Debug.WriteLine(String.Format(format, args), "Livecache Error");
        }

        public void LogInfo(Enum eventId, Exception ex, string format, params object[] args)
        {
            Debug.WriteLine("**Livecache Info**", "Livecache Info");
            Debug.WriteLine("Event Id: " + eventId.ToString(), "Livecache Info");
            Debug.WriteLine("Exception: " + ex.ToString(), "Livecache Info");
            Debug.WriteLine(String.Format(format, args), "Livecache Info");
        }

        public void LogInfo(string format, params object[] args)
        {
            Debug.WriteLine("**Livecache Info**", "Livecache Info");
            Debug.WriteLine(String.Format(format, args), "Livecache Info");
        }

        public void LogVerbose(string format, params object[] args)
        {
            Debug.WriteLine("**Livecache Event**", "Livecache Event");
            Debug.WriteLine(String.Format(format, args), "Livecache Event");
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity.Test\Leet.Identity.Test\IdentityManagerTests.cs ===
﻿namespace Leet.Identity.Test
{
    using Leet.TestUtilities;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Rhino.Mocks;
    
    [TestClass]
    public class IdentityManagerTests
    {
        /// <summary>
        /// Windows Live service that returns Puid for an email address
        /// </summary>
        private IPpsaCredentialProvider credentialProvider;
        
        /// <summary>
        /// Initialize for each test
        /// </summary>
        [TestInitialize]
        public void Initialize()
        {   
            // Register a stub for IPpsaCredentialProvider
            var stubber = new Stubber();
            this.credentialProvider =
                    stubber.RegisterWithContainer<IPpsaCredentialProvider>();
        }

        /// <summary>
        /// Call GetNetIDsForSigninNames and verify the correct ulong Puid is passed back.
        /// </summary>
        [TestMethod]
        public void GetNetIDsForSigninNames_Test()
        { 
            // Arrange
            long expectedPuid = 844427078212612; // equals 0x0003000080091C04
            string response = 
                "<Name2NETID><SigninName NetID=\"0003000080091C04\">user1@example.com</SigninName></Name2NETID>";
            
            this.credentialProvider.Stub(x => x.GetNetIDsForSigninNames(string.Empty))
                .IgnoreArguments()
                .Return(response);

            // Act
            var puid =
                IdentityManager.GetPuidFromEmailAddress("user1@example.com");

            // Assert
            Assert.AreEqual(expectedPuid, puid);
        }

        [TestMethod]
        public void GetNetIDsForSigninNames_WebExceptionTest()
        { 
            // Arrange
            long expected = 0;

            this.credentialProvider.Stub(x => x.GetNetIDsForSigninNames(string.Empty))
                .IgnoreArguments()
                .Throw(new System.Web.Services.Protocols.SoapException());

            // Act

            try
            {
                var puid = IdentityManager.GetPuidFromEmailAddress("user1@example.com");
                Assert.AreEqual(expected, puid);
            }
            // Assert
            catch (System.Web.Services.Protocols.SoapException) 
            {
                Assert.Fail("WebException unhandled");
            }
            catch (System.Exception e)
            {
                // A web exception could cause other exceptions if not handled correctly
                // verify that no unhandled exceptions.
                Assert.Fail("Exception unhandled" + e.Message);
            }

            
        }

        [TestMethod]
        public void GetNetIDsForSigninNames_EmailNotFound()
        {
            // Arrange
            long expected = 0;
            string response =
                "<Name2NETID></Name2NETID>";

            this.credentialProvider.Stub(x => x.GetNetIDsForSigninNames(string.Empty))
                .IgnoreArguments()
                .Return(response);

            // Act
            var actual =
                IdentityManager.GetPuidFromEmailAddress("user1@example.com");

            // Assert
            Assert.AreEqual(expected, actual);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Identity\Proxies\PPSACredentialProxy.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.3038.
// 
namespace Leet.Identity {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="CredentialServiceAPISoapServerSoap", Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public partial class CredentialServiceAPISoapServer : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private PPSoapHeader_wrapper pPSoapHeaderField;
        
        private tagWSSECURITYHEADER wSSecurityHeaderField;
        
        private System.Threading.SendOrPostCallback GetPassportIDOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCredentialInfoOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddCredentialOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateCredentialOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteCredentialOperationCompleted;
        
        private System.Threading.SendOrPostCallback RenameCredentialOperationCompleted;
        
        private System.Threading.SendOrPostCallback UnblockCredentialOperationCompleted;
        
        private System.Threading.SendOrPostCallback BlockCredentialOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumCredentialsByNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumCredentialsByNetIDOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumCredentialsByNamespaceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCertificateAssociationsOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteCertificateAssociationOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteAllCertificateAssociationsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSigninNamesForNetIDsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ForceCredentialRenameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNetIDsForSigninNamesOperationCompleted;
        
        private System.Threading.SendOrPostCallback QueryCredentialChangesOperationCompleted;
        
        private System.Threading.SendOrPostCallback QueryCredentialHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback QueryCredentialHistoryByNetIDOperationCompleted;
        
        private System.Threading.SendOrPostCallback QueryNetIDHistoryBySigninNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SuggestAlternateMemberNamesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSigninNamesAndCIDsForNetIDsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNetIDsAndCIDsForSigninNamesOperationCompleted;
        
        private System.Threading.SendOrPostCallback CheckAvailableSigninNamesOperationCompleted;
        
        private System.Threading.SendOrPostCallback CheckRenameRulesOperationCompleted;
        
        private System.Threading.SendOrPostCallback RenameCredentialExOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReserveNameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSLTOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddLinkAccountsOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeLinkAccountsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetLinkAccountMembersOperationCompleted;
        
        private System.Threading.SendOrPostCallback AssociateCertificateOperationCompleted;
        
        private System.Threading.SendOrPostCallback DisassociateCertificateOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteCredentialExOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateAliasOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateAliasOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteAliasOperationCompleted;
        
        private System.Threading.SendOrPostCallback RenameAliasOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAliasesForAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetAccountForAliasOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddToReputationScoreOperationCompleted;
        
        private System.Threading.SendOrPostCallback OverrideReputationScoreOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReputationScoreDetailsOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateDeviceOperationCompleted;
        
        private System.Threading.SendOrPostCallback AssociateDeviceOperationCompleted;
        
        private System.Threading.SendOrPostCallback DisassociateDeviceOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateDevicePropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback QueryDevicePropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback ConvertCredentialOperationCompleted;
        
        /// <remarks/>
        public CredentialServiceAPISoapServer() {
            this.Url = "https://ppsacredential.service.passport-int.net/PPSACredential.srf";
        }
        
        public PPSoapHeader_wrapper PPSoapHeader {
            get {
                return this.pPSoapHeaderField;
            }
            set {
                this.pPSoapHeaderField = value;
            }
        }
        
        public tagWSSECURITYHEADER WSSecurityHeader {
            get {
                return this.wSSecurityHeaderField;
            }
            set {
                this.wSSecurityHeaderField = value;
            }
        }
        
        /// <remarks/>
        public event GetPassportIDCompletedEventHandler GetPassportIDCompleted;
        
        /// <remarks/>
        public event GetCredentialInfoCompletedEventHandler GetCredentialInfoCompleted;
        
        /// <remarks/>
        public event AddCredentialCompletedEventHandler AddCredentialCompleted;
        
        /// <remarks/>
        public event UpdateCredentialCompletedEventHandler UpdateCredentialCompleted;
        
        /// <remarks/>
        public event DeleteCredentialCompletedEventHandler DeleteCredentialCompleted;
        
        /// <remarks/>
        public event RenameCredentialCompletedEventHandler RenameCredentialCompleted;
        
        /// <remarks/>
        public event UnblockCredentialCompletedEventHandler UnblockCredentialCompleted;
        
        /// <remarks/>
        public event BlockCredentialCompletedEventHandler BlockCredentialCompleted;
        
        /// <remarks/>
        public event EnumCredentialsByNameCompletedEventHandler EnumCredentialsByNameCompleted;
        
        /// <remarks/>
        public event EnumCredentialsByNetIDCompletedEventHandler EnumCredentialsByNetIDCompleted;
        
        /// <remarks/>
        public event EnumCredentialsByNamespaceCompletedEventHandler EnumCredentialsByNamespaceCompleted;
        
        /// <remarks/>
        public event GetCertificateAssociationsCompletedEventHandler GetCertificateAssociationsCompleted;
        
        /// <remarks/>
        public event DeleteCertificateAssociationCompletedEventHandler DeleteCertificateAssociationCompleted;
        
        /// <remarks/>
        public event DeleteAllCertificateAssociationsCompletedEventHandler DeleteAllCertificateAssociationsCompleted;
        
        /// <remarks/>
        public event GetSigninNamesForNetIDsCompletedEventHandler GetSigninNamesForNetIDsCompleted;
        
        /// <remarks/>
        public event ForceCredentialRenameCompletedEventHandler ForceCredentialRenameCompleted;
        
        /// <remarks/>
        public event GetNetIDsForSigninNamesCompletedEventHandler GetNetIDsForSigninNamesCompleted;
        
        /// <remarks/>
        public event QueryCredentialChangesCompletedEventHandler QueryCredentialChangesCompleted;
        
        /// <remarks/>
        public event QueryCredentialHistoryCompletedEventHandler QueryCredentialHistoryCompleted;
        
        /// <remarks/>
        public event QueryCredentialHistoryByNetIDCompletedEventHandler QueryCredentialHistoryByNetIDCompleted;
        
        /// <remarks/>
        public event QueryNetIDHistoryBySigninNameCompletedEventHandler QueryNetIDHistoryBySigninNameCompleted;
        
        /// <remarks/>
        public event SuggestAlternateMemberNamesCompletedEventHandler SuggestAlternateMemberNamesCompleted;
        
        /// <remarks/>
        public event GetSigninNamesAndCIDsForNetIDsCompletedEventHandler GetSigninNamesAndCIDsForNetIDsCompleted;
        
        /// <remarks/>
        public event GetNetIDsAndCIDsForSigninNamesCompletedEventHandler GetNetIDsAndCIDsForSigninNamesCompleted;
        
        /// <remarks/>
        public event CheckAvailableSigninNamesCompletedEventHandler CheckAvailableSigninNamesCompleted;
        
        /// <remarks/>
        public event CheckRenameRulesCompletedEventHandler CheckRenameRulesCompleted;
        
        /// <remarks/>
        public event RenameCredentialExCompletedEventHandler RenameCredentialExCompleted;
        
        /// <remarks/>
        public event ReserveNameCompletedEventHandler ReserveNameCompleted;
        
        /// <remarks/>
        public event GetSLTCompletedEventHandler GetSLTCompleted;
        
        /// <remarks/>
        public event AddLinkAccountsCompletedEventHandler AddLinkAccountsCompleted;
        
        /// <remarks/>
        public event DeLinkAccountsCompletedEventHandler DeLinkAccountsCompleted;
        
        /// <remarks/>
        public event GetLinkAccountMembersCompletedEventHandler GetLinkAccountMembersCompleted;
        
        /// <remarks/>
        public event AssociateCertificateCompletedEventHandler AssociateCertificateCompleted;
        
        /// <remarks/>
        public event DisassociateCertificateCompletedEventHandler DisassociateCertificateCompleted;
        
        /// <remarks/>
        public event DeleteCredentialExCompletedEventHandler DeleteCredentialExCompleted;
        
        /// <remarks/>
        public event CreateAliasCompletedEventHandler CreateAliasCompleted;
        
        /// <remarks/>
        public event UpdateAliasCompletedEventHandler UpdateAliasCompleted;
        
        /// <remarks/>
        public event DeleteAliasCompletedEventHandler DeleteAliasCompleted;
        
        /// <remarks/>
        public event RenameAliasCompletedEventHandler RenameAliasCompleted;
        
        /// <remarks/>
        public event GetAliasesForAccountCompletedEventHandler GetAliasesForAccountCompleted;
        
        /// <remarks/>
        public event GetAccountForAliasCompletedEventHandler GetAccountForAliasCompleted;
        
        /// <remarks/>
        public event AddToReputationScoreCompletedEventHandler AddToReputationScoreCompleted;
        
        /// <remarks/>
        public event OverrideReputationScoreCompletedEventHandler OverrideReputationScoreCompleted;
        
        /// <remarks/>
        public event GetReputationScoreDetailsCompletedEventHandler GetReputationScoreDetailsCompleted;
        
        /// <remarks/>
        public event EnumerateDeviceCompletedEventHandler EnumerateDeviceCompleted;
        
        /// <remarks/>
        public event AssociateDeviceCompletedEventHandler AssociateDeviceCompleted;
        
        /// <remarks/>
        public event DisassociateDeviceCompletedEventHandler DisassociateDeviceCompleted;
        
        /// <remarks/>
        public event UpdateDevicePropertiesCompletedEventHandler UpdateDevicePropertiesCompleted;
        
        /// <remarks/>
        public event QueryDevicePropertiesCompletedEventHandler QueryDevicePropertiesCompleted;
        
        /// <remarks/>
        public event ConvertCredentialCompletedEventHandler ConvertCredentialCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetPassportID", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pPassIDOut")]
        public tagPASSID GetPassportID(tagPASSID PassIDIn) {
            object[] results = this.Invoke("GetPassportID", new object[] {
                        PassIDIn});
            return ((tagPASSID)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPassportID(tagPASSID PassIDIn, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPassportID", new object[] {
                        PassIDIn}, callback, asyncState);
        }
        
        /// <remarks/>
        public tagPASSID EndGetPassportID(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((tagPASSID)(results[0]));
        }
        
        /// <remarks/>
        public void GetPassportIDAsync(tagPASSID PassIDIn) {
            this.GetPassportIDAsync(PassIDIn, null);
        }
        
        /// <remarks/>
        public void GetPassportIDAsync(tagPASSID PassIDIn, object userState) {
            if ((this.GetPassportIDOperationCompleted == null)) {
                this.GetPassportIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPassportIDOperationCompleted);
            }
            this.InvokeAsync("GetPassportID", new object[] {
                        PassIDIn}, this.GetPassportIDOperationCompleted, userState);
        }
        
        private void OnGetPassportIDOperationCompleted(object arg) {
            if ((this.GetPassportIDCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPassportIDCompleted(this, new GetPassportIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetCredentialInfo", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrcredXML")]
        public string GetCredentialInfo(tagPASSID PassIDIn, string bstrAttribList) {
            object[] results = this.Invoke("GetCredentialInfo", new object[] {
                        PassIDIn,
                        bstrAttribList});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCredentialInfo(tagPASSID PassIDIn, string bstrAttribList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCredentialInfo", new object[] {
                        PassIDIn,
                        bstrAttribList}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetCredentialInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetCredentialInfoAsync(tagPASSID PassIDIn, string bstrAttribList) {
            this.GetCredentialInfoAsync(PassIDIn, bstrAttribList, null);
        }
        
        /// <remarks/>
        public void GetCredentialInfoAsync(tagPASSID PassIDIn, string bstrAttribList, object userState) {
            if ((this.GetCredentialInfoOperationCompleted == null)) {
                this.GetCredentialInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCredentialInfoOperationCompleted);
            }
            this.InvokeAsync("GetCredentialInfo", new object[] {
                        PassIDIn,
                        bstrAttribList}, this.GetCredentialInfoOperationCompleted, userState);
        }
        
        private void OnGetCredentialInfoOperationCompleted(object arg) {
            if ((this.GetCredentialInfoCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCredentialInfoCompleted(this, new GetCredentialInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddCredential(string bstrNamespace, string bstrCredXML, ref string pbstrNetID) {
            object[] results = this.Invoke("AddCredential", new object[] {
                        bstrNamespace,
                        bstrCredXML,
                        pbstrNetID});
            pbstrNetID = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddCredential(string bstrNamespace, string bstrCredXML, string pbstrNetID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddCredential", new object[] {
                        bstrNamespace,
                        bstrCredXML,
                        pbstrNetID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddCredential(System.IAsyncResult asyncResult, out string pbstrNetID) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrNetID = ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddCredentialAsync(string bstrNamespace, string bstrCredXML, string pbstrNetID) {
            this.AddCredentialAsync(bstrNamespace, bstrCredXML, pbstrNetID, null);
        }
        
        /// <remarks/>
        public void AddCredentialAsync(string bstrNamespace, string bstrCredXML, string pbstrNetID, object userState) {
            if ((this.AddCredentialOperationCompleted == null)) {
                this.AddCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCredentialOperationCompleted);
            }
            this.InvokeAsync("AddCredential", new object[] {
                        bstrNamespace,
                        bstrCredXML,
                        pbstrNetID}, this.AddCredentialOperationCompleted, userState);
        }
        
        private void OnAddCredentialOperationCompleted(object arg) {
            if ((this.AddCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCredentialCompleted(this, new AddCredentialCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateCredential(string bstrCredXML) {
            this.Invoke("UpdateCredential", new object[] {
                        bstrCredXML});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateCredential(string bstrCredXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateCredential", new object[] {
                        bstrCredXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateCredential(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UpdateCredentialAsync(string bstrCredXML) {
            this.UpdateCredentialAsync(bstrCredXML, null);
        }
        
        /// <remarks/>
        public void UpdateCredentialAsync(string bstrCredXML, object userState) {
            if ((this.UpdateCredentialOperationCompleted == null)) {
                this.UpdateCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateCredentialOperationCompleted);
            }
            this.InvokeAsync("UpdateCredential", new object[] {
                        bstrCredXML}, this.UpdateCredentialOperationCompleted, userState);
        }
        
        private void OnUpdateCredentialOperationCompleted(object arg) {
            if ((this.UpdateCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateCredentialCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCredential(tagPASSID PassID) {
            this.Invoke("DeleteCredential", new object[] {
                        PassID});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteCredential(tagPASSID PassID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteCredential", new object[] {
                        PassID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteCredential(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteCredentialAsync(tagPASSID PassID) {
            this.DeleteCredentialAsync(PassID, null);
        }
        
        /// <remarks/>
        public void DeleteCredentialAsync(tagPASSID PassID, object userState) {
            if ((this.DeleteCredentialOperationCompleted == null)) {
                this.DeleteCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteCredentialOperationCompleted);
            }
            this.InvokeAsync("DeleteCredential", new object[] {
                        PassID}, this.DeleteCredentialOperationCompleted, userState);
        }
        
        private void OnDeleteCredentialOperationCompleted(object arg) {
            if ((this.DeleteCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteCredentialCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RenameCredential(tagPASSID PassIDIn, string bstrnewCredName) {
            this.Invoke("RenameCredential", new object[] {
                        PassIDIn,
                        bstrnewCredName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRenameCredential(tagPASSID PassIDIn, string bstrnewCredName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RenameCredential", new object[] {
                        PassIDIn,
                        bstrnewCredName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRenameCredential(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RenameCredentialAsync(tagPASSID PassIDIn, string bstrnewCredName) {
            this.RenameCredentialAsync(PassIDIn, bstrnewCredName, null);
        }
        
        /// <remarks/>
        public void RenameCredentialAsync(tagPASSID PassIDIn, string bstrnewCredName, object userState) {
            if ((this.RenameCredentialOperationCompleted == null)) {
                this.RenameCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRenameCredentialOperationCompleted);
            }
            this.InvokeAsync("RenameCredential", new object[] {
                        PassIDIn,
                        bstrnewCredName}, this.RenameCredentialOperationCompleted, userState);
        }
        
        private void OnRenameCredentialOperationCompleted(object arg) {
            if ((this.RenameCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RenameCredentialCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UnblockCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UnblockCredential(tagPASSID PassID) {
            this.Invoke("UnblockCredential", new object[] {
                        PassID});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnblockCredential(tagPASSID PassID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnblockCredential", new object[] {
                        PassID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnblockCredential(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UnblockCredentialAsync(tagPASSID PassID) {
            this.UnblockCredentialAsync(PassID, null);
        }
        
        /// <remarks/>
        public void UnblockCredentialAsync(tagPASSID PassID, object userState) {
            if ((this.UnblockCredentialOperationCompleted == null)) {
                this.UnblockCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnblockCredentialOperationCompleted);
            }
            this.InvokeAsync("UnblockCredential", new object[] {
                        PassID}, this.UnblockCredentialOperationCompleted, userState);
        }
        
        private void OnUnblockCredentialOperationCompleted(object arg) {
            if ((this.UnblockCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnblockCredentialCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#BlockCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void BlockCredential(tagPASSID PassID) {
            this.Invoke("BlockCredential", new object[] {
                        PassID});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBlockCredential(tagPASSID PassID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BlockCredential", new object[] {
                        PassID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBlockCredential(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void BlockCredentialAsync(tagPASSID PassID) {
            this.BlockCredentialAsync(PassID, null);
        }
        
        /// <remarks/>
        public void BlockCredentialAsync(tagPASSID PassID, object userState) {
            if ((this.BlockCredentialOperationCompleted == null)) {
                this.BlockCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBlockCredentialOperationCompleted);
            }
            this.InvokeAsync("BlockCredential", new object[] {
                        PassID}, this.BlockCredentialOperationCompleted, userState);
        }
        
        private void OnBlockCredentialOperationCompleted(object arg) {
            if ((this.BlockCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BlockCredentialCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByName", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string EnumCredentialsByName(string bstrCredName, string bstrAttribList) {
            object[] results = this.Invoke("EnumCredentialsByName", new object[] {
                        bstrCredName,
                        bstrAttribList});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumCredentialsByName(string bstrCredName, string bstrAttribList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumCredentialsByName", new object[] {
                        bstrCredName,
                        bstrAttribList}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndEnumCredentialsByName(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void EnumCredentialsByNameAsync(string bstrCredName, string bstrAttribList) {
            this.EnumCredentialsByNameAsync(bstrCredName, bstrAttribList, null);
        }
        
        /// <remarks/>
        public void EnumCredentialsByNameAsync(string bstrCredName, string bstrAttribList, object userState) {
            if ((this.EnumCredentialsByNameOperationCompleted == null)) {
                this.EnumCredentialsByNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumCredentialsByNameOperationCompleted);
            }
            this.InvokeAsync("EnumCredentialsByName", new object[] {
                        bstrCredName,
                        bstrAttribList}, this.EnumCredentialsByNameOperationCompleted, userState);
        }
        
        private void OnEnumCredentialsByNameOperationCompleted(object arg) {
            if ((this.EnumCredentialsByNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumCredentialsByNameCompleted(this, new EnumCredentialsByNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByNetID", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredentialXML")]
        public string EnumCredentialsByNetID(string bstrNetID, string bstrAttribList) {
            object[] results = this.Invoke("EnumCredentialsByNetID", new object[] {
                        bstrNetID,
                        bstrAttribList});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumCredentialsByNetID(string bstrNetID, string bstrAttribList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumCredentialsByNetID", new object[] {
                        bstrNetID,
                        bstrAttribList}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndEnumCredentialsByNetID(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void EnumCredentialsByNetIDAsync(string bstrNetID, string bstrAttribList) {
            this.EnumCredentialsByNetIDAsync(bstrNetID, bstrAttribList, null);
        }
        
        /// <remarks/>
        public void EnumCredentialsByNetIDAsync(string bstrNetID, string bstrAttribList, object userState) {
            if ((this.EnumCredentialsByNetIDOperationCompleted == null)) {
                this.EnumCredentialsByNetIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumCredentialsByNetIDOperationCompleted);
            }
            this.InvokeAsync("EnumCredentialsByNetID", new object[] {
                        bstrNetID,
                        bstrAttribList}, this.EnumCredentialsByNetIDOperationCompleted, userState);
        }
        
        private void OnEnumCredentialsByNetIDOperationCompleted(object arg) {
            if ((this.EnumCredentialsByNetIDCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumCredentialsByNetIDCompleted(this, new EnumCredentialsByNetIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByNamespace", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredListXML")]
        public string EnumCredentialsByNamespace(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn) {
            object[] results = this.Invoke("EnumCredentialsByNamespace", new object[] {
                        bstrNamespace,
                        bstrStartingCredName,
                        NumCredsToReturn});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumCredentialsByNamespace(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumCredentialsByNamespace", new object[] {
                        bstrNamespace,
                        bstrStartingCredName,
                        NumCredsToReturn}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndEnumCredentialsByNamespace(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void EnumCredentialsByNamespaceAsync(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn) {
            this.EnumCredentialsByNamespaceAsync(bstrNamespace, bstrStartingCredName, NumCredsToReturn, null);
        }
        
        /// <remarks/>
        public void EnumCredentialsByNamespaceAsync(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn, object userState) {
            if ((this.EnumCredentialsByNamespaceOperationCompleted == null)) {
                this.EnumCredentialsByNamespaceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumCredentialsByNamespaceOperationCompleted);
            }
            this.InvokeAsync("EnumCredentialsByNamespace", new object[] {
                        bstrNamespace,
                        bstrStartingCredName,
                        NumCredsToReturn}, this.EnumCredentialsByNamespaceOperationCompleted, userState);
        }
        
        private void OnEnumCredentialsByNamespaceOperationCompleted(object arg) {
            if ((this.EnumCredentialsByNamespaceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumCredentialsByNamespaceCompleted(this, new EnumCredentialsByNamespaceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetCertificateAssociations", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCertXML")]
        public string GetCertificateAssociations(string bstrNetID, string bstrSigninName) {
            object[] results = this.Invoke("GetCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCertificateAssociations(string bstrNetID, string bstrSigninName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetCertificateAssociations(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetCertificateAssociationsAsync(string bstrNetID, string bstrSigninName) {
            this.GetCertificateAssociationsAsync(bstrNetID, bstrSigninName, null);
        }
        
        /// <remarks/>
        public void GetCertificateAssociationsAsync(string bstrNetID, string bstrSigninName, object userState) {
            if ((this.GetCertificateAssociationsOperationCompleted == null)) {
                this.GetCertificateAssociationsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCertificateAssociationsOperationCompleted);
            }
            this.InvokeAsync("GetCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName}, this.GetCertificateAssociationsOperationCompleted, userState);
        }
        
        private void OnGetCertificateAssociationsOperationCompleted(object arg) {
            if ((this.GetCertificateAssociationsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCertificateAssociationsCompleted(this, new GetCertificateAssociationsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCertificateAssociation", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCertificateAssociation(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose) {
            this.Invoke("DeleteCertificateAssociation", new object[] {
                        bstrNetID,
                        bstrSigninName,
                        bstrIssuer,
                        bstrSerialNumber,
                        sPurpose});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteCertificateAssociation(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteCertificateAssociation", new object[] {
                        bstrNetID,
                        bstrSigninName,
                        bstrIssuer,
                        bstrSerialNumber,
                        sPurpose}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteCertificateAssociation(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteCertificateAssociationAsync(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose) {
            this.DeleteCertificateAssociationAsync(bstrNetID, bstrSigninName, bstrIssuer, bstrSerialNumber, sPurpose, null);
        }
        
        /// <remarks/>
        public void DeleteCertificateAssociationAsync(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose, object userState) {
            if ((this.DeleteCertificateAssociationOperationCompleted == null)) {
                this.DeleteCertificateAssociationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteCertificateAssociationOperationCompleted);
            }
            this.InvokeAsync("DeleteCertificateAssociation", new object[] {
                        bstrNetID,
                        bstrSigninName,
                        bstrIssuer,
                        bstrSerialNumber,
                        sPurpose}, this.DeleteCertificateAssociationOperationCompleted, userState);
        }
        
        private void OnDeleteCertificateAssociationOperationCompleted(object arg) {
            if ((this.DeleteCertificateAssociationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteCertificateAssociationCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteAllCertificateAssociations", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteAllCertificateAssociations(string bstrNetID, string bstrSigninName) {
            this.Invoke("DeleteAllCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteAllCertificateAssociations(string bstrNetID, string bstrSigninName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteAllCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteAllCertificateAssociations(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteAllCertificateAssociationsAsync(string bstrNetID, string bstrSigninName) {
            this.DeleteAllCertificateAssociationsAsync(bstrNetID, bstrSigninName, null);
        }
        
        /// <remarks/>
        public void DeleteAllCertificateAssociationsAsync(string bstrNetID, string bstrSigninName, object userState) {
            if ((this.DeleteAllCertificateAssociationsOperationCompleted == null)) {
                this.DeleteAllCertificateAssociationsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteAllCertificateAssociationsOperationCompleted);
            }
            this.InvokeAsync("DeleteAllCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName}, this.DeleteAllCertificateAssociationsOperationCompleted, userState);
        }
        
        private void OnDeleteAllCertificateAssociationsOperationCompleted(object arg) {
            if ((this.DeleteAllCertificateAssociationsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteAllCertificateAssociationsCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSigninNamesForNetIDs", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetSigninNamesForNetIDs(string bstrNetIDs) {
            object[] results = this.Invoke("GetSigninNamesForNetIDs", new object[] {
                        bstrNetIDs});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSigninNamesForNetIDs(string bstrNetIDs, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSigninNamesForNetIDs", new object[] {
                        bstrNetIDs}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetSigninNamesForNetIDs(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetSigninNamesForNetIDsAsync(string bstrNetIDs) {
            this.GetSigninNamesForNetIDsAsync(bstrNetIDs, null);
        }
        
        /// <remarks/>
        public void GetSigninNamesForNetIDsAsync(string bstrNetIDs, object userState) {
            if ((this.GetSigninNamesForNetIDsOperationCompleted == null)) {
                this.GetSigninNamesForNetIDsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSigninNamesForNetIDsOperationCompleted);
            }
            this.InvokeAsync("GetSigninNamesForNetIDs", new object[] {
                        bstrNetIDs}, this.GetSigninNamesForNetIDsOperationCompleted, userState);
        }
        
        private void OnGetSigninNamesForNetIDsOperationCompleted(object arg) {
            if ((this.GetSigninNamesForNetIDsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSigninNamesForNetIDsCompleted(this, new GetSigninNamesForNetIDsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ForceCredentialRename", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ForceCredentialRename(tagPASSID PassID) {
            this.Invoke("ForceCredentialRename", new object[] {
                        PassID});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginForceCredentialRename(tagPASSID PassID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ForceCredentialRename", new object[] {
                        PassID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndForceCredentialRename(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ForceCredentialRenameAsync(tagPASSID PassID) {
            this.ForceCredentialRenameAsync(PassID, null);
        }
        
        /// <remarks/>
        public void ForceCredentialRenameAsync(tagPASSID PassID, object userState) {
            if ((this.ForceCredentialRenameOperationCompleted == null)) {
                this.ForceCredentialRenameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnForceCredentialRenameOperationCompleted);
            }
            this.InvokeAsync("ForceCredentialRename", new object[] {
                        PassID}, this.ForceCredentialRenameOperationCompleted, userState);
        }
        
        private void OnForceCredentialRenameOperationCompleted(object arg) {
            if ((this.ForceCredentialRenameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ForceCredentialRenameCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetNetIDsForSigninNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetNetIDsForSigninNames(string bstrSigninNames) {
            object[] results = this.Invoke("GetNetIDsForSigninNames", new object[] {
                        bstrSigninNames});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNetIDsForSigninNames(string bstrSigninNames, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNetIDsForSigninNames", new object[] {
                        bstrSigninNames}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetNetIDsForSigninNames(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetNetIDsForSigninNamesAsync(string bstrSigninNames) {
            this.GetNetIDsForSigninNamesAsync(bstrSigninNames, null);
        }
        
        /// <remarks/>
        public void GetNetIDsForSigninNamesAsync(string bstrSigninNames, object userState) {
            if ((this.GetNetIDsForSigninNamesOperationCompleted == null)) {
                this.GetNetIDsForSigninNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNetIDsForSigninNamesOperationCompleted);
            }
            this.InvokeAsync("GetNetIDsForSigninNames", new object[] {
                        bstrSigninNames}, this.GetNetIDsForSigninNamesOperationCompleted, userState);
        }
        
        private void OnGetNetIDsForSigninNamesOperationCompleted(object arg) {
            if ((this.GetNetIDsForSigninNamesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNetIDsForSigninNamesCompleted(this, new GetNetIDsForSigninNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialChanges", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangesXml")]
        public string QueryCredentialChanges(string OptionsXml) {
            object[] results = this.Invoke("QueryCredentialChanges", new object[] {
                        OptionsXml});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQueryCredentialChanges(string OptionsXml, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QueryCredentialChanges", new object[] {
                        OptionsXml}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndQueryCredentialChanges(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void QueryCredentialChangesAsync(string OptionsXml) {
            this.QueryCredentialChangesAsync(OptionsXml, null);
        }
        
        /// <remarks/>
        public void QueryCredentialChangesAsync(string OptionsXml, object userState) {
            if ((this.QueryCredentialChangesOperationCompleted == null)) {
                this.QueryCredentialChangesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQueryCredentialChangesOperationCompleted);
            }
            this.InvokeAsync("QueryCredentialChanges", new object[] {
                        OptionsXml}, this.QueryCredentialChangesOperationCompleted, userState);
        }
        
        private void OnQueryCredentialChangesOperationCompleted(object arg) {
            if ((this.QueryCredentialChangesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QueryCredentialChangesCompleted(this, new QueryCredentialChangesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialHistory", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangeHistory")]
        public string QueryCredentialHistory(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID) {
            object[] results = this.Invoke("QueryCredentialHistory", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        CredType,
                        ChangeType,
                        OptionalDomainAuthority,
                        NumRecordsMax,
                        StartAfterChangeID});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQueryCredentialHistory(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QueryCredentialHistory", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        CredType,
                        ChangeType,
                        OptionalDomainAuthority,
                        NumRecordsMax,
                        StartAfterChangeID}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndQueryCredentialHistory(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void QueryCredentialHistoryAsync(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID) {
            this.QueryCredentialHistoryAsync(StartAfterDateTime, EndAtDateTime, CredType, ChangeType, OptionalDomainAuthority, NumRecordsMax, StartAfterChangeID, null);
        }
        
        /// <remarks/>
        public void QueryCredentialHistoryAsync(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID, object userState) {
            if ((this.QueryCredentialHistoryOperationCompleted == null)) {
                this.QueryCredentialHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQueryCredentialHistoryOperationCompleted);
            }
            this.InvokeAsync("QueryCredentialHistory", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        CredType,
                        ChangeType,
                        OptionalDomainAuthority,
                        NumRecordsMax,
                        StartAfterChangeID}, this.QueryCredentialHistoryOperationCompleted, userState);
        }
        
        private void OnQueryCredentialHistoryOperationCompleted(object arg) {
            if ((this.QueryCredentialHistoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QueryCredentialHistoryCompleted(this, new QueryCredentialHistoryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialHistoryByNetID", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangeHistory")]
        public string QueryCredentialHistoryByNetID(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID) {
            object[] results = this.Invoke("QueryCredentialHistoryByNetID", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        NetID,
                        CredType,
                        ChangeType,
                        NumRecordsMax,
                        StartAfterChangeID});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQueryCredentialHistoryByNetID(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QueryCredentialHistoryByNetID", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        NetID,
                        CredType,
                        ChangeType,
                        NumRecordsMax,
                        StartAfterChangeID}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndQueryCredentialHistoryByNetID(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void QueryCredentialHistoryByNetIDAsync(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID) {
            this.QueryCredentialHistoryByNetIDAsync(StartAfterDateTime, EndAtDateTime, NetID, CredType, ChangeType, NumRecordsMax, StartAfterChangeID, null);
        }
        
        /// <remarks/>
        public void QueryCredentialHistoryByNetIDAsync(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID, object userState) {
            if ((this.QueryCredentialHistoryByNetIDOperationCompleted == null)) {
                this.QueryCredentialHistoryByNetIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQueryCredentialHistoryByNetIDOperationCompleted);
            }
            this.InvokeAsync("QueryCredentialHistoryByNetID", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        NetID,
                        CredType,
                        ChangeType,
                        NumRecordsMax,
                        StartAfterChangeID}, this.QueryCredentialHistoryByNetIDOperationCompleted, userState);
        }
        
        private void OnQueryCredentialHistoryByNetIDOperationCompleted(object arg) {
            if ((this.QueryCredentialHistoryByNetIDCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QueryCredentialHistoryByNetIDCompleted(this, new QueryCredentialHistoryByNetIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryNetIDHistoryBySigninName", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("NetIDHistory")]
        public string QueryNetIDHistoryBySigninName(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax) {
            object[] results = this.Invoke("QueryNetIDHistoryBySigninName", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        SigninName,
                        NumRecordsMax});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQueryNetIDHistoryBySigninName(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QueryNetIDHistoryBySigninName", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        SigninName,
                        NumRecordsMax}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndQueryNetIDHistoryBySigninName(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void QueryNetIDHistoryBySigninNameAsync(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax) {
            this.QueryNetIDHistoryBySigninNameAsync(StartAfterDateTime, EndAtDateTime, SigninName, NumRecordsMax, null);
        }
        
        /// <remarks/>
        public void QueryNetIDHistoryBySigninNameAsync(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax, object userState) {
            if ((this.QueryNetIDHistoryBySigninNameOperationCompleted == null)) {
                this.QueryNetIDHistoryBySigninNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQueryNetIDHistoryBySigninNameOperationCompleted);
            }
            this.InvokeAsync("QueryNetIDHistoryBySigninName", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        SigninName,
                        NumRecordsMax}, this.QueryNetIDHistoryBySigninNameOperationCompleted, userState);
        }
        
        private void OnQueryNetIDHistoryBySigninNameOperationCompleted(object arg) {
            if ((this.QueryNetIDHistoryBySigninNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QueryNetIDHistoryBySigninNameCompleted(this, new QueryNetIDHistoryBySigninNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SuggestAlternateMemberNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Names")]
        public string SuggestAlternateMemberNames(string Namespace, string FirstName, string LastName, string RequestedName) {
            object[] results = this.Invoke("SuggestAlternateMemberNames", new object[] {
                        Namespace,
                        FirstName,
                        LastName,
                        RequestedName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSuggestAlternateMemberNames(string Namespace, string FirstName, string LastName, string RequestedName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SuggestAlternateMemberNames", new object[] {
                        Namespace,
                        FirstName,
                        LastName,
                        RequestedName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndSuggestAlternateMemberNames(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void SuggestAlternateMemberNamesAsync(string Namespace, string FirstName, string LastName, string RequestedName) {
            this.SuggestAlternateMemberNamesAsync(Namespace, FirstName, LastName, RequestedName, null);
        }
        
        /// <remarks/>
        public void SuggestAlternateMemberNamesAsync(string Namespace, string FirstName, string LastName, string RequestedName, object userState) {
            if ((this.SuggestAlternateMemberNamesOperationCompleted == null)) {
                this.SuggestAlternateMemberNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSuggestAlternateMemberNamesOperationCompleted);
            }
            this.InvokeAsync("SuggestAlternateMemberNames", new object[] {
                        Namespace,
                        FirstName,
                        LastName,
                        RequestedName}, this.SuggestAlternateMemberNamesOperationCompleted, userState);
        }
        
        private void OnSuggestAlternateMemberNamesOperationCompleted(object arg) {
            if ((this.SuggestAlternateMemberNamesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SuggestAlternateMemberNamesCompleted(this, new SuggestAlternateMemberNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSigninNamesAndCIDsForNetIDs", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetSigninNamesAndCIDsForNetIDs(string bstrNetIDs) {
            object[] results = this.Invoke("GetSigninNamesAndCIDsForNetIDs", new object[] {
                        bstrNetIDs});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSigninNamesAndCIDsForNetIDs(string bstrNetIDs, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSigninNamesAndCIDsForNetIDs", new object[] {
                        bstrNetIDs}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetSigninNamesAndCIDsForNetIDs(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetSigninNamesAndCIDsForNetIDsAsync(string bstrNetIDs) {
            this.GetSigninNamesAndCIDsForNetIDsAsync(bstrNetIDs, null);
        }
        
        /// <remarks/>
        public void GetSigninNamesAndCIDsForNetIDsAsync(string bstrNetIDs, object userState) {
            if ((this.GetSigninNamesAndCIDsForNetIDsOperationCompleted == null)) {
                this.GetSigninNamesAndCIDsForNetIDsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSigninNamesAndCIDsForNetIDsOperationCompleted);
            }
            this.InvokeAsync("GetSigninNamesAndCIDsForNetIDs", new object[] {
                        bstrNetIDs}, this.GetSigninNamesAndCIDsForNetIDsOperationCompleted, userState);
        }
        
        private void OnGetSigninNamesAndCIDsForNetIDsOperationCompleted(object arg) {
            if ((this.GetSigninNamesAndCIDsForNetIDsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSigninNamesAndCIDsForNetIDsCompleted(this, new GetSigninNamesAndCIDsForNetIDsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetNetIDsAndCIDsForSigninNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetNetIDsAndCIDsForSigninNames(string bstrSigninNames) {
            object[] results = this.Invoke("GetNetIDsAndCIDsForSigninNames", new object[] {
                        bstrSigninNames});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNetIDsAndCIDsForSigninNames(string bstrSigninNames, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNetIDsAndCIDsForSigninNames", new object[] {
                        bstrSigninNames}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetNetIDsAndCIDsForSigninNames(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetNetIDsAndCIDsForSigninNamesAsync(string bstrSigninNames) {
            this.GetNetIDsAndCIDsForSigninNamesAsync(bstrSigninNames, null);
        }
        
        /// <remarks/>
        public void GetNetIDsAndCIDsForSigninNamesAsync(string bstrSigninNames, object userState) {
            if ((this.GetNetIDsAndCIDsForSigninNamesOperationCompleted == null)) {
                this.GetNetIDsAndCIDsForSigninNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNetIDsAndCIDsForSigninNamesOperationCompleted);
            }
            this.InvokeAsync("GetNetIDsAndCIDsForSigninNames", new object[] {
                        bstrSigninNames}, this.GetNetIDsAndCIDsForSigninNamesOperationCompleted, userState);
        }
        
        private void OnGetNetIDsAndCIDsForSigninNamesOperationCompleted(object arg) {
            if ((this.GetNetIDsAndCIDsForSigninNamesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNetIDsAndCIDsForSigninNamesCompleted(this, new GetNetIDsAndCIDsForSigninNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CheckAvailableSigninNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string CheckAvailableSigninNames(string bstrSigninNames) {
            object[] results = this.Invoke("CheckAvailableSigninNames", new object[] {
                        bstrSigninNames});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckAvailableSigninNames(string bstrSigninNames, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckAvailableSigninNames", new object[] {
                        bstrSigninNames}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCheckAvailableSigninNames(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CheckAvailableSigninNamesAsync(string bstrSigninNames) {
            this.CheckAvailableSigninNamesAsync(bstrSigninNames, null);
        }
        
        /// <remarks/>
        public void CheckAvailableSigninNamesAsync(string bstrSigninNames, object userState) {
            if ((this.CheckAvailableSigninNamesOperationCompleted == null)) {
                this.CheckAvailableSigninNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCheckAvailableSigninNamesOperationCompleted);
            }
            this.InvokeAsync("CheckAvailableSigninNames", new object[] {
                        bstrSigninNames}, this.CheckAvailableSigninNamesOperationCompleted, userState);
        }
        
        private void OnCheckAvailableSigninNamesOperationCompleted(object arg) {
            if ((this.CheckAvailableSigninNamesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CheckAvailableSigninNamesCompleted(this, new CheckAvailableSigninNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CheckRenameRules", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAvailableAttributes")]
        public string CheckRenameRules(tagPASSID PassIDIn) {
            object[] results = this.Invoke("CheckRenameRules", new object[] {
                        PassIDIn});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckRenameRules(tagPASSID PassIDIn, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckRenameRules", new object[] {
                        PassIDIn}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCheckRenameRules(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CheckRenameRulesAsync(tagPASSID PassIDIn) {
            this.CheckRenameRulesAsync(PassIDIn, null);
        }
        
        /// <remarks/>
        public void CheckRenameRulesAsync(tagPASSID PassIDIn, object userState) {
            if ((this.CheckRenameRulesOperationCompleted == null)) {
                this.CheckRenameRulesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCheckRenameRulesOperationCompleted);
            }
            this.InvokeAsync("CheckRenameRules", new object[] {
                        PassIDIn}, this.CheckRenameRulesOperationCompleted, userState);
        }
        
        private void OnCheckRenameRulesOperationCompleted(object arg) {
            if ((this.CheckRenameRulesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CheckRenameRulesCompleted(this, new CheckRenameRulesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameCredentialEx", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RenameCredentialEx(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams) {
            this.Invoke("RenameCredentialEx", new object[] {
                        PassIDIn,
                        bstrNewSigninName,
                        bstrOptionalParams});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRenameCredentialEx(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RenameCredentialEx", new object[] {
                        PassIDIn,
                        bstrNewSigninName,
                        bstrOptionalParams}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRenameCredentialEx(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RenameCredentialExAsync(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams) {
            this.RenameCredentialExAsync(PassIDIn, bstrNewSigninName, bstrOptionalParams, null);
        }
        
        /// <remarks/>
        public void RenameCredentialExAsync(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams, object userState) {
            if ((this.RenameCredentialExOperationCompleted == null)) {
                this.RenameCredentialExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRenameCredentialExOperationCompleted);
            }
            this.InvokeAsync("RenameCredentialEx", new object[] {
                        PassIDIn,
                        bstrNewSigninName,
                        bstrOptionalParams}, this.RenameCredentialExOperationCompleted, userState);
        }
        
        private void OnRenameCredentialExOperationCompleted(object arg) {
            if ((this.RenameCredentialExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RenameCredentialExCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ReserveName", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ReserveName(tagPASSID PassIDIn, string bstrNewSigninName) {
            this.Invoke("ReserveName", new object[] {
                        PassIDIn,
                        bstrNewSigninName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReserveName(tagPASSID PassIDIn, string bstrNewSigninName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReserveName", new object[] {
                        PassIDIn,
                        bstrNewSigninName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReserveName(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ReserveNameAsync(tagPASSID PassIDIn, string bstrNewSigninName) {
            this.ReserveNameAsync(PassIDIn, bstrNewSigninName, null);
        }
        
        /// <remarks/>
        public void ReserveNameAsync(tagPASSID PassIDIn, string bstrNewSigninName, object userState) {
            if ((this.ReserveNameOperationCompleted == null)) {
                this.ReserveNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReserveNameOperationCompleted);
            }
            this.InvokeAsync("ReserveName", new object[] {
                        PassIDIn,
                        bstrNewSigninName}, this.ReserveNameOperationCompleted, userState);
        }
        
        private void OnReserveNameOperationCompleted(object arg) {
            if ((this.ReserveNameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReserveNameCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSLT", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("SLT")]
        public string GetSLT(tagPASSID PassIDIn, int LoginSeconds) {
            object[] results = this.Invoke("GetSLT", new object[] {
                        PassIDIn,
                        LoginSeconds});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSLT(tagPASSID PassIDIn, int LoginSeconds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSLT", new object[] {
                        PassIDIn,
                        LoginSeconds}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetSLT(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetSLTAsync(tagPASSID PassIDIn, int LoginSeconds) {
            this.GetSLTAsync(PassIDIn, LoginSeconds, null);
        }
        
        /// <remarks/>
        public void GetSLTAsync(tagPASSID PassIDIn, int LoginSeconds, object userState) {
            if ((this.GetSLTOperationCompleted == null)) {
                this.GetSLTOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSLTOperationCompleted);
            }
            this.InvokeAsync("GetSLT", new object[] {
                        PassIDIn,
                        LoginSeconds}, this.GetSLTOperationCompleted, userState);
        }
        
        private void OnGetSLTOperationCompleted(object arg) {
            if ((this.GetSLTCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSLTCompleted(this, new GetSLTCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddLinkAccounts", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddLinkAccounts(string bstrLinkProofData, ref string pbstrLinkID) {
            object[] results = this.Invoke("AddLinkAccounts", new object[] {
                        bstrLinkProofData,
                        pbstrLinkID});
            pbstrLinkID = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddLinkAccounts(string bstrLinkProofData, string pbstrLinkID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddLinkAccounts", new object[] {
                        bstrLinkProofData,
                        pbstrLinkID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddLinkAccounts(System.IAsyncResult asyncResult, out string pbstrLinkID) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrLinkID = ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddLinkAccountsAsync(string bstrLinkProofData, string pbstrLinkID) {
            this.AddLinkAccountsAsync(bstrLinkProofData, pbstrLinkID, null);
        }
        
        /// <remarks/>
        public void AddLinkAccountsAsync(string bstrLinkProofData, string pbstrLinkID, object userState) {
            if ((this.AddLinkAccountsOperationCompleted == null)) {
                this.AddLinkAccountsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddLinkAccountsOperationCompleted);
            }
            this.InvokeAsync("AddLinkAccounts", new object[] {
                        bstrLinkProofData,
                        pbstrLinkID}, this.AddLinkAccountsOperationCompleted, userState);
        }
        
        private void OnAddLinkAccountsOperationCompleted(object arg) {
            if ((this.AddLinkAccountsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddLinkAccountsCompleted(this, new AddLinkAccountsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeLinkAccounts", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeLinkAccounts(string bstrSigninNames, string SLT) {
            this.Invoke("DeLinkAccounts", new object[] {
                        bstrSigninNames,
                        SLT});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeLinkAccounts(string bstrSigninNames, string SLT, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeLinkAccounts", new object[] {
                        bstrSigninNames,
                        SLT}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeLinkAccounts(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeLinkAccountsAsync(string bstrSigninNames, string SLT) {
            this.DeLinkAccountsAsync(bstrSigninNames, SLT, null);
        }
        
        /// <remarks/>
        public void DeLinkAccountsAsync(string bstrSigninNames, string SLT, object userState) {
            if ((this.DeLinkAccountsOperationCompleted == null)) {
                this.DeLinkAccountsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeLinkAccountsOperationCompleted);
            }
            this.InvokeAsync("DeLinkAccounts", new object[] {
                        bstrSigninNames,
                        SLT}, this.DeLinkAccountsOperationCompleted, userState);
        }
        
        private void OnDeLinkAccountsOperationCompleted(object arg) {
            if ((this.DeLinkAccountsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeLinkAccountsCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetLinkAccountMembers", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrLinkCredXML")]
        public string GetLinkAccountMembers(string bstrLinkID) {
            object[] results = this.Invoke("GetLinkAccountMembers", new object[] {
                        bstrLinkID});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLinkAccountMembers(string bstrLinkID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLinkAccountMembers", new object[] {
                        bstrLinkID}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetLinkAccountMembers(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetLinkAccountMembersAsync(string bstrLinkID) {
            this.GetLinkAccountMembersAsync(bstrLinkID, null);
        }
        
        /// <remarks/>
        public void GetLinkAccountMembersAsync(string bstrLinkID, object userState) {
            if ((this.GetLinkAccountMembersOperationCompleted == null)) {
                this.GetLinkAccountMembersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLinkAccountMembersOperationCompleted);
            }
            this.InvokeAsync("GetLinkAccountMembers", new object[] {
                        bstrLinkID}, this.GetLinkAccountMembersOperationCompleted, userState);
        }
        
        private void OnGetLinkAccountMembersOperationCompleted(object arg) {
            if ((this.GetLinkAccountMembersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLinkAccountMembersCompleted(this, new GetLinkAccountMembersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AssociateCertificate", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AssociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateToken) {
            this.Invoke("AssociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateToken});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAssociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AssociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAssociateCertificate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void AssociateCertificateAsync(string bstrCertType, string bstrNetID, string bstrCertificateToken) {
            this.AssociateCertificateAsync(bstrCertType, bstrNetID, bstrCertificateToken, null);
        }
        
        /// <remarks/>
        public void AssociateCertificateAsync(string bstrCertType, string bstrNetID, string bstrCertificateToken, object userState) {
            if ((this.AssociateCertificateOperationCompleted == null)) {
                this.AssociateCertificateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAssociateCertificateOperationCompleted);
            }
            this.InvokeAsync("AssociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateToken}, this.AssociateCertificateOperationCompleted, userState);
        }
        
        private void OnAssociateCertificateOperationCompleted(object arg) {
            if ((this.AssociateCertificateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AssociateCertificateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DisassociateCertificate", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DisassociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateList) {
            this.Invoke("DisassociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateList});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDisassociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateList, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DisassociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateList}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDisassociateCertificate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DisassociateCertificateAsync(string bstrCertType, string bstrNetID, string bstrCertificateList) {
            this.DisassociateCertificateAsync(bstrCertType, bstrNetID, bstrCertificateList, null);
        }
        
        /// <remarks/>
        public void DisassociateCertificateAsync(string bstrCertType, string bstrNetID, string bstrCertificateList, object userState) {
            if ((this.DisassociateCertificateOperationCompleted == null)) {
                this.DisassociateCertificateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDisassociateCertificateOperationCompleted);
            }
            this.InvokeAsync("DisassociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateList}, this.DisassociateCertificateOperationCompleted, userState);
        }
        
        private void OnDisassociateCertificateOperationCompleted(object arg) {
            if ((this.DisassociateCertificateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DisassociateCertificateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCredentialEx", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCredentialEx(tagPASSID PassIDIn, string bstrOptionalParams) {
            this.Invoke("DeleteCredentialEx", new object[] {
                        PassIDIn,
                        bstrOptionalParams});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteCredentialEx(tagPASSID PassIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteCredentialEx", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteCredentialEx(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteCredentialExAsync(tagPASSID PassIDIn, string bstrOptionalParams) {
            this.DeleteCredentialExAsync(PassIDIn, bstrOptionalParams, null);
        }
        
        /// <remarks/>
        public void DeleteCredentialExAsync(tagPASSID PassIDIn, string bstrOptionalParams, object userState) {
            if ((this.DeleteCredentialExOperationCompleted == null)) {
                this.DeleteCredentialExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteCredentialExOperationCompleted);
            }
            this.InvokeAsync("DeleteCredentialEx", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, this.DeleteCredentialExOperationCompleted, userState);
        }
        
        private void OnDeleteCredentialExOperationCompleted(object arg) {
            if ((this.DeleteCredentialExCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteCredentialExCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreateAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAUID")]
        public string CreateAlias(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, out string pbstrSuggestedNames) {
            object[] results = this.Invoke("CreateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML,
                        fSuggestName});
            pbstrSuggestedNames = ((string)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateAlias(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML,
                        fSuggestName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCreateAlias(System.IAsyncResult asyncResult, out string pbstrSuggestedNames) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrSuggestedNames = ((string)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CreateAliasAsync(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName) {
            this.CreateAliasAsync(PassIDIn, bstrAliasXML, fSuggestName, null);
        }
        
        /// <remarks/>
        public void CreateAliasAsync(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, object userState) {
            if ((this.CreateAliasOperationCompleted == null)) {
                this.CreateAliasOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateAliasOperationCompleted);
            }
            this.InvokeAsync("CreateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML,
                        fSuggestName}, this.CreateAliasOperationCompleted, userState);
        }
        
        private void OnCreateAliasOperationCompleted(object arg) {
            if ((this.CreateAliasCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateAliasCompleted(this, new CreateAliasCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateAlias(tagPASSID PassIDIn, string bstrAliasXML) {
            this.Invoke("UpdateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateAlias(tagPASSID PassIDIn, string bstrAliasXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateAlias(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UpdateAliasAsync(tagPASSID PassIDIn, string bstrAliasXML) {
            this.UpdateAliasAsync(PassIDIn, bstrAliasXML, null);
        }
        
        /// <remarks/>
        public void UpdateAliasAsync(tagPASSID PassIDIn, string bstrAliasXML, object userState) {
            if ((this.UpdateAliasOperationCompleted == null)) {
                this.UpdateAliasOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateAliasOperationCompleted);
            }
            this.InvokeAsync("UpdateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML}, this.UpdateAliasOperationCompleted, userState);
        }
        
        private void OnUpdateAliasOperationCompleted(object arg) {
            if ((this.UpdateAliasCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateAliasCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteAlias(tagPASSID PassIDIn, string bstrAliasXML) {
            this.Invoke("DeleteAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteAlias(tagPASSID PassIDIn, string bstrAliasXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteAlias(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteAliasAsync(tagPASSID PassIDIn, string bstrAliasXML) {
            this.DeleteAliasAsync(PassIDIn, bstrAliasXML, null);
        }
        
        /// <remarks/>
        public void DeleteAliasAsync(tagPASSID PassIDIn, string bstrAliasXML, object userState) {
            if ((this.DeleteAliasOperationCompleted == null)) {
                this.DeleteAliasOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteAliasOperationCompleted);
            }
            this.InvokeAsync("DeleteAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML}, this.DeleteAliasOperationCompleted, userState);
        }
        
        private void OnDeleteAliasOperationCompleted(object arg) {
            if ((this.DeleteAliasCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteAliasCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        public string RenameAlias(tagPASSID PassIDIn, string bstrOldName, string bstrNewName) {
            object[] results = this.Invoke("RenameAlias", new object[] {
                        PassIDIn,
                        bstrOldName,
                        bstrNewName});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRenameAlias(tagPASSID PassIDIn, string bstrOldName, string bstrNewName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RenameAlias", new object[] {
                        PassIDIn,
                        bstrOldName,
                        bstrNewName}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndRenameAlias(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void RenameAliasAsync(tagPASSID PassIDIn, string bstrOldName, string bstrNewName) {
            this.RenameAliasAsync(PassIDIn, bstrOldName, bstrNewName, null);
        }
        
        /// <remarks/>
        public void RenameAliasAsync(tagPASSID PassIDIn, string bstrOldName, string bstrNewName, object userState) {
            if ((this.RenameAliasOperationCompleted == null)) {
                this.RenameAliasOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRenameAliasOperationCompleted);
            }
            this.InvokeAsync("RenameAlias", new object[] {
                        PassIDIn,
                        bstrOldName,
                        bstrNewName}, this.RenameAliasOperationCompleted, userState);
        }
        
        private void OnRenameAliasOperationCompleted(object arg) {
            if ((this.RenameAliasCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RenameAliasCompleted(this, new RenameAliasCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAliasesForAccount", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        public string GetAliasesForAccount(tagPASSID PassIDIn, string bstrOptionalParams) {
            object[] results = this.Invoke("GetAliasesForAccount", new object[] {
                        PassIDIn,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAliasesForAccount(tagPASSID PassIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAliasesForAccount", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetAliasesForAccount(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetAliasesForAccountAsync(tagPASSID PassIDIn, string bstrOptionalParams) {
            this.GetAliasesForAccountAsync(PassIDIn, bstrOptionalParams, null);
        }
        
        /// <remarks/>
        public void GetAliasesForAccountAsync(tagPASSID PassIDIn, string bstrOptionalParams, object userState) {
            if ((this.GetAliasesForAccountOperationCompleted == null)) {
                this.GetAliasesForAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAliasesForAccountOperationCompleted);
            }
            this.InvokeAsync("GetAliasesForAccount", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, this.GetAliasesForAccountOperationCompleted, userState);
        }
        
        private void OnGetAliasesForAccountOperationCompleted(object arg) {
            if ((this.GetAliasesForAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAliasesForAccountCompleted(this, new GetAliasesForAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAccountForAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        public string GetAccountForAlias(tagPASSID AliasIDIn, string bstrOptionalParams) {
            object[] results = this.Invoke("GetAccountForAlias", new object[] {
                        AliasIDIn,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountForAlias(tagPASSID AliasIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountForAlias", new object[] {
                        AliasIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetAccountForAlias(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetAccountForAliasAsync(tagPASSID AliasIDIn, string bstrOptionalParams) {
            this.GetAccountForAliasAsync(AliasIDIn, bstrOptionalParams, null);
        }
        
        /// <remarks/>
        public void GetAccountForAliasAsync(tagPASSID AliasIDIn, string bstrOptionalParams, object userState) {
            if ((this.GetAccountForAliasOperationCompleted == null)) {
                this.GetAccountForAliasOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountForAliasOperationCompleted);
            }
            this.InvokeAsync("GetAccountForAlias", new object[] {
                        AliasIDIn,
                        bstrOptionalParams}, this.GetAccountForAliasOperationCompleted, userState);
        }
        
        private void OnGetAccountForAliasOperationCompleted(object arg) {
            if ((this.GetAccountForAliasCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetAccountForAliasCompleted(this, new GetAccountForAliasCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddToReputationScore", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDataFeedXML")]
        public string AddToReputationScore(string bstrDataFeedXML) {
            object[] results = this.Invoke("AddToReputationScore", new object[] {
                        bstrDataFeedXML});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddToReputationScore(string bstrDataFeedXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddToReputationScore", new object[] {
                        bstrDataFeedXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndAddToReputationScore(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddToReputationScoreAsync(string bstrDataFeedXML) {
            this.AddToReputationScoreAsync(bstrDataFeedXML, null);
        }
        
        /// <remarks/>
        public void AddToReputationScoreAsync(string bstrDataFeedXML, object userState) {
            if ((this.AddToReputationScoreOperationCompleted == null)) {
                this.AddToReputationScoreOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddToReputationScoreOperationCompleted);
            }
            this.InvokeAsync("AddToReputationScore", new object[] {
                        bstrDataFeedXML}, this.AddToReputationScoreOperationCompleted, userState);
        }
        
        private void OnAddToReputationScoreOperationCompleted(object arg) {
            if ((this.AddToReputationScoreCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddToReputationScoreCompleted(this, new AddToReputationScoreCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#OverrideReputationScore", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDataFeedXML")]
        public string OverrideReputationScore(string bstrDataFeedXML) {
            object[] results = this.Invoke("OverrideReputationScore", new object[] {
                        bstrDataFeedXML});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOverrideReputationScore(string bstrDataFeedXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OverrideReputationScore", new object[] {
                        bstrDataFeedXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndOverrideReputationScore(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void OverrideReputationScoreAsync(string bstrDataFeedXML) {
            this.OverrideReputationScoreAsync(bstrDataFeedXML, null);
        }
        
        /// <remarks/>
        public void OverrideReputationScoreAsync(string bstrDataFeedXML, object userState) {
            if ((this.OverrideReputationScoreOperationCompleted == null)) {
                this.OverrideReputationScoreOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOverrideReputationScoreOperationCompleted);
            }
            this.InvokeAsync("OverrideReputationScore", new object[] {
                        bstrDataFeedXML}, this.OverrideReputationScoreOperationCompleted, userState);
        }
        
        private void OnOverrideReputationScoreOperationCompleted(object arg) {
            if ((this.OverrideReputationScoreCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OverrideReputationScoreCompleted(this, new OverrideReputationScoreCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetReputationScoreDetails", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrReputationScoreXML")]
        public string GetReputationScoreDetails(tagPASSID PassIDIn, string bstrOptionalParams) {
            object[] results = this.Invoke("GetReputationScoreDetails", new object[] {
                        PassIDIn,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReputationScoreDetails(tagPASSID PassIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReputationScoreDetails", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetReputationScoreDetails(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetReputationScoreDetailsAsync(tagPASSID PassIDIn, string bstrOptionalParams) {
            this.GetReputationScoreDetailsAsync(PassIDIn, bstrOptionalParams, null);
        }
        
        /// <remarks/>
        public void GetReputationScoreDetailsAsync(tagPASSID PassIDIn, string bstrOptionalParams, object userState) {
            if ((this.GetReputationScoreDetailsOperationCompleted == null)) {
                this.GetReputationScoreDetailsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReputationScoreDetailsOperationCompleted);
            }
            this.InvokeAsync("GetReputationScoreDetails", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, this.GetReputationScoreDetailsOperationCompleted, userState);
        }
        
        private void OnGetReputationScoreDetailsOperationCompleted(object arg) {
            if ((this.GetReputationScoreDetailsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReputationScoreDetailsCompleted(this, new GetReputationScoreDetailsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumerateDevice", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDeviceIdsXML")]
        public string EnumerateDevice(tagPASSID idUserPUID) {
            object[] results = this.Invoke("EnumerateDevice", new object[] {
                        idUserPUID});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateDevice(tagPASSID idUserPUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateDevice", new object[] {
                        idUserPUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndEnumerateDevice(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateDeviceAsync(tagPASSID idUserPUID) {
            this.EnumerateDeviceAsync(idUserPUID, null);
        }
        
        /// <remarks/>
        public void EnumerateDeviceAsync(tagPASSID idUserPUID, object userState) {
            if ((this.EnumerateDeviceOperationCompleted == null)) {
                this.EnumerateDeviceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateDeviceOperationCompleted);
            }
            this.InvokeAsync("EnumerateDevice", new object[] {
                        idUserPUID}, this.EnumerateDeviceOperationCompleted, userState);
        }
        
        private void OnEnumerateDeviceOperationCompleted(object arg) {
            if ((this.EnumerateDeviceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateDeviceCompleted(this, new EnumerateDeviceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AssociateDevice", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AssociateDevice(string bstrAssociationInfoXml) {
            this.Invoke("AssociateDevice", new object[] {
                        bstrAssociationInfoXml});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAssociateDevice(string bstrAssociationInfoXml, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AssociateDevice", new object[] {
                        bstrAssociationInfoXml}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAssociateDevice(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void AssociateDeviceAsync(string bstrAssociationInfoXml) {
            this.AssociateDeviceAsync(bstrAssociationInfoXml, null);
        }
        
        /// <remarks/>
        public void AssociateDeviceAsync(string bstrAssociationInfoXml, object userState) {
            if ((this.AssociateDeviceOperationCompleted == null)) {
                this.AssociateDeviceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAssociateDeviceOperationCompleted);
            }
            this.InvokeAsync("AssociateDevice", new object[] {
                        bstrAssociationInfoXml}, this.AssociateDeviceOperationCompleted, userState);
        }
        
        private void OnAssociateDeviceOperationCompleted(object arg) {
            if ((this.AssociateDeviceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AssociateDeviceCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DisassociateDevice", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DisassociateDevice(tagPASSID idUserPUID, tagPASSID idDIDPUID, string bstrAssociationInfoXml) {
            this.Invoke("DisassociateDevice", new object[] {
                        idUserPUID,
                        idDIDPUID,
                        bstrAssociationInfoXml});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDisassociateDevice(tagPASSID idUserPUID, tagPASSID idDIDPUID, string bstrAssociationInfoXml, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DisassociateDevice", new object[] {
                        idUserPUID,
                        idDIDPUID,
                        bstrAssociationInfoXml}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDisassociateDevice(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DisassociateDeviceAsync(tagPASSID idUserPUID, tagPASSID idDIDPUID, string bstrAssociationInfoXml) {
            this.DisassociateDeviceAsync(idUserPUID, idDIDPUID, bstrAssociationInfoXml, null);
        }
        
        /// <remarks/>
        public void DisassociateDeviceAsync(tagPASSID idUserPUID, tagPASSID idDIDPUID, string bstrAssociationInfoXml, object userState) {
            if ((this.DisassociateDeviceOperationCompleted == null)) {
                this.DisassociateDeviceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDisassociateDeviceOperationCompleted);
            }
            this.InvokeAsync("DisassociateDevice", new object[] {
                        idUserPUID,
                        idDIDPUID,
                        bstrAssociationInfoXml}, this.DisassociateDeviceOperationCompleted, userState);
        }
        
        private void OnDisassociateDeviceOperationCompleted(object arg) {
            if ((this.DisassociateDeviceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DisassociateDeviceCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateDeviceProperties", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateDeviceProperties(tagPASSID idDIDPUID, string bstrDeviceProperties) {
            this.Invoke("UpdateDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrDeviceProperties});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateDeviceProperties(tagPASSID idDIDPUID, string bstrDeviceProperties, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrDeviceProperties}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateDeviceProperties(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UpdateDevicePropertiesAsync(tagPASSID idDIDPUID, string bstrDeviceProperties) {
            this.UpdateDevicePropertiesAsync(idDIDPUID, bstrDeviceProperties, null);
        }
        
        /// <remarks/>
        public void UpdateDevicePropertiesAsync(tagPASSID idDIDPUID, string bstrDeviceProperties, object userState) {
            if ((this.UpdateDevicePropertiesOperationCompleted == null)) {
                this.UpdateDevicePropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateDevicePropertiesOperationCompleted);
            }
            this.InvokeAsync("UpdateDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrDeviceProperties}, this.UpdateDevicePropertiesOperationCompleted, userState);
        }
        
        private void OnUpdateDevicePropertiesOperationCompleted(object arg) {
            if ((this.UpdateDevicePropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateDevicePropertiesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryDeviceProperties", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDeviceIdPropertiesXML")]
        public string QueryDeviceProperties(tagPASSID idDIDPUID, string bstrPropertyFilter) {
            object[] results = this.Invoke("QueryDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrPropertyFilter});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQueryDeviceProperties(tagPASSID idDIDPUID, string bstrPropertyFilter, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QueryDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrPropertyFilter}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndQueryDeviceProperties(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void QueryDevicePropertiesAsync(tagPASSID idDIDPUID, string bstrPropertyFilter) {
            this.QueryDevicePropertiesAsync(idDIDPUID, bstrPropertyFilter, null);
        }
        
        /// <remarks/>
        public void QueryDevicePropertiesAsync(tagPASSID idDIDPUID, string bstrPropertyFilter, object userState) {
            if ((this.QueryDevicePropertiesOperationCompleted == null)) {
                this.QueryDevicePropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQueryDevicePropertiesOperationCompleted);
            }
            this.InvokeAsync("QueryDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrPropertyFilter}, this.QueryDevicePropertiesOperationCompleted, userState);
        }
        
        private void OnQueryDevicePropertiesOperationCompleted(object arg) {
            if ((this.QueryDevicePropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QueryDevicePropertiesCompleted(this, new QueryDevicePropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ConvertCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ConvertCredential(tagPASSID PassIDIn, string bstrNewCredXML) {
            this.Invoke("ConvertCredential", new object[] {
                        PassIDIn,
                        bstrNewCredXML});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertCredential(tagPASSID PassIDIn, string bstrNewCredXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ConvertCredential", new object[] {
                        PassIDIn,
                        bstrNewCredXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertCredential(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void ConvertCredentialAsync(tagPASSID PassIDIn, string bstrNewCredXML) {
            this.ConvertCredentialAsync(PassIDIn, bstrNewCredXML, null);
        }
        
        /// <remarks/>
        public void ConvertCredentialAsync(tagPASSID PassIDIn, string bstrNewCredXML, object userState) {
            if ((this.ConvertCredentialOperationCompleted == null)) {
                this.ConvertCredentialOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConvertCredentialOperationCompleted);
            }
            this.InvokeAsync("ConvertCredential", new object[] {
                        PassIDIn,
                        bstrNewCredXML}, this.ConvertCredentialOperationCompleted, userState);
        }
        
        private void OnConvertCredentialOperationCompleted(object arg) {
            if ((this.ConvertCredentialCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConvertCredentialCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("WSSecurityHeader", Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", IsNullable=false)]
    public partial class tagWSSECURITYHEADER : System.Web.Services.Protocols.SoapHeader {
        
        private EnumSHVersion versionField;
        
        private string wssecurityField;
        
        private string authorizationField;
        
        private string sitetokenField;
        
        private string ppSoapHeader25Field;
        
        private string auditInfoField;
        
        private string delegateField;
        
        private string originatorField;
        
        private string clientIPField;
        
        /// <remarks/>
        public EnumSHVersion version {
            get {
                return this.versionField;
            }
            set {
                this.versionField = value;
            }
        }
        
        /// <remarks/>
        public string wssecurity {
            get {
                return this.wssecurityField;
            }
            set {
                this.wssecurityField = value;
            }
        }
        
        /// <remarks/>
        public string authorization {
            get {
                return this.authorizationField;
            }
            set {
                this.authorizationField = value;
            }
        }
        
        /// <remarks/>
        public string sitetoken {
            get {
                return this.sitetokenField;
            }
            set {
                this.sitetokenField = value;
            }
        }
        
        /// <remarks/>
        public string ppSoapHeader25 {
            get {
                return this.ppSoapHeader25Field;
            }
            set {
                this.ppSoapHeader25Field = value;
            }
        }
        
        /// <remarks/>
        public string auditInfo {
            get {
                return this.auditInfoField;
            }
            set {
                this.auditInfoField = value;
            }
        }
        
        /// <remarks/>
        public string @delegate {
            get {
                return this.delegateField;
            }
            set {
                this.delegateField = value;
            }
        }
        
        /// <remarks/>
        public string originator {
            get {
                return this.originatorField;
            }
            set {
                this.originatorField = value;
            }
        }
        
        /// <remarks/>
        public string clientIP {
            get {
                return this.clientIPField;
            }
            set {
                this.clientIPField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum EnumSHVersion {
        
        /// <remarks/>
        eshHeader30,
        
        /// <remarks/>
        eshHeader25,
        
        /// <remarks/>
        eshNone,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public partial class tagPASSID {
        
        private PASSIDTYPE pitField;
        
        private string bstrIDField;
        
        /// <remarks/>
        public PASSIDTYPE pit {
            get {
                return this.pitField;
            }
            set {
                this.pitField = value;
            }
        }
        
        /// <remarks/>
        public string bstrID {
            get {
                return this.bstrIDField;
            }
            set {
                this.bstrIDField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum PASSIDTYPE {
        
        /// <remarks/>
        PASSID_PUID_SIGNINNAME,
        
        /// <remarks/>
        PASSID_ROLEID,
        
        /// <remarks/>
        PASSID_PPSACREDENTIALID,
        
        /// <remarks/>
        PASSID_NULL,
        
        /// <remarks/>
        PASSID_PUID,
        
        /// <remarks/>
        PASSID_SIGNINNAME,
        
        /// <remarks/>
        PASSID_ALIASNAME,
        
        /// <remarks/>
        PASSID_AUID,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("PPSoapHeader", Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", IsNullable=false)]
    public partial class PPSoapHeader_wrapper : System.Web.Services.Protocols.SoapHeader {
        
        private string[] textField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string[] Text {
            get {
                return this.textField;
            }
            set {
                this.textField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetPassportIDCompletedEventHandler(object sender, GetPassportIDCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPassportIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPassportIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public tagPASSID Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((tagPASSID)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetCredentialInfoCompletedEventHandler(object sender, GetCredentialInfoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCredentialInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCredentialInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AddCredentialCompletedEventHandler(object sender, AddCredentialCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCredentialCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCredentialCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string pbstrNetID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void UpdateCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DeleteCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void RenameCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void UnblockCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void BlockCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void EnumCredentialsByNameCompletedEventHandler(object sender, EnumCredentialsByNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumCredentialsByNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumCredentialsByNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void EnumCredentialsByNetIDCompletedEventHandler(object sender, EnumCredentialsByNetIDCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumCredentialsByNetIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumCredentialsByNetIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void EnumCredentialsByNamespaceCompletedEventHandler(object sender, EnumCredentialsByNamespaceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumCredentialsByNamespaceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumCredentialsByNamespaceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetCertificateAssociationsCompletedEventHandler(object sender, GetCertificateAssociationsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCertificateAssociationsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCertificateAssociationsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DeleteCertificateAssociationCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DeleteAllCertificateAssociationsCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetSigninNamesForNetIDsCompletedEventHandler(object sender, GetSigninNamesForNetIDsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSigninNamesForNetIDsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSigninNamesForNetIDsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void ForceCredentialRenameCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetNetIDsForSigninNamesCompletedEventHandler(object sender, GetNetIDsForSigninNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNetIDsForSigninNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNetIDsForSigninNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void QueryCredentialChangesCompletedEventHandler(object sender, QueryCredentialChangesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCredentialChangesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCredentialChangesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void QueryCredentialHistoryCompletedEventHandler(object sender, QueryCredentialHistoryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCredentialHistoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCredentialHistoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void QueryCredentialHistoryByNetIDCompletedEventHandler(object sender, QueryCredentialHistoryByNetIDCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCredentialHistoryByNetIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCredentialHistoryByNetIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void QueryNetIDHistoryBySigninNameCompletedEventHandler(object sender, QueryNetIDHistoryBySigninNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryNetIDHistoryBySigninNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryNetIDHistoryBySigninNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void SuggestAlternateMemberNamesCompletedEventHandler(object sender, SuggestAlternateMemberNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SuggestAlternateMemberNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SuggestAlternateMemberNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetSigninNamesAndCIDsForNetIDsCompletedEventHandler(object sender, GetSigninNamesAndCIDsForNetIDsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSigninNamesAndCIDsForNetIDsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSigninNamesAndCIDsForNetIDsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetNetIDsAndCIDsForSigninNamesCompletedEventHandler(object sender, GetNetIDsAndCIDsForSigninNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNetIDsAndCIDsForSigninNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNetIDsAndCIDsForSigninNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void CheckAvailableSigninNamesCompletedEventHandler(object sender, CheckAvailableSigninNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckAvailableSigninNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CheckAvailableSigninNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void CheckRenameRulesCompletedEventHandler(object sender, CheckRenameRulesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckRenameRulesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CheckRenameRulesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void RenameCredentialExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void ReserveNameCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetSLTCompletedEventHandler(object sender, GetSLTCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSLTCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSLTCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AddLinkAccountsCompletedEventHandler(object sender, AddLinkAccountsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddLinkAccountsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddLinkAccountsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string pbstrLinkID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DeLinkAccountsCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetLinkAccountMembersCompletedEventHandler(object sender, GetLinkAccountMembersCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLinkAccountMembersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLinkAccountMembersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AssociateCertificateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DisassociateCertificateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DeleteCredentialExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void CreateAliasCompletedEventHandler(object sender, CreateAliasCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateAliasCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateAliasCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrSuggestedNames {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void UpdateAliasCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DeleteAliasCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void RenameAliasCompletedEventHandler(object sender, RenameAliasCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RenameAliasCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RenameAliasCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetAliasesForAccountCompletedEventHandler(object sender, GetAliasesForAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAliasesForAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAliasesForAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetAccountForAliasCompletedEventHandler(object sender, GetAccountForAliasCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountForAliasCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAccountForAliasCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AddToReputationScoreCompletedEventHandler(object sender, AddToReputationScoreCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddToReputationScoreCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddToReputationScoreCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void OverrideReputationScoreCompletedEventHandler(object sender, OverrideReputationScoreCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OverrideReputationScoreCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal OverrideReputationScoreCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetReputationScoreDetailsCompletedEventHandler(object sender, GetReputationScoreDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReputationScoreDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReputationScoreDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void EnumerateDeviceCompletedEventHandler(object sender, EnumerateDeviceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateDeviceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateDeviceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void AssociateDeviceCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void DisassociateDeviceCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void UpdateDevicePropertiesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void QueryDevicePropertiesCompletedEventHandler(object sender, QueryDevicePropertiesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryDevicePropertiesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryDevicePropertiesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void ConvertCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DefaultLocalLivecacheContext.cs ===
﻿using xonline.common.webplatform.livecache;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Live.Livecache
{
    public class DefaultLocalLivecacheContext : ILocalLivecacheContext
    {
        private IContextItemProvider contextItemProvider;
        private IConfigurationProvider configProvider;

        public DefaultLocalLivecacheContext(IContextItemProvider contextItemProvider, IConfigurationProvider configProvider)
        {
            this.contextItemProvider = contextItemProvider;
            this.configProvider = configProvider;
        }


        #region ILocalLivecacheContext Members

        public IAccountAuthDataProvider CurrentUser
        {
            get 
            {
                return Container.Instance.GetComponent<IAccountAuthDataProvider>();
            }
        }

        public bool ShouldApplyPerUserThrottle(LivecacheRequest request)
        {
            return configProvider.GetBoolSetting(Settings.LivecachePerUserThrottleEnabled);
        }

        public bool ShouldCacheRequest(LivecacheRequest request)
        {
            return configProvider.GetBoolSetting(Settings.LivecacheLocalCachingEnabled);
        }

        #endregion

        #region IContextItemProvider Members

        public object this[string name]
        {
            get
            {
                return this.contextItemProvider[name];
            }
            set
            {
                this.contextItemProvider[name] = value;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\ILcAuthManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Account
{
    public interface ILcAuthManager
    {
        ILcAuthTicket GetAuthTicket();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\LivecacheLogger.cs ===
﻿using System;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache
{
    /// <summary>
    /// This is a stubbed out class that is intended to hold the "official" implementation of
    /// the ILivecacheLogger interface for LIVE Engagement applications.  It
    /// should be modified appropriately when the correct information is available.
    /// </summary>
    public class LivecacheLogger : ILivecacheLogger
    {
        public LivecacheLogger(string area, string component)
        {
            // init logging storage for default logger -- expected dependency on the ongoing event log dev work
        }

        #region ILivecacheLogger Members

        public void LogError(Enum eventId, string format, params object[] args)
        {
            return;
        }

        public void LogError(Enum eventId, Exception ex, string format, params object[] args)
        {
            return;
        }

        public void LogInfo(Enum eventId, Exception ex, string format, params object[] args)
        {
            return;
        }

        public void LogInfo(string format, params object[] args)
        {
            return;
        }

        public void LogVerbose(string format, params object[] args)
        {
            return;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\LeetLivecacheClient.cs ===
﻿namespace Leet.Live.Livecache
{
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.Account;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Providers;
    using xonline.common.webplatform.livecache;

    public class LeetLivecacheClient
    {
        internal static string ComponentName = string.Empty;

        public static bool IsInitialized = false;

        /// <summary>
        /// Initializes the Livecache client.  Should be called on application startup.
        /// Will register the interfaces appropriate for using Livecache with an available
        /// HttpContext (typically as part of a web site)
        /// </summary>
        /// <param name="componentName">Name used by logging components to uniquely identify the client application</param>
        public static void RegisterWebInterfacesAndInitialize(string componentName)
        {
            if (IsInitialized)
                return;

            RegisterWebInterfacesAndInitialize(componentName, LivecacheClientType.LIVEn);
        }

        public static void RegisterWebInterfacesAndInitialize(string componentName, LivecacheClientType clientType)
        {
            if (IsInitialized)
                return;

            ComponentName = componentName;
            // Required LiveCache/Xcache interfaces
            switch(clientType)
            {
                case LivecacheClientType.Xboxcom:
                    Container.Instance.AddEmulatableService<ILivecacheClientIdentifierProvider, XboxcomLivecacheClientIdentifierProvider>();
                    break;
                default:
                    Container.Instance.AddEmulatableService<ILivecacheClientIdentifierProvider, LIVEnLivecacheClientIdentifierProvider>();
                    break;

            }
            Container.Instance.AddEmulatableService<ILocalLivecacheContextProvider, LocalLivecacheContextProvider>();
            Container.Instance.AddEmulatableService<ILivecacheLocaleProvider, DefaultLivecacheLocaleProvider>();
            Container.Instance.AddEmulatableService<IContextItemProvider, WebContextItemProvider>();
            Container.Instance.AddEmulatableService<ILocalLivecacheContext, DefaultLocalLivecacheContext>();

            Container.Instance.AddEmulatableService<ILivecacheLoggerProvider, LivecacheLoggerProvider>();
            Container.Instance.AddEmulatableService<ILivecacheLogger, LivecacheLogger>();

            // TODO:  Replace these with final implementations of the objects once Leet.Authentication refactoring is completed
            Container.Instance.AddEmulatableService<IAccountAuthDataProvider, LIVEnWebMobileExtendedAuthDataProvider>();
            
            RegisterDataAccessInterfaces();
            Initialize(componentName);
        }

        /// <summary>
        /// Initializes the Livecache client.  Should be called on application startup.
        /// Will register interfaces appropriate for a service without an HttpContext to use.
        /// </summary>
        /// <param name="componentName">Name used by logging components to uniquely identify the client application</param>
        public static void RegisterServiceInterfacesAndInitialize(string componentName)
        {
            if (IsInitialized)
                return;

            ComponentName = componentName;
            Container.Instance.AddEmulatableService<ILivecacheClientIdentifierProvider, LIVEnLivecacheClientIdentifierProvider>();
            Container.Instance.AddEmulatableService<ILocalLivecacheContextProvider, LocalLivecacheContextProvider>();
            Container.Instance.AddEmulatableService<ILivecacheLocaleProvider, DefaultLivecacheLocaleProvider>();

            Container.Instance.AddEmulatableService<IContextItemProvider, NonWebContextItemProvider>();
            Container.Instance.AddEmulatableService<ILocalLivecacheContext, DefaultLocalLivecacheContext>();

            Container.Instance.AddEmulatableService<ILivecacheLoggerProvider, LivecacheLoggerProvider>();
            Container.Instance.AddEmulatableService<ILivecacheLogger, LivecacheLogger>();

            Container.Instance.AddEmulatableService<ILcAuthManager, AnonymousLcAuthManager>();
            Container.Instance.AddEmulatableService<IAccountAuthDataProvider, LIVEnServiceMobileExtendedAuthDataProvider>();

            RegisterDataAccessInterfaces();
            Initialize(componentName);
        }

        private static void RegisterDataAccessInterfaces()
        {
            Container.Instance.AddEmulatableService<IXCacheDataAccess, XCacheDataAccess>();
            Container.Instance.AddEmulatableService<ILcXCache, LcXCache>();

            Container.Instance.AddEmulatableService<IPresenceDataAccess, PresenceDataAccess>();
            Container.Instance.AddEmulatableService<ILcPresence, LcPresenceAdapter>();

            Container.Instance.AddEmulatableService<IAccountCreationDataAccess, AccountCreationDataAccess>();
            Container.Instance.AddEmulatableService<ILcAccountCreation, LcAccountCreationAdapter>();

            Container.Instance.AddEmulatableService<IAchievementDataAccess, AchievementDataAccess>();
            Container.Instance.AddEmulatableService<ILcAchievement, LcAchievementAdapter>();

            Container.Instance.AddEmulatableService<ISettingsDataAccess, SettingsDataAccess>();
            Container.Instance.AddEmulatableService<ILcStats, LcStatsAdapter>();
            Container.Instance.AddEmulatableService<ILcLeaderboards, LcLeaderboards>();
            Container.Instance.AddEmulatableService<ILcTitleStorage, LcTitleStorage>();

            Container.Instance.AddEmulatableService<IStsDataAccess, StsDataAccess>();
            Container.Instance.AddEmulatableService<ILcSts, LcStsAdapter>();

            Container.Instance.AddEmulatableService<IAvatarStorageAccess, AvatarStorageAccess>();
            Container.Instance.AddEmulatableService<ILcStorageAdapter, LcStorageAdapter>();

            Container.Instance.AddEmulatableService<ILcStringSvr, LcStringSvrAdapter>();

            Container.Instance.AddEmulatableService<ILcBillingOffering, LcBillingOfferingAdapter>();

            Container.Instance.AddEmulatableService<IBillingOfferingDataAccess, BillingOfferingDataAccess>();
        }

        private static void Initialize(string componentName)
        {
            Container.Instance.GetComponent<ILivecacheLoggerProvider>().RegisterLogger(componentName);
            Container.Instance.GetComponent<ILocalLivecacheContextProvider>().RegisterLocalContext();
            Container.Instance.GetComponent<ILivecacheLocaleProvider>().RegisterLocaleHandler();

            IsInitialized = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\AnonymousLcAuthManager.cs ===
﻿using System;
using Leet.Live.Livecache.Providers;
using xonline.common.service;

namespace Leet.Live.Livecache.Account
{
    /// <summary>
    /// A temporary class to act as a placeholder until Leet.Core & Leet.Authentication changes are
    /// made.  This will then be removed and replaced with final implementations from those libraries.
    /// </summary>
    public class AnonymousLcAuthManager : ILcAuthManager
    {
        private const string UnknownGamerTag = "??????";

        #region ILcAuthManager Members

        public ILcAuthTicket GetAuthTicket()
        {
            return BuildNewTicket();
        }

        #endregion

        private LcAuthTicket BuildNewTicket()
        {
            AnonymousAuthDataProvider anonAuthProvider = new AnonymousAuthDataProvider();
            LcAuthTicket ticket = new LcAuthTicket();
            ticket.Privileges = anonAuthProvider.Privileges;
            ticket.LivePuid = anonAuthProvider.LivePuid;
            ticket.Tier = anonAuthProvider.Tier;
            ticket.ParentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
            ticket.Gamertag = UnknownGamerTag;

            return ticket;
        }

        private bool IsUnknownGamertag(string gamertag)
        {
            return String.IsNullOrEmpty(gamertag) || (gamertag.Length > 0 && gamertag[0] == '?');
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\ILcAuthTicket.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Account
{
    public interface ILcAuthTicket
    {
        ulong Puid { get; }
        uint[] Privileges { get; }
        ulong LivePuid { get; }
        uint Tier { get; }
        string Gamertag { get; }
        int ParentalControlGroup { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\LcAuthTicket.cs ===
﻿using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Account
{
    public class LcAuthTicket : ILcAuthTicket
    {
        public ulong Puid { get; set; }
        public uint[] Privileges { get; set; }
        public ulong LivePuid { get; set; }
        public uint Tier { get; set; }
        public string Gamertag { get; set; }
        public int ParentalControlGroup { get; set; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\LivecacheConstants.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.service;

namespace Leet.Live.Livecache
{


    public static class LivecacheConstants
    {
        #region Constants from PresDefs

        // public system set state flags
        public const uint P_STATE_FLAG_NONE = 0;
        public const uint P_STATE_FLAG_ONLINE = 0x00000001; // Set if online
        public const uint P_STATE_FLAG_PLAYING = 0x00000002; // Set if playing a game
        public const uint P_STATE_FLAG_CLOAKED = 0x00000004; // Set to fake being offline
        public const uint P_STATE_FLAG_VOICE = 0x00000008; // Set if supports voice
        public const uint P_STATE_FLAG_JOINABLE = 0x00000010; // Set if session is joinable
        public const uint P_STATE_MASK_GUESTS = 0x00000060;
        public const uint P_STATE_FLAG_RESERVED0 = 0x00000080;

        // private user set state enumeration
        public const uint P_STATE_ENUM_ONLINE = 0x00000000;
        public const uint P_STATE_ENUM_AWAY = 0x00010000;
        public const uint P_STATE_ENUM_BUSY = 0x00020000;
        public const uint P_STATE_ENUM_WEB = 0x00030000;
        public const uint P_STATE_ENUM_RESERVED2 = 0x00040000;
        public const uint P_STATE_ENUM_RESERVED3 = 0x00050000;
        public const uint P_STATE_ENUM_RESERVED4 = 0x00060000;
        public const uint P_STATE_MASK_USER_STATE = 0x000F0000;

        // messaging/notification state flags
        public const uint P_STATE_FLAG_VOICE_TV = 0x02000000;
        public const uint P_STATE_FLAG_SENTINVITE = 0x04000000;
        public const uint P_STATE_FLAG_RECEIVEDINVITE = 0x08000000;
        public const uint P_STATE_FLAG_INVITEACCEPTED = 0x10000000;
        public const uint P_STATE_FLAG_INVITEREJECTED = 0x20000000;
        public const uint P_STATE_FLAG_SENTREQUEST = 0x40000000;
        public const uint P_STATE_FLAG_RECEIVEDREQUEST = 0x80000000;

        // User buddy status
        public const uint P_BUDDY_STATUS_OK = 0; // Mutually accepted buddy
        public const uint P_BUDDY_STATUS_PENDING = 1; // Buddy request pending acceptance
        public const uint P_BUDDY_STATUS_REQUEST = 2; // Buddy request to accept or reject

        #endregion

        #region Common XONLINE Constants

        public const uint XSOURCE_DEFAULT = 1;
        public const uint XSOURCE_NO_VALUE = 0;
        public const uint XSOURCE_PERMISSION_DENIED = 3;
        public const uint XSOURCE_TITLE = 2;

        public static uint XONLINE_NAME_MAX_SIZE = XOn.XONLINE_NAME_MAX_SIZE;

        public const uint XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES = 0x80155A0B;   // the sender does not have permissions to send this message
        public const uint XONLINE_E_MESSAGE_SENDER_BLOCKED = 0x80155A07;            // a send failed because the recipient has blocked the sender

        #endregion

        #region Misc Constants

        public const uint WEB_TITLE_ID = 4293722112;

        #endregion Misc Constants
    }

    public enum GamercardZone : int
    {
        Unknown = -2,
        None = -1,
        XBOXLive = 0,
        Recreation = 1,
        Pro = 2,
        Family = 3,
        Underground = 4
    }

    /// <summary>
    /// List of valid profile Live tiers.
    /// </summary>
    public enum GamerTier : int
    {
        Unknown = -1,
        None = 0,
        Silver = 3,
        Gold = 6,
        Family = 9, 
    }

    public enum StatsProfileSettings : uint
    {
        //Web preferences
        Spam = 0x10042002,
        Flash = 0x1004200C,
        VideoPreference = 0x1004200D,
        EmailFormat = 0x10042000,
        FavoriteGenre = 0x10042003,
        FavoriteGame = 0x10042004,
        FavoriteGame1 = 0x10042005,
        FavoriteGame2 = 0x10042006,
        FavoriteGame3 = 0x10042007,
        FavoriteGame4 = 0x10042008,
        FavoriteGame5 = 0x10042009,
        PlatformsOwned = 0x1004200A,
        ConnectionSpeed = 0x1004200B,
        Flags = 0x10042001,

        //Gamer profile
        ProfilePermissions = 0x10040000,
        GamercardZone = 0x10040004,
        GamercardTile = 0x4064000F,
        GamercardMotto = 0x402C0011,
        GamercardRep = 0x5004000B,
        GamercardCred = 0x10040006,
        GamerTier = 0x1004003A,
        GamerType = 0x10040001,
        GamerCountry = 0x10040005,
        GamercardName = 0x41040040,
        GamercardLocation = 0x40520041,
        GamercardBlogUrl = 0x41900042,
        GamercardBio = 0x43E80043,
        GamercardAvatarInfo = 0x63E80044,
    }

    [Flags]
    public enum GamerTypeFlags : int
    {
        LaunchTeam = 0x01,
        Cheater = 0x02,
        NXELaunchTeam = 0x04
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\Account.cs ===
﻿
namespace Leet.Live.Livecache.Account
{
    using System;
    using xonline.common.service;

    /// <summary>
    /// Account Class
    /// </summary>
    public class Account
    {
        public ulong Xuid { get; set; }
        public SubscriptionTier Tier { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public DateTime DateOfBirth { get; set; }
        public string Email { get; set; }
        public bool MicrosoftOptIn { get; set; }
        public bool PartnerOptIn { get; set; }
        public string Phone { get; set; }
        public string Street1 { get; set; }
        public string Street2 { get; set; }
        public string City { get; set; }
        public string StateCode { get; set; }
        public string PostalCode { get; set; }
        public int CountryId { get; set; }
        public ushort LanguageId { get; set; }
    }

    public enum SubscriptionTier
    {
        None = (int)XOn.XONLINE_TIER_NEWUSER,
        Silver = (int)XOn.XONLINE_TIER_SILVER,
        Gold = (int)XOn.XONLINE_TIER_GOLD,
        Family = (int)XOn.XONLINE_TIER_FAMILY_GOLD 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\EnumerateAssetsRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.DataAccess
{
    public class EnumerateAssetsRequest
    {
       public ulong Xuid {get; set;}
       public uint TitleId {get; set;}
       public String Locale { get; set; }
       public uint MaxResults { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\AvatarStorageAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Logic.Profile;
using xonline.common.service;

namespace Leet.Live.Livecache.DataAccess
{
    public class AvatarStorageAccess : IAvatarStorageAccess
    {
        public AvatarStorageAccess(ILcStorageAdapter lcStorageAdapter)
        {
            _lcStorageAdapter = lcStorageAdapter;
        }

        public void StorageWrite(ulong userId, string pictureName, byte[] data)
        {
            string path = string.Format("//avatar/u:{0:x}/{1}", userId, pictureName);
            _lcStorageAdapter.StorageWrite(0, path, data, DateTime.MaxValue, 0, LivecacheClientType.LIVEn);
        }

        public bool StorageValidate(ulong readerXuid, string pictureName)
        {
            string path = string.Format("//avatar/u:{0:x}/{1}", readerXuid, pictureName);
            bool result = _lcStorageAdapter.StorageValidate(readerXuid, path, XOn.XENON_DASH_TITLE_ID, LivecacheClientType.LIVEn);

            return result;
        }

        private ILcStorageAdapter _lcStorageAdapter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\AchievementDataAccess.cs ===
﻿
namespace Leet.Live.Livecache.DataAccess
{
    using System;
    using System.Collections.Generic;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.Live.Livecache.Logic.Avatars;
    using Leet.Live.Livecache.Logic.Games;
    using Leet.Live.Livecache.Providers;
    using UserTitle = xonline.common.protocol.UserTitle;
    using xonline.common.protocol;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;
    using xProtocol = xonline.common.protocol;

    public class AchievementDataAccess : IAchievementDataAccess
    {
        private ILcAchievement _lcAchievement;
        private ILcStringSvr _lcStringSvr;
        private IContextItemProvider _context;

        public AchievementDataAccess(
            ILcAchievement lcAchievement,
            ILcStringSvr lcStringSvr,
            IContextItemProvider context)
        {
            _lcAchievement = lcAchievement;
            _lcStringSvr = lcStringSvr;
            _context = context;
        }

        #region IAchievementDataAccess Members

        public List<IReadOnlyUserTitle> GetUserTitles(ulong callingUserPuid, ulong targetUserPuid, ushort localeId, ushort startingIndex, ushort maxTitles)
        {
            List<IReadOnlyUserTitle> userTitleList = new List<IReadOnlyUserTitle>();
            EnumTitlesRequest request = new EnumTitlesRequest(callingUserPuid, targetUserPuid, startingIndex, maxTitles);
            request.LocaleId = localeId;

            EnumTitlesResponse response = _lcAchievement.GetUserTitles(request);
            if (response != null)
            {
                for (int i = 0; i < response.TitlesLen; i++)
                {
                    if (IsTitleValid(response.Titles[i], localeId) && response.Titles[i].ShouldAppearInUserHistory())
                    {
                        userTitleList.Add(new Leet.Live.Livecache.Logic.Games.UserTitle(response.Titles[i]));
                    }
                }
            }
            return userTitleList;
        }        

        public List<IReadOnlyUserTitle> GetPublicUserTitles(ulong targetUserPuid, ushort localeId, ushort startingIndex, ushort maxTitles, out DateTime responseTTL)
        {
            IAccountAuthDataProvider anonymousAuthProvider = new AnonymousAuthDataProvider();
            List<IReadOnlyUserTitle> userTitleList = new List<IReadOnlyUserTitle>();

            EnumTitlesRequest request = new EnumTitlesRequest(anonymousAuthProvider.LivePuid, targetUserPuid,
                                                              startingIndex, maxTitles);
            request.LocaleId = localeId;

            EnumTitlesResponse response = _lcAchievement.GetPublicUserTitles(request, anonymousAuthProvider,
                                                                             out responseTTL);

            if (response != null)
            {
                for (int i = 0; i < response.TitlesLen; i++)
                {
                    if (IsTitleValid(response.Titles[i], localeId) && response.Titles[i].ShouldAppearInUserHistory())
                    {
                        userTitleList.Add(new Leet.Live.Livecache.Logic.Games.UserTitle(response.Titles[i]));
                    }
                }
            }

            return userTitleList;
        }

        private bool IsTitleValid(xProtocol.UserTitle title, ushort localeId)
        {
            string key = String.Format("LocTitle:{0}:{1}", title.TitleId.ToString(), localeId.ToString());
            string locTitle = (string)_context[key];

            if (String.IsNullOrEmpty(locTitle))
            {
                DateTime cacheTTL;
                try
                {
                    locTitle = _lcStringSvr.StringLookup(title.TitleId, 0, localeId, out cacheTTL);
                }
                catch
                {
                    return false;
                }
            }

            if (String.IsNullOrEmpty(locTitle))
            {
                return false;
            }

            _context[key] = locTitle;
            return true;
        }

        public List<IReadOnlyAchievementInfo> GetUserAchievements(uint gameTitleId, ulong callingUserPuid, ulong targetUserPuid, ushort localeId)
        {
            List<IReadOnlyAchievementInfo> achievements = new List<IReadOnlyAchievementInfo>();
            AchievementEnumResponse response = null;
            bool hasMoreAchievements = true;
            ushort startIndex = 0;

            AchievementEnumRequest request = new AchievementEnumRequest();
            request.TitleId = gameTitleId;
            request.Puid = callingUserPuid;
            request.ForPuid = targetUserPuid;
            request.MaxAchievements = XOn.XONLINE_MAX_ACHIEVEMENTS;
            request.LocaleId = localeId;

            // Achievements come back in XOn.XONLINE_MAX_ACHIEVEMENTS sized chunks.  Keep fetching 
            // and adding to list until all achievements have been retrieved.
            while (hasMoreAchievements)
            {
                // don't catch exceptions, they will get handled (logged) by the caller
                // doing anything else yields incorrect behaviour (like saying no achievements for this user)
                request.StartingIndex = startIndex;
                response = _lcAchievement.GetUserAchievements(request);

                // Add the chunk of achievements to the list
                if (response != null)
                {
                    foreach (Achievement a in response.Achievements)
                    {
                        achievements.Add(new AchievementInfo(gameTitleId, a));
                    }

                    if (response.Achievements.Length < XOn.XONLINE_MAX_ACHIEVEMENTS)
                    {
                        hasMoreAchievements = false;
                    }
                    else
                    {
                        startIndex += XOn.XONLINE_MAX_ACHIEVEMENTS;
                    }
                }
                else
                {
                    hasMoreAchievements = false;
                }
            }

            return achievements;
        }

        public void SyncAchievements(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<IReadOnlyAchievementInfo> readOnlyAchievementInfos)
        {
            if (readOnlyAchievementInfos == null || readOnlyAchievementInfos.Count == 0)
            {
                throw new ArgumentException("readOnlyAchievementInfos cannot be null or empty.");
            }

            Achievement[] achievements = new Achievement[readOnlyAchievementInfos.Count];

            for (int i = 0; i < readOnlyAchievementInfos.Count; i++)
            {
                achievements[i] = new Achievement();
                achievements[i].AchievementId = readOnlyAchievementInfos[i].AchievementId;
                achievements[i].Achieved = readOnlyAchievementInfos[i].DateUnlocked;
                achievements[i].Sequence = (uint) i;
                achievements[i].Flags = readOnlyAchievementInfos[i].Flags;
            }

            SyncAchievementsRequest request = new SyncAchievementsRequest();
            request.TitleId = gameTitleId;
            request.UserId = targetUserPuid;
            request.Version = DateTime.UtcNow;
            request.LocaleId = localeId;
            request.StartingIndex = 0;
            request.AchievementCount = (ushort) achievements.Length;
            request.Achievements = achievements;

            _lcAchievement.SyncAchievements(request);
        }

        public void SyncTitles(uint gameTitleId, ulong targetUserPuid, ushort localeId, DateTime lastPlayedTime)
        {
            xProtocol.UserTitle[] titles = new UserTitle[1];

            titles[0] = new UserTitle();
            titles[0].Sequence = 0;
            titles[0].LastPlayed = lastPlayedTime;
            titles[0].TitleId = gameTitleId;

            SyncTitlesRequest request = new SyncTitlesRequest();
            request.UserId = targetUserPuid;
            request.LocaleId = localeId;
            request.StartingIndex = 0;
            request.Version = DateTime.UtcNow;
            request.TitlesLen = 1;
            request.Titles = titles;

            _lcAchievement.SyncTitles(request);
        }

        public void SyncAvatarAssets(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<AwardedAvatarAsset> awardedAvatarAssets)
        {
            if (awardedAvatarAssets == null || awardedAvatarAssets.Count == 0)
            {
                throw new ArgumentException("awardedAvatarAssets cannot be null or empty.");
            }

            // count the total avatar assets to award
            // if IsUnisexItem = true, then award only the unisex asset, else award both male and female assets
            int totalAssetsAwarded = 0;
            for (int i = 0; i < awardedAvatarAssets.Count; i++)
            {
                if (awardedAvatarAssets[i].IsUnisexItem == true)
                {
                    totalAssetsAwarded += 1;
                }
                else
                {
                    totalAssetsAwarded += 2;
                }
            }

            xProtocol.AvatarAsset[] avatarAsset = new xProtocol.AvatarAsset[totalAssetsAwarded];

            int j = 0; // index for avatarAsset array
            for (int i = 0; i < awardedAvatarAssets.Count; i++)
            {
                if (awardedAvatarAssets[i].IsUnisexItem == true)
                {
                    // award only the eunisex asset
                    avatarAsset[j] = new xProtocol.AvatarAsset();
                    // here AvatarBodyType.All (=2) really means unisex
                    avatarAsset[j].BodyTypeMask = (byte)Leet.Live.Livecache.Logic.Avatars.AvatarBodyType.All;
                    avatarAsset[j].Awarded = awardedAvatarAssets[i].Awarded;
                    avatarAsset[j].AvatarAssetOrdinal = awardedAvatarAssets[i].AvatarAssetOrdinal;
                    avatarAsset[j].Sequence = (uint)i;
                    avatarAsset[j].Flags = awardedAvatarAssets[i].Flags;
                    j += 1;
                }
                else
                {
                    // award both male and femal assets
                    avatarAsset[j] = new xProtocol.AvatarAsset();
                    avatarAsset[j].BodyTypeMask = (byte)Leet.Live.Livecache.Logic.Avatars.AvatarBodyType.Male;
                    avatarAsset[j].Awarded = awardedAvatarAssets[i].Awarded;
                    avatarAsset[j].AvatarAssetOrdinal = awardedAvatarAssets[i].AvatarAssetOrdinal;
                    avatarAsset[j].Sequence = (uint)i;
                    avatarAsset[j].Flags = awardedAvatarAssets[i].Flags;

                    avatarAsset[j + 1] = new xProtocol.AvatarAsset();
                    avatarAsset[j + 1].BodyTypeMask = (byte)Leet.Live.Livecache.Logic.Avatars.AvatarBodyType.Female;
                    avatarAsset[j + 1].Awarded = awardedAvatarAssets[i].Awarded;
                    avatarAsset[j + 1].AvatarAssetOrdinal = awardedAvatarAssets[i].AvatarAssetOrdinal;
                    avatarAsset[j + 1].Sequence = (uint)(i + 1);
                    avatarAsset[j + 1].Flags = awardedAvatarAssets[i].Flags;
                    j += 2;
                }
            }

            SyncAvatarAssetRequest request = new SyncAvatarAssetRequest();
            request.TitleId = gameTitleId;
            request.UserId = targetUserPuid;
            request.Version = DateTime.UtcNow;
            request.LocaleId = localeId;
            request.StartingIndex = 0;
            request.AvatarAssetCount = (ushort) avatarAsset.Length;
            request.AvatarAssets = avatarAsset;

            _lcAchievement.SyncAvatarAssets(request);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\WebLcAuthManager.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using xonline.common.protocol;
using xonline.common.service;

namespace Leet.Live.Livecache.Account
{
    public class WebLcAuthManager : ILcAuthManager
    {
        private const string UnknownGamerTag = "??????";

        public WebLcAuthManager()
        {
        }

        public ILcAuthTicket GetAuthTicket()
        {
            LcAuthTicket authTicket = null;
            WebTicket webTicket = WebTicket.Current;
            ulong puid = 0;

            // TODO: uncomment code below when this code is moved to Leet.Authentication
            //IUserIdentity identityMgr = Container.Instance.GetComponent<IUserIdentity>();

            //if (!identityMgr.IsAuthenticated)
            //{
            //    return null;
            //}

            if ((webTicket != null) && (webTicket.IssuedOn < DateTime.Now.AddMinutes(-15))) // tickets are valid for 15 minutes after they're issued
            {
                webTicket = null;
            }

            if (webTicket != null && IsUnknownGamertag(webTicket.Gamertag))
            {
                webTicket = null;
            }

            // TODO: hard-coding puid until this code is moved to Leet.Authentication. Needs to eventually be pulled from IUserIdentity
            puid = 0;

            if (webTicket != null && puid != webTicket.PassportPuid)
            {
                webTicket = null;
            }

            if (webTicket == null)
            {
                webTicket = BuildNewTicket(puid);
            }

            if (webTicket != null)
            {
                authTicket = new LcAuthTicket();
                authTicket.LivePuid = webTicket.LivePuid;
                authTicket.Privileges = webTicket.Privileges;
                authTicket.Puid = webTicket.PassportPuid;
                authTicket.Tier = webTicket.Tier;
                authTicket.Gamertag = webTicket.Gamertag;
                authTicket.ParentalControlGroup = webTicket.ParentalControlGroup;
            }

            return authTicket;
        }

        private WebTicket BuildNewTicket(ulong puid)
        {
            WebTicket ticket = null;
            ulong livePuid = 0;
            string gamertag = UnknownGamerTag;
            uint[] privileges = null;
            byte parentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
            uint tier = 0;
            DateTime lastActivity;
            bool isLightAcct;
            bool isProvisioned;
            byte accountType;
            bool isFreeGamertagChangeEligible;
            bool isParentallyControlled;

            IXCacheDataAccess xda = Container.Instance.GetComponent<IXCacheDataAccess>();

            if(xda.LookupWebID(puid, out livePuid, out gamertag))
            {
                IAccountCreationDataAccess acda = Container.Instance.GetComponent<IAccountCreationDataAccess>();

                acda.GetUserWebInfo(livePuid, ServiceTypeEnum.XboxLive, out tier, out privileges, out lastActivity, out parentalControlGroup, out isLightAcct, out isProvisioned, out accountType, out isFreeGamertagChangeEligible, out isParentallyControlled);

                ticket = new WebTicket(gamertag, livePuid, puid, (byte)tier, privileges, parentalControlGroup);

                ticket.SaveToCookie();
                WebTicket.Current = ticket;
            }

            return ticket;
        }

        private bool IsUnknownGamertag(string gamertag)
        {
            return String.IsNullOrEmpty(gamertag) || (gamertag.Length > 0 && gamertag[0] == '?');
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\AwardedAvatarAsset.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// Info about Awarded Avatar Asset
    /// </summary>
    public struct AwardedAvatarAsset
    {
        public byte[] AvatarAssetId;
        public uint AvatarAssetOrdinal;
        public DateTime Awarded;
        public uint BodyComponent;
        public byte BodyTypeMask;
        public string Description;
        public byte DescriptionLen;
        public int Flags;
        public string HowTo;
        public uint ImageId;
        public uint Sequence;
        public uint SubCategory;
        public string Title;
        public bool IsUnisexItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\AccountCreationDataAccess.cs ===
﻿
namespace Leet.Live.Livecache.DataAccess
{
    using System;
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.Account;
    using xonline.common.protocol;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;

    public class AccountCreationDataAccess : IAccountCreationDataAccess
    {
        private ILcAccountCreation _lcAccountCreation;

        public AccountCreationDataAccess(ILcAccountCreation lcAccountCreation)
        {
            _lcAccountCreation = lcAccountCreation;
        }

        public void GetUserWebInfo(
            ulong livePuid,
            ServiceTypeEnum liveServiceType,
            out uint tier,
            out uint[] privileges,
            out DateTime lastWebActivity,
            out byte parentalControlGroup,
            out bool isLightAccount,
            out bool isProvisioned,
            out byte accountType,
            out bool isFreeGamertagChangeEligible,
            out bool isParentallyControlled)
        {
            isProvisioned = false;

            XeGetUserWebInfoRequest req = new XeGetUserWebInfoRequest();
            req.userPuid = livePuid;
            req.serviceType = (uint)liveServiceType;

            XeGetUserWebInfoResponse reply = null;
            try
            {
                reply = _lcAccountCreation.GetUserWebInfo(req);
                isProvisioned = true;
            }
            catch (ServiceNotProvisionedException)
            {
                req.serviceType = (uint)ServiceTypeEnum.Unknown;
                reply = _lcAccountCreation.GetUserWebInfo(req);
            }

            tier = reply.tier;
            lastWebActivity = reply.lastWebActivity.ToFileTimeUtc() == 0 ? DateTime.MinValue : reply.lastWebActivity;
            privileges = reply.userPrivileges;
            parentalControlGroup = (byte)reply.parentalControlGroupId;
            isLightAccount = reply.isLightweight;
            isFreeGamertagChangeEligible = reply.isFreeGamertagChangeEligible;
            isParentallyControlled = reply.isParentallyControlled;

            // Leaving this line out for now -- when it is needed it should be a new out parameter
            accountType = reply.userType;
        }

        public Account GetAccount(ulong xuid)
        {
            XeGetUserWebInfoRequest webInfoRequest = new XeGetUserWebInfoRequest
            {
                userPuid = xuid,
                serviceType = (uint)ServiceTypeEnum.Unknown
            };

            XeGetUserWebInfoResponse webInfoResponse = _lcAccountCreation.GetUserWebInfo(webInfoRequest);

            XeGetAccountInfoRequest accountInfoRequest = new XeGetAccountInfoRequest { userPuid = xuid, machinePuid = 0 };

            XeGetAccountInfoResponse accountInfoResponse = _lcAccountCreation.GetAccountInfo(accountInfoRequest);

            return new Account
            {
                Xuid = xuid,
                Tier = GetSubscriptionTier(webInfoResponse.tier),
                FirstName = accountInfoResponse.firstName,
                LastName = accountInfoResponse.lastName,
                DateOfBirth = accountInfoResponse.birthdate,
                Email = accountInfoResponse.email,
                MicrosoftOptIn = accountInfoResponse.msftOptIn == 1,
                PartnerOptIn = accountInfoResponse.partnerOptIn == 1,
                Phone = accountInfoResponse.phoneInfo.phonePrefix + accountInfoResponse.phoneInfo.phoneNumber,
                Street1 = accountInfoResponse.addressInfo.street1,
                Street2 = accountInfoResponse.addressInfo.street2,
                City = accountInfoResponse.addressInfo.city,
                StateCode = accountInfoResponse.addressInfo.state,
                PostalCode = accountInfoResponse.addressInfo.postalCode,
                CountryId = accountInfoResponse.countryId,
                LanguageId = accountInfoResponse.languageId
            };
        }


        internal static SubscriptionTier GetSubscriptionTier(uint tierId)
        {
            SubscriptionTier tier = SubscriptionTier.None;
            switch (tierId)
            {
                case XOn.XONLINE_TIER_NEWUSER:
                    tier = SubscriptionTier.None;
                    break;
                case XOn.XONLINE_TIER_SILVER:
                    tier = SubscriptionTier.Silver;
                    break;
                case XOn.XONLINE_TIER_GOLD:
                    tier = SubscriptionTier.Gold;
                    break;
                case XOn.XONLINE_TIER_FAMILY_GOLD:
                    tier = SubscriptionTier.Family;
                    break;
            }
            return tier;
        }

        /// <summary>
        /// Used to update privacy/privilege bits for a user profile
        /// </summary>
        /// <param name="livePuid"></param>
        /// <param name="grantPrivileges"></param>
        /// <param name="restrictPrivileges"></param>
        /// <param name="source"></param>
        public void UpdateParentalControls(ulong livePuid, uint[] grantPrivileges, uint[] restrictPrivileges, string source)
        {
            UpdateParentalControlsRequest updateRequest = new UpdateParentalControlsRequest();
            updateRequest.userGrantPrivileges = grantPrivileges;
            updateRequest.userPuid = livePuid;
            updateRequest.userRestrictPrivileges = restrictPrivileges;
            updateRequest.source = source;

            IAccountAuthDataProvider authProvider = Container.Instance.GetComponent<IAccountAuthDataProvider>();
            ILocalLivecacheContext localContext = Container.Instance.GetComponent<ILocalLivecacheContext>();

            _lcAccountCreation.UpdateParentalControls(updateRequest, localContext, authProvider);
        }

        /// <summary>
        /// Reserves the gamer tag
        /// </summary>
        /// <param name="machinePuid"></param>
        /// <param name="countryID"></param>
        /// <param name="gamerTag"></param>
        /// <returns>null if gamertag is reserved. ReserveNameSuggestedName[] is returned if gamertag already exists</returns>
        public ReserveNameSuggestedName[] ReserveGamerTag(ulong machinePuid, int countryID, string gamerTag)
        {
            const int MAX_SUGGESTIONS = 5;

            ReserveNameRequest reqRN = new ReserveNameRequest();
            reqRN.gamertag = gamerTag;
            reqRN.gamertagLength = (ushort)gamerTag.Length;
            reqRN.machinePuid = machinePuid;
            reqRN.maxSuggestedNames = MAX_SUGGESTIONS;
            reqRN.countryId = Convert.ToByte(countryID);

            return _lcAccountCreation.ReserveGamerTag(reqRN);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Account\WebTicket.cs ===
﻿using System;
using System.Text;
using System.Web;
using Leet.Live.Livecache.Logic;
using Leet.Live.Livecache.Logic.Exceptions;
using xonline.common.service;
using xonline.common.webplatform.livecache;
using Leet.Core.IoCCo;

namespace Leet.Live.Livecache.Account
{
    public class WebTicket : SignedWireData
    {
        private static IContextItemProvider _currentContext = Container.Instance.GetComponent<IContextItemProvider>();

        public const string WebTicketName = "XBLTkt";

        [WireInfo(ArraySize = 15)]
        public string Gamertag;

        [WireInfo(ArraySize = LivePrivilegeSet.DWordCount)]
        public uint[] Privileges;

        public ulong LivePuid;
        public ulong PassportPuid;
        public byte Tier;
        public byte ParentalControlGroup;

        public DateTime IssuedOn;

        private WebTicket()
        {
        }

        public WebTicket(string gamertag,
            ulong livePuid,
            ulong passportPuid,
            byte tier,
            uint[] privileges,
            byte parentalControlGroup)
        {
            this.LivePuid = livePuid;
            this.Gamertag = gamertag;
            this.PassportPuid = passportPuid;
            this.Privileges = privileges;
            this.Tier = tier;
            this.IssuedOn = DateTime.Now;
            this.ParentalControlGroup = parentalControlGroup;
        }

        public static WebTicket Current
        {
            get
            {
                
                WebTicket ticket = _currentContext["WebTicket"] as WebTicket;
                if (ticket == null)
                {
                    ticket = new WebTicket();
                    try
                    {
                        if (HttpContext.Current != null && ticket.FromRequest(HttpContext.Current.Request))
                        {
                            _currentContext["WebTicket"] = ticket;
                        }
                        else
                        {
                            ticket = null;
                        }
                    }
                    catch (ArgumentOutOfRangeException)
                    {
                        ticket = null;
                    }
                    catch (SignedDataInvalidException)
                    {
                        ticket = null;
                    }
                }

                return ticket;
            }

            set
            {
                _currentContext["WebTicket"] = value;
            }
        }

        public void SaveToCookie()
        {
            if (HttpContext.Current != null)
            {
                HttpContext.Current.Response.Cookies.Add(this.ToCookie());
            }
        }

        public bool FromRequest(HttpRequest request)
        {
            if (request == null) return false;
            return FromCookie(request.Cookies[WebTicketName]);
        }

        public bool FromCookie(HttpCookie c)
        {
            if (c == null) return false;
            return FromCookieString(c.Value);
        }

        public HttpCookie ToCookie()
        {
            HttpCookie c = new HttpCookie(WebTicketName, ToCookieString());
            c.HttpOnly = true;
            return c;
        }

        public bool FromCookieString(string hexstr)
        {
            if (string.IsNullOrEmpty(hexstr)) return false;

            byte[] blob = Convert.FromBase64String(DecompressA(hexstr));
            return base.FromBytes(blob);
        }

        public string ToCookieString()
        {
            byte[] blob = base.ToBytes();
            return CompressA(Convert.ToBase64String(blob));
        }

        public static void ClearCookie(HttpContext ctx)
        {
            if (ctx == null) return;

            HttpCookie c = new HttpCookie(WebTicketName);
            c.HttpOnly = true;
            c.Value = "";
            c.Expires = DateTime.Now.AddMonths(-25);
            ctx.Response.Cookies.Add(c);
        }

        private string CompressA(string base64str)
        {
            StringBuilder sb = new StringBuilder(base64str.Length);
            for (int i = 0; i < base64str.Length; i++)
            {
                char c = base64str[i];
                if (c == 'A')
                {
                    int i0 = i++;
                    for (; i < base64str.Length && i < i0 + 26 + 26; i++)
                    {
                        if (base64str[i] != 'A')
                        {
                            break;
                        }
                    }

                    if (i - i0 > 1)
                    {
                        sb.Append('$');
                        int cnt = i - i0;
                        if (cnt > 26)
                        {
                            c = (char)('a' + cnt - 27);
                        }
                        else
                        {
                            c = (char)('A' + cnt - 1);
                        }
                    }

                    i--; // it's pointing to the 'next' char, compensate for loop increment
                }

                sb.Append(c);
            }
            return sb.ToString();
        }

        private const int MaxTicketStringLength = 512;

        private string DecompressA(string str)
        {
            StringBuilder sb = new StringBuilder(MaxTicketStringLength);
            for (int i = 0; i < str.Length; )
            {
                char c = str[i++];
                if (c == '$')
                {
                    c = str[i++];
                    if ('a' <= c && c <= 'z')
                    {
                        sb.Append('A', 27 + c - 'a');
                    }
                    else if ('A' <= c && c <= 'Z')
                    {
                        sb.Append('A', 1 + c - 'A');
                    }
                }
                else
                {
                    sb.Append(c);
                }

                if (sb.Length >= MaxTicketStringLength)
                {
                    throw new ArgumentException("str", "decompressed string over limit");
                }
            }

            // Validate against a valid base64 string length (must be a multiple of 4)
            if (sb.Length % 4 != 0)
            {
                throw new ArgumentException("str", "decompressed string is an invalid length");
            }
            return sb.ToString();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\BillingOfferingDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Xml;
using System.Linq;
using System.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache.Providers;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Logic.Exceptions;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// Implements methods to access the Live Cache Billing Service
    /// </summary>
    public class BillingOfferingDataAccess : IBillingOfferingDataAccess
    {
        ILogging logger;

        private ILcBillingOffering _lcBillingOffering;
        
        /// <summary>
        /// ctor
        /// </summary>
        ///<param name="lcBillingOffering">ILcBillingOffering</param>
        public BillingOfferingDataAccess(ILcBillingOffering lcBillingOffering)
        {
            if (lcBillingOffering == null)
            {
                throw new ArgumentNullException("lcBillingOffering", "lcBillingOffering cannot be null");
            }

            _lcBillingOffering = lcBillingOffering;
            this.logger = Container.Instance.GetComponent<ILogging>();
        }

        /// <summary>
        /// Gets the purchase history for the xbox live user
        /// </summary>
        /// <param name="request">PurchaseHistoryRequest</param>
        /// <returns>PurchaseHistoryResponse</returns>
        public PurchaseHistoryResponse GetPurchaseHistory(PurchaseHistoryRequest purchaseHistoryRequest)
        {
            if (purchaseHistoryRequest == null)
            {
                throw new ArgumentNullException("purchaseHistoryRequest", "request cannot be null");
            }

            if (String.IsNullOrEmpty(purchaseHistoryRequest.Locale))
            {
                throw new ArgumentException("purchaseHistoryRequest", "PurchaseHistoryRequest.Locale cannot be null or empty");
            }

            if (purchaseHistoryRequest.LivePuid <= 0)
            {
                throw new ArgumentException("purchaseHistoryRequest", "PurchaseHistoryRequest.LivePuid must be greater than 0");
            }

            Debug.Assert(this._lcBillingOffering != null, "_lcBillingOffering");

            LivecacheWebSvcRequest liveCacheRequest = purchaseHistoryRequest.CreateLiveCacheRequest();
            Debug.Assert(liveCacheRequest != null, "LiveCacheRequest");
            
            LiveCacheWebSvcResponse response = null;

            try
            {
                response = _lcBillingOffering.PurchaseHistory(purchaseHistoryRequest.LivePuid, liveCacheRequest);
            }
            catch (LivecacheUserThrottledException tex)
            {
                throw new LeetLivecacheThrottledException(tex);
            }
            catch (LivecacheConfigException configEx)
            {
                throw new LeetLivecacheConfigException(configEx);
            }
            catch (LivecacheResponseException rEx)
            {
                throw new LeetLivecacheResponseException(rEx);
            }

            if (response == null || String.IsNullOrEmpty(response.response))
            {
                return null;
            }

            Int32 totalItems = 0;
            List<PurchaseHistoryEntry> purchaseHistoryEntryList = PurchaseHistoryEntry.GetEntriesFromXml(response.response, out totalItems);
            return new PurchaseHistoryResponse()
            {
                TotalItems = (UInt32)totalItems,
                PurchaseHistoryEntries = new ReadOnlyCollection<PurchaseHistoryEntry>(purchaseHistoryEntryList)
            };
        }

        public uint GetPointsBalance(ulong xuid)
        {
            var getptsReq = new XeGetPointsBalanceRequest
            {
                machinePuid = xuid,
                userPuid = xuid
            };

            return _lcBillingOffering.GetPointsBalance(getptsReq).pointsBalance;
        }

        public ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request)
        {
            return _lcBillingOffering.EnumerateContent(request);
        }

        public uint PurchaseGamertag(XeOfferPurchaseGamertagRequest purchaseReq)
        {
            IAccountAuthDataProvider authDataProvider = Container.Instance.GetComponent<IAccountAuthDataProvider>();

            // cast _lcBillingOffering to a object for now because PurchaseGamerTag is not exposed in the webplatform interface. Need to update this once the webplateform interface gets updated.
            LcBillingOffering billing = _lcBillingOffering as LcBillingOffering;
            if (null != billing)
            {
                return billing.PurchaseGamerTag(purchaseReq, authDataProvider);
            }

            throw new InvalidOperationException();
        }

        public uint PurchaseMediaOfferWithPoints(ulong xuid, Guid offerId, uint points, int mediaTypeId, uint storeId, Guid transactionId)
        {
            var request = new PurchaseMediaOffersRequest
            {
                offers = new[]
                {
                    new OfferMediaTypeExpectedPrice
                    {
                        expectedPriceWhole = points,
                        offerId = offerId,
                        mediaTypeId = mediaTypeId
                    }
                },
                paymentType = (uint)PaymentTypeEnum.Points,
                storeId = storeId,
                userPuid = xuid,
                trackingGuid = transactionId,
                subscriptionPurchaseInfo = new SubscriptionPurchaseInfo()
            };

            return PurchaseMediaOffers(request);
        }

        public uint PurchaseMediaOfferWithToken(ulong xuid, Guid offerId, uint points, int mediaTypeId, uint storeId, string token, Guid transactionId)
        {
            var request = new PurchaseMediaOffersRequest
            {
                offers = new[]
                {
                    new OfferMediaTypeExpectedPrice
                    {
                        expectedPriceWhole = points,
                        offerId = offerId,
                        mediaTypeId = mediaTypeId
                    }
                },
                paymentType = (uint)PaymentTypeEnum.Token,
                storeId = storeId,
                userPuid = xuid,
                billingToken = token,
                trackingGuid = transactionId,
                subscriptionPurchaseInfo = new SubscriptionPurchaseInfo()
            };

            return PurchaseMediaOffers(request);
        }

        public MediaInstanceUrl[] GetMediaInstanceUrls(Guid[] mediaInstanceIds)
        {
            if ((mediaInstanceIds == null) || (mediaInstanceIds.Length == 0))
            {
                return null;
            }

            FindMediaInstanceUrlsRequest request = new FindMediaInstanceUrlsRequest();
            request.mediaInstanceIds = mediaInstanceIds;
            request.mediaInstanceIdCount = (uint)mediaInstanceIds.Length;
            FindMediaInstanceUrlsResponse response = _lcBillingOffering.FindMediaInstanceUrls(request);

            return response.mediaInstanceUrls;
        }

        /// <summary>
        /// Gets the media offer information associated with the given token.
        /// </summary>
        /// <param name="livePuid">the XUID of the caller.</param>
        /// <param name="token">the 5x5 token string.</param>
        /// <param name="storeId">the store Id the token was issued for.</param>
        /// <param name="offerCatalogType">the type of the offer behind the token (Xbox or EMS).</param>
        /// <param name="emsOfferId">The EMS offer Id.</param>
        /// <param name="mediaId">The EMS media Id.</param>
        /// <param name="mediaType">The EMS media type.</param>
        /// <param name="xboxOfferId">The legacy Xbox offer Id.</param>
        /// <param name="xboxOfferType">The legacy Xboc offer type.</param>
        public uint VerifyToken(ulong livePuid, string token, uint storeId, out ushort offerCatalogType, out Guid emsOfferId, out Guid mediaId, out uint mediaType, out ulong xboxOfferId, out uint xboxOfferType)
        {
            XeVerifyTokenRequest request = new XeVerifyTokenRequest();
            request.userPuid = livePuid;
            request.machinePuid = livePuid;
            request.billingToken = token;
            request.storeId = storeId;

            XeVerifyTokenResponse response;
            uint hr = _lcBillingOffering.VerifyToken(request, out response);
            if (HResult.Succeeded(hr))
            {
                offerCatalogType = response.offerCatalogType;
                if (response.offerCatalogType == (ushort)OfferCatalogTypeEnum.Ems)
                {
                    emsOfferId = response.emsOfferInfo.offerId;
                    mediaId = response.emsOfferInfo.mediaId;
                    mediaType = response.emsOfferInfo.mediaType;

                    xboxOfferId = 0;
                    xboxOfferType = 0;
                }
                else
                {
                    emsOfferId = Guid.Empty;
                    mediaId = Guid.Empty;
                    mediaType = 0;

                    xboxOfferId = response.xboxOfferInfo.offerId;
                    xboxOfferType = response.xboxOfferInfo.offerTypeId;
                }
            }
            else
            {
                offerCatalogType = (ushort)OfferCatalogTypeEnum.Unknown;
                emsOfferId = Guid.Empty;
                mediaId = Guid.Empty;
                mediaType = 0;

                xboxOfferId = 0;
                xboxOfferType = 0;
            }

            return hr;
        }

        /// <summary>
        /// Consumes the input array of assets for the title, tracked by the specified Guid.
        /// </summary>
        /// <param name="livePuid">the XUID of the caller.</param>
        /// <param name="titleId">the title Id that the assets belongs to.</param>
        /// <param name="transactionId">the transaction id that tracks the consumption.</param>
        /// <param name="assetsToConsume">assets to consume.</param>
        public void AssetConsume(ulong livePuid, uint titleId, Guid transactionId, Asset[] assetsToConsume)
        {
            AssetConsumeRequest request = new AssetConsumeRequest();
            request.userPuid = livePuid;
            request.machinePuid = livePuid;
            request.titleID = titleId;
            request.trackingGuid = transactionId;
            request.assets = assetsToConsume;
            request.cAssets = (uint)assetsToConsume.Length;
            request.SchemaVersion = WireData.MakeSchemaVersion(6, 9);

            LcBillingOffering perTitleBillingOffering = new LcBillingOffering(
                LivecacheClientType.LIVEn,
                titleId,
                Container.Instance.GetComponent<IAccountAuthDataProvider>(),
                false);

            perTitleBillingOffering.AssetConsume(livePuid, request);
        }

        private uint PurchaseMediaOffers(PurchaseMediaOffersRequest request)
        {
            return _lcBillingOffering.PurchaseMediaOffers(request);
        }

        /// <summary>
        /// Call livecache to enumerate assets for a user and a titleid. 
        /// </summary>
        ///<param name="request">If EnumerateRequest.MaxResults is zero the the value will default to ushort.Max</param>
        /// <returns></returns>
        public EnumerateAssetsResponse EnumerateAssets(EnumerateAssetsRequest request)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }
            

            IAccountAuthDataProvider authDataProvider = Container.Instance.GetComponent<IAccountAuthDataProvider>();
            //ILivecacheClientIdentifierProvider clientIdentifierProvider = Container.Instance.GetComponent<ILivecacheClientIdentifierProvider>();
            
            LcBillingOffering billingOffetingInternal = new LcBillingOffering(LivecacheClientType.LIVEn, request.TitleId, authDataProvider, false); 

            var liveCacheRequest = new AssetEnumerateRequest
            {
                titleID = request.TitleId,
                userPuid = request.Xuid,
                signAssets = false,
                maxResults = (request.MaxResults == 0) ? ushort.MaxValue : (ushort)request.MaxResults
            };

            try
            {

                AssetEnumerateResponse liveCacheResponse
                    = billingOffetingInternal.AssetEnumerate(request.Xuid, liveCacheRequest);

                IEnumerable<EnumerateAssetsResponse.Asset> assets = from asset in liveCacheResponse.package.assets
                                                                    select (new EnumerateAssetsResponse.Asset
                                                                    {
                                                                        AssetId = asset.assetID,
                                                                        Quantity = asset.quantity
                                                                    });
                return new EnumerateAssetsResponse
                {
                    Assets = new List<EnumerateAssetsResponse.Asset>(assets),
                    TitleId = request.TitleId
                };
            }
            catch (LivecacheUserThrottledException tex)
            {
                throw new LeetLivecacheThrottledException(tex);
            }
            catch (LivecacheConfigException configEx)
            {
                throw new LeetLivecacheConfigException(configEx);
            }
            catch (LivecacheResponseException rEx)
            {
                throw new LeetLivecacheResponseException(rEx);
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\EnumerateAssetsResponse.cs ===
﻿using System;
using System.Collections.Generic;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// EnumerateAssetsResponse
    /// </summary>
    public class EnumerateAssetsResponse
    {
        /// <summary>
        /// Asset
        /// </summary>
        public class Asset
        {
            public UInt32 AssetId { get; set; }
            public Int32 Quantity { get; set; }
        }

        public UInt32 TitleId { get; set; }

        public IList<Asset> Assets
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IAccountCreationDataAccess.cs ===
﻿using System;
using xonline.common.protocol;

namespace Leet.Live.Livecache.DataAccess
{
    public interface IAccountCreationDataAccess
    {
        void GetUserWebInfo(
            ulong livePuid,
            ServiceTypeEnum liveServiceType,
            out uint tier,
            out uint[] privileges,
            out DateTime lastWebActivity,
            out byte parentalControlGroup,
            out bool isLightAccount,
            out bool isProvisioned,
            out byte accountType,
            out bool isFreeGamertagChangeEligible,
            out bool isParentallyControlled);

        ReserveNameSuggestedName[] ReserveGamerTag(ulong machinePuid, int countryID, string gamerTag);

        void UpdateParentalControls(ulong livePuid, uint[] grantPrivileges, uint[] restrictPrivileges, string source);

        Account.Account GetAccount(ulong livePuid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IAvatarStorageAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;

namespace Leet.Live.Livecache.DataAccess
{
    public interface IAvatarStorageAccess
    {
        void StorageWrite(ulong userId, string pictureName, byte[] data);
        bool StorageValidate(ulong readerPuid, string pictureName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IBillingOfferingDataAccess.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections.ObjectModel;
using System.Xml;
using Leet.Live.Livecache.Providers;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// Interface to access Live Cache Billing Service
    /// </summary>
    public interface IBillingOfferingDataAccess
    {

        /// <summary>
        /// Gets the purchase history for the user represented by the request
        /// </summary>
        /// <param name="request">PurchaseHistoryRequest</param>
        /// <returns>PurchaseHistoryResponse</returns>
       PurchaseHistoryResponse GetPurchaseHistory(PurchaseHistoryRequest request);

        /// <summary>
        /// Gets the user's points balance.
        /// </summary>
        /// <param name="livePuid">live puid of the user</param>
        /// <returns>The ammount of points the user has</returns>
        uint GetPointsBalance(ulong livePuid);

        /// <summary>
        /// Returns the available offers.
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request);

        /// <summary>
        /// Returns 0 if the purchase successful, hresult error code if fails.
        /// </summary>
        /// <param name="purchaseReq"></param>
        /// <returns></returns>
        uint PurchaseGamertag(XeOfferPurchaseGamertagRequest purchaseReq);

        /// <summary>
        /// Purchase media offer with Microsoft Points.
        /// </summary>
        /// <param name="xuid">XUID of the user.</param>
        /// <param name="offerId">The offer to purchase.</param>
        /// <param name="points">The points price of the offer.</param>
        /// <param name="mediaTypeId">The media type of the offer.</param>
        /// <param name="storeId">The store the offer resides.</param>
        /// <param name="transactionId">the transaction id that tracks the request.</param>
        /// <returns></returns>
        uint PurchaseMediaOfferWithPoints(ulong xuid, Guid offerId, uint points, int mediaTypeId, uint storeId, Guid transactionId);

        /// <summary>
        /// Purchase media offer with 5x5 token.
        /// </summary>
        /// <param name="xuid">XUID of the user.</param>
        /// <param name="offerId">The offer to purchase.</param>
        /// <param name="points">The points price of the offer.</param>
        /// <param name="mediaTypeId">The media type of the offer.</param>
        /// <param name="storeId">The store the offer resides.</param>
        /// <param name="token">The 5x5 token string.</param>
        /// <param name="transactionId">the transaction id that tracks the request.</param>
        /// <returns></returns>
        uint PurchaseMediaOfferWithToken(ulong xuid, Guid offerId, uint points, int mediaTypeId, uint storeId, string token, Guid transactionId);

        /// <summary>
        /// Get the URLs to the media instances.
        /// </summary>
        /// <param name="mediaInstanceId">Media instance Ids.</param>
        /// <returns>The URLs to the media instances.</returns>
        MediaInstanceUrl[] GetMediaInstanceUrls(Guid[] mediaInstanceId);

        /// <summary>
        /// Gets the media offer information associated with the given token.
        /// </summary>
        /// <param name="livePuid">the XUID of the caller.</param>
        /// <param name="token">the 5x5 token string.</param>
        /// <param name="storeId">the store Id the token was issued for.</param>
        /// <param name="offerCatalogType">the type of the offer behind the token (Xbox or EMS).</param>
        /// <param name="emsOfferId">The EMS offer Id.</param>
        /// <param name="mediaId">The EMS media Id.</param>
        /// <param name="mediaType">The EMS media type.</param>
        /// <param name="xboxOfferId">The legacy Xbox offer Id.</param>
        /// <param name="xboxOfferType">The legacy Xboc offer type.</param>
        uint VerifyToken(ulong livePuid, string token, uint storeId, out ushort offerCatalogType, out Guid emsOfferId, out Guid mediaId, out uint mediaType, out ulong xboxOfferId, out uint xboxOfferType);

        /// <summary>
        /// Enumerate Assets for a user and a titleid
        /// </summary>
        ///<param name="request"></param>
        /// <returns></returns>
        EnumerateAssetsResponse EnumerateAssets(EnumerateAssetsRequest request);

        /// <summary>
        /// Consumes the input array of assets for the title, tracked by the specified Guid.
        /// </summary>
        /// <param name="livePuid">the XUID of the caller.</param>
        /// <param name="titleId">the title Id that the assets belongs to.</param>
        /// <param name="transactionId">the transaction id that tracks the consumption.</param>
        /// <param name="assetsToConsume">assets to consume.</param>
        void AssetConsume(ulong livePuid, uint titleId, Guid transactionId, Asset[] assetsToConsume);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\ILcStorageAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess
{
    public interface ILcStorageAdapter
    {
        //public byte[] StorageRead(string path, uint titleID, LivecacheClientType client);
        //public byte[] StorageRead(ulong readerPuid, string path, uint titleID, LivecacheClientType client);
        //public void StorageRemove(string path, LivecacheClientType client);
        //public void StorageRemove(ulong ownerPuid, string path, LivecacheClientType client);
        //public bool StorageValidate(string path, uint titleID, LivecacheClientType client);
        bool StorageValidate(ulong readerPuid, string path, uint titleID, LivecacheClientType client);
        //public void StorageWrite(string path, byte[] data, DateTime expirationDate, byte countryId, LivecacheClientType client);
        void StorageWrite(ulong ownerPuid, string path, byte[] data, DateTime expirationDate, byte countryId, LivecacheClientType client);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\ISettingsDataAccess.cs ===
﻿
namespace Leet.Live.Livecache.DataAccess
{
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using Leet.Live.Livecache.Logic.Profile;
    using xonline.common.protocol;

    // TODO:  Implement methods on this interface as required
    public interface ISettingsDataAccess
    {
        //void LoadSettings(ulong callingLivepuid, IGamerProfile profile, IWebPreferences preferences);
        void LoadSettings(ReadSettingsResponse readResp, IGamerProfile profile, IWebPreferences webPreferences);
        IGamerProfile[] LoadSettings(ReadSettingsResponse readResp);
        void SaveSettings(IGamerProfile profile, IWebPreferences preferences, string locale);
        //ReadSettingsResponse ReadSettings(ulong callingLivepuid, ulong targetLivepuid);
        //ReadSettingsResponse PublicReadSettings(ulong targetLivepuid, out DateTime responseTTL);
        ReadSettingsResponse[] ReadProfileSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings);
        SaveSettingsResponse SyncSettings(ulong callingLivepuid, ProfileSetting[] settings);
        IGamerProfile GetGamerProfile(ulong callingLivepuid, ulong targetLivepuid);
        IGamerProfile GetGamerProfile(string gamertag, ulong callingLivepuid, ulong targetLivepuid);
        IGamerProfile GetPublicGamerProfile(ulong targetLivepuid);
        IGamerProfile GetPublicGamerProfile(string gamertag, ulong targetLivepuid);
        IGamerProfile[] GetGamerProfilesBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag);
        Dictionary<ulong, IGamerProfile> GetGamerProfileCollectionBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag);
        // pass the 0 for titleID if you need assets for all the titles
        ReadOnlyCollection<AwardedAvatarAsset> GetUserAvatarAwards(ulong livePuid, ushort localeId, uint titleID);
        void SaveGamerProfile(IGamerProfile profile, string locale);

        //IWebPreferences GetWebPreferences(ulong callingLivepuid, ulong targetLivepuid);
        //void SaveWebPreferences(IWebPreferences preferences);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IAchievementDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using Leet.Live.Livecache.Logic.Achievements;
using Leet.Live.Livecache.Logic.Games;

namespace Leet.Live.Livecache.DataAccess
{
    public interface IAchievementDataAccess
    {
        List<IReadOnlyUserTitle> GetUserTitles(ulong callingUserPuid, ulong targetUserPuid, ushort localeId, ushort startingIndex, ushort maxTitles);
        List<IReadOnlyUserTitle> GetPublicUserTitles(ulong targetUserPuid, ushort localeId, ushort startingIndex, ushort maxTitles, out DateTime responseTTL);
        List<IReadOnlyAchievementInfo> GetUserAchievements(uint gameTitleId, ulong callingUserPuid, ulong targetUserPuid, ushort localeId);
        void SyncAchievements(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<IReadOnlyAchievementInfo> readOnlyAchievementInfos);
        void SyncTitles(uint gameTitleId, ulong targetUserPuid, ushort localeId, DateTime lastPlayedTime);
        void SyncAvatarAssets(uint gameTitleId, ulong targetUserPuid, ushort localeId, IList<AwardedAvatarAsset> readOnlyAchievementInfos);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IPresenceDataAccess.cs ===
﻿using System;
using Leet.Live.Livecache.Logic.Profile;
using xonline.common.protocol;
using Leet.Live.Livecache.Logic.Messaging;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// TODO:  Complete implementation of this interface
    /// </summary>
    public interface IPresenceDataAccess
    {
        void SendWebAlive(ulong livePuid);
        void SendWebAlive2(ulong livePuid, uint titleId);

        IReadOnlyPresenceInfo GetPresenceInfo(ulong senderLivePuid, ulong targetLivePuid);
        IReadOnlyPresenceInfo GetPublicPresenceInfo(ulong targetLivepuid, out DateTime responseTTL);

        QueryAffiliatesReplyData[] GetQueryAffiliatesReplyData(ulong callingLivepuid, ushort maxCount);

        IReadOnlyFriendInfo[] GetFriendsInfo(ulong callerLivepuid, bool sortAlphabetically, bool includeProfileData);
        IReadOnlyFriendInfo[] GetFriendsOfFriend(ulong sender, ulong target);
        void AddFriend(ulong userPuid, ulong targetPuid);
        void AddFriendFromContact(ulong userPuid, ulong targetPuid);
        void DeleteFriend(ulong userPuid, ulong targetPuid);
        void AcceptFriendRequest(ulong userPuid, ulong targetPuid);
        void RejectFriendRequest(ulong userPuid, ulong targetPuid);

        MessageSummary2[] EnumerateMessages(ulong userPuid);
        MessageSummary2[] EnumerateMessages(ulong userPuid, bool includeWebAlive);
        MessageSummary2 GetMessageSummary(ulong userPuid, uint messageId);
        IReadOnlyMessage GetMessageDetails(ulong userPuid, uint messageId, uint setFlags, uint unsetFlags);
        bool DeleteMessage(ulong userPuid, uint messageId, uint flags);
        bool SetMessageFlags(ulong userPuid, uint messageId, uint setFlags, uint unsetFlags);
        void SendMessage(ulong userPuid, string szSenderName, ulong qwSenderContext, uint dwMessageFlags,
            ushort wExpireMinutes, byte bMessageType, ulong[] rgqwRecipients, MessageDetails details);
        SystemMessageSummary[] EnumerateSystemMessages(ulong userPuid, uint titleId);
        IReadOnlySystemMessage GetSystemMessageDetails(ulong userPuid, uint titleId, uint messageId);

        /// <summary>
        /// Indicates if a user has rights to send a message to the provided list of Xbox LIVE users.
        /// This method returns an in-order array of values that map to the list of XUIDs provided as 
        /// input.
        /// </summary>
        /// <param name="userPuid">Xbox LIVE PUID (XUID) of the user making the request</param>
        /// <param name="targetPuids">Array of Xbox LIVE PUIDs of the users to check</param>
        /// <returns>LivecacheConstants.XONLINE_E_MESSAGE_SENDER_BLOCKED or LivecacheConstants.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES if user does not have permission to send</returns>
        uint[] CanSendMessageToUsers(ulong userPuid, ulong[] targetPuids);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IStsDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.DataAccess
{
    public interface IStsDataAccess
    {
        string GetSecurityTicket(ulong livePuid, ulong passportPuid, uint titleId, ushort titleVersion, string ipAddressInternet, ulong passportCid, DateTime issueInstant, DateTime notAfter);
        string GetPartnerSecurityTicket(ulong livePuid, uint titleId, uint titleVersion, string ipAddressInternet, string userSamlToken, string audience);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IXCacheDataAccess.cs ===
﻿
namespace Leet.Live.Livecache.DataAccess
{
    public interface IXCacheDataAccess
    {
        bool GetGamertagByPuid(ulong livePuid, out string gamertag);
        bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag);
        bool GetPuidByGamerTag(string gamertag, out ulong livePuid);
        bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcAchievementAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Providers;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcAchievementAdapter : LcAchievement
    {
        public LcAchievementAdapter(ILivecacheClientIdentifierProvider identProvider, IAccountAuthDataProvider authDataProvider) : 
            base(identProvider.GetClientType(), identProvider.GetClientTitleId(), authDataProvider)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcStatsAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Providers;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcStatsAdapter : LcStats
    {
        public LcStatsAdapter(ILivecacheClientIdentifierProvider identProvider) :
            base(identProvider.GetClientType(), identProvider.GetClientTitleId()) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\IStringServerDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.DataAccess
{
    public interface IStringServerDataAccess
    {
        string LookupString(uint titleId, uint stringId, ushort liveLanguageId, out DateTime responseTTL);
        bool VetString(string locale, string vetString);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcPresenceAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Providers;
using Leet.Core.IoCCo;

namespace Leet.Live.Livecache.DataAccess
{
    [PerWebRequestInstance]
    public class LcPresenceAdapter : LcPresence
    {
        public LcPresenceAdapter(IWebRequestClientIdentifierProvider identProvider, IContextItemProvider contextProvider, IAccountAuthDataProvider authDataProvider) :
            base(identProvider.GetClientType(), identProvider.GetClientTitleId(), contextProvider, authDataProvider)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcBillingOfferingAdapter.cs ===
﻿using System;
using Leet.Live.Livecache.Providers;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcBillingOfferingAdapter : LcBillingOffering
    {
        public LcBillingOfferingAdapter(IAccountAuthDataProvider authDataProvider, ILivecacheClientIdentifierProvider clientIdentifierProvider)
            : base(clientIdentifierProvider.GetClientType(), clientIdentifierProvider.GetClientTitleId(), authDataProvider, false)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcAccountCreationAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using Leet.Live.Livecache.Providers;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcAccountCreationAdapter : LcAccountCreation
    {
        // TODO:  Get the right setting as the last value (set to false currently)
        public LcAccountCreationAdapter(ILivecacheClientIdentifierProvider clientIdentProvider, IAccountAuthDataProvider authDataProvider) :
            base(clientIdentProvider.GetClientType(), clientIdentProvider.GetClientTitleId(), authDataProvider, false)
        {

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcStsAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Providers;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcStsAdapter : LcSts
    {
        public LcStsAdapter(ILivecacheClientIdentifierProvider identProvider, IAccountAuthDataProvider authDataProvider) :
            base(identProvider.GetClientType(), authDataProvider) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcStringSvrAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Providers;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcStringSvrAdapter : LcStringSvr
    {
        public LcStringSvrAdapter(ILivecacheClientIdentifierProvider identProvider) :
            base(identProvider.GetClientType(), identProvider.GetClientTitleId()) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\LcStorageAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess
{
    public class LcStorageAdapter : LcTitleStorage, ILcStorageAdapter
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\PurchaseHistoryEntry.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Xml;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess
{
    public interface IPurchaseHistoryEntry
    {
        void FromXML(XmlReader reader);
        IList<IMediaInstance> MediaInstances { get; set; }
        Guid OfferId { get; set; }
        IOffer TheOffer { get; set; }
        string Title { get; set; }
        DateTime Updated { get; set; }
    }

    public interface IOffer
    {
        void FromXML(XmlReader reader);
        Guid MediaId { get; set; }
        MediaTypes MediaType { get; set; }
        IList<int> OfferStores { get; set; }
        DateTime PurchaseDate { get; set; }
        Guid TransactionId { get; set; }
        string ShortDescription { get; set; }
        string ShortTitle { get; set; }
    }

    public interface IMediaInstance
    {
        DateTime AwknowledgedDate { get; set; }
        void FromXML(XmlReader reader);
        Guid InstanceId { get; set; }
        bool IsAdSupported { get; set; }
        bool IsAquirable { get; set; }
        bool LicenceAwknowledged { get; set; }
        Guid MediaId { get; set; }
        string OfferLicenseType { get; set; }
    }

    [Serializable]
    public class PurchaseHistoryEntry : IPurchaseHistoryEntry
    {
        // strip off any UID:UUID: or URN:UUID: prefixes
        static Regex guidRegex = new Regex(@"([0-9a-f]{8}\-?[0-9a-f]{4}\-?[0-9a-f]{4}\-?[0-9a-f]{4}\-?[0-9a-f]{12})", RegexOptions.Compiled | RegexOptions.IgnoreCase);

        private Guid _offerId;
        public Guid OfferId
        {
            get { return _offerId; }
            set { _offerId = value; }
        }

        private DateTime _updated;
        public DateTime Updated
        {
            get { return _updated; }
            set { _updated = value; }
        }

        private string _title;
        public string Title
        {
            get { return _title; }
            set { _title = value; }
        }

        private IOffer _theOffer;
        public IOffer TheOffer
        {
            get { return _theOffer; }
            set { _theOffer = value; }
        }

        private IList<IMediaInstance> _mediaInstances = new List<IMediaInstance>();
        public IList<IMediaInstance> MediaInstances
        {
            get { return _mediaInstances; }
            set { _mediaInstances = value; }
        }

        /// <summary>
        /// Reads the purchase history entry from xml.  This assumes the the 
        /// XML reader is currently pointing to the "entry" node.
        /// </summary>
        public void FromXML(XmlReader reader)
        {
            string endNodeName = reader.Name;
            while (reader.Read())
            {
                if (reader.NodeType == XmlNodeType.Element)
                {
                    switch (reader.Name)
                    {
                        case "id":
                            OfferId = PurchaseHistoryEntry.ExtractGuid(reader.ReadElementContentAsString());
                            break;
                        case "updated":
                            Updated = DateTime.Parse(reader.ReadElementContentAsString());
                            break;
                        case "title":
                            Title = reader.ReadElementContentAsString();
                            break;
                        case "live:offer":
                            TheOffer = new Offer();
                            TheOffer.FromXML(reader);
                            break;
                        case "live:mediaInstances":
                            while (reader.Read() && !((reader.NodeType == XmlNodeType.EndElement) &&
                                (reader.Name == "live:mediaInstances")))
                            {
                                if (reader.Name == "live:mediaInstance")
                                {
                                    MediaInstance mediaInstance = new MediaInstance();
                                    mediaInstance.FromXML(reader);
                                    MediaInstances.Add(mediaInstance);
                                }
                            }
                            break;
                    }
                }
                else if ((reader.NodeType == XmlNodeType.EndElement) && (reader.Name == endNodeName))
                    break; // done reading...
            }
        }

        static internal Guid ExtractGuid(string guidString)
        {
            Match m = guidRegex.Match(guidString);
            if (m.Success)
            {
                return new Guid(m.Groups[1].Captures[0].Value);
            }
            return Guid.Empty;
        }

        static public List<PurchaseHistoryEntry> GetEntriesFromXml(string xml, out int totalItems)
        {
            List<PurchaseHistoryEntry> entries = new List<PurchaseHistoryEntry>();
            XmlTextReader reader = new XmlTextReader(new StringReader(xml));

            totalItems = 0;
            while (reader.Read())
            {
                if (reader.Name == "feed")
                {
                    while (reader.Read())
                    {
                        if (reader.Name == "entry")
                        {
                            PurchaseHistoryEntry entry = new PurchaseHistoryEntry();
                            entry.FromXML(reader);
                            entries.Add(entry);
                        }
                        else if (reader.Name == "live:totalItems")
                        {
                            totalItems = reader.ReadElementContentAsInt();
                        }
                    }
                    break;

                }
            }
            return entries;
        }
      
        [Serializable]
        public class Offer : IOffer
        {
            private MediaTypes _mediaType;
            public MediaTypes MediaType
            {
                get { return _mediaType; }
                set { _mediaType = value; }
            }

            private Guid _mediaId;
            public Guid MediaId
            {
                get { return _mediaId; }
                set { _mediaId = value; }
            }

            private string _shortTitle;
            public string ShortTitle
            {
                get { return _shortTitle; }
                set { _shortTitle = value; }
            }

            private string _shortDescription;
            public string ShortDescription
            {
                get { return _shortDescription; }
                set { _shortDescription = value; }
            }

            private DateTime _purchaseDate;
            public DateTime PurchaseDate
            {
                get { return _purchaseDate; }
                set { _purchaseDate = value; }
            }

            private IList<int> _offerStores = new List<int>();
            public IList<int> OfferStores
            {
                get { return _offerStores; }
                set { _offerStores = value; }
            }

            public Guid TransactionId { get; set; }

            public void FromXML(XmlReader reader)
            {
                string endNodeName = reader.Name;
                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {
                        switch (reader.Name)
                        {
                            case "live:transactionId":
                                {
                                    this.TransactionId =
                                        new Guid(reader.ReadElementContentAsString().Replace("urn:uuid:", String.Empty));
                                    break;
                                }
                            case "live:mediaType":
                                MediaType = (MediaTypes)reader.ReadElementContentAsInt();
                                break;
                            case "live:mediaId":
                                MediaId = PurchaseHistoryEntry.ExtractGuid(reader.ReadElementContentAsString());
                                break;
                            case "live:reducedTitle":
                                ShortTitle = reader.ReadElementContentAsString();
                                break;
                            case "live:reducedDescription":
                                ShortDescription = reader.ReadElementContentAsString();
                                break;
                            case "live:purchasedDate":
                                PurchaseDate = DateTime.Parse(reader.ReadElementContentAsString());
                                break;
                            case "live:offerStores":
                                while (reader.Read() && !((reader.NodeType == XmlNodeType.EndElement) &&
                                    (reader.Name == "live:offerStores")))
                                {
                                    if (reader.Name == "live:offerStore")
                                    {
                                        OfferStores.Add(reader.ReadElementContentAsInt());
                                    }
                                }
                                break;
                        }
                    }
                    else if ((reader.NodeType == XmlNodeType.EndElement) && (reader.Name == endNodeName))
                        break; // done reading...
                }
            }
        }
        [Serializable]
        public class MediaInstance : IMediaInstance
        {
            private Guid _instanceId;
            public Guid InstanceId
            {
                get { return _instanceId; }
                set { _instanceId = value; }
            }

            private Guid _mediaId;
            public Guid MediaId
            {
                get { return _mediaId; }
                set { _mediaId = value; }
            }

            private string _offerLicenseType;
            public string OfferLicenseType
            {
                get { return _offerLicenseType; }
                set { _offerLicenseType = value; }
            }

            private bool _licenceAwknowledged;
            public bool LicenceAwknowledged
            {
                get { return _licenceAwknowledged; }
                set { _licenceAwknowledged = value; }
            }

            private DateTime _awknowledgedDate;
            public DateTime AwknowledgedDate
            {
                get { return _awknowledgedDate; }
                set { _awknowledgedDate = value; }
            }

            private bool _isAquirable;
            public bool IsAquirable
            {
                get { return _isAquirable; }
                set { _isAquirable = value; }
            }

            private bool _isAdSupported;
            public bool IsAdSupported
            {
                get { return _isAdSupported; }
                set { _isAdSupported = value; }
            }

            public void FromXML(XmlReader reader)
            {
                string endNodeName = reader.Name;
                while (reader.Read())
                {
                    if (reader.NodeType == XmlNodeType.Element)
                    {
                        switch (reader.Name)
                        {
                            case "live:instanceId":
                                InstanceId = PurchaseHistoryEntry.ExtractGuid(reader.ReadElementContentAsString());
                                break;
                            case "live:mediaId":
                                MediaId = PurchaseHistoryEntry.ExtractGuid(reader.ReadElementContentAsString());
                                break;
                            case "live:offerLicenseType":
                                OfferLicenseType = reader.ReadElementContentAsString();
                                break;
                            case "live:licenseAcknowledged":
                                LicenceAwknowledged = reader.ReadElementContentAsBoolean();
                                break;
                            case "live:isAcquirable":
                                IsAquirable = reader.ReadElementContentAsBoolean();
                                break;
                            case "live:isAdSupported":
                                IsAdSupported = reader.ReadElementContentAsBoolean();
                                break;
                        }
                    }
                    else if ((reader.NodeType == XmlNodeType.EndElement) && (reader.Name == endNodeName))
                        break; // done reading...
                }
            }
        }
  
     
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\PurchaseHistoryRequest.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Xml;
using xonline.common.protocol;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// Models a purchase history request
    /// </summary>
    public sealed class PurchaseHistoryRequest
    {
        private List<Guid> trandactionIds = new List<Guid>();
        
        /// <summary>
        /// This is false by default. Set this to true if you want to use Livecache purchase history v1 call flow
        /// </summary>
        public bool UsePurchaseHistoryV1
        {
            get;
            set;
        }

        public enum OrderHistoryBy
        {
            DateOfTransaction = 0,
        }

        public enum OrderDirection
        {
            Ascending = 1,
            Descending
        }

        public enum DetailView
        {
            Starter = 1,
            Home,
            Premium,
            Enterprise,
            Ultimate
        }

        public enum MarketplaceStore
        {
            Xbox = 1,
            Zune = 2,
            GamesForWindows = 3,
            Zest = 4,
            Mobile = 5,
        }


        #region Static Methods

        /// <summary>
        /// Helper method that creates a purchase history request based on input parameters
        /// </summary>
        /// <param name="livePuid"></param>
        /// <param name="locale"></param>
        /// <param name="titleID"></param>
        /// <param name="mediaType"></param>
        /// <param name="startDate"></param>
        /// <param name="transactionId"></param>
        /// <param name="storeId"></param>
        /// <param name="pageNum"></param>
        /// <param name="pageSize"></param>
        /// <returns></returns>
        public static PurchaseHistoryRequest CreatePurchaseHistoryRequest(UInt64 livePuid, String locale,
         UInt32 titleID, MediaTypes mediaType,
         DateTime startDate, Guid transactionId, uint storeId,
         UInt32 pageNum, UInt32 pageSize, OrderDirection orderByDirection)
        {
            var purchaseHistoryRequest = new PurchaseHistoryRequest
            {
                TitleId = titleID,
                LivePuid = livePuid,
                Locale = locale,
                PageSize = pageSize,
                PageNum = pageNum,
                StartDate = startDate,
                Store = (MarketplaceStore)storeId,
                View = DetailView.Ultimate,
                MediaType = mediaType,
                OrderBy = OrderHistoryBy.DateOfTransaction,
                Direction = orderByDirection
            };

            purchaseHistoryRequest.TransactionIDs.Add(transactionId);

            return purchaseHistoryRequest;
        }

        /// <summary>
        /// Helper method that creates a purchase history request based on input parameters
        /// </summary>
        /// <param name="livePuid"></param>
        /// <param name="locale"></param>
        /// <param name="titleID"></param>
        /// <param name="mediaType"></param>
        /// <param name="startDate"></param>
        /// <param name="transactionIds"></param>
        /// <param name="pageNum"></param>
        /// <param name="pageSize"></param>
        /// <returns></returns>
        public static PurchaseHistoryRequest CreatePurchaseHistoryRequest(UInt64 livePuid, String locale,
         UInt32 titleID, MediaTypes mediaType,
         DateTime startDate, ICollection<Guid> transactionIds,
         UInt32 pageNum, UInt32 pageSize, OrderDirection orderByDirection)
        {
            var purchaseHistoryRequest = new PurchaseHistoryRequest
            {
                TitleId = titleID,
                LivePuid = livePuid,
                Locale = locale,
                PageSize = pageSize,
                PageNum = pageNum,
                StartDate = startDate,
                Store = MarketplaceStore.Xbox,
                View = DetailView.Ultimate,
                MediaType = mediaType,
                OrderBy = OrderHistoryBy.DateOfTransaction,
                Direction = orderByDirection
            };

            purchaseHistoryRequest.TransactionIDs.AddRange(transactionIds);

            return purchaseHistoryRequest;
        }
        

        /// <summary>
        /// Helper method that creates a purchase history request specific to users avatar assets
        /// Uses Livecache purchase history v1 flow 
        /// </summary>
        /// <param name="livePuid"></param>
        /// <param name="locale"></param>
        /// <returns></returns>
        public static PurchaseHistoryRequest CreateAvatarGearPurchaseHistoryRequest(UInt64 livePuid, String locale)
        {
            var purchaseHistoryRequest = new PurchaseHistoryRequest
            {
                UsePurchaseHistoryV1 = true,
                LivePuid = livePuid,
                Locale = locale,
                PageSize = 1000,
                PageNum = 1,
                Store = MarketplaceStore.Xbox,
                View = DetailView.Ultimate,
                MediaType = MediaTypes.AvatarGear,
                OrderBy = OrderHistoryBy.DateOfTransaction,
                Direction = OrderDirection.Ascending
            };

            return purchaseHistoryRequest;
        }

        #endregion

        #region Proeprties
        /// <summary>
        /// TitleId
        /// </summary>
        public UInt32 TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// Transaction Ids
        /// </summary>
        public List<Guid> TransactionIDs { get { return this.trandactionIds; } }

        /// <summary>
        /// LivePuid
        /// </summary>
        public UInt64 LivePuid
        {
            get;
            set;
        }

     

        /// <summary>
        /// Locale. This is the locale associated with the user
        /// </summary>
        public String Locale
        {
            get;
            set;
        }


        /// <summary>
        /// Purchase date filter.
        /// </summary>
        public DateTime StartDate
        {
            get;
            set;
        }

        /// <summary>
        /// Max number of purchase history entries per page
        /// </summary>
        public UInt32 PageSize
        {
            get;
            set;
        }

        /// <summary>
        /// Page number
        /// </summary>
        public UInt32 PageNum
        {
            get;
            set;
        }

        /// <summary>
        /// Defines the MarketplaceStore
        /// </summary>
        public MarketplaceStore Store
        {
            get;
            set;
        }

        /// <summary>
        /// Detail view level
        /// </summary>
        public DetailView View
        {
            get;
            set;
        }

        /// <summary>
        /// Media type filter
        /// </summary>
        public MediaTypes MediaType
        {
            get;
            set;
        }

        /// <summary>
        /// Defines ordering of purchase history entries in the response
        /// </summary>
        public OrderHistoryBy OrderBy
        {
            get;
            set;
        }

        /// <summary>
        /// Defines ordering direction of purchase history entries in the response
        /// </summary>
        public OrderDirection Direction
        {
            get;
            set;
        }

        
        #endregion

        #region Helper Methods
        
        internal LivecacheWebSvcRequest CreateLiveCacheRequest()
        {
            return (this.UsePurchaseHistoryV1) ? CreateLiveCacheRequestInnerV1() : CreateLiveCacheRequestInnerV2();
        }

        internal LivecacheWebSvcRequest CreateLiveCacheRequestInnerV2()
        {
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();

            //set request parameters
            SetKeyNamePair("methodName", "PurchaseHistoryv2", ref request);
            SetKeyNamePair("UserPuid", LivePuid.ToString(), ref request);
            SetKeyNamePair("MachinePuid", "0", ref request);

            if (PageSize == 0)
            {
                PageSize = 100;
            }
            SetNameValuePairs("PageSize", PageSize.ToString(), ref request);  //required parameter. Max size is 1000. Beyond which the call fails.

            if (PageNum == 0)
            {
                PageNum = 1;
            }
            SetNameValuePairs("PageNum", PageNum.ToString(), ref request); //required parameter. Call fails if this is missing
            SetNameValuePairs("Locale", Locale.ToLower().ToString(), ref request); //specify the locale of the user (this is the language associated with the country xblox live user)
            SetNameValuePairs("LegalLocale", Locale.ToLower().ToString(), ref request); //same as Locale.

            if (TitleId > 0)
            {
                SetNameValuePairs("TitleId", TitleId.ToString(), ref request); //titleid
            }
            SetNameValuePairs("Store", ((UInt32)Store).ToString(), ref request); //required to indicate what store the assets need to be pulled from. Other enumerations are zune etc..
            SetNameValuePairs("DetailView", ((Int32)View).ToString(), ref request);
            SetNameValuePairs("MediaTypes", ((Int32)MediaType).ToString(), ref request);  //Enum that indicates type of assets.
            SetNameValuePairs("OrderBy", ((Int32)OrderBy).ToString(), ref request);
            SetNameValuePairs("OrderDirection", ((Int32)Direction).ToString(), ref request);
            if (StartDate > DateTime.MinValue.ToUniversalTime())
            {
                SetNameValuePairs("MinPurchaseDate", XmlConvert.ToString(StartDate.ToUniversalTime(), XmlDateTimeSerializationMode.RoundtripKind), ref request);
            }
            if (TransactionIDs != null)
            {
                foreach (var transactionID in TransactionIDs)
                {
                    SetNameValuePairs("TransactionIds", transactionID.ToString(), ref request);
                }
            }

            return request;
        }

        internal LivecacheWebSvcRequest CreateLiveCacheRequestInnerV1()
        {
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();

            //set request parameters
            SetKeyNamePair("methodName", "PurchaseHistory", ref request);
            SetKeyNamePair("UserPuid", LivePuid.ToString(), ref request);
            SetKeyNamePair("MachinePuid", "0", ref request);
            SetNameValuePairs("PageSize", "1000", ref request);  //required parameter. Max size is 1000. Beyond which the call fails.
            SetNameValuePairs("PageNum", "1", ref request); //required parameter. Call fails if this is missing
            SetNameValuePairs("Locale", Locale.ToLower().ToString(), ref request); //specify the locale of the user (this is the language associated with the country xblox live user)
            SetNameValuePairs("LegalLocale", Locale.ToLower().ToString(), ref request); //same as Locale.
            SetNameValuePairs("Store", ((UInt32)Store).ToString(), ref request); //required to indicate what store the assets need to be pulled from. Other enumerations are zune etc..
            SetNameValuePairs("DetailView", ((Int32)View).ToString(), ref request);
            SetNameValuePairs("MediaTypes", ((Int32)MediaType).ToString(), ref request);  //Enum that indicates type of assets.
            SetNameValuePairs("OrderBy", ((Int32)OrderBy).ToString(), ref request);
            SetNameValuePairs("OrderDirection", ((Int32)Direction).ToString(), ref request);

            return request;

        }

        private void SetKeyNamePair(String key, String value, ref LivecacheWebSvcRequest request)
        {
            Debug.Assert(request != null);
            Debug.Assert(!String.IsNullOrEmpty(key));
            request.NameValuePairs.Add(new WebServiceNameValuePair(key, value));
        }

        private void SetNameValuePairs(String key, String value, ref LivecacheWebSvcRequest request)
        {
            Debug.Assert(request != null);
            Debug.Assert(!String.IsNullOrEmpty(key));
            request.NameValuePairs.Add(new WebServiceNameValuePair("Names", key));
            request.NameValuePairs.Add(new WebServiceNameValuePair("Values", value));
        }

        #endregion
    }

    /// <summary>
    /// Models a PurchaseHistoryResponse
    /// </summary>
    public sealed class PurchaseHistoryResponse
    {
        /// <summary>
        /// Total Items purchased by the user irrespective of pagination
        /// </summary>
        public UInt32 TotalItems
        {
            get;
            set;
        }

        /// <summary>
        /// Purchase History Entries. May not be euqal to the total items purchased because this list might be generated 
        /// as pages entries.(Request to generate these enries might have pagination properties set)
        /// </summary>
        public ReadOnlyCollection<PurchaseHistoryEntry> PurchaseHistoryEntries
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\SaveSettingsResponse.cs ===
﻿using xonline.common.protocol;
using System;
using Leet.Live.Livecache.Logic.Profile;

namespace Leet.Live.Livecache.DataAccess
{
    public class SaveSettingsResponse
    {
        public DateTime Version { get; set; }
        public ushort TotalSettings { get; set; }
        public ushort SettingsLen { get; set; }
        public ProfileSetting[] Settings { get; set; }

        public SaveSettingsResponse()
        {
        }

        internal SaveSettingsResponse(SyncSettingsResponse response)
        {
            this.Version = response.Version;
            this.TotalSettings = response.TotalSettings;
            this.SettingsLen = response.SettingsLen;
            this.Settings = ProfileSetting.FromArray(response.Settings);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\MediaTypes.cs ===
﻿using System;

namespace Leet.Live.Livecache.DataAccess
{
    // The Marketplace MediaTypes are related to Console ContentTypes and there 
    // is a mapper class called MediaTypeToContentTypeMapper
    // Updates to add MediaTypes should also consider adding ContentTypes and mapping updates and vice versa
    public enum MediaTypes : int
    {
        Unknown = 0,
        /* Games */
        Xbox360Game = 1,                // Game Title, may have associated offers and instances 
        ArcadeDemo = 5,	                // Represents the Trial version of the Arcade game
        InGameContent = 18,             // Generic game content that the game knows how to interpret
        GameDemo = 19,                  // Demo for a game
        Xbox360Theme = 20,              // Theme that can be used in the Xbox Dashboard
        Xbox1Game = 21,                 // Downloadable Xbox 1 Game that is playable on Xbox 360 through fusion
        GamerTile = 22,                 // Gamer picture
        ArcadeGame = 23,                // Arcade game. Represents the Full Arcade game
        InGameConsumable = 24,          // Generic game consumable that the game knows how to interpret
        CommunityGame = 37,             // XNA created community arcade game
        FullGame = 38,                  // TBD
        GamePackagedVideo = 42,         // TBD
        Primetime = 45,
        LiveApp = 56,
        WebGame = 57,                   // Web game
        MobileGame = 58,                // Mobile game
        MobilePdlc = 59,                // Mobile Game Content
        MobileConsumable = 60,          // Mobile Consumable
            
        /* Video */
        Movie = 2,                      // Videos that are of type movie
        TVShow = 3,                     // Videos that are from television that are not designated as an episode, season or series (e.g. special programming like an Academy Award presentation)
        MusicVideo = 4,                 // Videos that are Music based
        ViralVideo = 7,                 // These are viral videos (from MSN Warhol)
        TVEpisode = 8,                  // A single TV show
        TVSeason = 9,                   // A group of TV Episodes typically grouping within a date range (typically falls within a year)
        TVSeries = 10,                  // A group of TV Seasons grouped together within a larger date range than a season
        VideoPreview = 11,              // TBD
        Podcast = 13,                   // Video or audio podcast media
        GameVideo = 30,                 // Game videos such as E3 event highlights.
        TVTrailer = 33,                 // Trailer of a TV show
        GameTrailer = 34,               // Trailer of a Game
        VideoShort = 35,                // A short Video
        Promotional = 39,               // Promotional video
        MovieTrailer = 40,              // Trailer of a movie
        /* Image */
        Poster = 12,                    // Poster image
        Image = 14,                     // Generic image media
        BoxArt = 15,                    // Box art image
        ArtistPicture = 16,             // Picture of an artist
        ScreenShot = 17,                // Screen shot of a media
        AlbumArt = 28,                  // Album cover art
        BackgroundArt = 31,             // Background art
        SlideshowPreviewImage = 41,     // Slideshow preview
        /* General */
        Bundle = 36,                    // Bundle
        MarketplaceContent = 46,
        AvatarGear = 47,
        GamerTagChange = 48,
        PointsBundle = 49,              // Microsoft Points Bundle

        /* Music */
        Track = 25,                     // Music track
        Album = 26,                     // Music Album
        AlbumDisc = 27,                 // Music Album Disc
        Music = 29,                     // Music
        Playlist = 32,                  // Music Playlist

        /* Subscription */
        GameSubscription = 50,          // Subscription
        LiveSubscription = 51,          // Subscription
        AddonSubscription = 52,         // Subscription
        LiveSubscriptionFamily = 53,    // SubscriptionFamily
        GameSubscriptionFamily = 54,    // SubscriptionFamily
        AddonSubscriptionFamily = 55,   // SubscriptionFamily

    }

    public enum MediaRelationshipTypes : int
    {
        Unknown = 0,
        EquivalentWorldwideGameTitle = 1,           // Used to link worldwide games that have different titleIDs in different regions
        MediaToAssociatedDownload = 2,              // Downloads which should show up under a media
        GameTrialToFullGame = 3,                    // Trial Game to a Full Game
        GameContentPreviewToFullGameContent = 5,    // Preview Offers
        SeriesToSeason = 6,                         // TV Episodic Seasons under TV Episodic Series.
        SeriesToEpisode = 7,                        // TV Episodes to a Series where there is no season, e.g. Daily Show, Academy Awards etc.
        SeasonToEpisode = 8,                        // TV Episodes under TV Seasons.
        MediaToImage = 15,                          // Represents the relationship between media and image
        AlbumDisc = 16,                             // Links an Album to a disc 
        DiscTrack = 17,                             // Links a disc to a track
        RelatedAlbum = 18,                          // Links albums to related media
        AlbumImage = 19,                            // Image of an album
        PromoToMedia = 20,                          // Links a promotional media to a media
        MediaToPreview = 21,                        // Links a preview to a media
        MediaToPoster = 22,                         // Links a poster image to a media
        MediaToThumbnail = 23,                      // Links a thumbnail to a media
        MediaToBackground = 24,                     // Links a background to a media
        MediaToWideBackgroundImage = 25,            // Links a wide background to a media
        MediaToVideoFrameImage = 26,                // Links a video frame image to a media
        MediaToSellImage = 27,                      // Links the sell image to a media
        RelatedPlaylist = 28,                       // Links playlists to a media
        ContributorToImage = 29,                    // Links a contributor to an image media
        MusicVideoToTrack = 30,                     // Links a MusicVideo to a music track
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\PresenceDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.DataAccess.Factories;
using Leet.Live.Livecache.Logic.Messaging;
using Leet.Core.IoCCo;
using xonline.common.service;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Live.Livecache.Logic.RecentPlayers;

namespace Leet.Live.Livecache.DataAccess
{
    /// <summary>
    /// 
    /// </summary>
    public class PresenceDataAccess : IPresenceDataAccess
    {
        private ILcPresence _lcPresence;
        private ILivecacheClientIdentifierProvider _lcClientIdentifier;

        public PresenceDataAccess(ILcPresence lcPresence, ILivecacheClientIdentifierProvider lcClientIdentifier)
        {
            _lcPresence = lcPresence;
            _lcClientIdentifier = lcClientIdentifier;
        }

        #region IPresenceDataAccess Members

        public void SendWebAlive(ulong livePuid)
        {
            _lcPresence.SendWebAlive(livePuid);
        }

        public void SendWebAlive2(ulong livePuid, uint titleId)
        {
            IContextItemProvider contextProvider = Container.Instance.GetComponent<IContextItemProvider>();
            IAccountAuthDataProvider authDataProvider = Container.Instance.GetComponent<IAccountAuthDataProvider>();

            ILcPresence lcPresence = new LcPresence(_lcClientIdentifier.GetClientType(), titleId, contextProvider, authDataProvider);
            lcPresence.SendWebAlive2(livePuid);
        }

        public IReadOnlyPresenceInfo GetPresenceInfo(ulong senderLivePuid, ulong targetLivePuid)
        {
            GetPresenceInfoRequest presenceReq = new GetPresenceInfoRequest();
            presenceReq.qwSenderID = senderLivePuid;
            presenceReq.rgUsers = new ulong[1] { targetLivePuid };
            presenceReq.cdwUsers = 1;

            PresenceInfoResponse response = _lcPresence.GetPresenceInfo(presenceReq);

            if (response.cdwUsers != 1)
            {
                throw new System.ArgumentOutOfRangeException("GetPresenceInfo did not return the expected number of users.");
            }

            PresenceInfo presence = PresenceInfoFactory.Create(response.rgUsers[0]);
            return presence;
        }

        public IReadOnlyPresenceInfo GetPublicPresenceInfo(ulong targetLivePuid, out DateTime responseTTL)
        {
            const ulong FAKE_XUID_NO_FRIENDS = 1;

            GetPresenceInfoRequest presenceReq = new GetPresenceInfoRequest();
            presenceReq.qwSenderID = FAKE_XUID_NO_FRIENDS;
            presenceReq.rgUsers = new ulong[1] { targetLivePuid };
            presenceReq.cdwUsers = 1;

            PresenceInfoResponse response = _lcPresence.GetPublicPresenceInfo(presenceReq, out responseTTL);

            if (response.cdwUsers != 1)
            {
                throw new ArgumentOutOfRangeException("GetPublicPresenceInfo did not return the expected number of users.");
            }

            PresenceInfo presence = PresenceInfoFactory.Create(response.rgUsers[0]);
            return presence;
        }

        public QueryAffiliatesReplyData[] GetQueryAffiliatesReplyData(ulong callingLivepuid, ushort maxCount)
        {
            if (maxCount == 0)
            {
                return new QueryAffiliatesReplyData[0];
            }

            // set up Presence request
            PresenceQueryAffiliatesMsg qaReq = new PresenceQueryAffiliatesMsg();
            qaReq.qwSenderID = callingLivepuid;
            qaReq.cdwLimit = maxCount;
            qaReq.dwListFlags = RecentPlayerCollectionBuilder.GetAffiliateListFlag(AffiliateFlag.Encountered);
            qaReq.dwOnlineTitleID = 0;

            return _lcPresence.QueryAffiliates(qaReq);
        }

        public IReadOnlyFriendInfo[] GetFriendsInfo(ulong callerLivepuid, bool sortAlphabetically, bool includeProfileData)
        {
            WebFriendsRequest wfrReq = new WebFriendsRequest();
            wfrReq.puid = callerLivepuid;
            WebFriendsResponse wfrResp = _lcPresence.GetFriends(wfrReq);

            uint friendCount = wfrResp.cdwFriends;

            // callers expect null returned if no friends found
            FriendInfo[] friends = null;
            if (friendCount > 0)
            {
                friends = new FriendInfo[friendCount];

                for (int i = 0; i < friendCount; i++)
                {
                    FriendInfo myFriend = FriendInfoFactory.Create(wfrResp.rgFriends[i]);

                    friends[i] = myFriend;
                }
            }

            return friends;
        }

        public void AddFriend(ulong userPuid, ulong targetPuid)
        {
            PresenceAddBuddy2Msg addFriendReq = new PresenceAddBuddy2Msg();
            addFriendReq.qwSenderID = userPuid;
            addFriendReq.qwBuddyID = targetPuid;
            addFriendReq.details = new MessageDetails();

            _lcPresence.AddFriend(addFriendReq);
        }

        public void AddFriendFromContact(ulong userPuid, ulong targetPuid)
        {
            PresenceAddBuddy2Msg addFriendReq = new PresenceAddBuddy2Msg();
            addFriendReq.qwSenderID = userPuid;
            addFriendReq.qwBuddyID = targetPuid;
            addFriendReq.details = new MessageDetails();

            _lcPresence.AddFriendFromContact(addFriendReq);
        }

        public void DeleteFriend(ulong userPuid, ulong targetPuid)
        {
            PresenceDeleteBuddyMsg deleteFriendReq = new PresenceDeleteBuddyMsg();
            deleteFriendReq.qwUserID = userPuid;
            deleteFriendReq.qwBuddyID = targetPuid;

            _lcPresence.DeleteFriend(deleteFriendReq);
        }

        public void AcceptFriendRequest(ulong userPuid, ulong targetPuid)
        {
            PresenceAcceptBuddyMsg acceptFriendReq = new PresenceAcceptBuddyMsg();
            acceptFriendReq.qwUserID = userPuid;
            acceptFriendReq.qwBuddyID = targetPuid;

            _lcPresence.AcceptFriendRequest(acceptFriendReq);
        }

        public void RejectFriendRequest(ulong userPuid, ulong targetPuid)
        {
            PresenceRejectBuddyMsg rejectFriendReq = new PresenceRejectBuddyMsg();
            rejectFriendReq.qwUserID = userPuid;
            rejectFriendReq.qwBuddyID = targetPuid;

            _lcPresence.RejectFriendRequest(rejectFriendReq);
        }

        public MessageSummary2[] EnumerateMessages(ulong userPuid)
        {
            EnumerateMessages2Msg request = new EnumerateMessages2Msg();
            request.qwUserID = userPuid;

            return _lcPresence.EnumerateMessages(request);
        }

        public MessageSummary2[] EnumerateMessages(ulong userPuid, bool includeWebAlive)
        {
            EnumerateMessages2Msg request = new EnumerateMessages2Msg();
            request.qwUserID = userPuid;

            //return _lcPresence.EnumerateMessages(request, includeWebAlive);
            return null;
        }

        public MessageSummary2 GetMessageSummary(ulong userPuid, uint messageId)
        {
            MessageSummary2Msg request = new MessageSummary2Msg();
            request.qwUserID = userPuid;
            request.dwMessageID = messageId;

            return _lcPresence.GetMessageSummary(request);
        }

        public IReadOnlyMessage GetMessageDetails(ulong userPuid, uint messageId, uint setFlags, uint unsetFlags)
        {
            MessageDetailsMsg request = new MessageDetailsMsg();
            request.qwUserID = userPuid;
            request.dwMessageID = messageId;
            request.dwSetFlags = setFlags;
            request.dwUnsetFlags = unsetFlags;

            MessageDetailsReply response = _lcPresence.GetMessageDetails(request);

            MessageSummary2 summary = new MessageSummary2();
            if (response.summary != null)
            {
                summary.bMessageType = response.summary.bMessageType;
                summary.cbDetails = response.summary.cbDetails;
                summary.dwMessageFlags = response.summary.dwMessageFlags;
                summary.dwMessageID = response.summary.dwMessageID;
                summary.dwSenderTitleID = response.summary.dwSenderTitleID;
                summary.mtSentTime = response.summary.mtSentTime;
                summary.qwSenderContext = response.summary.qwSenderContext;
                summary.qwSenderID = response.summary.qwSenderID;
                summary.szSenderName = response.summary.szSenderName;
                summary.wExpireMinutes = response.summary.wExpireMinutes;
            }
            else
            {
                throw new Exception(String.Format("Message id does not exist for the user.\r\nUserPuid = '{0}', messageId = {1}.", userPuid.ToString("X"), messageId.ToString()));
            }
            //initialize szSubject to avoid following error inside summary object:
            //<error: an exception of type: {System.NullReferenceException} occurred>
            summary.szSubject = String.Empty;

            Message message = new Message(summary, response.details);
            return message;
        }

        public bool DeleteMessage(ulong userPuid, uint messageId, uint flags)
        {
            DeleteMessageMsg request = new DeleteMessageMsg();
            request.qwUserID = userPuid;
            request.dwMessageID = messageId;
            request.dwFlags = flags;

            return _lcPresence.DeleteMessage(request);
        }

        public bool SetMessageFlags(ulong userPuid, uint messageId, uint setFlags, uint unsetFlags)
        {
            MessageFlagsMsg request = new MessageFlagsMsg();
            request.qwUserID = userPuid;
            request.dwMessageID = messageId;
            request.dwSetFlags = setFlags;
            request.dwUnsetFlags = unsetFlags;

            return _lcPresence.SetMessageFlags(request);
        }

        public void SendMessage(ulong userPuid, string szSenderName, ulong qwSenderContext, uint dwMessageFlags, ushort wExpireMinutes, byte bMessageType, ulong[] rgqwRecipients, xonline.common.protocol.MessageDetails details)
        {
            SendMessageMsg request = new SendMessageMsg();
            request.qwSenderID = userPuid;
            request.qwSenderContext = qwSenderContext;
            request.dwMessageFlags = dwMessageFlags;
            request.dwSenderTitleID = _lcClientIdentifier.GetClientTitleId();
            request.wExpireMinutes = wExpireMinutes;
            if (null != details)
            {
                request.cbDetails = (ushort)details.Size();
            }
            request.cRecipients = (ushort)rgqwRecipients.Length;
            request.bMessageType = bMessageType;
            request.szSenderName = szSenderName;
            request.qwRecipientIDs = rgqwRecipients;
            request.details = details;

            SendMessageReply response = _lcPresence.SendMessage(request);

            if (response.hr != HResult.S_OK)
            {
                for (int i = 0; i < response.recipients.Length; i++)
                {
                    if (HResult.Failed(response.recipients[i].dwMessageID))
                    {
                        // we only care about 3 error conditions right now.
                        switch (response.recipients[i].dwMessageID)
                        {
                            case HResult.XONLINE_E_NOTIFICATION_INVALID_PUID:
                            case HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES:
                                throw new MessageNotSentException(response.recipients[i].dwMessageID, userPuid);

                            case xonline.common.service.HResult.XONLINE_E_MESSAGE_THROTTLED:
                                throw new SendMessageThrottleException(userPuid);

                            case HResult.XONLINE_E_MESSAGE_SENDER_BLOCKED:
                            case HResult.XONLINE_E_MESSAGE_UNDELIVERABLE:
                            default:
                                // if sender was blocked, we just ignore and don't care
                                // if recipient is a child account, then we get the undeliverable message
                                break;
                        }
                    }
                }
            }
        }

        public SystemMessageSummary[] EnumerateSystemMessages(ulong userPuid, uint titleId)
        {
            EnumerateSystemMessagesMsg request = new EnumerateSystemMessagesMsg();
            request.dwTitleID = titleId;

            return _lcPresence.EnumerateSystemMessages(userPuid, request);
        }

        public IReadOnlySystemMessage GetSystemMessageDetails(ulong userPuid, uint titleId, uint messageId)
        {
            SystemMessageDetailsMsg request = new SystemMessageDetailsMsg();
            request.dwTitleID = titleId;
            request.dwMessageID = messageId;

            SystemMessageDetailsReply response = _lcPresence.GetSystemMessageDetails(userPuid, request);

            return new SystemMessage(response.summary, response.details);
        }

        /// <summary>
        /// Returns FriendInfo[] with GamerTag and LivePuid of each friend.
        /// </summary>
        /// <param name="sender">sender Xuid</param>
        /// <param name="target">target Xuid</param>
        /// <returns></returns>
        public IReadOnlyFriendInfo[] GetFriendsOfFriend(ulong sender, ulong target)
        {
            GetFriendsListRequest request = new GetFriendsListRequest();
            request.qwSender = sender;
            request.qwTarget = target;

            GetFriendsListResponse response = _lcPresence.GetFriendsOfFriend(request);
            if (xonline.common.service.HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES == response.hr)
            {
                return new FriendInfo[0]; // return empty array
            }

            // parse response and create friendinfolist
            FriendInfo[] friends = new FriendInfo[response.rgFriends.Length];

            for (int i = 0; i < response.rgFriends.Length; ++i)
            {
                FriendInfo friend = new FriendInfo();

                friend.Gamertag = response.rgFriends[i].szGamerTag;
                friend.LivePuid = response.rgFriends[i].Puid;

                friends[i] = friend;
            }

            return friends;
        }

        public uint[] CanSendMessageToUsers(ulong userPuid, ulong[] targetPuids)
        {
            CanSendMessageToUsersMsg request = new CanSendMessageToUsersMsg();
            request.qwUserID = userPuid;
            request.rgqwUsers = targetPuids;
            request.cUserListCount = (ushort)targetPuids.Length;

            CanSendMessageToUsersResponse response = null;
            response = _lcPresence.CanSendMessageToUsers(request);

            return response.rghrResponses;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\StsDataAccess.cs ===
﻿using System;
using xonline.common.webplatform.livecache;
using xonline.common.protocol;
using xonline.common.service;
using Leet.Live.Livecache.Logic;
using System.IO;
using System.Xml;
using System.Reflection;

namespace Leet.Live.Livecache.DataAccess
{
    public class StsDataAccess : IStsDataAccess
    {
        private ILcSts _lcSts;

        public StsDataAccess(ILcSts lcSts)
        {
            _lcSts = lcSts;
        }

        static ushort? buildNumber = null;
        private static ushort BuildNumber
        {
            get
            {
                if (!buildNumber.HasValue)
                {
                    buildNumber = (ushort) Assembly.GetExecutingAssembly().GetName().Version.Build;
                }
                return buildNumber ?? 0;
            }
        }

        public string GetSecurityTicket(ulong livePuid, ulong passportPuid, uint titleId, ushort titleVersion, string ipAddressInternet, ulong passportCid, DateTime issueInstant, DateTime notAfter)
        {
            if (livePuid == 0) { throw new ArgumentOutOfRangeException("livePuid", "livePuid must be non-zero"); }
            if (passportPuid == 0) { throw new ArgumentOutOfRangeException("passportPuid", "passportPuid must be non-zero"); }
            if (titleId == 0) { throw new ArgumentOutOfRangeException("titleId", "titleId must be non-zero"); }
            if (String.IsNullOrEmpty(ipAddressInternet)) { throw new ArgumentNullException("ipAddressInternet", "ipAddressInternet cannot be null or empty"); }
            if (passportCid == 0) { throw new ArgumentOutOfRangeException("passportCid", "passportCid must be non-zero"); }

            // DeviceID really applies to mobile. Just push a value in until we're told otherwise. It does need to match the CertThumbprint in the AAInfo though.
            const string deviceId = "";

            // Prepare the request
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            // Hardcode the platform for the web based scenario
            request.NameValuePairs.Add(new WebServiceNameValuePair("platformType", XOn.XPLT_WEB_GAMES.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("titleId", titleId.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("titleVersion", titleVersion.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("clientVersion", BuildNumber.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("deviceId", deviceId));

            // Prepare the AAInfo
            IAAInfoData infoData = new AAInfoData()
            {
                CertDeviceId = deviceId,
                IpAddressInternet = ipAddressInternet,
                IssueInstant = issueInstant,
                NotAfter = notAfter,
                PassportCId = passportCid,
                PassportPuid = passportPuid,
            };

            // make the request
            LiveCacheWebSvcResponse response = _lcSts.GetSecurityTicket(livePuid, titleId, request, infoData);

            return GetTokenFromWebSvcResponse(response);
        }

        public string GetPartnerSecurityTicket(ulong livePuid, uint titleId, uint titleVersion, string ipAddressInternet, string userSamlToken, string audience)
        {
            if (livePuid == 0) { throw new ArgumentOutOfRangeException("livePuid", "livePuid must be non-zero"); }
            if (titleId == 0) { throw new ArgumentOutOfRangeException("titleId", "titleId must be non-zero"); }
            if (String.IsNullOrEmpty(ipAddressInternet)) { throw new ArgumentNullException("ipAddressInternet", "ipAddressInternet cannot be null or empty"); }
            
            // DeviceID really applies to mobile. Just push a value in until we're told otherwise. It does need to match the CertThumbprint in the AAInfo though.
            const string deviceId = "";

            // Prepare the request
            LivecacheWebSvcRequest request = new LivecacheWebSvcRequest();
            // Hardcode the platform for the web based scenario
            request.NameValuePairs.Add(new WebServiceNameValuePair("xuid", livePuid.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("titleId", titleId.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("titleVersion", titleVersion.ToString()));
            request.NameValuePairs.Add(new WebServiceNameValuePair("audience", audience));

            // Prepare the AAInfo
            IAAInfoData infoData = new AAInfoData()
            {
                CertDeviceId = deviceId,
                IpAddressInternet = ipAddressInternet,
                SamlToken = userSamlToken
            };

            // make the request
            LiveCacheWebSvcResponse response = _lcSts.GetPartnerSecurityTicket(livePuid, titleId, request, infoData);

            return GetTokenFromWebSvcResponse(response);
        }

        private static string GetTokenFromWebSvcResponse(LiveCacheWebSvcResponse response)
        {
            string token = "";

            XmlTextReader reader = new XmlTextReader(new StringReader(response.response));

            while (reader.Read())
            {
                if (reader.IsStartElement("string"))
                {
                    token = reader.ReadElementContentAsString();
                }
            }
            return token;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\SettingsDataAccess.cs ===
﻿
namespace Leet.Live.Livecache.DataAccess
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Text;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Live.Livecache.DataAccess.Factories;
    using Leet.Live.Livecache.Logic.Exceptions;
    using xonline.common.protocol;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;

    public class SettingsDataAccess : ISettingsDataAccess
    {
        private const int MAX_LENGTH_MOTTO = 21;
        private const int MAX_LENGTH_NAME = 129;
        private const int MAX_LENGTH_BIO = 499;
        private const int MAX_LENGTH_LOCATION = 40;

        private ILcStats _lcStats;
        private IAccountAuthDataProvider _accountAuthProvider;
        private IXCacheDataAccess _xCacheDA;
        private ILcStringSvr _lcStringServer;

        public SettingsDataAccess(ILcStats lcStats, 
            IAccountAuthDataProvider accountAuthProvider, 
            IXCacheDataAccess xCacheDA, 
            ILcStringSvr lcStringServer)
        {
            _lcStats = lcStats;
            _accountAuthProvider = accountAuthProvider;
            _xCacheDA = xCacheDA;
            _lcStringServer = lcStringServer;
        }

        #region ISettingsDataAccess Members

        public void LoadSettings(ReadSettingsResponse readResp, IGamerProfile profile, IWebPreferences webPreferences)
        {
            int numberOfSetting = 0;
            numberOfSetting = readResp.Settings.Length;

            for (int index = 0; index < numberOfSetting; index++)
            {
                UserSetting setting = readResp.Settings[index];
                GamerProfileFactory.PopulateSetting(setting, profile, webPreferences);
            }
        }

        public IGamerProfile[] LoadSettings(ReadSettingsResponse readResp)
        {
            int numberOfSetting = 0;
            numberOfSetting = readResp.Settings.Length;

            Hashtable htGamerProfiles = new Hashtable((int)XOn.XONLINE_MAX_SETTING_USERS);

            for (int index = 0; index < numberOfSetting; index++)
            {
                UserSetting setting = readResp.Settings[index];
                ulong userLivepuid = setting.UserId;
                IGamerProfile profile;

                // go through all the results and create a GamerProfile object for each user and stick in hash table
                if (!htGamerProfiles.ContainsKey(userLivepuid))
                {
                    profile = new GamerProfile();
                    profile.LivePuid = userLivepuid;
                    htGamerProfiles.Add(userLivepuid, profile);
                    string gamerTag = string.Empty;
                    if (_xCacheDA.GetGamertagByPuid(profile.LivePuid, out gamerTag))
                    {
                        profile.GamerTag = gamerTag;
                    }

                }
                else
                {
                    profile = htGamerProfiles[userLivepuid] as IGamerProfile;
                }

                GamerProfileFactory.PopulateSetting(setting, profile, null);
            }

            IGamerProfile[] profiles = new IGamerProfile[htGamerProfiles.Count];
            htGamerProfiles.Values.CopyTo(profiles, 0);
            return profiles;
        }

        public void SaveSettings(IGamerProfile profile, IWebPreferences preferences, string locale)
        {
            if ((profile == null) && (preferences == null))
            {
                throw new ArgumentNullException("profile and preferences", "Profile and preferences cannot both be null.");
            }

            if ((profile != null) && (preferences != null) && (profile.LivePuid != preferences.LivePuid))
            {
                throw new ArgumentException("profile and preferences", "Profile and preferences must have the same value for their Livepuid.");
            }

            ulong targetLivepuid;

            if (profile != null)
            {
                targetLivepuid = profile.LivePuid;
            }
            else
            {
                targetLivepuid = preferences.LivePuid;
            }

            // create settings list.
            List<ProfileSetting> profileSettings = new List<ProfileSetting>();
            PopulateSettingsForSync(profileSettings, profile, preferences, locale);

            // Not sure if there's anything interesting we should be looking for in the response.
            // Ignoring response for now.
            SyncSettings(targetLivepuid, profileSettings.ToArray());
        }
        
        //ReadSettingsResponse ReadSettings(ulong callingLivepuid, ulong targetLivepuid);
        
        //ReadSettingsResponse PublicReadSettings(ulong targetLivepuid, out DateTime responseTTL);
        
        public ReadSettingsResponse[] ReadProfileSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings)
        {
            return _lcStats.ReadMultiUsersSettings(callingLivepuid, targetLivepuids, settings, _accountAuthProvider);
        }

        public SaveSettingsResponse SyncSettings(ulong callingLivepuid, ProfileSetting[] settings)
        {
            if (settings.Length == 0)
            {
                // Not asking for anything, mock up an empty response.
                SaveSettingsResponse emptySyncResp = new SaveSettingsResponse();
                emptySyncResp.Version = DateTime.MinValue;
                emptySyncResp.TotalSettings = 0;
                emptySyncResp.SettingsLen = 0;
                emptySyncResp.Settings = new ProfileSetting[0];
                return emptySyncResp;
            }

            SyncSettingsResponse response;
            try
            {
                response = _lcStats.SyncSettings(callingLivepuid, ProfileSetting.ToArray(settings), _accountAuthProvider);
            }
            catch (LivecacheResponseException ex)
            {
                throw new LeetLivecacheResponseException(ex);
            }

            return new SaveSettingsResponse(response);
        }

        public IGamerProfile GetGamerProfile(ulong callingLivepuid, ulong targetLivepuid)
        {
            //Get Gamertag from XCache
            string gamertag;
            _xCacheDA.GetGamertagByPuid(targetLivepuid, out gamertag);

            return GetGamerProfile(gamertag, callingLivepuid, targetLivepuid);
        }

        public IGamerProfile GetGamerProfile(string gamertag, ulong callingLivepuid, ulong targetLivepuid)
        {
            ReadSettingsResponse response = _lcStats.ReadSettings(callingLivepuid, targetLivepuid, SettingsDataAccess.AllSettings,
                _accountAuthProvider);

            GamerProfile profile = GamerProfileFactory.Create(targetLivepuid, gamertag, response.Settings);
            return profile;
        }

        public IGamerProfile GetPublicGamerProfile(ulong targetLivepuid)
        {
            string gamertag;
            _xCacheDA.GetGamertagByPuid(targetLivepuid, out gamertag);

            return GetPublicGamerProfile(gamertag, targetLivepuid);
        }

        public IGamerProfile GetPublicGamerProfile(string gamertag, ulong targetLivepuid)
        {
            DateTime responseTTL;
            ReadSettingsResponse response = _lcStats.PublicReadSettings(targetLivepuid, SettingsDataAccess.AllSettings, out responseTTL);

            GamerProfile profile = GamerProfileFactory.Create(targetLivepuid, gamertag, response.Settings);
            return profile;
        }

        public IGamerProfile[] GetGamerProfilesBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            if (targetLivepuids == null || targetLivepuids.Length == 0)
            {
                return new GamerProfile[0];
            }
            if (settings == null || settings.Length == 0)
            {
                throw new Exception("settings is not defined");
            }
            ReadSettingsResponse[] responses = ReadProfileSettings(callingLivepuid, targetLivepuids, settings);
            int estimatedArrayListSize = responses.Length * (int)XOn.XONLINE_MAX_SETTING_USERS;
            ArrayList profileList = new ArrayList(estimatedArrayListSize);

            //populate gamer profile
            foreach (ReadSettingsResponse readResp in responses)
            {
                IGamerProfile[] profiles = LoadSettings(readResp);
                foreach (IGamerProfile profile in profiles)
                {
                    if (getGamertag)
                    {
                        string gamerTag;

                        if (_xCacheDA.GetGamertagByPuid(profile.LivePuid, out gamerTag))
                        {
                            profile.GamerTag = gamerTag;
                        }
                        else
                        {
                            profile.GamerTag = "??????";
                        }
                    }
                    profileList.Add(profile);
                }
            }

            IGamerProfile[] totalProfiles = new IGamerProfile[profileList.Count];
            profileList.CopyTo(totalProfiles);

            return totalProfiles;
        }

        public Dictionary<ulong, IGamerProfile> GetGamerProfileCollectionBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            IGamerProfile[] profiles = GetGamerProfilesBySetting(callingLivepuid, targetLivepuids, settings, getGamertag);

            Dictionary<ulong, IGamerProfile> gamerListSettings = new Dictionary<ulong, IGamerProfile>();
            foreach (IGamerProfile profile in profiles)
            {
                gamerListSettings.Add(profile.LivePuid, profile);
            }
            return gamerListSettings;
        }

        // pass the 0 for titleID if you need assets for all the titles
        public ReadOnlyCollection<AwardedAvatarAsset> GetUserAvatarAwards(ulong livePuid, ushort localeId, uint titleID)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();

            if (livePuid == 0)
            {
                throw new ArgumentNullException("livePuid", "livePuid should be greater than 0");
            }

            Debug.Assert(_lcStats != null ,"_lcStats");
            Debug.Assert(_accountAuthProvider !=null, "_accountAuthProvider");
            
            //Create the request to get awardable assets
            AvatarAssetEnumRequest request = new AvatarAssetEnumRequest();
            request.ForPuid = livePuid; 
            request.Puid = livePuid;
            request.TitleId = titleID;  // get assests for only this title, set it for 0 for all the titles.
            request.StartingIndex = 0;
            request.MaxAssets = UInt16.MaxValue;  
            request.LocaleId = localeId;

            AvatarAssetEnumResponse response = null;
            try
            {
                //Make a call to the live cache to get the awardable assets
                response = _lcStats.GetUserAvatarAwards(request, _accountAuthProvider);
            }
            catch (LivecacheConfigException configEx)
            {
                throw new LeetLivecacheConfigException(configEx);
            }
            catch (LivecacheResponseException rEx)
            {
                throw new LeetLivecacheResponseException(rEx);
            }


            List<AwardedAvatarAsset> awardedAssets = new List<AwardedAvatarAsset>();
            if (response != null && response.AvatarAssetsCount > 0) //we will return no assets if we failed to get a response or the asset count is 0;
            {
                foreach (xonline.common.protocol.AvatarAsset responseAsset in response.AvatarAssets)
                {
                    AwardedAvatarAsset awardedAsset = new AwardedAvatarAsset();
                    awardedAsset.AvatarAssetId = responseAsset.AvatarAssetId;
                    awardedAsset.AvatarAssetOrdinal = responseAsset.AvatarAssetOrdinal;
                    awardedAsset.Awarded = responseAsset.Awarded;
                    awardedAsset.BodyComponent = responseAsset.BodyComponent;
                    awardedAsset.BodyTypeMask = responseAsset.BodyTypeMask;
                    awardedAsset.Description = responseAsset.Description;
                    awardedAsset.DescriptionLen = responseAsset.DescriptionLen;
                    awardedAsset.Flags = responseAsset.Flags;
                    awardedAsset.HowTo = responseAsset.HowTo;
                    awardedAsset.ImageId = responseAsset.ImageId;
                    awardedAsset.Sequence = responseAsset.Sequence;
                    awardedAsset.SubCategory = responseAsset.SubCategory;
                    awardedAsset.Title = responseAsset.Title;
                    awardedAssets.Add(awardedAsset);
                }
            }
            return new ReadOnlyCollection<AwardedAvatarAsset>(awardedAssets);
        }

        public void SaveGamerProfile(IGamerProfile profile, string locale)
        {
            SaveSettings(profile, null, locale);
        }

        //IWebPreferences GetWebPreferences(ulong callingLivepuid, ulong targetLivepuid);
        
        //void SaveWebPreferences(IWebPreferences preferences);

        #endregion


        #region AllSettings
        private static uint[] AllSettings
        {
            get
            {
                if (allSettings == null)
                {
                    System.Array allSettingsInEnum = Enum.GetValues(typeof(StatsProfileSettings));
                    uint[] tempAllSettings = new uint[allSettingsInEnum.Length];

                    for (int i = 0; i < allSettingsInEnum.Length; i++)
                    {
                        tempAllSettings[i] = Convert.ToUInt32(allSettingsInEnum.GetValue(i));
                    }

                    allSettings = tempAllSettings;
                }

                return allSettings;
            }
        }
        private static uint[] allSettings;
        #endregion

        #region ISettingsDataAccess support methods

        private void PopulateSettingsForSync(List<ProfileSetting> settings, IGamerProfile profile, IWebPreferences

webPreferences, string locale)
        {
            if (webPreferences != null)
            {
                // These settings are not yet supported.
                throw new NotImplementedException();
            }

            if (profile != null)
            {
                if (profile.GamerTile != null)
                {
                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardTile,

profile.GamerTile.Substring(0, 24)));
                }

                if ((profile.Zone != GamercardZone.Unknown) && (profile.Zone != GamercardZone.None))
                {
                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardZone, (int)

profile.Zone));
                }

                if (profile.Country != int.MinValue)
                {
                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamerCountry,

profile.Country));
                }

                if ((profile.ProfilePermissions != int.MinValue))
                {
                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.ProfilePermissions,

profile.ProfilePermissions));
                }

                if ((int)profile.GamerType != int.MinValue)
                {
                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamerType, (int)

profile.GamerType));
                }

                if (profile.Motto != null)
                {
                    ValidateGlyphs(profile.Motto, "Motto");
                    VetString(profile.Motto, locale, "Motto");
                    ValidateLength("Motto", MAX_LENGTH_MOTTO, profile.Motto);

                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardMotto,

profile.Motto));
                }

                if (profile.Name != null)
                {
                    ValidateGlyphs(profile.Name, "Name");
                    VetString(profile.Name, locale, "Name");
                    ValidateLength("Name", MAX_LENGTH_NAME, profile.Name);

                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardName, profile.Name));
                }

                if (profile.Location != null)
                {
                    ValidateGlyphs(profile.Location, "Location");
                    VetString(profile.Location, locale, "Location");
                    ValidateLength("Location", MAX_LENGTH_LOCATION, profile.Location);

                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardLocation,

profile.Location));
                }

                if (profile.BlogUrl != null)
                {
                    ValidateGlyphs(profile.BlogUrl, "BlogUrl");
                    VetString(profile.BlogUrl, locale, "BlogUrl");

                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardBlogUrl,

profile.BlogUrl));
                }

                if (profile.Bio != null)
                {
                    ValidateGlyphs(profile.Bio, "Bio");
                    VetString(profile.Bio, locale, "Bio");
                    ValidateLength("Bio", MAX_LENGTH_BIO, profile.Bio);

                    settings.Add(CreateProfileSetting(profile.LivePuid, StatsProfileSettings.GamercardBio, profile.Bio));
                }
            }
        }

        private static ProfileSetting CreateProfileSetting(ulong xuid, StatsProfileSettings settingId, string newValue)
        {
            byte[] valueInBytes = ConvertProfileStringToByte(newValue);

            ProfileSetting profileSetting = new ProfileSetting
            {
                UserId = xuid,
                SettingId = (uint)settingId,
                Value = valueInBytes,
                ValueLen = (ushort)valueInBytes.Length,
                Source = LivecacheConstants.XSOURCE_DEFAULT,
            };

            return profileSetting;
        }

        private static ProfileSetting CreateProfileSetting(ulong xuid, StatsProfileSettings settingId, int newValue)
        {
            byte[] valueInBytes = BitConverter.GetBytes(newValue);

            ProfileSetting profileSetting = new ProfileSetting
            {
                UserId = xuid,
                SettingId = (uint)settingId,
                Value = valueInBytes,
                ValueLen = (ushort)valueInBytes.Length,
                Source = LivecacheConstants.XSOURCE_DEFAULT,
            };

            return profileSetting;
        }

        private static byte[] ConvertProfileStringToByte(string profileString)
        {
            if (profileString == null)
            {
                throw new ArgumentNullException("profileString");
            }

            Encoding unicode = Encoding.Unicode;
            int byteCount = unicode.GetByteCount(profileString);

            byte[] byteValue = new byte[byteCount + 2];
            unicode.GetBytes(profileString, 0, profileString.Length, byteValue, 0);
            byteValue[byteCount] = 0;
            byteValue[byteCount + 1] = 0;

            return byteValue;
        }

        private static void ValidateGlyphs(string stringToValidate, string propertyName)
        {
            //// TODO: Add GlyphValidator support similar to what is in xboxcom business libs
            //List<int> invalidGlyphPositions = logic.consoleSupport.GlyphValidator.Instance.Validate(stringToValidate);

            //if (invalidGlyphPositions.Count > 0)
            //{
            //    throw new InvalidXboxConsoleGlyphsException(
            //        stringToValidate,
            //        invalidGlyphPositions,
            //        String.Format("Property, {0}, has invalid glyphs: {1}.", propertyName, stringToValidate));
            //}
        }

        private void VetString(string stringToVet, string locale, string propertyName)
        {
            if (!string.IsNullOrEmpty(stringToVet))
            {
                StringServerDataAccess dataAccess = new StringServerDataAccess(_lcStringServer);
                bool isOffensive = dataAccess.VetString(locale, stringToVet);
                if (isOffensive)
                {
                    throw new ArgumentException(String.Format("{0} is considered offensive: {1}.", propertyName,

stringToVet), propertyName);
                }
            }
        }

        // bug 6747
        // validate length of different profile settings
        private void ValidateLength(string profileSetting, int maxLength, string value)
        {
            if (!string.IsNullOrEmpty(value))
            {
                if (value.Length > maxLength) 
                {
                    throw new ArgumentException(String.Format("{0} length exceeds {1} characters: {2}.", profileSetting, maxLength, value), profileSetting);
                }
            }
        }

        #endregion ISettingsDataAccess support methods
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\XCacheDataAccess.cs ===
﻿namespace Leet.Live.Livecache.DataAccess
{
    using System;
    using xonline.common.webplatform.livecache;

    public class XCacheDataAccess : IXCacheDataAccess
    {
        private ILcXCache _lcXCache;

        public XCacheDataAccess(ILcXCache lcXCache)
        {
            _lcXCache = lcXCache;
        }

        public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
        {
            return _lcXCache.LookupWebID(passportPuid, out livePuid, out gamertag);
        }

        public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
        {
            return _lcXCache.GetOfficialGamerTag(gamertag, out livePuid, out officialGamertag);
        }

        public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
        {
            return _lcXCache.GetPuidByGamerTag(gamertag, out livePuid);
        }

        public bool GetGamertagByPuid(ulong livePuid, out string gamertag)
        {
            return _lcXCache.GetGamertagByPuid(livePuid, out gamertag);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\StringServerDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using xonline.common.xboxcom;
using xonline.common.service;
using xonline.common.webplatform.livecache;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Providers;

namespace Leet.Live.Livecache.DataAccess
{
    public class StringServerDataAccess : IStringServerDataAccess
    {
        private ILcStringSvr _lcStringSvr;

        public StringServerDataAccess(ILcStringSvr stringSvr)
        {
            _lcStringSvr = stringSvr;
        }

        #region IStringServerDataAccess Members

        public string LookupString(uint titleId, uint stringId, ushort liveLanguageId, out DateTime responseTTL)
        {
            return _lcStringSvr.StringLookup(titleId, stringId, liveLanguageId, out responseTTL);
        }

        //TODO:  This needs a database to back it up, so can't port it.  We need this before we can write to profile though.
        public bool VetString(string locale, string vetString)
        {
            const int NUMBER_OF_STRINGS = 1;
            bool isOffensive = false;
            StringVet2Request vetReq = new StringVet2Request();

            vetReq.dwTitleID = LivecacheConstants.WEB_TITLE_ID;
            vetReq.szLocale = locale;
            vetReq.wLocaleLen = (ushort)vetReq.szLocale.Length;
            vetReq.wNumStrings = NUMBER_OF_STRINGS;
            vetReq.rgStringData = new StringData[1];

            vetReq.rgStringData[0] = new StringData();
            vetReq.rgStringData[0].szString = vetString;

            StringVetResponse vetResp = _lcStringSvr.VetString(vetReq);

            uint retVal;
            if (vetResp.rghrString.Length != 0)
            {
                retVal = (uint)(vetResp.rghrString.GetValue(0));
                if (retVal == HResult.XONLINE_E_STRING_OFFENSIVE_TEXT)
                    isOffensive = true;
            }
            return isOffensive;
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\Factories\GamerProfileFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Leet.Live.Livecache.Logic.Profile;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.DataAccess.Factories
{
    internal class GamerProfileFactory
    {
        public static GamerProfile Create(ulong livePuid, string gamertag, UserSetting[] settings)
        {
            GamerProfile profile = new GamerProfile(livePuid, gamertag);

            if (settings == null)
            {
                throw new NullReferenceException("No User Settings were retrieved from Livecache");
            }

            //Enumerate through Settings Response Property Bag and Populate Business Object
            for (int i = 0; i < settings.Length; i++)
            {
                UserSetting setting = settings[i];
                PopulateSetting(setting, profile, null);
            }
            return profile;
        }

        public static void PopulateSetting(UserSetting setting, IGamerProfile profile, IWebPreferences webPreferences)
        {
            switch ((StatsProfileSettings)setting.SettingId)
            {
                case StatsProfileSettings.ConnectionSpeed:
                    if (webPreferences != null)
                    {
                        webPreferences.InternetConnection = (ConnectionSpeeds)ReadIntSetting(setting, (int)ConnectionSpeeds.Unknown, (byte)ConnectionSpeeds.Unknown);
                    }
                    break;

                case StatsProfileSettings.EmailFormat:
                    if (webPreferences != null)
                    {
                        webPreferences.EmailFormat = (EmailFormats)ReadIntSetting(setting, (int)EmailFormats.Unknown, (byte)EmailFormats.Unknown);
                    }
                    break;

                case StatsProfileSettings.FavoriteGame:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGame1 = ReadIntSetting(setting, 0, -1);
                    }
                    break;

                case StatsProfileSettings.FavoriteGame1:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGame2 = ReadIntSetting(setting, 0, -1);
                    }
                    break;

                case StatsProfileSettings.FavoriteGame2:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGame3 = ReadIntSetting(setting, 0, -1);
                    }
                    break;

                case StatsProfileSettings.FavoriteGame3:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGame4 = ReadIntSetting(setting, 0, -1);
                    }
                    break;

                case StatsProfileSettings.FavoriteGame4:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGame5 = ReadIntSetting(setting, 0, -1);
                    }
                    break;

                case StatsProfileSettings.FavoriteGame5:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGame6 = ReadIntSetting(setting, 0, -1);
                    }
                    break;

                case StatsProfileSettings.FavoriteGenre:
                    if (webPreferences != null)
                    {
                        webPreferences.FavoriteGenres = (FavoriteGenreFlag)ReadIntSetting(setting, (int)FavoriteGenreFlag.None, (int)FavoriteGenreFlag.Unknown);
                    }
                    break;

                case StatsProfileSettings.Flash:
                    if (webPreferences != null)
                    {
                        webPreferences.ImageType = (ImageTypePreferences)ReadIntSetting(setting, (int)ImageTypePreferences.Unknown, (int)ImageTypePreferences.Unknown);
                    }
                    break;

                case StatsProfileSettings.GamercardBlogUrl:
                    if (profile != null)
                    {
                        profile.BlogUrl = ReadStringSetting(setting, string.Empty, null);
                    }
                    break;

                case StatsProfileSettings.PlatformsOwned:
                    if (webPreferences != null)
                    {
                        webPreferences.OwnedConsoles = (Consoles)ReadIntSetting(setting, (int)Consoles.None, (int)Consoles.Unknown);
                    }
                    break;

                case StatsProfileSettings.Spam:
                    // TODO:ZACKB: is this used?
                    break;

                case StatsProfileSettings.VideoPreference:
                    if (webPreferences != null)
                    {
                        webPreferences.VideoBandwidth = (VideoBandwidthPreferences)ReadIntSetting(setting, (int)VideoBandwidthPreferences.Unknown, (int)VideoBandwidthPreferences.Unknown);
                    }
                    break;

                case StatsProfileSettings.Flags:
                    // TODO:ZACKB: this needs to be clarified.  which route are we going?
                    if (profile != null)
                    {
                        int acceptedTou = ReadIntSetting(setting, 0x0, 0x0);
                        profile.HasAcceptedTOU = acceptedTou > 0;
                    }
                    if (webPreferences != null)
                    {
                        int acceptedTou = ReadIntSetting(setting, 0x0, 0x40000000);
                        if (acceptedTou == 0x40000000)
                        {
                            webPreferences.AcceptedTouValid = false;
                        }
                        else
                        {
                            webPreferences.AcceptedTou = (acceptedTou > 0);
                        }
                    }
                    break;

                case StatsProfileSettings.GamercardAvatarInfo:
                    if (profile != null)
                    {
                        if (setting.ValueLen > 0)
                        {
                            profile.AvatarManifest = setting.Value;
                        }
                        else
                        {
                            profile.AvatarManifest = null;
                        }
                    }
                    break;

                case StatsProfileSettings.GamercardBio:
                    if (profile != null)
                    {
                        profile.Bio = ReadStringSetting(setting, String.Empty, null);
                    }
                    break;

                case StatsProfileSettings.GamercardName:
                    if (profile != null)
                    {
                        profile.Name = ReadStringSetting(setting, String.Empty, null);
                    }
                    break;

                case StatsProfileSettings.GamercardLocation:
                    if (profile != null)
                    {
                        profile.Location = ReadStringSetting(setting, String.Empty, null);
                    }
                    break;

                case StatsProfileSettings.GamercardCred:
                    if (profile != null)
                    {
                        profile.Gamerscore = ReadIntSetting(setting, 0, int.MinValue);
                    }
                    break;

                case StatsProfileSettings.GamercardTile:
                    if (profile != null)
                    {
                        profile.GamerTileId = ReadStringSetting(setting, String.Empty, null);
                        profile.GamerTileUrl = Tiles.TileLocator.Instance.GamerTileUrl(profile.GamerTag, profile.GamerTileId, true, false);
                        profile.SecureGamerTileUrl = Tiles.TileLocator.Instance.GamerTileUrl(profile.GamerTag, profile.GamerTileId, true, true);
                        profile.SmallGamerTileUrl = Tiles.TileLocator.Instance.GamerTileUrl(profile.GamerTag, profile.GamerTileId, false, false);
                        profile.SecureSmallGamerTileUrl = Tiles.TileLocator.Instance.GamerTileUrl(profile.GamerTag, profile.GamerTileId, false, true);
                    }
                    break;

                case StatsProfileSettings.GamercardMotto:
                    if (profile != null)
                    {
                        profile.Motto = ReadStringSetting(setting, String.Empty, null);
                    }
                    break;

                case StatsProfileSettings.GamerCountry:
                    if (profile != null)
                    {
                        profile.Country = ReadIntSetting(setting, int.MinValue, int.MinValue);
                    }
                    break;

                case StatsProfileSettings.GamercardRep:
                    if (profile != null)
                    {
                        profile.Reputation = ReadFloatSetting(setting, 0F, float.NaN);
                    }
                    break;

                case StatsProfileSettings.GamerType:
                    if (profile != null)
                    {
                        profile.GamerType = (GamerTypeFlags)ReadIntSetting(setting, 0, 0);
                    }
                    break;

                case StatsProfileSettings.GamercardZone:
                    if (profile != null)
                    {
                        profile.Zone = (GamercardZone)ReadIntSetting(
                            setting,
                            (int)GamercardZone.None,
                            (int)GamercardZone.Unknown);
                    }
                    break;

                case StatsProfileSettings.GamerTier:
                    if (profile != null)
                    {
                        profile.Tier = (GamerTier)ReadIntSetting(
                            setting,
                            (int)GamerTier.None,
                            (int)GamerTier.Unknown);
                    }
                    break;

                case StatsProfileSettings.ProfilePermissions:
                    if (profile != null)
                    {
                        profile.ProfilePermissions = ReadIntSetting(setting, 0, XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE | XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE);
                    }
                    break;
            }
        }

        #region Setting Readers
        private static string ReadStringSetting(UserSetting setting, string defaultValue, string noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte)XuserDataType.Unicode)
            {
                //TODO: User LiveWebException instead.
                throw new Exception(
                    "ReadStringSetting was called with a setting ID that does not indicate a Unicode type. Type value for setting " 
                    + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
                //    "ReadStringSetting was called with a setting ID that does not indicate a Unicode type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else if (setting.ValueLen <= 2)
            {
                return "";
            }
            else
            {
                Encoding unicode = Encoding.Unicode;
                return unicode.GetString(setting.Value, 0, setting.ValueLen - 2);
            }
        }
        private static int ReadIntSetting(UserSetting setting, int defaultValue, int noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte)XuserDataType.Int32)
            {
                //TODO: Use LiveWebException Instead.
                throw new Exception(
                    String.Format("ReadIntSetting was called with a setting ID that does not indicate a Int32 type. Type value for setting {0} is {1}.",
                    setting,
                    ((setting.SettingId >> 28) & 0xf)));
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else
            {
                if (setting.ValueLen == 1)
                {
                    return (int)setting.Value[0];
                }
                else if (setting.ValueLen == 2)
                {
                    return (int)BitConverter.ToInt16(setting.Value, 0);
                }
                else if (setting.ValueLen == 4)
                {
                    return BitConverter.ToInt32(setting.Value, 0);
                }
                else
                {
                    //TODO: Use LiveWebException Instead.
                    throw new Exception(
                        "Can't convert setting " + ((StatsProfileSettings)setting.SettingId).ToString() + " to an int. " + setting.ValueLen.ToString() + " bytes were in the response - needs to be 1, 2, or 4 bytes to convert.");
                }
            }
        }
        private static float ReadFloatSetting(UserSetting setting, float defaultValue, float noPermissionValue)
        {
            if (((setting.SettingId >> 28) & 0xf) != (byte)XuserDataType.Float)
            {
                //TODO: Use Liveweb Exception Instead.
                throw new Exception(
                    "ReadFloatSetting was called with a setting ID that does not indicate a Float type. Type value for setting " + setting + " is " + ((setting.SettingId >> 28) & 0xf) + ".");
            }

            if (setting.Source == XOn.XSOURCE_PERMISSION_DENIED)
            {
                return noPermissionValue;
            }
            else if (setting.Source == XOn.XSOURCE_NO_VALUE)
            {
                return defaultValue;
            }
            else
            {
                if (setting.ValueLen == 4)
                {
                    return BitConverter.ToSingle(setting.Value, 0);
                }
                else
                {
                    //TODO: Use Liveweb Exception instead.
                    throw new Exception(
                        "Can't convert setting " + ((StatsProfileSettings)setting.SettingId).ToString() + " to a float. " + setting.ValueLen.ToString() + " bytes were in the response - needs to be 4 bytes to convert.");
                }
            }
        }
        #endregion


        /// <summary>
        /// A privilege read method to be used against the integer privilege value returned
        /// in the profile (as opposed to the raw uint[] used by GetUserWebInfo).  Only used
        /// when reading privileges from the user profile.
        /// </summary>
        /// <param name="privileges">Integer based privilege set from the user profile</param>
        /// <param name="friendsOnlyFlag">Flag representing the friends-only setting for the privilege being tested</param>
        /// <param name="nooneFlag">Flag representing the not allowed setting for the privilege being tested</param>
        /// <returns></returns>
        private static PrivilegeValue GetPrivilegeValue(int privileges, byte friendsOnlyFlag, byte nooneFlag)
        {
            PrivilegeValue privilegeValue = PrivilegeValue.Allow;
            if ((privileges & nooneFlag) == nooneFlag)
            {
                privilegeValue = PrivilegeValue.Deny;
            }
            else if ((privileges & friendsOnlyFlag) == friendsOnlyFlag)
            {
                privilegeValue = PrivilegeValue.FriendsOnly;
            }
            return privilegeValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\Factories\PresenceInfoFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;
using xonline.common.protocol;

namespace Leet.Live.Livecache.DataAccess.Factories
{
    class PresenceInfoFactory
    {
        private static readonly DateTime MT_BEGIN = new DateTime(2003, 1, 1);

        public static PresenceInfo Create(PresenceInfoData presenceData)
        {
            PresenceInfo presence = new PresenceInfo();

            presence.LivePuid = presenceData.Puid;
            presence.Gamertag = presenceData.szGamerTag;
            presence.IsJoinable = false;
            presence.IsPlaying = false;
            presence.State = OnlineState.Offline;
            presence.PresenceString = System.Text.UTF8Encoding.UTF8.GetString(presenceData.RPData, 0, (int)presenceData.RPDataLen);
            presence.LastSeen = MT_BEGIN.AddSeconds(presenceData.mtLastActive);

            SetOnlineStateFromServiceState(presenceData.OnlineState, ref presence);

            if (presence.State == OnlineState.Offline && presenceData.mtLastActive == 0)
            {
                presence.TitleId = 0;
            }
            else
            {
                presence.TitleId = presenceData.TitleId;
            }

            return presence;
        }

        public static PresenceInfo Create(WebFriendsData friendData)
        {
            PresenceInfo presence = new PresenceInfo();

            presence.LivePuid = friendData.Puid;
            presence.Gamertag = friendData.szGamerTag;
            presence.IsJoinable = false;
            presence.IsPlaying = false;
            presence.State = OnlineState.Offline;
            presence.PresenceString = System.Text.UTF8Encoding.UTF8.GetString(friendData.RPData, 0, (int)friendData.RPDataLen);
            presence.LastSeen = MT_BEGIN.AddSeconds(friendData.mtLastActive);  // Convert from service time (seconds from Jan 1, 2003)

            SetOnlineStateFromServiceState(friendData.OnlineState, ref presence);

            if ((presence.State == OnlineState.Offline) && (friendData.mtLastActive == 0))
            {
                presence.TitleId = 0;
            }
            else
            {
                presence.TitleId = friendData.TitleId;
            }

            return presence;
        }

        private static void SetOnlineStateFromServiceState(uint onlineState, ref PresenceInfo presence)
        {
            // offline or cloaked
            if (((onlineState & LivecacheConstants.P_STATE_FLAG_ONLINE) == 0) || ((onlineState & LivecacheConstants.P_STATE_FLAG_CLOAKED) != 0))
            {
                return;
            }

            presence.IsPlaying = ((onlineState & LivecacheConstants.P_STATE_FLAG_PLAYING) == LivecacheConstants.P_STATE_FLAG_PLAYING);
            presence.IsJoinable = ((onlineState & LivecacheConstants.P_STATE_FLAG_JOINABLE) == LivecacheConstants.P_STATE_FLAG_JOINABLE);

            // check online state
            uint userState = (onlineState & LivecacheConstants.P_STATE_MASK_USER_STATE);

            if (userState == LivecacheConstants.P_STATE_ENUM_BUSY)
            {
                presence.State = OnlineState.Busy;
            }
            else if (userState == LivecacheConstants.P_STATE_ENUM_AWAY)
            {
                presence.State = OnlineState.Away;
            }
            else
            {
                presence.State = OnlineState.Online;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\Factories\FriendInfoFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;
using xonline.common.protocol;

namespace Leet.Live.Livecache.DataAccess.Factories
{
    class FriendInfoFactory
    {
        public FriendInfoFactory()
        {

        }

        public static FriendInfo Create(WebFriendsData lcFriend)
        {
            FriendInfo myFriend = new FriendInfo();
            myFriend.Gamertag = lcFriend.szGamerTag;
            myFriend.LivePuid = lcFriend.Puid;

            //Friend request that I've sent
            if (lcFriend.FriendStatus == LivecacheConstants.P_BUDDY_STATUS_PENDING)
            {
                myFriend.FriendState = FriendState.Pending;
            }

            //Friend request sent to me
            if (lcFriend.FriendStatus == LivecacheConstants.P_BUDDY_STATUS_REQUEST)
            {
                myFriend.FriendState = FriendState.Requesting;
            }

            AddPresenceComponent(lcFriend, ref myFriend);

            return myFriend;
        }

        private static void AddPresenceComponent(WebFriendsData friendData, ref FriendInfo myFriend)
        {
            PresenceInfo presence = PresenceInfoFactory.Create(friendData);

            myFriend.IsJoinable = presence.IsJoinable;
            myFriend.IsPlaying = presence.IsPlaying;
            myFriend.State = presence.State;
            myFriend.PresenceString = presence.PresenceString;
            myFriend.LastSeen = presence.LastSeen;
            myFriend.TitleId = presence.TitleId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\LivePrivilegeSet.cs ===
using System;
using System.Diagnostics;

namespace Leet.Live.Livecache.Logic
{
    public class LivePrivilegeSet
    {
        public const int BitCount = 256;
        public const int ByteCount = BitCount/8;
        public const int DWordCount = ByteCount / 4;

        public static bool Test(uint[] privilegeSet, int privilegeId)
        {
            uint mask = (uint) 1 << (privilegeId % 32);
            return (privilegeSet[privilegeId / 32] & mask) != 0;
        }

        /* will these be useful to us? - [Probably, but perhaps more appropriate in HTTPAuthData (rrector)]
         */
        public static void Set(uint[] privilegeSet, int privilegeId)
        {
            uint mask = (uint) 1 << (privilegeId % 32);
            privilegeSet[privilegeId / 32] |= mask;
        }

        public static void Clear(uint[] privilegeSet, int privilegeId)
        {
            uint mask = (uint) 1 << (privilegeId % 32);
            privilegeSet[privilegeId / 32] &= ~mask;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\AAInfoData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Logic
{
    public class AAInfoData : IAAInfoData
    {
        public string CertThumbprint { get; set; }
        public string IpAddressInternet{ get; set; }

        public string CertDeviceId{ get; set; }
       
        public DateTime? IssueInstant{ get; set; }
        public DateTime? NotAfter{ get; set; }
        public System.Net.IPAddress OriginatingIP{ get; set; }
        public ulong? PassportCId{ get; set; }
        public ulong PassportPuid{ get; set; }
        public string SamlToken{ get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\Factories\AvatarFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Logic.Avatars;
using xonline.common.service;
using System.Globalization;

namespace Leet.Live.Livecache.DataAccess.Factories
{
    public class AvatarFactory
    {
        private static Guid AvatarBodyAssetMaleId = new Guid(0x00000002, 0x0000, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
        private static Guid AvatarBodyAssetFemaleId = new Guid(0x00000002, 0x0001, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);

        // TODO: Refactor and Integrate

        /*
        public static string MakeRelativeUrlFromGuid(Guid avatarAsset)
        {
            string assetsPath = "";
            string marketPlacePath = "";
            string assetsExt = ".bin";
            string relPath;

            byte[] assetId = avatarAsset.ToByteArray();

            if (assetId[8] == 0xc1 && assetId[9] == 0xc8)
            {
                relPath = assetsPath + avatarAsset.ToString().ToUpper(CultureInfo.InvariantCulture) + assetsExt;
            }

            else
            {
                relPath = marketPlacePath + avatarAsset.ToString().ToUpper(CultureInfo.InvariantCulture) + assetsExt;
            }

            return relPath;

        }
        */



        public static Avatar MakeAvatar(AvatarManifest manifest, byte[] rawManifest)
        {
            Avatar avatar = new Avatar();

            avatar.RawManifest = rawManifest;

            avatar.Size.HeightFactor = manifest.HeightFactor;
            avatar.Size.WeightFactor = manifest.WeightFactor;

            
            avatar.Body.Id = manifest.BodyComponentInfo.ModelAssetId.Id;
            avatar.Body.AssetUrl = String.Format("http://xboxlive.com/Assets/{0}.bin", avatar.Body.Id.ToString());

            //Body
            if (manifest.BodyComponentInfo.ModelAssetId.Id == AvatarFactory.AvatarBodyAssetMaleId)
            {
                avatar.Body.Type = AvatarBodyType.Male;
            }
            else if (manifest.BodyComponentInfo.ModelAssetId.Id == AvatarFactory.AvatarBodyAssetFemaleId)
            {
                avatar.Body.Type = AvatarBodyType.Female;
            }
            else
            {
                avatar.Body.Type = AvatarBodyType.Unknown;
            }

            //Assets
            for (int i = 0; i < manifest.ComponentInfo.Length; i++)
            {
                if (manifest.ComponentInfo[i].ModelAssetId.Id == Guid.Empty)
                {
                    continue;
                }
                AvatarAsset asset = ExtractAvatarAsset(manifest.ComponentInfo[i]);
                avatar.Assets.Add(asset);
            }

            //Previous Assets
            for (int i = 0; i < manifest.PreviousRequiredComponentInfo.Length; i++)
            {
                AvatarAsset asset = ExtractAvatarAsset(manifest.PreviousRequiredComponentInfo[i]);
                avatar.PreviousAssets.Add(asset);
            }

            //Head
            avatar.Head.Id = manifest.HeadComponentInfo.ModelAssetId.Id;
            avatar.Head.AssetUrl = String.Format("http://xboxlive.com/Assets/{0}.bin", avatar.Head.Id.ToString());

            //Shape Overrides
            foreach (int i in Enum.GetValues(typeof(ShapeType)))
            {
                if (i >= manifest.BlendShapes.Length) { break; }

                AvatarShape shape = new AvatarShape();
                AvatarManifest.BlendShape_c manShape = manifest.BlendShapes[i];

                shape.Id = manShape.BlendShapeAssetId.Id;
                shape.Type = (ShapeType)i;
                shape.AssetUrl = String.Format("http://xboxlive.com/Assets/{0}.bin", shape.Id.ToString());
                avatar.Head.BlendShapes.Add(shape);
            }

            //Textures
            foreach(int i in Enum.GetValues(typeof(TextureType)))
            {
                if (i >= manifest.ReplacementTextures.Length) { break; }

                if (manifest.ReplacementTextures[i].TextureAssetId.Id == Guid.Empty)
                {
                    continue;
                }

                AvatarTexture texture = new AvatarTexture();
                AvatarManifest.ReplacementTexture_c manTexture = manifest.ReplacementTextures[i];

                texture.Id = manTexture.TextureAssetId.Id;
                texture.Rotation = manTexture.Placement.Rotation;
                texture.Scale = manTexture.Placement.Scale;
                texture.TranslationX = manTexture.Placement.Translation[0];
                texture.TranslationY = manTexture.Placement.Translation[1];
                texture.Type = (TextureType)i;

                //TODO: Fix this URL with NPDB data when URL is known.
                texture.AssetUrl = String.Format("http://xboxlive.com/Assets/{0}.bin", texture.Id.ToString());

                //TODO: Fix this URL with TOC data when URL is known.
                texture.AdditionalAssetUrl = null;

                avatar.Textures.Add(texture);
            }

            //Color Settings
            foreach (int i in Enum.GetValues(typeof(ColorType)))
            {
                if (i >= manifest.DynamicColors.Length) { break; }

                FeatureColor aColor = new FeatureColor() { Value = manifest.DynamicColors[i].c, Type = (ColorType)i };

                avatar.FeatureColors.Add(aColor);
            }

            return avatar;
        }

        #region Helper Methods

        private static AvatarAsset ExtractAvatarAsset(AvatarManifest.XAVATAR_COMPONENT_INFO component)
        {
            AvatarAsset asset = new AvatarAsset();

            asset.Slot = (AvatarComponentMasks)component.ComponentMask;
            asset.Id = component.ModelAssetId.Id;

            //TODO: Fix this URL when URL generation is figured out and TOC is implemented.
            asset.AssetUrl = String.Format("http://xboxlive.com/Assets/{0}.bin", asset.Id.ToString());
            asset.OverrideUrl = String.Format("http://xboxlive.com/Assets/Overrides/{0}.bin", asset.Id.ToString());
            for (int i = 0; i < component.CustomColors.Length; i++)
            {
                if (component.CustomColors[i].c != 0)
                {
                    asset.CustomColors.Add(new CustomColor() { Value = component.CustomColors[i].c, Index = i });
                }
            }
            return asset;
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Achievements\AchievementFlags.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Achievements
{
    public enum AchievementType : int
    {
        COMPLETION = 1,
        LEVELING = 2,
        UNLOCK = 3,
        EVENT = 4,
        TOURNAMENT = 5,
        CHECKPOINT = 6,
        OTHER = 7
    }

    /// <summary>
    /// A utility class used to check the flag values on an Xbox LIVE AchievementInfo object.
    /// </summary>
    public class AchievementFlags
    {
        public static int MASK_TYPE = 0x00000007;
        public static int SHOW_UNACHIEVED = 0x00000008;
        public static int ACHIEVED_ONLINE = 0x00010000;
        public static int ACHIEVED = 0x00020000;

        public static bool ShowUnachieved(int flags)
        {
            return (flags & AchievementFlags.SHOW_UNACHIEVED) > 0 ? true : false;
        }

        public static bool Achieved(int flags)
        {
            return AchievementFlags.AchievedOffline(flags) || AchievementFlags.AchievedOnline(flags);
        }

        public static bool AchievedOffline(int flags)
        {
            return (flags & AchievementFlags.ACHIEVED) > 0 ? true : false;
        }

        public static bool AchievedOnline(int flags)
        {
            return (flags & AchievementFlags.ACHIEVED_ONLINE) > 0 ? true : false;
        }

        public static AchievementType Type(int flags)
        {
            return (AchievementType)(flags & AchievementFlags.MASK_TYPE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Achievements\AchievementInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using Leet.Live.Tiles;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using xonline.common.service;

namespace Leet.Live.Livecache.Logic.Achievements
{
    public class AchievementInfo : IReadOnlyAchievementInfo
    {
        private uint gameTitleId = 0;

        public AchievementInfo()
        {
        }

        public AchievementInfo(uint titleId, Achievement lcAchievement)
        {
            this.DateUnlocked = lcAchievement.Achieved;
            this.AchievementId = lcAchievement.AchievementId;
            this.GamerscoreValue = lcAchievement.Cred;
            this.Description = lcAchievement.Description;
            this.Flags = lcAchievement.Flags;
            this.Title = lcAchievement.Title;
            this.Type = lcAchievement.Type;
            this.ImageId = lcAchievement.ImageId;
            this.HowTo = lcAchievement.HowTo;

            gameTitleId = titleId;
        }


        #region IReadOnlyAchievementInfo Members

        public DateTime DateUnlocked { get; set; }
        public uint AchievementId { get; set; }
        public int GamerscoreValue { get; set; }
        public string Description { get; set; }
        public string HowTo { get; set; }
        public int Flags { get; set; }
        public uint ImageId { get; set; }
        public string Title { get; set; }
        public byte Type { get; set; }

        private Uri imageHref = null;
        public Uri ImageHref
        {
            get
            {
                if (imageHref == null)
                {
                    IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
                    string tilesDomain = "http://" + configProvider.GetSetting(Settings.TilesDomainName);

                    Uri href = GetAchievementTileUrl(gameTitleId, this.ImageId, tilesDomain);
                    if (href != null)
                    {
                        imageHref = href;
                    }
                }

                return imageHref;
            }
        }

        private Uri secureImageHref = null;
        public Uri SecureImageHref
        {
            get
            {
                if (secureImageHref == null)
                {
                    IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
                    string tilesDomain = "https://" + configProvider.GetSetting(Settings.TilesDomainName);

                    Uri href = GetAchievementTileUrl(gameTitleId, this.ImageId, tilesDomain);
                    if (href != null)
                    {
                        secureImageHref = href;
                    }
                }

                return secureImageHref;
            }
        }

        // return the AchievementTileUrl based on hidden and achieved flags
        private Uri GetAchievementTileUrl(uint gameTitleId, uint imageId, string tilesDomain)
        {
            bool hidden = this.IsHidden;
            bool achieved = this.IsUnlocked; // in rewards, unlocked achievements are achieved achievements

            if (hidden == true)
            {
                if (achieved == true)
                {
                    // we are sending the Achievement Url regardless of hidden state if it is achieved
                    return TileLocator.Instance.AchievementTileUrl(achieved, gameTitleId, imageId, tilesDomain);
                }
                else
                {
                    // unachieved hidden achievement Url is sent
                    return TileLocator.Instance.UnachievedHiddenAchievementTileUrl(tilesDomain);
                }
            }
            else
            {
                // if achieved = false we send the dimmed image
                // if Achieved = true we send the coloured image
                return TileLocator.Instance.AchievementTileUrl(achieved, gameTitleId, imageId, tilesDomain); 
            }
        }

        public bool IsUnlocked
        {
            get
            {
                return AchievementFlags.Achieved(this.Flags);
            }
        }

        public bool IsHidden
        {
            get
            {
                return !AchievementFlags.ShowUnachieved(this.Flags);
            }
        }

        public bool WasEarnedOnline
        {
            get
            {
                return AchievementFlags.AchievedOnline(this.Flags);
            }
            set
            {
                if (value)
                {
                    this.Flags = AchievementFlags.ACHIEVED |
                                 AchievementFlags.ACHIEVED_ONLINE;
                }
                else
                {
                    this.Flags = AchievementFlags.ACHIEVED;
                }
            }
        }

        public bool WasEarnedOffline
        {
            get
            {
                return AchievementFlags.AchievedOffline(this.Flags);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\SignedWireData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.service;
using System.IO;
using System.Security.Cryptography;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Live.Livecache.Logic.Exceptions;

namespace Leet.Live.Livecache.Logic
{
    public class SignedWireData : WireData
    {
        private static byte[] baseKey = {
                                            0xd8,0x98,0x15,0x5a,0x70,0x34,0x4d,0x38,
                                            0x87,0x69,0x60,0xff,0x5e,0x2e,0xab,0xfb
                                        };

        public virtual HMACSHA1 Seal
        {
            get
            {
                IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
                byte[] key = HexStringToBytes(config.GetSetting(Settings.WebTicketEncryptionKey));

                for (int i = 0; i < baseKey.Length; i++)
                {
                    key[i] += baseKey[i];
                }
                return new HMACSHA1(key);
            }
        }

        public virtual bool FromBytes(byte[] buf)
        {
            MemoryStream stream = new MemoryStream(buf);
            BinaryReader reader = new BinaryReader(stream);

            //_logArea.LogVerbose("parse ticket: {0}", BytesToHexString(buf));

            try
            {
                base.ReadStream(reader);
            }
            catch (xonline.common.service.XRLException ex)
            {
                throw new SignedDataInvalidException("Error reading signed data.", ex);
            }

            int posHashStart = (int)stream.Position;
            byte[] hash = Seal.ComputeHash(buf, 0, posHashStart);

            //_logArea.LogVerbose("compute hash = {0}", BytesToHexString(hash));

            if (hash.Length != buf.Length - posHashStart)
            {
                throw new SignedDataInvalidException(
                    String.Format("Signature not verified: req is {0}, expected {1}.",
                        BytesToHexString(buf, posHashStart),
                        BytesToHexString(hash)));
            }

            for (int i = 0; i < hash.Length; i++)
            {
                if (hash[i] != buf[posHashStart + i])
                {
                    throw new SignedDataInvalidException(
                        String.Format("Signature not verified: req is {0}, expected {1}.",
                            BytesToHexString(buf, posHashStart),
                            BytesToHexString(hash)));
                }
            }

            return true;
        }

        public virtual byte[] ToBytes()
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            base.WriteStream(writer);
            writer.Flush();

            stream.Position = 0;

            byte[] hash = Seal.ComputeHash(stream);

            writer.Write(hash);
            writer.Flush();

            return stream.ToArray();

        }

        //
        // helper functions
        //

        private static string BytesToHexString(byte[] bytes, int start, int len)
        {
            string hexDigit = "0123456789ABCDEF";

            StringBuilder sb = new StringBuilder(3 * len);
            for (int i = 0; i < len; i++)
            {
                int b = (bytes[start + i]);
                sb.Append(hexDigit[b / 16]);
                sb.Append(hexDigit[b % 16]);
                sb.Append(' ');
            }
            return sb.ToString();
        }

        private static string BytesToHexString(byte[] bytes, int start)
        {
            return BytesToHexString(bytes, start, bytes.Length - start);
        }

        private static string BytesToHexString(byte[] bytes)
        {
            return BytesToHexString(bytes, 0);
        }

        private static byte[] HexStringToBytes(string hexString)
        {
            int len = hexString.Length / 2;
            byte[] bytes = new byte[len];
            for (int i = 0; i < len; i++)
            {
                bytes[i] = (byte)(Uri.FromHex(hexString[i * 2]) * 16
                        + Uri.FromHex(hexString[i * 2 + 1]));
            }
            return bytes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Achievements\IReadOnlyAchievementInfo.cs ===
﻿
namespace Leet.Live.Livecache.Logic.Achievements
{
    using System;

    public interface IReadOnlyAchievementInfo
    {
        DateTime DateUnlocked { get; set; }
        uint AchievementId { get; set; }
        int GamerscoreValue { get; }
        string Description { get; }
        string HowTo { get; }
        int Flags { get; }
        uint ImageId { get; }
        Uri ImageHref { get; }
        Uri SecureImageHref { get; }
        string Title { get; }
        byte Type { get; }
        bool IsHidden { get; }
        bool IsUnlocked { get; }
        bool WasEarnedOnline { get; set; }
        bool WasEarnedOffline { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\InvalidMessageException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    public class InvalidMessageException : Exception
    {
        public InvalidMessageException(uint messageId, ulong userPuid)
            : base (String.Format("Message id does not exist for the user.\r\nUserPuid = '{0}', messageId = {1}.", userPuid.ToString("X"), messageId.ToString()))
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Avatars\AvatarAsset.cs ===
﻿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Leet.Live.Livecache.Logic.Avatars
{
    /// <summary>
    /// This class defines metadata relevant for retrieving and processing a 3D avatar asset
    /// </summary>
    [DataContract]
    public class AvatarAsset
    {
        public AvatarAsset()
        {
            CustomColors = new List<CustomColor>();
        }

        [DataMember(IsRequired = true, Name = "Id", Order = 0)]
        public Guid Id { get; set; }

        [DataMember(IsRequired = true, Name = "Slot", Order = 1)]
        public AvatarComponentMasks Slot { get; set; }

        [DataMember(IsRequired = true, Name = "AssetUrl", Order = 2)]
        public string AssetUrl { get; set; }

        [DataMember(IsRequired = false, Name = "OverrideUrl", Order = 3)]
        public string OverrideUrl { get; set; }

        [DataMember(IsRequired = true, Name = "CustomColors", Order = 4)]
        public List<CustomColor> CustomColors { get; set; }
    }

    /// <summary>
    /// This class defines metadata relevant for retrieving and processing an avatar blendshape
    /// </summary>
    [DataContract]
    public class AvatarShape
    {
        [DataMember(IsRequired = true, Name = "Id", Order = 0)]
        public Guid Id { get; set; }

        [DataMember(IsRequired = true, Name = "Type", Order = 1)]
        public ShapeType Type { get; set; }

        [DataMember(IsRequired = true, Name = "AssetUrl", Order = 2)]
        public string AssetUrl { get; set; }
    }

    /// <summary>
    /// This class defines metadata relevant for retrieving and processing an avatar texture 
    /// </summary>
    [DataContract]
    public class AvatarTexture
    {
        [DataMember(IsRequired = true, Name = "Id", Order = 0)]
        public Guid Id { get; set; }

        [DataMember(IsRequired = true, Name = "Type", Order = 1)]
        public TextureType Type { get; set; }

        [DataMember(IsRequired = true, Name = "AssetUrl", Order = 2)]
        public string AssetUrl { get; set; }

        [DataMember(IsRequired = false, Name = "AdditionalAssetUrl", Order = 3)]
        public string AdditionalAssetUrl { get; set; }

        [DataMember(IsRequired = true, Name = "Rotation", Order = 4)]
        public float Rotation { get; set; }

        [DataMember(IsRequired = true, Name = "Scale", Order = 5)]
        public float Scale { get; set; }

        [DataMember(IsRequired = true, Name = "TranslationX", Order = 6)]
        public float TranslationX { get; set; }

        [DataMember(IsRequired = true, Name = "TranslationY", Order = 7)]
        public float TranslationY { get; set; }
    }

    /// <summary>
    /// This class defines constants used to determine the height and weight of an avatar.
    /// </summary>
    [DataContract]
    public class AvatarSize
    {
        [DataMember(IsRequired = true, Name = "HeightFactor", Order = 0)]
        public float HeightFactor { get; set; }

        [DataMember(IsRequired = true, Name = "WeightFactor", Order = 1)]
        public float WeightFactor { get; set; }
    }

    [DataContract]
    public class AvatarBody
    {
        [DataMember(IsRequired = true, Name = "Id", Order = 0)]
        public Guid Id { get; set; }

        [DataMember(IsRequired = true, Name = "Type", Order = 1)]
        public AvatarBodyType Type { get; set; }

        [DataMember(IsRequired = true, Name = "AssetUrl", Order = 2)]
        public string AssetUrl { get; set; }
    }

    [DataContract]
    public class AvatarHead
    {
        public AvatarHead()
        {
            BlendShapes = new List<AvatarShape>();
        }

        [DataMember(IsRequired = true, Name = "Id", Order = 0)]
        public Guid Id { get; set; }

        [DataMember(IsRequired = true, Name = "AssetUrl", Order = 1)]
        public string AssetUrl { get; set; }

        [DataMember(IsRequired = true, Name = "BlendShapes", Order = 2)]
        public List<AvatarShape> BlendShapes { get; set; }
    }

    [DataContract]
    public class FeatureColor
    {
        [DataMember(IsRequired = true, Name = "Type", Order = 0)]
        public ColorType Type { get; set; }

        [DataMember(IsRequired = true, Name = "Value", Order = 1)]
        public uint Value { get; set; }        
    }

    [DataContract]
    public class CustomColor
    {
        [DataMember(IsRequired = true, Name = "Index", Order = 0)]
        public int Index { get; set; }

        [DataMember(IsRequired = true, Name = "Value", Order = 1)]
        public uint Value { get; set; }
    }

    #region Enums


    [FlagsAttribute]
    public enum AvatarComponentMasks : ushort
    {
        None = 0,
        Head = 1,
        Body = 2,
        Hair = 4,
        Shirt = 8,
        Trousers = 0x10,
        Shoes = 0x20,
        Hat = 0x40,
        Gloves = 0x80,
        Glasses = 0x100,
        Wristwear = 0x200,
        Earrings = 0x400,
        Ring = 0x800,
        Carryable = 0x1000,
        All = 0x1FFF
    }


    public enum ColorType : int
    {
        Skin = 0,
        Hair = 1,
        Mouth = 2,
        Iris = 3,
        EyeBrow = 4,
        EyeShadow = 5,
        FacialHair = 6,
        SkinFeatures1 = 7,
        SkinFeatures2 = 8
    }

    public enum ShapeType : int
    {
        Chin = 0,
        Nose = 1,
        Ear = 2
    }

    public enum TextureType : int
    {
        Mouth = 0,
        Eye = 1,
        EyeBrow = 2,
        FacialHair = 3,
        EyeShadow = 4,
        SkinFeatures = 5
    }

    public enum AvatarBodyType : int
    {
        Unknown = 0,
        Male = 1,
        Female = 2,
        All = 3,
    }

    #endregion


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\LeetLivecacheResponseException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    public class LeetLivecacheResponseException : Exception
    {
        public LeetLivecacheResponseException(LivecacheResponseException ex) : base("A Livecache exception was thrown.", ex)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\LeetLiveCacheConfigException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    public class LeetLivecacheConfigException : Exception
    {
        public LeetLivecacheConfigException(LivecacheConfigException ex)
            : base("A Livecache configuration exception was thrown.", ex)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Avatars\Avatar.cs ===
﻿using System;
using System.Xml.Serialization;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using xonline.common.service;
using System.Runtime.Serialization;

namespace Leet.Live.Livecache.Logic.Avatars
{
    
    [DataContract]
    public class Avatar
    {
        
        public Avatar()
        {
            Version = "1.0";
            Assets = new List<AvatarAsset>();
            Textures = new List<AvatarTexture>();
            FeatureColors = new List<FeatureColor>();
            PreviousAssets = new List<AvatarAsset>();

            Body = new AvatarBody();
            Head = new AvatarHead();
            Size = new AvatarSize();
        }

        [DataMember(IsRequired= true, Name="RawManifest", Order=8)]
        public byte[] RawManifest { get; set; }

        [DataMember(IsRequired = true, Name = "Version", Order = 0)]
        public string Version { get; set; }

        [DataMember(IsRequired = true, Name = "Size", Order = 1)]
        public AvatarSize Size { get; set; }
        
        [DataMember(IsRequired=true, Name="Body", Order=2)]
        public AvatarBody Body { get;  set; }

        [DataMember(IsRequired = true, Name = "Head", Order = 3)]
        public AvatarHead Head { get;  set; }

        [DataMember(IsRequired = true, Name = "Assets", Order = 4)]
        public List<AvatarAsset> Assets { get;  set; }

        [DataMember(IsRequired = true, Name = "Textures", Order = 5)]
        public List<AvatarTexture> Textures { get;  set; }

        [DataMember(IsRequired = true, Name = "FeatureColors", Order = 6)]
        public List<FeatureColor> FeatureColors { get;  set; }

        [DataMember(IsRequired = true, Name = "PreviousAssets", Order = 7)]
        public List<AvatarAsset> PreviousAssets { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Avatars\AvatarAssetFlags.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Avatars
{
    /// <summary>
    /// A utility class used to check the flag values on an Xbox LIVE AvatarAsset object.
    /// </summary>
    public class AvatarAssetFlags
    {
        // XBOX online still uses these these constants as Achieved instead of earned so we should keep it that way
        public static int SHOW_UNACHIEVED = 0x00000008;
        public static int ACHIEVED_ONLINE = 0x00010000;
        public static int ACHIEVED = 0x00020000;

        public static bool ShowUnachieved(int flags)
        {
            return (flags & AvatarAssetFlags.SHOW_UNACHIEVED) > 0 ? true : false;
        }

        public static bool Achieved(int flags)
        {
            return AvatarAssetFlags.AchievedOffline(flags) || AvatarAssetFlags.AchievedOnline(flags);
        }

        public static bool AchievedOffline(int flags)
        {
            return (flags & AvatarAssetFlags.ACHIEVED) > 0 ? true : false;
        }

        public static bool AchievedOnline(int flags)
        {
            return (flags & AvatarAssetFlags.ACHIEVED_ONLINE) > 0 ? true : false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\LeetLivecacheThrottledException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    class LeetLivecacheThrottledException: Exception
    {
        public LeetLivecacheThrottledException(LivecacheUserThrottledException ex)
            : base("A Livecache throttled exception was thrown.", ex)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\SendMessageThrottleException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    public class SendMessageThrottleException : Exception
    {
        public SendMessageThrottleException(ulong senderLivePuid)
            : base(String.Format("Message not sent from livepuid {0} because user is sending messages too quickly.", senderLivePuid.ToString("X8"))) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\SignedDataInvalidException.cs ===
﻿using System;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    public class SignedDataInvalidException : Exception
    {
        public SignedDataInvalidException(string message)
        {
        }

        public SignedDataInvalidException(string message, Exception e)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Exceptions\MessageNotSentException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Exceptions
{
    public class MessageNotSentException : Exception
    {
        public MessageNotSentException(uint hr)
            : base(String.Format("Message not sent.  HResult={0}", hr)) { }


        public MessageNotSentException(uint hr, ulong senderLivePuid)
            : base(String.Format("Message not sent sent from livepuid {0}.  HResult={1}", senderLivePuid.ToString("X8"), hr)) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Games\IReadOnlyUserTitle.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Games
{
    public interface IReadOnlyUserTitle
    {
        DateTime LastPlayed { get; }
        ushort EarnedAchievements { get; }
        uint EarnedGamerscore { get; }
        uint Reserved { get; }
        uint Sequence { get; }
        uint TitleId { get; }
        string TitleName { get; }
        ushort TotalAchievements { get; }
        uint TotalGamerscore { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\IReadOnlyMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public interface IReadOnlyMessage
    {
        IReadOnlyMessageHeader Header { get; }
        string Text { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Games\UserTitle.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;


namespace Leet.Live.Livecache.Logic.Games
{
    public class UserTitle : IReadOnlyUserTitle
    {
        public UserTitle()
        {
        }

        public UserTitle(xonline.common.protocol.UserTitle userTitle)
        {
            this.EarnedAchievements = userTitle.NumAchievements;
            this.EarnedGamerscore = userTitle.NumCreds;
            this.LastPlayed = userTitle.LastPlayed;
            this.Reserved = 0;
            this.Sequence = userTitle.Sequence;
            this.TitleId = userTitle.TitleId;
            this.TitleName = userTitle.TitleName;
            this.TotalAchievements = userTitle.TotalAchievements;
            this.TotalGamerscore = userTitle.TotalCred;
        }

        #region IReadOnlyUserTitle Members
        public DateTime LastPlayed {get; set;}
        public ushort EarnedAchievements {get; set;}
        public uint EarnedGamerscore { get; set; }
        public uint Reserved { get; set; }
        public uint Sequence { get; set; }
        public uint TitleId { get; set; }
        public string TitleName { get; set; }
        public ushort TotalAchievements { get; set; }
        public uint TotalGamerscore { get; set; }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\IReadOnlySystemMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public interface IReadOnlySystemMessage
    {
        IReadOnlySystemMessageHeader Header { get; }
        uint StringId { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\IReadOnlyMessageHeader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public interface IReadOnlyMessageHeader
    {
        MessageTypeEnum MessageType { get; }
        IGamerProfile UserProfileSettings { get; }
        bool IsRequired { get; }
        bool IsRecommended { get; }
        bool HasVoice { get; }
        bool HasImage { get; }
        bool HasText { get; }
        bool HasBeenRead { get; }
        bool AllowDisplayOnWeb { get; }
        bool IsTeamContext { get; }
        bool IsCompetitionContext { get; }
        bool IsFromAlternateTitle { get; }
        bool IsFromMarketing { get; }
        bool IsFromMicrosoftMarketing { get; }
        bool IsFromFriend { get; }
        bool IsFromZune { get; }
        ulong SenderId { get; }
        string SenderGamertag { get; }
        uint MessageId { get; }
        uint SenderTitleId { get; }
        DateTime SentTime { get; }
        int Expires { get; }
        int ExpiresInDays { get; }
        string Subject { get; }
        bool CanDelete { get; }
        bool CanSetReadFlag { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\Message.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using System.IO;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public class Message : IReadOnlyMessage
    {
        private IReadOnlyMessageHeader m_header;
        private string text = "";

        public Message(MessageSummary2 summary, MessageDetails details)
        {
            if (details != null)
            {
                int offset = 0;

                byte[] data = details.rgbData;

                // find the text value
                for (int i = 0; i < details.wPropCount; i++)
                {
                    if (details.rgProperties[i].wPropTag == MsgDefs.XONLINE_MSG_PROP_TEXT)
                    {
                        offset = details.rgProperties[i].wPropOffset;

                        System.IO.Stream stream = new System.IO.MemoryStream();
                        int sizeOfUShort = System.Runtime.InteropServices.Marshal.SizeOf(typeof(ushort));

                        // find out the length of this property
                        stream.Write(data, offset, sizeOfUShort);
                        stream.Position = 0;
                        System.IO.BinaryReader reader = new BinaryReader(stream);
                        // size of string + size of ushort
                        int length = (int)reader.ReadUInt16() + sizeOfUShort;

                        byte[] strdata = new byte[length];
                        for (int j = 0; j < length; j++)
                        {
                            strdata[j] = data[offset + j];
                        }

                        MessageStringProperty str = new MessageStringProperty();
                        str.ReadBytes(strdata);

                        this.text = str.szString;
                    }
                }
            }

            int subjectLength = Math.Min(this.text.Length, (int)MsgDefs.XONLINE_MAX_SUBJECT_SIZE);
            summary.szSubject = this.text.Substring(0, subjectLength);

            this.m_header = new MessageHeader(summary);
        }

        public IReadOnlyMessageHeader Header
        {
            get { return this.m_header; }
        }

        public string Text
        {
            get { return this.text; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\MessageTypeEnum.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public enum MessageTypeEnum
    {
        TitleCustom = MsgDefs.XONLINE_MSG_TYPE_TITLE_CUSTOM,
        FriendRequest = MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
        GameInvite = MsgDefs.XONLINE_MSG_TYPE_GAME_INVITE,
        TeamRecruit = MsgDefs.XONLINE_MSG_TYPE_TEAM_RECRUIT,
        CompetitionReminder = MsgDefs.XONLINE_MSG_TYPE_COMP_REMINDER,
        CompetitionRequest = MsgDefs.XONLINE_MSG_TYPE_COMP_REQUEST,
        LiveMessage = MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
        PersonalMessage = MsgDefs.XONLINE_MSG_TYPE_PERSONAL_MESSAGE,
        VideoMessage = MsgDefs.XONLINE_MSG_TYPE_VIDEO_MESSAGE,
        QuickChatInvite = MsgDefs.XONLINE_MSG_TYPE_QUICK_CHAT_INVITE,
        VideoChatInvite = MsgDefs.XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE,
        PartyInvite = MsgDefs.XONLINE_MSG_TYPE_PARTY_CHAT_INVITE,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\IReadOnlySystemMessageHeader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public interface IReadOnlySystemMessageHeader
    {
        MessageTypeEnum MessageType { get; }
        bool IsRequired { get; }
        bool IsRecommended { get; }
        bool HasVoice { get; }
        bool HasText { get; }
        bool HasBeenRead { get; }
        bool AllowDisplayOnWeb { get; }
        bool IsTeamContext { get; }
        bool IsCompetitionContext { get; }
        bool IsFromAlternateTitle { get; }
        bool IsFromMarketing { get; }
        bool IsFromMicrosoftMarketing { get; }
        bool IsFromFriend { get; }
        uint Region { get; }
        string SenderName { get; }
        uint MessageId { get; }
        uint TitleId { get; }
        DateTime SentTime { get; }
        ushort Expires { get; }
        string Description { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\SystemMessageHeader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public class SystemMessageHeader : IReadOnlySystemMessageHeader
    {
        private SystemMessageSummary m_summary;

        public SystemMessageHeader(SystemMessageSummary summary)
        {
            this.m_summary = summary;
        }

        public MessageTypeEnum MessageType
        {
            get { return (MessageTypeEnum)(this.m_summary.bMessageType); }
        }

        public bool IsRequired
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_REQUIRED) > 0; }
        }

        public bool IsRecommended
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED) > 0; }
        }

        public bool HasVoice
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_VOICE) > 0; }
        }

        public bool HasText
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_TEXT) > 0; }
        }

        public bool HasBeenRead
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_READ) > 0; }
        }

        public bool AllowDisplayOnWeb
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_NON_EXPORTABLE) == 0; }
        }

        public bool IsTeamContext
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_TEAM_CONTEXT) > 0; }
        }

        public bool IsCompetitionContext
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_COMP_CONTEXT) > 0; }
        }

        public bool IsFromAlternateTitle
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_ALTERNATE_TITLE) > 0; }
        }

        public bool IsFromMarketing
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_MARKETING) > 0; }
        }

        public bool IsFromMicrosoftMarketing
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_MS_MARKETING) > 0; }
        }

        public bool IsFromFriend
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_SENDER_IS_FRIEND) > 0; }
        }

        public uint Region
        {
            get { return this.m_summary.dwRegion; }
        }

        public string SenderName
        {
            get { return this.m_summary.szSenderName; }
        }

        public uint MessageId
        {
            get { return this.m_summary.dwMessageID; }
        }

        public uint TitleId
        {
            get { return this.m_summary.dwTitleID; }
        }

        public DateTime SentTime
        {
            get
            {
                return this.m_summary.dtSentTime;
            }
        }

        public ushort Expires
        {
            get { return this.m_summary.wExp