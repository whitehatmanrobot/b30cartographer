OFROMSEG;
						pTransition->m_pToSegment = NULL;
					}
					else
					{
						pTransition->m_dwToSegmentFlag = 0;
						pTransition->m_fResolveToSegmentID = true;
						pTransition->m_dwToSegmentID = dmusTransitionIO.dwSegmentID;
					}
					if( dmusTransitionIO.dwTransitionID == DMUS_SONG_NOSEG )
					{
						pTransition->m_fResolveTransitionSegmentID = false;
						pTransition->m_pTransitionSegment= NULL;
					}
					else
					{
						pTransition->m_fResolveTransitionSegmentID = true;
						pTransition->m_dwTransitionSegmentID = dmusTransitionIO.dwTransitionID;
					}
					pTransition->m_dwPlayFlagsDM = dmusTransitionIO.dwPlayFlags;
					m_lstTransitions.AddTail( pTransition );

					dwSize -= dwByteCount;
				}
				break;
			}

			case DMUS_FOURCC_TRANSITION_COPY_PASTE_UI_CHUNK:
			{
				ioTransitionCopyPasteUI iTransitionCopyPasteUI;
				CTransition* pTransition;

				dwSize = ck.cksize;
				while( dwSize > 0 )
				{
					hr = pIStream->Read( &iTransitionCopyPasteUI, sizeof(ioTransitionCopyPasteUI), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(ioTransitionCopyPasteUI) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					pTransition = new CTransition( m_pSong );
					if( pTransition == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}

					pTransition->m_dwToSegmentFlag = iTransitionCopyPasteUI.dwToSegmentFlag;
					pTransition->m_pToSegment = m_pSong->PtrToVirtualSegment( iTransitionCopyPasteUI.pToSegment );
					if( pTransition->m_pToSegment )
					{
						ASSERT( pTransition->m_dwToSegmentFlag == 0 ); 
						pTransition->m_pToSegment->AddRef();
					}
					else
					{
						// No "To Segment" so we must have a value in m_dwToSegmentFlag
						if( pTransition->m_dwToSegmentFlag == 0 )
						{
							pTransition->m_dwToSegmentFlag = DMUS_SONG_NOSEG;
						}
					}
					pTransition->m_pTransitionSegment = m_pSong->PtrToVirtualSegment( iTransitionCopyPasteUI.pTransitionSegment );
					if( pTransition->m_pTransitionSegment )
					{
						pTransition->m_pTransitionSegment->AddRef();
					}
					pTransition->m_dwPlayFlagsDM = iTransitionCopyPasteUI.dwPlayFlagsDM;
					m_lstTransitions.AddTail( pTransition );

					dwSize -= dwByteCount;
				}
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_TRACKREFS_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_TRACKREF_LIST:
										{
											CTrack* pTrack = new CTrack( m_pSong );
											if( pTrack == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}

											hr = pTrack->Load( pIRiffStream, &ck );
											if( hr == S_OK )
											{
												InsertTrack( pTrack );
												RELEASE( pTrack );
											}
											else if( hr == S_FALSE )
											{
												// Could not resolve SourceSegment so discard this track
												RELEASE( pTrack );
												hr = S_OK;
											}
											else
											{
												RELEASE( pTrack );
												goto ON_ERROR;
											}
											break;
										}
									}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

	long lMeasure, lBeat, lGrid, lTick;
	if( SUCCEEDED ( ClocksToMeasureBeatGridTick( m_mtLength_SEGH, &lMeasure, &lBeat, &lGrid, &lTick ) ) )
	{
		m_VirtualSegmentUI.dwNbrMeasures = lMeasure;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveTransitionList
    
HRESULT CVirtualSegment::SaveTransitionList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	POSITION pos;
	DMUS_IO_TRANSITION_DEF dmusTransitionIO;

	if( m_lstTransitions.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_SEGTRANS_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	pos = m_lstTransitions.GetHeadPosition();
	while( pos )
	{
		CTransition* pTransition = m_lstTransitions.GetNext( pos );

		// Prepare DMUS_IO_TRANSITION_DEF structure
		memset( &dmusTransitionIO, 0, sizeof(DMUS_IO_TRANSITION_DEF) );

		if( pTransition->m_pToSegment )
		{
			ASSERT( pTransition->m_dwToSegmentFlag == 0 );
			dmusTransitionIO.dwSegmentID = m_pSong->VirtualSegmentToIndex( pTransition->m_pToSegment );
		}
		else
		{
			// No "To Segment" so we must have a value in m_dwToSegmentFlag
			if( pTransition->m_dwToSegmentFlag == 0 )
			{
				pTransition->m_dwToSegmentFlag = DMUS_SONG_NOSEG;
			}
			dmusTransitionIO.dwSegmentID = pTransition->m_dwToSegmentFlag;
		}
		if( pTransition->m_pTransitionSegment )
		{
			dmusTransitionIO.dwTransitionID = m_pSong->VirtualSegmentToIndex( pTransition->m_pTransitionSegment );
		}
		else
		{
			dmusTransitionIO.dwTransitionID = DMUS_SONG_NOSEG;
		}
		dmusTransitionIO.dwPlayFlags = pTransition->m_dwPlayFlagsDM;

		// Write Transition chunk data
		hr = pIStream->Write( &dmusTransitionIO, sizeof(DMUS_IO_TRANSITION_DEF), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_TRANSITION_DEF) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveTrackList
    
HRESULT CVirtualSegment::SaveTrackList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ckMain;
	POSITION pos;

	if( m_lstTracks.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO DMUS_FOURCC_TRACKREFS_LIST header
	ckMain.fccType = DMUS_FOURCC_TRACKREFS_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save all tracks
	pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		CTrack* pTrack = m_lstTracks.GetNext( pos );

		hr = pTrack->Save( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveInfoList
    
HRESULT CVirtualSegment::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write VirtualSegment name
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveCopyPasteUI
    
HRESULT CVirtualSegment::SaveCopyPasteUI( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	ioVirtualSegmentCopyPasteUI oVirtualSegmentCopyPasteUI;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_VIRTUAL_SEGMENT_COPY_PASTE_UI_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioVirtualSegmentCopyPasteUI structure
	memset( &oVirtualSegmentCopyPasteUI, 0, sizeof(ioVirtualSegmentCopyPasteUI) );

	oVirtualSegmentCopyPasteUI.pSourceSegment = m_pSourceSegment;
	oVirtualSegmentCopyPasteUI.pIToolGraphNode = m_pIToolGraphNode;

	// Write ioVirtualSegmentCopyPasteUI structure
	hr = pIStream->Write( &oVirtualSegmentCopyPasteUI, sizeof(ioVirtualSegmentCopyPasteUI), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioVirtualSegmentCopyPasteUI) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveUI
    
HRESULT CVirtualSegment::SaveUI( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_VIRTUAL_SEGMENT_UI_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write UI chunk data
	hr = pIStream->Write( &m_VirtualSegmentUI, sizeof(ioVirtualSegmentUI), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioVirtualSegmentUI) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveSourceHeader

HRESULT CVirtualSegment::SaveSourceHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_SEGMENT_HEADER dmusSegHeaderIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_SEGMENT_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_SEGREF_HEADER structure
	memset( &dmusSegHeaderIO, 0, sizeof(DMUS_IO_SEGMENT_HEADER) );

	dmusSegHeaderIO.dwRepeats = m_dwRepeats_SEGH;
	dmusSegHeaderIO.mtLength = m_mtLength_SEGH;
	dmusSegHeaderIO.mtPlayStart = m_mtPlayStart_SEGH;
	dmusSegHeaderIO.mtLoopStart = m_mtLoopStart_SEGH;
	dmusSegHeaderIO.mtLoopEnd = m_mtLoopEnd_SEGH;
	dmusSegHeaderIO.dwResolution = m_dwResolution_SEGH;
	dmusSegHeaderIO.rtLength = m_rtLength_SEGH;
	dmusSegHeaderIO.dwFlags = m_dwFlags_SEGH;

	// Write SourceSegment header data
	hr = pIStream->Write( &dmusSegHeaderIO, sizeof(DMUS_IO_SEGMENT_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_SEGMENT_HEADER) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveVirtualHeader
    
HRESULT CVirtualSegment::SaveVirtualHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_SEGREF_HEADER dmusSegRefIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_SEGREF_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_SEGREF_HEADER structure
	memset( &dmusSegRefIO, 0, sizeof(DMUS_IO_SEGREF_HEADER) );

	dmusSegRefIO.dwID = m_pSong->VirtualSegmentToIndex( this );
	if( m_pSourceSegment )
	{
		dmusSegRefIO.dwSegmentID = m_pSong->SourceSegmentToIndex( m_pSourceSegment );
	}
	else
	{
		dmusSegRefIO.dwSegmentID = DMUS_SONG_NOSEG;
	}
	if( m_pIToolGraphNode )
	{
		dmusSegRefIO.dwToolGraphID = m_pSong->ToolGraphToIndex( m_pIToolGraphNode );
	}
	else
	{
		dmusSegRefIO.dwToolGraphID = DMUS_SONG_NOSEG;
	}
	if( m_pNextVirtualSegment )
	{
		dmusSegRefIO.dwNextPlayID = m_pSong->VirtualSegmentToIndex( m_pNextVirtualSegment );
	}
	else
	{
		dmusSegRefIO.dwNextPlayID = DMUS_SONG_NOSEG;
	}
	dmusSegRefIO.dwFlags = 0;			// Not used

	// Write VirtualSegment header data
	hr = pIStream->Write( &dmusSegRefIO, sizeof(DMUS_IO_SEGREF_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_SEGREF_HEADER) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveSongGuidUI
    
HRESULT CVirtualSegment::SaveSongGuidUI( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_SONG_GUID_UI_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Song GUID
	GUID guidSong;
	m_pSong->GetGUID( &guidSong );
	hr = pIStream->Write( &guidSong, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveSelectedTransitions

HRESULT CVirtualSegment::SaveSelectedTransitions( IDMUSProdRIFFStream* pIRiffStream, bool fSaveAll )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	POSITION pos;
	ioTransitionCopyPasteUI oTransitionCopyPasteUI;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Save Song GUID UI chunk
	// Used for copy/paste of Transitions
	hr = SaveSongGuidUI( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	{
		// Write DMUS_FOURCC_TRANSITION_COPY_PASTE_UI_CHUNK header
		ck.ckid = DMUS_FOURCC_TRANSITION_COPY_PASTE_UI_CHUNK;
		if( pIRiffStream->CreateChunk(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Save selected Transitions
		pos = m_lstTransitions.GetHeadPosition();
		while( pos )
		{
			CTransition* pTransition = m_lstTransitions.GetNext( pos );

			if( (pTransition->m_dwBitsUI & BF_SELECTED)
			||   fSaveAll )
			{
				// Prepare ioTransitionCopyPasteUI structure
				memset( &oTransitionCopyPasteUI, 0, sizeof(ioTransitionCopyPasteUI) );

				if( pTransition->m_pToSegment == NULL )
				{
					// No "To Segment" so we must have a value in m_dwToSegmentFlag
					if( pTransition->m_dwToSegmentFlag == 0 )
					{
						pTransition->m_dwToSegmentFlag = DMUS_SONG_NOSEG;
					}
				}
				oTransitionCopyPasteUI.dwToSegmentFlag = pTransition->m_dwToSegmentFlag;
				oTransitionCopyPasteUI.pToSegment = pTransition->m_pToSegment;
				oTransitionCopyPasteUI.pTransitionSegment = pTransition->m_pTransitionSegment;
				oTransitionCopyPasteUI.dwPlayFlagsDM = pTransition->m_dwPlayFlagsDM;

				// Write Transition chunk data
				hr = pIStream->Write( &oTransitionCopyPasteUI, sizeof(ioTransitionCopyPasteUI), &dwBytesWritten);
				if( FAILED( hr )
				||  dwBytesWritten != sizeof(ioTransitionCopyPasteUI) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveSelectedTracks

HRESULT CVirtualSegment::SaveSelectedTracks( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	POSITION pos;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Save Song GUID UI chunk
	// Used for copy/paste of Tracks
	hr = SaveSongGuidUI( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	{
		// Write DMUS_FOURCC_TRACKREFS_LIST header
		ckMain.fccType = DMUS_FOURCC_TRACKREFS_LIST;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Save selected Tracks
		pos = m_lstTracks.GetHeadPosition();
		while( pos )
		{
			CTrack* pTrack = m_lstTracks.GetNext( pos );

			if( pTrack->m_dwBitsUI & BF_SELECTED )
			{
				hr = pTrack->Save( pIRiffStream );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}

		if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment SaveVirtualSegment

HRESULT CVirtualSegment::SaveVirtualSegment( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Save VirtualSegment header chunk
	hr = SaveVirtualHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save SourceSegment header chunk
	hr = SaveSourceHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save Song GUID UI chunk
	// Used for drag/drop and copy/paste of Tracks and Transitions
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		hr = SaveSongGuidUI( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save UI chunk
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		hr = SaveUI( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save Copy/Paste UI chunk
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedVirtualSegments ) )
		{
			hr = SaveCopyPasteUI( pIRiffStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

	// Save UNFO list
	hr = SaveInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save Transition list
	if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedVirtualSegments ) )
	{
		// Save Copy/Paste version of Transition list
		hr = SaveSelectedTransitions( pIRiffStream, true );
	}
	else
	{
		hr = SaveTransitionList( pIRiffStream );
	}
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save Track list
	hr = SaveTrackList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment Save

HRESULT CVirtualSegment::Save( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Write DMUS_FOURCC_SEGREF_LIST header
	ckMain.fccType = DMUS_FOURCC_SEGREF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedTracks ) )
	{
		// Copy/paste tracks
		hr = SaveSelectedTracks( pIRiffStream );
	}
	else if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedTransitions ) )
	{
		// Copy/paste transitions
		hr = SaveSelectedTransitions( pIRiffStream, false );
	}
	else
	{
		hr = SaveVirtualSegment( pIRiffStream );
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


///////////////////////////////////////////////////////////////////////////
// CVirtualSegment::EmptyTrackList

void CVirtualSegment::EmptyTrackList( void )
{
	CTrack* pTrack;

	while( !m_lstTracks.IsEmpty() )
	{
		pTrack = m_lstTracks.RemoveHead();

		RELEASE( pTrack );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::InsertTrack

void CVirtualSegment::InsertTrack( CTrack* pTrackToInsert )
{
	if( pTrackToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// If this is a sequence track
	if( CLSID_DirectMusicSeqTrack == pTrackToInsert->m_clsidTrack )
	{
		// Check if we already have a sequence track in this track group
		POSITION pos = m_lstTracks.GetHeadPosition();
		while( pos )
		{
			CTrack *pTmpTrack = m_lstTracks.GetNext( pos );

			if( (CLSID_DirectMusicSeqTrack == pTmpTrack->m_clsidTrack)
			&&	(pTrackToInsert->m_dwGroup == pTmpTrack->m_dwGroup)
			&&	(pTrackToInsert->m_pSourceSegment == pTmpTrack->m_pSourceSegment) )
			{
				// Don't insert the track, since one already exists in the same group
				return;
			}
		}

		// The sequence track's position is always 0
		pTrackToInsert->m_dwPosition = 0;
	}

	pTrackToInsert->AddRef();

	// Place Track in m_lstTracks
	m_lstTracks.AddTail( pTrackToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::RemoveTrack

void CVirtualSegment::RemoveTrack( CTrack* pTrackToRemove )
{
	if( pTrackToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// If item is in m_lstTracks, remove it
	POSITION pos = m_lstTracks.Find( pTrackToRemove );
	if( pos )
	{
		m_lstTracks.RemoveAt( pos );

		RELEASE( pTrackToRemove );
	}
}


///////////////////////////////////////////////////////////////////////////
// CVirtualSegment::EmptyTransitionList

void CVirtualSegment::EmptyTransitionList( void )
{
	CTransition* pTransition;

	while( !m_lstTransitions.IsEmpty() )
	{
		pTransition = m_lstTransitions.RemoveHead();

		RELEASE( pTransition );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::InsertTransition

void CVirtualSegment::InsertTransition( CTransition* pTransitionToInsert )
{
	if( pTransitionToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	pTransitionToInsert->AddRef();

	m_lstTransitions.AddTail( pTransitionToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::RemoveTransition

void CVirtualSegment::RemoveTransition( CTransition* pTransitionToRemove )
{
	if( pTransitionToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// If item is in m_lstTransitions, remove it
	POSITION pos = m_lstTransitions.Find( pTransitionToRemove );
	if( pos )
	{
		m_lstTransitions.RemoveAt( pos );

		RELEASE( pTransitionToRemove );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::ClocksToMeasureBeatGridTick

HRESULT	CVirtualSegment::ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick )
{
	long lMeasure = -1;
	long lBeat = -1;
	long lGrid = -1;
	long lTick = -1;

	HRESULT hr = S_OK;

	if( mtTime < 0 )
	{
		lMeasure = 0;
		lBeat = 0;
		lGrid = 0;
		lTick = mtTime;
	}
	else
	{
		IDirectMusicSegment* pIDMSegment = GetSegmentForTimeSigConversions();

		hr = ClocksToMeasureBeat( pIDMSegment, mtTime, &lMeasure, &lBeat );
		if( SUCCEEDED ( hr ) )
		{
			long lClocks;
			hr = MeasureBeatToClocks( pIDMSegment, lMeasure, lBeat, &lClocks );
			if( SUCCEEDED ( hr ) )
			{
				long lGridsAndTicks = mtTime - lClocks;

				// Get the TimeSig for this measure/beat
				DMUS_TIMESIGNATURE ts;
				if( (pIDMSegment == NULL)
				||  (FAILED( pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, lClocks, NULL, &ts ) )) )
				{
					ts.mtTime = 0;
					ts.bBeatsPerMeasure = 4;
					ts.bBeat = 4;
					ts.wGridsPerBeat = 2;
				}

				// Compute the grid and tick
				long lClocksPerGrid = ((DMUS_PPQ << 2) / ts.bBeat) / ts.wGridsPerBeat;
				lGrid = lGridsAndTicks / lClocksPerGrid;
				lTick = lGridsAndTicks % lClocksPerGrid;

				// Try and preserve negative tick offsets
				if( lTick > 0 )
				{
					long lNewClocks = lClocks + lClocksPerGrid;

					if( lTick >= (lClocksPerGrid >> 1) )
					{
						if( lNewClocks < m_mtLength_SEGH )
						{
							lGrid++;
							lTick -= lClocksPerGrid;
							if( lGrid >= ts.wGridsPerBeat )
							{
								lGrid = 0;
								mtTime += lClocksPerGrid;
								hr = ClocksToMeasureBeat( pIDMSegment, mtTime, &lMeasure, &lBeat );
							}
						}
					}
				}
			}
		}

		RELEASE( pIDMSegment );
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;
	*plGrid = lGrid;
	*plTick	= lTick;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::MeasureBeatGridTickToClocks

HRESULT	CVirtualSegment::MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime )
{
	MUSIC_TIME mtTime = -1;

	HRESULT hr = S_OK;

	IDirectMusicSegment* pIDMSegment = GetSegmentForTimeSigConversions();

	long lClocks;
	hr = MeasureBeatToClocks( pIDMSegment, lMeasure, lBeat, &lClocks );
	if( SUCCEEDED ( hr ) )
	{
		// Get the TimeSig for this measure/beat
		DMUS_TIMESIGNATURE ts;
		if( (pIDMSegment == NULL)
		||  (FAILED( pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, lClocks, NULL, &ts ) )) )
		{
			ts.mtTime = 0;
			ts.bBeatsPerMeasure = 4;
			ts.bBeat = 4;
			ts.wGridsPerBeat = 2;
		}

		long lClocksPerGrid = ((DMUS_PPQ << 2) / ts.bBeat) / ts.wGridsPerBeat;
		long lGridClocks = lGrid * lClocksPerGrid;

		mtTime = lClocks + lGridClocks + lTick;
	}

	RELEASE( pIDMSegment );

	*pmtTime = mtTime;

	ASSERT( SUCCEEDED ( hr ) );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::ClocksToMeasureBeat

HRESULT	CVirtualSegment::ClocksToMeasureBeat( IDirectMusicSegment* pIDMSegment,
											  MUSIC_TIME mtTime, long* plMeasure, long* plBeat )
{
	if( plMeasure == NULL
	||  plBeat == NULL )
	{
		ASSERT( 0 );
		return E_POINTER;
	}

	long lMeasure = 0;
	long lBeat = 0;

	MUSIC_TIME mtTSCur = 0;
	MUSIC_TIME mtTSNext;
	
	DMUS_TIMESIGNATURE TimeSig;
	TimeSig.mtTime = 0;
	TimeSig.bBeatsPerMeasure = 4;
	TimeSig.bBeat = 4;
	TimeSig.wGridsPerBeat = 2;

	// Store segment length
	MUSIC_TIME mtSegmentLength = 0;
	if( pIDMSegment )
	{
		if( FAILED ( pIDMSegment->GetLength( &mtSegmentLength ) ) )
		{
			mtSegmentLength = 0;
		}
	}

	do
	{
		// Get the current time signature
		if( pIDMSegment )
		{
			if( FAILED ( pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, mtTSCur, &mtTSNext, &TimeSig ) ) )
			{
				ASSERT( 0 );
				return E_UNEXPECTED;
			}
		}

		// If mtTime is less than 0, only use the first TimeSig
		if( mtTime < 0 )
		{
			lMeasure += mtTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));
			mtTime = -(abs(mtTime) % (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ )));
			break;
		}
		// If no pIDMSegment -OR- no next time signature, do the math to find how many more measures to add
		else if( pIDMSegment == NULL
			 ||  mtTSNext == 0 
			 ||  mtTSNext == mtSegmentLength )
		{
			lMeasure += mtTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));
			mtTime %= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// If the next time signature is after the time we're looking for
			if( mtTime < mtTSNext )
			{
				// Add the number of complete measures between here and there
				lMeasure += mtTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));

				// mtTime now stores an offset from the beginning of the measure
				mtTime %= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

				// Subtract from the time left (mtTime) and add to the current time (mtTSCur)
				mtTime -= lMeasureDiff;
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the time left is greater than 0
	while( mtTime > 0 );

	if( mtTime < 0 )
	{
		mtTime += TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		lMeasure--;
	}

	if( mtTime != 0 && plBeat != NULL )
	{
		lBeat = mtTime / NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
	}
	else
	{
		lBeat = 0;
	}

	*plMeasure = lMeasure;
	*plBeat = lBeat;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::MeasureBeatToClocks

HRESULT	CVirtualSegment::MeasureBeatToClocks( IDirectMusicSegment* pIDMSegment,
											  long lMeasure, long lBeat, MUSIC_TIME* pmtTime )
{
	if( pmtTime == NULL )
	{
		ASSERT( 0 );
		return E_POINTER;
	}

	MUSIC_TIME mtTSCur = 0;
	MUSIC_TIME mtTSNext = 1;

	DMUS_TIMESIGNATURE TimeSig;
	TimeSig.mtTime = 0;
	TimeSig.bBeatsPerMeasure = 4;
	TimeSig.bBeat = 4;
	TimeSig.wGridsPerBeat = 2;

	// Store segment length
	MUSIC_TIME mtSegmentLength = 0;
	if( pIDMSegment )
	{
		if( FAILED ( pIDMSegment->GetLength( &mtSegmentLength ) ) )
		{
			mtSegmentLength = 0;
		}
	}

	do
	{
		// Get the current time signature
		if( pIDMSegment )
		{
			if( FAILED ( pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, mtTSCur, &mtTSNext, &TimeSig ) ) )
			{
				ASSERT( 0 );
				return E_UNEXPECTED;
			}
		}

		long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

		if( pIDMSegment == NULL 
  	    ||  mtTSNext == 0 
	    ||  mtTSNext == mtSegmentLength )
		{
			mtTSCur += lMeasureClocks * lMeasure;
			break;
		}
		else
		{
			long lTmpMeasures = mtTSNext / lMeasureClocks;
			if( lMeasure <= lTmpMeasures )
			{
				mtTSCur += lMeasureClocks * lMeasure;
				break;
			}
			else
			{
				mtTSCur += lMeasureClocks * lTmpMeasures;
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	HRESULT hr = S_OK;
	if( lBeat >= 0 )
	{
		if( pIDMSegment )
		{
			hr = pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, max(mtTSCur, 0), NULL, &TimeSig );
		}
	}
	else
	{
		if( pIDMSegment )
		{
			hr = pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, max(mtTSCur - TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ), 0), NULL, &TimeSig );
		}
	}
	if( FAILED( hr ) )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	mtTSCur += NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ) * lBeat;
	
	*pmtTime = mtTSCur;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::GetSegmentForTimeSigConversions

IDirectMusicSegment* CVirtualSegment::GetSegmentForTimeSigConversions( void )
{
	IDirectMusicSegment* pITheDMSegment = NULL;

	if( m_pSourceSegment )
	{
		IDMUSProdNode* pISegmentDocRootNode;
		if( SUCCEEDED ( m_pSourceSegment->GetSegmentDocRootNode( &pISegmentDocRootNode ) ) )
		{
			IDirectMusicSegment* pIDMSegment;
			if( SUCCEEDED( pISegmentDocRootNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pIDMSegment ) ) )
			{
				MUSIC_TIME mtTSNext;
				DMUS_TIMESIGNATURE TimeSig;
				if( SUCCEEDED ( pIDMSegment->GetParam( GUID_TimeSignature, m_VirtualSegmentUI.dwTimeSigGroupBits, 0, 0, &mtTSNext, &TimeSig ) ) )
				{
					pITheDMSegment = pIDMSegment;
					pITheDMSegment->AddRef();
				}

				RELEASE( pIDMSegment );
			}

			RELEASE( pISegmentDocRootNode );
		}
	}

	return pITheDMSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::HasAudioPath

bool CVirtualSegment::HasAudioPath( void )
{
	if( m_pSourceSegment )
	{
		IDMUSProdNode* pISegmentDocRootNode;
		if( SUCCEEDED ( m_pSourceSegment->GetSegmentDocRootNode( &pISegmentDocRootNode ) ) )
		{
			IDMUSProdNode* pIAudioPathNode;
			if( SUCCEEDED( pISegmentDocRootNode->GetObject( GUID_AudioPathNode, IID_IDMUSProdNode, (void **)&pIAudioPathNode ) ) )
			{
				RELEASE( pIAudioPathNode );
				return true;
			}

			RELEASE( pISegmentDocRootNode );
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment RecomputeLength
    
BOOL CVirtualSegment::RecomputeLength( void )
{
	BOOL fChanged = FALSE;

	// Recalc m_mtLength_SEGH
	MUSIC_TIME mtNewLength;
	if( SUCCEEDED ( MeasureBeatGridTickToClocks( m_VirtualSegmentUI.dwNbrMeasures,
												 0,
												 0,
												 0,
												 &mtNewLength ) ) )
	{
		if( mtNewLength != m_mtLength_SEGH )
		{
			m_mtLength_SEGH = mtNewLength;

			m_mtPlayStart_SEGH = min( m_mtPlayStart_SEGH, (m_mtLength_SEGH - 1) );
			if( m_mtLoopStart_SEGH != 0
			||  m_mtLoopEnd_SEGH != 0 )
			{
				m_mtLoopEnd_SEGH = min( m_mtLoopEnd_SEGH, m_mtLength_SEGH );
				m_mtLoopStart_SEGH = min( m_mtLoopStart_SEGH, (m_mtLoopEnd_SEGH - 1) );
			}

			m_pSong->SetModified( TRUE );
			fChanged = TRUE;
		}
	}

	return fChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\VirtualSegmentPropPageObject.cpp ===
// VirtualSegmentPropPageObject.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SongDlg.h"
#include <TabBoundaryFlags.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


short CVirtualSegmentPropPageManager::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVirtualSegmentPropPageManager::CVirtualSegmentPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabSegment = NULL;
	m_pTabLoop = NULL;
	m_pTabBoundary = NULL;
}

CVirtualSegmentPropPageManager::~CVirtualSegmentPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabSegment )
	{
		delete m_pTabSegment;
	}

	if( m_pTabLoop )
	{
		delete m_pTabLoop;
	}

	if( m_pTabBoundary )
	{
		delete m_pTabBoundary;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager::RemoveCurrentObject

void CVirtualSegmentPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IUnknown implementation

HRESULT CVirtualSegmentPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CVirtualSegmentPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CVirtualSegmentPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CVirtualSegmentPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	PPGVirtualSegment ppgVirtualSegment;
	PPGVirtualSegment* pPPGVirtualSegment = &ppgVirtualSegment;

	if( m_pIPropPageObject 
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pPPGVirtualSegment))) )
	{
		if( ppgVirtualSegment.pSong
		&&  ppgVirtualSegment.pVirtualSegment )
		{
			CString strName;
			BSTR bstrName;

			strTitle.LoadString( IDS_SONG_TEXT );
			strTitle += _T(": ");

			// Add name of Song
			if( ppgVirtualSegment.pSong )
			{
				if( SUCCEEDED ( ppgVirtualSegment.pSong->GetNodeName( &bstrName ) ) )
				{
					strName = bstrName;
					::SysFreeString( bstrName );
			
					strTitle += strName;
					strTitle += _T(" - ");
				}
			}

			// Add Name of VirtualSegment
			ppgVirtualSegment.pVirtualSegment->GetName( strName );
			strTitle += _T("'");
			strTitle += strName;
			strTitle += _T("' ");
		}
	}

	// Add "Virtual Segment"
	CString strVirtualSegment;
	strVirtualSegment.LoadString( IDS_VIRTUAL_SEGMENT_TEXT );
	strTitle += strVirtualSegment;

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CVirtualSegmentPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Segment tab
	m_pTabSegment = new CTabVirtualSegment( this );
	if( m_pTabSegment )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabSegment->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Loop tab
	m_pTabLoop = new CTabVirtualSegmentLoop( this );
	if( m_pTabLoop )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabLoop->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Boundary tab
	m_pTabBoundary = new CTabBoundaryFlags( this );
	m_pTabBoundary->UseTransitionPrompts( TRUE );
	if( m_pTabBoundary )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabBoundary->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CVirtualSegmentPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CVirtualSegmentPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CVirtualSegmentPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pTabSegment )
	{
		m_pTabSegment->SetObject( pINewPropPageObject );
	}

	if( m_pTabLoop )
	{
		m_pTabLoop->SetObject( pINewPropPageObject );
	}

	if( m_pTabBoundary )
	{
		m_pTabBoundary->SetObject( pINewPropPageObject );
	}
	
	if( m_pIPropPageObject != pINewPropPageObject )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing
	}

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CVirtualSegmentPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CVirtualSegmentPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CVirtualSegmentPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTabSegment )
	{
		m_pTabSegment->RefreshTab();
	}

	if( m_pTabLoop )
	{
		m_pTabLoop->RefreshTab();
	}

	if( m_pTabBoundary )
	{
		m_pTabBoundary->RefreshTab();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CVirtualSegmentPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_VirtualSegmentPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//	CVirtualSegmentPropPageObject Constructor/Destructor

CVirtualSegmentPropPageObject::CVirtualSegmentPropPageObject( CSongDlg* pSongDlg )
{
    m_dwRef = 0;
	AddRef();

	ASSERT( pSongDlg != NULL );
	m_pSongDlg = pSongDlg;
//	m_pSongDlg->AddRef();		intentionally missing

	m_pVirtualSegment = NULL;
	m_dwFlagsUI = 0;
}

CVirtualSegmentPropPageObject::~CVirtualSegmentPropPageObject( void )
{
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Remove VirtualSegmentPropPageObject from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IUnknown implementation

HRESULT CVirtualSegmentPropPageObject::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CVirtualSegmentPropPageObject::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CVirtualSegmentPropPageObject::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject::GetData

HRESULT CVirtualSegmentPropPageObject::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (ppData == NULL)
	|| (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	int nSelCount = m_pSongDlg->GetVirtualSegmentSelCount();
	if( nSelCount > 1 )
	{
		m_pVirtualSegment = NULL;
		m_dwFlagsUI = PROPF_MULTI_SELECTED;
	}
	else
	{
		m_pVirtualSegment = m_pSongDlg->GetVirtualSegmentToEdit();
		if( m_pVirtualSegment )
		{
			m_dwFlagsUI = PROPF_ONE_SELECTED;
		}
		else
		{
			m_dwFlagsUI = PROPF_NONE_SELECTED;
		}
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
		// Asking for Song and VirtualSegment pointers
		case 0:
		{
			PPGVirtualSegment *pPPGVirtualSegment = reinterpret_cast<PPGVirtualSegment *>(*ppData);

			if( m_pVirtualSegment )
			{
				pPPGVirtualSegment->pSong = m_pVirtualSegment->m_pSong;
			}
			else
			{
				pPPGVirtualSegment->pSong = NULL;
			}
			pPPGVirtualSegment->pVirtualSegment = m_pVirtualSegment;
			break;
		}

		// Segment tab
		case 1:
		{
			PPGTabVirtualSegment* pPPGTabVirtualSegment = reinterpret_cast<PPGTabVirtualSegment *>(*ppData);
			InitPPGTabVirtualSegment( pPPGTabVirtualSegment );

			pPPGTabVirtualSegment->dwFlagsUI = m_dwFlagsUI;

			if( m_pVirtualSegment )
			{
				pPPGTabVirtualSegment->strName = m_pVirtualSegment->m_strName;
				pPPGTabVirtualSegment->dwTimeSigGroupBits = m_pVirtualSegment->m_VirtualSegmentUI.dwTimeSigGroupBits;
				pPPGTabVirtualSegment->dwResolution = m_pVirtualSegment->m_dwResolution_SEGH;

				long lMeasure, lBeat, lGrid, lTick;
				if( SUCCEEDED ( m_pVirtualSegment->ClocksToMeasureBeatGridTick( m_pVirtualSegment->m_mtLength_SEGH,
																			    &lMeasure,
																			    &lBeat,
																			    &lGrid,
																			    &lTick ) ) 
				&&  SUCCEEDED ( m_pVirtualSegment->ClocksToMeasureBeatGridTick( m_pVirtualSegment->m_mtPlayStart_SEGH,
																			    &pPPGTabVirtualSegment->lStartMeasure,
																			    &pPPGTabVirtualSegment->lStartBeat,
																			    &pPPGTabVirtualSegment->lStartGrid,
																			    &pPPGTabVirtualSegment->lStartTick ) ) )
				{
					m_pVirtualSegment->m_VirtualSegmentUI.dwNbrMeasures = max( 1, lMeasure );
					pPPGTabVirtualSegment->dwNbrMeasures = m_pVirtualSegment->m_VirtualSegmentUI.dwNbrMeasures;
					pPPGTabVirtualSegment->dwFlagsUI |= PROPF_TIME_CONVERSIONS_OK;
				}
				if( m_pVirtualSegment->HasAudioPath() )
				{
					pPPGTabVirtualSegment->dwFlagsUI |= PROPF_HAVE_AUDIOPATH;
				}
			}
			break;
		}

		// Boundary tab (Shared code so *pdwIndex must be 2)
		case 2:
		{
			PPGTabBoundaryFlags* pPPGTabBoundaryFlags = reinterpret_cast<PPGTabBoundaryFlags *>(*ppData);

			if( m_pVirtualSegment )
			{
				pPPGTabBoundaryFlags->dwPlayFlags = m_pVirtualSegment->m_dwResolution_SEGH;
				pPPGTabBoundaryFlags->strPrompt = m_pVirtualSegment->m_strName;
				pPPGTabBoundaryFlags->dwFlagsUI = PROPF_HAVE_VALID_DATA;
			}
			else
			{
				pPPGTabBoundaryFlags->dwPlayFlags = 0;
				if( m_dwFlagsUI & PROPF_MULTI_SELECTED )
				{
					pPPGTabBoundaryFlags->strPrompt.LoadString( IDS_MULTIPLE_SEGMENTS_SELECTED );
				}
				else
				{
					pPPGTabBoundaryFlags->strPrompt.Empty();
				}
				pPPGTabBoundaryFlags->dwFlagsUI = 0;
			}
			break;
		}

		// Loop tab
		case 3:
		{
			PPGTabVirtualSegmentLoop* pPPGTabVirtualSegmentLoop = reinterpret_cast<PPGTabVirtualSegmentLoop *>(*ppData);
			InitPPGTabVirtualSegmentLoop( pPPGTabVirtualSegmentLoop );

			pPPGTabVirtualSegmentLoop->dwFlagsUI = m_dwFlagsUI;

			if( m_pVirtualSegment )
			{
				pPPGTabVirtualSegmentLoop->dwRepeats = m_pVirtualSegment->m_dwRepeats_SEGH;
				MUSIC_TIME mtLoopEnd;
				if( pPPGTabVirtualSegmentLoop->dwRepeats > 0
				&&  m_pVirtualSegment->m_mtLoopStart_SEGH == 0
				&&  m_pVirtualSegment->m_mtLoopEnd_SEGH == 0 )
				{
					mtLoopEnd = m_pVirtualSegment->m_mtLength_SEGH;
				}
				else
				{
					mtLoopEnd = m_pVirtualSegment->m_mtLoopEnd_SEGH;
				}
				if( SUCCEEDED ( m_pVirtualSegment->ClocksToMeasureBeatGridTick( m_pVirtualSegment->m_mtLoopStart_SEGH,
																			    &pPPGTabVirtualSegmentLoop->lStartMeasure,
																			    &pPPGTabVirtualSegmentLoop->lStartBeat,
																			    &pPPGTabVirtualSegmentLoop->lStartGrid,
																			    &pPPGTabVirtualSegmentLoop->lStartTick ) ) 
				&&  SUCCEEDED ( m_pVirtualSegment->ClocksToMeasureBeatGridTick( mtLoopEnd,
																				&pPPGTabVirtualSegmentLoop->lEndMeasure,
																				&pPPGTabVirtualSegmentLoop->lEndBeat,
																				&pPPGTabVirtualSegmentLoop->lEndGrid,
																				&pPPGTabVirtualSegmentLoop->lEndTick ) ) )
				{
					pPPGTabVirtualSegmentLoop->dwFlagsUI |= PROPF_TIME_CONVERSIONS_OK;
				}
			}
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject::SetData

HRESULT CVirtualSegmentPropPageObject::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( m_pVirtualSegment == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	bool fChanged = false;
	
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
		// Segment tab
		case 1:
		{
			PPGTabVirtualSegment *pPPGTabVirtualSegment = reinterpret_cast<PPGTabVirtualSegment *>(pData);

			// m_mtLength_SEGH
			MUSIC_TIME mtTime;
			if( SUCCEEDED ( m_pVirtualSegment->MeasureBeatGridTickToClocks( pPPGTabVirtualSegment->dwNbrMeasures,
																		    0,
																		    0,
																		    0,
																		    &mtTime ) ) )
			{
				if( mtTime != m_pVirtualSegment->m_mtLength_SEGH )
				{
					m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_LENGTH );
					m_pVirtualSegment->m_mtLength_SEGH = mtTime;
					m_pVirtualSegment->m_VirtualSegmentUI.dwNbrMeasures = pPPGTabVirtualSegment->dwNbrMeasures;
					fChanged = true;
					m_pVirtualSegment->m_mtPlayStart_SEGH = min( m_pVirtualSegment->m_mtPlayStart_SEGH, (m_pVirtualSegment->m_mtLength_SEGH - 1) );
					if( m_pVirtualSegment->m_mtLoopStart_SEGH != 0
					||  m_pVirtualSegment->m_mtLoopEnd_SEGH != 0 )
					{
						m_pVirtualSegment->m_mtLoopEnd_SEGH = min( m_pVirtualSegment->m_mtLoopEnd_SEGH, m_pVirtualSegment->m_mtLength_SEGH );
						m_pVirtualSegment->m_mtLoopStart_SEGH = min( m_pVirtualSegment->m_mtLoopStart_SEGH, (m_pVirtualSegment->m_mtLoopEnd_SEGH - 1) );
					}
					break;
				}
			}

			// m_mtPlayStart_SEGH
			if( SUCCEEDED ( m_pVirtualSegment->MeasureBeatGridTickToClocks( pPPGTabVirtualSegment->lStartMeasure,
																		    pPPGTabVirtualSegment->lStartBeat,
																		    pPPGTabVirtualSegment->lStartGrid,
																		    pPPGTabVirtualSegment->lStartTick,
																		    &mtTime ) ) )
			{
				mtTime = max( 0, mtTime );
				mtTime = min( (m_pVirtualSegment->m_mtLength_SEGH - 1), mtTime );
				if( mtTime != m_pVirtualSegment->m_mtPlayStart_SEGH )
				{
					m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_START );
					m_pVirtualSegment->m_mtPlayStart_SEGH = mtTime;
					fChanged = true;
					break;
				}
			}

			// m_VirtualSegmentUI.dwTimeSigGroupBits
			if( pPPGTabVirtualSegment->dwTimeSigGroupBits != m_pVirtualSegment->m_VirtualSegmentUI.dwTimeSigGroupBits )
			{
				m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_GROUP_BITS );
				m_pVirtualSegment->m_VirtualSegmentUI.dwTimeSigGroupBits = pPPGTabVirtualSegment->dwTimeSigGroupBits;
				fChanged = true;
				break;
			}

			// DMUS_SEGF_USE_AUDIOPATH
			if( (pPPGTabVirtualSegment->dwResolution & DMUS_SEGF_USE_AUDIOPATH) != (m_pVirtualSegment->m_dwResolution_SEGH & DMUS_SEGF_USE_AUDIOPATH) )
			{
				m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_USE_AUDIOPATH );
				m_pVirtualSegment->m_dwResolution_SEGH &= ~DMUS_SEGF_USE_AUDIOPATH;
				m_pVirtualSegment->m_dwResolution_SEGH |= (pPPGTabVirtualSegment->dwResolution & DMUS_SEGF_USE_AUDIOPATH);
				fChanged = true;
				break;
			}

			// DMUS_SEGF_TIMESIG_ALWAYS
			if( (pPPGTabVirtualSegment->dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) != (m_pVirtualSegment->m_dwResolution_SEGH & DMUS_SEGF_TIMESIG_ALWAYS) )
			{
				m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_EXTEND_TIMESIG );
				m_pVirtualSegment->m_dwResolution_SEGH &= ~DMUS_SEGF_TIMESIG_ALWAYS;
				m_pVirtualSegment->m_dwResolution_SEGH |= (pPPGTabVirtualSegment->dwResolution & DMUS_SEGF_TIMESIG_ALWAYS);
				fChanged = true;
				break;
			}

			// m_strName
			if( pPPGTabVirtualSegment->strName.Compare(m_pVirtualSegment->m_strName) != 0 )
			{
				m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_CHANGE_VIRTUAL_SEGMENT_NAME );
				m_pVirtualSegment->m_strName = pPPGTabVirtualSegment->strName;
				m_pVirtualSegment->m_pSong->SyncChanges( SC_EDITOR,
														 SSE_REDRAW_VIRTUAL_SEGMENT_LIST | SSE_REDRAW_TRANSITION_LIST,
														 NULL );
				fChanged = true;
				break;
			}
			break;
		}

		// Boundary tab
		case 2:
		{
			PPGTabBoundaryFlags *pPPGTabBoundaryFlags = reinterpret_cast<PPGTabBoundaryFlags *>(pData);

			// m_dwResolution_SEGH
			if( pPPGTabBoundaryFlags->dwPlayFlags != m_pVirtualSegment->m_dwResolution_SEGH )
			{
				DWORD dwOrigTabVSegFlags = (m_pVirtualSegment->m_dwResolution_SEGH & TAB_VSEG_RESOLUTION_FLAGS);
				m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_BOUNDARY_FLAGS );
				m_pVirtualSegment->m_dwResolution_SEGH = pPPGTabBoundaryFlags->dwPlayFlags;
				m_pVirtualSegment->m_dwResolution_SEGH &= ~TAB_VSEG_RESOLUTION_FLAGS;
				m_pVirtualSegment->m_dwResolution_SEGH |= dwOrigTabVSegFlags;
				fChanged = true;
				break;
			}
			break;
		}

		// Loop tab
		case 3:
		{
			PPGTabVirtualSegmentLoop *pPPGTabVirtualSegmentLoop = reinterpret_cast<PPGTabVirtualSegmentLoop *>(pData);

			// m_dwRepeats_SEGH
			if( pPPGTabVirtualSegmentLoop->dwRepeats != DMUS_SEG_REPEAT_INFINITE )
			{
				pPPGTabVirtualSegmentLoop->dwRepeats = max( 0, pPPGTabVirtualSegmentLoop->dwRepeats );
			}
			if( pPPGTabVirtualSegmentLoop->dwRepeats != m_pVirtualSegment->m_dwRepeats_SEGH )
			{
				m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_LOOP_REPEATS );
				m_pVirtualSegment->m_dwRepeats_SEGH = pPPGTabVirtualSegmentLoop->dwRepeats;
				if( m_pVirtualSegment->m_dwRepeats_SEGH == 0 )
				{
					m_pVirtualSegment->m_mtLoopStart_SEGH = 0;
					m_pVirtualSegment->m_mtLoopEnd_SEGH = 0;
				}
				fChanged = true;
				break;
			}

			// "Reset" loop (m_mtLoopStart_SEGH and m_mtLoopEnd_SEGH)
			if( pPPGTabVirtualSegmentLoop->lStartMeasure == 0
			&&  pPPGTabVirtualSegmentLoop->lStartBeat == 0
			&&  pPPGTabVirtualSegmentLoop->lStartGrid == 0
			&&  pPPGTabVirtualSegmentLoop->lStartTick == 0
			&&  pPPGTabVirtualSegmentLoop->lEndMeasure == 0
			&&  pPPGTabVirtualSegmentLoop->lEndBeat == 0
			&&  pPPGTabVirtualSegmentLoop->lEndGrid == 0
			&&  pPPGTabVirtualSegmentLoop->lEndTick == 0 )
			{
				if( m_pVirtualSegment->m_mtLoopStart_SEGH != 0
				||  m_pVirtualSegment->m_mtLoopEnd_SEGH != 0 )
				{
					m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_RESET_LOOP );
					m_pVirtualSegment->m_mtLoopStart_SEGH = 0;
					m_pVirtualSegment->m_mtLoopEnd_SEGH = 0;
					fChanged = true;
				}
				break;
			}

			// m_mtLoopStart_SEGH and m_mtLoopEnd_SEGH
			MUSIC_TIME mtStartTime;
			MUSIC_TIME mtEndTime;
			if( SUCCEEDED ( m_pVirtualSegment->MeasureBeatGridTickToClocks( pPPGTabVirtualSegmentLoop->lStartMeasure,
																		    pPPGTabVirtualSegmentLoop->lStartBeat,
																		    pPPGTabVirtualSegmentLoop->lStartGrid,
																		    pPPGTabVirtualSegmentLoop->lStartTick,
																		    &mtStartTime ) ) 
			&&  SUCCEEDED ( m_pVirtualSegment->MeasureBeatGridTickToClocks( pPPGTabVirtualSegmentLoop->lEndMeasure,
																		    pPPGTabVirtualSegmentLoop->lEndBeat,
																		    pPPGTabVirtualSegmentLoop->lEndGrid,
																		    pPPGTabVirtualSegmentLoop->lEndTick,
																		    &mtEndTime ) ) )
			{
				mtStartTime = max( 0, mtStartTime );
				mtStartTime = min( (m_pVirtualSegment->m_mtLength_SEGH - 1), mtStartTime );
				mtEndTime = max( 1, mtEndTime );
				mtEndTime = min( m_pVirtualSegment->m_mtLength_SEGH, mtEndTime );

				// m_mtStartEnd_SEGH
				if( mtStartTime != m_pVirtualSegment->m_mtLoopStart_SEGH )
				{
					m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_LOOP_START );
					m_pVirtualSegment->m_mtLoopStart_SEGH = mtStartTime;
					m_pVirtualSegment->m_mtLoopEnd_SEGH = mtEndTime;
					if( m_pVirtualSegment->m_mtLoopStart_SEGH >= m_pVirtualSegment->m_mtLoopEnd_SEGH )
					{
						m_pVirtualSegment->m_mtLoopEnd_SEGH = m_pVirtualSegment->m_mtLoopStart_SEGH + 1;
					}
					fChanged = true;
					break;
				}

				// m_mtLoopEnd_SEGH
				if( mtEndTime != m_pVirtualSegment->m_mtLoopEnd_SEGH )
				{
					m_pVirtualSegment->m_pSong->m_pUndoMgr->SaveState( m_pVirtualSegment->m_pSong, theApp.m_hInstance, IDS_UNDO_VIRTUAL_SEGMENT_LOOP_END );
					m_pVirtualSegment->m_mtLoopEnd_SEGH = mtEndTime;
					if( m_pVirtualSegment->m_mtLoopEnd_SEGH <= m_pVirtualSegment->m_mtLoopStart_SEGH )
					{
						m_pVirtualSegment->m_mtLoopStart_SEGH = m_pVirtualSegment->m_mtLoopEnd_SEGH - 1;
					}
					fChanged = true;
					break;
				}
			}
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	if( fChanged )
	{
		// Sync changes
		m_pVirtualSegment->m_pSong->SetModified( TRUE );
		m_pVirtualSegment->m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject::OnShowProperties

HRESULT CVirtualSegmentPropPageObject::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Get the VirtualSegment's page manager
	CVirtualSegmentPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_VirtualSegmentPropPageManager ) == S_OK )
	{
		pPageManager = (CVirtualSegmentPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CVirtualSegmentPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the VirtualSegment's properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pPageManager == theApp.m_pIPageManager )
		{
			pIPropSheet->GetActivePage( &CVirtualSegmentPropPageManager::sm_nActiveTab );
		}
		short nActiveTab = CVirtualSegmentPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CVirtualSegmentPropPageObject::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject::InitPPGTabVirtualSegment

void CVirtualSegmentPropPageObject::InitPPGTabVirtualSegment( PPGTabVirtualSegment* pPPGTabVirtualSegment )
{
	if( pPPGTabVirtualSegment )
	{
		ASSERT( pPPGTabVirtualSegment->dwPageIndex == 1 );

		pPPGTabVirtualSegment->strName.Empty();
		pPPGTabVirtualSegment->dwNbrMeasures = 0;
		pPPGTabVirtualSegment->lStartMeasure = 0;
		pPPGTabVirtualSegment->lStartBeat = 0;
		pPPGTabVirtualSegment->lStartGrid = 0;
		pPPGTabVirtualSegment->lStartTick = 0;
		pPPGTabVirtualSegment->dwTimeSigGroupBits = 0;
		pPPGTabVirtualSegment->dwResolution = 0;
		pPPGTabVirtualSegment->dwFlagsUI = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegmentPropPageObject IDMUSProdPropPageObject::InitPPGTabVirtualSegmentLoop

void CVirtualSegmentPropPageObject::InitPPGTabVirtualSegmentLoop( PPGTabVirtualSegmentLoop* pPPGTabVirtualSegmentLoop )
{
	if( pPPGTabVirtualSegmentLoop )
	{
		ASSERT( pPPGTabVirtualSegmentLoop->dwPageIndex == 3 );

		pPPGTabVirtualSegmentLoop->dwRepeats = 0;
		pPPGTabVirtualSegmentLoop->lStartMeasure = 0;
		pPPGTabVirtualSegmentLoop->lStartBeat = 0;
		pPPGTabVirtualSegmentLoop->lStartGrid = 0;
		pPPGTabVirtualSegmentLoop->lStartTick = 0;
		pPPGTabVirtualSegmentLoop->lEndMeasure = 0;
		pPPGTabVirtualSegmentLoop->lEndBeat = 0;
		pPPGTabVirtualSegmentLoop->lEndGrid = 0;
		pPPGTabVirtualSegmentLoop->lEndTick = 0;
		pPPGTabVirtualSegmentLoop->dwFlagsUI = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\DialogLinkExisting.h ===
#if !defined(AFX_DIALOGLINKEXISTING_H__B135C0F6_2637_11D2_88F7_00C04FBF8D15__INCLUDED_)
#define AFX_DIALOGLINKEXISTING_H__B135C0F6_2637_11D2_88F7_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DialogLinkExisting.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CDialogLinkExisting dialog

class CDialogLinkExisting : public CDialog
{
// Construction
public:
	CDialogLinkExisting(CWnd* pParent = NULL);   // standard constructor

	class CDirectMusicPartRef *m_pDMPartRef;
	const class CDirectMusicStyle* m_pDMStyle;

// Dialog Data
	//{{AFX_DATA(CDialogLinkExisting)
	enum { IDD = IDD_PART_LINK };
	CListBox	m_listPart;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogLinkExisting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialogLinkExisting)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGLINKEXISTING_H__B135C0F6_2637_11D2_88F7_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\VirtualSegment.h ===
#ifndef __VIRTUAL_SEGMENT_H_
#define __VIRTUAL_SEGMENT_H_

#include "RiffStrm.h"
#include "Track.h"
#include "Transition.h"


#define DMUS_FOURCC_SONG_GUID_UI_CHUNK						mmioFOURCC('s','g','u','i')
#define DMUS_FOURCC_VIRTUAL_SEGMENT_UI_CHUNK				mmioFOURCC('v','s','u','i')
#define DMUS_FOURCC_VIRTUAL_SEGMENT_COPY_PASTE_UI_CHUNK		mmioFOURCC('v','c','p','u')

#define NOTE_TO_CLOCKS(note, ppq) ( (ppq)*4 /(note) )


#pragma pack(2)

typedef struct ioVirtualSegmentUI
{
	ioVirtualSegmentUI()
	{
		wFlags = 0;
		CoCreateGuid( &guidVirtualSegment ); 
		dwTimeSigGroupBits = 1;
		dwNbrMeasures = 20;
	}

	WORD	wFlags;			
	GUID	guidVirtualSegment;
	DWORD	dwTimeSigGroupBits;
	DWORD	dwNbrMeasures;
} ioVirtualSegmentUI;

typedef struct ioVirtualSegmentCopyPasteUI
{
	ioVirtualSegmentCopyPasteUI()
	{
		pSourceSegment = NULL;
		pIToolGraphNode = NULL;
	}

	CSourceSegment*		pSourceSegment;			// From Source Segment list
	IDMUSProdNode*		pIToolGraphNode;		// From Source ToolGraph list
} ioVirtualSegmentCopyPasteUI;

#pragma pack()


//////////////////////////////////////////////////////////////////////
//  CVirtualSegment

class CVirtualSegment : public IUnknown
{
friend class CDirectMusicSong;
friend class CSongDlg;
friend class CSegmentListBox;
friend class CFolder;
friend class CVirtualSegmentPropPageObject;

public:
	CVirtualSegment( CDirectMusicSong* pSong );
	virtual ~CVirtualSegment();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// Additional methods
	HRESULT Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT Save( IDMUSProdRIFFStream* pIRiffStream );

private:
	HRESULT SaveVirtualSegment( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSelectedTracks( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSelectedTransitions( IDMUSProdRIFFStream* pIRiffStream, bool fSaveAll );
	HRESULT SaveSongGuidUI( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveVirtualHeader( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSourceHeader( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveUI( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveCopyPasteUI( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveTrackList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveTransitionList( IDMUSProdRIFFStream* pIRiffStream );

	void EmptyTrackList();
	void InsertTrack( CTrack* pTrack );
	void RemoveTrack( CTrack* pTrack );

	void EmptyTransitionList();
	void InsertTransition( CTransition* pTransition );
	void RemoveTransition( CTransition* pTransition );

public:
	HRESULT	ClocksToMeasureBeatGridTick( MUSIC_TIME mtTime, long* plMeasure, long* plBeat, long* plGrid, long* plTick );
	HRESULT	MeasureBeatGridTickToClocks( long lMeasure, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime );
	HRESULT	ClocksToMeasureBeat( IDirectMusicSegment* pIDMSegment, MUSIC_TIME mtTime, long* plMeasure, long* plBeat );
	HRESULT	MeasureBeatToClocks( IDirectMusicSegment* pIDMSegment, long lMeasure, long lBeat, MUSIC_TIME* pmtTime );
	IDirectMusicSegment* GetSegmentForTimeSigConversions();
	void RemoveVirtualSegmentReferences( CVirtualSegment* pVirtualSegmentToRemove );
	void RemoveSourceSegmentReferences( CSourceSegment* pSourceSegmentToRemove );
	void RemoveToolGraphReferences( IDMUSProdNode* pIToolGraphNodeToRemove );
	void ResolveVirtualSegmentIDs();
	bool IsVirtualSegmentInTransitionList( CVirtualSegment* pVirtualSegment );
	HRESULT SetDefaultValues( IStream* pIStream );
	void GetSourceSegmentName( CString& strSourceSegmentName );
	void GetName( CString& strName );
	void SetName( CString strName );
	bool HasAudioPath();
	BOOL RecomputeLength();

public:
	bool					m_fIsPlaying;

private:
    DWORD					m_dwRef;
	CDirectMusicSong*		m_pSong;

	// UI
	ioVirtualSegmentUI		m_VirtualSegmentUI;
	bool					m_fResolveNextPlayID;
	DWORD					m_dwNextPlayID;
	DWORD					m_dwBitsUI;

	// Persisted for DirectMusic
	//		UNFO/UNAM
	CString					m_strName;				// Name of Virtual Segment

	//		DMUS_IO_SEGREF_HEADER
	CSourceSegment*			m_pSourceSegment;		// From Source Segment list
	IDMUSProdNode*			m_pIToolGraphNode;		// From Source ToolGraph list
	CVirtualSegment*		m_pNextVirtualSegment;	// From Virtual Segment list

	//		DMUS_IO_SEGMENT_HEADER	
    DWORD					m_dwRepeats_SEGH;			// Number of repeats. By default, 0. 
    MUSIC_TIME				m_mtLength_SEGH;			// Length, in music time. 
    MUSIC_TIME				m_mtPlayStart_SEGH;			// Start of playback. By default, 0. 
    MUSIC_TIME				m_mtLoopStart_SEGH;			// Start of looping portion. By default, 0. 
    MUSIC_TIME				m_mtLoopEnd_SEGH;			// End of loop. Must be greater than dwPlayStart. By default equal to length. 
    DWORD					m_dwResolution_SEGH;		// Default resolution. 
    REFERENCE_TIME			m_rtLength_SEGH;			// Length, in reference time (overrides music time length.) 
    DWORD					m_dwFlags_SEGH;

	CTypedPtrList<CPtrList, CTrack*> m_lstTracks;
	CTypedPtrList<CPtrList, CTransition*> m_lstTransitions;
};

#endif // __VIRTUAL_SEGMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\VirtualSegmentPropPageObject.h ===
#ifndef __VIRTUALSEGMENTPROPPAGEOBJECT_H_
#define __VIRTUALSEGMENTPROPPAGEOBJECT_H_

#include "TabVirtualSegment.h"
#include "TabVirtualSegmentLoop.h"

typedef struct _PPGVirtualSegment
{
	_PPGVirtualSegment( void )
	{
		dwPageIndex = 0;
		pSong = NULL;
		pVirtualSegment = NULL;
	}

	DWORD				dwPageIndex;
	CDirectMusicSong*	pSong;
	CVirtualSegment*	pVirtualSegment;
} PPGVirtualSegment;


//////////////////////////////////////////////////////////////////////
//  CVirtualSegmentPropPageManager

class CVirtualSegmentPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabVirtualSegment;
friend class CTabVirtualSegmentLoop;
friend class CTabBoundaryFlags;

public:
	CVirtualSegmentPropPageManager();
	virtual ~CVirtualSegmentPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabVirtualSegment*			m_pTabSegment;
	CTabVirtualSegmentLoop*		m_pTabLoop;
	CTabBoundaryFlags*			m_pTabBoundary;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CVirtualSegmentPropPageObject

class CVirtualSegmentPropPageObject : public IDMUSProdPropPageObject
{
friend class CVirtualSegmentPropPageManager;

public:
	CVirtualSegmentPropPageObject( CSongDlg* pSongDlg );
	virtual ~CVirtualSegmentPropPageObject();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// Additional methods
private:
	void InitPPGTabVirtualSegment( PPGTabVirtualSegment* pPPGTabVirtualSegment );
	void InitPPGTabVirtualSegmentLoop( PPGTabVirtualSegmentLoop* pPPGTabVirtualSegmentLoop );

private:
    DWORD				m_dwRef;
	CSongDlg*			m_pSongDlg;

	CVirtualSegment*	m_pVirtualSegment;
	DWORD				m_dwFlagsUI;
};

#endif // __VIRTUALSEGMENTPROPPAGEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\MIDIFile.cpp ===
//
// midifile.cpp
//
// original author: Dave Miller
// orignal project: AudioActive
// modified by: Mark Burton
// Adopted for use in DMUSProducer by: Jeff Fried
// project: DirectMusic
//
#define assert ASSERT
#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "styleriff.h"
#include "RiffStrm.h"
#include <mmreg.h>
#include <math.h>

#include "midifile.h"
void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord,
							DWORD* scalepattern=0, DWORD* chordpattern=0, BYTE* scaleroot=0, BYTE* chordroot=0);
static DMUS_CHORD_PARAM g_Chord; // Holds the latest chord
static DMUS_CHORD_PARAM g_DefaultChord; // in case no chords are extracted from the track

// specific to pattern
static DWORD	gdwDefaultKeyPattern = 0xAB5AB5;	// Major	
static DWORD	gdwDefaultChordPattern = 0x891;	// M7
static DWORD	gbDefaultKeyRoot = 0;		
static DWORD	gbDefaultChordRoot = 12;		

static DWORD	gdwKeyPattern;
static DWORD	gdwChordPattern;
static BYTE	gbKeyRoot;
static BYTE	gbChordRoot;
static BOOL gfKeyFlatsNotSharps;
static BOOL gfChordFlatsNotSharps;

static bool	gKeySigExists = false;


// Flags for CBandInstrument::m_dwFlags. When set, a flag indicates that the 
// corresponding field in CBandInstrument should be used to generate
// a MIDI event as well as information about the instrument

#define DMBI_PATCH			(1 << 0)		// m_dwPatch is valid.
#define DMBI_VOLUME			(1 << 1)		// m_bVolume is valid
#define DMBI_PAN			(1 << 2)		// m_bPan is valid
#define DMBI_BANKSELECT_MSB	(1 << 3)		// m_dwPatch contains a valid Bank Select MSB part
#define DMBI_BANKSELECT_LSB	(1 << 4)		// m_dwPatch contains a valid Bank Select LSB part
#define DMBI_GM				(1 << 5)		// Instrument is from GM collection
#define DMBI_GS				(1 << 6)		// Instrument is from GS collection
#define DMBI_ASSIGN_PATCH	(1 << 7)		// m_AssignPatch is valid


bool IsGS(DWORD dwBank, DWORD dwInstrument)
{
	BYTE	bMSB, bLSB, bPatch;

	bMSB = (BYTE) ((dwBank & 0x00007F00) >> 8);
	bLSB = (BYTE) (dwBank & 0x0000007F);
	bPatch = (BYTE) (dwInstrument & 0x0000007F);
	
	if (bLSB != 0) return false;

	if ( (bMSB == 0) ) // && (bLSB == 0) 
	{
		if ((dwBank & 0x80000000)) //Drum Kit
		{
			if ((bPatch == 0x0)  ||
				(bPatch == 0x08) ||
				(bPatch == 0x10) ||
				(bPatch == 0x18) ||
				(bPatch == 0x19) ||
				(bPatch == 0x20) ||
				(bPatch == 0x28) ||
				(bPatch == 0x30) || 
				(bPatch == 0x38) )
			{
				return  true;
			}
			else
				return false;
		}
		else return true;//is GM
	}
	// check for GS
	switch (bMSB)
	{
		case 6:
		case 7:
			if (bPatch == 0x7D) return true;
			break;
		case 24:
			if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
			break;
		case 9:
			if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
			break;
		case 2:
			if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
			break;
		case 3:
			if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
			break;
		case 4:
		case 5:
			if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
			break;
		case 32:
			if ((bPatch == 0x10) ||
				(bPatch == 0x11) ||
				(bPatch == 0x18) ||
				(bPatch == 0x34) ) return true;
			break;
		case 1:
			if ((bPatch == 0x26) ||
				(bPatch == 0x39) ||
				(bPatch == 0x3C) ||
				(bPatch == 0x50) ||
				(bPatch == 0x51) ||
				(bPatch == 0x62) ||
				(bPatch == 0x66) ||
				(bPatch == 0x68) ||
				((bPatch > 0x77) && (bPatch < 0x80))) return true;
				break;
		case 16:
			switch (bPatch)
			{
				case 0x00:
					return true;
					break;
				case 0x04:
					return true;
					break;
				case 0x05:
					return true;
					break;
				case 0x06:
					return true;
					break;
				case 0x10:
					return true;
					break;
				case 0x13:
					return true;
					break;
				case 0x18:
					return true;
					break;
				case 0x19:
					return true;
					break;
				case 0x1C:
					return true;
					break;
				case 0x27:
					return true;
					break;
				case 0x3E:
					return true;
					break;
				case 0x3F:
					return true;
					break;
				default:
					return false;
			}
			break;
		case 8:
			if ((bPatch < 0x07) || ((bPatch == 0x7D)))
			{
				return true;
			}
			else if ((bPatch > 0x3F) && (bPatch < 0x50))
			{
				return false;
			}
			else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
			{
				if ((bPatch == 0x50) || 
					(bPatch == 0x51) ||
					(bPatch == 0x6B))
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x1F) && (bPatch < 0x40))
			{
				if ((bPatch > 0x25) && (bPatch < 0x29) ||
					(bPatch > 0x3C)  ||
					(bPatch == 0x30) || 
					(bPatch == 0x32) )
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
				     (bPatch != 0x0D) && (bPatch != 0x0F))
			{
				return true;
			}
			else if ((bPatch > 0x0F) && (bPatch < 0x20))
			{
				if (bPatch > 0x17)
				{
					return true;
				}
				else if ( (bPatch == 0x13) || (bPatch == 0x15) )
					return true;
				else
					return false;
			}
			break;
		default:
			return false;
	}
	return false;
}



inline bool operator == (const ULARGE_INTEGER& i1, const ULARGE_INTEGER& i2)
{
	if(i1.LowPart == i2.LowPart && i1.HighPart == i2.HighPart)
		return true;
	else
		return false;
}


// One for each MIDI channel 0-15	
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];

DMUS_IO_BANKSELECT_ITEM& MIDIBankSelect(int ch)
{
	return gBankSelect[ch];
}


DWORD gdwLastControllerTime[NUM_MIDI_CHANNELS];	// Holds the time of the last CC event
DWORD gdwControlCollisionOffset[NUM_MIDI_CHANNELS];

void MIDIInit()
{
	gKeySigExists = false;
	MIDIInitBankSelect();
}

void MIDIInitBankSelect()
{
	FillMemory(&gBankSelect, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS), 0xFF);
}


void MIDIInitChordOfComposition()
{
	CreateChordFromKey(0, 0, 0, g_Chord, &gdwKeyPattern, &gdwChordPattern, &gbKeyRoot, &gbChordRoot);
	CreateChordFromKey(0, 0, 0, g_DefaultChord, &gdwKeyPattern, &gdwChordPattern, &gbKeyRoot, &gbChordRoot);
}

void MIDIGetChordOfComposition(DMUS_CHORD_PARAM& chord)
{
	memcpy(&chord, &g_Chord, sizeof(DMUS_CHORD_PARAM));
}


void MIDIGetChordOfComposition(DWORD& keypattern, DWORD& chordpattern, BYTE& keyroot, 
							   BYTE& chordroot, BOOL& fKeyFlatsNotSharps, BOOL& fChordFlatsNotSharps)
{
	if( gKeySigExists )
	{
		keypattern = gdwKeyPattern;
		chordpattern = gdwChordPattern;
		keyroot = gbKeyRoot;
		chordroot = gbChordRoot;
		fKeyFlatsNotSharps = gfKeyFlatsNotSharps;
		fChordFlatsNotSharps = gfChordFlatsNotSharps;
	}
}

/*
HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
					   IDirectMusicLoader* pIDMLoader)
{
	// Any changes made to this function should also be made to CDirectMusicBand::LoadCollection
	// in dmband.dll

	ASSERT(ppIDMCollection);
	ASSERT(pIDMLoader);

	DMUS_OBJECTDESC desc;
	ZeroMemory(&desc, sizeof(desc));
	desc.dwSize = sizeof(desc);

	desc.guidClass = CLSID_DirectMusicCollection;
	wcscpy(desc.wszFileName, L"gm.dls");	
	desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME);
	
	LPDMUS_OBJECT m_pDMObject = NULL;

	HRESULT hr = pIDMLoader->GetObject(&m_pDMObject, &desc);

	if(SUCCEEDED(hr))
	{
		hr = m_pDMObject->QueryInterface(IID_IDirectMusicCollection, (void**)ppIDMCollection);
	}

	if(m_pDMObject)
	{
		m_pDMObject->Release();
	}
	
	return hr;
}
*/

#ifndef  _CRIFFStream_
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
	li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
	DWORD dw;
	} u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 4, NULL ) )
    {
	return FALSE;
    }


#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

#endif


static short snPPQN;
//static IStream* gpTempoStream = NULL;
//static IStream* gpSysExStream = NULL;
//static IStream* gpTimeSigStream = NULL;
//static BOOL	gfSetTempo = FALSE;
//static CDirectMusicPattern* gpPattern = NULL;


short& MIDIsnPPQN()
{
	return snPPQN;
}


/*
DMUS_IO_TIMESIGNATURE_ITEM	gTimeSigItem;


long	glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
	// this is needed because we only care about the time sigs on the first track to
	// contain them that we read -- need to initialize this in createPatternfromMidi

DMUS_IO_TIMESIGNATURE_ITEM& MIDITimeSig()
{
	return gTimeSigItem;
}

long& MIDITimeSigFlag()
{
	return glTimeSig;
}
*/

WORD MIDIGetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
		rfdwValue = 0;
		return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
		if( S_OK != pStream->Read( &b, 1, NULL ) )
		{
			break;
		}
		++wBytes;
		rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
DWORD MIDIConvertTime( DWORD dwTime )
{
	wide d;
	long l;  // storage for the remainder

	if( snPPQN == DMUS_PPQ )  {
		return dwTime;
	}
	WideMultiply( dwTime, DMUS_PPQ, &d );
	return WideDivide( &d, snPPQN, &l );
}
#else
DWORD MIDIConvertTime( DWORD dwTime )
{
    __int64 d;

    if( snPPQN == DMUS_PPQ )
    {
		return dwTime;
    }
    d = dwTime;
    d *= DMUS_PPQ;
    d /= snPPQN;
    return (DWORD)d;
}
#endif

FullSeqEvent* MIDICompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
    int nChannel;

	ZeroMemory( paNoteOnEvent, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
		pEvent->pTempNext = NULL;
		pNextEvent = pEvent->pNext;
		nChannel = pEvent->dwPChannel;
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			// add this event to the end of the list of events based
			// on the event's pitch. Keeping track of multiple events
			// of the same pitch allows us to have overlapping notes
			// of the same pitch, choosing that note on's and note off's
			// follow in the same order.
			if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
			}
			else
			{
				FullSeqEvent* pScan;
				for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
					 pScan->pTempNext != NULL; pScan = pScan->pTempNext );
				pScan->pTempNext = pEvent;
			}
		}
		else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
		{
			if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
					pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
				paNoteOnEvent[nChannel][pEvent->bByte1] =
					paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
			}
			if( pPrevEvent == NULL )
			{
				lstEvent = pNextEvent;
			}
			else
			{
				pPrevEvent->pNext = pNextEvent;
			}
			delete pEvent;
			continue;
		}
		pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
//		pEvent->mtTime =  MIDIConvertTime(pEvent->mtTime);
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
//			pEvent->mtDuration = MIDIConvertTime( pEvent->mtDuration );
			if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
		}
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
    if( pEvent1->mtTime < pEvent2->mtTime )
    {
	return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
	return 1;
    }
    else if( (pEvent1->bStatus & 0xF0) != MIDI_SYSX
		&&	 (pEvent2->bStatus & 0xF0) != ET_SYSX )
    {
	BYTE bStatus1;
	BYTE bStatus2;

	bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
	bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
	if( bStatus1 == bStatus2 )
	{
	    return 0;
	}
	else if( bStatus1 == MIDI_NOTEON )
	{
	    return -1;
	}
	else if( bStatus2 == MIDI_NOTEON )
	{
	    return 1;
	}
	else if( bStatus1 > bStatus2 )
	{
	    return 1;
	}
	else if( bStatus1 < bStatus2 )
	{
	    return -1;
	}
    }
    return 0;
}

FullSeqEvent* MIDIMergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
	if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
	{
	    pEvent->pNext = lstLeftEvent;
	    pEvent = lstLeftEvent;
	    lstLeftEvent = lstLeftEvent->pNext;
	    if( lstLeftEvent == NULL )
	    {
		pEvent->pNext = lstRightEvent;
	    }
	}
	else
	{
	    pEvent->pNext = lstRightEvent;
	    pEvent = lstRightEvent;
	    lstRightEvent = lstRightEvent->pNext;
	    if( lstRightEvent == NULL )
	    {
		pEvent->pNext = lstLeftEvent;
		lstLeftEvent = NULL;
	    }
	}
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

FullSeqEvent* MIDIRemoveDuplicateCCs( FullSeqEvent* lstEvent )
{
#ifdef _DEBUG
	BYTE bCurrentCCValue[16][128];
	BYTE bCurPitchBendByte1[16];
	BYTE bCurPitchBendByte2[16];
	BYTE bCurPTouchValue[16][128];
	BYTE bCurMTouchValue[16];
#endif

	bool fHaveMTouch[16];
	bool fHavePBend[16];
	DWORD adwHavePTouch[16][8];
	DWORD adwHaveCC[16][8];

	FullSeqEvent *pLastEvent = NULL;
	FullSeqEvent *pCurEvent = lstEvent;
	while( pCurEvent )
	{
		// Initialize our flags
		ZeroMemory( fHaveMTouch, sizeof(bool) * 16 );
		ZeroMemory( fHavePBend, sizeof(bool) * 16 );
		ZeroMemory( adwHavePTouch, sizeof(DWORD) * 8 * 16 );
		ZeroMemory( adwHaveCC, sizeof(DWORD) * 8* 16 );

		// Set the current time
		const MUSIC_TIME mtCurrent = pCurEvent->mtTime;
		while( pCurEvent
			&& mtCurrent == pCurEvent->mtTime )
		{
			// The PChannel # must be less than 16
			ASSERT( pCurEvent->dwPChannel < 16 );

			FullSeqEvent *pNextEvent = pCurEvent->pNext;
			switch( pCurEvent->bStatus & 0xF0 )
			{
			case MIDI_PBEND:
				if( fHavePBend[pCurEvent->dwPChannel] )
				{
#ifdef _DEBUG
					TRACE("Throwing away PBend on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						(int)(((pCurEvent->bByte2 & 0x7F) << 7) + (pCurEvent->bByte1 & 0x7F)),
						(int)(((bCurPitchBendByte2[pCurEvent->dwPChannel] & 0x7F) << 7) + (bCurPitchBendByte1[pCurEvent->dwPChannel] & 0x7F)) );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					fHavePBend[pCurEvent->dwPChannel] = true;
#ifdef _DEBUG
					bCurPitchBendByte1[pCurEvent->dwPChannel] = pCurEvent->bByte1;
					bCurPitchBendByte2[pCurEvent->dwPChannel] = pCurEvent->bByte2;
#endif
				}
				break;
			case MIDI_MTOUCH:
				if( fHaveMTouch[pCurEvent->dwPChannel] )
				{
#ifdef _DEBUG
					TRACE("Throwing away MTouch on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						pCurEvent->bByte1,
						bCurMTouchValue[pCurEvent->dwPChannel] );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					fHaveMTouch[pCurEvent->dwPChannel] = true;
#ifdef _DEBUG
					bCurMTouchValue[pCurEvent->dwPChannel] = pCurEvent->bByte1;
#endif
				}
				break;
			case MIDI_PTOUCH:
				if( adwHavePTouch[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] & (0x1 << (pCurEvent->bByte1 & 0x1F)) )
				{
#ifdef _DEBUG
					TRACE("Throwing away PTouch %d on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->bByte1,
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						pCurEvent->bByte2,
						bCurPTouchValue[pCurEvent->dwPChannel][pCurEvent->bByte1] );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					adwHavePTouch[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] |= (0x1 << (pCurEvent->bByte1 & 0x1F));
#ifdef _DEBUG
					bCurPTouchValue[pCurEvent->dwPChannel][pCurEvent->bByte1] = pCurEvent->bByte2;
#endif
				}
				break;
			case MIDI_CCHANGE:
				if( adwHaveCC[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] & (0x1 << (pCurEvent->bByte1 & 0x1F)) )
				{
#ifdef _DEBUG
					TRACE("Throwing away CC %d on %d at %d with value %d.  Keeping Value %d\n",
						pCurEvent->bByte1,
						pCurEvent->dwPChannel,
						pCurEvent->mtTime,
						pCurEvent->bByte2,
						bCurrentCCValue[pCurEvent->dwPChannel][pCurEvent->bByte1] );
#endif

					// pLastEvent should always be valid, because we never throw away the first event
					ASSERT( pLastEvent );
					pLastEvent->pNext = pNextEvent;
					pCurEvent->pNext = NULL;
					delete pCurEvent;
					pCurEvent = NULL;
				}
				else
				{
					adwHaveCC[pCurEvent->dwPChannel][pCurEvent->bByte1 / 32] |= (0x1 << (pCurEvent->bByte1 & 0x1F));
#ifdef _DEBUG
					bCurrentCCValue[pCurEvent->dwPChannel][pCurEvent->bByte1] = pCurEvent->bByte2;
#endif
				}
				break;
			}
			if( pCurEvent )
			{
				pLastEvent = pCurEvent;
			}
			pCurEvent = pNextEvent;
		}
	}
	return lstEvent;
}

FullSeqEvent* MIDIReverseEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* lstNew = NULL;

	while( lstEvent )
	{
		// Save a poiter to the next event
		FullSeqEvent *pNextEvent = lstEvent->pNext;

		// Redirect the event to the start of lstNew
		lstEvent->pNext = lstNew;
		lstNew = lstEvent;

		// Move lstEvent to the next event
		lstEvent = pNextEvent;
	}

    return lstNew;
}

FullSeqEvent* MIDISortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
	pMidEvent = lstEvent;
	pRightEvent = pMidEvent->pNext->pNext;
	if( pRightEvent != NULL )
	{
	    pRightEvent = pRightEvent->pNext;
	}
	while( pRightEvent != NULL )
	{
	    pMidEvent = pMidEvent->pNext;
	    pRightEvent = pRightEvent->pNext;
	    if( pRightEvent != NULL )
	    {
		pRightEvent = pRightEvent->pNext;
	    }
	}
	pRightEvent = pMidEvent->pNext;
	pMidEvent->pNext = NULL;
	return MIDIMergeEvents( MIDISortEventList( lstEvent ),
			    MIDISortEventList( pRightEvent ) );
    }
    return lstEvent;
}

DWORD MIDIReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent, LPSTR* pszTrackName )
{
    static BYTE bRunningStatus;

	dwTime = MIDIConvertTime(dwTime);

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
	DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;
    BYTE b;

	BYTE* pbSysExData = 0;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
		return 0;
    }

    if( b < 0x80 )
    {
		StreamSeek( pStream, -1, STREAM_SEEK_CUR );
		b = bRunningStatus;
		dwBytes = 0;
    }
    else
    {
		dwBytes = 1;
    }

    if( b < 0xf0 )
    {
		bRunningStatus = (BYTE)b;

		switch( b & 0xf0 )
		{
		case MIDI_CCHANGE:
		case MIDI_PTOUCH:
		case MIDI_PBEND:
		case MIDI_NOTEOFF:
		case MIDI_NOTEON:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;

			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
			pEvent->mtDuration = 0;
			pEvent->nOffset = 0;
			pEvent->bStatus = static_cast<BYTE>(bRunningStatus & 0xf0);
			pEvent->dwPChannel = bRunningStatus & 0xf;
			pEvent->bByte1 = b;
//			( (NoteEvent*)pEvent )->voiceid = (char)( ( ( bRunningStatus - 4 ) & 0xf ) + 1 );
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				delete pEvent;
				return dwBytes;
			}
			++dwBytes;
			pEvent->bByte2 = b;

			if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
				pEvent->bByte2 == 0 )
			{
				pEvent->bStatus = (BYTE)( MIDI_NOTEOFF | ( pEvent->bStatus & 0xf ) );
			}

//			pEvent->bEventType = static_cast<BYTE>( pEvent->bStatus >> 4 );

			if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
			{
				// We have a bank select or its LSB either of which are not added to event list
				if(pEvent->bByte1 == 0x20)
				{
					gBankSelect[pEvent->bStatus & 0xf].byLSB = pEvent->bByte2;
				}
				else // pEvent->bByte1 == 0
				{
					gBankSelect[pEvent->bStatus & 0xf].byMSB = pEvent->bByte2;
				}
				// We no longer need the event so we can free it
				delete pEvent;
			}
			else // Add to event list
			{
				pEvent->pNext = *plstEvent;
				*plstEvent = pEvent;
			}
			break;

		case MIDI_PCHANGE:
		{
			if(FAILED(pStream->Read(&b, 1, NULL)))
			{
				return dwBytes;
			}
			
			++dwBytes;

			pPatchEvent = new DMUS_IO_PATCH_ITEM;

			if(pPatchEvent == NULL)
			{
				return 0;
			}

			pPatchEvent->lTime = dwTime - 1;
			pPatchEvent->byStatus = bRunningStatus;
			pPatchEvent->byPChange = b;	// byte 0 in dwPatch
			pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
			pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
			pPatchEvent->dwFlags &= 0;
			pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

			if(pPatchEvent->byMSB != 0xFF)
			{
				pPatchEvent->dwFlags |= DMBI_BANKSELECT_MSB;						
			}
			
			if(pPatchEvent->byLSB != 0xFF)
			{
				pPatchEvent->dwFlags |= DMBI_BANKSELECT_LSB;				
			}

			if(!(pPatchEvent->dwFlags & (DMBI_BANKSELECT_MSB | DMBI_BANKSELECT_LSB) ) )
			{
				// no bank select in effect, defaults to GM
					pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
			}
			else
			{
				// test and set GM/GS flags
				DWORD dwPatch = pPatchEvent->byPChange & 0x7F
												| (pPatchEvent->byLSB & 0x7F) << 8
												| (pPatchEvent->byMSB & 0x7F) << 16;

				DWORD dwInstrument = dwPatch & 0xFF;
				DWORD dwBank = (dwPatch & ~(0x0 | 0xFF)) >> 8;

				if(IsGS(dwBank, dwInstrument))
				{
					pPatchEvent->dwFlags |= DMUS_IO_INST_GS;
					if(dwBank == 0 || (dwBank & ~(0x80000000)) == 0)
					{
						pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
					}
				}
			}

			pPatchEvent->pNext = *pplstPatchEvent;
			pPatchEvent->pIDMCollection = NULL;

			*pplstPatchEvent = pPatchEvent;

			break;
		}
		case MIDI_MTOUCH:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
			pEvent->mtDuration = 0;
			pEvent->nOffset = 0;
			pEvent->bStatus = static_cast<BYTE>(bRunningStatus & 0xf0);
			pEvent->dwPChannel = bRunningStatus & 0xf;
			pEvent->bByte1 = b;
//			( (NoteEvent*)pEvent )->voiceid = (char)( ( ( bRunningStatus - 4 ) & 0xf ) + 1 );
//			pEvent->bEventType = static_cast<BYTE>( pEvent->bStatus >> 4 );

			pEvent->pNext = *plstEvent;
			*plstEvent = pEvent;
			break;
		default:
			// this should NOT be possible - unknown midi note event type
			ASSERT(FALSE);
			break;
		}
    }
    else
    {
		switch( b )
		{
		case 0xf0:
			dwBytes += MIDIGetVarLength( pStream, dwLen );
			pSysEx = new DMUS_IO_SYSEX_ITEM;
			if( pSysEx != NULL )
			{
				pbSysExData = new BYTE[dwLen + 1];
				if( pbSysExData != NULL )
				{
					pbSysExData[0] = 0xf0;
					if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
					{
						delete []pbSysExData;
						delete pSysEx;
						return dwBytes;
					}

					if( pbSysExData[1] == 0x43 )
					{
						extern bool gbIsXG;
						// check for XG files
						BYTE abXG[] = { 0xF0, 0x43, 0x10, 0x4C, 0x00, 0x00, 0x7E, 0x00, 0xF7 };
						int i;
						if(dwLen >= 8)
						{
							for( i = 0; i < 8; i++ )
							{
								if( i == 2 )
								{
									//if( ( pSysEx->pbSysExData[i] & 0xF0 ) != abXG[i] )
									if( ( pbSysExData[i] & 0xF0 ) != abXG[i] )
										break;
								}
								else
								{
									//if( pSysEx->pbSysExData[i] != abXG[i] )
									if( pbSysExData[i] != abXG[i] )
										break;
								}
							}
							if( i == 8 ) // we have an XG!
							{
								// what direct music does
	//							TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
	//							if (!pPair) return dwBytes;
	//                        	mt -= 2; // so it's before any PC
	//							pPair->GetItemValue().mtTime = mt;
	//							pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_XG;
	//							InsertMidiMode(pPair);

								// what producer does
								gbIsXG = true;
							}
						}
					}

					pSysEx->dwPChannel = 0;
					pSysEx->mtTime = dwTime;
					DWORD dwTempLen = dwLen + 1;
					pSysEx->dwSysExLength = dwTempLen;
					/*
					if( NULL == gpSysExStream )
					{
						// create a stream to hold sysex events
						CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
					}
					if( gpSysExStream )
					{
						// bugbug error checking needs to be here
						gpSysExStream->Write( &pSysEx->lTime, sizeof(long), NULL );
						gpSysExStream->Write( &pSysEx->dwSysExLength, sizeof(DWORD), NULL );
						gpSysExStream->Write( pSysEx->pbSysExData, dwLen, NULL );
					}
					*/
					delete []pbSysExData;
					delete pSysEx;
				}
				else
				{
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				}
			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			}
			dwBytes += dwLen;
			break;
		case 0xf7:
			// ignore sysex f7 chunks
			dwBytes += MIDIGetVarLength( pStream, dwLen );
			StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			dwBytes += dwLen;
			break;
		case 0xff:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			dwBytes += MIDIGetVarLength( pStream, dwLen );
			if( b == 0x51 ) // tempo change
			{
				DWORD dw = 0;
//				DMUS_IO_TEMPO_ITEM tempo;

				while( dwLen > 0 )
				{
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return dwBytes;
					}
					++dwBytes;
					--dwLen;
					dw <<= 8;
					dw += b;
				}
				/*
				tempo.lTime = ConvertTime( dwTime );
				tempo.dblTempo = 60000000 / (double)dw;
				if( gpSegment && !gfSetTempo )
				{
					gpSegment->m_dblTempo = tempo.dblTempo;
					gfSetTempo = TRUE;
				}
				if( NULL == gpTempoStream )
				{
					// create a stream to hold tempo events
					CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
				}
				if( gpTempoStream )
				{
					gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
					// bugbug error checking needs to be here
				}
				*/
			}
			// We don't care about TimeSigs - just use the Style's TimeSig.
			/*
			else if( b == 0x58 && glTimeSig )
			{
				// glTimeSig will be set to 0 inside the main calling function
				// once we no longer care about time sigs.
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				// set glTimeSig to 2 to signal to the main function that we've
				// read a time sig on this track
				glTimeSig = 2;
				gTimeSigItem.lTime = dwTime;
				gTimeSigItem.bBeatsPerMeasure = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				gTimeSigItem.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
				gTimeSigItem.wGridsPerBeat = 4; // default
				++dwBytes;
				StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
				dwBytes += ( dwLen - 2 );
			}
			*/
			else if( b == 0x59 )
			{
				// Read sharps/flats and major/minor bytes
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				char cSharpsFlats = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				BYTE bMode = b;
				++dwBytes;

				if(!gKeySigExists)
				{
					// Create a chord (with one subchord) from the key info
					CreateChordFromKey(cSharpsFlats, bMode, dwTime, g_Chord, 
										&gdwKeyPattern, &gdwChordPattern, &gbKeyRoot, &gbChordRoot);
					gfKeyFlatsNotSharps = cSharpsFlats < 0 ? TRUE : FALSE;
					gfChordFlatsNotSharps = gfKeyFlatsNotSharps;
					gKeySigExists = true;
				}
			}
			else if( b == 0x03 )
			{
				// MIDI Sequence name/Track name/Subtitle
				*pszTrackName = new char[dwLen + 2];
				if( (*pszTrackName == NULL) || FAILED( pStream->Read( *pszTrackName, dwLen, NULL ) ) )
				{
					if( *pszTrackName != NULL )
					{
						delete []*pszTrackName;
						*pszTrackName = NULL;
					}
					return dwBytes;
				}

				// Add the null terminator
				(*pszTrackName)[dwLen] = 0;
				dwBytes += dwLen;
			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				dwBytes += dwLen;
			}
			break;
		default:
	//            DisplayDebug( 1, "Unknown midi event type: 0x%x", b );
			break;
		}
    }
    return dwBytes;
}

void CopyPatchItem(DMUS_IO_PATCH_ITEM* to, DMUS_IO_PATCH_ITEM* from)
{
	memcpy(to, from, sizeof(DMUS_IO_PATCH_ITEM));
	to->pNext = 0;
}

FullSeqEvent *DeleteEventFromList( FullSeqEvent *pList, FullSeqEvent *pEvent )
{
	if( pList == NULL )
	{
		return NULL;
	}
	if( pEvent == NULL )
	{
		return pList;
	}

	if( pList == pEvent )
	{
		pList = pEvent->pNext;
		pEvent->pNext = NULL;
		delete pEvent;
	}
	else
	{
		FullSeqEvent *pLast = pList;
		FullSeqEvent *pTmp = pList->pNext;
		while( (pTmp != pEvent) && pTmp)
		{
			pLast = pTmp;
			pTmp = pTmp->pNext;
		}

		ASSERT( pLast );
		ASSERT( pTmp );
		ASSERT( pTmp == pEvent );

		if( pLast && pTmp )
		{
			pLast->pNext = pTmp->pNext;
			pTmp->pNext = NULL;
			delete pTmp;
		}
	}

	return pList;
}

HRESULT WriteBandTrack(IDMUSProdRIFFStream* pRiffStream, DMUS_IO_PATCH_ITEM** lstPatchEvent, int nTracks, FullSeqEvent **lstEvent)
// this function (in ListOfBands) deletes patch change and zeros out lstPatchEvent, assuming its successful
// makes a band from first patch change on each channel
// This also eats the first volume and pan change, if they occur before (or concurrently with) the first note
{
	ASSERT(pRiffStream);

	// extract first patch change on each channel
	DMUS_IO_PATCH_ITEM*	lstFirstPatches = 0;
	DWORD	fFirstPatches = 0;
	
	for(DMUS_IO_PATCH_ITEM* pItem = *lstPatchEvent; pItem; pItem = pItem->pNext)
	{
		BYTE ch = (BYTE)(pItem->byStatus & 0xF);
		if(!(fFirstPatches & (1 << ch)))
		{
			// first patch change for this style
			DMUS_IO_PATCH_ITEM* pfirst = new DMUS_IO_PATCH_ITEM;
			CopyPatchItem(pfirst, pItem);
			pfirst->lTime = -1;
			lstFirstPatches = List_Cat(lstFirstPatches, pfirst);
			fFirstPatches |= (1 << ch);
		}
	}

	// Now, extract first vol/pan changes on each channel
	MUSIC_TIME mtEarliestVol[16] = {LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX};
	MUSIC_TIME mtEarliestPan[16] = {LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX,LONG_MAX};
	FullSeqEvent *lstEarliestVol[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	FullSeqEvent *lstEarliestPan[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	int nTrackEarliestVol[16] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
	int nTrackEarliestPan[16] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
	for( int nIndex = nTracks - 1; nIndex >= 0; nIndex-- )
	{
		FullSeqEvent *curEvent = lstEvent[nIndex];
		while( curEvent )
		{
			if( curEvent->bStatus == MIDI_CCHANGE )
			{
				if( curEvent->bByte1 == 7 )
				{
					// Check if volume is earlier than any other volume on this channel
					if( (curEvent->mtTime + curEvent->nOffset) < mtEarliestVol[curEvent->dwPChannel] )
					{
						mtEarliestVol[curEvent->dwPChannel] = curEvent->mtTime + curEvent->nOffset;
						lstEarliestVol[curEvent->dwPChannel] = curEvent;
						nTrackEarliestVol[curEvent->dwPChannel] = nIndex;
					}
				}
				else if( curEvent->bByte1 == 10 )
				{
					// Check if pan is earlier than any other pan on this channel
					if( (curEvent->mtTime + curEvent->nOffset) < mtEarliestPan[curEvent->dwPChannel] )
					{
						mtEarliestPan[curEvent->dwPChannel] = curEvent->mtTime + curEvent->nOffset;
						lstEarliestPan[curEvent->dwPChannel] = curEvent;
						nTrackEarliestPan[curEvent->dwPChannel] = nIndex;
					}
				}
			}
			else if( curEvent->bStatus == MIDI_NOTEON )
			{
				// Check if note is earlier than earliest volume on this channel
				if( (curEvent->mtTime + curEvent->nOffset) < mtEarliestVol[curEvent->dwPChannel] )
				{
					mtEarliestVol[curEvent->dwPChannel] = curEvent->mtTime + curEvent->nOffset;
					lstEarliestVol[curEvent->dwPChannel] = NULL;
					nTrackEarliestVol[curEvent->dwPChannel] = -1;
				}

				// Check if note is earlier than earliest pan on this channel
				if( (curEvent->mtTime + curEvent->nOffset) < mtEarliestPan[curEvent->dwPChannel] )
				{
					mtEarliestPan[curEvent->dwPChannel] = curEvent->mtTime + curEvent->nOffset;
					lstEarliestPan[curEvent->dwPChannel] = NULL;
					nTrackEarliestPan[curEvent->dwPChannel] = -1;
				}

				break;
			}

			curEvent = curEvent->pNext;
		}
	}

	WriteRiffChunk riff(pRiffStream, DMUS_FOURCC_BAND_FORM);
	HRESULT hr = riff.State();
	if(hr == S_OK)
	{
		ListOfInst listinst(lstFirstPatches, lstEarliestVol, lstEarliestPan);
		hr = listinst.Write(pRiffStream);
	}

	// Delete the volume/pan events from the lists
	for( nIndex = 0; nIndex < 16; nIndex++ )
	{
		lstEvent[nTrackEarliestVol[nIndex]] = DeleteEventFromList( lstEvent[nTrackEarliestVol[nIndex]], lstEarliestVol[nIndex] );
		lstEvent[nTrackEarliestPan[nIndex]] = DeleteEventFromList( lstEvent[nTrackEarliestPan[nIndex]], lstEarliestPan[nIndex] );
	}

	List_Free(lstFirstPatches);
	List_Free(*lstPatchEvent);
	*lstPatchEvent = 0;

	return hr;
}




// Creates and returns (in rChord) a DMUS_CHORD_PARAM given the three input params.
// the new chord will have one subchord containing the root, third, fifth, and seventh
// of the key (as indicated by the sharps/flats and mode).  Scale will be either
// major or minor, depending on the mode (mode is 0 if major, 1 if minor).
#pragma warning(disable:4244)
const DWORD adwFlatScales[8] = {
	0x00AB5AB5,
	0x006B56B5,
	0x006AD6AD,
	0x005AD5AD,
	0x005AB5AB,
	0x0056B56B,
	0x00D6AD6A,
	0x00D5AD5A};
const DWORD adwSharpScales[8] = {
	0x00AB5AB5,
	0x00AD5AD5,
	0x00AD6AD6,
	0x00B56B56,
	0x00B5AB5A,
	0x00D5AD5A,
	0x00D6AD6A,
	0x0056B56B};

const bool bShiftScale = false;	// work around for bug: in producer scale root always 0, and scale pattern
								// shifted accordingly
void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord,
						DWORD* scalepattern, DWORD* chordpattern, BYTE* scaleroot, BYTE* chordroot)
{
	TRACE("Creating a chord.  Key: %d Mode: %d Time: %d\n", cSharpsFlats, bMode, dwTime);
	static DWORD dwMajorScale = 0xab5ab5;	// 1010 1011 0101 1010 1011 0101
	static DWORD dwMinorScale = 0x5ad5ad;	// 0101 1010 1101 0101 1010 1101
	static DWORD dwMajor7Chord = 0x891;		// 1000 1001 0001
	static DWORD dwMinor7Chord = 0x489;		// 0100 1000 1001
	BYTE bScaleRoot = 0;
	BYTE bChordRoot = 0;
	bMode = 0;		// for now disable the ability to distinguish modes
					// will need to update MidiStripMgr::AddChordTrack to deal with this
	switch (cSharpsFlats)
	{
	case  0: bChordRoot = bMode ?  9 :  0; break;
	case  1: bChordRoot = bMode ?  4 :  7; break;
	case  2: bChordRoot = bMode ? 11 :  2; break;
	case  3: bChordRoot = bMode ?  6 :  9; break;
	case  4: bChordRoot = bMode ?  1 :  4; break;
	case  5: bChordRoot = bMode ?  8 : 11; break;
	case  6: bChordRoot = bMode ?  3 :  6; break;
	case  7: bChordRoot = bMode ? 10 :  1; break;
	case -1: bChordRoot = bMode ?  2 :  5; break;
	case -2: bChordRoot = bMode ?  7 : 10; break;
	case -3: bChordRoot = bMode ?  0 :  3; break;
	case -4: bChordRoot = bMode ?  5 :  8; break;
	case -5: bChordRoot = bMode ? 10 :  1; break;
	case -6: bChordRoot = bMode ?  3 :  6; break;
	case -7: bChordRoot = bMode ?  8 : 11; break;
	}

	// transpose up an octave
	bChordRoot += 12;
	bScaleRoot = bChordRoot;

	if (bMode)
	{
		wcscpy(rChord.wszName, L"m7");
	}
	else
	{
		wcscpy(rChord.wszName, L"M7");
	}
	DMUS_IO_TIMESIGNATURE_ITEM timesig;
	timesig.bBeat = 4;
	timesig.bBeatsPerMeasure = 4;
	timesig.wGridsPerBeat = 4;
	DWORD dwAbsBeat = dwTime / (DMUS_PPQ * (4 / timesig.bBeat));
	rChord.wMeasure = (WORD)(dwAbsBeat / timesig.bBeatsPerMeasure);
	rChord.bBeat = (BYTE)(dwAbsBeat % timesig.bBeatsPerMeasure);
	rChord.bSubChordCount = 4;
	for(int i = 0; i < 4; i++)
	{
		rChord.SubChordList[i].dwChordPattern = bMode ? dwMinor7Chord : dwMajor7Chord;
		rChord.SubChordList[i].dwScalePattern = bMode ? dwMinorScale : dwMajorScale;
		rChord.SubChordList[i].dwInversionPoints = 0xffffff;	// inversions allowed everywhere
		rChord.SubChordList[i].dwLevels = 1<<i;
		rChord.SubChordList[i].bChordRoot = bChordRoot;
		rChord.SubChordList[i].bScaleRoot = bScaleRoot;
	}

	BYTE key = bChordRoot % 12;
	DWORD scale;
	if(cSharpsFlats >= 0)
	{
		scale = ((adwSharpScales[cSharpsFlats] >> key) |
						  (0x00FFFFFF & (adwSharpScales[cSharpsFlats] << (12 - key))));
//		rChord.bKey = 0;
	}
	else
	{
		scale = ((adwFlatScales[-cSharpsFlats] >> key) |
						  (0x00FFFFFF & (adwFlatScales[-cSharpsFlats] << (12 - key))));
//		rChord.bKey = 1;
	}

	if(scalepattern)
	{
		*scalepattern = scale;
	}
	if(chordpattern)
		*chordpattern = bMode ? dwMinor7Chord : dwMajor7Chord;
	if(chordroot)
		*chordroot = bChordRoot;
	if(scaleroot)
	{
		if(bShiftScale)
			*scaleroot = 0;
		else
			*scaleroot = bScaleRoot;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\MIDIFile.h ===
#ifndef MIDIFILE_H
#define MIDIFILE_H
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#include <dmusicf.h>
#include <dmuspriv.h>
#include <dmusicc.h>
#pragma warning( pop )
#include "alist.h"
#include "templates.h"



/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF  ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE          0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS	16

/* FullSeqEvent is SeqEvent plus next pointers*/
typedef struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
	struct FullSeqEvent*   pNext;
	struct FullSeqEvent*	pTempNext; /* used in the compresseventlist routine */
} FullSeqEvent;


DWORD MIDIConvertTime( DWORD dwTime );

FullSeqEvent* MIDICompressEventList( FullSeqEvent* lstEvent );
FullSeqEvent* MIDIMergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent );
FullSeqEvent* MIDIRemoveDuplicateCCs( FullSeqEvent* lstEvent );
FullSeqEvent* MIDIReverseEventList( FullSeqEvent* lstEvent );
FullSeqEvent* MIDISortEventList( FullSeqEvent* lstEvent );
DWORD MIDIReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent, LPSTR* pszTrackName );
HRESULT WriteBandTrack(IDMUSProdRIFFStream* pRiffStream, DMUS_IO_PATCH_ITEM** lstPatchEvent, int nTracks, FullSeqEvent **lstEvent );

DMUS_IO_TIMESIGNATURE_ITEM& MIDITimeSig();	// returns internal timesig used by midi parsing engine (midifile.cpp)
long& MIDITimeSigFlag();			// flag that signals midi parsing engine to scan for time signature (0 == stop scan, 1 == start scan, 2 == midi
													// parsing has found signal.

DMUS_IO_BANKSELECT_ITEM& MIDIBankSelect(int ch);

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
    union uShort
	{
	unsigned char buf[2];
	short n;
	} u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 2, NULL ) )
    {
	return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[1];
    u.buf[1] = ch;
#endif

    n = u.n;
    return TRUE;
}

short& MIDIsnPPQN();

void MIDIInit();
void MIDIInitBankSelect();
void MIDIInitChordOfComposition();
// this is not being used and should not as overall key and enharmonics is not preserved
//void MIDIGetChordOfComposition(DMUS_CHORD_PARAM& chord);
void MIDIGetChordOfComposition(DWORD& keypattern, DWORD& chordpattern, BYTE& keyroot, BYTE& chordroot, 
							   BOOL& fKeyFlatsNotSharps, BOOL& fChordFlatsNotSharps);

WORD MIDIGetVarLength( LPSTREAM pStream, DWORD& rfdwValue );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\NewPatternDlg.cpp ===
// NewPatternDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "NewPatternDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg dialog


CNewPatternDlg::CNewPatternDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNewPatternDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewPatternDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_wEmbellishment = EMB_NORMAL;
	m_pPattern = NULL;
	m_pStyle = NULL;
}


void CNewPatternDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPatternDlg)
	DDX_Control(pDX, IDC_PATTERN_LIST, m_lstbxPattern);
	DDX_Control(pDX, IDC_NEW_PATTERN, m_radioNewPattern);
	DDX_Control(pDX, IDC_LINK_PATTERN, m_radioLinkPattern);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewPatternDlg, CDialog)
	//{{AFX_MSG_MAP(CNewPatternDlg)
	ON_BN_CLICKED(IDC_NEW_PATTERN, OnNewPattern)
	ON_BN_DOUBLECLICKED(IDC_NEW_PATTERN, OnDoubleClickedNewPattern)
	ON_BN_CLICKED(IDC_LINK_PATTERN, OnLinkPattern)
	ON_BN_DOUBLECLICKED(IDC_LINK_PATTERN, OnDoubleClickedLinkPattern)
	ON_LBN_SELCHANGE(IDC_PATTERN_LIST, OnSelChangePatternList)
	ON_WM_COMPAREITEM()
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnInitDialog

BOOL CNewPatternDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	ASSERT( m_pStyle != NULL );	// Should have been set after CNewPatternDlg was constructed

	// Get text for dialog title and controls
	CString strTitle;
	CString strTextNew;
	CString strTextLink;

	if( m_wEmbellishment & EMB_MOTIF )
	{
		strTitle.LoadString( IDS_NEW_MOTIF_TEXT );
		strTextNew.LoadString( IDS_CREATE_NEW_MOTIF_TEXT );
		strTextLink.LoadString( IDS_CREATE_LINK_MOTIF_TEXT );
	}
	else
	{
		strTitle.LoadString( IDS_NEW_PATTERN_TEXT );
		strTextNew.LoadString( IDS_CREATE_NEW_PATTERN_TEXT );
		strTextLink.LoadString( IDS_CREATE_LINK_PATTERN_TEXT );
	}

	// Initialize title of dialog
	SetWindowText( strTitle );
	
	// Initialize radio buttons
	m_radioNewPattern.SetCheck( 1 );
	m_radioNewPattern.SetWindowText( strTextNew );
	m_radioLinkPattern.SetCheck( 0 );
	m_radioLinkPattern.SetWindowText( strTextLink );

	// Fill Pattern list box
	CDirectMusicPattern* pPattern;

    //		Add Patterns
	POSITION pos = m_pStyle->m_StylePatterns.m_lstPatterns.GetHeadPosition();
    while( pos )
    {
        pPattern = m_pStyle->m_StylePatterns.m_lstPatterns.GetNext( pos );

		m_lstbxPattern.AddString( (LPCTSTR)pPattern  );
	}

    //		Add Motifs
    pos = m_pStyle->m_StyleMotifs.m_lstMotifs.GetHeadPosition();
    while( pos )
    {
        pPattern = m_pStyle->m_StyleMotifs.m_lstMotifs.GetNext( pos );

		m_lstbxPattern.AddString( (LPCTSTR)pPattern  );
	}

	// Disable Pattern list box
	m_lstbxPattern.EnableWindow( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnNewPattern

void CNewPatternDlg::OnNewPattern() 
{
	if( m_radioNewPattern.GetCheck() )
	{
		m_lstbxPattern.EnableWindow( FALSE );
	}
	else
	{
		m_lstbxPattern.EnableWindow( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnDoubleClickedNewPattern

void CNewPatternDlg::OnDoubleClickedNewPattern() 
{
	OnNewPattern();
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnLinkPattern

void CNewPatternDlg::OnLinkPattern() 
{
	if( m_radioLinkPattern.GetCheck() )
	{
		m_lstbxPattern.EnableWindow( TRUE );
	}
	else
	{
		m_lstbxPattern.EnableWindow( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnDoubleClickedLinkPattern

void CNewPatternDlg::OnDoubleClickedLinkPattern() 
{
	OnLinkPattern();
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnSelChangePatternList

void CNewPatternDlg::OnSelChangePatternList() 
{
	m_pPattern = NULL;

	// Get the current Pattern
	int nPos = m_lstbxPattern.GetCurSel();
	if( nPos == LB_ERR )
	{
		return;
	}

	// Get a pointer to the Pattern
	CDirectMusicPattern* pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
	if( pPattern 
	&&  pPattern != (CDirectMusicPattern *)-1 )
	{
		m_pPattern = pPattern;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnOK

void CNewPatternDlg::OnOK() 
{
	if( m_radioNewPattern.GetCheck() )
	{
		EndDialog( IDC_NEW_PATTERN );
	}
	else if( m_radioLinkPattern.GetCheck() )
	{
		if( m_pPattern == NULL )
		{
			AfxMessageBox( IDS_MISSING_PATTERN );
			m_lstbxPattern.SetFocus();
		}
		else
		{
			EndDialog( IDC_LINK_PATTERN );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnMeasureItem

void CNewPatternDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_PATTERN_LIST:
		{
			TEXTMETRIC tm;
			
			CDC* pDC = GetDC();
			if( pDC )
			{
				pDC->GetTextMetrics( &tm );
				lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;

				ReleaseDC( pDC );
				return;
			}
		}
	}
	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnCompareItem

int CNewPatternDlg::OnCompareItem( int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern1 = (CDirectMusicPattern *)lpCompareItemStruct->itemData1;
			CDirectMusicPattern* pPattern2 = (CDirectMusicPattern *)lpCompareItemStruct->itemData2;

			// Place Motifs at the bottom of the list
			if( !(pPattern1->m_wEmbellishment & EMB_MOTIF)
			&&   (pPattern2->m_wEmbellishment & EMB_MOTIF) )
			{
				return -1;
			}
			if(  (pPattern1->m_wEmbellishment & EMB_MOTIF)
			&&  !(pPattern2->m_wEmbellishment & EMB_MOTIF) )
			{
				return 1;
			}

			return pPattern1->m_strName.CompareNoCase( pPattern2->m_strName );
		}
	}
	
	return CDialog::OnCompareItem( nIDCtl, lpCompareItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg::OnDrawItem

void CNewPatternDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_PATTERN_LIST:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
                pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				// Get the Pattern
				CDirectMusicPattern* pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( lpDrawItemStruct->itemID );
				ASSERT( pPattern != NULL ); 

				// Format the string
				CString strText;
				if( pPattern->m_wEmbellishment & EMB_MOTIF )
				{
					CString strMotifText;
					strMotifText.LoadString( IDS_MOTIF_TEXT );
					strText = strMotifText + _T(":  ") + pPattern->m_strName;
				}
				else
				{
					CString strPatternText;
					strPatternText.LoadString( IDS_PATTERN_TEXT );
					strText = strPatternText + _T(":  ") + pPattern->m_strName;
				}
				
				int nBkModeOld = pDC->SetBkMode( TRANSPARENT );
				if( m_lstbxPattern.IsWindowEnabled() )
				{
					pDC->SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
				}
				else
				{
					pDC->SetTextColor( ::GetSysColor(COLOR_GRAYTEXT) );
				}

				// Draw the string
				pDC->FillSolidRect( &lpDrawItemStruct->rcItem, ::GetSysColor(COLOR_WINDOW) );
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
		        pDC->DrawText( strText, -1, &lpDrawItemStruct->rcItem, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
				
				// Cleanup
				pDC->SetBkMode( nBkModeOld );

				// Invert if selected
                if( lpDrawItemStruct->itemState & ODS_SELECTED )
				{
					pDC->InvertRect( &lpDrawItemStruct->rcItem );
				}
			}

			return;
		}
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Pattern.cpp ===
// Pattern.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "VarChoices.h"
#include "PatternCtl.h"
#include <mmreg.h>
#include <PChannelname.h>
#include "DialogLinkExisting.h"
#include <SegmentGUIDS.h>
#include <ioDMStyle.h>
#include "RiffStructs.h"
#include "StyleCtl.h"
#include "TabPatternPattern.h"
#include "TabMotifMotif.h"
#include "TabMotifLoop.h"
#include <TabBoundaryFlags.h>
#include "SharedPattern.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// FROM SuperJAM! Drum Map
static char achMappingsToDMUS[128] = {
         0,			//0 },
         35,		//1  },
         36,		//2  },
         38,		//3  },
         40,		//4  },
         41,		//5  },
         45,		//6  },
         48,		//7  },
         42,		//8  },
         44,		//9  },
         46,		//10 },
         39,		//11 },
         37,		//12 },
         51,		//13 },
         49,		//14 },
         54,		//15 },
         56,		//16 },
         61,		//17 },
         60,		//18 },
         64,		//19 },
         63,		//20 },
         66,		//21 },
         65,		//22 },
         69,		//23 },
         70,		//24 },
         71,		//25 },
         72,		//26 },
         73,		//27 },
         75,		//28 },
         47,		//29 },
         50,		//30 },
         53,		//31 },
         57,		//32 },
         52,		//33 },
         74,		//34 },
		 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
		 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74,
		 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
		 95, 96, 97, 98,
         87,		//99 },
         86,		//100 },
         85,		//101 },
         84,		//102 },
         83,		//103 },
         82,		//104 },
         81,		//105 },
         80,		//106 },
         79,		//107 },
         78,		//108 },
         77,		//109 },
         76,		//110 },
         68,		//111 },
         67,		//112 },
         62,		//113 },
         59,		//114 },
         58,		//115 },
         55,		//116 },
         43,		//117 },
         34,		//118 },
         33,		//119 },
         32,		//120 },
         31,		//121 },
         30,		//122 },
         29,		//123 },
         28,		//124 },
         27,		//125 },
         26,		//126 },
		 25,		//127 }
};

// TO SuperJAM! Drum Map
static char achMappingsToIMA[128] = {
         0,
		 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
		 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
		 21, 22, 23, 24,
		 127,		//25
		 126,		//26
		 125,		//27
		 124,		//28
		 123,		//29
		 122,		//30
		 121,		//31
		 120,		//32
		 119,		//33
		 118,		//34
		 1,			//35
		 2,			//36
		 12,		//37
		 3,			//38
		 11,		//39
		 4,			//40
		 5,			//41
		 8,			//42
		 117,		//43
		 9,			//44
		 6,			//45
		 10,		//46
		 29,		//47
		 7,			//48
		 14,		//49
		 30,		//50	
		 13,		//51
		 33,		//52
		 31,		//53
		 15,		//54
		 116,		//55
		 16,		//56
		 32,		//57
		 115,		//58
		 114,		//59
		 18,		//60
		 17,		//61
		 113,		//62
		 20,		//63
		 19,		//64
		 22,		//65
		 21,		//66
		 112,		//67
		 111,		//68
		 23,		//69
		 24,		//70
		 25,		//71
		 26,		//72
		 27,		//73
		 34,		//74
		 28,		//75
		 110,		//76
		 109,		//77
		 108,		//78
		 107,		//79
		 106,		//80
		 105,		//81
		 104,		//82
		 103,		//83
		 102,		//84
		 101,		//85
		 100,		//86
		 99,		//87
		 88,		//88
		 89,		//89
		 90,		//90
		 91,		//91
		 92,		//92
		 93,		//93
		 94,		//64
		 95,		//95
		 96,		//96
		 97,		//97
		 98,		//98
		 99, 100, 
		 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
		 111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
		 121, 122, 123, 124, 125, 126, 127
};


// {27D9B240-733E-11d1-89AE-00A0C9054129}
static const GUID GUID_MotifPropPageManager = 
{ 0x27d9b240, 0x733e, 0x11d1, { 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };

// {37A0B2A0-733E-11d1-89AE-00A0C9054129}
static const GUID GUID_PatternPropPageManager = 
{ 0x37a0b2a0, 0x733e, 0x11d1, { 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };

short CMotifPropPageManager::sm_nActiveTab = 0;

static BOOL sg_fPatternFromMidiMgr = FALSE;

// This code is shared with Segment.cpp in the Segment Designer project
HRESULT DoAutoTransition( const ConductorTransitionOptions &TransitionOptions, IDirectMusicPerformance *pPerformance,
						IDirectMusicComposer8 *pIDMComposer, IDirectMusicSegment *pSegmentTo,
						IDirectMusicChordMap *pIDMChordMap, IDirectMusicSegmentState **ppTransitionSegmentState,
						IDirectMusicSegmentState **ppSegmentStateTo )
{
	IDirectMusicSegment *pITransitionSegment = NULL;

	// Set the transition pattern (embellishment)
	WORD wCommand = 0;
	if( !(TransitionOptions.dwFlags & TRANS_REGULAR_PATTERN) )
	{
		// if we have an embellishment, set it.
		wCommand = TransitionOptions.wPatternType;
	}

	// Set the transition flags
	DWORD dwFlags = TransitionOptions.dwBoundaryFlags;

	// Set the Boundary settings (bar/beat/grid/immediate/end of segment)
	{
		// Can't use COMPOSEF_QUEUE, so use COMPOSEF_SEGMENTEND
		dwFlags |= DMUS_COMPOSEF_SEGMENTEND;
	}

	HRESULT hr = pIDMComposer->AutoTransition(pPerformance, 
											   pSegmentTo, 
											   wCommand, 
											   dwFlags, 
											   pIDMChordMap, 
											   &pITransitionSegment, 
											   ppSegmentStateTo, 
											   ppTransitionSegmentState);

	if( pITransitionSegment )
	{
		pITransitionSegment->Release();
		pITransitionSegment = NULL;
	}

	if( ppSegmentStateTo
	&&	(NULL == *ppSegmentStateTo) )
	{
		hr = E_FAIL;
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
// CMotifPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMotifPropPageManager::CMotifPropPageManager()
{
	m_pTabMotif = NULL;
	m_pTabLoop = NULL;
	m_pTabBoundary = NULL;
	m_GUIDManager = GUID_MotifPropPageManager;
}

CMotifPropPageManager::~CMotifPropPageManager()
{
	if( m_pTabMotif )
	{
		delete m_pTabMotif;
	}

	if( m_pTabLoop )
	{
		delete m_pTabLoop;
	}

	if( m_pTabBoundary )
	{
		delete m_pTabBoundary;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMotifPropPageManager::RemoveCurrentObject

void CMotifPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMotifPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CMotifPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strMotif;

	strMotif.LoadString( IDS_MOTIF_TEXT );

	CString strTitle = strMotif;

	PPGMotif ppgMotif;
	PPGMotif* pPPGMotif = &ppgMotif;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pPPGMotif))) )
	{
		if( ppgMotif.pMotif )
		{
			// Get Style Name
			CString strStyleName;
			BSTR bstrStyleName;
			IDMUSProdNode* pIDocRootNode;

			if( SUCCEEDED ( ppgMotif.pMotif->GetDocRootNode( &pIDocRootNode ) ) )
			{
				if( SUCCEEDED ( pIDocRootNode->GetNodeName( &bstrStyleName ) ) )
				{
					strStyleName = bstrStyleName;
					::SysFreeString( bstrStyleName );
					strStyleName += _T(" - ");
				}

				RELEASE( pIDocRootNode );
			}

			// Format title
			strTitle = strMotif + _T(": ") + strStyleName + ppgMotif.pMotif->m_strName;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMotifPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CMotifPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Motif tab
	m_pTabMotif = new CTabMotifMotif( this );
	if( m_pTabMotif )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabMotif->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Loop tab
	m_pTabLoop = new CTabMotifLoop( this );
	if( m_pTabLoop )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabLoop->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Boundary tab
	m_pTabBoundary = new CTabBoundaryFlags( this );
	if( m_pTabBoundary )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabBoundary->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMotifPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CMotifPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CMotifPropPageManager::sm_nActiveTab );

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMotifPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CMotifPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pTabBoundary )
	{
		m_pTabBoundary->SetObject( pINewPropPageObject );
	}
	
	if( m_pIPropPageObject != pINewPropPageObject )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing
	}

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CMotifPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CMotifPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure changes to current Motif are processed in OnKillFocus
	// messages before setting the new Motif
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabMotif->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Refresh Property tabs to display the new Motif
	m_pTabMotif->RefreshTab( m_pIPropPageObject );
	m_pTabLoop->RefreshTab( m_pIPropPageObject );
	m_pTabBoundary->RefreshTab();

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// CPatternPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPatternPropPageManager::CPatternPropPageManager()
{
	m_pTabPattern = NULL;
	m_GUIDManager = GUID_PatternPropPageManager;
}

CPatternPropPageManager::~CPatternPropPageManager()
{
	if( m_pTabPattern )
	{
		delete m_pTabPattern;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPatternPropPageManager::RemoveCurrentObject

void CPatternPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CPatternPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strPattern;

	strPattern.LoadString( IDS_PATTERN_TEXT );

	CString strTitle = strPattern;

	PPGPattern ppgPattern;
	PPGPattern* pPPGPattern = &ppgPattern;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pPPGPattern))) )
	{
		// Get Style Name
		CString strStyleName;
		BSTR bstrStyleName;
		IDMUSProdNode* pIDocRootNode;

		if( SUCCEEDED ( ppgPattern.pPattern->GetDocRootNode( &pIDocRootNode ) ) )
		{
			if( SUCCEEDED ( pIDocRootNode->GetNodeName( &bstrStyleName ) ) )
			{
				strStyleName = bstrStyleName;
				::SysFreeString( bstrStyleName );
				strStyleName += _T(" - ");
			}

			RELEASE( pIDocRootNode );
		}

		// Format title
		strTitle = strPattern + _T(": ") + strStyleName + ppgPattern.pPattern->m_strName;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CPatternPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);


	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Pattern tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	m_pTabPattern = new CTabPatternPattern( this );
	if( m_pTabPattern )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabPattern->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CPatternPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CPatternPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure changes to current Pattern are processed in OnKillFocus
	// messages before setting the new Pattern
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabPattern->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Refresh Property tabs to display the new Pattern
	m_pTabPattern->RefreshTab( m_pIPropPageObject );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CIMA25EventItem destructor

CIMA25EventItem::~CIMA25EventItem()
{
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicEventItem destructor

CDirectMusicEventItem::~CDirectMusicEventItem()
{
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve contructor

CDirectMusicStyleCurve::CDirectMusicStyleCurve()
{
	m_mtGridStart = 0;
	m_nTimeOffset = 0;
	m_dwVariation = 0;
	m_bType = ET_CURVE;

	m_mtDuration = 0;
	m_mtResetDuration = 0;
	m_nStartValue = 0;	
	m_nEndValue = 0;	
	m_nResetValue = 0;	
    m_bEventType = DMUS_CURVET_CCCURVE;	
	m_bCurveShape = DMUS_CURVES_SINE;	
	m_bCCData = 0;		
	m_bFlags = 0;		
	m_wParamType = 0;
	m_wMergeIndex =0;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleMarker contructor

CDirectMusicStyleMarker::CDirectMusicStyleMarker()
{
	m_pNext = 0;
	m_mtGridStart = 0;
	m_nTimeOffset = 0;
	m_dwVariation = 0;
	m_bType = ET_MARKER;
	m_wMarkerFlags = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart constructor/destructor

CDirectMusicPart::CDirectMusicPart( CDirectMusicStyle* pStyle )
{
	ASSERT( pStyle != NULL );
    
	m_pStyle = pStyle;
//	m_pStyle->AddRef();		intentionally missing

	m_dwUseCount = 0;
	m_dwHardLinkCount = 0;
	
	// Set defaults
	m_TimeSignature = m_pStyle->m_TimeSignature;
	m_wNbrMeasures = 1;
	m_bPlayModeFlags = DMUS_PLAYMODE_PURPLEIZED;			
	m_bInvertLower = 0;			
	m_bInvertUpper = 127;
	m_dwFlags = 0;

	for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
	{
		m_dwVariationChoices[i] = (DM_VF_MODE_DMUSIC | DM_VF_FLAG_BITS);	
	}

	m_pVarChoicesNode = NULL;
	m_pVarChoicesPartRef = NULL;
	m_pPartDesignData = NULL;
	m_dwPartDesignDataSize = 0;
	
	CoCreateGuid( &m_guidPartID ); 
}

CDirectMusicPart::~CDirectMusicPart()
{
	if( m_pPartDesignData )
	{
		GlobalFree( m_pPartDesignData );
	}

	if( m_pVarChoicesNode )
	{
		HWND hWndEditor;
		m_pVarChoicesNode->GetEditorWindow( &hWndEditor );
		if( hWndEditor )
		{
			theApp.m_pStyleComponent->m_pIFramework->CloseEditor( m_pVarChoicesNode );
		}
		RELEASE( m_pVarChoicesNode );
	}

	m_pVarChoicesPartRef = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::CopyTo

void CDirectMusicPart::CopyTo( CDirectMusicPart* pDMPart )
{
	ASSERT( pDMPart );

	pDMPart->m_pStyle = m_pStyle;
//	m_pStyle->AddRef();		intentionally missing

	ASSERT( pDMPart->m_dwPartDesignDataSize == m_dwPartDesignDataSize );
	if( pDMPart->m_dwPartDesignDataSize == m_dwPartDesignDataSize )
	{
		*pDMPart->m_pPartDesignData = *m_pPartDesignData;
	}

	pDMPart->m_pVarChoicesNode = NULL;
	pDMPart->m_pVarChoicesPartRef = NULL;
	pDMPart->m_strName = m_strName;
	memcpy( &pDMPart->m_guidPartID, &m_guidPartID, sizeof(GUID) );
	pDMPart->m_TimeSignature = m_TimeSignature;
	pDMPart->m_wNbrMeasures = m_wNbrMeasures;
	memcpy( pDMPart->m_dwVariationChoices, m_dwVariationChoices, sizeof(DWORD) * 32 );
	pDMPart->m_bPlayModeFlags = m_bPlayModeFlags;
	pDMPart->m_bInvertLower = m_bInvertLower;
	pDMPart->m_bInvertUpper = m_bInvertUpper;
	pDMPart->m_dwFlags = m_dwFlags;

	// Copy the list of events
	CDirectMusicEventItem* pItem = m_lstEvents.GetHead();
	while( pItem )
	{
		if( pItem->m_bType == ET_NOTE )
		{
			CDirectMusicStyleNote* pNote = new CDirectMusicStyleNote;
			*pNote = *(CDirectMusicStyleNote *)pItem;
			pDMPart->m_lstEvents.AddHead( pNote );
		}
		else if( pItem->m_bType == ET_CURVE )
		{
			CDirectMusicStyleCurve* pCurve = new CDirectMusicStyleCurve;
			*pCurve = *(CDirectMusicStyleCurve *)pItem;
			pDMPart->m_lstEvents.AddHead( pCurve );
		}
		else if( pItem->m_bType == ET_MARKER )
		{
			CDirectMusicStyleMarker* pMarker = new CDirectMusicStyleMarker;
			*pMarker = *(CDirectMusicStyleMarker *)pItem;
			pDMPart->m_lstEvents.AddHead( pMarker );
		}

		pItem = pItem->GetNext();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_LoadPart

HRESULT CDirectMusicPart::DM_LoadPart( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	MMCKINFO ckList;
	DWORD dwByteCount;
	DWORD dwSize;
    DWORD dwStructSize;
    DWORD dwExtra;

	CDirectMusicEventList lstNotes;	
	CDirectMusicEventList lstCurves;
	CDirectMusicEventList lstMarkers;

	ASSERT( m_pStyle != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Clear Part UI fields
	memset( m_pPartDesignData, 0, m_dwPartDesignDataSize );

	// Clear Part name
	m_strName.Empty();

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PART_CHUNK:
			{
				BOOL fIsDX7 = ck.cksize == 154;	// Size of DX7 struct

				DMUS_IO_STYLEPART dmusStylePartIO;
				ZeroMemory( &dmusStylePartIO, sizeof( DMUS_IO_STYLEPART ) );

				dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLEPART ) );
				hr = pIStream->Read( &dmusStylePartIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( m_pStyle->FindPartByGUID( dmusStylePartIO.guidPartID ) )
				{
					hr = S_FALSE;	// Style already contains a Part with this GUID
					goto ON_ERROR;	// so we must bypass this Part
				}

				m_TimeSignature.m_bBeatsPerMeasure = dmusStylePartIO.timeSig.bBeatsPerMeasure;
				m_TimeSignature.m_bBeat = dmusStylePartIO.timeSig.bBeat;
				m_TimeSignature.m_wGridsPerBeat = dmusStylePartIO.timeSig.wGridsPerBeat;

				m_wNbrMeasures = dmusStylePartIO.wNbrMeasures;
				m_bInvertUpper = dmusStylePartIO.bInvertUpper;
				m_bInvertLower = dmusStylePartIO.bInvertLower;
				m_bPlayModeFlags = dmusStylePartIO.bPlayModeFlags;
				m_dwFlags = dmusStylePartIO.dwFlags;

				memcpy( &m_guidPartID, &dmusStylePartIO.guidPartID, sizeof(GUID) );
				memcpy( &m_dwVariationChoices, &dmusStylePartIO.dwVariationChoices, sizeof(m_dwVariationChoices) );

				for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
				{
					if( m_dwVariationChoices[i] == 0xFFFFFFFF )
					{
						m_dwVariationChoices[i] = (DM_VF_MODE_DMUSIC | DM_VF_FLAG_BITS);	
					}
					if( fIsDX7
					&& (m_dwVariationChoices[i] & DM_VF_MODE_DMUSIC) )
					{
						m_dwVariationChoices[i] |= DM_VF_DEST_TOOTHER;	
					}
				}
				break;
			}

			case DMUS_FOURCC_NOTE_CHUNK:
			{
				CDirectMusicStyleNote* pNote;
				DMUS_IO_STYLENOTE dmusStyleNoteIO;

				dwSize = ck.cksize;

				// Read size of the note structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( DMUS_IO_STYLENOTE ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLENOTE );
					dwStructSize = sizeof( DMUS_IO_STYLENOTE );
				}
				else
				{
					dwExtra = 0;
				}

				// now read in the notes
				while( dwSize > 0 )
				{
					// Prepare DMUS_IO_STYLENOTE structure
					ZeroMemory( &dmusStyleNoteIO, sizeof( DMUS_IO_STYLENOTE ) );

					hr = pIStream->Read( &dmusStyleNoteIO, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Note
					pNote = new CDirectMusicStyleNote;
					if( pNote )
					{
						pNote->m_mtGridStart = dmusStyleNoteIO.mtGridStart;
						pNote->m_dwVariation = dmusStyleNoteIO.dwVariation;
						pNote->m_mtDuration = dmusStyleNoteIO.mtDuration;
						pNote->m_nTimeOffset = dmusStyleNoteIO.nTimeOffset;

						pNote->m_wMusicValue = dmusStyleNoteIO.wMusicValue;
						pNote->m_bVelocity = dmusStyleNoteIO.bVelocity;
						pNote->m_bTimeRange = dmusStyleNoteIO.bTimeRange;
						pNote->m_bDurRange = dmusStyleNoteIO.bDurRange;
						pNote->m_bVelRange = dmusStyleNoteIO.bVelRange;
						pNote->m_bInversionId = dmusStyleNoteIO.bInversionID; 
						pNote->m_bPlayModeFlags = dmusStyleNoteIO.bPlayModeFlags;
						pNote->m_bNoteFlags = dmusStyleNoteIO.bNoteFlags;

						// Place note in Part's event list
						lstNotes.AddHead( pNote );
					}
				}
				break;
			}

			case DMUS_FOURCC_CURVE_CHUNK:
			{
				CDirectMusicStyleCurve* pCurve;
				DMUS_IO_STYLECURVE dmusStyleCurveIO;

				dwSize = ck.cksize;

				// Read size of the note structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				if( dwStructSize > sizeof( DMUS_IO_STYLECURVE ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLECURVE );
					dwStructSize = sizeof( DMUS_IO_STYLECURVE );
				}
				else
				{
					dwExtra = 0;
				}

				// now read in the curves
				while( dwSize > 0 )
				{
					ZeroMemory( &dmusStyleCurveIO, sizeof( DMUS_IO_STYLECURVE ) );
					hr = pIStream->Read( &dmusStyleCurveIO, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music Curve
					pCurve = new CDirectMusicStyleCurve;
					if( pCurve )
					{
						pCurve->m_mtGridStart = dmusStyleCurveIO.mtGridStart;
						pCurve->m_dwVariation = dmusStyleCurveIO.dwVariation;
						pCurve->m_mtDuration = dmusStyleCurveIO.mtDuration;
						pCurve->m_mtResetDuration = dmusStyleCurveIO.mtResetDuration;
						pCurve->m_nTimeOffset = dmusStyleCurveIO.nTimeOffset;

						pCurve->m_nStartValue = dmusStyleCurveIO.nStartValue;
						pCurve->m_nEndValue = dmusStyleCurveIO.nEndValue;
						pCurve->m_nResetValue = dmusStyleCurveIO.nResetValue;
						pCurve->m_bEventType = dmusStyleCurveIO.bEventType;
						pCurve->m_bCurveShape = dmusStyleCurveIO.bCurveShape;
						pCurve->m_bCCData = dmusStyleCurveIO.bCCData;
						pCurve->m_bFlags = dmusStyleCurveIO.bFlags;
						pCurve->m_wParamType = dmusStyleCurveIO.wParamType;
						pCurve->m_wMergeIndex = dmusStyleCurveIO.wMergeIndex;

						// Place curve in Part's event list
						lstCurves.AddHead( pCurve );
					}
				}
				break;
			}

			case DMUS_FOURCC_MARKER_CHUNK:
			{
				dwSize = ck.cksize;

				// Read size of the marker structure
				hr = pIStream->Read( &dwStructSize, sizeof( dwStructSize ), &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != sizeof( dwStructSize ) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				dwSize -= dwByteCount;

				// Check if there is any extra data to skip over
				if( dwStructSize > sizeof( DMUS_IO_STYLEMARKER ) )
				{
					dwExtra = dwStructSize - sizeof( DMUS_IO_STYLEMARKER );
					dwStructSize = sizeof( DMUS_IO_STYLEMARKER );
				}
				else
				{
					dwExtra = 0;
				}

				// now read in the markers
				DMUS_IO_STYLEMARKER iDMStyleMarker;
				while( dwSize > 0 )
				{
					ZeroMemory( &iDMStyleMarker, sizeof( DMUS_IO_STYLEMARKER ) );
					hr = pIStream->Read( &iDMStyleMarker, dwStructSize, &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != dwStructSize )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
					dwSize -= dwStructSize;

					// Skip over any extra data, if necessary
					if( dwExtra > 0 )
					{
						StreamSeek( pIStream, dwExtra, STREAM_SEEK_CUR );
						dwSize -= dwExtra;
					}

					// Create Direct Music marker
					CDirectMusicStyleMarker* pMarker;
					pMarker = new CDirectMusicStyleMarker;
					if( pMarker )
					{
						pMarker->m_mtGridStart = iDMStyleMarker.mtGridStart;
						pMarker->m_dwVariation = iDMStyleMarker.dwVariation;

						pMarker->m_wMarkerFlags = iDMStyleMarker.wMarkerFlags;

						// Place marker in Part's event list
						lstMarkers.AddHead( pMarker );
					}
				}
				break;
			}

			case DMUS_FOURCC_PART_DESIGN:
				dwSize = min( ck.cksize, m_dwPartDesignDataSize );
				hr = pIStream->Read( m_pPartDesignData, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	CDirectMusicEventItem* pEvent;

	// Transfer lstNotes to m_lstEvents
	ASSERT( m_lstEvents.GetHead() == NULL );		// Part event list should be empty
	pEvent = lstNotes.RemoveHead();
	while( pEvent )
	{
		m_lstEvents.AddHead( pEvent );
		pEvent = lstNotes.RemoveHead();
	}

	// Transfer lstCurves to m_lstEvents
	pEvent = lstCurves.RemoveHead();
	while( pEvent )
	{
		m_lstEvents.AddHead( pEvent );
		pEvent = lstCurves.RemoveHead();
	}

	// Transfer lstMarkers to m_lstEvents
	pEvent = lstMarkers.RemoveHead();
	while( pEvent )
	{
		m_lstEvents.AddHead( pEvent );
		pEvent = lstMarkers.RemoveHead();
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePartInfoList

HRESULT CDirectMusicPart::DM_SavePartInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Part name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePart

HRESULT CDirectMusicPart::DM_SavePart( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_STYLEPART dmusStylePartIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Part list header
	ckMain.fccType = DMUS_FOURCC_PART_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Part chunk header
	ck.ckid = DMUS_FOURCC_PART_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_STYLEPART structure
	memset( &dmusStylePartIO, 0, sizeof(DMUS_IO_STYLEPART) );

	dmusStylePartIO.timeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	dmusStylePartIO.timeSig.bBeat = m_TimeSignature.m_bBeat;
	dmusStylePartIO.timeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;

	dmusStylePartIO.wNbrMeasures = m_wNbrMeasures;
	dmusStylePartIO.bInvertUpper = m_bInvertUpper;
	dmusStylePartIO.bInvertLower = m_bInvertLower;
	dmusStylePartIO.bPlayModeFlags = m_bPlayModeFlags;
	dmusStylePartIO.dwFlags = m_dwFlags;

	memcpy( &dmusStylePartIO.guidPartID, &m_guidPartID, sizeof(GUID) );
	memcpy( &dmusStylePartIO.dwVariationChoices, &m_dwVariationChoices, sizeof(m_dwVariationChoices) );

	// Write Part chunk data
	hr = pIStream->Write( &dmusStylePartIO, sizeof(DMUS_IO_STYLEPART), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_STYLEPART) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

// Save Part info
	hr = DM_SavePartInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	CDirectMusicEventItem* pEvent;

	// Save Part note list (when applicable)
	pEvent = m_lstEvents.GetHead();
	while( pEvent )
	{
		if( pEvent->m_bType == ET_NOTE )
		{
			hr = DM_SaveNoteList( pIRiffStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			break;
		}

		pEvent = pEvent->GetNext();
	}

	// Save Part curve list (when applicable)
	pEvent = m_lstEvents.GetHead();
	while( pEvent )
	{
		if( pEvent->m_bType == ET_CURVE )
		{
			hr = DM_SaveCurveList( pIRiffStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			break;
		}

		pEvent = pEvent->GetNext();
	}

	// Save Marker list (when applicable)
	pEvent = m_lstEvents.GetHead();
	while( pEvent )
	{
		if( pEvent->m_bType == ET_MARKER )
		{
			hr = DM_SaveMarkerList( pIRiffStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			break;
		}

		pEvent = pEvent->GetNext();
	}

	// Save Part Design data
	hr = DM_SavePartDesignData( pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveNoteList

HRESULT CDirectMusicPart::DM_SaveNoteList( IDMUSProdRIFFStream* pIRiffStream )
{
	CDirectMusicEventItem* pEvent;
	CDirectMusicStyleNote* pNote;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_STYLENOTE dmusStyleNoteIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Note chunk header
	ck.ckid = DMUS_FOURCC_NOTE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_STYLENOTE structure
	dwStructSize = sizeof(DMUS_IO_STYLENOTE);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all of the notes
	pEvent = m_lstEvents.GetHead();
	while( pEvent )
	{
		if( pEvent->m_bType == ET_NOTE )
		{
			pNote = (CDirectMusicStyleNote *)pEvent;
			
			// Prepare DMUS_IO_STYLENOTE structure
			ZeroMemory( &dmusStyleNoteIO, sizeof( DMUS_IO_STYLENOTE ) );

			dmusStyleNoteIO.mtGridStart = pNote->m_mtGridStart;
			dmusStyleNoteIO.dwVariation = pNote->m_dwVariation;
			dmusStyleNoteIO.nTimeOffset = pNote->m_nTimeOffset;	

			dmusStyleNoteIO.mtDuration = pNote->m_mtDuration;
			dmusStyleNoteIO.wMusicValue = pNote->m_wMusicValue;	
			dmusStyleNoteIO.bVelocity = pNote->m_bVelocity;	
			dmusStyleNoteIO.bTimeRange = pNote->m_bTimeRange;	
			dmusStyleNoteIO.bDurRange = pNote->m_bDurRange;	
			dmusStyleNoteIO.bVelRange = pNote->m_bVelRange;	
			dmusStyleNoteIO.bInversionID = pNote->m_bInversionId;	
			dmusStyleNoteIO.bPlayModeFlags = pNote->m_bPlayModeFlags;
			dmusStyleNoteIO.bNoteFlags = pNote->m_bNoteFlags;

			// Write DMUS_IO_STYLENOTE structure
			hr = pIStream->Write( &dmusStyleNoteIO, sizeof(DMUS_IO_STYLENOTE), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLENOTE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		pEvent = pEvent->GetNext();
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveCurveList

HRESULT CDirectMusicPart::DM_SaveCurveList( IDMUSProdRIFFStream* pIRiffStream )
{
	CDirectMusicEventItem* pEvent;
	CDirectMusicStyleCurve* pCurve;
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwStructSize;
	DMUS_IO_STYLECURVE dmusStyleCurveIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ck.ckid = DMUS_FOURCC_CURVE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of DMUS_IO_STYLECURVE structure
	dwStructSize = sizeof(DMUS_IO_STYLECURVE);
	hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all of the curves
	pEvent = m_lstEvents.GetHead();
	while( pEvent )
	{
		if( pEvent->m_bType == ET_CURVE )
		{
			pCurve = (CDirectMusicStyleCurve *)pEvent;
			
			// Prepare DMUS_IO_STYLECURVE structure
			dmusStyleCurveIO.mtGridStart = pCurve->m_mtGridStart;
			dmusStyleCurveIO.dwVariation = pCurve->m_dwVariation;
			dmusStyleCurveIO.nTimeOffset = pCurve->m_nTimeOffset;	

			dmusStyleCurveIO.mtDuration = pCurve->m_mtDuration;
			dmusStyleCurveIO.mtResetDuration = pCurve->m_mtResetDuration;
			dmusStyleCurveIO.nStartValue = pCurve->m_nStartValue;	
			dmusStyleCurveIO.nEndValue = pCurve->m_nEndValue;	
			dmusStyleCurveIO.nResetValue = pCurve->m_nResetValue;	
			dmusStyleCurveIO.bEventType = pCurve->m_bEventType;	
			dmusStyleCurveIO.bCurveShape = pCurve->m_bCurveShape;	
			dmusStyleCurveIO.bCCData = pCurve->m_bCCData;	
			dmusStyleCurveIO.bFlags = pCurve->m_bFlags;	
			dmusStyleCurveIO.wParamType = pCurve->m_wParamType;	
			dmusStyleCurveIO.wMergeIndex = pCurve->m_wMergeIndex;

			// Write DMUS_IO_STYLECURVE structure
			hr = pIStream->Write( &dmusStyleCurveIO, sizeof(DMUS_IO_STYLECURVE), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLECURVE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		pEvent = pEvent->GetNext();
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SaveMarkerList

HRESULT CDirectMusicPart::DM_SaveMarkerList( IDMUSProdRIFFStream* pIRiffStream ) const
{
    MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_MARKER_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Save size of DMUS_IO_STYLEMARKER structure
	DWORD dwBytesWritten, dwStructSize = sizeof(DMUS_IO_STYLEMARKER);
	HRESULT hr = pIStream->Write( &dwStructSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save all the markers
	CDirectMusicEventItem* pEvent;
	pEvent = m_lstEvents.GetHead();
	while( pEvent )
	{
		if( pEvent->m_bType == ET_MARKER )
		{
			// Prepare DMUS_IO_STYLEMARKER structure
			DMUS_IO_STYLEMARKER oDMStyleMarker;
			ZeroMemory( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER) );

			oDMStyleMarker.mtGridStart = pEvent->m_mtGridStart;
			oDMStyleMarker.dwVariation = pEvent->m_dwVariation;

			oDMStyleMarker.wMarkerFlags = ((CDirectMusicStyleMarker *)pEvent)->m_wMarkerFlags;

			// Write DMUS_IO_STYLEMARKER structure
			hr = pIStream->Write( &oDMStyleMarker, sizeof(DMUS_IO_STYLEMARKER), &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_STYLEMARKER) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		pEvent = pEvent->GetNext();
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::DM_SavePartDesignData

HRESULT CDirectMusicPart::DM_SavePartDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Only save this chunk in "Design" files
	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;	// Not an error, just need to free pIStream
	}

	// Write Part Design header
	ck.ckid = DMUS_FOURCC_PART_DESIGN;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

    hr = pIStream->Write( m_pPartDesignData, m_dwPartDesignDataSize, &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != m_dwPartDesignDataSize )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::SetTimeSignature

void CDirectMusicPart::SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fInUndo, BOOL fStyleTimeSigChanging )
{
	ASSERT( m_pStyle != NULL );

	if( fStyleTimeSigChanging )
	{
		if( m_pStyle->m_TimeSignature.m_bBeatsPerMeasure != m_TimeSignature.m_bBeatsPerMeasure
		||  m_pStyle->m_TimeSignature.m_bBeat != m_TimeSignature.m_bBeat )
		{
			// Don't change Part's timesig unless equal to Style's timesig
			m_pPartDesignData->m_bStyleTimeSigChange = 0;
			return;
		}

		if( fInUndo )
		{
			if( m_pPartDesignData->m_bStyleTimeSigChange == 0 )
			{
				// Don't change Part's timesig if it wasn't changed when Style's timesig changed
				return;
			}
		}

		m_pPartDesignData->m_bStyleTimeSigChange = 0;
	}

	if( timeSig.m_bBeatsPerMeasure != m_TimeSignature.m_bBeatsPerMeasure
	||  timeSig.m_bBeat != m_TimeSignature.m_bBeat
	||  timeSig.m_wGridsPerBeat != m_TimeSignature.m_wGridsPerBeat )
	{
		if( fStyleTimeSigChanging )
		{
			m_pPartDesignData->m_bStyleTimeSigChange = 1;
		}

		// Store values based on original time signature
		DWORD dwOrigClocksPerBeat = DM_PPQNx4 / m_TimeSignature.m_bBeat;
		DWORD dwOrigClocksPerGrid = dwOrigClocksPerBeat / (DWORD)m_TimeSignature.m_wGridsPerBeat;
		DWORD dwOrigClocksPerMeasure = dwOrigClocksPerBeat * (DWORD)m_TimeSignature.m_bBeatsPerMeasure;
		DWORD dwOrigLength = dwOrigClocksPerMeasure * m_wNbrMeasures;

		// Change Part time signature
		DirectMusicTimeSig timeSigOrig = m_TimeSignature;
		m_TimeSignature = timeSig;

		// Store values based on new time signature
		DWORD dwNewClocksPerBeat = DM_PPQNx4 / m_TimeSignature.m_bBeat;
		DWORD dwNewClocksPerGrid = dwNewClocksPerBeat / (DWORD)m_TimeSignature.m_wGridsPerBeat;
		DWORD dwNewClocksPerMeasure = dwNewClocksPerBeat * (DWORD)m_TimeSignature.m_bBeatsPerMeasure;
		
		// Adjust Part length
		m_wNbrMeasures = (WORD)(dwOrigLength / dwNewClocksPerMeasure);
		if( dwOrigLength % dwNewClocksPerMeasure )
		{
			m_wNbrMeasures++;
		}
		DWORD dwNewLength = dwNewClocksPerMeasure * m_wNbrMeasures;
		
		// Adjust event list
		if( dwNewClocksPerBeat != dwOrigClocksPerBeat
		||  m_TimeSignature.m_wGridsPerBeat != timeSigOrig.m_wGridsPerBeat )  
		{
			DWORD dwMaxGrids = (DWORD)m_wNbrMeasures *
							   (DWORD)m_TimeSignature.m_bBeatsPerMeasure *
							   (DWORD)m_TimeSignature.m_wGridsPerBeat;

			DWORD dwBeat;
			DWORD dwExtraGrids;	    // Number of grids into the beat
			DWORD dwExtraClocks;	
			DWORD dwOffsetClocks;	

			CDirectMusicEventItem* pEvent = m_lstEvents.GetHead();
			while( pEvent )
			{
				// Store number of grids into the beat
				dwExtraGrids = (DWORD)pEvent->m_mtGridStart % timeSigOrig.m_wGridsPerBeat;

				// Sync to the beat
				dwBeat = (DWORD)pEvent->m_mtGridStart / (DWORD)timeSigOrig.m_wGridsPerBeat;
				dwBeat *= dwOrigClocksPerBeat;
				dwExtraClocks = dwBeat % dwNewClocksPerBeat;
				dwBeat /= dwNewClocksPerBeat;
				pEvent->m_mtGridStart = dwBeat * (DWORD)m_TimeSignature.m_wGridsPerBeat;

				// Take dwExtraGrids into consideration
				dwExtraGrids *= dwOrigClocksPerGrid;
				dwExtraGrids += dwExtraClocks;
				dwOffsetClocks = dwExtraGrids % dwNewClocksPerGrid;
				dwExtraGrids /= dwNewClocksPerGrid;
				pEvent->m_mtGridStart += dwExtraGrids;

				// Adjust pEvent->m_nTimeOffset
				pEvent->m_nTimeOffset += (short)dwOffsetClocks;

				// Make pEvent->m_mtGridStart is valid
				ASSERT( pEvent->m_mtGridStart >= 0 ); 
				ASSERT( pEvent->m_mtGridStart <= (signed)dwMaxGrids ); 

				// Adjust Curve reset duration
				if( pEvent->m_bType == ET_CURVE )
				{
					CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pEvent;

					if( (pDMCurve->m_bFlags & DMUS_CURVE_RESET)
					&&  (pDMCurve->m_mtResetDuration == (long)dwOrigLength) )
					{
						pDMCurve->m_mtResetDuration = (long)dwNewLength;
					}
				}

				pEvent = pEvent->GetNext();
			}
		}

		m_pStyle->SetModified( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::SetNbrMeasures

void CDirectMusicPart::SetNbrMeasures( WORD wNbrMeasures )
{
	// Helper function - no need to save undo, refresh, sync, set modified

	if( wNbrMeasures != m_wNbrMeasures )
	{
		long lClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
		long lClocksPerMeasure = lClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
		long lOldPartClockLength = lClocksPerMeasure * (long)m_wNbrMeasures;

		m_wNbrMeasures = wNbrMeasures;
		
		long lNewPartClockLength = lClocksPerMeasure * (long)m_wNbrMeasures; 
		long lNewNbrBeats = (long)m_wNbrMeasures * (long)m_TimeSignature.m_bBeatsPerMeasure; 
		long lNewLastGrid = lNewNbrBeats * (long)m_TimeSignature.m_wGridsPerBeat; 

		CDirectMusicEventItem* pEvent;
		CDirectMusicEventItem* pEventNext = m_lstEvents.GetHead();
		while( pEventNext )
		{
			pEvent = pEventNext;
			pEventNext = pEvent->GetNext();

			// Delete events with start times past end of Part
			if( pEvent->m_mtGridStart >= lNewLastGrid )
			{
				 m_lstEvents.Remove( pEvent );
				 pEvent->m_pNext = NULL;	// To prevent entire list from being deleted
				 delete pEvent;
			}
			else
			{
				// Adjust Curve reset durations
				if( pEvent->m_bType == ET_CURVE )
				{
					CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pEvent;

					if( pDMCurve->m_bFlags & DMUS_CURVE_RESET )
					{
						if( (pDMCurve->m_mtResetDuration == 0) 
						||  (pDMCurve->m_mtResetDuration == lOldPartClockLength) )
						{
							pDMCurve->m_mtResetDuration = lNewPartClockLength;
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::UpdateFromVarChoices

void CDirectMusicPart::UpdateFromVarChoices( IDMUSProdFramework *pFramework, IPersistStream *pIPersistStream )
{
	// Validate the parameters
	ASSERT( pIPersistStream );
	ASSERT( pFramework );
	if( pFramework == NULL
	||	pIPersistStream == NULL )
	{
		return;
	}

	// Try and allocate the stream
	IStream *pStream = NULL;
	if( SUCCEEDED( pFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream ) ) )
	{
		IDMUSProdRIFFStream* pIRiffStream;
		if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
		{
			// Save the editor into the stream
			if( SUCCEEDED( pIPersistStream->Save( pStream, TRUE ) ) )
			{
				// Seek back to the start of the stream
				StreamSeek( pStream, 0, STREAM_SEEK_SET );

				// Prepare the chunk headers
				MMCKINFO ckMain, ckSubChunk;
				ckMain.fccType = DM_FOURCC_VARCHOICES_FORM;
				ckSubChunk.ckid = DM_FOURCC_VARCHOICES_CHUNK;

				// Prepare ioVarChoices structure
				ioVarChoices iVarChoices;
				memset( &iVarChoices, 0, sizeof(ioVarChoices) );
				memcpy( iVarChoices.m_dwVariationChoices, m_dwVariationChoices, sizeof(DWORD) * NBR_VARIATIONS );

				// Read in the data
				DWORD dwBytesRead;
				if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0
				&&	pIRiffStream->Descend( &ckSubChunk, NULL, MMIO_FINDCHUNK ) == 0
				&&	SUCCEEDED( pStream->Read( &iVarChoices, sizeof(ioVarChoices), &dwBytesRead) )
				&&	sizeof(ioVarChoices) == dwBytesRead )
				{
					// Copy the data
					memcpy( m_dwVariationChoices, iVarChoices.m_dwVariationChoices, sizeof(DWORD) * NBR_VARIATIONS );

					// Update the design data
					if( m_pPartDesignData )
					{
						BOOL fRowDisabled;
						BOOL fDisabledFlag;

						for( short nRow = 0 ;  nRow < NBR_VARIATIONS ; nRow++ )
						{
							fRowDisabled = IsVarChoicesRowDisabled( nRow );
							fDisabledFlag = m_pPartDesignData->m_dwVariationsDisabled & (1 << nRow) ? TRUE : FALSE;

							if( fRowDisabled != fDisabledFlag )
							{
								if( fRowDisabled )
								{
									m_pPartDesignData->m_dwVariationsDisabled |= (1 << nRow);
									m_pPartDesignData->m_dwDisabledChoices[nRow] = m_dwVariationChoices[nRow];
								}
								else
								{
									m_pPartDesignData->m_dwVariationsDisabled &= ~(1 << nRow);
									m_pPartDesignData->m_dwDisabledChoices[nRow] = 0x00000000;
								}
							}
						}
					}
				}
			}
			RELEASE( pIRiffStream );
		}
		RELEASE( pStream );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef constructor/destructor

CDirectMusicPartRef::CDirectMusicPartRef( CDirectMusicPattern* pPattern )
{
	ASSERT( pPattern != NULL );
    
	m_pPattern = pPattern;
//	m_pPattern->AddRef();		intentionally missing

	m_pDMPart = NULL;
	m_dwPChannel = LOGICAL_PART_MELODY;
	m_bVariationLockID = 0;		// no locking
	m_bSubChordLevel = SUBCHORD_BASS;
	m_bPriority = 100;			
	m_bRandomVariation = 1;
	memset( &m_guidOldPartID, 0, sizeof(GUID) );
	m_fSetGUIDOldPartID = TRUE;

	m_fHardLink = FALSE;
}

CDirectMusicPartRef::~CDirectMusicPartRef()
{
	FreePianoRollStateList();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::FreePianoRollStateList

void CDirectMusicPartRef::FreePianoRollStateList( void )
{
	PianoRollUIState* pPianoRollUIState;

	while( !m_lstPianoRollUIStates.IsEmpty() )
	{
		pPianoRollUIState = static_cast<PianoRollUIState*>( m_lstPianoRollUIStates.RemoveHead() );

		if( pPianoRollUIState->pPianoRollData )
		{
			GlobalFree( pPianoRollUIState->pPianoRollData );
		}
		delete pPianoRollUIState;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::SetName

void CDirectMusicPartRef::SetName( LPCTSTR pszName )
{
	m_strName.Empty();

	if( pszName )
	{
		m_strName = pszName;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::SetPart

void CDirectMusicPartRef::SetPart( CDirectMusicPart* pPart )
{
	if( m_pDMPart == pPart )
	{
		return;
	}

	if( m_pDMPart )
	{
		ASSERT( m_pDMPart->m_pStyle != NULL );
		ASSERT( m_pDMPart->m_dwUseCount > 0 );

		m_pDMPart->m_dwUseCount--;

		if( m_fHardLink )
		{
			ASSERT( m_pDMPart->m_dwHardLinkCount > 0 );
			m_pDMPart->m_dwHardLinkCount--;
		}

		if( m_pDMPart->m_dwUseCount == 0 )
		{
			m_pDMPart->m_pStyle->DeletePart( m_pDMPart );
		}

		m_pDMPart = NULL;
	}

	if( pPart )
	{
		m_pDMPart = pPart;
		m_pDMPart->m_dwUseCount++;

		if( m_fHardLink )
		{
			m_pDMPart->m_dwHardLinkCount++;
		}

		if( ::IsEqualGUID( GUID_AllZeros, m_guidOldPartID ) )
		{
			memcpy ( &m_guidOldPartID, &m_pDMPart->m_guidPartID, sizeof( GUID ));
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::LinkParts

HRESULT CDirectMusicPartRef::LinkParts( CDirectMusicPartRef* pPartRef )
{
	ASSERT( pPartRef != NULL );

	pPartRef->SetPart( m_pDMPart );

	pPartRef->m_dwPChannel		 = m_dwPChannel;
	pPartRef->m_bVariationLockID = m_bVariationLockID;	
	pPartRef->m_bSubChordLevel	 = m_bSubChordLevel;
	pPartRef->m_bPriority		 = m_bPriority;			
	pPartRef->m_bRandomVariation = m_bRandomVariation;
	pPartRef->m_strName			 = m_strName;

	// Make sure hard link flag is set in both PartRefs
	if( !pPartRef->m_fHardLink )
	{
		m_pDMPart->m_dwHardLinkCount++;
		pPartRef->m_fHardLink = TRUE;
	}
	if( !m_fHardLink )
	{
		m_pDMPart->m_dwHardLinkCount++;
		m_fHardLink = TRUE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_SavePartRefPianoRollStates

HRESULT CDirectMusicPartRef::DM_SavePartRefPianoRollStates( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	POSITION pos;

	if( m_lstPianoRollUIStates.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Only save this chunk in "Design" files
	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;	// Not an error, just need to free pIStream
	}

	PianoRollUIState* pPianoRollUIState;

	pos = m_lstPianoRollUIStates.GetHeadPosition();
	while( pos )
	{
        pPianoRollUIState = m_lstPianoRollUIStates.GetNext( pos );

		// Write Piano Roll LIST header
		ck.fccType = DMUS_FOURCC_PIANOROLL_LIST;
		if( pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = pIStream->Write( pPianoRollUIState->pPianoRollData,
							  pPianoRollUIState->dwPianoRollDataSize,
							  &dwBytesWritten );
		if( FAILED( hr )
		||  dwBytesWritten != pPianoRollUIState->dwPianoRollDataSize )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_SavePartRefDesignData

HRESULT CDirectMusicPartRef::DM_SavePartRefDesignData( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Only save this chunk in "Design" files
	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;	// Not an error, just need to free pIStream
	}

	// Write PartOldGUID chunk header
	ck.ckid = DMUS_FOURCC_OLDGUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMPartOldGUID structure
	ioDMPartOldGUID oDMPartOldGUID;
	memcpy( &oDMPartOldGUID.m_guidOldPartID, &m_guidOldPartID, sizeof(GUID) );

	// Write PartOldGUID data
	hr = pIStream->Write( &oDMPartOldGUID, sizeof(ioDMPartOldGUID), &dwBytesWritten);
	if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioDMPartOldGUID) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Reset flag so that m_guidOldPartID will be updated
	m_fSetGUIDOldPartID = TRUE;

	// Write PartRef Design header
	ck.ckid = DMUS_FOURCC_PARTREF_DESIGN;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0)
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Initialize ioDMStylePartRefDesign
	ioDMStylePartRefDesign oDMStylePartRefDesign;
	oDMStylePartRefDesign.m_fHardLink = m_fHardLink;

    hr = pIStream->Write( &oDMStylePartRefDesign, sizeof(ioDMStylePartRefDesign), &dwBytesWritten );
    if( FAILED( hr )
    ||  dwBytesWritten != sizeof(ioDMStylePartRefDesign) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_SavePartRef

HRESULT CDirectMusicPartRef::DM_SavePartRef( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_PARTREF dmusPartRefIO;

	ASSERT( m_pDMPart != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write PartRef list header
	ckMain.fccType = DMUS_FOURCC_PARTREF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write PartRef chunk header
	ck.ckid = DMUS_FOURCC_PARTREF_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_PARTREF structure
	memset( &dmusPartRefIO, 0, sizeof(DMUS_IO_PARTREF) );

	dmusPartRefIO.wLogicalPartID = WORD(m_dwPChannel);
	dmusPartRefIO.dwPChannel = m_dwPChannel;
	dmusPartRefIO.bVariationLockID = m_bVariationLockID; 
	dmusPartRefIO.bSubChordLevel = m_bSubChordLevel;
	dmusPartRefIO.bPriority = m_bPriority;
	dmusPartRefIO.bRandomVariation = m_bRandomVariation;
	dmusPartRefIO.dwPChannel = m_dwPChannel;

	memcpy( &dmusPartRefIO.guidPartID, &m_pDMPart->m_guidPartID, sizeof(GUID) );

	// Write PartRef chunk data
	hr = pIStream->Write( &dmusPartRefIO, sizeof(DMUS_IO_PARTREF), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_PARTREF) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save PartRef info
	hr = DM_SavePartRefInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save PartRef PianoRoll UI States
	hr = DM_SavePartRefPianoRollStates( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save PartRef Design Data
	hr = DM_SavePartRefDesignData( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_LoadPartRef

HRESULT CDirectMusicPartRef::DM_LoadPartRef( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	CDirectMusicPart* pPart;
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	MMCKINFO ckList;
	DWORD dwByteCount;
	DWORD dwSize;
	BOOL fSetOldGuid = TRUE;

	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pStyle != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Free all items in the PianoRoll UI State list
	FreePianoRollStateList();

	// Clear PartRef name
	m_strName.Empty();

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PARTREF_CHUNK:
			{
				DMUS_IO_PARTREF dmusPartRefIO;
				ZeroMemory( &dmusPartRefIO, sizeof( DMUS_IO_PARTREF ) );

				dwSize = min( ck.cksize, sizeof( DMUS_IO_PARTREF ) );
				hr = pIStream->Read( &dmusPartRefIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}


				if (dwSize < DX8_PARTREF_SIZE)
				{
					m_dwPChannel = dmusPartRefIO.wLogicalPartID;	
				}
				else
				{
					// BUGBUG: TODO: Remove this HACK (added to cleanup part# corruption)
					if( dmusPartRefIO.dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
					{
						m_dwPChannel = dmusPartRefIO.wLogicalPartID;
					}
					else
					{
						m_dwPChannel = dmusPartRefIO.dwPChannel;
					}
				}
				m_bVariationLockID = dmusPartRefIO.bVariationLockID; 
				m_bSubChordLevel = dmusPartRefIO.bSubChordLevel;
				m_bPriority = dmusPartRefIO.bPriority;
				m_bRandomVariation = dmusPartRefIO.bRandomVariation;

				pPart = m_pPattern->m_pStyle->FindPartByGUID( dmusPartRefIO.guidPartID );
				if( pPart == NULL )
				{
					ASSERT( 0 );
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if (fSetOldGuid)
				{
					memcpy ( &m_guidOldPartID, &dmusPartRefIO.guidPartID, sizeof( GUID ));
				}
				SetPart( pPart );
				break;
			}

			case DMUS_FOURCC_OLDGUID_CHUNK:
			{
				ioDMPartOldGUID iDMPartOldGUID;

				dwSize = min( ck.cksize, sizeof( ioDMPartOldGUID ) );
				hr = pIStream->Read( &iDMPartOldGUID, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				fSetOldGuid = FALSE;
				memcpy( &m_guidOldPartID, &iDMPartOldGUID.m_guidOldPartID, sizeof(GUID) );
				break;
			}

			case DMUS_FOURCC_PARTREF_DESIGN:
			{
				ioDMStylePartRefDesign iDMStylePartRefDesign;

				dwSize = min( ck.cksize, sizeof( ioDMStylePartRefDesign ) );
				hr = pIStream->Read( &iDMStylePartRefDesign, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_fHardLink = iDMStylePartRefDesign.m_fHardLink;

				if( m_fHardLink )
				{
					if( m_pDMPart )
					{
						m_pDMPart->m_dwHardLinkCount++;
					}
					if( !fSetOldGuid )
					{
						CString strText;
						if( m_pPattern->m_fInUndo )
						{
							strText.LoadString( IDS_UNDO );
						}
						else if( m_pPattern->m_fInRedo )
						{
							strText.LoadString( IDS_REDO );
						}

						if( !strText.IsEmpty() )
						{
							// Remove all '&' from the string
							int nIndex = 0;
							while( nIndex >= 0 )
							{
								nIndex = strText.Find(_T("&"),nIndex);
								if( nIndex >= 0 )
								{
									strText.Delete(nIndex);
									nIndex = max( nIndex - 1, 0 );
								}
							}
						}

						TCHAR achText[256];
						BOOL fEnable = FALSE;

						ASSERT( m_pPattern->m_pUndoMgr != NULL );

						if( m_pPattern->m_pUndoMgr )
						{
							if( m_pPattern->m_fInRedo )
							{
								if( m_pPattern->m_pUndoMgr->GetRedo(achText, 256) )
								{
									if( *achText )
									{
										fEnable = TRUE;
										strText += " ";
										strText += achText;
										// Should now say 'Redo Insert Note'.
									}
								}
							}
							else //if( m_fInUndo || !m_fInUndo )
							{
								if( m_pPattern->m_pUndoMgr->GetUndo(achText, 256) )
								{
									if( *achText )
									{
										fEnable = TRUE;
										if( m_pPattern->m_fInUndo )
										{
											strText += " ";
											strText += achText;
											// Should now say 'Undo Insert Note'.
										}
										else
										{
											strText = achText;
											// Should now say 'Insert Note'
										}
									}
								}
							}
						}
						m_pPattern->m_pStyle->UpdateLinkedParts( this, fEnable ? ((LPCTSTR)strText) : NULL );
					}
				}
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_PIANOROLL_LIST:
					{
						PianoRollUIState* pPianoRollUIState;

						pPianoRollUIState = new PianoRollUIState;
						if( pPianoRollUIState == NULL )
						{
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}

						dwSize = ck.cksize;
						dwSize -= 4;
						pPianoRollUIState->pPianoRollData = (BYTE *)GlobalAlloc( GPTR, dwSize );
						if( pPianoRollUIState->pPianoRollData == NULL )
						{
							delete pPianoRollUIState;
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}
						pPianoRollUIState->dwPianoRollDataSize = dwSize;
						hr = pIStream->Read( pPianoRollUIState->pPianoRollData,
											 pPianoRollUIState->dwPianoRollDataSize,
											 &dwByteCount );
						if( FAILED( hr )
						||  dwByteCount != pPianoRollUIState->dwPianoRollDataSize )
						{
							hr = E_FAIL;
							GlobalFree( pPianoRollUIState->pPianoRollData );
							delete pPianoRollUIState;
							goto ON_ERROR;
						}
						m_lstPianoRollUIStates.AddTail( pPianoRollUIState );
						break;
					}
				}
				break;
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	if( !m_strName.IsEmpty()
	&&   m_pPattern->m_pStyle->m_pIProject )
	{
		// Query for an IDMUSProdPChannelName interface on the project
		IDMUSProdPChannelName* pIPChannelName;
		if( SUCCEEDED( m_pPattern->m_pStyle->m_pIProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pIPChannelName ) ) )
		{
			// Found the interface, update the PChannel name if one doesn't already exist
			WCHAR*		wstrText = NULL;
			wstrText = new wchar_t[MAX_PATH];
			if( pIPChannelName->GetPChannelName( m_dwPChannel, wstrText ) != S_OK )
			{
				// Convert the name to wide characters
				MultiByteToWideChar( CP_ACP, 0, m_strName, -1, wstrText, MAX_PATH );

				// Update the name
				pIPChannelName->SetPChannelName( m_dwPChannel, wstrText );
			}
			delete wstrText;
			RELEASE(pIPChannelName);
		}
	}
ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern constructor/destructor

CDirectMusicPattern::CDirectMusicPattern( CDirectMusicStyle* pStyle, BOOL fMotif )
{
	ASSERT( pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );

	// Pattern needs Style Component
	theApp.m_pStyleComponent->AddRef();
    
	m_dwRef = 0;
	AddRef();

	m_fModified = FALSE;
	m_fSendChangeNotification = FALSE;
	m_fRecordPressed = FALSE;
	m_fDialogActive = FALSE;
	m_fInUndo = FALSE;
	m_fInRedo = FALSE;
	m_fDontUpdateDirectMusicDuringLoad = FALSE;
	m_fPatternIsPlaying = FALSE;
	m_fInGroupEdit = FALSE;
	m_fInOpenVarChoicesEditor = FALSE;

	m_pStyle = pStyle;
//	m_pStyle->AddRef();		intentionally missing

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pPatternCtrl = NULL;
	m_hWndEditor = NULL;
	m_pIDMSegment = NULL;
	m_pIDMSegmentState = NULL;
	m_rpIDMStoppedSegmentState = NULL;
	m_pIDMTransitionSegmentState = NULL;
	m_pIDMTransitionSegment = NULL;
	m_fTrackTimeCursor = TRUE;
	m_rtCurrentStartTime = 0;

	m_pPatternDesignData = NULL;
	m_dwPatternDesignDataSize = 0;

	m_dwPlaybackID = ++m_pStyle->m_dwNextPatternID;

    m_dwDefaultKeyPattern = 0xAB5AB5;	// Major	
    m_dwDefaultChordPattern = 0x891;	// M7
    m_bDefaultKeyRoot = 0;		
    m_bDefaultChordRoot = 12;		
	m_fKeyFlatsNotSharps = FALSE;
	m_fChordFlatsNotSharps = FALSE;

	m_dblZoom = 0.0;
	m_dblHorizontalScroll = 0.0;
	m_lVerticalScroll = 0;
	m_tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
	m_lFunctionbarWidth = 0;
	m_fIgnoreTimelineSync = false;

	// Set defaults
	m_TimeSignature = m_pStyle->m_TimeSignature;
	m_wNbrMeasures = 1;
	RecalcLength();

    m_pIBandNode = NULL;
	m_dwRepeats = 0;
    m_mtPlayStart = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = m_dwLength;
    m_dwResolution = DMUS_SEGF_BEAT;

	m_bGrooveBottom = 1; 
	m_bGrooveTop = 100;
	m_bDestGrooveBottom = 1; 
	m_bDestGrooveTop = 100;

	m_nLastCustomId = MIN_EMB_CUSTOM_ID;

	m_dwFlags = fMotif ? DMUS_PATTERNF_PERSIST_CONTROL : 0;

	m_pRhythmMap = NULL;
	if( fMotif )
	{
		m_wEmbellishment = EMB_MOTIF;
	}
	else
	{
		m_wEmbellishment = EMB_NORMAL;
	}

	// Set default name
	TCHAR achName[MID_BUFFER];

	if( fMotif )
	{
		::LoadString( theApp.m_hInstance, IDS_MOTIF_TEXT, achName, MID_BUFFER );
	}
	else
	{
		::LoadString( theApp.m_hInstance, IDS_PATTERN_TEXT, achName, MID_BUFFER );
	}

	m_strName.Format( "%s%d", achName, 1 );
	m_pStyle->GetUniquePatternName( this );

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	m_pUndoMgr = new CJazzUndoMan(theApp.m_pStyleComponent->m_pIFramework);
	m_pUndoMgr->SetStreamAttributes(FT_DESIGN, GUID_SinglePattern);
}

CDirectMusicPattern::~CDirectMusicPattern()
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Remove Pattern from clipboard
	theApp.FlushClipboard( this );

	// Remove Pattern/Motif from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup references
	RELEASE( m_pIBandNode );
	RELEASE( m_pIDMSegment );
	RELEASE( m_pIDMSegmentState );
	RELEASE( m_pIDMTransitionSegmentState );
	RELEASE( m_pIDMTransitionSegment );

	// Don't release m_rpIDMStoppedSegmentState, it's just a reference

	// Cleanup CDirectMusicPattern
	if( m_pRhythmMap )
	{
		delete [] m_pRhythmMap;
	}

	// Clean up the undo mgr.
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
		m_pUndoMgr = NULL;
	}

	// Free Pattern design data
	if( m_pPatternDesignData )
	{
		GlobalFree( m_pPatternDesignData );
		m_pPatternDesignData = NULL;
	}

	CDirectMusicPartRef* pPartRef;

	while( !m_lstPartRefs.IsEmpty() )
	{
		pPartRef = m_lstPartRefs.GetHead();
		DeletePartRef( pPartRef );
	}

	// Pattern no longer needs Style Component
	theApp.m_pStyleComponent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::Initialize

HRESULT CDirectMusicPattern::Initialize( void )
{
	ASSERT( m_pStyle != NULL );

	// This method should only be called immedialtely
	// after construction to create an empty Pattern

	HRESULT hr = Initialize1();		// initialize state
	if( SUCCEEDED(hr) )
	{
		hr = Initialize2();		// create single empty part
	}
	
	return hr;	
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SyncPatternWithDirectMusic

HRESULT CDirectMusicPattern::SyncPatternWithDirectMusic()
{
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	HRESULT hr;

	if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( this ) == S_OK )
	{
		hr = SyncPatternWithAuditionSegment( FALSE, m_pIDMSegment );
	}
	else
	{
		hr = m_pStyle->SyncStyleWithDirectMusic();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SyncPatternWithMidiStripMgr

HRESULT CDirectMusicPattern::SyncPatternWithMidiStripMgr()
{
	IPersistStream* pIPersistStream;
	IStream* pIMemStream;
	HRESULT hr = S_OK;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pPatternCtrl
	&&  m_pPatternCtrl->m_pPatternDlg
	&&  m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr )
	{
		IDMUSProdStripMgr* pIMIDIStripMgr = m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr;

		// Persist this Pattern's data to the MIDI strip manager
		hr = pIMIDIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( SUCCEEDED( hr ) )
		{
			hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_SinglePattern, &pIMemStream );
			if( SUCCEEDED( hr ) )
			{
				hr = Save( pIMemStream, FALSE );
				if( SUCCEEDED( hr ) )
				{
					StreamSeek( pIMemStream, 0, STREAM_SEEK_SET ); //seek to beginning

					// If timeline exists, disable drawing operations until Load() is completed
					if( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
					{
						IOleWindow *pOleWindow;
						if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->QueryInterface( IID_IOleWindow, (void **)&pOleWindow ) ) )
						{
							HWND hwnd;
							pOleWindow->GetWindow( &hwnd );
							::LockWindowUpdate( hwnd );
							pOleWindow->Release();
						}
					}

					hr = pIPersistStream->Load( pIMemStream );
		
					// Reset timeline time signature and length
					if( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
					{
						DMUS_TIMESIGNATURE dmusTimeSig;

						dmusTimeSig.mtTime = 0;
						dmusTimeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
						dmusTimeSig.bBeat = m_TimeSignature.m_bBeat;			
						dmusTimeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;	
						m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->SetParam( GUID_TimeSignature, 1, 0, 0, &dmusTimeSig );

						VARIANT vtInit;
						vtInit.vt = VT_I4;

						V_I4(&vtInit) = m_dwLength;
						m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->SetTimelineProperty( TP_CLOCKLENGTH, vtInit );

						// Update the horizontal zoom, horizontal scroll, and vertical scroll
						m_pPatternCtrl->m_pPatternDlg->UpdateZoomAndScroll();

						// Now, redraw the dialog
						::LockWindowUpdate( NULL );
					}
				}

				RELEASE( pIMemStream );
			}

			RELEASE( pIPersistStream );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetModified

void CDirectMusicPattern::SetModified( BOOL fModified )
{
	m_fModified = fModified;

	if( m_wEmbellishment & EMB_MOTIF )
	{
		if( fModified )
		{
			// We must notify others when motif's have changed
			// In particualr, segment trigger track need to know
			m_fSendChangeNotification = TRUE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IUnknown implementation

HRESULT CDirectMusicPattern::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IDMUSProdTimelineCallback) )
	{
		AddRef();
		*ppvObj = (IDMUSProdTimelineCallback *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
	{
		AddRef();
		*ppvObj = (IDMUSProdPropPageObject *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdNotifyCPt) )
	{
		AddRef();
		*ppvObj = (IDMUSProdNotifyCPt *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdTransport) )
	{
		AddRef();
		*ppvObj = (IDMUSProdTransport *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdConductorTempo) )
	{
		AddRef();
		*ppvObj = (IDMUSProdConductorTempo *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IPatternNodePrivate) )
	{
		AddRef();
		*ppvObj = (IPatternNodePrivate *)this;
		return S_OK;
	}

	if( ::IsEqualIID(riid, IID_IDMUSProdSecondaryTransport) )
	{
		AddRef();
		*ppvObj = (IDMUSProdSecondaryTransport *)this;
		return S_OK;
	}

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDirectMusicPattern::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicPattern::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicPattern::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	if( pnFirstImage == NULL )
	{
		return E_POINTER;
	}

	if( m_wEmbellishment & EMB_MOTIF )
	{
		return( theApp.m_pStyleComponent->GetMotifImageIndex(pnFirstImage) );
	}
	else
	{
		return( theApp.m_pStyleComponent->GetPatternImageIndex(pnFirstImage) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicPattern::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

	if( m_pIBandNode )
	{
		m_pIBandNode->AddRef();
		*ppIFirstChildNode = m_pIBandNode;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetNextChild

HRESULT CDirectMusicPattern::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetComponent

HRESULT CDirectMusicPattern::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	if( ppIComponent == NULL )
	{
		return E_POINTER;
	}

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicPattern::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicPattern::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );
	if( pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetParentNode

HRESULT CDirectMusicPattern::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::SetParentNode

HRESULT CDirectMusicPattern::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetNodeId

HRESULT CDirectMusicPattern::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	if( m_wEmbellishment & EMB_MOTIF )
	{
		*pguid = GUID_MotifNode;
	}
	else
	{
		*pguid = GUID_PatternNode;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetNodeName

HRESULT CDirectMusicPattern::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicPattern::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pnMaxLength == NULL )
	{
		return E_POINTER;
	}

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicPattern::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName = bstrName;
	::SysFreeString( bstrName );

	HRESULT hr = S_OK;

	// Store original Pattern name
	CString strOrigName = m_strName;

	// Make sure new Pattern name is unique
	m_strName = strName;

	if( m_pStyle->IsPatternNameUnique( this ) == FALSE )
	{
		CString strMsg;

		if( m_wEmbellishment & EMB_MOTIF )
		{
			AfxFormatString1( strMsg, IDS_DUPE_MOTIF_NAME, m_strName );
		}
		else
		{
			AfxFormatString1( strMsg, IDS_DUPE_PATTERN_NAME, m_strName );
		}

		AfxMessageBox( strMsg, MB_OK );
		hr = S_FALSE;
	}

	// Put back original Pattern name
	m_strName = strOrigName;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::SetNodeName

HRESULT CDirectMusicPattern::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( strName.CompareNoCase( m_strName ) != 0 )
	{
		if( m_wEmbellishment & EMB_MOTIF )
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_NAME );
		}
		else
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_NAME );
		}
	}

	CString strOrigName = m_strName;
	m_strName = strName;

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		RELEASE( pIPropSheet );
	}

	if( strOrigName.Compare( m_strName ) != 0 )
	{
		BSTR bstrTransportName;

		SetModified( TRUE );
		if( SUCCEEDED ( GetName( &bstrTransportName ) ) )
		{
			theApp.m_pStyleComponent->m_pIConductor->SetTransportName( this, bstrTransportName );
			if( m_wEmbellishment & EMB_MOTIF )
			{
				if( SUCCEEDED ( GetName( &bstrTransportName ) ) )
				{
					theApp.m_pStyleComponent->m_pIConductor->SetSecondaryTransportName( this, bstrTransportName );
				}
			}
		}
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();

		// Notify connected nodes that Motif name has changed
		{
			DMUSProdMotifData	mtfData;
			WCHAR				wstrMotifName[MAX_PATH];
			WCHAR				wstrOldMotifName[MAX_PATH];
		
			MultiByteToWideChar( CP_ACP, 0, m_strName, -1, wstrMotifName, MAX_PATH );
			mtfData.pwszMotifName = wstrMotifName;

			MultiByteToWideChar( CP_ACP, 0, strOrigName, -1, wstrOldMotifName, MAX_PATH );
			mtfData.pwszOldMotifName = wstrOldMotifName;
			
			theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( m_pStyle, STYLE_MotifNameChange, &mtfData );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicPattern::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );
	UNREFERENCED_PARAMETER(pListInfo);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicPattern::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pClsId = CLSID_PatternEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicPattern::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pbstrTitle == NULL )
	{
		return E_POINTER;
	}

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	if( m_wEmbellishment & EMB_MOTIF )
	{
		// "Motif: "
		::LoadString( theApp.m_hInstance, IDS_MOTIF_TEXT, achTitle, MID_BUFFER );
	}
	else
	{
		// "Pattern: "
		::LoadString( theApp.m_hInstance, IDS_PATTERN_TEXT, achTitle, MID_BUFFER );
	}
	strTitle  = achTitle;
	strTitle += _T(": " );

	// plus "Style name - "
	BSTR bstrStyleName;

	if( SUCCEEDED ( m_pStyle->GetNodeName( &bstrStyleName ) ) )
	{
		CString strStyleName = bstrStyleName;
		::SysFreeString( bstrStyleName );
		strTitle += strStyleName;
		strTitle += " - ";
	}

	// plus "name"
	strTitle += m_strName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicPattern::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( hWndEditor == NULL )
	{
		return E_POINTER;
	}

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicPattern::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicPattern::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfUseOpenCloseImages == NULL )
	{
		return E_POINTER;
	}

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicPattern::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( phInstance == NULL
	||  pnMenuId == NULL )
	{
		return E_POINTER;
	}

	*phInstance = theApp.m_hInstance;

	if( m_wEmbellishment & EMB_MOTIF )
	{
		*pnMenuId = IDM_MOTIF_NODE_RMENU;
	}
	else
	{
		*pnMenuId = IDM_PATTERN_NODE_RMENU;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicPattern::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_NEW_BAND
		if( m_wEmbellishment & EMB_MOTIF
		&&  m_pIBandNode == NULL )
		{
			// Only applies to Motifs that do not already have Bands
			menu.EnableMenuItem( IDM_NEW_BAND, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_NEW_BAND, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_CUT
		if( CanCut() == S_OK )
		{
			menu.EnableMenuItem( IDM_CUT, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_CUT, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_COPY
		if( CanCopy() == S_OK )
		{
			menu.EnableMenuItem( IDM_COPY, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_COPY, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_DELETE
		if( CanDelete() == S_OK )
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicPattern::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	IDataObject* pIDataObject;

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_BAND:
			// Only applies to Motifs
			if( m_wEmbellishment & EMB_MOTIF )
			{
				hr = InsertChildNode( NULL );
			}
			break;

		case IDM_CUT:
			if( CanCut() == S_OK )
			{
				if( SUCCEEDED ( CreateDataObject( &pIDataObject ) ) )
				{
					if( theApp.PutDataInClipboard( pIDataObject, this ) )
					{
						DeleteNode( FALSE );
					}
					
					RELEASE( pIDataObject );
				}
			}
			break;
	
		case IDM_COPY:
			if( CanCopy() == S_OK )
			{
				if( SUCCEEDED ( CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, this );
					
					RELEASE( pIDataObject );
				}
			}
			break;
	
		case IDM_PASTE:
		{
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}
	
		case IDM_RENAME:
			hr = theApp.m_pStyleComponent->m_pIFramework->EditNodeLabel( this );
			break;

		case IDM_DELETE:
			hr = DeleteNode( TRUE );
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicPattern::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pStyleComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Reset Style's active Band to NULL (when applicable)
	m_pStyle->RemoveActiveBand( pIChildNode );

	// Save undo state
//	m_pStyle->m_pINodeBeingDeleted = pIChildNode;
//	m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_DELETE_BAND );
//	m_pStyle->m_pINodeBeingDeleted = NULL;

	// Remove from Motif
	RELEASE( m_pIBandNode );

	SetModified( TRUE );

	// Update the DirectMusic Style object
	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicPattern::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

	IDMUSProdDocType* pIDocType;

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( pIChildNode == NULL )
	{
		HRESULT hr;

		hr = theApp.m_pStyleComponent->m_pIFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType );
		if( SUCCEEDED ( hr ) ) 
		{
			// Create a new Band 
			hr = pIDocType->AllocNode( GUID_BandNode, &pIChildNode );
			if( !SUCCEEDED ( hr ) )
			{
				pIChildNode = NULL;
			}

			RELEASE( pIDocType );
		}

		if( pIChildNode == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		pIChildNode->AddRef();
	}

	// Motif can only have one Band
	if( m_pIBandNode )
	{
		DeleteChildNode( m_pIBandNode, FALSE );
	}

	// Set the Motif's Band
	ASSERT( m_pIBandNode == NULL );
	m_pIBandNode = pIChildNode;

	// Set root and parent node of ALL children
	theApp.SetNodePointers( m_pIBandNode, (IDMUSProdNode *)m_pStyle, (IDMUSProdNode *)this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(m_pIBandNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( m_pIBandNode, FALSE );
		return E_FAIL;
	}

	// Make sure "Default" flag is off
	IDMUSProdBandEdit* pIBandEdit;

	if( SUCCEEDED ( pIChildNode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
	{
		pIBandEdit->SetDefaultFlag( FALSE );
		RELEASE( pIBandEdit );
	}

	SetModified( TRUE );

	// Update the DirectMusic Style object
	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::DeleteNode

HRESULT CDirectMusicPattern::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIParentNode;

	// Let our parent delete us
	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			RELEASE( pIParentNode );
			return hr;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicPattern::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	if( fSelected )
	{
		if( m_pIDocRootNode == this )
		{
			// if the Pattern isn't part of a Style, SetActiveTransport to NULL so
			// the Conductor knows that this isn't a playable Pattern (until
			// the music engine is updated to support Pattern w/o Style playback
			theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( NULL, 0 );	
		}
		else
		{
			DWORD dwButtonState = BS_AUTO_UPDATE;
			if( m_pPatternCtrl != NULL && m_pPatternCtrl->m_pPatternDlg != NULL &&
				m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr != NULL )
			{
				dwButtonState |= BS_RECORD_ENABLED;
				if( m_fRecordPressed )
				{
					dwButtonState |= BS_RECORD_CHECKED;
				}
			}
			theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( this, dwButtonState );	
			theApp.m_pStyleComponent->m_pIConductor->SetTempo( this, m_pStyle->m_dblTempo, TRUE );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicPattern::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Pattern into stream
	HRESULT hr = E_FAIL;
	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_SinglePattern, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			UINT uClipFormat;

			if( m_wEmbellishment & EMB_MOTIF )
			{
				// Place CF_MOTIF into CDllJazzDataObject
				uClipFormat = theApp.m_pStyleComponent->m_cfMotif;
			}
			else
			{
				// Place CF_PATTERN into CDllJazzDataObject
				uClipFormat = theApp.m_pStyleComponent->m_cfPattern;
			}

			// Place stream into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( uClipFormat, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CanCut

HRESULT CDirectMusicPattern::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CanCopy

HRESULT CDirectMusicPattern::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CanDelete

HRESULT CDirectMusicPattern::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		return m_pIParentNode->CanDeleteChildNode( this );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicPattern::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

	if( m_pIBandNode )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicPattern::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Can paste Bands on Motifs
	if( m_wEmbellishment & EMB_MOTIF )
	{
		// Create a new CDllJazzDataObject and see if it can read the data object's format.
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject == NULL )
		{
			return E_OUTOFMEMORY;
		}

		if( pDataObject->IsClipFormatAvailable(pIDataObject, theApp.m_pStyleComponent->m_cfBand) == S_OK
		||  pDataObject->IsClipFormatAvailable(pIDataObject, theApp.m_pStyleComponent->m_cfBandList) == S_OK 
		||  pDataObject->IsClipFormatAvailable(pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack) == S_OK 
		||  m_pStyle->ContainsClipFormat(pDataObject, pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack) == S_OK )
		{
			RELEASE( pDataObject );
			return S_OK;
		}

		RELEASE( pDataObject );
	}

	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let Style decide what can be dropped
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	// Can't drop anything on a Pattern file in the Project Tree
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::PasteFromData

HRESULT CDirectMusicPattern::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Can paste Bands on Motifs
	if( m_wEmbellishment & EMB_MOTIF )
	{
		// Create a new CDllJazzDataObject and see if it can read the data object's format.
		CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
		if( pDataObject == NULL )
		{
			return E_OUTOFMEMORY;
		}

		HRESULT hr = E_FAIL;

		if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) ) )
		{
			// Handle CF_BAND 
			hr = PasteCF_BAND( pDataObject, pIDataObject );
		}

		else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) )
		{
			// Handle CF_BANDLIST format
			hr = PasteCF_BANDLIST( pDataObject, pIDataObject );
		}

		else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) )
		{
			// Handle CF_BANDTRACK format
			hr = PasteCF_BANDTRACK( pDataObject, pIDataObject );
		}

		else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
		{
			// Handle CF_TIMELINE format
			hr = PasteCF_TIMELINE ( pDataObject, pIDataObject );
		}

		RELEASE( pDataObject );

		if( hr == S_OK )
		{
			return hr;
		}
	}

	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let Style handle paste
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	// Can't drop anything on a Pattern file in the Project Tree
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicPattern::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												    BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) 
	||  SUCCEEDED ( m_pStyle->ContainsClipFormat( pDataObject, pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicPattern::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have children
		return E_FAIL;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) ) )
	{
		// Handle CF_BAND format
		hr = PasteCF_BAND( pDataObject, pIDataObject );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) )
	{
		// Handle CF_BANDLIST format
		hr = PasteCF_BANDLIST( pDataObject, pIDataObject );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) )
	{
		// Handle CF_BANDTRACK format
		hr = PasteCF_BANDTRACK( pDataObject, pIDataObject );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
	{
		// Handle CF_TIMELINE format
		hr = PasteCF_TIMELINE ( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNode::GetObject

HRESULT CDirectMusicPattern::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( ::IsEqualCLSID( rclsid, GUID_TimeSignature ) && ::IsEqualIID( riid, GUID_TimeSignature ) )
	{
		DMUS_TIMESIGNATURE *pTimeSig = (DMUS_TIMESIGNATURE *)ppvObject;
		ASSERT( pTimeSig );
		if( !pTimeSig )
		{
			return E_POINTER;
		}

		pTimeSig->bBeat = m_TimeSignature.m_bBeat;
		pTimeSig->bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
		pTimeSig->wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;
		pTimeSig->mtTime = 0;

		return S_OK;
	}

	else if( ::IsEqualCLSID( rclsid, GUID_TempoParam ) && ::IsEqualIID( riid, GUID_TempoParam ) )
	{
		DMUS_TEMPO_PARAM *pTempo = (DMUS_TEMPO_PARAM *)ppvObject;
		ASSERT( pTempo );
		if( !pTempo )
		{
			return E_POINTER;
		}

		if( !m_pStyle )
		{
			return E_FAIL;
		}
		
		pTempo->mtTime = 0;
		pTempo->dblTempo = m_pStyle->m_dblTempo;

		return S_OK;
	}

	else if( ::IsEqualCLSID( rclsid, GUID_ConductorCountInBeatOffset ) && ::IsEqualIID( riid, GUID_ConductorCountInBeatOffset ) )
	{
		if( m_pPatternCtrl && m_pPatternCtrl->m_pPatternDlg &&
			 m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
		{
			MUSIC_TIME mtTime;
			if( SUCCEEDED(	m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
			{
				MUSIC_TIME *pmtOffset = (MUSIC_TIME *)ppvObject;
				*pmtOffset = mtTime % (DM_PPQNx4 / m_TimeSignature.m_bBeat);
			}
		}
	}

    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersist::GetClassID

HRESULT CDirectMusicPattern::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

	if( pClsId == NULL )
	{
		return E_POINTER;
	}

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream implementation


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream::Load

HRESULT CDirectMusicPattern::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    DWORD dwPos = StreamTell( pIStream );

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	BOOL fFoundFormat = FALSE;

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
		{
			hr = DM_LoadPattern( pIRiffStream, &ckMain, false );
			fFoundFormat = TRUE;
		}

		RELEASE( pIRiffStream );
	}

	// Check for Direct Music single Pattern format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = DM_LoadPattern( pIRiffStream, &ckMain, true );
				fFoundFormat = TRUE;
			}

			RELEASE( pIRiffStream );
		}
	}

	// Check for IMA 2.5 format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = FOURCC_PATTERN_FORM;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = IMA25_LoadPattern( pIRiffStream, &ckMain );
				fFoundFormat = TRUE;
			}

			RELEASE( pIRiffStream );
		}
	}

	if( m_pPatternCtrl && m_pPatternCtrl->m_pPatternDlg )
	{
		// Update the horizontal zoom, horizontal scroll, and vertical scroll
		m_pPatternCtrl->m_pPatternDlg->UpdateZoomAndScroll();
	}


    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream::Save

HRESULT CDirectMusicPattern::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Save the Pattern
	if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||  ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
	{
		// Direct Music format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) == 0
			&&  SUCCEEDED( DM_SavePattern( pIRiffStream, fClearDirty ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}
				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

	else if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SinglePattern ) )
	{
		// Single Pattern (Direct Music format)
		// Used by clipboard and MIDI Manager
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_PATTERN_LIST;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( DM_SaveSinglePattern( pIRiffStream, fClearDirty ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}
				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern additional functions


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::FindPartRefByPChannelAndGUID

CDirectMusicPartRef* CDirectMusicPattern::FindPartRefByPChannelAndGUID( DWORD dwPChannel, REFGUID guidPart ) const
{
	CDirectMusicPartRef* pPartRef;

	POSITION pos = m_lstPartRefs.GetHeadPosition();

	while( pos )
	{
		pPartRef = m_lstPartRefs.GetNext( pos );

		if( pPartRef->m_dwPChannel == dwPChannel )
		{
			if( ::IsEqualGUID( guidPart, pPartRef->m_pDMPart->m_guidPartID ) 
			||  ::IsEqualGUID( guidPart, pPartRef->m_guidOldPartID ) )
			{
				return pPartRef;
			}
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::RecalcLength

void CDirectMusicPattern::RecalcLength( void )
{
	// Store the original length
	DWORD dwOrigLength = m_dwLength;

	// Set m_dwLength
	DWORD dwClocksPerBeat = DM_PPQNx4 / m_TimeSignature.m_bBeat;
	DWORD dwClocksPerMeasure = dwClocksPerBeat * (DWORD)m_TimeSignature.m_bBeatsPerMeasure;
	m_dwLength = dwClocksPerMeasure * m_wNbrMeasures;

	// Adjust m_mtLoopEnd
	if( m_mtLoopEnd == (long)dwOrigLength 
	||  m_mtLoopEnd > (long)m_dwLength )
	{
		m_mtLoopEnd = m_dwLength;
	}

	// Adjust m_mtLoopStart
	if( m_mtLoopStart >= m_mtLoopEnd ) 
	{
		m_mtLoopStart = m_mtLoopEnd - 1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::MusicValueToNote

/*
unsigned char CDirectMusicPattern::MusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot,         // Root note of chord.
char count)             // Total notes in chord.

{
unsigned char   result ;
char            octpart   = (char)(value >> 12) ;
char            chordpart = (char)((value >> 8) & 0xF) ;
char            keypart   = (char)((value >> 4) & 0xF) ;
char            accpart   = (char)(value & 0xF) ;
unsigned char   bits      = (unsigned char) (count & 0xF0) ;

    count  &= CHORD_COUNT ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    if( count ) {
        if( bits & CHORD_FOUR ) {
            if( count > 4 )
                chordpart += (count - 4) ;
        } else {
            if( count > 3 )
                chordpart += (count - 3) ;
        }
    }

//    if( chordpart ) {
        for( ;  chordpattern ;  result++ ) {
            if( chordpattern & 1L ) {
                if( !chordpart )
                    break ;
                chordpart-- ;
            }
            chordpattern = chordpattern >> 1L ;
            if( !chordpattern ) {
                if( !scalevalue )
                    return( 0 ) ;
                result  = unsigned char(12 * octpart) ;
                result += chordroot ;
                keypart = char(scalevalue >> 4) ;
                accpart = char(scalevalue & 0x0F) ;
                break ;
            }
        }
//    }

    if( keypart ) {
        keypattern |= (keypattern << 12L) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}
*/


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::NoteToMusicValue
/*
WORD CDirectMusicPattern::NoteToMusicValue( BYTE bMIDINote, BYTE bPlayModes,
											const DMUS_SUBCHORD &dmSubChord )
{
	ASSERT( bPlayModes != DMUS_PLAYMODE_NONE );

	if( bPlayModes == DMUS_PLAYMODE_FIXED )
	{
		return (WORD)bMIDINote;
	}
	else if( bPlayModes == DMUS_PLAYMODE_FIXEDTOSCALE )
	{
		return (bMIDINote >= dmSubChord.bScaleRoot) ?
			WORD(bMIDINote - dmSubChord.bScaleRoot) : 0;
	}
	else if( bPlayModes == DMUS_PLAYMODE_FIXEDTOCHORD )
	{
		return (bMIDINote >= (dmSubChord.bChordRoot % 12) + dmSubChord.bScaleRoot) ?
			WORD(bMIDINote - (dmSubChord.bChordRoot % 12) - dmSubChord.bScaleRoot) : 0;
	}

	WORD wNewMusicValue = OldNoteToMusicValue( bMIDINote, dmSubChord.dwScalePattern,
			dmSubChord.bScaleRoot, dmSubChord.dwChordPattern, dmSubChord.bChordRoot );

	// If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
	if( bPlayModes & DMUS_PLAYMODE_CHORD_ROOT )
	{
		WORD wOctave = (wNewMusicValue % 0xF000) >> 12;
		wOctave++;
		wNewMusicValue = (wNewMusicValue & 0x0FFF) | (wOctave << 12);
	}

	return wNewMusicValue;
}
*/


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternEditInfo

HRESULT CDirectMusicPattern::DM_SavePatternEditInfo( IDMUSProdRIFFStream* pIRiffStream )
{
    MMCKINFO ckMain;
	DWORD dwBytesWritten;
    HRESULT hr = S_OK;

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	if( m_pPatternDesignData == NULL )
	{
		hr = S_FALSE;
		goto ON_ERROR;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_PATTERN_DESIGN LIST header
	ckMain.fccType = DMUS_FOURCC_PATTERN_DESIGN;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Pattern design data
	hr = pIStream->Write( m_pPatternDesignData,
						  m_dwPatternDesignDataSize,
						  &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != m_dwPatternDesignDataSize )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternChunk

HRESULT CDirectMusicPattern::DM_SavePatternChunk( IDMUSProdRIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_PATTERN dmusPatternIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Pattern chunk header
    ck.ckid = DMUS_FOURCC_PATTERN_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_PATTERN
	memset( &dmusPatternIO, 0, sizeof(DMUS_IO_PATTERN) );

	dmusPatternIO.timeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	dmusPatternIO.timeSig.bBeat = m_TimeSignature.m_bBeat;
	dmusPatternIO.timeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;

	dmusPatternIO.bGrooveBottom = m_bGrooveBottom;
	dmusPatternIO.bGrooveTop = m_bGrooveTop;
	dmusPatternIO.bDestGrooveBottom = m_bDestGrooveBottom;
	dmusPatternIO.bDestGrooveTop = m_bDestGrooveTop;

	dmusPatternIO.dwFlags = m_dwFlags;

	dmusPatternIO.wEmbellishment = m_wEmbellishment;
	dmusPatternIO.wNbrMeasures = m_wNbrMeasures;

	// Write Pattern chunk data
	hr = pIStream->Write( &dmusPatternIO, sizeof(DMUS_IO_PATTERN), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_PATTERN) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternUIChunk

HRESULT CDirectMusicPattern::DM_SavePatternUIChunk( IDMUSProdRIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	ioDMPatternUI8 oDMPatternUI;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

	// Only save this chunk in "Design" files
	if( StreamInfo.ftFileType != FT_DESIGN )
	{
		hr = S_OK;
		goto ON_ERROR;	// Not an error, just need to free pIStream
	}

	// Write Pattern UI chunk header
    ck.ckid = DMUS_FOURCC_PATTERN_UI_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMPatternUI8
	memset( &oDMPatternUI, 0, sizeof(ioDMPatternUI8) );

	oDMPatternUI.m_dwDefaultKeyPattern = m_dwDefaultKeyPattern;
	oDMPatternUI.m_dwDefaultChordPattern = m_dwDefaultChordPattern;
	oDMPatternUI.m_bDefaultKeyRoot = m_bDefaultKeyRoot;
	oDMPatternUI.m_bDefaultChordRoot = m_bDefaultChordRoot;
	oDMPatternUI.m_fDefaultKeyFlatsNotSharps = m_fKeyFlatsNotSharps;	
	oDMPatternUI.m_fDefaultChordFlatsNotSharps = m_fChordFlatsNotSharps;

	// Sync up Timeline data, if our editor is open
	SyncTimelineSettings();

	// Copy Timeline settings
	oDMPatternUI.m_dblZoom = m_dblZoom;
	oDMPatternUI.m_dblHorizontalScroll = m_dblHorizontalScroll;
	oDMPatternUI.m_lVerticalScroll = m_lVerticalScroll;
	oDMPatternUI.m_dwSnapTo = m_tlSnapTo;
	oDMPatternUI.m_lFunctionbarWidth = m_lFunctionbarWidth;

	// Write Pattern UI chunk data
	hr = pIStream->Write( &oDMPatternUI, sizeof(ioDMPatternUI8), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMPatternUI8) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
/* not necessary, this info is in ioDMPatternUI8	
	// so we can display the right enharmonics in pattern editor
	hr = pIStream->Write(&m_fChordFlatsNotSharps, sizeof(BOOL), &dwBytesWritten);
	if(SUCCEEDED(hr) && dwBytesWritten == sizeof(BOOL))
	{
		hr = pIStream->Write(&m_fKeyFlatsNotSharps, sizeof(BOOL), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(BOOL) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}			
	}
*/
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePattern

HRESULT CDirectMusicPattern::DM_SavePattern( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	HRESULT hr = S_OK;
	IStream* pIStream;
	POSITION pos;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Pattern chunk
	hr = DM_SavePatternChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern UI chunk
	hr = DM_SavePatternUIChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern rhythm
	hr = DM_SavePatternRhythm( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern info
	hr = DM_SavePatternInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Motif Settings
	hr = DM_SaveMotifSettingsChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Motif Band
	if( m_wEmbellishment & EMB_MOTIF )
	{
		if( m_pIBandNode )
		{
			IPersistStream* pIPersistStream;

			hr = m_pIBandNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			hr = pIPersistStream->Save( pIStream, fClearDirty );
			RELEASE( pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

// Save Pattern Edit info
	hr = DM_SavePatternEditInfo( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Part References
	CDirectMusicPartRef* pPartRef;

    pos = m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );
		hr = pPartRef->DM_SavePartRef( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SaveSinglePattern

HRESULT CDirectMusicPattern::DM_SaveSinglePattern( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	CTypedPtrList<CPtrList, CDirectMusicPart*> lstParts;
	CDirectMusicPartRef* pPartRef;
	CDirectMusicPart* pPart;
	HRESULT hr = S_OK;
	IStream* pIStream;
	POSITION pos;
	POSITION pos2;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Pattern chunk
	hr = DM_SavePatternChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern UI chunk
	hr = DM_SavePatternUIChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern rhythm
	hr = DM_SavePatternRhythm( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Pattern info
	hr = DM_SavePatternInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Motif Settings
	hr = DM_SaveMotifSettingsChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Motif Band
	if( m_wEmbellishment & EMB_MOTIF )
	{
		if( m_pIBandNode )
		{
			IPersistStream* pIPersistStream;

			hr = m_pIBandNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			hr = pIPersistStream->Save( pIStream, fClearDirty );
			RELEASE( pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

// Save Pattern Edit info
	hr = DM_SavePatternEditInfo( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Build list of Parts
    pos = m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );
		ASSERT( pPartRef->m_pDMPart != NULL );

		pos2 = lstParts.Find( pPartRef->m_pDMPart );
		if( pos2 == NULL )
		{
			lstParts.AddTail( pPartRef->m_pDMPart ); 
		}
    }

// Save Parts
    pos = lstParts.GetHeadPosition();
    while( pos )
    {
        pPart = lstParts.GetNext( pos );

		hr = pPart->DM_SavePart( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
    }

// Save Part References
    pos = m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );

		hr = pPartRef->DM_SavePartRef( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::IMA25_LoadNoteList

HRESULT CDirectMusicPattern::IMA25_LoadNoteList( IStream* pIStream, MMCKINFO* pckMain, short nClickTime )
{
	HRESULT		hr = S_OK;;
    ioNote      iNote;
    DWORD       dwByteCount;
    WORD        wNoteSize;
    WORD        wExtra;
    long        dwSize;
    CDirectMusicEventItem*  pNote = NULL;

    dwSize = pckMain->cksize;

	// read size of the note structure
    hr = pIStream->Read( &wNoteSize, sizeof( wNoteSize ), &dwByteCount );
    if( FAILED( hr )
	||  dwByteCount != sizeof( wNoteSize ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	dwSize -= dwByteCount;

    if( wNoteSize > sizeof( ioNote ) )
	{
        wExtra = static_cast<WORD>( wNoteSize - sizeof( ioNote ) );
        wNoteSize = sizeof( ioNote );
	}
    else
    {
        wExtra = 0;
    }

    // now read in the notes
	while( dwSize > 0 )
	{
        hr = pIStream->Read( &iNote, wNoteSize, &dwByteCount );
        if( FAILED( hr )
		||  dwByteCount != wNoteSize )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
        dwSize -= wNoteSize;

        if( wExtra > 0 )
        {
            StreamSeek( pIStream, wExtra, STREAM_SEEK_CUR );
            dwSize -= wExtra;
        }

		// Create Direct Music Note
        pNote = new CDirectMusicStyleNote;
        if( pNote != NULL )
		{
			pNote->m_mtGridStart = nClickTime;

			pNote->m_nTimeOffset = (DM_PPQN / PPQN) * iNote.nTime;
            pNote->m_dwVariation = iNote.wVariation;
            ((CDirectMusicStyleNote*)pNote)->m_bVelocity = iNote.bVelocity;
            ((CDirectMusicStyleNote*)pNote)->m_mtDuration = (DM_PPQN / PPQN) * iNote.nDuration;
            ((CDirectMusicStyleNote*)pNote)->m_bTimeRange = iNote.bTimeRange;
            ((CDirectMusicStyleNote*)pNote)->m_bDurRange = iNote.bDurRange;
            ((CDirectMusicStyleNote*)pNote)->m_bVelRange = iNote.bVelRange;
            ((CDirectMusicStyleNote*)pNote)->m_bInversionId = 0;  // not in IMA2.5
            ((CDirectMusicStyleNote*)pNote)->m_bNoteFlags = 0;  // not in IMA2.5

			// Make sure SuperJAM! play mode is valid
			if ( !(iNote.bPlayMode & 0x80) )
        	{
        		iNote.bPlayMode = CHTYPE_NONE;
        	}
            
			// Strip 0x80 before checking SuperJAM! play mode
			switch( iNote.bPlayMode & 0x0F )
			{
				case CHTYPE_NOTINITIALIZED:
				case CHTYPE_NONE:
					((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
					break;
				
				case CHTYPE_DRUM:
				case CHTYPE_FIXED:
				   ((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
				   break;

				case CHTYPE_UPPER:
				case CHTYPE_BASS:
					((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
					break;

				case CHTYPE_SCALEONLY:
					((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
					break;

				case CHTYPE_BASSMELODIC:
				case CHTYPE_UPPERMELODIC:
					((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT;
					break;

				default:
					ASSERT( 0 );
					if( iNote.bVoiceID == LOGICAL_PART_DRUM )
					{
						((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
					}
					else
					{
						((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
					}
			}

			// Handle SuperJAM! drum tracks
			if( iNote.bVoiceID == LOGICAL_PART_DRUM )
			{
				// Use SuperJAM! drum map to convert note values				
				if( iNote.bValue < 128
				&&  achMappingsToDMUS[iNote.bValue] < 128 )
				{
					iNote.bValue = achMappingsToDMUS[iNote.bValue];
				}
				else
				{
					iNote.bValue = 0;
				}
			}

			// Find Part
			CDirectMusicPart* pPart = FindPart( IMA25_VOICEID_TO_PCHANNEL( iNote.bVoiceID ) );
			ASSERT( pPart != NULL );

			// Determine playmode of note
			BYTE bNotePlayModeFlags;

			if( ((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags == DMUS_PLAYMODE_NONE )
			{
				bNotePlayModeFlags = pPart->m_bPlayModeFlags;
			}
			else
			{
				bNotePlayModeFlags = ((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags;
			}

			// if ScaleValue is non-zero and the note isn't a pedalpoint, it's purpleized.
			if( iNote.bScaleValue != 0
			&&  bNotePlayModeFlags != DMUS_PLAYMODE_PEDALPOINT )
			{
				((CDirectMusicStyleNote*)pNote)->m_bPlayModeFlags = DMUS_PLAYMODE_PURPLEIZED;
			}

			// if the note is a fixed event, use the MIDI value; otherwise use MusicValue
			if( bNotePlayModeFlags == DMUS_PLAYMODE_FIXED )
			{
				((CDirectMusicStyleNote*)pNote)->m_wMusicValue = iNote.bValue;
			}
			else
			{
				((CDirectMusicStyleNote*)pNote)->m_wMusicValue = iNote.nMusicValue;
			}

			// Place note in Part
			pPart->m_lstEvents.AddTail( pNote ); 
        }
    }

ON_ERROR:

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::IMA25_LoadCurveList

HRESULT CDirectMusicPattern::IMA25_LoadCurveList( IStream* pIStream, MMCKINFO* pckMain, short nClickTime )
{
	HRESULT		hr = S_OK;
	DWORD		dwByteCount;
    WORD        wCurveSize;
    WORD        wCurveExtra;
    WORD        wSubSize;
    WORD        wSubExtra;
	long		dwSize;
    ioSubCurve  iSubCurve;
    ioCurve     iCurve;
	WORD		wCount;
    CDirectMusicEventItem*  pCurve = NULL;

    dwSize = pckMain->cksize;

	// read size of the curve structure
    hr = pIStream->Read( &wCurveSize, sizeof( wCurveSize ), &dwByteCount );
    if( FAILED( hr )
	||  dwByteCount != sizeof( wCurveSize ) )
	{
        hr = E_FAIL;
		goto ON_ERROR;
	}
	dwSize -= dwByteCount;

    if( wCurveSize > sizeof( ioCurve ) )
	{
        wCurveExtra = static_cast<WORD>( wCurveSize - sizeof( ioCurve ) );
        wCurveSize = sizeof( ioCurve );
	}
    else
    {
        wCurveExtra = 0;
    }

    // read size of the subcurve structure
    hr = pIStream->Read( &wSubSize, sizeof( wSubSize ), &dwByteCount );
    if( FAILED( hr )
	||  dwByteCount != sizeof( wSubSize ) )
	{
        hr = E_FAIL;
		goto ON_ERROR;
	}
	dwSize -= dwByteCount;

    if( wSubSize > sizeof( ioSubCurve ) )
	{
        wSubExtra = static_cast<WORD>( wSubSize - sizeof( ioSubCurve ) );
        wSubSize = sizeof( ioSubCurve );
	}
    else
    {
        wSubExtra = 0;
    }

    // now read in the curve
	while( dwSize > 0 )
	{
        hr = pIStream->Read( &iCurve, wCurveSize, &dwByteCount );
        if( FAILED( hr )
		||  dwByteCount != wCurveSize )
		{
            hr = E_FAIL;
			goto ON_ERROR;
		}
		dwSize -= dwByteCount;

        if( wCurveExtra > 0 )
        {
            StreamSeek( pIStream, wCurveExtra, STREAM_SEEK_CUR );
            dwSize -= wCurveExtra;
        }

        pCurve = new CDirectMusicStyleCurve;
        if( pCurve == NULL )
		{
            hr = E_FAIL;
            goto ON_ERROR;
        }

        pCurve->m_dwVariation = iCurve.wVariation;
		pCurve->m_mtGridStart = nClickTime;
		((CDirectMusicStyleCurve*)pCurve)->m_bEventType = iCurve.bEventType;
		((CDirectMusicStyleCurve*)pCurve)->m_bCCData = iCurve.bCCData;

        // read subcurve count
        hr = pIStream->Read( &wCount, sizeof( wCount ), &dwByteCount );
        if( FAILED( hr )
		||  dwByteCount != sizeof( wCount ) )
		{
            hr = E_FAIL;
			goto ON_ERROR;
		}
		dwSize -= dwByteCount;

		BOOL fEnteredLoop = wCount > 0;
        for( ; wCount > 0 ; --wCount )
		{
            // read subcurves
            hr = pIStream->Read( &iSubCurve, wSubSize, &dwByteCount );
            if( FAILED( hr )
			||  dwByteCount != wSubSize )
            {
                hr = E_FAIL;
                goto ON_ERROR;
            }
            dwSize -= wSubSize;

            if( wSubExtra > 0 )
            {
                StreamSeek( pIStream, wSubExtra, STREAM_SEEK_CUR );
                dwSize -= wSubExtra;
            }
			
            ((CDirectMusicStyleCurve*)pCurve)->m_bCurveShape = iSubCurve.bCurveType;

			// Make sure nMaxTime > nMinTime
			if( iSubCurve.nMaxTime < iSubCurve.nMinTime )
			{
				short nMaxTime = iSubCurve.nMaxTime;
				iSubCurve.nMaxTime = iSubCurve.nMinTime;
				iSubCurve.nMinTime = nMaxTime;
			}

			// Make sure nMaxValue > nMinValue
			if( iSubCurve.nMaxValue < iSubCurve.nMinValue )
			{
				short nMaxValue = iSubCurve.nMaxValue;
				iSubCurve.nMaxValue = iSubCurve.nMinValue;
				iSubCurve.nMinValue = nMaxValue;
				iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped --- different
			}

			if( iSubCurve.fFlipped & CURVE_FLIPTIME )
			{
				switch( ((CDirectMusicStyleCurve*)pCurve)->m_bCurveShape )
				{
					case DMUS_CURVES_LINEAR:
						if( iSubCurve.fFlipped & CURVE_FLIPVALUE )
						{
							iSubCurve.fFlipped = 0;
						}
						else
						{
							iSubCurve.fFlipped = CURVE_FLIPVALUE;
						}
						break;

					case DMUS_CURVES_INSTANT:
						iSubCurve.nMinTime = iSubCurve.nMaxTime;
						iSubCurve.nMaxTime = iSubCurve.nMinTime + 1;
						break;

					case DMUS_CURVES_EXP:
						((CDirectMusicStyleCurve*)pCurve)->m_bCurveShape = DMUS_CURVES_LOG;
						iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
						// log is the horiz flipped version of vertical flipped exp
						break;

					case DMUS_CURVES_LOG:
						((CDirectMusicStyleCurve*)pCurve)->m_bCurveShape = DMUS_CURVES_EXP;
						iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
						// exp is the horiz flipped version of vertical flipped log
						break;

					case DMUS_CURVES_SINE:
						iSubCurve.fFlipped ^= CURVE_FLIPVALUE; // toggle fFlipped
						// because horiz. and vert. flip are the same for sine wave
						break;

					default:
						ASSERT( 0 );
						break;
				}
			}
			
			if( iSubCurve.fFlipped & CURVE_FLIPVALUE )
			{
				((CDirectMusicStyleCurve*)pCurve)->m_nStartValue = iSubCurve.nMaxValue;
				((CDirectMusicStyleCurve*)pCurve)->m_nEndValue = iSubCurve.nMinValue;
			}
			else
			{
				((CDirectMusicStyleCurve*)pCurve)->m_nStartValue = iSubCurve.nMinValue;
				((CDirectMusicStyleCurve*)pCurve)->m_nEndValue = iSubCurve.nMaxValue;
			}

            pCurve->m_nTimeOffset = (DM_PPQN / PPQN) * (iSubCurve.nMinTime);
			((CDirectMusicStyleCurve*)pCurve)->m_mtDuration = (DM_PPQN / PPQN) * (iSubCurve.nMaxTime - iSubCurve.nMinTime);

			// Place curve in Part
			CDirectMusicPart* pPart = FindPart( IMA25_VOICEID_TO_PCHANNEL( iCurve.bVoiceID ) );
			ASSERT( pPart != NULL );
			if( pPart )
			{
				long lClocksPerBeat = DM_PPQNx4 / (long)pPart->m_TimeSignature.m_bBeat;
				long lClocksPerMeasure = lClocksPerBeat * (long)pPart->m_TimeSignature.m_bBeatsPerMeasure;
				long lPartClockLength = lClocksPerMeasure * (long)pPart->m_wNbrMeasures;

				((CDirectMusicStyleCurve*)pCurve)->SetDefaultResetValues( lPartClockLength );
				pPart->m_lstEvents.AddTail( pCurve ); 
			}
			
			pCurve = new CDirectMusicStyleCurve;
			if( pCurve == NULL )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			pCurve->m_dwVariation = iCurve.wVariation;
			pCurve->m_mtGridStart = nClickTime;
			((CDirectMusicStyleCurve*)pCurve)->m_bEventType = iCurve.bEventType;
			((CDirectMusicStyleCurve*)pCurve)->m_bCCData = iCurve.bCCData;
        }

		if( fEnteredLoop )
		{	
			delete pCurve; // the loop generates an extra one 
		}
    }

ON_ERROR:

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::IMA25_LoadEvents

HRESULT CDirectMusicPattern::IMA25_LoadEvents( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    ioClick iClick;
    HRESULT hr = S_OK;
	IStream* pIStream;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

	short nClickTime = 0;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_CLICK:
				dwSize = min( ck.cksize, sizeof( iClick ) );
				hr = pIStream->Read( &iClick, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				nClickTime = iClick.lTime;
				break;
			
			case FOURCC_NOTE:
				hr = IMA25_LoadNoteList( pIStream, &ck, nClickTime);
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
				break;

			case FOURCC_CURVE:
				hr = IMA25_LoadCurveList( pIStream, &ck, nClickTime);
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::IMA25_LoadPattern

HRESULT CDirectMusicPattern::IMA25_LoadPattern( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	CDirectMusicPart *pPart;
	CDirectMusicPartRef* pPartRef;
    IStream*    pIStream;
    HRESULT     hr = S_OK;
	DWORD		dwByteCount;
	DWORD		dwSize;
	WORD		wKludge;
	MMCKINFO	ck;
	POSITION	pos;
	ioPattern   iPattern;
	int			i;
	int			j;

    ASSERT( m_pStyle != NULL );
	ASSERT( pIRiffStream != NULL );
    ASSERT( pckMain != NULL );

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_PATTERN:
				dwSize = min( ck.cksize, sizeof( iPattern ) );
				hr = pIStream->Read( &iPattern, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwDefaultKeyPattern = iPattern.dwKeyPattern;
				m_dwDefaultChordPattern = iPattern.dwChordPattern;
				m_bDefaultKeyRoot = iPattern.bRoot;		
				m_bDefaultChordRoot = (iPattern.bRoot + 12) % 24;

				// Make sure Pattern name is unique
				m_strName = iPattern.wstrName;
				m_pStyle->GetUniquePatternName( this );

				m_TimeSignature.m_bBeatsPerMeasure = (BYTE)( (iPattern.dwLength / (DWORD)iPattern.wClocksPerBeat) / (DWORD)iPattern.wMeasures );
				m_TimeSignature.m_bBeat = (BYTE)iPattern.wBeat;
				m_TimeSignature.m_wGridsPerBeat = iPattern.wClocksPerBeat / iPattern.wClocksPerClick;
				m_wNbrMeasures = iPattern.wMeasures;
				RecalcLength();

				// Set bottom of groove range
				if(  iPattern.fFlags & PF_A
				|| !(iPattern.fFlags & (PF_A | PF_B | PF_C | PF_D)) )
				{
					// Bottom of groove range is 1 if either level A or no levels were specified
					m_bGrooveBottom = 1;
				}
				else if( iPattern.fFlags & PF_B )
				{
					// 26 if level B is the lowest level specified
					m_bGrooveBottom = 26;
				}
				else if( iPattern.fFlags & PF_C )
				{
					// 51 if level C is the lowest level specified
					m_bGrooveBottom = 51;
				}
				else
				{
					// 76 if level D is the lowest level specified
					m_bGrooveBottom = 76;
				}

				// Set top of groove range
				if(  iPattern.fFlags & PF_D
				|| !(iPattern.fFlags & (PF_A | PF_B | PF_C | PF_D)) )
				{
					// Top of groove range is 100 if either level D or no levels were specified
					m_bGrooveTop = 100;
				}
				else if( iPattern.fFlags & PF_C )
				{
					// 75 if level C is the highest level specified
					m_bGrooveTop = 75;
				}
				else if( iPattern.fFlags & PF_B )
				{
					// 50 if level B is the highest level specified
					m_bGrooveTop = 50;
				}
				else
				{
					// 25 if level A is the highest level specified
					m_bGrooveTop = 25;
				}

				// Set embellishment
				m_wEmbellishment = EMB_NORMAL;
				if( iPattern.fFlags & PF_FILL )
				{
					m_wEmbellishment |= EMB_FILL;
				}
				if( iPattern.fFlags & PF_INTRO )
				{
					m_wEmbellishment |= EMB_INTRO;
				}
				if( iPattern.fFlags & PF_END )
				{
					m_wEmbellishment |= EMB_END;
				}
				if( iPattern.fFlags & PF_BREAK )
				{
					m_wEmbellishment |= EMB_BREAK;
				}
				if( iPattern.fFlags & PF_MOTIF )
				{
					m_wEmbellishment |= EMB_MOTIF;
				}

				// Create rhythm map
				DWORD dwRhythm;

				if( m_pRhythmMap )
				{
					delete [] m_pRhythmMap;
					m_pRhythmMap = NULL;
				}
				m_pRhythmMap = new DWORD[iPattern.wMeasures];
				if( m_pRhythmMap == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}
				if( iPattern.fFlags & PF_QUARTER )
				{
					dwRhythm = 15;	// bits 1-4
				}
				else if( iPattern.fFlags & PF_HALF )
				{
					dwRhythm = 5;	// bits 1 and 3
				}
				else
				{
					dwRhythm = 1;	// bit 1 set
				}
				for( i = 0; i < iPattern.wMeasures; ++i )
				{
					m_pRhythmMap[i] = dwRhythm;
				}

				// Create 16 Parts and 16 Part References
				for( i = 0 ; i < 16 ; ++i )			// Loop over Parts
				{
					// Create Part
					pPart = m_pStyle->AllocPart();
					if( pPart == NULL )
					{
						hr = E_OUTOFMEMORY;	
						goto ON_ERROR;
					}

					pPart->m_TimeSignature = m_TimeSignature;
					pPart->m_wNbrMeasures = m_wNbrMeasures;

					if( iPattern.wInvert & (1 << i) 
					&&  iPattern.wAutoInvert & (1 << i) )
					{
						pPart->m_pPartDesignData->m_bAutoInvert = 1;
					}

					if( iPattern.wInvert & (1 << i) )
					{
						pPart->m_bInvertLower = iPattern.abInvertLower[i];
						pPart->m_bInvertUpper = iPattern.abInvertUpper[i];
					}
					else
					{
						pPart->m_bInvertLower = 0;
						pPart->m_bInvertUpper = 127;
					}

					switch( iPattern.achChordChoice[i] )
					{
						case CHTYPE_DRUM:
						case CHTYPE_FIXED:
						   pPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
						   break;

						 case CHTYPE_UPPER:
						 case CHTYPE_BASS:
							pPart->m_bPlayModeFlags = DMUS_PLAYMODE_NORMALCHORD;
							break;

						case CHTYPE_SCALEONLY:
							pPart->m_bPlayModeFlags = DMUS_PLAYMODE_PEDALPOINT;
							break;

						case CHTYPE_BASSMELODIC:
						case CHTYPE_UPPERMELODIC:
							pPart->m_bPlayModeFlags = DMUS_PLAYMODE_SCALE_INTERVALS | DMUS_PLAYMODE_CHORD_ROOT;
							break;

						default:
							ASSERT( 0 );
							pPart->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
					}

					// If none of the variations have the ->I or ->V flag set,
					// set it in all variations
					wKludge = VF_TO1 | VF_TO5;
					for( j = 0 ; j < 16 ; ++j )
					{
						pPart->m_dwVariationChoices[j] = iPattern.awVarFlags[i][j];
						if( ( pPart->m_dwVariationChoices[j] & VF_TO1 ) != 0 )
						{
							wKludge &= ~VF_TO1;
						}
						if( ( pPart->m_dwVariationChoices[j] & VF_TO5 ) != 0 )
						{
							wKludge &= ~VF_TO5;
						}
					}
					if( wKludge != 0 )
					{
						for( j = 0 ; j < 16 ; ++j )
						{
							pPart->m_dwVariationChoices[j] |= wKludge;
						}
					}

					// Disable variations 17-32
					for( j = 16 ; j < NBR_VARIATIONS ; ++j )
					{
						if( pPart->m_pPartDesignData )
						{
							pPart->m_pPartDesignData->m_dwVariationsDisabled |= (1 << j);
							pPart->m_pPartDesignData->m_dwDisabledChoices[j] = pPart->m_dwVariationChoices[j];
							pPart->m_dwVariationChoices[j] &= 0xE0000000;
						}
					}

					// Create Part Reference
					pPartRef = AllocPartRef();
					if( pPartRef == NULL )
					{
						m_pStyle->DeletePart( pPart );
						hr = E_OUTOFMEMORY;	
						goto ON_ERROR;
					}

					pPartRef->SetPart( pPart );
					pPartRef->m_dwPChannel = IMA25_VOICEID_TO_PCHANNEL( i );
 					pPartRef->m_bVariationLockID = 0;	// no locking between parts...

					if( iPattern.achChordChoice[i] == CHTYPE_UPPER
					||	iPattern.achChordChoice[i] == CHTYPE_UPPERMELODIC )
					{
						pPartRef->m_bSubChordLevel = SUBCHORD_STANDARD_CHORD;
					}
					else
					{
						pPartRef->m_bSubChordLevel = SUBCHORD_BASS;
					}
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case FOURCC_CLICK_LIST:
						IMA25_LoadEvents( pIRiffStream, &ck );
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

	// Delete empty Parts
    pos = m_lstPartRefs.GetHeadPosition();
    while( pos )
    {
        pPartRef = m_lstPartRefs.GetNext( pos );

		pPart = pPartRef->m_pDMPart;
		ASSERT( pPart != NULL );

		if( pPart->m_lstEvents.IsEmpty() )
		{
			DeletePartRef( pPartRef );	// Will also delete Part
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_LoadPattern

HRESULT CDirectMusicPattern::DM_LoadPattern( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool fSinglePattern )
{
	CDirectMusicPartRef* pPartRef;
	CDirectMusicPart* pPart;
    IStream*    pIStream;
    HRESULT     hr = S_OK;
	DWORD		dwByteCount;
	DWORD		dwSize;
	DWORD		dwPos;
	MMCKINFO	ck;
	MMCKINFO	ckList;
	int			i;
	BOOL		fUndoChangedLength = FALSE;
	WORD		wOrigEmbellishment = -1;
	WORD		wNewEmbellishment = -1;
	BOOL		fNeedToRequeuePatternPlayback = FALSE;

    ASSERT( m_pStyle != NULL );
	ASSERT( pIRiffStream != NULL );
    ASSERT( pckMain != NULL );

    pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

	// Keep track of original PartRef list
	CTypedPtrList<CPtrList, CDirectMusicPartRef*> lstOrigPartRefs;

	while( !m_lstPartRefs.IsEmpty() )
	{
		pPartRef = m_lstPartRefs.RemoveHead();
		lstOrigPartRefs.AddTail( pPartRef );
	}

	// Store values in original Pattern
	CString strOrigName = m_strName;

	// Load the Pattern
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_PATTERN_CHUNK:
			{
				DMUS_IO_PATTERN dmusPatternIO;

				ZeroMemory( &dmusPatternIO, sizeof( DMUS_IO_PATTERN ) );

				// Initialize DX8 fields not in DX7's DMUS_IO_PATTERN
				dmusPatternIO.bDestGrooveBottom = 1;
				dmusPatternIO.bDestGrooveTop = 100;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_PATTERN ) );
				hr = pIStream->Read( &dmusPatternIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_bGrooveBottom = dmusPatternIO.bGrooveBottom;
				m_bGrooveTop = dmusPatternIO.bGrooveTop;

				m_bDestGrooveBottom = dmusPatternIO.bDestGrooveBottom;
				m_bDestGrooveTop = dmusPatternIO.bDestGrooveTop;

				m_dwFlags = dmusPatternIO.dwFlags;

				wOrigEmbellishment = m_wEmbellishment;
				wNewEmbellishment = dmusPatternIO.wEmbellishment;
				m_wEmbellishment = dmusPatternIO.wEmbellishment;

				m_TimeSignature.m_bBeatsPerMeasure = dmusPatternIO.timeSig.bBeatsPerMeasure;
				m_TimeSignature.m_bBeat = dmusPatternIO.timeSig.bBeat;
				m_TimeSignature.m_wGridsPerBeat = dmusPatternIO.timeSig.wGridsPerBeat;
				
				m_wNbrMeasures = dmusPatternIO.wNbrMeasures;
				DWORD dwOrigLength = m_dwLength;
				RecalcLength();
				if( (m_fInUndo || m_fInRedo)
				&&  m_dwLength != dwOrigLength )
				{
					fUndoChangedLength = TRUE;
				}
				break;
			}

			case DMUS_FOURCC_PATTERN_UI_CHUNK:
			{
				ioDMPatternUI8 iDMPatternUI;
				ZeroMemory( &iDMPatternUI, sizeof( ioDMPatternUI8 ) );
				iDMPatternUI.m_dblZoom = 0.125;

				dwSize = min( ck.cksize, sizeof( ioDMPatternUI8 ) );
				hr = pIStream->Read( &iDMPatternUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( dwSize > sizeof( WORD ) )
				{
					m_dwDefaultKeyPattern = iDMPatternUI.m_dwDefaultKeyPattern;
					m_dwDefaultChordPattern = iDMPatternUI.m_dwDefaultChordPattern;
					m_bDefaultKeyRoot = iDMPatternUI.m_bDefaultKeyRoot;
					m_bDefaultChordRoot = iDMPatternUI.m_bDefaultChordRoot;
					if(dwSize >= sizeof(ioDMPatternUI))
					{
						/* not needed: info is in ioDMPatternUI8
						hr = pIStream->Read(&m_fChordFlatsNotSharps, sizeof(BOOL), &dwByteCount);
						if(FAILED(hr) || dwByteCount != sizeof(BOOL))
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}
						hr = pIStream->Read(&m_fKeyFlatsNotSharps, sizeof(BOOL), &dwByteCount);
						if(FAILED(hr) || dwByteCount != sizeof(BOOL))
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}
						*/
						m_fKeyFlatsNotSharps = iDMPatternUI.m_fDefaultKeyFlatsNotSharps;
						m_fChordFlatsNotSharps = iDMPatternUI.m_fDefaultChordFlatsNotSharps;

						if( dwSize >= sizeof( ioDMPatternUI8 ) )
						{
							// Copy Timeline settings
							if( m_dblZoom == 0.0 )
							{
								m_dblZoom = iDMPatternUI.m_dblZoom;
							}
							m_dblHorizontalScroll = iDMPatternUI.m_dblHorizontalScroll;
							m_lVerticalScroll = iDMPatternUI.m_lVerticalScroll;
							m_tlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO)iDMPatternUI.m_dwSnapTo;
							if( m_lFunctionbarWidth == 0 )
							{
								m_lFunctionbarWidth = iDMPatternUI.m_lFunctionbarWidth;
							}
						}
					}
					else
					{
						m_fKeyFlatsNotSharps = FALSE;
						m_fChordFlatsNotSharps = FALSE;
					}
				}
				break;
			}

			case DMUS_FOURCC_RHYTHM_CHUNK:
				if( m_pRhythmMap )
				{
					delete [] m_pRhythmMap;
					m_pRhythmMap = NULL;
				}
				m_pRhythmMap = new DWORD[m_wNbrMeasures];
				if( m_pRhythmMap == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}
				for( i = 0 ;  i < m_wNbrMeasures ;  i++ )
				{
					hr = pIStream->Read( &m_pRhythmMap[i], sizeof(DWORD), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(DWORD) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
				}
				break;

			case DMUS_FOURCC_MOTIFSETTINGS_CHUNK:
			{
				DMUS_IO_MOTIFSETTINGS dmusMotifSettingsIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_MOTIFSETTINGS ) );
				hr = pIStream->Read( &dmusMotifSettingsIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwRepeats = dmusMotifSettingsIO.dwRepeats;
				m_mtPlayStart = dmusMotifSettingsIO.mtPlayStart;
				m_mtLoopStart = dmusMotifSettingsIO.mtLoopStart;
				m_mtLoopEnd = dmusMotifSettingsIO.mtLoopEnd;
				m_dwResolution = dmusMotifSettingsIO.dwResolution;
				break;
			}

			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_BAND_FORM: 
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						if( m_pIBandNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIBandNode = pINode;
						}
						break;
					}
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case DMUS_FOURCC_UNAM_CHUNK:
								{
									CString strOrigName = m_strName;

									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );

									if( fSinglePattern
									&&  wOrigEmbellishment != -1 )
									{
										// Done so that name won't be needlessly changed
										// when pasting Pattern as Motif or pasting Motif as Pattern
										m_wEmbellishment = wOrigEmbellishment;
									}
									// Make sure Pattern name is unique
									m_pStyle->GetUniquePatternName( this );
									if( fSinglePattern
									&&  wNewEmbellishment != -1 )
									{
										m_wEmbellishment = wNewEmbellishment;
									}

									if( strOrigName.CompareNoCase( m_strName ) != 0 )
									{
										if( m_pIDocRootNode )
										{
											// Node is in Project Tree so we need to sync changes
											theApp.m_pStyleComponent->m_pIFramework->RefreshNode( this );

											// Notify transport that name has changed
											BSTR bstrTransportName;
											if( SUCCEEDED ( GetName( &bstrTransportName ) ) )
											{
												theApp.m_pStyleComponent->m_pIConductor->SetTransportName( this, bstrTransportName );
												if( m_wEmbellishment & EMB_MOTIF )
												{
													if( SUCCEEDED ( GetName( &bstrTransportName ) ) )
													{
														theApp.m_pStyleComponent->m_pIConductor->SetSecondaryTransportName( this, bstrTransportName );
													}
												}
											}

											// Notify connected nodes that Motif name has changed
											if( m_wEmbellishment & EMB_MOTIF )
											{
												DMUSProdMotifData	mtfData;
												WCHAR				wstrMotifName[MAX_PATH];
												WCHAR				wstrOldMotifName[MAX_PATH];
											
												MultiByteToWideChar( CP_ACP, 0, m_strName, -1, wstrMotifName, MAX_PATH );
												mtfData.pwszMotifName = wstrMotifName;

												MultiByteToWideChar( CP_ACP, 0, strOrigName, -1, wstrOldMotifName, MAX_PATH );
												mtfData.pwszOldMotifName = wstrOldMotifName;
												
												theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( m_pStyle, STYLE_MotifNameChange, &mtfData );
											}
										}
									}
									break;
								}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_PATTERN_DESIGN:
						dwSize = ck.cksize;
						dwSize -= 4;
						if( m_pPatternDesignData )
						{
							GlobalFree( m_pPatternDesignData );
							m_pPatternDesignData = NULL;
						}
						m_pPatternDesignData = (BYTE *)GlobalAlloc( GPTR, dwSize );
						if( m_pPatternDesignData == NULL )
						{
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}
						m_dwPatternDesignDataSize = dwSize;
						hr = pIStream->Read( m_pPatternDesignData,
											 m_dwPatternDesignDataSize,
											 &dwByteCount );
						if( FAILED( hr )
						||  dwByteCount != m_dwPatternDesignDataSize )
						{
							hr = E_FAIL;
							GlobalFree( m_pPatternDesignData );
							m_pPatternDesignData = NULL;
							goto ON_ERROR;
						}
						break;

					case DMUS_FOURCC_PART_LIST:		// only in GUID_SinglePattern format
						pPart = m_pStyle->AllocPart();
						if( pPart == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPart->DM_LoadPart( pIRiffStream, &ck );
						if( FAILED( hr ) )
						{
							m_pStyle->DeletePart( pPart );
			                goto ON_ERROR;
						}
						if( hr == S_FALSE )
						{
							// Bypass this Part because Style already contains a Part
							// whose GUID matches pPart->m_guidPartID
							m_pStyle->DeletePart( pPart );
						}
						break;

					case DMUS_FOURCC_PARTREF_LIST:
						pPartRef = AllocPartRef();
						if( pPartRef == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPartRef->DM_LoadPartRef( pIRiffStream, &ck );
						if( FAILED( hr ) )
						{
							DeletePartRef( pPartRef );
			                goto ON_ERROR;
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

	// If undo changed length of Pattern we need to change length of all Parts
//	if( fUndoChangedLength )
//	{
//		CDirectMusicPartRef* pPartRef;
//
//		POSITION pos = m_lstPartRefs.GetHeadPosition();
//		while( pos )
//		{
//			pPartRef = m_lstPartRefs.GetNext( pos );
//
//			ASSERT( pPartRef->m_pDMPart != NULL);
//			ASSERT( pPartRef->m_pDMPart->m_dwUseCount >= 1 );
//
//			pPartRef->m_pDMPart->SetNbrMeasures( m_wNbrMeasures );
//		}
//	}

	// If we got here, we should have succeeded
	ASSERT( SUCCEEDED(hr) );

	if( lstOrigPartRefs.GetCount() != m_lstPartRefs.GetCount() )
	{
		fNeedToRequeuePatternPlayback = TRUE;
	}

	// Delete original PartRef list
	while( !lstOrigPartRefs.IsEmpty() )
	{
		pPartRef = lstOrigPartRefs.RemoveHead();

		// Transfer m_pVarChoicesNode pointer to new PartRef and update any hard-linked parts
		if( pPartRef
		&&  pPartRef->m_pDMPart
		&& (pPartRef->m_pDMPart->m_pVarChoicesNode || pPartRef->m_fHardLink) )
		{
			CDirectMusicPartRef* pNewPartRef;

			pNewPartRef = FindPartRefByPChannelAndGUID( pPartRef->m_dwPChannel, pPartRef->m_guidOldPartID );
			if( pNewPartRef == NULL )
			{
				pNewPartRef = FindPartRefByPChannelAndGUID( pPartRef->m_dwPChannel, pPartRef->m_pDMPart->m_guidPartID );
			}

			// Ensure we have a valid pNewPartRef pointer, and that the part actually needs to be changed
			if( pNewPartRef && pNewPartRef->m_pDMPart && (pNewPartRef->m_pDMPart != pPartRef->m_pDMPart) )
			{
				ASSERT( pNewPartRef->m_pDMPart != NULL );

				// Update all hard linked part
				if( pPartRef->m_fHardLink && pNewPartRef->m_fHardLink )
				{
					CString strText;
					if( m_fInUndo )
					{
						strText.LoadString( IDS_UNDO );
					}
					else if( m_fInRedo )
					{
						strText.LoadString( IDS_REDO );
					}

					if( !strText.IsEmpty() )
					{
						// Remove all '&' from the string
						int nIndex = 0;
						while( nIndex >= 0 )
						{
							nIndex = strText.Find(_T("&"),nIndex);
							if( nIndex >= 0 )
							{
								strText.Delete(nIndex);
								nIndex = max( nIndex - 1, 0 );
							}
						}
					}

					TCHAR achText[256];
					BOOL fEnable = FALSE;

					ASSERT( m_pUndoMgr != NULL );

					if( m_pUndoMgr )
					{
						if( m_fInRedo )
						{
							if( m_pUndoMgr->GetRedo(achText, 256) )
							{
								if( *achText )
								{
									fEnable = TRUE;
									strText += " ";
									strText += achText;
									// Should now say 'Redo Insert Note'.
								}
							}
						}
						else //if( m_fInUndo || !m_fInUndo )
						{
							if( m_pUndoMgr->GetUndo(achText, 256) )
							{
								if( *achText )
								{
									fEnable = TRUE;
									if( m_fInUndo )
									{
										strText += " ";
										strText += achText;
										// Should now say 'Undo Insert Note'.
									}
									else
									{
										strText = achText;
										// Should now say 'Insert Note'
									}
								}
							}
						}
					}
					m_pStyle->UpdateMIDIMgrsAndChangePartPtrs( pPartRef->m_pDMPart, pNewPartRef, fEnable ? ((LPCTSTR)strText) : NULL );
				}

				// Update the variation choices editor, if open
				if( pPartRef->m_pDMPart->m_pVarChoicesNode )
				{
					pNewPartRef->m_pDMPart->m_pVarChoicesNode = pPartRef->m_pDMPart->m_pVarChoicesNode;
					// We re-initialize the variation choices editor below
					// We set m_pVarChoicesPartRef below

					// Clear the old part's pointers
					if( pNewPartRef->m_pDMPart != pPartRef->m_pDMPart )
					{
						pPartRef->m_pDMPart->m_pVarChoicesNode = NULL;
						pPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
					}
				}
			}
			// If we couldn't find the new part ref, close the editor
			else if( !pNewPartRef )
			{
				if( pPartRef->m_pDMPart->m_pVarChoicesNode )
				{
					// PChannel must have just changed so close Variation Choices Editor
					HWND hWndEditor;
					pPartRef->m_pDMPart->m_pVarChoicesNode->GetEditorWindow( &hWndEditor );
					if( hWndEditor )
					{
						theApp.m_pStyleComponent->m_pIFramework->CloseEditor( pPartRef->m_pDMPart->m_pVarChoicesNode );
					}
					RELEASE( pPartRef->m_pDMPart->m_pVarChoicesNode );
					pPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
				}
			}

			if( pNewPartRef
			&&	pNewPartRef->m_pDMPart
			&&	pNewPartRef->m_pDMPart->m_pVarChoicesNode )
			{
				// Re-initialize the variation choices editor
				pNewPartRef->m_pDMPart->m_pVarChoicesPartRef = pNewPartRef;
				InitializeVarChoicesEditor( pNewPartRef );
			}
		}

		DeletePartRef( pPartRef );
	}

	if( m_fInUndo || m_fInRedo )	
	{
		// Mark all 'linked' PartRefs that point to a part with m_dwHardLinkCount of one as 'unlinked'
		m_pStyle->UpdateLinkFlags();
	}

	// If node is in Project Tree we need to sync changes
	if( m_pIDocRootNode )
	{
		// Sync changes with Style editor
		if( m_pStyle->m_pStyleCtrl )
		{
			m_pStyle->m_pStyleCtrl->PostMessage( WM_SYNC_STYLEEDITOR,
					m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS, 0 );
		}

		// Sync changes with MIDI strip manager
		if( sg_fPatternFromMidiMgr == FALSE )
		{
			m_fIgnoreTimelineSync = true;
			SyncPatternWithMidiStripMgr();
			m_fIgnoreTimelineSync = false;

			// Sync changes with property sheet
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				pIPropSheet->RefreshTitleByObject( this );
				pIPropSheet->RefreshActivePageByObject( this );
				RELEASE( pIPropSheet );
			}
		}

		// Sync changes with DirectMusic objects
		if( !m_fDontUpdateDirectMusicDuringLoad )
		{
			SyncPatternWithDirectMusic();

			if( fNeedToRequeuePatternPlayback
			&&	m_pIDMSegmentState
			&& (theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( this ) == S_OK) )
			{
				REFERENCE_TIME rtQueue;
				DWORD dwPrepareTime;
				MUSIC_TIME mtNow, mtStartPoint, mtStartTime;
				if( SUCCEEDED( m_pIDMSegmentState->GetStartPoint( &mtStartPoint ) )
				&&	SUCCEEDED( m_pIDMSegmentState->GetStartTime( &mtStartTime ) )
				&&	SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->GetQueueTime( &rtQueue ) )
				&&	SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->GetPrepareTime( &dwPrepareTime ) )
				&&	SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->ReferenceToMusicTime( rtQueue + dwPrepareTime * 10000, &mtNow ) ) )
				{
					// Change mtNow into an offset
					MUSIC_TIME mtOffset = mtNow - mtStartTime + mtStartPoint;
					if( mtNow >=0 )
					{
						mtOffset = mtOffset % m_dwLength;

						// No need to stop the music - PlaySegment will just interrupt the currently playing segment
						//theApp.m_pStyleComponent->m_pIDMPerformance->Stop( m_pIDMSegment, m_pIDMSegmentState, -5 + mtNow, 0 );
						//theApp.m_pStyleComponent->m_pIDMPerformance->Stop( NULL, m_pIDMTransitionSegmentState, -5 + mtNow, 0 );

						// Release the segment states
						RELEASE( m_pIDMSegmentState );
						RELEASE( m_pIDMTransitionSegmentState );
						RELEASE( m_pIDMTransitionSegment );

						m_pIDMSegment->SetStartPoint( mtOffset );
						theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegment( m_pIDMSegment, 0, mtNow, &m_pIDMSegmentState );
					}
				}
			}
		}
	}

ON_ERROR:
	if( FAILED(hr) )
	{
		// Put back original PartRef list
		while( !lstOrigPartRefs.IsEmpty() )
		{
			pPartRef = lstOrigPartRefs.RemoveHead();
			m_lstPartRefs.AddTail( pPartRef );
		}
	}

    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdTimelineCallback implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdTimelineCallback::OnDataChanged

HRESULT CDirectMusicPattern::OnDataChanged( LPUNKNOWN punkStripMgr )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( m_pPatternCtrl != NULL );
	ASSERT( m_pPatternCtrl->m_pPatternDlg != NULL );
	ASSERT( m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr != NULL );
	ASSERT( m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr != NULL );

	ASSERT(m_pUndoMgr != NULL);

	if(m_pUndoMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	if( punkStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( m_fInOpenVarChoicesEditor )
	{
		return S_FALSE;
	}

	HRESULT hr = E_FAIL;

	IDMUSProdNode *pIVarChoicesNode = NULL;

	if( punkStripMgr == m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr )
	{
		BOOL fUpdateDirectMusic = TRUE;
		IMIDIMgr* pIMIDIMgr;
		if( SUCCEEDED ( punkStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr) ) )
		{
			BSTR bstr;

			if( SUCCEEDED( pIMIDIMgr->GetUndoText( &fUpdateDirectMusic, &bstr) ) )
			{
				if( bstr != NULL )
				{
					BOOL fFreezeUndo = FALSE;

					if( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
					{
						VARIANT var;
						if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
						{
							fFreezeUndo = V_BOOL(&var);
						}
					}
					// Only save an undo state here if TP_FREEZE_UNDO is not set and we are not
					// in a group edit operation (See CPatternCtl::SendEditToTimeline)
					if( !fFreezeUndo && !m_fInGroupEdit )
					{
						CString strEdit;
						strEdit = bstr;
						m_pUndoMgr->SaveState( this, (char*)(LPCTSTR)strEdit );
					}
					SysFreeString( bstr );
				}
			}
			RELEASE( pIMIDIMgr );
		}

		// Check to see if any PChannels changed
		IDMUSProdStripMgr* pIStripMgr;
		if( SUCCEEDED ( punkStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**) &pIStripMgr) ) )
		{
			BOOL fPChannelChange;

			if( SUCCEEDED ( pIStripMgr->GetParam(  STYLE_PChannelChange, 0, NULL, &fPChannelChange ) ) )
			{
				if( fPChannelChange )
				{
					m_pStyle->m_fPChannelChange = TRUE;

					fPChannelChange = FALSE;
					pIStripMgr->SetParam( STYLE_PChannelChange, 0, &fPChannelChange );
				}
			}

			RELEASE( pIStripMgr );
		}

		m_fDontUpdateDirectMusicDuringLoad = !fUpdateDirectMusic;
		if( SUCCEEDED( GetPatternFromMIDIStripMgr() ) )
		{
			hr = S_OK;
		}
		m_fDontUpdateDirectMusicDuringLoad = FALSE; 
	}
	// Check if this is a change from the variation choices editor
	else if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IDMUSProdNode, (void **)&pIVarChoicesNode ) ) )
	{
		// Find the part that has this var choices pointer
		POSITION pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			// Get a pointer to each part ref
			CDirectMusicPartRef* pPartRef = m_lstPartRefs.GetNext( pos );

			// Check if we found the editor
			if( pPartRef->m_pDMPart->m_pVarChoicesNode == pIVarChoicesNode )
			{
				// Found the editor - make sure we're using the correct partref pointer
				pPartRef = pPartRef->m_pDMPart->m_pVarChoicesPartRef;

				// QI the variation choices node for its IPersistStream interface
				IPersistStream *pIPersistStream;
				if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
				{
					// QI the variation choices node for its IVarChoices interface
					IVarChoices *pIVarChoices;
					if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IVarChoices, (void **)&pIVarChoices ) ) )
					{
						// Try and get undo text to display
						BSTR bstrUndoText;
						if( SUCCEEDED( pIVarChoices->GetUndoText( &bstrUndoText ) ) )
						{
							CString strUndoText = bstrUndoText;
							if( !strUndoText.IsEmpty() )
							{
								m_pUndoMgr->SaveState( this, strUndoText.GetBuffer( 1 ) );
								strUndoText.ReleaseBuffer();
							}
							::SysFreeString( bstrUndoText );
						}

						// Create a new part, if needed
						PreChangePartRef( pPartRef );

						pPartRef->m_pDMPart->UpdateFromVarChoices( theApp.m_pStyleComponent->m_pIFramework, pIPersistStream );

						m_pStyle->SyncMidiStripMgrsThatUsePart( pPartRef->m_pDMPart );
						SyncPatternWithDirectMusic();

						pIVarChoices->Release();
					}
					pIPersistStream->Release();
				}
				break;
			}
		}

		pIVarChoicesNode->Release();
	}
	else
	{
		// Save an undo state if we're about to do a multiple-strip cut/delete/paste
		BOOL fFreezeUndo = FALSE;

		if( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
		{
			VARIANT var;
			if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fFreezeUndo = V_BOOL(&var);
			}
		}

		if( fFreezeUndo == FALSE )
		{
			// BUGBUG: We should be smart here and only save the strip that changed to the Undo Manager.
			m_fInUndo = TRUE;

			// If the strip supports the IPersist interface, ignore it - it must be the chord strip
			IPersist *pIPersist;
			if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IPersist, (void**)&pIPersist ) ) )
			{
				pIPersist->Release();
			}
			else
			{
				// This must be for a multi-strip cut/delete/paste, since the stripmgr can't save itself.
				// Look in CTimelineCtl::Delete, etc. methods

				// Ask the StripMgr for its undo text
				IDMUSProdStripMgr *pStripMgr;
				if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
				{
					BSTR bstrUndoText = NULL;
					if( SUCCEEDED( pStripMgr->GetParam( GUID_Segment_Undo_BSTR, 0, NULL, &bstrUndoText ) ) )
					{
						if( bstrUndoText )
						{
							CString strUndoText = bstrUndoText;
							::SysFreeString( bstrUndoText );
							m_pUndoMgr->SaveState( this, (char*)(LPCTSTR)strUndoText );
						}
					}
					pStripMgr->Release();
				}
			}
		}
	}

	// Mark all 'linked' PartRefs that point to a part with m_dwUseCount of one as 'unlinked'
	m_pStyle->UpdateLinkFlags();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetPatternFromMIDIStripMgr()

HRESULT CDirectMusicPattern::GetPatternFromMIDIStripMgr()
{
	ASSERT( m_pPatternCtrl != NULL );
	ASSERT( m_pPatternCtrl->m_pPatternDlg != NULL );
	ASSERT( m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr != NULL );

	// Synchronize our Timeline settings (for when they're set in Load())
	SyncTimelineSettings();

	IDMUSProdStripMgr* pIMIDIStripMgr = m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr; 

	IPersistStream	*pIPS;
	IStream* pIStream;

	// Get Pattern from the MIDI Manager
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_SinglePattern, &pIStream) ) )
	{
		if( SUCCEEDED( pIMIDIStripMgr->QueryInterface(IID_IPersistStream, (void**)&pIPS) ) )
		{
			if( SUCCEEDED( pIPS->Save( pIStream, FALSE) ) )
			{
				// Seek to beginning of stream
				LARGE_INTEGER liTemp;
				liTemp.QuadPart = 0;
				pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL ); 

				sg_fPatternFromMidiMgr = TRUE;
				if( SUCCEEDED( Load( pIStream ) ) )
				{
					SetModified( TRUE );
					hr = S_OK;
				}
				sg_fPatternFromMidiMgr = FALSE;
			}

			RELEASE( pIPS );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::OpenVarChoicesEditor()

HRESULT CDirectMusicPattern::OpenVarChoicesEditor( CDirectMusicPartRef* pPartRef )
{
	m_fInOpenVarChoicesEditor = TRUE;
	ASSERT( pPartRef != NULL );
	ASSERT( pPartRef->m_pDMPart != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// TODO: Check if this editor is still valid
	if( pPartRef->m_pDMPart->m_pVarChoicesNode )
	{
		HWND hWndEditor;
		pPartRef->m_pDMPart->m_pVarChoicesNode->GetEditorWindow( &hWndEditor );
		if( hWndEditor )
		{
			theApp.m_pStyleComponent->m_pIFramework->CloseEditor( pPartRef->m_pDMPart->m_pVarChoicesNode );
		}
		RELEASE( pPartRef->m_pDMPart->m_pVarChoicesNode );
		pPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
	}

	if( pPartRef->m_pDMPart->m_pVarChoicesNode == NULL )
	{
		pPartRef->m_pDMPart->m_pVarChoicesNode = new CVarChoices();
		
		if( pPartRef->m_pDMPart->m_pVarChoicesNode == NULL )
		{
			m_fInOpenVarChoicesEditor = FALSE;
			return E_OUTOFMEMORY;
		}
		pPartRef->m_pDMPart->m_pVarChoicesPartRef = pPartRef;
	}

	// Set the dialog's title and callback and data
	if( pPartRef->m_pDMPart->m_pVarChoicesNode )
	{
		InitializeVarChoicesEditor( pPartRef );
	}

	HRESULT hr = theApp.m_pStyleComponent->m_pIFramework->OpenEditor( pPartRef->m_pDMPart->m_pVarChoicesNode );

	if( SUCCEEDED ( hr ) )
	{
		// Set WINDOWPLACEMENT
		// TODO: ?
		/*
		if( pPartRef->m_pDMPart->m_pVarChoicesNode->m_wp.length )
		{
			if( ::IsWindow( pPartRef->m_pDMPart->m_pVarChoicesNode->m_hWndEditor ) )
			{
				::SetWindowPlacement( pPartRef->m_pDMPart->m_pVarChoicesNode->m_hWndEditor,
									 &pPartRef->m_pDMPart->m_pVarChoicesNode->m_wp );
			}
		}
		*/
	}

	m_fInOpenVarChoicesEditor = FALSE;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::InitializeVarChoicesEditor()

HRESULT CDirectMusicPattern::InitializeVarChoicesEditor( CDirectMusicPartRef* pPartRef )
{
	ASSERT( pPartRef != NULL );
	ASSERT( pPartRef->m_pDMPart != NULL );
	ASSERT( pPartRef->m_pDMPart->m_pVarChoicesNode != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );


	// Set the dialog's title and callback and data
	CString strTitle;

	// "Style name - "
	if( m_pStyle )
	{
		strTitle = m_pStyle->m_strName;
		strTitle += _T(" - " );
	}

	// "Pattern name "
	strTitle += m_strName;
	strTitle += _T(" " );

	// "(Track name)"
	CString strTrack;
	TCHAR achTemp[MID_BUFFER];

	strTrack.LoadString( IDS_TRACK );
	sprintf( achTemp, "%s %d", strTrack, pPartRef->m_dwPChannel + 1 );
	strTrack = achTemp;

	strTitle += _T("(" );
	strTitle += strTrack;
	strTitle += _T(")" );

	IVarChoices *pIVarChoices;
	if( SUCCEEDED( pPartRef->m_pDMPart->m_pVarChoicesNode->QueryInterface( IID_IVarChoices, (void **)&pIVarChoices ) ) )
	{
		pIVarChoices->SetVarChoicesTitle( strTitle.AllocSysString() );

		pIVarChoices->SetDataChangedCallback( (IDMUSProdTimelineCallback *)this );

		pIVarChoices->Release();
	}

	pPartRef->m_pDMPart->m_pVarChoicesNode->SetDocRootNode( m_pStyle );


	IPersistStream *pIPersistStream;
	if( SUCCEEDED( pPartRef->m_pDMPart->m_pVarChoicesNode->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
	{
		IStream *pStream = CreateStreamForVarChoices( theApp.m_pStyleComponent->m_pIFramework, pPartRef->m_pDMPart->m_dwVariationChoices );
		if( pStream )
		{
			StreamSeek( pStream, 0, STREAM_SEEK_SET );
			pIPersistStream->Load( pStream );
			pStream->Release();
		}
		pIPersistStream->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicPattern::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (ppData == NULL)
	|| (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
		// Asking for Motif pointer
		case 0:
		{
			PPGMotif *pPPGMotif = reinterpret_cast<PPGMotif *>(*ppData);
			pPPGMotif->pMotif = this;
			break;
		}

		// Asking for Pattern pointer
		case 1:
		{
			PPGPattern *pPPGPattern = reinterpret_cast<PPGPattern *>(*ppData);
			pPPGPattern->pPattern = this;
			break;
		}

		// Boundary tab
		case 2:
		{
			PPGTabBoundaryFlags *pPPGTabBoundaryFlags = reinterpret_cast<PPGTabBoundaryFlags *>(*ppData);
			pPPGTabBoundaryFlags->dwPlayFlags = m_dwResolution;
			pPPGTabBoundaryFlags->dwFlagsUI = PROPF_HAVE_VALID_DATA;
			pPPGTabBoundaryFlags->strPrompt = m_strName;
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicPattern::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}
	
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
		// Boundary tab
		case 2:
		{
			PPGTabBoundaryFlags *pPPGTabBoundaryFlags = reinterpret_cast<PPGTabBoundaryFlags *>(pData);

			// m_dwResolution
			if( pPPGTabBoundaryFlags->dwPlayFlags != m_dwResolution )
			{
				SetMotifResolution( pPPGTabBoundaryFlags->dwPlayFlags );
			}
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicPattern::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDllBasePropPageManager* pPageManager;
	short nActiveTab = 0;

	if( m_wEmbellishment & EMB_MOTIF )
	{
		// Get the Motif page manager
		if( theApp.m_pIPageManager
		&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_MotifPropPageManager ) == S_OK )
		{
			pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
		}
		else
		{
			pPageManager = new CMotifPropPageManager();
		}
	}
	else
	{
		// Get the Pattern page manager
		if( theApp.m_pIPageManager
		&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_PatternPropPageManager ) == S_OK )
		{
			pPageManager = (CDllBasePropPageManager *)theApp.m_pIPageManager;
		}
		else
		{
			pPageManager = new CPatternPropPageManager();
		}
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Pattern/Motif properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( m_wEmbellishment & EMB_MOTIF )
		{
			if( pPageManager == theApp.m_pIPageManager )
			{
				pIPropSheet->GetActivePage( &CMotifPropPageManager::sm_nActiveTab );
			}
			nActiveTab = CMotifPropPageManager::sm_nActiveTab;
		}

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicPattern::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdTransport implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::Play

HRESULT CDirectMusicPattern::Play(BOOL fPlayFromStart )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( m_pStyle->m_pIDMStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	ASSERT( m_pIDMSegment == NULL );
	ASSERT( m_pIDMSegmentState == NULL );
	ASSERT( m_pIDMTransitionSegmentState == NULL );

	RELEASE( m_pIDMTransitionSegment );

	HRESULT hr;
	hr = CreateSegment( FALSE );

	if( SUCCEEDED( hr ) )
	{
		ASSERT( m_pIDMSegment );

		// If play button was pressed, set the start position to the current cursor position
		if( m_pPatternCtrl && m_pPatternCtrl->m_pPatternDlg &&
			 m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
		{
			if( !fPlayFromStart )
			{
				MUSIC_TIME mtTime;
				if( SUCCEEDED(	m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
				{
					m_pIDMSegment->SetStartPoint( mtTime );
				}
			}
			else
			{
				m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, 0 );
			}
		}

		// Play the band
		PlayBand();

		// Send Tempo event NOW - the only thing that may be playing are pick-up bars, which shold be
		// at this tempo already anyways
		ASSERT( m_pIDMSegmentState == NULL );
		QueueTempoEvent();

		// Play the segment
		hr = theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegment( m_pIDMSegment, DMUS_SEGF_QUEUE, 0, &m_pIDMSegmentState );

		// Notify the MIDIMgr that the music started
		if( SUCCEEDED( hr ) )
		{
			// If editor is open make sure cursor starts moving
			// Wait for DMUS_NOTIFICATION_SEGSTART
			//StartStopMusic( TRUE );

			// Send a tempo event to establish the tempo (this queues it to play 1ms
			// before the SegmentState's start time)
			// Already set - don't set it again.
			/*
			if( fSendTempoEvent )
			{
				QueueTempoEvent();
			}
			*/

			// Notify the MIDIStripMgr that we've started, so that pick-up notes are recorded correctly.
			if( m_pPatternCtrl
			&&	m_pPatternCtrl->m_pPatternDlg
			&&	m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr )
			{
				IMIDIMgr* pIMIDIMgr;
				if( SUCCEEDED ( m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr) ) )
				{
					pIMIDIMgr->SetSegmentState( m_pIDMSegmentState );
					pIMIDIMgr->Release();
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::Stop

HRESULT CDirectMusicPattern::Stop( BOOL fStopImmediate )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	MUSIC_TIME mtNow, mtSegmentStart = 0;
	theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtNow );

	if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( this ) == S_OK )
	{
		// Only stop the transition if there is one.  Otherwise this causes all music to cease immediately.
		if( m_pIDMTransitionSegmentState )
		{
			m_pIDMTransitionSegmentState->GetStartTime( &mtSegmentStart );
			theApp.m_pStyleComponent->m_pIDMPerformance->Stop( NULL, m_pIDMTransitionSegmentState, 0,
															   fStopImmediate ? 0 : DMUS_SEGF_DEFAULT );
		}
		else if( m_pIDMTransitionSegment )
		{
			theApp.m_pStyleComponent->m_pIDMPerformance->StopEx( m_pIDMTransitionSegment, 0,
															   fStopImmediate ? 0 : DMUS_SEGF_DEFAULT );
		}
		// Stop the pattern
		theApp.m_pStyleComponent->m_pIDMPerformance->Stop( m_pIDMSegment, m_pIDMSegmentState, 0,
														   fStopImmediate ? 0 : DMUS_SEGF_DEFAULT );
		if( m_pIDMSegmentState && !mtSegmentStart )
		{
			m_pIDMSegmentState->GetStartTime( &mtSegmentStart );
		}

		// Update the DirectMusic Style object
		m_pStyle->ForceSyncStyleWithDirectMusic();
	}

	// If editor is open make sure cursor stops moving
	// Wait for DMUS_NOTIFICATION_SEGABORT or DMUS_NOTIFICATION_SEGEND
	//StartStopMusic( FALSE );

	// Release the segment
	m_rpIDMStoppedSegmentState = m_pIDMSegmentState;
	RELEASE( m_pIDMSegment );
	RELEASE( m_pIDMSegmentState );
	RELEASE( m_pIDMTransitionSegmentState );
	RELEASE( m_pIDMTransitionSegment );

	// If we are asked to stop our segment state before it begins playing, return an error code because
	// it probably won't stop whatever is currently playing.
	if( mtNow < mtSegmentStart )
	{
		return E_UNEXPECTED;
	}
	else
	{
		return S_OK;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::Transition

HRESULT CDirectMusicPattern::Transition( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( m_pStyle->m_pIDMStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	/*
	if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( this ) == S_OK )
	{
		// We don't support transitioning from ourself to ourself.
		return E_NOTIMPL;
	}
	*/

	ConductorTransitionOptions TransitionOptions;
	if( FAILED( theApp.m_pStyleComponent->m_pIConductor->GetTransitionOptions( &TransitionOptions ) ) )
	{
		return E_NOTIMPL;
	}

	RELEASE( m_pIDMSegment );
	RELEASE( m_pIDMSegmentState );
	RELEASE( m_pIDMTransitionSegmentState );
	RELEASE( m_pIDMTransitionSegment );

	HRESULT hr;
	if( TransitionOptions.dwFlags & TRANS_NO_TRANSITION )
	{
		hr = CreateSegment( TRUE );
		if( SUCCEEDED( hr ) )
		{
			DWORD dwFlags;
			// Set the Boundary settings (bar/beat/grid/immediate/end of segment)
			if( TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
			{
				dwFlags = DMUS_SEGF_QUEUE;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_IMMEDIATE )
			{
				dwFlags = 0;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_GRID )
			{
				dwFlags = DMUS_SEGF_GRID;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_BEAT )
			{
				dwFlags = DMUS_SEGF_BEAT;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MEASURE )
			{
				dwFlags = DMUS_SEGF_MEASURE;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND )
			{
				dwFlags = DMUS_SEGF_SEGMENTEND;
			}
			else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT )
			{
				dwFlags = DMUS_SEGF_DEFAULT;
			}
			else
			{
				ASSERT( FALSE );
				dwFlags = 0;
			}

			if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
			{
				dwFlags |= DMUS_SEGF_ALIGN;

				if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_TICK )
				{
					dwFlags |= DMUS_SEGF_VALID_START_TICK;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_GRID )
				{
					dwFlags |= DMUS_SEGF_VALID_START_GRID;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_BEAT )
				{
					dwFlags |= DMUS_SEGF_VALID_START_BEAT;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_MEASURE )
				{
					dwFlags |= DMUS_SEGF_VALID_START_MEASURE;
				}
			}

			if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MARKER )
			{
				dwFlags |= DMUS_SEGF_MARKER;
			}

			if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_NOINVALIDATE )
			{
				dwFlags |= DMUS_SEGF_NOINVALIDATE;
			}

			if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_AFTERPREPARETIME )
			{
				dwFlags |= DMUS_SEGF_AFTERPREPARETIME;
			}

			if( TransitionOptions.pDMUSProdNodeSegmentTransition )
			{
				IDMUSProdNode *pNode;
				if( SUCCEEDED( TransitionOptions.pDMUSProdNodeSegmentTransition->QueryInterface( IID_IDMUSProdNode, (void **)&pNode ) ) )
				{
					if( SUCCEEDED( pNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&m_pIDMTransitionSegment ) ) )
					{
						dwFlags |= DMUS_SEGF_AUTOTRANSITION;
					}
					pNode->Release();
				}
			}

			m_rpIDMStoppedSegmentState = NULL;

			// Play the segment
			hr = theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegmentEx( m_pIDMSegment, 0, m_pIDMTransitionSegment,
				dwFlags, 0, &m_pIDMSegmentState, NULL, NULL );

			if( SUCCEEDED( hr ) )
			{
				// If editor is open make sure cursor starts moving
				// Wait for DMUS_NOTIFICATION_SEGSTART
				//StartStopMusic( TRUE, TRUE );

				// Queue a tempo event to establish the tempo
				QueueTempoEvent();
			}
		}
		return hr;
	}

	IDirectMusicComposer8 *pIDMComposer;
	::CoCreateInstance( CLSID_DirectMusicComposer, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicComposer8, (void**)&pIDMComposer );
	if( !pIDMComposer )
	{
		return E_NOTIMPL;
	}

	m_rpIDMStoppedSegmentState = NULL;

	hr = CreateSegment( TRUE );
	if( SUCCEEDED( hr ) )
	{
		hr = DoAutoTransition( TransitionOptions, theApp.m_pStyleComponent->m_pIDMPerformance,
						  pIDMComposer, m_pIDMSegment,
						  NULL, &m_pIDMTransitionSegmentState,
						  &m_pIDMSegmentState );

		// Notify the MIDIMgr that the music started
		if( SUCCEEDED( hr ) )
		{
			// If editor is open make sure cursor starts moving
			// Wait for DMUS_NOTIFICATION_SEGSTART
			//StartStopMusic( TRUE, TRUE );

			// Queue a tempo event to establish the tempo
			QueueTempoEvent();
		}
		else
		{
			// Fallback to non-composed transition
			RELEASE( m_pIDMSegment );
			RELEASE( m_pIDMSegmentState );
			RELEASE( m_pIDMTransitionSegmentState );
			ASSERT( m_pIDMSegment == NULL );

			hr = CreateSegment( TRUE );
			if( SUCCEEDED( hr ) )
			{
				DWORD dwFlags;
				// Set the Boundary settings (bar/beat/grid/immediate/end of segment)
				if( TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
				{
					dwFlags = DMUS_SEGF_QUEUE;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_IMMEDIATE )
				{
					dwFlags = 0;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_GRID )
				{
					dwFlags = DMUS_SEGF_GRID;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_BEAT )
				{
					dwFlags = DMUS_SEGF_BEAT;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MEASURE )
				{
					dwFlags = DMUS_SEGF_MEASURE;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND )
				{
					dwFlags = DMUS_SEGF_SEGMENTEND;
				}
				else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT )
				{
					dwFlags = DMUS_SEGF_DEFAULT;
				}
				else
				{
					ASSERT( FALSE );
					dwFlags = 0;
				}

				if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
				{
					dwFlags |= DMUS_SEGF_ALIGN;

					if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_TICK )
					{
						dwFlags |= DMUS_SEGF_VALID_START_TICK;
					}
					else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_GRID )
					{
						dwFlags |= DMUS_SEGF_VALID_START_GRID;
					}
					else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_BEAT )
					{
						dwFlags |= DMUS_SEGF_VALID_START_BEAT;
					}
					else if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_MEASURE )
					{
						dwFlags |= DMUS_SEGF_VALID_START_MEASURE;
					}
				}

				if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MARKER )
				{
					dwFlags |= DMUS_SEGF_MARKER;
				}

				if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_NOINVALIDATE )
				{
					dwFlags |= DMUS_SEGF_NOINVALIDATE;
				}

				if( TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_AFTERPREPARETIME )
				{
					dwFlags |= DMUS_SEGF_AFTERPREPARETIME;
				}

				m_rpIDMStoppedSegmentState = NULL;

				// Play the segment
				hr = theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegment( m_pIDMSegment, dwFlags, 0, &m_pIDMSegmentState );

				// Notify the MIDIMgr that the music started
				if( SUCCEEDED( hr ) )
				{
					// If editor is open make sure cursor starts moving
					// Wait for DMUS_NOTIFICATION_SEGSTART
					//StartStopMusic( TRUE, TRUE );

					// Queue a tempo event to establish the tempo
					QueueTempoEvent();
				}
			}
		}
	}

	RELEASE( pIDMComposer );

	if( FAILED( hr ) )
	{
		return E_NOTIMPL;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::Record

HRESULT CDirectMusicPattern::Record( BOOL fPressed )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Dialog active - tell MIDIMgr that the Record button state changed
	if( m_fDialogActive )
	{
		if( m_pPatternCtrl == NULL || m_pPatternCtrl->m_pPatternDlg == NULL ||
			m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr == NULL )
		{
			m_fRecordPressed = fPressed;
			// We shouldn't have an active dialog if we don't even have a dialog...
			ASSERT(FALSE);
			return S_FALSE;
		}

		HRESULT hr = E_FAIL;

		IMIDIMgr* pIMIDIMgr;
		if( SUCCEEDED ( m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr) ) )
		{
			hr = pIMIDIMgr->OnRecord( fPressed );
			if( SUCCEEDED( hr ) )
			{
				m_fRecordPressed = fPressed;
			}
			pIMIDIMgr->Release();
		}
		return hr;
	}
	// Dialog inactive - just set m_fRecordPressed
	else
	{
		m_fRecordPressed = fPressed;
		return S_OK;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetName

HRESULT CDirectMusicPattern::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	// Style file name
	CString strName;
	BSTR bstrStyleFileName;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->GetNodeFileName( m_pStyle, &bstrStyleFileName ) ) )
	{
		// Node is in the Project tree
		strName = bstrStyleFileName;
		::SysFreeString( bstrStyleFileName );
		int nFindPos = strName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strName = strName.Right( strName.GetLength() - nFindPos - 1 );
		}
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Style is still in the process of being loaded
		strName = m_pStyle->m_strOrigFileName;
		strName += _T(": ");
	}
	
	// Plus "name"
	strName += m_strName;

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::TrackCursor

HRESULT CDirectMusicPattern::TrackCursor( BOOL fTrackCursor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fTrackTimeCursor = fTrackCursor;

	if( m_pPatternCtrl && m_pPatternCtrl->m_pPatternDlg && m_fPatternIsPlaying )
	{
		m_pPatternCtrl->m_pPatternDlg->EnableTimer( fTrackCursor );
	}

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdSecondaryTransport implementation

// CDirectMusicPattern IDMUSProdSecondaryTransport::GetSecondaryTransportSegment

HRESULT CDirectMusicPattern::GetSecondaryTransportSegment( IUnknown **ppunkSegment )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate ppunkSegment
	if( ppunkSegment == NULL )
	{
		return E_POINTER;
	}

	/**/
	// Try and create a segment
	ASSERT( m_pStyle != NULL );
	ASSERT( m_pStyle->m_pIDMStyle != NULL );

	IDirectMusicSegment *pSegment = NULL;

	// Get the Wide character name of this motif
	BSTR bstrName = m_strName.AllocSysString();

	HRESULT hr = m_pStyle->m_pIDMStyle->GetMotif( bstrName, &pSegment );

	if( hr == S_OK )
	{
		hr = pSegment->QueryInterface( IID_IUnknown, (void**)ppunkSegment );
	}
	else if ( hr == S_FALSE )
	{
		hr = E_FAIL;
	}

	RELEASE(pSegment);
	SysFreeString( bstrName );
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdSecondaryTransport::GetSecondaryTransportName

HRESULT CDirectMusicPattern::GetSecondaryTransportName( BSTR* pbstrName )
{
	return GetName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IConductorTempo implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetTempo

HRESULT CDirectMusicPattern::SetTempo( double dblTempo )
{
	if( !m_pStyle )
	{
		return E_FAIL;
	}

	m_pStyle->SetTempo( dblTempo, FALSE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetTempo

HRESULT CDirectMusicPattern::GetTempo( double *pdblTempo )
{
	if( !pdblTempo )
	{
		return E_POINTER;
	}

	if( !m_pStyle )
	{
		return E_FAIL;
	}

	*pdblTempo = m_pStyle->m_dblTempo;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetTempoModifier

HRESULT CDirectMusicPattern::SetTempoModifier( double dblModifier )
{
	UNREFERENCED_PARAMETER(dblModifier);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetTempoModifier

HRESULT CDirectMusicPattern::GetTempoModifier( double *pdblModifier )
{
	UNREFERENCED_PARAMETER(pdblModifier);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::TempoModified

HRESULT CDirectMusicPattern::TempoModified( BOOL fModified )
{
	UNREFERENCED_PARAMETER(fModified);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IDMUSProdNotifyCPt implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::OnNotify

HRESULT CDirectMusicPattern::OnNotify( ConductorNotifyEvent *pConductorNotifyEvent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pConductorNotifyEvent != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	switch( pConductorNotifyEvent->m_dwType )
	{
		case DMUS_PMSGT_NOTIFICATION:
		{
			DMUS_NOTIFICATION_PMSG* pNotifyEvent = (DMUS_NOTIFICATION_PMSG *)pConductorNotifyEvent->m_pbData;
			//HRESULT hr;
			//hr = theApp.m_pStyleComponent->m_pIDMPerformance->IsPlaying( NULL, m_pIDMSegmentState);

			// Handle GUID_NOTIFICATION_SEGMENT notifications
			if( ::IsEqualGUID ( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_SEGMENT ) )
			{
				//TRACE("SegmentState: %d %x\n", pNotifyEvent->dwNotificationOption, pNotifyEvent->punkUser );
				if( (pNotifyEvent->punkUser == m_pIDMSegmentState)
				||	(pNotifyEvent->punkUser == m_rpIDMStoppedSegmentState) )
				{
					switch( pNotifyEvent->dwNotificationOption )
					{
						case DMUS_NOTIFICATION_SEGSTART:
							m_rtCurrentStartTime = pNotifyEvent->rtTime;
						case DMUS_NOTIFICATION_SEGLOOP:
							// Update the playing flag
							StartStopMusic( TRUE );

							// Make sure cursor starts moving
							if( m_pPatternCtrl
							&&  m_pPatternCtrl->m_pPatternDlg )
							{
								::PostMessage( m_pPatternCtrl->m_pPatternDlg->m_hWnd, WM_APP, pNotifyEvent->dwNotificationOption, pNotifyEvent->mtTime );
							}
							break;

						case DMUS_NOTIFICATION_SEGABORT:
						case DMUS_NOTIFICATION_SEGEND:
							//TRACE("SegmentState: %d %x\n", pNotifyEvent->dwNotificationOption, pNotifyEvent->punkUser );
							// Update the playing flag
							StartStopMusic( FALSE );

							// Notify the Conductor we stopped playing
							if( theApp.m_pStyleComponent && theApp.m_pStyleComponent->m_pIConductor )
							{
								theApp.m_pStyleComponent->m_pIConductor->TransportStopped( (IDMUSProdTransport*) this );
							}

							// If editor is open, make sure cursor stops moving
							if( m_pPatternCtrl
							&&  m_pPatternCtrl->m_pPatternDlg )
							{
								IDirectMusicSegmentState* pIDMSegmentState = m_pIDMSegmentState ? m_pIDMSegmentState : m_rpIDMStoppedSegmentState;
								MUSIC_TIME mtStartTime;
								MUSIC_TIME mtOffset = -1;
								MUSIC_TIME mtStartPoint;

								if( SUCCEEDED ( pIDMSegmentState->GetStartTime( &mtStartTime ) ) && 
									SUCCEEDED ( pIDMSegmentState->GetStartPoint( &mtStartPoint ) ) )
								{
									mtOffset = pNotifyEvent->mtTime - mtStartTime + mtStartPoint;
									if( mtOffset >=0 )
									{
										mtOffset = mtOffset % m_dwLength;
									}
								}
								::PostMessage( m_pPatternCtrl->m_pPatternDlg->m_hWnd, WM_APP, pNotifyEvent->dwNotificationOption, mtOffset );
							}

							// Don't need this reference or time anymore
							m_rpIDMStoppedSegmentState = NULL;
							m_rtCurrentStartTime = 0;
							break;
					}
				}
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPatternNodePrivate implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DisplayPartLinkDialog

HRESULT CDirectMusicPattern::DisplayPartLinkDialog( GUID *pGuid, IStream **ppPartStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate parameters
	if( !pGuid || !ppPartStream )
	{
		return E_POINTER;
	}

	// Initialize parameters to 0
	*ppPartStream = NULL;
	memset( pGuid, 0, sizeof(GUID) );

	// Display the dialog
	CDialogLinkExisting dlg;
	dlg.m_pDMStyle = m_pStyle;
	if( (dlg.DoModal() == IDOK) && (dlg.m_pDMPartRef != NULL) )
	{
		if( dlg.m_pDMPartRef->m_pPattern != this )
		{
			// Linking to another pattern - get a copy of the part in a stream

			// Get a memory stream
			HRESULT hr;
			hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, ppPartStream );
			if( FAILED ( hr ) )
			{
				return hr;
			}

			// Get a RIFF stream
			IDMUSProdRIFFStream* pIRiffStream = NULL;
			hr = AllocRIFFStream( *ppPartStream, &pIRiffStream );
			if( FAILED ( hr ) )
			{
				RELEASE(*ppPartStream);
				return hr;
			}

			// Save the part to the RIFF stream
			hr = dlg.m_pDMPartRef->m_pDMPart->DM_SavePart( pIRiffStream );

			// Release the RIFF stream
			RELEASE( pIRiffStream );

			// Exit if we failed
			if( FAILED ( hr ) )
			{
				RELEASE(*ppPartStream);
				return hr;
			}

			// Seek back to the beginning
			LARGE_INTEGER li;
			li.QuadPart = 0;
			hr = (*ppPartStream)->Seek( li, STREAM_SEEK_SET, NULL );
			if( FAILED ( hr ) )
			{
				RELEASE(*ppPartStream);
				return hr;
			}
		}

		// Copy the GUID
		memcpy( pGuid, &dlg.m_pDMPartRef->m_pDMPart->m_guidPartID, sizeof(GUID) );

		// Fix 22261: Always mark the linked to PartRef as hardLinked here, rather than
		// letting the MIDIStripMgr try and figure out which PartRef it was linked to.
		//if( dlg.m_pDMPartRef->m_pPattern != this )
		{
			// Save "Undo" state
			//   Don't save an undo state - this is a 'side effect', so we don't care about it
			//dlg.m_pDMPartRef->m_pPattern->m_pUndoMgr->SaveState( dlg.m_pDMPartRef->m_pPattern, theApp.m_hInstance, IDS_UNDO_PATTERN_PART_LINK );

			dlg.m_pDMPartRef->m_fHardLink = TRUE;
			dlg.m_pDMPartRef->m_pDMPart->m_dwHardLinkCount++;

			dlg.m_pDMPartRef->m_pPattern->SetModified( TRUE );
			dlg.m_pDMPartRef->m_pPattern->m_pStyle->SyncStyleEditor( dlg.m_pDMPartRef->m_pPattern->m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
			dlg.m_pDMPartRef->m_pPattern->SyncPatternWithMidiStripMgr();
			dlg.m_pDMPartRef->m_pPattern->SyncPatternWithDirectMusic();
		}

		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DisplayVariationChoicesDlg

HRESULT CDirectMusicPattern::DisplayVariationChoicesDlg( REFGUID guidPart, DWORD dwPChannel )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicPartRef* pPartRef = FindPartRefByPChannelAndGUID( dwPChannel, guidPart );
	m_pPatternCtrl->PostMessage( WM_OPEN_VARCHOICES, 0, (LPARAM)pPartRef );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetAuditionVariations

HRESULT CDirectMusicPattern::SetAuditionVariations( DWORD dwVariations, REFGUID rguidPart, DWORD dwPChannel )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDirectMusicTrack* pIDMTrack;

	HRESULT hr = E_FAIL;

	// Update Pattern Track
	if( !m_pIDMSegment )
	{
		hr = S_FALSE;
	}
	else if( SUCCEEDED ( m_pIDMSegment->GetTrack( CLSID_DirectMusicPatternTrack, 1, 0, &pIDMTrack ) ) )
	{
		IPrivatePatternTrack* pIDMPrivatePatternTrack;
		IPrivatePatternTrack9* pIDMPrivatePatternTrack9;
		if( SUCCEEDED ( pIDMTrack->QueryInterface( IID_IPrivatePatternTrack9, (void **)&pIDMPrivatePatternTrack9 ) ) )
		{
			// If no variations are selected, then pass GUID_AllZeros
			hr = pIDMPrivatePatternTrack9->SetVariationMaskByGUID( m_pIDMSegmentState, dwVariations, dwVariations ? rguidPart : GUID_AllZeros, dwPChannel );

			RELEASE( pIDMPrivatePatternTrack9 );
		}
		else if( SUCCEEDED ( pIDMTrack->QueryInterface( IID_IPrivatePatternTrack, (void **)&pIDMPrivatePatternTrack ) ) )
		{
			hr = pIDMPrivatePatternTrack->SetVariationByGUID( m_pIDMSegmentState, dwVariations, rguidPart, dwPChannel );

			RELEASE( pIDMPrivatePatternTrack );
		}
		
		RELEASE( pIDMTrack );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetNumHardLinkRefs

HRESULT CDirectMusicPattern::GetNumHardLinkRefs( REFGUID guidPart, DWORD* pdwReferences )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !pdwReferences )
	{
		return E_POINTER;
	}

	CDirectMusicPart* pDMPart = m_pStyle->FindPartByGUID( guidPart );

	if( pDMPart )
	{
		*pdwReferences = pDMPart->m_dwHardLinkCount;
		return S_OK;
	}
	else
	{
		*pdwReferences = 0;
		return E_INVALIDARG;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::CanShowPartLinkDialog

HRESULT CDirectMusicPattern::CanShowPartLinkDialog()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		if( !m_pStyle->m_lstStyleParts.IsEmpty() )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::RegisterWithTransport

HRESULT CDirectMusicPattern::RegisterWithTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	DWORD dwButtonState = BS_AUTO_UPDATE;
	if( m_pPatternCtrl != NULL && m_pPatternCtrl->m_pPatternDlg != NULL &&
		m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr != NULL )
	{
		dwButtonState |= BS_RECORD_ENABLED;
		if( m_fRecordPressed )
		{
			dwButtonState |= BS_RECORD_CHECKED;
		}
	}

	// If we're a Motif, register with Conductor's Secondary Transport system
	if( m_wEmbellishment & EMB_MOTIF )
	{
		if( FAILED ( theApp.m_pStyleComponent->m_pIConductor->RegisterSecondaryTransport( this ) ) )
		{
			return E_FAIL;
		}
	}

	// Register Pattern with Conductor's Transport and notification system
	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIConductor->RegisterTransport( this, dwButtonState ) )
	&&  SUCCEEDED ( theApp.m_pStyleComponent->m_pIConductor->RegisterNotify( this, GUID_NOTIFICATION_SEGMENT ) )
	&&  SUCCEEDED ( theApp.m_pStyleComponent->m_pIConductor->RegisterNotify( this, GUID_NOTIFICATION_MEASUREANDBEAT ) ) )
	{
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::UnRegisterWithTransport

HRESULT CDirectMusicPattern::UnRegisterWithTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	// Make sure Pattern is not playing
	Stop( TRUE );

	// If we're a motif, unregister the Transport's secondary Play, Stop functionality.
	if( m_wEmbellishment & EMB_MOTIF )
	{
		theApp.m_pStyleComponent->m_pIConductor->UnRegisterSecondaryTransport( this );
	}

	// Unregister the Transport's Play, Stop, Transition functionality.
	theApp.m_pStyleComponent->m_pIConductor->UnRegisterTransport( this );

	// Unregister notification messages
	theApp.m_pStyleComponent->m_pIConductor->UnregisterNotify( this, GUID_NOTIFICATION_SEGMENT );
	theApp.m_pStyleComponent->m_pIConductor->UnregisterNotify( this, GUID_NOTIFICATION_MEASUREANDBEAT );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetNbrMeasures

void CDirectMusicPattern::SetNbrMeasures( WORD wNbrMeasures )
{
	ASSERT( m_pStyle != NULL );

	if( wNbrMeasures != m_wNbrMeasures )
	{
		// Save "Undo" state
		if( m_wEmbellishment & EMB_MOTIF )
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_LENGTH );
		}
		else
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_LENGTH );
		}

		// Change Pattern rhythm map
		DWORD* pRhythmMap = m_pRhythmMap;
		m_pRhythmMap = new DWORD[wNbrMeasures];
		if( m_pRhythmMap )
		{
			for( int i = 0 ;  i < wNbrMeasures ;  ++i )
			{
				if( i < m_wNbrMeasures )
				{
					m_pRhythmMap[i] = pRhythmMap[i];
				}
				else
				{
					m_pRhythmMap[i] = 0;
				}
			}
		}
		if( pRhythmMap )
		{
			delete [] pRhythmMap;
		}

		// Change Pattern length
		WORD wOrigNbrMeasures = m_wNbrMeasures;
		m_wNbrMeasures = wNbrMeasures; 
		RecalcLength();

		// Change length of all Parts
		CDirectMusicPartRef* pPartRef;

		POSITION pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			pPartRef = m_lstPartRefs.GetNext( pos );

			ASSERT( pPartRef->m_pDMPart != NULL);

			// Only change when length of part equals original pattern length
			// and time signature of part equals time signature of pattern
			if( pPartRef->m_pDMPart->m_wNbrMeasures == wOrigNbrMeasures 
			&&  pPartRef->m_pDMPart->m_TimeSignature.m_bBeat == m_TimeSignature.m_bBeat 
			&&  pPartRef->m_pDMPart->m_TimeSignature.m_bBeatsPerMeasure == m_TimeSignature.m_bBeatsPerMeasure 
			&&  pPartRef->m_pDMPart->m_TimeSignature.m_wGridsPerBeat == m_TimeSignature.m_wGridsPerBeat )
			{
				if( pPartRef->m_fHardLink == FALSE )
				{
					PreChangePartRef( pPartRef );
					pPartRef->m_pDMPart->SetNbrMeasures( wNbrMeasures );
				}
				else
				{
					DWORD dwLinkCount = pPartRef->m_pDMPart->m_dwHardLinkCount;
					POSITION pos2 = m_lstPartRefs.GetHeadPosition();
					while( pos2 && dwLinkCount )
					{
						CDirectMusicPartRef* pTmpPartRef = m_lstPartRefs.GetNext( pos2 );
						if( pTmpPartRef->m_fHardLink
						&&	pTmpPartRef->m_pDMPart == pPartRef->m_pDMPart )
						{
							dwLinkCount--;
						}
					}

					// If all hard links to this part are in this pattern, change the part's length
					if( dwLinkCount == 0 )
					{
						PreChangePartRef( pPartRef );
						pPartRef->m_pDMPart->SetNbrMeasures( wNbrMeasures );
					}
				}
			}
		}
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();

		if( m_pPatternCtrl
		&&  m_pPatternCtrl->m_pPatternDlg
		&&  m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
		{
			m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->Refresh();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetEmbellishment

void CDirectMusicPattern::SetEmbellishment( WORD wOnEmbellishment, WORD wOffEmbellishment, WORD wCustomId )
{
	ASSERT( m_pStyle != NULL );
	ASSERT( (wCustomId == 0) || ((wCustomId >= MIN_EMB_CUSTOM_ID) && (wCustomId <= MAX_EMB_CUSTOM_ID)) );

	// LOBYTE(m_wEmbellishment) contains bit flags for intro, fill, break, end. When set, HIBYTE must be zero.
	// HIBYTE(m_wEmbellishment) contains custom id number between 100-199.  When set, LOBYTE must be zero.
	
	WORD wOrigEmbellishment = m_wEmbellishment;
	WORD wEmbellishment = m_wEmbellishment;
	wEmbellishment &= ~wOffEmbellishment;	// Turn off bits in LOBYTE
	wEmbellishment |= wOnEmbellishment;		// Turn on bits in LOBYTE
	wEmbellishment &= 0x00FF;				// Set HIBYTE to zero
	wEmbellishment += wCustomId << 8;		// Set HIBYTE to new value

	// Store last custom embellishment ID
	if( HIBYTE(wOrigEmbellishment) )
	{
		// Store original
		m_nLastCustomId = HIBYTE(wOrigEmbellishment);
	}
	if( HIBYTE(wEmbellishment) )
	{
		// Overlay original with current
		m_nLastCustomId = HIBYTE(wEmbellishment);
	}

	if( wEmbellishment != m_wEmbellishment )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_EMBELLISHMENT );

		// Change Embellishment
		m_wEmbellishment = wEmbellishment; 
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		if( (HIBYTE(wOrigEmbellishment) == 0)  &&  (HIBYTE(m_wEmbellishment) != 0) 
		||  (HIBYTE(wOrigEmbellishment) != 0)  &&  (HIBYTE(m_wEmbellishment) == 0) )
		{
			// Refresh properties when switching to/from a custom embellishment
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				pIPropSheet->RefreshActivePageByObject( this );
				RELEASE( pIPropSheet );
			}
		}
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetGrooveRange

void CDirectMusicPattern::SetGrooveRange( BYTE bGrooveBottom, BYTE bGrooveTop )
{
	ASSERT( m_pStyle != NULL );

	if( bGrooveBottom != m_bGrooveBottom
	||  bGrooveTop != m_bGrooveTop )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_GROOVE_RANGE );

		// Change Groove Range
		m_bGrooveBottom = bGrooveBottom; 
		m_bGrooveTop = bGrooveTop; 
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetDestGrooveRange

void CDirectMusicPattern::SetDestGrooveRange( BYTE bDestGrooveBottom, BYTE bDestGrooveTop )
{
	ASSERT( m_pStyle != NULL );

	if( bDestGrooveBottom != m_bDestGrooveBottom
	||  bDestGrooveTop != m_bDestGrooveTop )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_DEST_GROOVE_RANGE );

		// Change Dest Groove Range
		m_bDestGrooveBottom = bDestGrooveBottom; 
		m_bDestGrooveTop = bDestGrooveTop; 
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetRhythmMap

void CDirectMusicPattern::SetRhythmMap( DWORD* pRythmMap  )
{
	ASSERT( m_pStyle != NULL );
	ASSERT( pRythmMap != NULL );

	BOOL fModified = FALSE;

	// Determine if rhythm map has changed
	for( int i = 0 ;  i < m_wNbrMeasures ;  ++i )
	{
		if( pRythmMap[i] != m_pRhythmMap[i] )
		{
			fModified = TRUE;
			break;
		}
	}

	// Change rhythm map
	if( fModified )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_RHYTHM_MAP );

		for( int i = 0 ;  i < m_wNbrMeasures ;  ++i )
		{
			m_pRhythmMap[i] = pRythmMap[i];
		}
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetTimeSignature

void CDirectMusicPattern::SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fSyncWithEngine )
{
	if( timeSig.m_bBeatsPerMeasure != m_TimeSignature.m_bBeatsPerMeasure
	||  timeSig.m_bBeat != m_TimeSignature.m_bBeat
	||  timeSig.m_wGridsPerBeat != m_TimeSignature.m_wGridsPerBeat )
	{
		// Change Pattern time signature
		m_TimeSignature = timeSig;
		
		// Adjust Pattern length
		DWORD dwClocksPerBeat = DM_PPQNx4 / m_TimeSignature.m_bBeat;
		DWORD dwClocksPerMeasure = dwClocksPerBeat * (DWORD)m_TimeSignature.m_bBeatsPerMeasure;
		WORD wNbrMeasures = (WORD)(m_dwLength / dwClocksPerMeasure);
		if( m_dwLength % dwClocksPerMeasure )
		{
			wNbrMeasures++;
		}

		if( wNbrMeasures != m_wNbrMeasures )
		{
			// Change Pattern rhythm map
			DWORD* pRhythmMap = m_pRhythmMap;
			m_pRhythmMap = new DWORD[wNbrMeasures];
			if( m_pRhythmMap )
			{
				for( int i = 0 ;  i < wNbrMeasures ;  ++i )
				{
					if( i < m_wNbrMeasures )
					{
						m_pRhythmMap[i] = pRhythmMap[i];
					}
					else
					{
						m_pRhythmMap[i] = 0;
					}
				}
			}
			if( pRhythmMap )
			{
				delete [] pRhythmMap;
			}

			// Change Pattern length
			m_wNbrMeasures = wNbrMeasures; 
		}
		
		RecalcLength();

		// Refresh Property Page
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RefreshActivePageByObject( this );
			RELEASE( pIPropSheet );
		}

		SetModified( TRUE );
		SyncPatternWithMidiStripMgr();
		if( fSyncWithEngine )
		{
			SyncPatternWithDirectMusic();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetMotifResolution

void CDirectMusicPattern::SetMotifResolution( DWORD dwResolution )
{
	ASSERT( m_pStyle != NULL );

	// Only applies to Motifs
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return;
	}

	if( dwResolution != m_dwResolution )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_RESOLUTION );

		// Change Motif Resolution
		m_dwResolution = dwResolution; 
		
		SetModified( TRUE );
//		m_pStyle->SyncStyleEditor( SSE_MOTIFS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetMotifRepeats

void CDirectMusicPattern::SetMotifRepeats( DWORD dwRepeats )
{
	ASSERT( m_pStyle != NULL );

	// Only applies to Motifs
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return;
	}

	if( dwRepeats != m_dwRepeats )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_REPEATS );

		// Change Motif Repeats
		m_dwRepeats = dwRepeats; 
		
		SetModified( TRUE );
//		m_pStyle->SyncStyleEditor( SSE_MOTIFS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetMotifPlayStart

BOOL CDirectMusicPattern::SetMotifPlayStart( MUSIC_TIME mtPlayStart )
{
	ASSERT( m_pStyle != NULL );

	// Only applies to Motifs
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return FALSE;
	}

	if( mtPlayStart > ((long)m_dwLength - 1) )
	{
		return FALSE;
	}
	mtPlayStart = max( mtPlayStart, 0 );

	if( mtPlayStart != m_mtPlayStart )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_PLAYSTART );

		// Change Motif Play Start
		m_mtPlayStart = mtPlayStart; 
		
		SetModified( TRUE );
//		m_pStyle->SyncStyleEditor( SSE_MOTIFS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetMotifLoopStart

BOOL CDirectMusicPattern::SetMotifLoopStart( MUSIC_TIME mtLoopStart )
{
	ASSERT( m_pStyle != NULL );

	// Only applies to Motifs
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return FALSE;
	}

	mtLoopStart = min( mtLoopStart, (long)m_dwLength - 1 );
	mtLoopStart = max( mtLoopStart, 0 );

	if( mtLoopStart != m_mtLoopStart )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_LOOPPOINTS );

		// Change Motif Loop Start
		m_mtLoopStart = mtLoopStart; 

		// Adjust related fields
		if( m_mtLoopEnd <= m_mtLoopStart )
		{
			m_mtLoopEnd = m_mtLoopStart + 1;
		}
		
		SetModified( TRUE );
//		m_pStyle->SyncStyleEditor( SSE_MOTIFS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetMotifLoopEnd

BOOL CDirectMusicPattern::SetMotifLoopEnd( MUSIC_TIME mtLoopEnd )
{
	ASSERT( m_pStyle != NULL );

	// Only applies to Motifs
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return FALSE;
	}

	mtLoopEnd = min( mtLoopEnd, (long)m_dwLength );
	mtLoopEnd = max( mtLoopEnd, 1 );

	if( mtLoopEnd != m_mtLoopEnd )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_LOOPPOINTS );

		// Change Motif Loop End
		m_mtLoopEnd = mtLoopEnd; 

		// Adjust related fields
		if( m_mtLoopStart >= m_mtLoopEnd )
		{
			m_mtLoopStart = m_mtLoopEnd - 1;
		}
		
		SetModified( TRUE );
//		m_pStyle->SyncStyleEditor( SSE_MOTIFS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::ResetMotifLoopPoints

void CDirectMusicPattern::ResetMotifLoopPoints( void )
{
	ASSERT( m_pStyle != NULL );

	// Only applies to Motifs
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return;
	}

	if( m_mtLoopStart != 0
	||  m_mtLoopEnd != (long)m_dwLength )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_MOTIF_LOOPPOINTS );

		// Change Motif Loop Start/End
		m_mtLoopStart = 0; 
		m_mtLoopEnd = (long)m_dwLength; 
		
		SetModified( TRUE );
//		m_pStyle->SyncStyleEditor( SSE_MOTIFS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::MusicTimeToBarBeatGridTick

void CDirectMusicPattern::MusicTimeToBarBeatGridTick( MUSIC_TIME mtTime,
													  long* plBar, long* plBeat, long* plGrid, long* plTick )
{
	long lClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
	long lClocksPerMeasure = lClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
	long lClocksPerGrid = lClocksPerBeat / (long)m_TimeSignature.m_wGridsPerBeat;
	long lRemainder;

	// Bar
	*plBar = (mtTime / lClocksPerMeasure) + 1;
	lRemainder = mtTime % lClocksPerMeasure;

	// Beat
	*plBeat = (lRemainder / lClocksPerBeat) + 1;
	lRemainder = lRemainder % lClocksPerBeat;

	// Grid
	*plGrid = (lRemainder / lClocksPerGrid) + 1;

	// Tick
	*plTick = lRemainder % lClocksPerGrid;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::BarBeatGridTickToMusicTime

void CDirectMusicPattern::BarBeatGridTickToMusicTime( long lBar, long lBeat, long lGrid, long lTick,
													  MUSIC_TIME* pmtTime )
{
	long lClocksPerBeat = DM_PPQNx4 / (long)m_TimeSignature.m_bBeat;
	long lClocksPerMeasure = lClocksPerBeat * (long)m_TimeSignature.m_bBeatsPerMeasure;
	long lClocksPerGrid = lClocksPerBeat / (long)m_TimeSignature.m_wGridsPerBeat;

	*pmtTime  = (lBar - 1) * lClocksPerMeasure;
	*pmtTime += (lBeat - 1) * lClocksPerBeat;
	*pmtTime += (lGrid - 1) * lClocksPerGrid;
	*pmtTime += lTick;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SyncTempo

void CDirectMusicPattern::SyncTempo( void )
{
	ASSERT( m_pStyle != NULL );

	// Sync timeline tempo
	if( m_pPatternCtrl
	&&  m_pPatternCtrl->m_pPatternDlg
	&&  m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
	{
		DMUS_TEMPO_PARAM dmusTempoParam;

		dmusTempoParam.mtTime = 0;
		dmusTempoParam.dblTempo = m_pStyle->m_dblTempo;

		m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->SetParam( GUID_TempoParam, 1, 0, 0, &dmusTempoParam );

		// Notify the Timeline that the tempo changed
		m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->NotifyStripMgrs( GUID_TempoParam, 0xffffffff, NULL );
	}

	// Sync conductor tempo
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	theApp.m_pStyleComponent->m_pIConductor->SetTempo( this, m_pStyle->m_dblTempo, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PlayBand

HRESULT CDirectMusicPattern::PlayBand( void )
{
	ASSERT( m_pStyle != NULL );
	ASSERT( m_pStyle->m_pIDMStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	// Determine which Band to use
	IDMUSProdNode* pIBandNode = GetActiveBand();
	if( pIBandNode == NULL )
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	// Persist the Band into a DirectMusicBand object
	IDirectMusicBand* pIDMBand = m_pStyle->GetDMBand( pIBandNode );
	if( pIDMBand )
	{
		// Send the Band
		IDirectMusicSegment* pIDMSegmentBand;

		if( SUCCEEDED ( pIDMBand->CreateSegment( &pIDMSegmentBand ) ) )
		{
			theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegment( pIDMSegmentBand, DMUS_SEGF_SECONDARY , 0, NULL );
			hr = S_OK;

			RELEASE( pIDMSegmentBand );
		}

		RELEASE( pIDMBand );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::InsertBandTrack

HRESULT CDirectMusicPattern::InsertBandTrack( IDirectMusicSegment *pSegment, BOOL fNeedBandTrack )
{
	ASSERT( pSegment != NULL );
	if( pSegment == NULL )
	{
		return E_POINTER;
	}
	ASSERT( m_pStyle != NULL );
	ASSERT( m_pStyle->m_pIDMStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	// Determine which Band to use
	IDMUSProdNode* pIBandNode = GetActiveBand();
	if( pIBandNode == NULL )
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;

	// Persist the Band into a DirectMusicBand object
	IDirectMusicBand* pIDMBand = m_pStyle->GetDMBand( pIBandNode );
	if( pIDMBand )
	{
		// Create a new Band track
		IDirectMusicTrack* pIDMTrack;

		if( SUCCEEDED ( ::CoCreateInstance( CLSID_DirectMusicBandTrack, NULL, CLSCTX_INPROC, 
											IID_IDirectMusicTrack, (void**)&pIDMTrack ) ) )
		{
			// Place the Band into the track
			if( SUCCEEDED ( pIDMTrack->SetParam( GUID_IDirectMusicBand, 0, pIDMBand ) )
			&&  SUCCEEDED (	pIDMTrack->SetParam( GUID_Disable_Auto_Download, 0, NULL ) )
			&&  SUCCEEDED ( pSegment->InsertTrack( pIDMTrack, 1 ) ) ) 
			{
				pIDMTrack->Init( pSegment );

				if( !fNeedBandTrack )
				{
					pSegment->RemoveTrack( pIDMTrack );
					// Disable playback of the band track
					//pSegment->SetTrackConfig( CLSID_DirectMusicBandTrack, 1, 0, 0, 0xFFFFFFFF );
				}
				hr = S_OK;
			}

			RELEASE( pIDMTrack );
		}

		RELEASE( pIDMBand );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::InsertChordTrack

HRESULT CDirectMusicPattern::InsertChordTrack( IDirectMusicSegment *pSegment )
{
	ASSERT( pSegment != NULL );
	if( pSegment == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	IDirectMusicTrack* pIDMTrack;

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( ::CoCreateInstance( CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC, 
										IID_IDirectMusicTrack, (void**)&pIDMTrack ) ) )
	{
		hr = pSegment->InsertTrack( pIDMTrack, 1 );
		RELEASE( pIDMTrack );
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetChordList

IStream* CDirectMusicPattern::GetChordList( void )
{
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	IStream* pIMemStream = NULL;
	BOOL fFoundChordList = FALSE;
    MMCKINFO ckMain;
    MMCKINFO ck;
	HRESULT hr;

	// Get a memory stream
	hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get a RIFF stream
	hr = AllocRIFFStream( pIMemStream, &pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save the Pattern design data
	hr = DM_SavePatternEditInfo( pIRiffStream );
	if( hr != S_OK )
	{
		goto ON_ERROR;
	}

	// Reposition to beginning of stream
	LARGE_INTEGER liTemp;
	liTemp.QuadPart = 0;
	pIMemStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

	// Find the Chord list
	ckMain.fccType = DMUS_FOURCC_PATTERN_DESIGN;
	if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
	{
		ck.fccType = DMUS_FOURCC_CHORDSTRIP_LIST;
		if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDLIST ) == 0 )
		{
			// Fix 19549: Check to see if the chord list's key and scale are 0.
			// If so, change them to 0x0C and 0xAB5AB5.
			DWORD dwPosition = StreamTell( pIMemStream );
			ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
			if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
				if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
				{
					DWORD dwScalePos = StreamTell( pIMemStream );
					DWORD dwScale, dwBytes;
					if( (pIMemStream->Read(&dwScale, sizeof(DWORD), &dwBytes) == S_OK)
					&&	(dwBytes == sizeof(DWORD))
					&&	(dwScale == 0) )
					{
						VERIFY( SUCCEEDED( StreamSeek( pIMemStream, dwScalePos, STREAM_SEEK_SET) ) );
						// Default key and scale from Chord strip
						// (different from m_bDefaultKeyRoot and m_dwDefaultKeyPattern)
						dwScale = 0x0CAB5AB5;
						VERIFY( SUCCEEDED( pIMemStream->Write(&dwScale, sizeof(DWORD), &dwBytes) ) );
					}
				}
			}

			VERIFY( SUCCEEDED( StreamSeek( pIMemStream, dwPosition, STREAM_SEEK_SET) ) );
			fFoundChordList = TRUE;
		}
	}

ON_ERROR:
	RELEASE( pIRiffStream );

	if( fFoundChordList == FALSE )
	{
		RELEASE( pIMemStream );
	}

	return pIMemStream;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::UpdateChordTrack

HRESULT CDirectMusicPattern::UpdateChordTrack( IDirectMusicSegment *pSegment )
{
	if( pSegment == NULL )
	{
		return E_POINTER;
	}

	// Get the Chord list
	IStream* pIStream = GetChordList();
	if( pIStream == NULL )
	{
		DMUS_CHORD_PARAM chordData;

		wcscpy( chordData.wszName, L"M7" );
		chordData.wMeasure = 0;
		chordData.bBeat = 0;
		chordData.bKey = m_bDefaultKeyRoot;
		chordData.dwScale = m_dwDefaultKeyPattern;
		chordData.bSubChordCount = 4;
		chordData.SubChordList[0].dwChordPattern = m_dwDefaultChordPattern;
		chordData.SubChordList[0].dwScalePattern = m_dwDefaultKeyPattern;
		chordData.SubChordList[0].dwInversionPoints = 0xffffffff; // default: inversions everywhere
		chordData.SubChordList[0].dwLevels = 0xffffff01;			// default: match everything above level 16 and level 0
		chordData.SubChordList[0].bChordRoot = m_bDefaultChordRoot;
		chordData.SubChordList[0].bScaleRoot = m_bDefaultKeyRoot;
		chordData.SubChordList[1] = chordData.SubChordList[0];
		chordData.SubChordList[1].dwLevels = 0x00000002;			// level 1
		chordData.SubChordList[2] = chordData.SubChordList[0];
		chordData.SubChordList[2].dwLevels = 0x00000004;			// level 2
		chordData.SubChordList[3] = chordData.SubChordList[0];
		chordData.SubChordList[3].dwLevels = 0x00000008;			// level 3

		return ChangeChord( &chordData, pSegment );
	}

	IDirectMusicTrack* pIDMTrack = NULL;
	IPersistStream* pIPersistStreamTrack = NULL;

	HRESULT hr = E_FAIL;

	// Get the DirectMusic Chord track
	hr = pSegment->GetTrack( CLSID_DirectMusicChordTrack, 1, 0, &pIDMTrack );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Load Chords into DirectMusic Chord track
	hr = pIDMTrack->QueryInterface( IID_IPersistStream, (void**)&pIPersistStreamTrack );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}
	hr = pIPersistStreamTrack->Load( pIStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIDMTrack );
	RELEASE( pIStream );
	RELEASE( pIPersistStreamTrack );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::ChangeChord

HRESULT CDirectMusicPattern::ChangeChord( DMUS_CHORD_PARAM* pChordData, IDirectMusicSegment *pSegment )
{
	if( pSegment == NULL )
	{
		return E_POINTER;
	}

	IDirectMusicTrack* pIDMTrack;

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pSegment->GetTrack( CLSID_DirectMusicChordTrack, 1, 0, &pIDMTrack ) ) )
	{
		hr = pIDMTrack->SetParam( GUID_ChordParam, 0, pChordData );

		RELEASE( pIDMTrack );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SyncPatternWithAuditionSegment

HRESULT CDirectMusicPattern::SyncPatternWithAuditionSegment( BOOL fFirstTime, IDirectMusicSegment *pSegment )
{
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	if( pSegment == NULL )
	{
		return S_OK;
	}

	// Set segment length and repeats
	pSegment->SetLength( m_dwLength );
	pSegment->SetLoopPoints( 0, 0 ); // Repeat entire segment
	pSegment->SetRepeats( DMUS_SEG_REPEAT_INFINITE );

	// Get active track and active variations
	long lTrack = -1;
	DWORD dwVariations = 0xFFFFFFFF;
	GUID guidPart = GUID_NULL;
	BOOL fHaveTrack = FALSE;
	BOOL fHaveVariations = FALSE;
	BOOL fHaveGUID = FALSE;

	if( m_pPatternCtrl
	&&  m_pPatternCtrl->m_pPatternDlg
	&&  m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
	{
		VARIANT var;
		
		if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_ACTIVESTRIP, &var )))
		{
			IUnknown* pIUnknown = V_UNKNOWN(&var);
			if( pIUnknown )
			{
				IDMUSProdStrip* pIStrip;
				if( SUCCEEDED( pIUnknown->QueryInterface( IID_IDMUSProdStrip, (void**)&pIStrip )))
				{
					if( SUCCEEDED( pIStrip->GetStripProperty( MSP_PIANOROLL_VARIATIONS, &var )))
					{
						fHaveVariations = TRUE;
						dwVariations = V_UI4(&var);
					}

					if( SUCCEEDED( pIStrip->GetStripProperty( MSP_PIANOROLL_TRACK, &var )))
					{
						fHaveTrack = TRUE;
						lTrack = V_I4(&var);
					}

					var.vt = VT_BYREF;
					V_BYREF(&var) = &guidPart;
					if( SUCCEEDED( pIStrip->GetStripProperty( MSP_PIANOROLL_GUID, &var )))
					{
						fHaveGUID = TRUE;
					}

					RELEASE( pIStrip );
				}

				RELEASE( pIUnknown );
			}
		}
	}

	IDirectMusicTrack* pIDMTrack;
	IPrivatePatternTrack* pIDMPrivatePatternTrack;
	IStream* pIMemStream;

	// Update Chord track
	UpdateChordTrack( pSegment );

	// Update Pattern Track
	if( SUCCEEDED ( pSegment->GetTrack( CLSID_DirectMusicPatternTrack, 1, 0, &pIDMTrack ) ) )
	{
		if( SUCCEEDED ( pIDMTrack->QueryInterface( IID_IPrivatePatternTrack, (void **)&pIDMPrivatePatternTrack ) ) )
		{
			// Set variation/track
			if( fFirstTime
			||  fHaveTrack
			||  fHaveVariations )
			{
				IPrivatePatternTrack9* pIDMPrivatePatternTrack9;
				if( SUCCEEDED ( pIDMTrack->QueryInterface( IID_IPrivatePatternTrack9, (void **)&pIDMPrivatePatternTrack9 ) ) )
				{
					// If no variations are selected, then pass GUID_AllZeros
					pIDMPrivatePatternTrack9->SetVariationMaskByGUID( m_pIDMSegmentState, dwVariations, dwVariations ? guidPart : GUID_AllZeros, lTrack );

					RELEASE( pIDMPrivatePatternTrack9 );
				}
				else
				{
					pIDMPrivatePatternTrack->SetVariationByGUID( m_pIDMSegmentState, dwVariations, guidPart, lTrack );
				}
			}

			// Set Pattern/Motif
			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_SinglePattern, &pIMemStream ) ) )
			{
				if( SUCCEEDED ( Save( pIMemStream, FALSE ) ) )
				{
					DWORD dwLength;

					pIDMPrivatePatternTrack->SetPattern( m_pIDMSegmentState, pIMemStream, &dwLength ); 
				}

				RELEASE( pIMemStream );
			}

			RELEASE( pIDMPrivatePatternTrack );
		}
		
		RELEASE( pIDMTrack );
	}

	// Invalidate queued events when chord strip has changed
	if( m_pPatternCtrl
	&&  m_pPatternCtrl->m_pPatternDlg
	&&  m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr )
	{
		BOOL fChordStripChanged = FALSE;

		m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->GetParam( GUID_ChordStripChanged, 0, NULL, &fChordStripChanged );
		if( fChordStripChanged )
		{
			MUSIC_TIME mtTimeNow;
			theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtTimeNow );
			theApp.m_pStyleComponent->m_pIDMPerformance->Invalidate( mtTimeNow, 0 );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::CreateSegment

HRESULT CDirectMusicPattern::CreateSegment( BOOL fNeedBandTrack )
{
	ASSERT( m_pIDMSegment == NULL );

	ASSERT( m_pStyle != NULL );
	ASSERT( m_pStyle->m_pIDMStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	IDirectMusicPatternTrack* pIDMPatternTrack;

	// Create the pattern track object
	HRESULT hr = ::CoCreateInstance( CLSID_DirectMusicPatternTrack, NULL, CLSCTX_INPROC, 
								 	 IID_IDirectMusicPatternTrack, (void**)&pIDMPatternTrack );
	if( SUCCEEDED ( hr ) )
	{
		// Create a segment for the pattern track
		hr = pIDMPatternTrack->CreateSegment( m_pStyle->m_pIDMStyle, &m_pIDMSegment );
		if( SUCCEEDED ( hr ) )
		{
			// Mark this segment as a Pattern audition segment
			IDirectMusicObject *pIDirectMusicObject = NULL;
			if( SUCCEEDED( m_pIDMSegment->QueryInterface( IID_IDirectMusicObject, (void **)&pIDirectMusicObject ) ) )
			{
				DMUS_OBJECTDESC objDesc;
				objDesc.dwSize = sizeof( DMUS_OBJECTDESC );
				objDesc.dwValidData = DMUS_OBJ_OBJECT;
				objDesc.guidObject = GUID_PatternAuditionSegment;
				pIDirectMusicObject->SetDescriptor( &objDesc );
				pIDirectMusicObject->Release();
			}

			// Insert a Band track when needed
			hr = InsertBandTrack( m_pIDMSegment, fNeedBandTrack );

			if( SUCCEEDED ( hr )  )
			{
				// Prepare the rest of the Segment
				if( SUCCEEDED ( InsertChordTrack( m_pIDMSegment ) )
				&&  SUCCEEDED ( SyncPatternWithAuditionSegment( TRUE, m_pIDMSegment ) ) )
				{
					// Disable tempo track so that repeats do not reset tempo
					IDirectMusicTrack* pIDMTrack;
					if( SUCCEEDED ( m_pIDMSegment->GetTrack( CLSID_DirectMusicTempoTrack, 1, 0, &pIDMTrack ) ) )
					{
						pIDMTrack->SetParam( GUID_DisableTempo, 0, NULL );

						RELEASE( pIDMTrack );
					}

					m_pIDMSegment->SetDefaultResolution( m_wEmbellishment & EMB_MOTIF ? m_dwResolution : DMUS_SEGF_BEAT );
				}
				else
				{
					hr = E_FAIL;
				}
			}
		}

		RELEASE( pIDMPatternTrack );
	}
	return hr;
}

HRESULT CDirectMusicPattern::Initialize1()
// initialize state
{
	ASSERT( m_pRhythmMap == NULL );

	// Initialize rhythm map
	m_pRhythmMap = new DWORD[m_wNbrMeasures];
	if( m_pRhythmMap == NULL )
	{
		return E_OUTOFMEMORY;
	}

	for( int i = 0 ;  i < m_wNbrMeasures ;  i++ )
	{
		if( i )
		{
			m_pRhythmMap[i] = 0;
		}
		else
		{
			m_pRhythmMap[i] = 1;
		}
	}
	return S_OK;
}

HRESULT CDirectMusicPattern::Initialize2()
{
	// Create an empty Part
	CDirectMusicPart* pPart = m_pStyle->AllocPart();
	if( pPart == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Create a Part Reference
	CDirectMusicPartRef* pPartRef = AllocPartRef();
	if( pPartRef == NULL )
	{
		m_pStyle->DeletePart( pPart );
		return E_OUTOFMEMORY;
	}

	pPartRef->SetPart( pPart );

	return S_OK;
}


CDirectMusicEventItem* CDirectMusicPattern::MakeDirectMusicEventItem(FullSeqEvent* pEvent)
{
	ASSERT(pEvent);
	if(!pEvent)
	{
		return 0;
	}

	CDirectMusicEventItem* pItem = 0;
	CDirectMusicStyleNote* pNote = 0;
	CDirectMusicStyleCurve* pCurve = 0;

	long lBeatClocks, lMeasureClocks, lGridClocks;
	lBeatClocks = DM_PPQNx4 / m_TimeSignature.m_bBeat;
	lMeasureClocks = lBeatClocks * m_TimeSignature.m_bBeatsPerMeasure;
	lGridClocks = lBeatClocks / m_TimeSignature.m_wGridsPerBeat;

	switch(pEvent->bStatus&0xF0)
	{
	case MIDI_NOTEON:
		pNote = new CDirectMusicStyleNote;
		pNote->m_mtDuration = pEvent->mtDuration;
		pNote->m_bVelocity = pEvent->bByte2;
		pNote->m_bTimeRange = pNote->m_bDurRange = pNote->m_bVelRange = 0;
		pNote->m_bInversionId = 0;
		pNote->m_bNoteFlags = 0;
		pNote->m_bPlayModeFlags = DMUS_PLAYMODE_NONE;
		if( pEvent->dwPChannel == 9 /* drum channel */)
		{
			pNote->m_wMusicValue = pEvent->bByte1;
		}
		else
		{
			DMUS_CHORD_KEY chord;
			ZeroMemory( &chord, sizeof( DMUS_CHORD_KEY ) );
			chord.bSubChordCount = 1;
			chord.dwScale = 0x00AB5AB5;
			//chord.bKey = 0;
			chord.SubChordList[0].dwChordPattern = m_dwDefaultChordPattern;
			chord.SubChordList[0].dwScalePattern = m_dwDefaultKeyPattern;
			chord.SubChordList[0].dwInversionPoints = 0xFFFFFFFF;
			chord.SubChordList[0].dwLevels = 0xFFFFFFFF;
			chord.SubChordList[0].bChordRoot = m_bDefaultChordRoot;
			chord.SubChordList[0].bScaleRoot = m_bDefaultKeyRoot;
			theApp.m_pStyleComponent->m_pIDMPerformance->MIDIToMusic( pEvent->bByte1, &chord,
																	  DMUS_PLAYMODE_PURPLEIZED, 0,
																	  &pNote->m_wMusicValue );
		}
		pItem = pNote;
		break;
	case MIDI_PTOUCH:
	case MIDI_CCHANGE:
	case MIDI_MTOUCH:
	case MIDI_PBEND:
		pCurve = new CDirectMusicStyleCurve;
		pCurve->m_mtDuration = 1;
		pCurve->m_bCurveShape = 	DMUS_CURVES_INSTANT;
		switch(pEvent->bStatus&0xF0)
		{
			case MIDI_PTOUCH:
				pCurve->m_bEventType = DMUS_CURVET_PATCURVE;
				pCurve->m_bCCData = pEvent->bByte1;
				pCurve->m_nStartValue = pCurve->m_nEndValue = pEvent->bByte2;
				break;
			case MIDI_CCHANGE:
				pCurve->m_bEventType = DMUS_CURVET_CCCURVE;
				pCurve->m_bCCData = pEvent->bByte1;
				pCurve->m_nStartValue = pCurve->m_nEndValue = pEvent->bByte2;
				break;
			case MIDI_MTOUCH:
				pCurve->m_bEventType = DMUS_CURVET_MATCURVE;
				pCurve->m_nStartValue = pCurve->m_nEndValue = pEvent->bByte1;
				break;
			case MIDI_PBEND:
				pCurve->m_bEventType = DMUS_CURVET_PBCURVE;
				pCurve->m_nStartValue = pCurve->m_nEndValue = ((pEvent->bByte2 & 0x7F) << 7) + (pEvent->bByte1 & 0x7F);
				break;
		}
		pItem = pCurve;
		break;
	default:
		ASSERT(FALSE);
		return 0;
	}


	pItem->m_dwVariation = 1;
	// compute offsets (imported events are not quantized)
	pItem->m_mtGridStart = (pEvent->mtTime + pEvent->nOffset) / lGridClocks ;
	pItem->m_nTimeOffset = (short)((pEvent->mtTime + pEvent->nOffset) - (long)pItem->m_mtGridStart*lGridClocks);
	return pItem;
}

DWORD CDirectMusicPartRef::GetPChannel()
{
	return m_dwPChannel;
}

void CDirectMusicPartRef::SetPChannel(DWORD pchan)
{
	m_dwPChannel = pchan;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::OldNoteToMusicValue

/*
unsigned short CDirectMusicPattern::OldNoteToMusicValue(

unsigned char note,     // MIDI note to convert.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
unsigned char   octpart = 0 ;
unsigned char   chordpart ;
unsigned char   keypart = (BYTE)-1 ;       
unsigned char   accpart = 0 ;
unsigned char   scan, test, base, last ;    // was char
long            pattern ;
short           testa, testb ;


    scan = chordroot ;

	// If we're trying to play a note below the bottom of our chord, forget it
	if( note < scan)
	{
		return 0;
	}

    while( scan < (note - 24) )
    {
        scan += 12 ;
        octpart++ ;
    }

    base = scan ;

    for( ;  base<=note ;  base+=12 )
    {
        chordpart = (unsigned char)-1 ;
        pattern   = chordpattern ;
        scan      = last = base ;
        if( scan == note )
            return( unsigned short (octpart << 12) ) ;           // if octave, return.
        for( ;  pattern ;  pattern=pattern >> 1 )
        {
            if( pattern & 1 )                   // chord interval?
            {                 
                if( scan == note )              // note in chord?
                {            
                    chordpart++ ;
                    return(unsigned short ((octpart << 12) | (chordpart << 8))) ; // yes, return.
                }
                else if (scan > note)           // above note?
                {         
                    test = scan ;
                    break ;                     // go on to key.
                }
                chordpart++ ;
                last = scan ;
            }
            scan++ ;
        }
        if( !pattern )                          // end of chord.
        {                        
            test = unsigned char(base + 12) ;                  // set to next note.
        }
        octpart++ ;
        if( test > note )
        {
            break ;                             // above our note?
        }
    }

    octpart-- ;

//  To get here, the note is not in the chord.  Scan should show the last
//  note in the chord.  octpart and chordpart have their final values.
//  Now, increment up the key to find the match.

    scan        = last ;
    keypattern |= keypattern << 12 ;
    keypattern  = keypattern >> ((scan - keyroot) % 12) ;

    for( ;  keypattern ;  keypattern=keypattern >> 1 )
    {
        if( 1 & keypattern )
        {
            keypart++ ;
            accpart = 0 ;
        }
        else
        {
            accpart++ ;
        }
        if( scan == note )
            break ;
        scan++;
    }

    if( accpart && keypart )
    {
        testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);
        testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);
        testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                     chordpattern, chordroot, (char)0 );
        testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
                                     chordpattern, chordroot, (char)0 );
        if( testa == testb )
        {
            chordpart++ ;
            keypart = 0 ;
            accpart = 15 ;
        }
    }

    return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart);

}
*/

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::OldMusicValueToNote

/*
unsigned char CDirectMusicPattern::OldMusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot,         // Root note of chord.
char count)             // Total notes in chord.

{
unsigned char   result ;
char            octpart   = (char)(value >> 12) ;
char            chordpart = (char)((value >> 8) & 0xF) ;
char            keypart   = (char)((value >> 4) & 0xF) ;
char            accpart   = (char)(value & 0xF) ;
unsigned char   bits      = (unsigned char) (count & 0xF0) ;

    count  &= CHORD_COUNT ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    if( count ) {
        if( bits & CHORD_FOUR ) {
            if( count > 4 )
                chordpart += (count - 4) ;
        } else {
            if( count > 3 )
                chordpart += (count - 3) ;
        }
    }

//    if( chordpart ) {
        for( ;  chordpattern ;  result++ ) {
            if( chordpattern & 1L ) {
                if( !chordpart )
                    break ;
                chordpart-- ;
            }
            chordpattern = chordpattern >> 1L ;
            if( !chordpattern ) {
                if( !scalevalue )
                    return( 0 ) ;
                result  = unsigned char(12 * octpart) ;
                result += chordroot ;
                keypart = char(scalevalue >> 4) ;
                accpart = char(scalevalue & 0x0F) ;
                break ;
            }
        }
//    }

    if( keypart ) {
        keypattern |= (keypattern << 12L) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}
*/


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::ActivateDialog

void CDirectMusicPattern::ActivateDialog( BOOL fActivate )
{
	m_fDialogActive = fActivate;

	if( m_fDialogActive )
	{
		MUSIC_TIME mtNow;
		if( SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtNow ) ) )
		{
			IDirectMusicSegmentState *pSegmentState = NULL;
			if( FAILED( theApp.m_pStyleComponent->m_pIDMPerformance->GetSegmentState( &pSegmentState, mtNow ) ) )
			{
				// Play the active band
				PlayBand();
			}
			else
			{
				if( pSegmentState )
				{
					pSegmentState->Release();
				}
			}
		}
	}

	if( m_fRecordPressed )
	{
		if( m_pPatternCtrl && m_pPatternCtrl->m_pPatternDlg
		&&	m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr )
		{
			IMIDIMgr* pIMIDIMgr;
			if( SUCCEEDED ( m_pPatternCtrl->m_pPatternDlg->m_punkMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr) ) )
			{
				// If dialog active - tell MIDIMgr Record is pressed
				// If dialog inactive - tell MIDIMgr Record is no longer pressed
				pIMIDIMgr->OnRecord( m_fDialogActive );
				pIMIDIMgr->Release();
			}
		}
	}

	if( m_pPatternCtrl && m_pPatternCtrl->m_pPatternDlg )
	{
		m_pPatternCtrl->m_pPatternDlg->Activate( fActivate );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PreChangePartRef

void CDirectMusicPattern::PreChangePartRef( CDirectMusicPartRef* pDMPartRef )
{
	ASSERT( m_pStyle );
	m_pStyle->PreChangePartRef( pDMPartRef );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::UpdateLinkedParts

void CDirectMusicPattern::UpdateLinkedParts( CDirectMusicPartRef* pPartRef, LPCTSTR pcstrText )
{
	CDirectMusicPartRef* pPartRefList;
	POSITION pos = m_lstPartRefs.GetHeadPosition();
	BOOL fChange = FALSE;

	while( pos )
	{
		pPartRefList = m_lstPartRefs.GetNext( pos );

		if( pPartRefList->m_pDMPart && pPartRefList->m_fHardLink &&
		    (pPartRefList->m_pDMPart != pPartRef->m_pDMPart) )
		{
			if( ::IsEqualGUID( pPartRefList->m_pDMPart->m_guidPartID, pPartRef->m_guidOldPartID ) )
			{
				fChange = TRUE;
			}
		}
	}
	if( fChange )
	{
		// Save "Undo" state
		if( pcstrText )
		{
			m_pUndoMgr->SaveState( this, (char *)pcstrText );
		}
		else
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_PART );
		}

		pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			pPartRefList = m_lstPartRefs.GetNext( pos );

			if( pPartRefList->m_pDMPart && pPartRefList->m_fHardLink &&
				(pPartRefList->m_pDMPart != pPartRef->m_pDMPart) )
			{
				if( ::IsEqualGUID( pPartRefList->m_pDMPart->m_guidPartID, pPartRef->m_guidOldPartID ) )
				{
					pPartRefList->SetPart( pPartRef->m_pDMPart );
				}
			}
		}
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::UpdateLinkFlags

void CDirectMusicPattern::UpdateLinkFlags()
{
	CDirectMusicPartRef* pPartRefList;
	POSITION pos = m_lstPartRefs.GetHeadPosition();
	BOOL fChange = FALSE;

	while( pos )
	{
		pPartRefList = m_lstPartRefs.GetNext( pos );

		if( pPartRefList->m_pDMPart && pPartRefList->m_fHardLink &&
		    (pPartRefList->m_pDMPart->m_dwHardLinkCount == 1) )
		{
			fChange = TRUE;
		}
	}

	if( fChange )
	{
		// Save "Undo" state
		//  Don't save an undo state - this is a side effect
		//m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_PART_UNLINK );

		pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			pPartRefList = m_lstPartRefs.GetNext( pos );

			if( pPartRefList->m_pDMPart && pPartRefList->m_fHardLink &&
				(pPartRefList->m_pDMPart->m_dwHardLinkCount == 1) )
			{
				pPartRefList->m_fHardLink = FALSE;
				pPartRefList->m_pDMPart->m_dwHardLinkCount = 0;
			}
		}
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::StartStopMusic

void CDirectMusicPattern::StartStopMusic( BOOL fStart, BOOL fInTransition )
{
	// If our start/stop state changed, or if we're in transition
	if( (fStart != m_fPatternIsPlaying) || fInTransition )
	{
		m_fPatternIsPlaying = fStart;

		if( !fStart && m_pIDMSegmentState )
		{
			m_rpIDMStoppedSegmentState = m_pIDMSegmentState;
			RELEASE( m_pIDMSegment );
			RELEASE( m_pIDMSegmentState );
			RELEASE( m_pIDMTransitionSegmentState );
			RELEASE( m_pIDMTransitionSegment );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::UpdateMIDIMgrsAndChangePartPtrs

void CDirectMusicPattern::UpdateMIDIMgrsAndChangePartPtrs( CDirectMusicPart* pOldPart, CDirectMusicPart* pNewPart, LPCTSTR pcstrText )
{
	ASSERT( pOldPart );
	ASSERT( pNewPart );

	CDirectMusicPartRef* pPartRefList;
	POSITION pos = m_lstPartRefs.GetHeadPosition();
	BOOL fChange = FALSE;

	while( pos )
	{
		pPartRefList = m_lstPartRefs.GetNext( pos );

		if( pPartRefList->m_fHardLink && (pPartRefList->m_pDMPart == pOldPart) )
		{

			fChange = TRUE;
		}
	}

	if( fChange )
	{
		// Save "Undo" state
		if( pcstrText )
		{
			m_pUndoMgr->SaveState( this, (char *)pcstrText );
		}
		else
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_PART );
		}

		pos = m_lstPartRefs.GetHeadPosition();
		while( pos )
		{
			pPartRefList = m_lstPartRefs.GetNext( pos );

			if( pPartRefList->m_fHardLink && (pPartRefList->m_pDMPart == pOldPart) )
			{
				pPartRefList->SetPart( pNewPart );
			}
		}
		
		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::CopyToForLinkAllParts

HRESULT CDirectMusicPattern::CopyToForLinkAllParts( CDirectMusicPattern* pPattern )
{
	pPattern->m_dwDefaultKeyPattern		= m_dwDefaultKeyPattern;	
	pPattern->m_dwDefaultChordPattern	= m_dwDefaultChordPattern;
	pPattern->m_bDefaultKeyRoot			= m_bDefaultKeyRoot;		
	pPattern->m_bDefaultChordRoot		= m_bDefaultChordRoot;	

	pPattern->m_TimeSignature		= m_TimeSignature;
	pPattern->m_wNbrMeasures		= m_wNbrMeasures;
	pPattern->m_dwLength			= m_dwLength;
	pPattern->m_bGrooveBottom		= m_bGrooveBottom;
	pPattern->m_bGrooveTop			= m_bGrooveTop;
	pPattern->m_bDestGrooveBottom	= m_bDestGrooveBottom;
	pPattern->m_bDestGrooveTop		= m_bDestGrooveTop;
	pPattern->m_dwFlags				= m_dwFlags;

	// Initialize rhythm map
	pPattern->m_pRhythmMap = new DWORD[pPattern->m_wNbrMeasures];
	if( pPattern->m_pRhythmMap == NULL )
	{
		return E_OUTOFMEMORY;
	}
	for( int i = 0 ;  i < pPattern->m_wNbrMeasures ;  i++ )
	{
		if( pPattern->m_wEmbellishment & EMB_MOTIF )
		{
			if( i )
			{
				pPattern->m_pRhythmMap[i] = 0;
			}
			else
			{
				pPattern->m_pRhythmMap[i] = 1;
			}
		}
		else
		{
			pPattern->m_pRhythmMap[i] = m_pRhythmMap[i];
		}
	}

	// Copy UI state and Chords for Composition
	if( pPattern->m_pPatternDesignData )
	{
		GlobalFree( pPattern->m_pPatternDesignData );
		pPattern->m_pPatternDesignData = NULL;
	}
	pPattern->m_pPatternDesignData = (BYTE *)GlobalAlloc( GPTR, m_dwPatternDesignDataSize );
	if( pPattern->m_pPatternDesignData )
	{
		pPattern->m_dwPatternDesignDataSize = m_dwPatternDesignDataSize;
		memcpy( pPattern->m_pPatternDesignData, m_pPatternDesignData, m_dwPatternDesignDataSize );  
	}

	// Motif specific data
	if( pPattern->m_wEmbellishment & EMB_MOTIF
	&&  m_wEmbellishment & EMB_MOTIF )
	{
		pPattern->m_dwRepeats		= m_dwRepeats;
		pPattern->m_mtPlayStart		= m_mtPlayStart;
		pPattern->m_mtLoopStart		= m_mtLoopStart;
		pPattern->m_mtLoopEnd		= m_mtLoopEnd;
		pPattern->m_dwResolution	= m_dwResolution;

		if( m_pIBandNode )
		{
			IStream* pIMemStream;

			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream ) ) )
			{
				IPersistStream* pIPersistStream;

				if( SUCCEEDED ( m_pIBandNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
				{
					if( SUCCEEDED ( pIPersistStream->Save( pIMemStream, FALSE ) ) )
					{
						IDMUSProdRIFFExt* pIRIFFExt;

						if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
						{
							IDMUSProdNode* pINode;

							StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
							if( SUCCEEDED ( pIRIFFExt->LoadRIFFChunk( pIMemStream, &pINode ) ) )
							{
								ASSERT( pPattern->m_pIBandNode == NULL );
								pPattern->m_pIBandNode = pINode;
							}

							RELEASE( pIRIFFExt );
						}
					}

					RELEASE( pIPersistStream );
				}

				RELEASE( pIMemStream );
			}
		}
	}

	// Pattern specific data
	if( !(pPattern->m_wEmbellishment & EMB_MOTIF)
	&&  !(m_wEmbellishment & EMB_MOTIF) )
	{
		pPattern->m_wEmbellishment	= m_wEmbellishment;
	}

	// Link all Parts
	CDirectMusicPartRef *pPartRefList;
	CDirectMusicPartRef *pPartRef;

	POSITION pos = m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		pPartRefList = m_lstPartRefs.GetNext( pos );

		pPartRef = new CDirectMusicPartRef( pPattern );
		if( pPartRef )
		{
			// Copy pertinent information from the original PartRef
			// and link to the original PartRef's Part
			if( SUCCEEDED ( pPartRefList->LinkParts( pPartRef ) ) )
			{
				// Add to Motif's PartRef list
				pPattern->m_lstPartRefs.AddTail( pPartRef );
			}
			else
			{
				delete pPartRef;
			}
		}
	}

	pPattern->SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::QueueTempoEvent

HRESULT CDirectMusicPattern::QueueTempoEvent()
{
	DMUS_TEMPO_PMSG* pTempo;
	if( SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
		(DMUS_PMSG**)&pTempo ) ) )
	{
		// Queue tempo event
		ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
		pTempo->dblTempo = m_pStyle->m_dblTempo;
		pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
		pTempo->dwType = DMUS_PMSGT_TEMPO;

		// Make it play when our SegmentState starts playing
		REFERENCE_TIME rtStartTime = 0;
		if( m_pIDMSegmentState )
		{
			MUSIC_TIME mtStartTime = 0;
			m_pIDMSegmentState->GetStartTime( &mtStartTime );
			theApp.m_pStyleComponent->m_pIDMPerformance->MusicToReferenceTime( mtStartTime, &rtStartTime );
			rtStartTime -= 10000;
		}
		pTempo->rtTime = rtStartTime;

		return theApp.m_pStyleComponent->m_pIDMPerformance->SendPMsg( (DMUS_PMSG*)pTempo );
	}
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::GetActiveBand

IDMUSProdNode* CDirectMusicPattern::GetActiveBand( void )
{
	IDMUSProdNode* pIBandNode = NULL;

	// Determine which band to use
	if( m_wEmbellishment & EMB_MOTIF )
	{
		// Use motif's band
		pIBandNode = m_pIBandNode;
	}
	
	if( pIBandNode == NULL )
	{
		pIBandNode = m_pStyle->GetActiveBand();
		if( pIBandNode == NULL )
		{
			pIBandNode = m_pStyle->GetTheDefaultBand();
		}
	}

	return pIBandNode;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PasteCF_BAND

HRESULT CDirectMusicPattern::PasteCF_BAND( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have Bands
		return E_FAIL;
	}

	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfBand, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Band
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PasteCF_BANDLIST

HRESULT CDirectMusicPattern::PasteCF_BANDLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have Bands
		return E_FAIL;
	}

	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfBandList, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::LoadCF_BANDTRACK

HRESULT CDirectMusicPattern::LoadCF_BANDTRACK( IStream* pIStream )
{
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have Bands
		return E_FAIL;
	}

	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;
	BOOL fFinished = FALSE;

	// Create a RIFF stream
	IDMUSProdRIFFStream* pIRiffStream;
	if( SUCCEEDED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		MMCKINFO ckMain;
		MMCKINFO ckList;

		// Look for the list of Bands in the RIFF stream
		ckMain.fccType = DMUS_FOURCC_BANDS_LIST;
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
		{
			while( pIRiffStream->Descend( &ckList, &ckMain, 0 ) == 0 )
			{
				if( fFinished )
				{
					break;
				}

				switch( ckList.ckid )
				{
					case FOURCC_LIST :
						switch( ckList.fccType )
						{
							case DMUS_FOURCC_BAND_LIST:
							{
								MMCKINFO ck;

								// Extract the first Band and attach it to the Motif
								while( pIRiffStream->Descend( &ck, &ckList, 0 ) == 0 )
								{
									if( fFinished )
									{
										break;
									}

									switch( ck.ckid )
									{
										case FOURCC_RIFF:
											switch( ck.fccType )
											{
												case DMUS_FOURCC_BAND_FORM:
												{
													StreamSeek( pIStream, -12, STREAM_SEEK_CUR );

													// Create and load a new Band
													IDMUSProdRIFFExt* pIRIFFExt;
													IDMUSProdNode* pINode;

													if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
													{
														if( SUCCEEDED ( pIRIFFExt->LoadRIFFChunk( pIStream, &pINode ) ) )
														{
															// We were able to paste something so return S_OK
															hr = S_OK;

															InsertChildNode( pINode );
															fFinished = TRUE;

															RELEASE( pINode );
														}

														RELEASE( pIRIFFExt );
													}
													break;
												}
											}
									}

									pIRiffStream->Ascend( &ck, 0 );
								}
								break;
							}
						}
						break;
				}

				pIRiffStream->Ascend( &ckList, 0 );
			}
		}

		RELEASE( pIRiffStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PasteCF_BANDTRACK

HRESULT CDirectMusicPattern::PasteCF_BANDTRACK( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have Bands
		return E_FAIL;
	}

	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		hr = LoadCF_BANDTRACK( pIStream );

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PasteCF_TIMELINE

HRESULT CDirectMusicPattern::PasteCF_TIMELINE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Pattern nodes do not have Bands
		return E_FAIL;
	}

	if( pDataObject == NULL 
	||  pIDataObject == NULL ) 
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
	{
		IStream* pIStream;

		if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline, &pIStream ) ) )
		{
			// Create a RIFF stream
			IDMUSProdRIFFStream* pIRiffStream;
			if( SUCCEEDED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				MMCKINFO ck1;
				MMCKINFO ck2;

				ck1.fccType = FOURCC_TIMELINE_LIST;
				if( pIRiffStream->Descend( &ck1, NULL, MMIO_FINDLIST ) == 0 )
				{
					ck2.fccType = FOURCC_TIMELINE_CLIPBOARD;
					while( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDLIST ) == 0 )
					{
						ck2.ckid = FOURCC_TIMELINE_CLIP_NAME;
						if( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDCHUNK ) == 0 )
						{
							DWORD dwSize;
							DWORD dwBytesRead;
							TCHAR achText[MAX_PATH];

							memset( achText, 0, sizeof( achText ) );

							dwSize = min( ck2.cksize, MAX_PATH );
							if( SUCCEEDED ( pIStream->Read( achText, dwSize, &dwBytesRead ) ) 
							&&  dwBytesRead == dwSize )
							{
								if( ::RegisterClipboardFormat(achText) == theApp.m_pStyleComponent->m_cfBandTrack )
								{
									pIRiffStream->Ascend( &ck2, 0 );

									// Handle CF_BANDTRACK format
									ck2.ckid = FOURCC_TIMELINE_CLIP_DATA;
									if( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDCHUNK ) == 0 )
									{
										hr = LoadCF_BANDTRACK( pIStream );
									}
									break;
								}
							}
						}

						pIRiffStream->Ascend( &ck2, 0 );
					}
				}

				RELEASE( pIRiffStream );
			}

			RELEASE( pIStream );
		}
	}

	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SendChangeNotification

void CDirectMusicPattern::SendChangeNotification( void )
{
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		// Only send notifications for Motifs
		return;
	}

	// Notify connected nodes that Motif has changed
	DMUSProdMotifData	mtfData;
	WCHAR				wstrMotifName[MAX_PATH];

	MultiByteToWideChar( CP_ACP, 0, m_strName, -1, wstrMotifName, MAX_PATH );
	mtfData.pwszMotifName = wstrMotifName;
	mtfData.pwszOldMotifName = NULL;
	
	theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( m_pStyle, STYLE_MotifChanged, &mtfData );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SetFlags

void CDirectMusicPattern::SetFlags( DWORD dwFlags )
{
	ASSERT( m_pStyle != NULL );

	if( dwFlags != m_dwFlags )
	{
		// Save "Undo" state
		m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_PATTERN_FLAGS );

		// Change flags
		m_dwFlags = dwFlags; 

		SetModified( TRUE );
		m_pStyle->SyncStyleEditor( m_wEmbellishment & EMB_MOTIF ? SSE_MOTIFS : SSE_PATTERNS );
		SyncPatternWithMidiStripMgr();
		SyncPatternWithDirectMusic();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::PreDeleteCleanup

void CDirectMusicPattern::PreDeleteCleanup( void )
{
	// See if we need to deal with link flags or the var. choices window
	POSITION pos = m_lstPartRefs.GetHeadPosition();
	while( pos )
	{
		CDirectMusicPartRef* pDMPartRef = m_lstPartRefs.GetNext( pos );

		if( pDMPartRef->m_pDMPart
		&&	(pDMPartRef->m_pDMPart->m_pVarChoicesPartRef == pDMPartRef) )
		{
			// Close the variation choices dialog
			if( pDMPartRef->m_pDMPart->m_pVarChoicesNode )
			{
				HWND hWndEditor;
				pDMPartRef->m_pDMPart->m_pVarChoicesNode->GetEditorWindow( &hWndEditor );
				if( hWndEditor )
				{
					theApp.m_pStyleComponent->m_pIFramework->CloseEditor( pDMPartRef->m_pDMPart->m_pVarChoicesNode );
				}
				RELEASE( pDMPartRef->m_pDMPart->m_pVarChoicesNode );
			}
			pDMPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::SyncTimelineSettings

void CDirectMusicPattern::SyncTimelineSettings( void )
{
	if( !m_fIgnoreTimelineSync
	&&	m_pPatternCtrl
	&&	m_pPatternCtrl->m_pPatternDlg
	&&	m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
	{
		VARIANT var;
		if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_ZOOM, &var ) ) )
		{
			m_dblZoom = V_R8(&var);
		}

		if( (m_dblZoom > 0.0)
		&&	SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			m_dblHorizontalScroll = V_I4(&var) / m_dblZoom;
		}

		if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_VERTICAL_SCROLL, &var ) ) )
		{
			m_lVerticalScroll = V_I4(&var);
		}

		if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
		{
			m_tlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO)V_I4(&var);
		}

		if( SUCCEEDED( m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) )
		{
			m_lFunctionbarWidth = V_I4(&var);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Pattern.h ===
#ifndef __PATTERN_H__
#define __PATTERN_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Pattern.h : header file
//

#include <afxtempl.h>

#include "RiffStrm.h"
#include "RiffStructs.h"
#include "Timeline.h"
#include "alist.h"
#include "midifile.h"
#include "MidiStripMgr.h"
#include "Conductor.h"
#include "DllBasePropPageManager.h"
#include "StyleDesignerDLL.h"
#include "SharedPattern.h"

struct ioDMStylePartDesign;
class CDllJazzDataObject;
class CTabPatternPattern;
class CTabMotifMotif;
class CTabMotifLoop;
class CTabBoundaryFlags;
class CJazzUndoMan;
class CVarChoices;

// This expects a voiceid from 1-16
#define IMA25_VOICEID_TO_PCHANNEL( id )  ( ( id + 4 ) & 0xf )
#define PCHANNEL_TO_IMA25_VOICEID( id )  ( ( id + 12 ) & 0xf )

#define SUBCHORD_STANDARD_CHORD 1


// IMA25 Variation flags
#define VF_SCALE			0x0000007F   // Seven positions in the scale.    
#define VF_ACCIDENTAL		0x00000080   // Handles chords outside of scale. 
#define VF_MAJOR			0x00000100   // Handles major chords.            
#define VF_MINOR			0x00000200   // Handles minor chords.            
#define VF_ALL				0x00000400   // Handles all chord types.         
#define VF_TO1				0x00000800   // Handles transitions to 1 chord.  
#define VF_TO5				0x00001000   // Handles transitions to 5 chord.  
#define VF_SIMPLE			0x00002000   // Handles simple chords.  
#define VF_COMPLEX			0x00004000   // Handles complex chords.  

// Chord types for use by each instrument in a pattern
enum
{ 
	CHTYPE_NOTINITIALIZED = 0,
	CHTYPE_DRUM,		// superceded by CHTYPE_FIXED
						// no longer in Note Dialog's combo box selections
						// no longer in Pattern Dialog's combo box selections
	CHTYPE_BASS,		// scale + lower chord
	CHTYPE_UPPER,		// scale + upper chord
	CHTYPE_SCALEONLY, 	// scale, no chord
	CHTYPE_BASSMELODIC,
	CHTYPE_UPPERMELODIC,
	CHTYPE_NONE,		// Ignored on Pattern Dialog's menu selections.
	CHTYPE_FIXED
};

class CDirectMusicPattern;


typedef struct _PPGMotif
{
	_PPGMotif( void )
	{
		dwPageID = 0;
		pMotif = NULL;
	}

	DWORD					dwPageID;
	CDirectMusicPattern*	pMotif;
} PPGMotif;


typedef struct _PPGPattern
{
	_PPGPattern( void )
	{
		dwPageID = 1;
		pPattern = NULL;
	}

	DWORD					dwPageID;
	CDirectMusicPattern*	pPattern;
} PPGPattern;


//////////////////////////////////////////////////////////////////////
//  CMotifPropPageManager

class CMotifPropPageManager : public CDllBasePropPageManager 
{
friend class CTabMotifMotif;
friend class CTabMotifLoop;

public:
	CMotifPropPageManager();
	virtual ~CMotifPropPageManager();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RefreshData();

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CTabMotifMotif*			m_pTabMotif;
	CTabMotifLoop*			m_pTabLoop;
	CTabBoundaryFlags*		m_pTabBoundary;

public:
	static short			sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CPatternPropPageManager

class CPatternPropPageManager : public CDllBasePropPageManager
{
friend class CTabPatternPattern;

public:
	CPatternPropPageManager();
	virtual ~CPatternPropPageManager();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CTabPatternPattern*		m_pTabPattern;
};


/////////////////////////////////////////////////////////////////////////////
// DirectMusicTimeSig structure

struct DirectMusicTimeSig
{
	// Time signatures define how many beats per measure, which note receives
	// the beat, and the grid resolution.
	DirectMusicTimeSig() : m_bBeatsPerMeasure(0), m_bBeat(0), m_wGridsPerBeat(0) { }
	BYTE	m_bBeatsPerMeasure;		// beats per measure (top of time sig)
	BYTE	m_bBeat;				// what note receives the beat (bottom of time sig.)
									// we can assume that 0 means 256th note
	WORD	m_wGridsPerBeat;		// grids per beat
};


// Event types
#define ET_NOTE		0x01
#define ET_CURVE	0x02
#define ET_MARKER	0x03


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicEventItem class

class CDirectMusicEventItem : public AListItem
{
friend class CDirectMusicStyle;
friend class CDirectMusicPattern;
friend class CDirectMusicPart;

public:
	virtual ~CDirectMusicEventItem(); 
	CDirectMusicEventItem* GetNext() { return (CDirectMusicEventItem*) AListItem::GetNext(); }

protected:
	MUSIC_TIME	m_mtGridStart;		// Grid position in track that this event belogs to.
	short		m_nTimeOffset;		// Offset, in music time, of event from designated grid position.
	DWORD		m_dwVariation;		// variation bits
	BYTE		m_bType;			// Note or curve
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicEventList class

class CDirectMusicEventList : public AList
{
public:
	virtual ~CDirectMusicEventList()	{	CDirectMusicEventItem* pEvent;	
											while( m_pHead != NULL )
											{
												pEvent = RemoveHead();
												delete pEvent;
											}
										}
    CDirectMusicEventItem *GetHead() const { return (CDirectMusicEventItem *)AList::GetHead();};
    CDirectMusicEventItem *RemoveHead() { return (CDirectMusicEventItem *)AList::RemoveHead();};
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleNote class

class CDirectMusicStyleNote : public CDirectMusicEventItem
{
friend class CDirectMusicPattern;
friend class CDirectMusicPart;

public:
	CDirectMusicStyleNote() : m_bPlayModeFlags(0) { m_bType = ET_NOTE; }

protected:
	MUSIC_TIME	m_mtDuration;		// how long this note lasts
    WORD		m_wMusicValue;		// Position in scale.
    BYTE		m_bVelocity;		// Note velocity.
    BYTE		m_bTimeRange;		// Range to randomize start time.
    BYTE		m_bDurRange;		// Range to randomize duration.
    BYTE		m_bVelRange;		// Range to randomize velocity.
	BYTE		m_bInversionId;		// Identifies inversion group to which this note belongs
	BYTE		m_bPlayModeFlags;	// can override part ref
	BYTE        m_bNoteFlags;		// values from DMUS_NOTEF_FLAGS
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve class

class CDirectMusicStyleCurve : public CDirectMusicEventItem
{
friend class CDirectMusicStyle;
friend class CDirectMusicPattern;
friend class CDirectMusicPart;

public:
	CDirectMusicStyleCurve();

protected:
	void SetDefaultResetValues( MUSIC_TIME mtLength  );

protected:
	MUSIC_TIME	m_mtDuration;		// how long this curve lasts
	MUSIC_TIME	m_mtResetDuration;	// how long after the end of the curve to reset the curve
	short		m_nStartValue;		// curve's start value
	short		m_nEndValue;		// curve's end value
	short		m_nResetValue;		// the value to which to reset the curve 
    BYTE		m_bEventType;		// type of curve
	BYTE		m_bCurveShape;		// shape of curve
	BYTE		m_bCCData;			// CC#
	BYTE		m_bFlags;			// Bit 1=TRUE means to send nResetValue. Otherwise, don't.
									//	   Other bits are reserved. 
	WORD		m_wParamType;		// RPN or NRPN parameter number.
	WORD		m_wMergeIndex;		// Allows multiple parameters to be merged (pitchbend, volume, and expression.)
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleMarker class

class CDirectMusicStyleMarker : public CDirectMusicEventItem
{
friend class CDirectMusicPattern;
friend class CDirectMusicPart;

public:
	CDirectMusicStyleMarker();

protected:
    WORD        m_wMarkerFlags;   /* how the marker is used */
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart class

class CDirectMusicPart
{
friend class CDirectMusicStyle;
friend class CDirectMusicPattern;
friend class CDirectMusicPartRef;

public:
	CDirectMusicPart( CDirectMusicStyle* pStyle );
	~CDirectMusicPart();

public:
    HRESULT DM_LoadPart( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT DM_SavePart( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveNoteList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveCurveList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveMarkerList( IDMUSProdRIFFStream* pIRiffStream ) const;
    HRESULT DM_SavePartInfoList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT DM_SavePartDesignData( IDMUSProdRIFFStream* pIRiffStream );

	void CopyTo( CDirectMusicPart* pDMPart );
	void SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fInUndo, BOOL fStyleTimeSigChanging );
	void SetNbrMeasures( WORD wNbrMeasures );
	void UpdateFromVarChoices( IDMUSProdFramework *pFramework, IPersistStream *pIPersistStream );
	bool IsVarChoicesRowDisabled( short nRow );
	short GetVarChoicesRowType( short nRow );
	short GetVarChoicesNbrColumns( short nRow );

protected:
	CDirectMusicStyle*	  m_pStyle;
	DWORD				  m_dwUseCount;				// Nbr PartRefs using this Part
	DWORD				  m_dwHardLinkCount;		// Nbr PartRefs Hard Linked to this Part

protected:
	ioDMStylePartDesign*  m_pPartDesignData;		// UI info for Part
	DWORD				  m_dwPartDesignDataSize;	// Size of UI info

	IDMUSProdNode*		  m_pVarChoicesNode;		// Implements IDMUSProdNode for VarChoices editor
	CDirectMusicPartRef*  m_pVarChoicesPartRef;		// Part Reference for VarChoices

	CString				  m_strName;				// Part name 
	GUID				  m_guidPartID;
	DirectMusicTimeSig	  m_TimeSignature;			// can override pattern's
	WORD				  m_wNbrMeasures;			// length of the Part
	DWORD				  m_dwVariationChoices[NBR_VARIATIONS];	// MOAW choices bitfield
	BYTE	              m_bPlayModeFlags;			// see PLAYMODE flags (in ioDMStyle.h)
	BYTE				  m_bInvertUpper;			// inversion upper limit
	BYTE				  m_bInvertLower;			// inversion lower limit
	DWORD				  m_dwFlags;				// various flags
	CDirectMusicEventList m_lstEvents;				// list of events (notes, curves, etc.)
};


typedef struct PianoRollUIState
{
	void*				pPianoRollData;				// UI info for Piano Roll
	DWORD				dwPianoRollDataSize;		// Size of UI info
}	PianoRollUIState;


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef class

class CDirectMusicPartRef
{
friend class CDirectMusicPattern;
friend class CDirectMusicStyle;
friend class CDialogLinkExisting;

protected:
	void FreePianoRollStateList();

public:
	void SetPChannel(DWORD pchan);
	DWORD GetPChannel( void );
	CDirectMusicPartRef( CDirectMusicPattern* pPattern );
	~CDirectMusicPartRef();

	void SetPart( CDirectMusicPart* pPart );
	void SetName( LPCTSTR pszName );
	HRESULT LinkParts( CDirectMusicPartRef* pPartRef );

    HRESULT DM_LoadPartRef( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT DM_SavePartRef( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePartRefInfoList( IDMUSProdRIFFStream* pIRiffStream ) const;
    HRESULT DM_SavePartRefPianoRollStates( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT DM_SavePartRefDesignData( IDMUSProdRIFFStream* pIRiffStream );

public:
	CDirectMusicPattern*	m_pPattern;

protected:
	CDirectMusicPart* m_pDMPart;// the Part to which this refers
	CString m_strName;			// PartRef name 
	DWORD	m_dwPChannel;		// corresponds to port/device/midi channel
	BYTE	m_bVariationLockID; // parts with the same ID lock variations.
								// high bit is used to identify master Part
	BYTE	m_bSubChordLevel;	// tells which sub chord level this part wants
	BYTE	m_bPriority;		// Priority levels. Parts with lower priority
								// aren't played first when a device runs out of
								// notes
	BYTE	m_bRandomVariation;	// when set, matching variations play in random order
								// when clear, matching variations play sequentially
	BOOL	m_fHardLink;		// Set if this PartRef is 'Linked' to its part
	GUID	m_guidOldPartID;	// GUID for finding linked parts to change
	BOOL	m_fSetGUIDOldPartID;

	CTypedPtrList<CPtrList, PianoRollUIState*> m_lstPianoRollUIStates;
};


/////////////////////////////////////////////////////////////////////////////
// CIMA25EventItem class

class CIMA25EventItem : public AListItem
{
friend class CDirectMusicPattern;

public:
	virtual ~CIMA25EventItem(); 
	CIMA25EventItem* GetNext() { return (CIMA25EventItem*) AListItem::GetNext(); }

protected:
	CDirectMusicPartRef*		m_pPartRef;
	CDirectMusicEventItem*		m_pEvent;
};


/////////////////////////////////////////////////////////////////////////////
// CIMA25EventList class

class CIMA25EventList : public AList
{
public:
	virtual ~CIMA25EventList()	{	CIMA25EventItem* pEvent;	
									while( m_pHead != NULL )
									{
										pEvent = RemoveHead();
										delete pEvent;
									}
								}
    CIMA25EventItem *GetHead() const { return (CIMA25EventItem *)AList::GetHead();};
    CIMA25EventItem *RemoveHead() { return (CIMA25EventItem *)AList::RemoveHead();};
};


/////////////////////////////////////////////////////////////////////////////
// IMA25 Click structure

struct Click
{
	~Click() { }
	Click() { }
	int					m_nClick;			// click
	CIMA25EventList		m_lstIMA25Events;	// list of events (notes, curves, etc.)
};


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern class

class CDirectMusicPattern : public IDMUSProdNode, public IPersistStream, public IDMUSProdTimelineCallback,
							public IDMUSProdPropPageObject, public IDMUSProdTransport, public IDMUSProdNotifyCPt,
							public IDMUSProdConductorTempo, public IDMUSProdSecondaryTransport, public IPatternNodePrivate
{
friend class CDirectMusicStyle;
friend class CStylePatterns;
friend class CStyleMotifs;
friend class CStyleDlg;
friend class CDirectMusicPartRef;
friend class CPatternCtrl;
friend class CPatternDlg;
friend class CPatternLengthDlg;
friend class CTabPatternPattern;
friend class CTabMotifMotif;
friend class CTabMotifLoop;
friend class CDialogLinkExisting;
friend class CNewPatternDlg;

public:
    CDirectMusicPattern( CDirectMusicStyle* pStyle, BOOL fMotif );
	~CDirectMusicPattern();

	// Must call this method when the pattern is going to be deleted
	// It cleans up the references to the variation choices editor
	void	PreDeleteCleanup( void );

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdTimelineCallback functions
	HRESULT STDMETHODCALLTYPE OnDataChanged( LPUNKNOWN punkStripMgr );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdTransport methods
	STDMETHOD(Play)(BOOL fPlayFromStart);
	STDMETHOD(Stop)(BOOL fStopImmediate);
	STDMETHOD(Transition)();
	STDMETHOD(Record)( BOOL fPressed );
	STDMETHOD(GetName)( BSTR* pbstrName );
	STDMETHOD(TrackCursor)(BOOL fTrackCursor);

	// IDMUSProdSecondaryTransport methods
	STDMETHOD(GetSecondaryTransportSegment)( IUnknown **ppunkSegment );
	STDMETHOD(GetSecondaryTransportName)( BSTR* pbstrName );
	
	// IDMUSProdConductorTempo methods
	STDMETHOD(SetTempo)( double dblTempo );
	STDMETHOD(GetTempo)( double *pdblTempo );
	STDMETHOD(SetTempoModifier)( double dblModifier );
	STDMETHOD(GetTempoModifier)( double *pdblModifier );
	STDMETHOD(TempoModified)( BOOL fModified );

	//IDMUSProdNotifyCPt method
	HRESULT STDMETHODCALLTYPE OnNotify( ConductorNotifyEvent *pConductorNotifyEvent );

	// IPatternNodePrivate method
	HRESULT STDMETHODCALLTYPE DisplayPartLinkDialog( GUID *pGuid, IStream **ppPartStream );
	HRESULT STDMETHODCALLTYPE DisplayVariationChoicesDlg( REFGUID guidPart, DWORD dwPChannel );
	HRESULT STDMETHODCALLTYPE SetAuditionVariations( DWORD dwVariations, REFGUID rguidPart, DWORD dwPChannel );
	HRESULT STDMETHODCALLTYPE GetNumHardLinkRefs( REFGUID guidPart, DWORD* pdwReferences );
	HRESULT STDMETHODCALLTYPE CanShowPartLinkDialog();

	//Additional functions
	CDirectMusicEventItem* MakeDirectMusicEventItem(FullSeqEvent* pEvent);	// make music event from midi event
	void ActivateDialog( BOOL fActivate );
	void SyncTimelineSettings( void );

protected:
	HRESULT Initialize2 ( void );
	HRESULT Initialize1( void );
	void RecalcLength();
	void StartStopMusic( BOOL fStart, BOOL fInTransition = FALSE );
	MUSIC_TIME CalcLength() const { return m_dwLength; };

	CDirectMusicPart* FindPart( DWORD dwChannelID ) const;

	/*
	unsigned char MusicValueToNote( unsigned short value, char scalevalue, long keypattern,
									char keyroot, long chordpattern, char chordroot, char count );             // Total notes in chord.
	WORD NoteToMusicValue( BYTE bMIDINote, BYTE bPlayModes,  const DMUS_SUBCHORD &dmSubChord );
	unsigned short OldNoteToMusicValue(unsigned char note, long keypattern, char keyroot, long chordpattern, char chordroot);
	unsigned char OldMusicValueToNote(unsigned short value, char scalevalue, 
															long keypattern,  char keyroot,
															long chordpattern, char chordroot,
															char count);
	*/

	CDirectMusicPartRef* AllocPartRef();
	void DeletePartRef( CDirectMusicPartRef* pPartRef );
	CDirectMusicPartRef* FindPartRefByPChannel( DWORD dwPChannel ) const;
	CDirectMusicPartRef* FindPartRefByPChannelAndGUID( DWORD dwPChannel, REFGUID guidPart ) const;

	HRESULT GetPatternFromMIDIStripMgr();
	HRESULT OpenVarChoicesEditor( CDirectMusicPartRef* pPartRef );
	HRESULT InitializeVarChoicesEditor( CDirectMusicPartRef* pPartRef );
	HRESULT InsertBandTrack( IDirectMusicSegment *pSegment, BOOL fNeedBandTrack );
	HRESULT InsertChordTrack( IDirectMusicSegment *pSegment );
	HRESULT UpdateChordTrack( IDirectMusicSegment *pSegment );
	HRESULT ChangeChord( DMUS_CHORD_PARAM* pChordData, IDirectMusicSegment *pSegment );
	HRESULT CreateSegment( BOOL fNeedBandTrack );
	HRESULT PlayBand();
	IStream* GetChordList();
	HRESULT QueueTempoEvent();
	IDMUSProdNode* GetActiveBand();

    HRESULT DM_SaveSinglePattern( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
    HRESULT DM_SavePattern( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
    HRESULT DM_SavePatternChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePatternUIChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePatternInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SavePatternRhythm( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveMotifSettingsChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_LoadPattern( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool fSinglePattern );
    HRESULT DM_SavePatternEditInfo( IDMUSProdRIFFStream* pIRiffStream );

    HRESULT IMA25_LoadPattern( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadEvents( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT IMA25_LoadNoteList( IStream* pIStream, MMCKINFO* pckMain, short nClickTime );
	HRESULT IMA25_LoadCurveList( IStream* pIStream, MMCKINFO* pckMain, short nClickTime );

public:
	HRESULT Initialize();
	void SetModified( BOOL fModified );
	HRESULT SyncPatternWithDirectMusic();
	HRESULT SyncPatternWithMidiStripMgr();
	HRESULT SyncPatternWithAuditionSegment( BOOL fFirstTime, IDirectMusicSegment *pSegment );
	HRESULT RegisterWithTransport();
	HRESULT UnRegisterWithTransport();
	void PreChangePartRef( CDirectMusicPartRef* pDMPartRef );
	void UpdateLinkedParts( CDirectMusicPartRef* pPartRef, LPCTSTR pcstrText );
	void UpdateLinkFlags( void );
	void UpdateMIDIMgrsAndChangePartPtrs( CDirectMusicPart* pOldPart, CDirectMusicPart* pNewPart, LPCTSTR pcstrText );

	// Methods to set Pattern data
	void SetNbrMeasures( WORD wNbrMeasures );
	void SetEmbellishment( WORD wOnEmbellishment, WORD wOffEmbellishment, WORD wCustomId );
	void SetGrooveRange( BYTE bGrooveBottom, BYTE bGrooveTop );
	void SetDestGrooveRange( BYTE bDestGrooveBottom, BYTE bDestGrooveTop );
	void SetRhythmMap( DWORD* pRythmMap );
	void SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fSyncWithEngine );
	void SetMotifResolution( DWORD dwResolution );
	void SetMotifRepeats( DWORD dwRepeats );
	BOOL SetMotifPlayStart( MUSIC_TIME mtPlayStart );
	BOOL SetMotifLoopStart( MUSIC_TIME mtLoopStart );
	BOOL SetMotifLoopEnd( MUSIC_TIME mtLoopEnd );
	void ResetMotifLoopPoints();
	void MusicTimeToBarBeatGridTick( MUSIC_TIME mtTime, long* plBar, long* plBeat, long* plGrid, long* plTick );
	void BarBeatGridTickToMusicTime( long lBar, long lBeat, long lGrid, long lTick, MUSIC_TIME* pmtTime );
	HRESULT CopyToForLinkAllParts( CDirectMusicPattern* pPattern );
	void SendChangeNotification();
	void SetFlags( DWORD dwFlags );

	// Methods to paste Bands
	HRESULT LoadCF_BANDTRACK( IStream* pIStream );
	HRESULT PasteCF_BAND( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT PasteCF_BANDLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT PasteCF_BANDTRACK( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT PasteCF_TIMELINE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );

	// Methods to sync Timeline data
	void SyncTempo();

private:
    CJazzUndoMan*      m_pUndoMgr;
    DWORD			   m_dwRef;
	BOOL			   m_fModified;
	BOOL			   m_fSendChangeNotification;
	BOOL			   m_fRecordPressed;
	BOOL			   m_fDialogActive;
	BOOL			   m_fInUndo;
	BOOL			   m_fInRedo;
	BOOL			   m_fDontUpdateDirectMusicDuringLoad;
	BOOL			   m_fPatternIsPlaying;
	BOOL			   m_fInTransition;
	BOOL			   m_fInGroupEdit;
	REFERENCE_TIME	   m_rtCurrentStartTime;
	BOOL			   m_fInOpenVarChoicesEditor;
	int				   m_nLastCustomId;


	CDirectMusicStyle* m_pStyle;

	IDMUSProdNode*	   m_pIDocRootNode;
	IDMUSProdNode*	   m_pIParentNode;
	HWND			   m_hWndEditor;

	DWORD						m_dwPlaybackID;
	IDirectMusicSegment*		m_pIDMSegment;
	IDirectMusicSegmentState*	m_pIDMSegmentState;
	IDirectMusicSegmentState*	m_rpIDMStoppedSegmentState;
	IDirectMusicSegment*		m_pIDMTransitionSegment;
	IDirectMusicSegmentState*	m_pIDMTransitionSegmentState;

public:
	CPatternCtrl*	   m_pPatternCtrl;		

// Pattern data
private:
    DWORD				m_dwDefaultKeyPattern;	// Default KeyPattern (Key/Chord for composing)
    DWORD				m_dwDefaultChordPattern;// Default ChordPattern (Key/Chord for composing)
    BYTE				m_bDefaultKeyRoot;		// Default KeyRoot (Key/Chord for composing)
    BYTE				m_bDefaultChordRoot;	// Default ChordRoot (Key/Chord for composing)
	BOOL				m_fChordFlatsNotSharps;	// Enharmonics for chord
	BOOL				m_fKeyFlatsNotSharps;	// Enharmonics for key

	DirectMusicTimeSig	m_TimeSignature;		// Patterns can override the Style's Time sig.
	WORD				m_wNbrMeasures;			// length in measures
	DWORD				m_dwLength;				// length in clocks
	WORD				m_wEmbellishment;		// Fill, Break, Intro, End, Normal, Motif
	BYTE				m_bGrooveBottom;		// bottom of groove range
	BYTE				m_bGrooveTop;			// top of groove range
	BYTE				m_bDestGrooveBottom;	// bottom of destination groove range
	BYTE				m_bDestGrooveTop;		// top of destination groove range
    DWORD               m_dwFlags;				// various flags (DMUS_PATTERNF_*)
	DWORD*				m_pRhythmMap;			// variable array of rhythms for chord matching
	CTypedPtrList<CPtrList, CDirectMusicPartRef*> m_lstPartRefs;	// list of part references

	void*				m_pPatternDesignData;		// UI info for Pattern
	DWORD				m_dwPatternDesignDataSize;	// Size of UI info

	BOOL				m_fTrackTimeCursor;

	// Timeline design data
	double				m_dblZoom;
	double				m_dblHorizontalScroll;
	long				m_lVerticalScroll;
	DMUSPROD_TIMELINE_SNAP_TO m_tlSnapTo;
	long				m_lFunctionbarWidth;
	bool				m_fIgnoreTimelineSync;

	// Motif specific data
	IDMUSProdNode*		m_pIBandNode;			// Motif's band.
    DWORD				m_dwRepeats;			// Number of repeats. By default, 0. 
    MUSIC_TIME			m_mtPlayStart;			// Start of playback. By default, 0. 
    MUSIC_TIME			m_mtLoopStart;			// Start of looping portion. By default, 0. 
    MUSIC_TIME			m_mtLoopEnd;			// End of loop. Must be greater than dwPlayStart.
												// By default, equal to length of motif. 
    DWORD				m_dwResolution;			// Default resolution. 
public:
    CString			    m_strName;				// Pattern name
};

#endif // __PATTERN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\PatternCtl.h ===
#if !defined(PATTERNCTL_H__3BD2BA28_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define PATTERNCTL_H__3BD2BA28_46E7_11D0_89AC_00A0C9054129__INCLUDED_

// PatternCtl.h : Declaration of the CPatternCtrl ActiveX Control class.

#include "PatternDlg.h"


class CDirectMusicPattern;


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl : See PatternCtl.cpp for implementation.

class CPatternCtrl : public COleControl
{
friend class CPatternDlg;
friend class CDirectMusicStyle;

	DECLARE_DYNCREATE(CPatternCtrl)

// Constructor
public:
	CPatternCtrl();

// Attributes
public:
	CPatternDlg*			m_pPatternDlg;

private:
	HWND					m_hWndContainer;
	HMENU					m_hMenuInPlace;
	HACCEL					m_hAcceleratorTable;
	HANDLE					m_hKeyStatusBar;
	CToolBar*				m_pToolBar;
	CDirectMusicPattern*	m_pPattern;
	BOOL					m_fDocWindowActive;

private:
	BOOL TimelineEditAvailable(WPARAM wId);
	void SendEditToTimeline(WPARAM wId);
	LRESULT OnOpenVarChoicesEditor( WPARAM wParam, LPARAM lParam );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPatternCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CPatternCtrl();

	DECLARE_OLECREATE_EX(CPatternCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CPatternCtrl)      // GetTypeInfo
	DECLARE_OLECTLTYPE(CPatternCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CPatternCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPatternNewstrip();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnEditCopy();
	afx_msg void OnEditCut();
	afx_msg void OnEditDelete();
	afx_msg void OnEditRedo();
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnEditPasteInsert();
	afx_msg void OnEditPasteMerge();
	afx_msg void OnEditPasteOverwrite();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditSelectall();
	afx_msg void OnEditInsert();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditMergeVariations();
	afx_msg void OnUpdateEditMergeVariations(CCmdUI* pCmdUI);
	afx_msg void OnHelpFinder();
	afx_msg void OnEditDeletePart();
	afx_msg void OnUpdateEditDeletePart(CCmdUI* pCmdUI);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnEditQuantize();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CPatternCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CPatternCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CPatternCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(PATTERNCTL_H__3BD2BA28_46E7_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\NewPatternDlg.h ===
#if !defined(AFX_NEWPATTERNDLG_H__B98F9683_BF6C_11D2_8545_00105A2796DE__INCLUDED_)
#define AFX_NEWPATTERNDLG_H__B98F9683_BF6C_11D2_8545_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPatternDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewPatternDlg dialog

class CNewPatternDlg : public CDialog
{
friend class CStyleMotifs;
friend class CStylePatterns;

// Construction
public:
	CNewPatternDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewPatternDlg)
	enum { IDD = IDD_NEW_PATTERN };
	CListBox	m_lstbxPattern;
	CButton	m_radioNewPattern;
	CButton	m_radioLinkPattern;
	//}}AFX_DATA

protected:
	WORD					m_wEmbellishment;	// Used to distinguish Pattern from Motif
	CDirectMusicPattern*	m_pPattern;			// Pointer to linked Pattern
	CDirectMusicStyle*		m_pStyle;			// Pointer to parent Style of the new Pattern/Motif 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPatternDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPatternDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnNewPattern();
	afx_msg void OnDoubleClickedNewPattern();
	afx_msg void OnLinkPattern();
	afx_msg void OnDoubleClickedLinkPattern();
	afx_msg void OnSelChangePatternList();
	virtual void OnOK();
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPATTERNDLG_H__B98F9683_BF6C_11D2_8545_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\PatternDlg.cpp ===
// PatternDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "PatternCtl.h"
#include "PatternDlg.h"
#include "MIDIStripMgr.h"
#include <SegmentGUIDS.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg

IMPLEMENT_DYNCREATE(CPatternDlg, CFormView)

CPatternDlg::CPatternDlg()
	: CFormView(CPatternDlg::IDD)
{
	//{{AFX_DATA_INIT(CPatternDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pPatternCtrl = NULL;
	m_pITimelineCtl = NULL;
	m_pIMIDIStripMgr = NULL;
	m_punkMIDIStripMgr = NULL;
	m_pStyle = NULL;
	m_pActiveStripWhenWindowDeactivated = NULL;

	m_nTimerID = 0;
	m_fActive = false;
}

CPatternDlg::~CPatternDlg()
{
	ASSERT(m_pITimelineCtl == NULL);
	ASSERT(m_pIMIDIStripMgr == NULL);
	ASSERT(m_pStyle == NULL);
	ASSERT(m_pActiveStripWhenWindowDeactivated == NULL);
}

void CPatternDlg::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPatternDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::EnableTimer

void CPatternDlg::EnableTimer( BOOL fEnable ) 
{
	if( fEnable )
	{
		if( m_nTimerID == 0 )
		{
			m_nTimerID = SetTimer( 1, 40, NULL );
		}
	}
	else
	{
		if( m_nTimerID )
		{
			KillTimer( m_nTimerID );
			m_nTimerID = 0;
		}
	}
}


BEGIN_MESSAGE_MAP(CPatternDlg, CFormView)
	//{{AFX_MSG_MAP(CPatternDlg)
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_APP, OnApp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPatternDlg diagnostics

#ifdef _DEBUG
void CPatternDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CPatternDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CPatternDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::Create

BOOL CPatternDlg::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext ) 
{
	return CFormView::Create( lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext );
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::OnInitialUpdate

void CPatternDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( m_pITimelineCtl == NULL );
	ASSERT( m_pPatternCtrl != NULL );
	ASSERT( m_pPatternCtrl->m_pPattern != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CFormView::OnInitialUpdate();

	IUnknown* pIUnknown = NULL;

	CWnd* pWnd = GetDlgItem( IDC_TIMELINECTL );
	if( pWnd )
	{
		pIUnknown = pWnd->GetControlUnknown();
		if( pIUnknown )
		{
			pIUnknown->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pITimelineCtl );
		}
	}

	if( m_pITimelineCtl )
	{
		// Hand Timeline pointer to IDMUSProdFramework
		VARIANT vtInit;
		vtInit.vt = VT_UNKNOWN;
		V_UNKNOWN(&vtInit) = theApp.m_pStyleComponent->m_pIFramework;
		m_pITimelineCtl->SetTimelineProperty( TP_DMUSPRODFRAMEWORK, vtInit );

		// Set Timeline time signature
		DMUS_TIMESIGNATURE dmusTimeSig;

		dmusTimeSig.mtTime = 0;
		dmusTimeSig.bBeatsPerMeasure = m_pPatternCtrl->m_pPattern->m_TimeSignature.m_bBeatsPerMeasure;
		dmusTimeSig.bBeat = m_pPatternCtrl->m_pPattern->m_TimeSignature.m_bBeat;			
		dmusTimeSig.wGridsPerBeat = m_pPatternCtrl->m_pPattern->m_TimeSignature.m_wGridsPerBeat;	
		m_pITimelineCtl->SetParam( GUID_TimeSignature, 1, 0, 0, &dmusTimeSig );

		// Set Timeline length
		vtInit.vt = VT_I4;
		V_I4(&vtInit) = m_pPatternCtrl->m_pPattern->m_dwLength;
		m_pITimelineCtl->SetTimelineProperty( TP_CLOCKLENGTH, vtInit );

		// Set Timeline tempo
		m_pPatternCtrl->m_pPattern->SyncTempo();

		// Set the Timeline's callback member so we get callbacks when data changes
		if( SUCCEEDED( m_pPatternCtrl->m_pPattern->QueryInterface( IID_IDMUSProdTimelineCallback, (void**)&pIUnknown)) )
		{
			vtInit.vt = VT_UNKNOWN;
			V_UNKNOWN(&vtInit) = pIUnknown;
			m_pITimelineCtl->SetTimelineProperty( TP_TIMELINECALLBACK, vtInit );
			RELEASE( pIUnknown );
		}			

		// Resize ourself so the Timeline is the correct size when the pattern is loaded
		// BUGBUG: This is a major hack, but it works.  The real fix should be in the
		// Framework's CComponentDoc::OpenEditorWindow method.
		RECT rectTmp;
		::GetWindowRect( ::GetParent( ::GetParent( ::GetParent( GetSafeHwnd() ))), &rectTmp );
		// BUGBUG: 4 is a majic number - it is unrelated to the border width (tested with width of 10)
		m_pPatternCtrl->OnSize( SIZE_RESTORED, rectTmp.right - rectTmp.left - 4, rectTmp.bottom - rectTmp.top - 4 );

		// Initialize the MIDIStrip Manager
		if( SUCCEEDED( CoCreateInstance( CLSID_MIDIMgr, NULL, CLSCTX_INPROC_SERVER,
										 IID_IDMUSProdStripMgr, (void**)&m_pIMIDIStripMgr )))
		{
			// Hand MIDIStripMgr pointer to Style's IDMUSProdNode interface
			if( m_pIMIDIStripMgr->IsParamSupported( GUID_StyleNode ) == S_OK )
			{
				if( FAILED( m_pIMIDIStripMgr->SetParam( GUID_StyleNode, 0, m_pStyle ) ) )
				{
					TRACE("Pattern: Failed to set MIDIStripMgr's Style node pointer\n");
				}
			}

			// Add MIDIStripMgr to the Timeline
			m_pITimelineCtl->AddStripMgr( m_pIMIDIStripMgr, 1 );

			// Store IUnknown* for MIDIStrip Manager
			m_pIMIDIStripMgr->QueryInterface( IID_IUnknown, (void**)&m_punkMIDIStripMgr );

			// Persist this pattern's data to the manager
			// Piano Roll strips will be created for each PartRef using the Design-time data if
			// available.  If not available, they will be created with default settings.
			IPersistStream* pIPS;
			if( SUCCEEDED( m_pIMIDIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPS )))
			{
				IStream* pIStream;

				if( SUCCEEDED( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_SinglePattern, &pIStream )))
				{
					m_pPatternCtrl->m_pPattern->m_fIgnoreTimelineSync = true;
					if( SUCCEEDED( m_pPatternCtrl->m_pPattern->Save( pIStream, FALSE )))
					{
						StreamSeek( pIStream, 0, STREAM_SEEK_SET ); //seek to beginning
						pIPS->Load( pIStream );
					}
					m_pPatternCtrl->m_pPattern->m_fIgnoreTimelineSync = false;

					RELEASE( pIStream );
				}

				RELEASE( pIPS );
			}

			// Enable the record button
			DWORD dwButtonState = BS_AUTO_UPDATE | BS_RECORD_ENABLED;
			if( m_pPatternCtrl->m_pPattern->m_fRecordPressed )
			{
				dwButtonState |= BS_RECORD_CHECKED;
			}
			theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( m_pPatternCtrl->m_pPattern, dwButtonState );	

			// If Record is pressed, tell the MIDIMgr to enable MIDI input.
			if ( m_pPatternCtrl->m_pPattern->m_fRecordPressed )
			{
				IMIDIMgr* pIMIDIMgr;
				if( SUCCEEDED( m_pIMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**)&pIMIDIMgr ) ) )
				{
					pIMIDIMgr->OnRecord( TRUE );
					pIMIDIMgr->Release();
				}
			}

			// If currently playing, start our timer and tell the MIDIMgr that music is playing.
			if ( m_pPatternCtrl->m_pPattern->m_fPatternIsPlaying )
			{
				EnableTimer( m_pPatternCtrl->m_pPattern->m_fTrackTimeCursor );
				IMIDIMgr* pIMIDIMgr;
				if( SUCCEEDED( m_pIMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**)&pIMIDIMgr ) ) )
				{
					pIMIDIMgr->SetSegmentState( m_pPatternCtrl->m_pPattern->m_pIDMSegmentState );
					pIMIDIMgr->Release();
				}

				// If we're playing, tell the Timeline
				m_pITimelineCtl->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pPatternCtrl->m_pPattern->m_rtCurrentStartTime );
			}
		}

		// Update the horizontal zoom, horizontal scroll, and vertical scroll
		UpdateZoomAndScroll();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::OnDestroy

void CPatternDlg::OnDestroy() 
{
	EnableTimer( FALSE );

	// Remove our reference to the active strip
	RELEASE(m_pActiveStripWhenWindowDeactivated);

	if( m_pITimelineCtl && m_pPatternCtrl && m_pPatternCtrl->m_pPattern )
	{
		VARIANT var;
		if( SUCCEEDED( m_pITimelineCtl->GetTimelineProperty( TP_ZOOM, &var ) ) )
		{
			if( V_R8(&var) != m_pPatternCtrl->m_pPattern->m_dblZoom )
			{
				m_pPatternCtrl->m_pPattern->m_dblZoom = V_R8(&var);
				m_pPatternCtrl->m_pPattern->SetModified( TRUE );
			}
		}

		if( (m_pPatternCtrl->m_pPattern->m_dblZoom > 0.0)
		&&	SUCCEEDED( m_pITimelineCtl->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			if( (V_I4(&var) / m_pPatternCtrl->m_pPattern->m_dblZoom) != m_pPatternCtrl->m_pPattern->m_dblHorizontalScroll )
			{
				m_pPatternCtrl->m_pPattern->m_dblHorizontalScroll = V_I4(&var) / m_pPatternCtrl->m_pPattern->m_dblZoom;
				m_pPatternCtrl->m_pPattern->SetModified( TRUE );
			}
		}

		if( SUCCEEDED( m_pITimelineCtl->GetTimelineProperty( TP_VERTICAL_SCROLL, &var ) ) )
		{
			if( V_I4(&var) != m_pPatternCtrl->m_pPattern->m_lVerticalScroll )
			{
				m_pPatternCtrl->m_pPattern->m_lVerticalScroll = V_I4(&var);
				m_pPatternCtrl->m_pPattern->SetModified( TRUE );
			}
		}

		if( SUCCEEDED( m_pITimelineCtl->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
		{
			if( V_I4(&var) != m_pPatternCtrl->m_pPattern->m_tlSnapTo )
			{
				m_pPatternCtrl->m_pPattern->m_tlSnapTo = (DMUSPROD_TIMELINE_SNAP_TO)V_I4(&var);
				m_pPatternCtrl->m_pPattern->SetModified( TRUE );
			}
		}

		if( SUCCEEDED( m_pITimelineCtl->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var ) ) )
		{
			if( V_I4(&var) != m_pPatternCtrl->m_pPattern->m_lFunctionbarWidth )
			{
				m_pPatternCtrl->m_pPattern->m_lFunctionbarWidth = V_I4(&var);
				m_pPatternCtrl->m_pPattern->SetModified( TRUE );
			}
		}

		// If we're playing, tell the Timeline we stopped
		if( m_pPatternCtrl->m_pPattern->m_rtCurrentStartTime != 0 )
		{
			REFERENCE_TIME rtTime = 0;
			m_pITimelineCtl->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &rtTime );
		}
	}

	RELEASE( m_pITimelineCtl );
	RELEASE( m_pIMIDIStripMgr );
	RELEASE( m_punkMIDIStripMgr );

	m_pStyle = NULL;

	CFormView::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::OnSize

void CPatternDlg::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CFormView::OnSize( nType, cx, cy );

	CWnd *pWndTimeline = GetDlgItem( IDC_TIMELINECTL );
	if( pWndTimeline )
	{
		pWndTimeline->MoveWindow( 0, 0, cx, cy, FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::OnEraseBkgnd

BOOL CPatternDlg::OnEraseBkgnd( CDC* pDC ) 
{
	UNREFERENCED_PARAMETER(pDC);

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::OnTimer

void CPatternDlg::OnTimer( UINT nIDEvent ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pITimelineCtl != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );
	ASSERT( m_pPatternCtrl != NULL );
	ASSERT( m_pPatternCtrl->m_pPattern != NULL );
	
	IDirectMusicSegmentState* pIDMSegmentState = m_pPatternCtrl->m_pPattern->m_pIDMSegmentState ? m_pPatternCtrl->m_pPattern->m_pIDMSegmentState : m_pPatternCtrl->m_pPattern->m_rpIDMStoppedSegmentState;
	if( m_pITimelineCtl && pIDMSegmentState )
	{
		MUSIC_TIME mtTimeNow;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtTimeNow ) ) )
		{
			MUSIC_TIME mtStartTime;
			MUSIC_TIME mtOffset;
			MUSIC_TIME mtStartPoint;

			if( SUCCEEDED ( pIDMSegmentState->GetStartTime( &mtStartTime ) ) && 
				SUCCEEDED ( pIDMSegmentState->GetStartPoint( &mtStartPoint ) ) )
			{
				mtOffset = mtTimeNow - mtStartTime + mtStartPoint;
				if( mtOffset >=0 )
				{
					mtOffset = mtOffset % m_pPatternCtrl->m_pPattern->m_dwLength;
					m_pITimelineCtl->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, mtOffset );
				}
			}
		}

		return;
	}
	
	CFormView::OnTimer(nIDEvent);
}

LRESULT CPatternDlg::OnApp( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_pPatternCtrl->m_pPattern == NULL )
	{
		return 0;
	}

	// wParam = dwNotificationOption
	// lParam = mtTime (for start/loop), mtOffset (for abort/end)
	switch( wParam )
	{
	case DMUS_NOTIFICATION_SEGSTART:
		// If the timeline exists, notify it that we started playing
		if( m_pITimelineCtl )
		{
			m_pITimelineCtl->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pPatternCtrl->m_pPattern->m_rtCurrentStartTime );
		}
	case DMUS_NOTIFICATION_SEGLOOP:
		// Make sure cursor is moving
		EnableTimer( m_pPatternCtrl->m_pPattern->m_fTrackTimeCursor );

		// Notify the MIDIMgr that the music started
		if( m_punkMIDIStripMgr )
		{
			IMIDIMgr* pIMIDIMgr;
			if( SUCCEEDED ( m_punkMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr) ) )
			{
				pIMIDIMgr->SetSegmentState( m_pPatternCtrl->m_pPattern->m_pIDMSegmentState );
				pIMIDIMgr->Release();
			}
		}
		break;
	case DMUS_NOTIFICATION_SEGABORT:
	case DMUS_NOTIFICATION_SEGEND:
		// Make sure cursor stops moving
		EnableTimer( FALSE );

		// Notify the MIDIMgr that the music stopped
		if( m_punkMIDIStripMgr )
		{
			IMIDIMgr* pIMIDIMgr;
			if( SUCCEEDED ( m_punkMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr) ) )
			{
				pIMIDIMgr->SetSegmentState( NULL );
				pIMIDIMgr->Release();
			}
		}

		// If the timeline exists, notify it that we stopped playing
		if( m_pITimelineCtl )
		{
			if( lParam >= 0 )
			{
				m_pITimelineCtl->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, lParam );
			}

			ASSERT( m_pPatternCtrl->m_pPattern->m_rtCurrentStartTime == 0 );
			m_pITimelineCtl->SetParam( GUID_TimelineSetSegStartTime, 1, 0, 0, &m_pPatternCtrl->m_pPattern->m_rtCurrentStartTime );
		}
		break;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::Activate

void CPatternDlg::Activate( BOOL fActive )
{
	if( m_fActive != fActive )
	{
		m_fActive = fActive;

		if( m_pITimelineCtl )
		{
			if( !m_fActive )
			{
				// Initialize the strip reference pointer to NULL
				m_pActiveStripWhenWindowDeactivated = NULL;

				// Determine which strip (if any) is active
				VARIANT var;
				if( SUCCEEDED( m_pITimelineCtl->GetTimelineProperty( TP_ACTIVESTRIP, &var ) )
				&&	(V_UNKNOWN(&var) != NULL) )
				{
					IDMUSProdStrip *pIStrip;
					if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdStrip, (void **) &pIStrip ) ) )
					{
						// Keep a copy of the strip
						m_pActiveStripWhenWindowDeactivated = pIStrip;
					}
					V_UNKNOWN(&var)->Release();

					// Deactivate the active strip
					V_UNKNOWN(&var) = NULL;
					m_pITimelineCtl->SetTimelineProperty( TP_ACTIVESTRIP, var );
				}
			}
			else if( m_pActiveStripWhenWindowDeactivated )
			{
				// Activate the strip that was active when we our window was deactivated
				VARIANT var;
				var.vt = VT_UNKNOWN;
				V_UNKNOWN(&var) = m_pActiveStripWhenWindowDeactivated;
				V_UNKNOWN(&var)->AddRef();
				m_pITimelineCtl->SetTimelineProperty( TP_ACTIVESTRIP, var );

				m_pActiveStripWhenWindowDeactivated->Release();
				m_pActiveStripWhenWindowDeactivated = NULL;
			}
		}

		if( m_pIMIDIStripMgr )
		{
			IMIDIMgr *pIMIDIMgr;
			if( SUCCEEDED( m_pIMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void **)&pIMIDIMgr ) ) )
			{
				pIMIDIMgr->Activate( m_fActive );
				pIMIDIMgr->Release();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPatternDlg::UpdateZoomAndScroll

void CPatternDlg::UpdateZoomAndScroll( void )
{
	ASSERT( m_pPatternCtrl && m_pPatternCtrl->m_pPattern );
	if( m_pPatternCtrl && m_pPatternCtrl->m_pPattern && m_pITimelineCtl )
	{
		VARIANT vtInit;
		if( m_pPatternCtrl->m_pPattern->m_dblZoom == 0.0 )
		{
			m_pPatternCtrl->m_pPattern->m_dblZoom = 0.125;
		}
		V_R8(&vtInit) = m_pPatternCtrl->m_pPattern->m_dblZoom;
		vtInit.vt = VT_R8;
		m_pITimelineCtl->SetTimelineProperty( TP_ZOOM, vtInit );

		V_I4(&vtInit) = m_pPatternCtrl->m_pPattern->m_lVerticalScroll;
		vtInit.vt = VT_I4;
		m_pITimelineCtl->SetTimelineProperty( TP_VERTICAL_SCROLL, vtInit );

		V_I4(&vtInit) = long(m_pPatternCtrl->m_pPattern->m_dblHorizontalScroll * m_pPatternCtrl->m_pPattern->m_dblZoom);
		vtInit.vt = VT_I4;
		m_pITimelineCtl->SetTimelineProperty( TP_HORIZONTAL_SCROLL, vtInit );

		V_I4(&vtInit) = m_pPatternCtrl->m_pPattern->m_tlSnapTo;
		vtInit.vt = VT_I4;
		m_pITimelineCtl->SetTimelineProperty( TP_SNAP_TO, vtInit );

		V_I4(&vtInit) = m_pPatternCtrl->m_pPattern->m_lFunctionbarWidth;
		vtInit.vt = VT_I4;
		m_pITimelineCtl->SetTimelineProperty( TP_FUNCTIONBAR_WIDTH, vtInit );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\PatternLengthDlg.h ===
#if !defined(AFX_PATTERNLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_PATTERNLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PatternLengthDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg dialog

class CPatternLengthDlg : public CDialog
{
// Construction
public:
	CPatternLengthDlg( CDirectMusicPattern* pPattern, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPatternLengthDlg)
	enum { IDD = IDD_PATTERN_LENGTH };
	CEdit	m_editLength;
	CButton	m_btnOK;
	CSpinButtonCtrl	m_spinLength;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPatternLengthDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDirectMusicPattern* m_pPattern;

	// Generated message map functions
	//{{AFX_MSG(CPatternLengthDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PATTERNLENGTHDLG_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\PatternCtl.cpp ===
// PatternCtl.cpp : Implementation of the CPatternCtrl ActiveX Control class.

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "PatternCtl.h"
#include "MIDIStripMgr.h"
#include <SegmentGUIDS.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CPatternCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CPatternCtrl, COleControl)
	//{{AFX_MSG_MAP(CPatternCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_COMMAND(ID_PATTERN_NEWSTRIP, OnPatternNewstrip)
	ON_WM_SETFOCUS()
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_PASTE_INSERT, OnEditPasteInsert)
	ON_COMMAND(ID_EDIT_PASTE_MERGE, OnEditPasteMerge)
	ON_COMMAND(ID_EDIT_PASTE_OVERWRITE, OnEditPasteOverwrite)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectall)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_COMMAND(ID_EDIT_MERGE_VARIATIONS, OnEditMergeVariations)
	ON_UPDATE_COMMAND_UI(ID_EDIT_MERGE_VARIATIONS, OnUpdateEditMergeVariations)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_COMMAND(ID_EDIT_DELETE_PART, OnEditDeletePart)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE_PART, OnUpdateEditDeletePart)
	ON_WM_PARENTNOTIFY()
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_INSERT, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_MERGE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_OVERWRITE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_QUANTIZE, OnEditQuantize)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(WM_OPEN_VARCHOICES, OnOpenVarChoicesEditor)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CPatternCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CPatternCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CPatternCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CPatternCtrl, COleControl)
	//{{AFX_EVENT_MAP(CPatternCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl Interface map

BEGIN_INTERFACE_MAP(CPatternCtrl, COleControl)
    INTERFACE_PART(CPatternCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CPatternCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CPatternCtrl, "STYLEDESIGNER.PatternCtrl.1",
	0x3bd2ba09, 0x46e7, 0x11d0, 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CPatternCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DPattern =
		{ 0x3bd2ba07, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DPatternEvents =
		{ 0x3bd2ba08, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwPatternOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CPatternCtrl, IDS_PATTERN, _dwPatternOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::CPatternCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CPatternCtrl

BOOL CPatternCtrl::CPatternCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_PATTERN,
			IDB_PATTERN,
			afxRegApartmentThreading,
			_dwPatternOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::CPatternCtrl - Constructor

CPatternCtrl::CPatternCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DPattern, &IID_DPatternEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DPattern;
	m_piidEvents = &IID_DPatternEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pPatternDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_hAcceleratorTable	= NULL;
	m_hKeyStatusBar = NULL;
	m_pToolBar = NULL;
	m_pPattern = NULL;
	// Initially, our doc window is inactive and the main window is active
	m_fDocWindowActive = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::~CPatternCtrl - Destructor

CPatternCtrl::~CPatternCtrl()
{
	RELEASE( m_pPattern );
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CPatternCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CPatternCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CPatternCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CPatternCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::QueryInterface

STDMETHODIMP CPatternCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CPatternCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::AttachObjects implementation

HRESULT CPatternCtrl::XEditor::AttachObjects( IDMUSProdNode* pNode )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	pThis->m_pPattern = (CDirectMusicPattern *)pNode;
	pThis->m_pPattern->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::OnInitMenuFilePrint

HRESULT CPatternCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::OnFilePrint

HRESULT CPatternCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CPatternCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::OnFilePrintPreview

HRESULT CPatternCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::OnViewProperties

HRESULT CPatternCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( !pThis->m_pPattern )
	{
		return E_FAIL;
	}

	IDMUSProdPropSheet* pIPropSheet;
	if( FAILED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	if( pIPropSheet->IsShowing() == S_OK )
	{
		if( pThis->m_pPatternDlg && pThis->m_pPatternDlg->m_pIMIDIStripMgr )
		{
			BOOL fSetPropPage = FALSE;
			VARIANT var;
			if( SUCCEEDED( pThis->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
			{
				IUnknown *punkStrip = V_UNKNOWN(&var);
				if( punkStrip )
				{
					IDMUSProdStrip *pIStrip;
					if( SUCCEEDED( punkStrip->QueryInterface( IID_IDMUSProdStrip, (void **) &pIStrip ) ) )
					{
						if( SUCCEEDED( pIStrip->OnWMMessage(WM_COMMAND, MAKEWPARAM(ID_VIEW_PROPERTIES, 0), 0L, 0L, 0L) ) )
						{
							hr = S_OK;
						}
						pIStrip->Release();
					}
					punkStrip->Release();
				}
			}
		}
		if( hr != S_OK )
		{
			pThis->m_pPattern->OnShowProperties();
		}
	}
	else
	{
		hr = S_OK;
	}

	RELEASE( pIPropSheet );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XEditor::OnF1Help

HRESULT CPatternCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CPatternCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/PatternEditor.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CPatternCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CPatternCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	
	// Translate only if the timeline has focus
	if( pThis->m_pPatternDlg
	&&  pThis->m_pPatternDlg->m_pITimelineCtl )
	{
		HWND hwndFocus;
		hwndFocus = ::GetFocus();
		IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;

		pThis->m_pPatternDlg->m_pITimelineCtl->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
		if( pIOleInPlaceObjectWindowless )
		{
			HWND hwnd;
			if( pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK )
			{
				if( hwndFocus == hwnd )
				{
					if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
					{
						RELEASE( pIOleInPlaceObjectWindowless );
						return S_OK;
					}
				}
			}
			RELEASE( pIOleInPlaceObjectWindowless );
		}
	}

//	OLEINPLACEFRAMEINFO frameInfo = pThis->m_frameInfo;
//	if( ::OleTranslateAccelerator(pThis->m_pInPlaceFrame, &frameInfo, lpmsg) == S_OK )
//	{
//		return S_OK;
//	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( pThis->m_fDocWindowActive && pThis->m_pPattern )
	{
		pThis->m_pPattern->ActivateDialog( fActivate );
		
		if( fActivate )
		{
			// Check if property sheet is visible
			IDMUSProdPropSheet* pIPropSheet;

			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				//  If the property sheet is visible
				if( pIPropSheet->IsShowing() == S_OK )
				{
					BOOL fSetPropPage = FALSE;
					VARIANT var;
					if( pIPropSheet->IsEqualPageManagerObject( pThis->m_pPattern ) != S_OK
					&&	SUCCEEDED( pThis->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
					{
						IUnknown *punkStrip;
						punkStrip = V_UNKNOWN(&var);
						if( punkStrip )
						{
							IDMUSProdPropPageObject* pIDMUSProdPropPageObject;
							if( SUCCEEDED( punkStrip->QueryInterface( IID_IDMUSProdPropPageObject, (void**) &pIDMUSProdPropPageObject ) ) )
							{
								if( SUCCEEDED( pIDMUSProdPropPageObject->OnShowProperties() ) )
								{
									fSetPropPage = TRUE;
								}
								pIDMUSProdPropPageObject->Release();
							}
							punkStrip->Release();
						}
					}
					if( !fSetPropPage )
					{
						pThis->m_pPattern->OnShowProperties();
					}
				}
				pIPropSheet->Release();
			}
		}
	}

	//TRACE("OnFrameWindowActivate %d %d\n", pThis->m_fFrameWindowActive, pThis->m_fDocWindowActive );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( pThis->m_pPattern )
	{
		pThis->m_pPattern->ActivateDialog( fActivate );
		
		if( fActivate )
		{
			// Check if property sheet is visible
			IDMUSProdPropSheet* pIPropSheet;

			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				//  If the property sheet is visible
				if( pIPropSheet->IsShowing() == S_OK )
				{
					BOOL fSetPropPage = FALSE;
					VARIANT var;
					if( pIPropSheet->IsEqualPageManagerObject( pThis->m_pPattern ) != S_OK
					&&	SUCCEEDED( pThis->m_pPatternDlg->m_pITimelineCtl->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
					{
						IUnknown *punkStrip;
						punkStrip = V_UNKNOWN(&var);
						if( punkStrip )
						{
							IDMUSProdPropPageObject* pIDMUSProdPropPageObject;
							if( SUCCEEDED( punkStrip->QueryInterface( IID_IDMUSProdPropPageObject, (void**) &pIDMUSProdPropPageObject ) ) )
							{
								if( SUCCEEDED( pIDMUSProdPropPageObject->OnShowProperties() ) )
								{
									fSetPropPage = TRUE;
								}
								pIDMUSProdPropPageObject->Release();
							}
							punkStrip->Release();
						}
					}
					if( !fSetPropPage )
					{
						pThis->m_pPattern->OnShowProperties();
					}
				}
				pIPropSheet->Release();
			}
		}
	}

	pThis->m_fDocWindowActive = fActivate;
	//TRACE("OnDocWindowActivate %d %d\n", pThis->m_fFrameWindowActive, pThis->m_fDocWindowActive );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CPatternCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CPatternCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnDraw - Drawing function

void CPatternCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::DoPropExchange - Persistence support

void CPatternCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnOpenVarChoicesEditor

LRESULT CPatternCtrl::OnOpenVarChoicesEditor( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(wParam);

	ASSERT( m_pPattern != NULL );

	CDirectMusicPartRef* pPartRef = (CDirectMusicPartRef *)lParam;

	m_pPattern->OpenVarChoicesEditor( pPartRef );

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CPatternAbout dialog used for Pattern Editor About Box

class CPatternAbout : public CDialog
{
public:
	CPatternAbout();

// Dialog Data
	//{{AFX_DATA(CPatternAbout)
	enum { IDD = IDD_ABOUTBOX_PATTERN };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPatternAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CPatternAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CPatternAbout::CPatternAbout() : CDialog(CPatternAbout::IDD)
{
	//{{AFX_DATA_INIT(CPatternAbout)
	//}}AFX_DATA_INIT
}

void CPatternAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPatternAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPatternAbout, CDialog)
	//{{AFX_MSG_MAP(CPatternAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CPatternAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_PATTERN_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::AboutBox - Display an "About" box to the user

void CPatternCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPatternAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnCreate

int CPatternCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( COleControl::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PATTERN_EDITOR) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PATTERN_ACCELS) );

	// Create control's toolbar
//	CWnd* pWndParent = CWnd::FromHandle( m_hWndContainer );
//	if( pWndParent )
//	{
//		m_pToolBar = new CToolBar;
//		m_pToolBar->Create( pWndParent );
//		m_pToolBar->LoadToolBar( IDR_PATTERN_EDITOR );
//		m_pToolBar->SetBarStyle( m_pToolBar->GetBarStyle() | CBRS_SIZE_DYNAMIC );
//		m_pToolBar->SetOwner( this );
//	}
	
	// Create control's dialog
	m_pPatternDlg = new CPatternDlg;
	if( m_pPatternDlg == NULL )
	{
		return -1;
	}

	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pStyle != NULL );

	m_pPattern->m_pPatternCtrl = this;

	m_pPatternDlg->m_pStyle = m_pPattern->m_pStyle;
	m_pPatternDlg->m_pPatternCtrl = this;
	if( 0 == m_pPatternDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL ))
	{
		return -1;
	}
	m_pPatternDlg->OnInitialUpdate();
	
	// By default, we're active when opened
	m_fDocWindowActive = TRUE;
	m_pPattern->ActivateDialog( TRUE );

	if( m_pPatternDlg
	&&  m_pPatternDlg->m_pIMIDIStripMgr )
	{
		// Make sure we have Pattern design info
		// or chord strip undo will not work
		if( m_pPattern->m_pPatternDesignData == NULL )
		{
			// Don't let GetPatternFromMIDIStripMgr() method turn on modified flag
			BOOL fOrigModified = m_pPattern->m_fModified;

			m_pPattern->m_fDontUpdateDirectMusicDuringLoad = TRUE;
			m_pPattern->GetPatternFromMIDIStripMgr();
			m_pPattern->m_fDontUpdateDirectMusicDuringLoad = FALSE;
			
			m_pPattern->SetModified( fOrigModified );
		}
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnDestroy

void CPatternCtrl::OnDestroy() 
{
	if( m_pPatternDlg && m_pPatternDlg->m_pIMIDIStripMgr )
	{
		m_pPatternDlg->m_pIMIDIStripMgr->OnUpdate( STYLE_PatternWindowClose, 0xFFFFFFFF, NULL );
	}

	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}
	
	if( m_pToolBar )
	{
		delete m_pToolBar;	
		m_pToolBar = NULL;
	}

	ASSERT( m_pPattern != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	if( theApp.m_pStyleComponent && theApp.m_pStyleComponent->m_pIConductor )
	{
		theApp.m_pStyleComponent->m_pIConductor->SetBtnStates( m_pPattern, 0 );	
	}

	m_pPattern->m_pPatternCtrl = NULL;

	// Deactivate the dialog
	m_pPattern->ActivateDialog( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnGetInPlaceMenu

HMENU CPatternCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnHideToolBars

void CPatternCtrl::OnHideToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pPatternDlg
	&&  m_pPatternDlg->m_pITimelineCtl )
	{
		HANDLE hKey = NULL;

		// hKey is NULL - this will stop RealTime display
		m_pPatternDlg->m_pITimelineCtl->SetParam( GUID_TimelineShowRealTime, 0xFFFFFFFF, 0, 0, (void *)&hKey );
	}

	theApp.m_pStyleComponent->m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );
	m_hKeyStatusBar = NULL;

	COleControl::OnHideToolBars();
	return;
/*
	if( m_pToolBar )
	{
		BORDERWIDTHS border;

		border.top = 0;
		border.left = 0;
		border.right = 0;
		border.bottom = 0;

		if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
		{
			m_pInPlaceFrame->SetBorderSpace( &border );
			m_pToolBar->ShowWindow( SW_HIDE );
			return;
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
*/
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnShowToolBars

void CPatternCtrl::OnShowToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	// Set up the Status Bar
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Create status bar panes if they don't already exist
	if( m_hKeyStatusBar == NULL )
	{
		theApp.m_pStyleComponent->m_pIFramework->SetNbrStatusBarPanes( 2, SBLS_EDITOR, &m_hKeyStatusBar );
		theApp.m_pStyleComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 20 );
		theApp.m_pStyleComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 1, SBS_SUNKEN, 20 );

		// Tell the timeline to update the RealTime display in the status bar
		if( m_pPatternDlg
		&&  m_pPatternDlg->m_pITimelineCtl )
		{
			m_pPatternDlg->m_pITimelineCtl->SetParam( GUID_TimelineShowRealTime, 0xFFFFFFFF, 0, 0, (void *)&m_hKeyStatusBar );
		}
	}

	COleControl::OnShowToolBars();
	return;
/*
	// Show the ToolBar
	if( m_pToolBar )
	{
		BORDERWIDTHS border;
		CRect rectBorder;
		if( SUCCEEDED ( m_pInPlaceFrame->GetBorder(&rectBorder) ) )
		{
			border.top = TOOLBAR_HEIGHT;
			border.left = 0;
			border.right = 0;
			border.bottom = 0;

			if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
			{
				m_pInPlaceFrame->SetBorderSpace( &border );

				m_pToolBar->MoveWindow( rectBorder.left,
										rectBorder.top,
										rectBorder.Width(),
										TOOLBAR_HEIGHT );
				m_pToolBar->ShowWindow( SW_SHOWNORMAL );
				return;
			}
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
*/
}

/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnSize

void CPatternCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);
	m_pPatternDlg->MoveWindow( 0, 0, cx, cy, FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnEraseBkgnd

BOOL CPatternCtrl::OnEraseBkgnd( CDC* pDC ) 
{
	UNREFERENCED_PARAMETER(pDC);

	return FALSE;
}

void CPatternCtrl::OnPatternNewstrip() 
{
	IMIDIMgr* pIMIDIMgr;
	if( SUCCEEDED( m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**)&pIMIDIMgr ) ) )
	{
		pIMIDIMgr->AddNewStrip();
		pIMIDIMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPatternCtrl::OnSetFocus

void CPatternCtrl::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pStyle != NULL );

	COleControl::OnSetFocus( pOldWnd );

	if( m_pPattern == m_pPattern->m_pIDocRootNode )
	{
		// if the Pattern isn't part of a Style, SetActiveTransport to NULL so
		// the Conductor knows that this isn't a playable Pattern (until
		// the music engine is updated to support Pattern w/o style playback
		theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( NULL, 0 );	
	}
	else
	{
		DWORD dwButtonState = BS_AUTO_UPDATE;
		if( m_pPatternDlg != NULL && m_pPatternDlg->m_punkMIDIStripMgr != NULL )
		{
			dwButtonState |= BS_RECORD_ENABLED;
			if( m_pPattern && m_pPattern->m_fRecordPressed )
			{
				dwButtonState |= BS_RECORD_CHECKED;
			}
		}
		theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( m_pPattern, dwButtonState );	
		theApp.m_pStyleComponent->m_pIConductor->SetTempo( m_pPattern, m_pPattern->m_pStyle->m_dblTempo, TRUE );
	}

	// Set the focus to the timeline
	if( m_pPatternDlg
	&&  m_pPatternDlg->m_pITimelineCtl )
	{
		IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;

		m_pPatternDlg->m_pITimelineCtl->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
		if( pIOleInPlaceObjectWindowless )
		{
			HWND hwnd;
			if( pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK )
			{
				::SetFocus(hwnd);
			}

			RELEASE( pIOleInPlaceObjectWindowless );
		}
	}
}

void CPatternCtrl::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_CUT));
}

void CPatternCtrl::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_COPY));
}

void CPatternCtrl::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_PASTE));
}

void CPatternCtrl::OnUpdateEditInsert(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_INSERT));
}

void CPatternCtrl::OnUpdateEditDelete(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	pCmdUI->Enable(TimelineEditAvailable(ID_EDIT_DELETE));
}

BOOL CPatternCtrl::TimelineEditAvailable(WPARAM wId)
{
	HRESULT					hr;
	IDMUSProdTimeline		*pITimeline;
	IDMUSProdTimelineEdit	*pITimelineEdit;

	ASSERT(m_pPatternDlg != NULL);
	if(m_pPatternDlg != NULL)
	{
		pITimeline = m_pPatternDlg->m_pITimelineCtl;
		ASSERT(pITimeline != NULL);
		if(pITimeline != NULL)
		{
			pITimeline->AddRef();
			if(SUCCEEDED(pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
			{
				switch(wId)
				{
				case ID_EDIT_CUT:
					hr = pITimelineEdit->CanCut();
					break;
				case ID_EDIT_COPY:
					hr = pITimelineEdit->CanCopy();
					break;
//				case ID_EDIT_PASTE_INSERT:
				case ID_EDIT_PASTE_MERGE:
				case ID_EDIT_PASTE_OVERWRITE:
				case ID_EDIT_PASTE:
					hr = pITimelineEdit->CanPaste(NULL);
					break;
				case ID_EDIT_INSERT:
					hr = pITimelineEdit->CanInsert();
					break;
				case ID_EDIT_DELETE:
					hr = pITimelineEdit->CanDelete();
					break;
				case ID_EDIT_SELECT_ALL:
					hr = S_OK;
					break;
				default:
					hr = S_FALSE;
				}

				RELEASE( pITimelineEdit );
			}

			RELEASE( pITimeline );

			if( hr == S_OK )
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

void CPatternCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPattern != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pPattern )
	{
		TCHAR achText[256];

		ASSERT( m_pPattern->m_pUndoMgr != NULL );

		if( m_pPattern->m_pUndoMgr )
		{
			if( m_pPattern->m_pUndoMgr->GetRedo(achText, 256) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}

void CPatternCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPattern != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pPattern )
	{
		TCHAR achText[256];

		ASSERT( m_pPattern->m_pUndoMgr != NULL );

		if( m_pPattern->m_pUndoMgr )
		{
			if( m_pPattern->m_pUndoMgr->GetUndo(achText, 256) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}

void CPatternCtrl::OnEditCut() 
{
	SendEditToTimeline(ID_EDIT_CUT);
}

void CPatternCtrl::OnEditCopy() 
{
	SendEditToTimeline(ID_EDIT_COPY);
}

void CPatternCtrl::OnEditPaste() 
{
	SendEditToTimeline(ID_EDIT_PASTE);
}

void CPatternCtrl::OnEditPasteInsert() 
{
	return;

//	SendEditToTimeline(ID_EDIT_PASTE_INSERT);
}

void CPatternCtrl::OnEditPasteMerge() 
{
	SendEditToTimeline( ID_EDIT_PASTE_MERGE );
}

void CPatternCtrl::OnEditPasteOverwrite() 
{
	SendEditToTimeline( ID_EDIT_PASTE_OVERWRITE );
}

void CPatternCtrl::OnEditInsert() 
{
	SendEditToTimeline(ID_EDIT_INSERT);
}

void CPatternCtrl::OnEditDelete() 
{
	SendEditToTimeline(ID_EDIT_DELETE);
}

void CPatternCtrl::OnEditSelectall() 
{
	SendEditToTimeline(ID_EDIT_SELECT_ALL);
}

void CPatternCtrl::SendEditToTimeline(WPARAM wId)
{
	HRESULT					hr;
	BOOL					bAvailable = FALSE;
	IDMUSProdTimeline		*pITimeline;
	IDMUSProdTimelineEdit	*pITimelineEdit;

	ASSERT(m_pPatternDlg != NULL);
	if(m_pPatternDlg != NULL)
	{
		pITimeline = m_pPatternDlg->m_pITimelineCtl;
		ASSERT( pITimeline != NULL);
		if( pITimeline != NULL)
		{
			pITimeline->AddRef();
			if(SUCCEEDED(pITimeline->QueryInterface(IID_IDMUSProdTimelineEdit, (void **) &pITimelineEdit)))
			{
				bAvailable = TimelineEditAvailable(wId);
				ASSERT(bAvailable);
				if(bAvailable)
				{
					if( m_pPattern )
					{
						// If the selecte time range is not empty, and there is more than one
						// gutter selected strip that can paste, set m_pPattern->m_fInGroupEdit
						long lStart = -1, lEnd = -1;
						pITimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_MS, &lStart );
						pITimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_MS, &lEnd );
						if( lStart != lEnd )
						{
							// Count number of gutter selected strips that can edit
							DWORD dwStripIndex = 0;
							long lCount = 0;
							IDMUSProdStrip *pStrip;
							while( S_OK == pITimeline->EnumStrip( dwStripIndex, &pStrip ) )
							{
								// Check for gutter selection
								VARIANT varGutter;
								if( SUCCEEDED( pITimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
								&&	(V_BOOL( &varGutter ) == TRUE) )
								{
									IDMUSProdTimelineEdit *pITimelineEdit;
									if( SUCCEEDED( pStrip->QueryInterface( IID_IDMUSProdTimelineEdit,
															  (void**) &pITimelineEdit ) ) )
									{
										switch( wId )
										{
										case ID_EDIT_CUT:
											if( S_OK == pITimelineEdit->CanCut() )
											{
												lCount++;
											}
											break;
											/* Don't care about copy
										case ID_EDIT_COPY:
											if( S_OK == pITimelineEdit->CanCopy() )
											{
												lCount++;
											}
											break;
											*/
						//				case ID_EDIT_PASTE_INSERT:
										case ID_EDIT_PASTE_MERGE:
										case ID_EDIT_PASTE_OVERWRITE:
										case ID_EDIT_PASTE:
											if( S_OK == pITimelineEdit->CanPaste(NULL) )
											{
												lCount++;
											}
											break;
										case ID_EDIT_INSERT:
											if( S_OK == pITimelineEdit->CanInsert() )
											{
												lCount++;
											}
											break;
										case ID_EDIT_DELETE:
											if( S_OK == pITimelineEdit->CanDelete() )
											{
												lCount++;
											}
											break;
											/* Don't care about select all
										case ID_EDIT_SELECT_ALL:
											if( S_OK == pITimelineEdit->CanPaste() )
											{
												lCount++;
											}
											hr = S_OK;
											break;
											*/
										}
										pITimelineEdit->Release();
									}
								}
								pStrip->Release();
								dwStripIndex++;
							}

							if( lCount > 1 )
							{
								m_pPattern->m_fInGroupEdit = TRUE;
							}
						}
					}

					switch(wId)
					{
					case ID_EDIT_CUT:
						hr = pITimelineEdit->Cut(NULL);
						break;
					case ID_EDIT_COPY:
						hr = pITimelineEdit->Copy(NULL);
						break;
					case ID_EDIT_PASTE:
					case ID_EDIT_PASTE_MERGE:
						pITimeline->SetPasteType(TL_PASTE_MERGE);
						hr = pITimelineEdit->Paste(NULL);
						break;
					case ID_EDIT_PASTE_OVERWRITE:
						pITimeline->SetPasteType(TL_PASTE_OVERWRITE);
						hr = pITimelineEdit->Paste(NULL);
						break;
					case ID_EDIT_INSERT:
						hr = pITimelineEdit->Insert();
						break;
					case ID_EDIT_DELETE:
						hr = pITimelineEdit->Delete();
						break;
					case ID_EDIT_SELECT_ALL:
						hr = pITimelineEdit->SelectAll();
						break;
					default:
						break;
					}

					if( m_pPattern )
					{
						m_pPattern->m_fInGroupEdit = FALSE;
					}
				}

				RELEASE( pITimelineEdit );
			}

			RELEASE( pITimeline );
		}
	}
}

void CPatternCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPattern != NULL );
	if( m_pPattern )
	{
		ASSERT( m_pPattern->m_pUndoMgr != NULL );
		if( m_pPattern->m_pUndoMgr )
		{
			// Save the current timeline settings
			m_pPattern->SyncTimelineSettings();

			ASSERT( m_pPattern->m_pStyle != NULL );
			if( m_pPattern->m_pStyle )
			{
				m_pPattern->m_pStyle->m_fPChannelChange = TRUE;
			}
			m_pPattern->m_fInRedo = TRUE;		// Use this flag for undo/redo
			m_pPattern->SetModified( TRUE );	// Call before Redo() to set m_fSendChangeNotification flag
			m_pPattern->m_pUndoMgr->Redo( m_pPattern );
			m_pPattern->m_fInRedo = FALSE;
		}
	}
}

void CPatternCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pPattern != NULL );
	if( m_pPattern )
	{
		ASSERT( m_pPattern->m_pUndoMgr != NULL);
		if( m_pPattern->m_pUndoMgr )
		{
			// Save the current timeline settings
			m_pPattern->SyncTimelineSettings();

			ASSERT( m_pPattern->m_pStyle != NULL );
			if( m_pPattern->m_pStyle )
			{
				m_pPattern->m_pStyle->m_fPChannelChange = TRUE;
			}
			m_pPattern->m_fInUndo = TRUE;
			m_pPattern->SetModified( TRUE );	// Call before Undo() to set m_fSendChangeNotification flag
			m_pPattern->m_pUndoMgr->Undo( m_pPattern );
			m_pPattern->m_fInUndo = FALSE;
		}
	}
}

void CPatternCtrl::OnEditMergeVariations() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdStripMgr *pIStripMgr;
	IMIDIMgr		  *pIMIDIMgr;

	ASSERT(m_pPatternDlg != NULL);
	if(m_pPatternDlg != NULL)
	{
		pIStripMgr = m_pPatternDlg->m_pIMIDIStripMgr;
		ASSERT( pIStripMgr != NULL);
		if( pIStripMgr != NULL)
		{
			pIStripMgr->AddRef();
			if(SUCCEEDED(pIStripMgr->QueryInterface(IID_IMIDIMgr, (void **) &pIMIDIMgr)))
			{
				pIMIDIMgr->MergeVariations( TRUE );
				RELEASE( pIMIDIMgr );
			}

			RELEASE( pIStripMgr );
		}
	}
}

void CPatternCtrl::OnUpdateEditMergeVariations(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdStripMgr	*pIStripMgr;
	IMIDIMgr			*pIMIDIMgr;
	BOOL				fEnable = FALSE;

	ASSERT(m_pPatternDlg != NULL);
	if(m_pPatternDlg != NULL)
	{
		pIStripMgr = m_pPatternDlg->m_pIMIDIStripMgr;
		ASSERT( pIStripMgr != NULL);
		if( pIStripMgr != NULL)
		{
			pIStripMgr->AddRef();
			if(SUCCEEDED(pIStripMgr->QueryInterface(IID_IMIDIMgr, (void **) &pIMIDIMgr)))
			{
				if( pIMIDIMgr->MergeVariations( FALSE ) == S_OK )
				{
					fEnable = TRUE;
				}
				RELEASE( pIMIDIMgr );
			}

			RELEASE( pIStripMgr );
		}
	}
	pCmdUI->Enable( fEnable );
}

void CPatternCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}

void CPatternCtrl::OnEditDeletePart() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IMIDIMgr *pIMIDIMgr;
	if ( m_pPatternDlg != NULL )
	{
		if ( m_pPatternDlg->m_pIMIDIStripMgr != NULL )
		{
			if(SUCCEEDED(m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr )))
			{
				pIMIDIMgr->DeleteTrack();
				RELEASE( pIMIDIMgr );
			}
		}
	}
}

void CPatternCtrl::OnUpdateEditDeletePart(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Ask the MIDIMgr if we can delete a track
	BOOL fCanDelete = FALSE;
	IMIDIMgr *pIMIDIMgr;
	if ( m_pPatternDlg != NULL )
	{
		if ( m_pPatternDlg->m_pIMIDIStripMgr != NULL )
		{
			if(SUCCEEDED(m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IMIDIMgr, (void**) &pIMIDIMgr )))
			{
				if( pIMIDIMgr->CanDeleteTrack() == S_OK )
				{
					// Yes, we can
					fCanDelete = TRUE;
				}
				RELEASE( pIMIDIMgr );
			}
		}
	}

	pCmdUI->Enable( fCanDelete );
}

void CPatternCtrl::OnParentNotify(UINT message, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );
	ASSERT( m_pPattern != NULL );
	ASSERT( m_pPattern->m_pStyle != NULL );

	COleControl::OnParentNotify(message, lParam);
	
	// If the user pressed the left or right mouse buttons in our control,
	// change the active transport to this segment
	if( (message == WM_LBUTTONDOWN) ||
		(message == WM_RBUTTONDOWN) )
	{
		if( m_pPattern == m_pPattern->m_pIDocRootNode )
		{
			// if the Pattern isn't part of a Style, SetActiveTransport to NULL so
			// the Conductor knows that this isn't a playable Pattern (until
			// the music engine is updated to support Pattern w/o style playback
			theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( NULL, 0 );	
		}
		else
		{
			DWORD dwButtonState = BS_AUTO_UPDATE;
			if( m_pPatternDlg != NULL && m_pPatternDlg->m_punkMIDIStripMgr != NULL )
			{
				dwButtonState |= BS_RECORD_ENABLED;
				if( m_pPattern && m_pPattern->m_fRecordPressed )
				{
					dwButtonState |= BS_RECORD_CHECKED;
				}
			}
			theApp.m_pStyleComponent->m_pIConductor->SetActiveTransport( m_pPattern, dwButtonState );	
			theApp.m_pStyleComponent->m_pIConductor->SetTempo( m_pPattern, m_pPattern->m_pStyle->m_dblTempo, TRUE );
		}
	}
}

void SendCommandToTimeline( int nID, IDMUSProdTimeline *pITimelineCtl )
{
	VARIANT var;
	if( SUCCEEDED( pITimelineCtl->GetTimelineProperty( TP_ACTIVESTRIP, &var ) ) )
	{
		if( V_UNKNOWN(&var) )
		{
			IDMUSProdStrip *pIStrip;
			if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdStrip, (void**) &pIStrip ) ) )
			{
				pIStrip->OnWMMessage( WM_COMMAND, nID, 0, 0, 0 );
				pIStrip->Release();
			}
			V_UNKNOWN(&var)->Release();
		}
	}
}

void CPatternCtrl::OnEditQuantize() 
{
	// ID_EDIT_QUANTIZE must have the same value as in the MIDIStripMgr project
	SendCommandToTimeline( ID_EDIT_QUANTIZE, m_pPatternDlg->m_pITimelineCtl );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\PatternDlg.h ===
#ifndef __PATTERNDLG_H__
#define __PATTERNDLG_H__

// PatternDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPatternDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CPatternCtrl;
interface IDMUSProdTimeline;
interface IDMUSProdStripMgr;
interface IDMUSProdStrip;
class CDirectMusicStyle;

class CPatternDlg : public CFormView
{
public:
	CPatternDlg();
	virtual ~CPatternDlg();

	// Additional methods
	void EnableTimer( BOOL fEnable );
	void Activate( BOOL fActive );
	void UpdateZoomAndScroll( void );

protected:
	DECLARE_DYNCREATE(CPatternDlg)

// Form Data
public:
	//{{AFX_DATA(CPatternDlg)
	enum { IDD = IDD_DLG_PATTERN };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
private:
	short				m_nTimerID;			// Used to display transport cursor
	BOOL				m_fActive;

public:
	CPatternCtrl*		m_pPatternCtrl;
	IDMUSProdTimeline*	m_pITimelineCtl;
	IDMUSProdStripMgr*	m_pIMIDIStripMgr;
	IUnknown*			m_punkMIDIStripMgr;
	CDirectMusicStyle*	m_pStyle;
	IDMUSProdStrip*		m_pActiveStripWhenWindowDeactivated;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPatternDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CPatternDlg)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	LRESULT OnApp( WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __PATTERNDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\PatternLengthDlg.cpp ===
// PatternLengthDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDll.h"
#include "Style.h"
#include "PatternLengthDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg dialog


CPatternLengthDlg::CPatternLengthDlg( CDirectMusicPattern* pPattern, CWnd* pParent /*=NULL*/)
	: CDialog(CPatternLengthDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPatternLengthDlg)
	//}}AFX_DATA_INIT

	ASSERT( pPattern != NULL );

	m_pPattern = pPattern;
}


void CPatternLengthDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPatternLengthDlg)
	DDX_Control(pDX, IDC_LENGTH, m_editLength);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LENGTH_SPIN, m_spinLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPatternLengthDlg, CDialog)
	//{{AFX_MSG_MAP(CPatternLengthDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg::OnInitDialog

BOOL CPatternLengthDlg::OnInitDialog() 
{
	ASSERT( m_pPattern != NULL );

	CDialog::OnInitDialog();

	// Set title
	CString strTitle;
	CString strContext;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );
	if( m_pPattern->m_wEmbellishment & EMB_MOTIF )
	{
		strContext.LoadString( IDS_MOTIF_TEXT );
	}
	else
	{
		strContext.LoadString( IDS_PATTERN_TEXT );
	}
	AfxFormatString1( strTitle, IDS_SET_LENGTH, strContext );
	AfxSetResourceHandle( hInstance );
	SetWindowText( strTitle );

	// Set length
	m_editLength.LimitText( 3 );
	m_spinLength.SetRange( MIN_PATTERN_LENGTH, MAX_PATTERN_LENGTH );
	m_spinLength.SetPos( m_pPattern->m_wNbrMeasures );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CPatternLengthDlg::OnOK

void CPatternLengthDlg::OnOK() 
{
	ASSERT( m_pPattern != NULL );

	CString strNewNbrMeasures;

	m_editLength.GetWindowText( strNewNbrMeasures );

	// Strip leading and trailing spaces
	strNewNbrMeasures.TrimRight();
	strNewNbrMeasures.TrimLeft();

	WORD wNewNbrMeasures = (WORD)( _ttoi( strNewNbrMeasures ) );

	// Validate new length
	if( wNewNbrMeasures < MIN_PATTERN_LENGTH
	||  wNewNbrMeasures > MAX_PATTERN_LENGTH )
	{
		CString strMsg;
		CString strMin;
		CString strMax;
		
		strMin.Format( "%d", MIN_PATTERN_LENGTH );
		strMax.Format( "%d", MAX_PATTERN_LENGTH );
		
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( theApp.m_hInstance );
		AfxFormatString2( strMsg, IDS_ERR_MIN_MAX, strMin, strMax );
		AfxSetResourceHandle( hInstance );
		AfxMessageBox( strMsg );
		return;
	}

	m_pPattern->SetNbrMeasures( wNewNbrMeasures );

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Personality.h ===
#ifndef __PERSONALITY_H__
#define __PERSONALITY_H__

interface IDMUSProdRIFFStream;

// Personality.h : header file
//

class CDirectMusicStyle;

class CPersonality
{
friend class CDirectMusicStyle;

public:
    CPersonality();
	~CPersonality();

    HRESULT DM_SavePersonalityRefChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_LoadPersonalityRef( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT IMA25_LoadPersonalityRef( IStream* pIStream, MMCKINFO* pckMain );

private:
// Personality Reference data for Music Engine
    CString			   m_strName;
	CString			   m_strFileName;
    GUID			   m_guid;
    BYTE			   m_fDefault;           // 1=Default personality
};

#endif // __PERSONALITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Personality.cpp ===
// Personality.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Personality.h"
#include "RiffStrm.h"
#include <dmusicf.h>
#include "RiffStructs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPersonality constructor/destructor

CPersonality::CPersonality()
{
	m_fDefault = FALSE;

    memset( &m_guid, 0, sizeof( GUID ) );
}

CPersonality::~CPersonality()
{
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::DM_SavePersonalityRefChunk

HRESULT CPersonality::DM_SavePersonalityRefChunk( IDMUSProdRIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr = S_OK;
    MMCKINFO ckMain;
    MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( pIRiffStream == NULL )
	{
		hr = E_INVALIDARG;
		goto ON_ERROR;
	}

	// Write REF LIST header
	ckMain.fccType = DMUS_FOURCC_REF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write REF chunk
	{
		DMUS_IO_REFERENCE dmusReference;

		ck.ckid = DMUS_FOURCC_REF_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare DMUS_IO_REFERENCE structure
		memset( &dmusReference, 0, sizeof(DMUS_IO_REFERENCE) );
		dmusReference.guidClassID = CLSID_DirectMusicChordMap;
		dmusReference.dwValidData = (DMUS_OBJ_CLASS | DMUS_OBJ_NAME | DMUS_OBJ_FILENAME);

		// Write REF chunk data 
		hr = pIStream->Write( &dmusReference, sizeof(DMUS_IO_REFERENCE), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_REFERENCE) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Name chunk
	{
		ck.ckid = DMUS_FOURCC_NAME_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Filename chunk
	{
		ck.ckid = DMUS_FOURCC_FILE_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strFileName );
		if( FAILED( hr ) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::DM_LoadPersonalityRef

HRESULT CPersonality::DM_LoadPersonalityRef( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pck )
{
    IStream* pIStream;
    HRESULT hr;
	MMCKINFO ck;
    DWORD dwSize;
    DWORD dwByteCount;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	while( pIRiffStream->Descend( &ck, pck, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case DMUS_FOURCC_REF_CHUNK:
			{
				DMUS_IO_REFERENCE dmusReference;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_REFERENCE ) );
				hr = pIStream->Read( &dmusReference, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Nothing to store at this time.....
				break;
			}

			case DMUS_FOURCC_NAME_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strName );
				break;

			case DMUS_FOURCC_FILE_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strFileName );
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
    pIStream->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CPersonality::IMA25_LoadPersonalityRef

HRESULT CPersonality::IMA25_LoadPersonalityRef( IStream* pIStream, MMCKINFO* pck )
{
    ioPersonalityRef iPersonalityRef;
    DWORD dwSize;
    WORD wStructSize;

    ASSERT( pIStream != NULL );

	// Read size of ioPersonalityRef structure
    dwSize = pck->cksize;
    pIStream->Read( &wStructSize, sizeof( wStructSize ), NULL );
    dwSize -= sizeof( wStructSize );

	// Read ioPersonalityRef structure
    if( wStructSize > sizeof(iPersonalityRef) )
    {
        pIStream->Read( &iPersonalityRef, sizeof(iPersonalityRef), NULL );
        StreamSeek( pIStream, wStructSize - sizeof(iPersonalityRef), STREAM_SEEK_CUR );
    }
    else
    {
        pIStream->Read( &iPersonalityRef, wStructSize, NULL );
    }
    dwSize -= wStructSize;

    m_strName = iPersonalityRef.wstrName;
    m_fDefault = iPersonalityRef.fDefault;
	memcpy( &m_guid, &iPersonalityRef.guid, sizeof( m_guid ) );

	// Read PersonalityRef filename (unicode format)
	if( dwSize > 0 )
	{
		ReadMBSfromWCS( pIStream, dwSize, &m_strFileName );
		m_strFileName += _T(".PER");
	}

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\RiffStructs.h ===
#ifndef __RIFFSTRUCTS_H__
#define __RIFFSTRUCTS_H__

#pragma pack(1)


/*
typedef struct ioNoteEvent
{
    long    lTime;           // When this event occurs.
    BYTE    bStatus;         // MIDI status.
    BYTE    bNote;           // Note value.
    BYTE    bVelocity;       // Note velocity.
    BYTE    bVoiceID;        // Band member who will play note
    WORD    wDuration;       // Lead line note duration. (Song)
    BYTE    bEventType;      // Type of event
} ioNoteEvent;
*/

typedef struct ioNote
{
    BYTE    bEventType;           // Type of event
    BYTE    bVoiceID;             // Instrument identifier.
    short   nTime;                // Time from center of beat.
    WORD    wVariation;           // 16 variation bits.
    BYTE    bScaleValue;          // Position in scale.
    BYTE    bBits;                // Various bits.
    BYTE    bValue;               // Note value.
    BYTE    bVelocity;            // Note velocity.
    WORD    nMusicValue;  // Description of note in chord and key.
    short   nDuration;            // Duration
    BYTE    bTimeRange;           // Range to randomize time.
    BYTE    bDurRange;            // Range to randomize duration.
    BYTE    bVelRange;            // Range to randomize velocity.
    BYTE    bPlayMode;
} ioNote;

/*
typedef struct ioCurveEvent
{
    long    lTime;
    WORD    wVariation;
    BYTE    bVoiceID;
    BYTE    bVelocity;
    BYTE    bEventType;
} ioCurveEvent;
*/

typedef struct ioCurve
{
    BYTE    bEventType;
    BYTE    bVoiceID;
    short   nTime;
    WORD    wVariation;
    BYTE    bCCData;
} ioCurve;


typedef struct ioSubCurve
{
    BYTE    bCurveType; // defines the shape of the curve
    char    fFlipped;  // flaggs defining the flipped state: not, vertical, or horizontal
    short   nMinTime;   // left lower corner of bounding box.
    short   nMinValue;  // also used by the ECT_INSTANT curve type.
    short   nMaxTime;   // right upper corner of bounding box.
    short   nMaxValue;
} ioSubCurve;


/*
typedef struct ioMute
{
    long    lTime;           // Time in clocks.
    WORD    wMuteBits;       // Which instruments to mute.
    WORD    wLock;          // Lock flag
} ioMute;
*/

/*
typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;
*/

/*
typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    BYTE    bRoot;         // root note of chord
    BYTE    bReserved;     // expansion room
    WORD    wCFlags;        // bit flags
	long	lReserved;		// expansion room
} ioChord;
*/

/*
enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
};
*/

/*
typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;
*/


#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;


/*
typedef struct ioBand
{
    wchar_t wstrName[20]; // Band name
    BYTE    abPatch[16];
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;    // This band is the style's default band
    char    chPad;
    WORD    awDLSBank[16];
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//    wchar_t wstrCollection[16];
    char    szCollection[32];           // this only needs to be single-wide chars
} ioBand;
*/

/*
typedef struct ioLyric
{
    long    lTime;       // Time, in clocks
} ioLyric;
*/

/*
typedef struct ioPhrase
{
    long    lTime;
    BYTE    bID;    // which phrase it is. Index starting at 0.
} ioPhrase;
*/

typedef struct ioClick
{
    short   lTime;               // Index into grid.
} ioClick;

typedef struct ioPattern
{
    long    lTime;             // Time this starts.
    DWORD   dwLength;           // Pattern length in clocks.
    DWORD   fFlags;            // Various flags.
    WORD    wClocksPerClick;   // Size of each click.
    WORD    wBeat;             // What note gets the beat.
    WORD    wClocksPerBeat;    // Size of each beat.
    WORD    wMeasures;         // Number of measures.
    wchar_t wstrName[16];         // Name of pattern.
    DWORD   dwKeyPattern;       // Key for defining in.
    DWORD   dwChordPattern;     // Defining chord.
    BYTE    abInvertUpper[16];   // Inversion upper limit.
    BYTE    abInvertLower[16];   // Inversion upper limit.
    WORD    wInvert;     // Activate inversion flags.
    WORD    awVarFlags[16][16]; // Var flags for all musicians.
    WORD    wAutoInvert;    // Automatically set inversion limits
    BYTE    bRoot;             // Root for defining.
    char    achChordChoice[16];
} ioPattern;

typedef struct ioStyle
{
    wchar_t wstrName[16];         // Each style has a name.
    WORD    wBPM;              // Beats per measure.
    WORD    wBeat;             // Beat note.
    WORD    wClocksPerClick;   // Clocks per click in patterns.
    WORD    wClocksPerBeat;    // Clocks per beat.
    WORD    wClocksPerMeasure; // Clocks per measure.
    WORD    wTempo;            // Tempo.
    WORD    wTempoFract;
    GUID    guid;
    wchar_t wstrCategory[16];
} ioStyle;

typedef struct ioPersonalityRef
{
    wchar_t wstrName[20];       // Internal name stored in personality
    char    fDefault;           // 1=Default personality
    char    achPad[3];
    GUID    guid;
} ioPersonalityRef;

#pragma pack()

#endif // __RIFFSTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by StyleDesignerDLL.rc
//
#define IDS_STYLE                       1
#define IDD_ABOUTBOX_STYLE              1
#define IDB_STYLE                       1
#define IDI_ABOUTDLL                    1
#define IDD_ABOUTBOX_PATTERN            2
#define IDB_PATTERN                     2
#define IDS_VARCHOICES                  2
#define IDS_PATTERN                     3
#define IDB_VARCHOICES                  3
#define IDD_ABOUTBOX_VARCHOICES         3
#define IDD_DLG_STYLE                   101
#define IDD_TAB_STYLE_STYLE             139
#define IDS_BROADCAST_SEG               156
#define IDS_BROADCAST_PERF              157
#define IDS_BROADCAST_APATH             171
#define IDS_BROADCAST_GRP               172
#define IDS_STYLE_FOLDER_NAME           205
#define IDC_PATTERN_LIST                205
#define IDS_STYLE_COMPONENT_NAME        206
#define IDD_DLG_PATTERN                 206
#define IDR_STYLE_DOCTYPE               207
#define IDC_MOTIF_LIST                  207
#define IDD_DLG_VARCHOICES              207
#define IDS_BAND_FOLDER_NAME            208
#define IDC_BAND_LIST                   208
#define IDC_PERSONALITY_LIST            209
#define IDS_ERR_MISSING_BAND_TRACK      210
#define IDS_PATTERN_FOLDER_NAME         211
#define IDS_MOTIF_FOLDER_NAME           214
#define IDC_TEMPO                       215
#define IDC_GROOVE_TOP                  216
#define IDD_TAB_MOTIF_LOOP              220
#define IDI_MOTIF_DOCTYPE_SEL           221
#define IDS_ERR_MISSING_CONDUCTOR       221
#define IDC_TIMELINECTL                 221
#define IDI_PATTERN_DOCTYPE_SEL         222
#define IDC_FILE_VERSION                222
#define IDS_ERR_VARCHOICES_PASTE        222
#define IDI_STYLE_DOCTYPE_SEL           223
#define IDC_ADDSTRIP_TRACK              223
#define IDS_ERR_MISSING_SEGMENT         223
#define IDM_PATTERN_NODE_RMENU          224
#define IDC_NAME                        224
#define IDI_FOLDER                      225
#define IDM_STYLE_NODE_RMENU            225
#define IDS_ERR_MISSING_BAND            225
#define IDC_AUTHOR                      225
#define IDI_FOLDER_SEL                  226
#define IDM_MOTIF_NODE_RMENU            226
#define IDS_ERR_REGISTER_CF             226
#define IDC_COPYRIGHT                   226
#define IDS_ERR_MEMORY                  227
#define IDM_STYLEBANDS_NODE_RMENU       227
#define IDC_VERSION_1                   227
#define IDS_ERR_ADD_DOCTYPE             228
#define IDM_STYLEPATTERNS_NODE_RMENU    228
#define IDC_VERSION_2                   228
#define IDS_ERR_ADD_IMAGELIST           229
#define IDM_STYLEMOTIFS_NODE_RMENU      229
#define IDI_STYLEREF                    229
#define IDD_ADDSTRIP                    229
#define IDC_VERSION_3                   229
#define IDS_STYLE_TEXT                  230
#define IDI_STYLEREF_SEL                230
#define IDD_TAB_STYLE_INFO              230
#define IDC_VERSION_4                   230
#define IDS_PATTERN_TEXT                231
#define IDC_SUBJECT                     231
#define IDD_TAB_PATTERN_PATTERN         231
#define IDR_MOTIF_DOCTYPE               231
#define IDS_MOTIF_TEXT                  232
#define IDC_CATEGORY                    232
#define IDD_TAB_MOTIF_MOTIF             232
#define IDR_PATTERN_DOCTYPE             232
#define IDS_ERR_ADD_CLIPFORMAT          233
#define IDC_LENGTH                      233
#define IDD_PATTERN_LENGTH              233
#define IDS_VARIATIONS_TEXT             234
#define IDC_TEMPO_SPIN                  234
#define IDD_TIME_SIGNATURE              234
#define IDS_NOT_SAVED                   235
#define IDB_GRIDS_PER_BEAT              235
#define IDC_GROOVE_TOP_SPIN             235
#define IDD_TAB_VARCHOICES              235
#define IDC_LENGTH_SPIN                 236
#define IDS_VARCHOICES_VERSION_TEXT     236
#define IDD_CUSTOM_RHYTHM               236
#define IDR_STYLE_EDITOR                237
#define IDS_PATTERN_VERSION_TEXT        237
#define IDC_BEAT                        237
#define IDR_PATTERN_EDITOR              238
#define IDS_STYLE_VERSION_TEXT          238
#define IDR_PATTERN_ACCELS              238
#define IDC_TIME_SIGNATURE              238
#define IDC_GRID                        238
#define IDC_SPLITTER                    238
#define IDR_MOTIF_EDITOR                239
#define IDS_DUPE_PATTERN_NAME           239
#define IDC_BPM                         239
#define IDR_STYLE_ACCELS                239
#define IDS_DUPE_MOTIF_NAME             240
#define IDC_BPM_SPIN                    240
#define IDR_VARCHOICES_ACCELS           240
#define IDS_TRACK                       241
#define IDC_CUSTOM_ID_SPIN              241
#define IDM_STYLEREF_NODE_RMENU         242
#define IDS_DUPE_BAND_NAME              242
#define IDM_DRAG_RMENU                  243
#define IDD_PART_LINK                   243
#define IDS_NEW_PATTERN_TEXT            243
#define IDC_GROOVE_BOTTOM               244
#define IDR_VARCHOICES_EDITOR           244
#define IDD_DLG_GUID                    244
#define IDS_NEW_MOTIF_TEXT              244
#define IDC_GROOVE_BOTTOM_SPIN          245
#define IDD_NEW_PATTERN                 245
#define IDS_CREATE_NEW_PATTERN_TEXT     245
#define IDM_VARCHOICES_RMENU            246
#define IDM_VARCHOICES_ROW_RMENU        246
#define IDS_CREATE_NEW_MOTIF_TEXT       246
#define IDC_BAND_COMBO                  247
#define IDS_MOTIF_IN_PAREN_TEXT         247
#define IDC_BAND_DEFAULT                248
#define IDS_MISSING_PATTERN             248
#define IDC_CUSTOM_ID                   248
#define IDC_EMB_FILL                    249
#define IDS_CREATE_LINK_PATTERN_TEXT    249
#define IDC_EMB_BREAK                   250
#define IDS_CREATE_LINK_MOTIF_TEXT      250
#define IDC_BAND_PROMPT                 251
#define IDC_EMB_END                     251
#define IDC_EMB_INTRO                   252
#define IDC_EMB_CUSTOM                  253
#define IDC_SEPARATOR_LINE              256
#define IDC_NAME_PROMPT                 257
#define IDC_SELECT_ROWS                 260
#define IDC_FLAGS                       261
#define IDC_ROW_HEADINGS                262
#define IDC_EDIT_LOOP_START_BAR         265
#define IDC_SPIN_LOOP_START_BAR         266
#define IDC_MAJOR                       267
#define IDC_EDIT_LOOP_START_BEAT        267
#define IDC_MINOR                       268
#define IDC_SPIN_LOOP_START_BEAT        268
#define IDC_OTHER                       269
#define IDC_EDIT_LOOP_START_GRID        269
#define IDC_FUNCTION                    270
#define IDC_SPIN_LOOP_START_GRID        270
#define IDC_VARIATION                   271
#define IDC_EDIT_LOOP_START_TICK        271
#define IDC_VARIATION_SPIN              272
#define IDC_SPIN_LOOP_START_TICK        272
#define IDC_EDIT_LOOP_END_BAR           273
#define IDC_SPIN_LOOP_END_BAR           274
#define IDC_EDIT_LOOP_END_BEAT          275
#define IDC_HEADING_1                   276
#define IDC_SPIN_LOOP_END_BEAT          276
#define IDC_HEADING_2                   277
#define IDC_EDIT_LOOP_END_GRID          277
#define IDC_HEADING_3                   278
#define IDC_SPIN_LOOP_END_GRID          278
#define IDC_HEADING_4                   279
#define IDC_EDIT_LOOP_END_TICK          279
#define IDC_SPIN_LOOP_END_TICK          280
#define IDC_EDIT_LOOP_REPEAT            281
#define IDC_SPIN_LOOP_REPEAT            282
#define IDC_EDIT_PLAY_START_BEAT        284
#define IDC_EDIT_PLAY_START_GRID        286
#define IDC_EDIT_PLAY_START_TICK        287
#define IDC_SPIN_PLAY_START_BAR         288
#define IDC_SPIN_PLAY_START_BEAT        289
#define IDC_SPIN_PLAY_START_GRID        290
#define IDC_SPIN_PLAY_START_TICK        291
#define IDC_EDIT_PLAY_START_BAR         292
#define IDC_RESET_LOOP                  294
#define IDC_CUSTOM_DLG                  295
#define IDC_GRID_SCROLL                 296
#define IDS_HELP_FILE_EXT               300
#define IDC_WHOLE                       300
#define IDC_HALF                        301
#define IDC_QUARTER                     302
#define IDC_RHYTHM_MAP                  302
#define IDC_CHECK_REPEAT_FOREVER        302
#define IDC_CLEAR                       303
#define IDC_LIST_PART                   304
#define IDC_EDIT_GUID                   305
#define IDC_NEW_GUID                    306
#define IDC_NEW_PATTERN                 308
#define IDC_LINK_PATTERN                309
#define IDC_CHECK_RESET_VAR_ORDER       312
#define IDB_GPB1                        501
#define IDB_GPB2                        502
#define IDB_GPB3                        503
#define IDB_GPB4                        504
#define IDB_GPB5                        505
#define IDB_GPB6                        506
#define IDB_GPB7                        507
#define IDB_GPB8                        508
#define IDB_GPB9                        509
#define IDB_GPBa10                      510
#define IDB_GPBa11                      511
#define IDB_GPBa12                      512
#define IDB_GPBa13                      513
#define IDB_GPBa14                      514
#define IDB_GPBa15                      515
#define IDB_GPBa16                      516
#define IDB_GPBa17                      517
#define IDB_GPBa18                      518
#define IDB_GPBa19                      519
#define IDB_GPBb20                      520
#define IDB_GPBb21                      521
#define IDB_GPBb22                      522
#define IDB_GPBb23                      523
#define IDB_GPBb24                      524
#define IDB_DISABLED                    525
#define IDB_SELECTED                    526
#define IDB_GPB1_ALT                    527
#define IDB_GPB2_ALT                    528
#define IDB_GPB3_ALT                    529
#define IDB_GPB4_ALT                    530
#define IDB_GPB6_ALT                    531
#define IDB_GPB8_ALT                    532
#define IDC_DEST_BOTTOM                 1003
#define IDC_DEST_BOTTOM_SPIN            1004
#define IDC_DEST_TOP                    1005
#define IDC_DEST_TOP_SPIN               1006
#define IDC_STYLE_FILENAME              1016
#define IDC_STYLE_INFO                  1017
#define IDC_INFO                        1017
#define IDS_CATEGORY1                   4000
#define IDS_CATEGORY2                   4001
#define IDS_CATEGORY3                   4002
#define IDS_CATEGORY4                   4003
#define IDS_CATEGORY5                   4004
#define IDS_CATEGORY6                   4005
#define IDS_CATEGORY7                   4006
#define IDS_CATEGORY8                   4007
#define IDS_CATEGORY9                   4008
#define IDS_CATEGORY10                  4009
#define IDS_CATEGORY11                  4010
#define IDS_CATEGORY12                  4011
#define IDS_CATEGORY13                  4012
#define IDS_CATEGORY14                  4013
#define IDS_CATEGORY15                  4014
#define IDS_NONE_TEXT                   4016
#define IDS_BEAT1                       4050
#define IDS_BEAT2                       4051
#define IDS_BEAT3                       4052
#define IDS_BEAT4                       4053
#define IDS_BEAT5                       4054
#define IDS_BEAT6                       4055
#define IDS_UNDO_STYLE_NAME             5000
#define IDS_UNDO_STYLE_TEMPO            5001
#define IDS_UNDO_STYLE_TIME_SIGNATURE   5002
#define IDS_UNDO_STYLE_AUTHOR           5003
#define IDS_UNDO_STYLE_COPYRIGHT        5004
#define IDS_UNDO_STYLE_INFO             5005
#define IDS_UNDO_STYLE_SUBJECT          5006
#define IDS_UNDO_STYLE_VERSION          5007
#define IDS_UNDO_STYLE_CATEGORY         5008
#define IDS_UNDO_DELETE_PATTERN         5009
#define IDS_UNDO_DELETE_MOTIF           5010
#define IDS_UNDO_DELETE_BAND            5011
#define IDS_UNDO_PATTERN_NAME           5012
#define IDS_UNDO_MOTIF_NAME             5013
#define IDS_UNDO_PATTERN_LENGTH         5014
#define IDS_UNDO_MOTIF_LENGTH           5015
#define IDS_UNDO_PATTERN_GROOVE_RANGE   5016
#define IDS_UNDO_PATTERN_RHYTHM_MAP     5017
#define IDS_UNDO_PATTERN_EMBELLISHMENT  5018
#define IDS_UNDO_PATTERN_DEST_GROOVE_RANGE 5019
#define IDS_UNDO_MOTIF_RESOLUTION       5020
#define IDS_UNDO_MOTIF_REPEATS          5021
#define IDS_UNDO_MOTIF_PLAYSTART        5022
#define IDS_UNDO_MOTIF_LOOPPOINTS       5023
#define IDS_UNDO_PATTERN_PART           5024
#define IDS_UNDO_PATTERN_PART_LINK      5025
#define IDS_UNDO_PATTERN_PART_UNLINK    5026
#define IDS_UNDO_STYLE_GUID             5027
#define IDS_UNDO_PATTERN_VARCHOICES_ENABLE 5028
#define IDS_UNDO_PATTERN_VARCHOICES_DISABLE 5029
#define IDS_UNDO_PATTERN_VARCHOICES_PASTE 5030
#define IDS_UNDO_PATTERN_VARCHOICES     5031
#define IDS_UNDO_PATTERN_VARCHOICES_MODE 5032
#define IDS_UNDO_STYLE_DEFAULT_BAND     5033
#define IDS_UNDO_PATTERN_FLAGS          5034
#define IDS_DM_FLAGS_TEXT_1             5600
#define IDS_DM_FLAGS_TEXT_2             5601
#define IDS_DM_FLAGS_TEXT_3             5602
#define IDS_DM_FLAGS_TEXT_4             5603
#define IDS_DM_FLAGS_TEXT_5             5604
#define IDS_DM_FLAGS_TEXT_6             5605
#define IDS_DM_FLAGS_TEXT_7             5606
#define IDS_DM_FLAGS_TEXT_8             5607
#define IDS_DM_FLAGS_TEXT_9             5608
#define IDS_DM_FLAGS_TEXT_10            5609
#define IDS_DM_FLAGS_TEXT_11            5610
#define IDS_DM_FLAGS_TEXT_12            5611
#define IDS_DM_FLAGS_TEXT_13            5612
#define IDS_DM_FLAGS_TEXT_14            5613
#define IDS_DM_FLAGS_TEXT_15            5614
#define IDS_DM_FLAGS_TEXT_16            5615
#define IDS_DM_FLAGS_TEXT_17            5616
#define IDS_DM_FLAGS_TEXT_18            5617
#define IDS_DM_FLAGS_TEXT_19            5618
#define IDS_DM_FLAGS_TEXT_20            5619
#define IDS_DM_FLAGS_TEXT_21            5620
#define IDS_DM_FLAGS_TEXT_22            5621
#define IDS_DM_FLAGS_TEXT_23            5622
#define IDS_DM_FLAGS_TEXT_24            5623
#define IDS_DM_FLAGS_TEXT_25            5624
#define IDS_DM_FLAGS_TEXT_26            5625
#define IDS_DM_FLAGS_TEXT_27            5626
#define IDS_DM_FLAGS_TEXT_28            5627
#define IDS_DM_FLAGS_TEXT_29            5628
#define IDS_DM_FLAGS_TEXT_30            5629
#define IDS_IMA_FLAGS_TEXT_1            5700
#define IDS_IMA_FLAGS_TEXT_2            5701
#define IDS_IMA_FLAGS_TEXT_3            5702
#define IDS_IMA_FLAGS_TEXT_4            5703
#define IDS_IMA_FLAGS_TEXT_5            5704
#define IDS_IMA_FLAGS_TEXT_6            5705
#define IDS_IMA_FLAGS_TEXT_7            5706
#define IDS_IMA_FLAGS_TEXT_8            5707
#define IDS_IMA_FLAGS_TEXT_9            5708
#define IDS_IMA_FLAGS_TEXT_10           5709
#define IDS_IMA_FLAGS_TEXT_11           5710
#define IDS_IMA_FLAGS_TEXT_12           5711
#define IDS_IMA_FLAGS_TEXT_13           5712
#define IDS_IMA_FLAGS_TEXT_14           5713
#define IDS_IMA_FLAGS_TEXT_15           5714
#define IDS_INVALID_GUID                6000
#define ID_VIEW_PROPERTIES              32768
#define IDM_SAVE                        32770
#define IDM_REVERT                      32771
#define IDM_DELETE                      32773
#define ID_EDIT_PASTE_INSERT            32773
#define IDM_RENAME                      32774
#define ID_EDIT_PASTE_MERGE             32774
#define IDM_PROPERTIES                  32775
#define ID_EDIT_PASTE_OVERWRITE         32775
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_PROPERTIES              32778
#define ID_STYLE_SPECIALSTUFF           32781
#define IDM_SAVEAS                      32782
#define ID_EDIT_QUANTIZE                32783
#define IDM_NEW_BAND                    32784
#define IDM_NEW_MOTIF                   32785
#define ID_EDIT_UNLINK                  32786
#define IDM_NEW_PATTERN                 32787
#define ID_PATTERN_NEWSTRIP             32794
#define ID_EDIT_INSERT                  32796
#define IDM_ENABLE                      32802
#define IDM_DISABLE                     32803
#define IDM_DRAG_MOVE                   32806
#define IDM_IMA_MODE                    32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DM_MODE                     32807
#define IDM_DRAG_COPY                   32808
#define IDM_CUT                         32808
#define IDM_COPY                        32809
#define IDM_PASTE                       32810
#define ID_EDIT_MERGE_VARIATIONS        32812
#define IDM_PATTERN_FROMMIDI            32813
#define IDM_MOTIF_FROMMIDI              32814
#define IDM_HELP_FINDER                 32815
#define IDM_HELP_INDEX                  32816
#define ID_EDIT_DELETE_PART             32817
#define IDS_ERR_INVALIDARG              57645
#define IDS_SAVE_TEXT                   57646
#define IDS_SAVE_AS_TEXT                57647
#define IDS_REVERT_TEXT                 57648
#define IDS_STYLE_OBJECT_TEXT           57657
#define IDS_NO_STYLE                    57658
#define IDS_ERR_STYLENOTFOUND           57659
#define IDS_ERR_NOPLAYSECTION           57660
#define IDS_SET_LENGTH                  57661
#define IDS_ERR_MIN_MAX                 57662
#define IDS_SET_TIME_SIGNATURE          57663
#define IDS_ERR_BEAT                    57664
#define IDS_ERR_GRIDS_PER_BEAT          57665
#define IDS_UNDO                        57666
#define IDS_REDO                        57667
#define IDS_UNDO_ACCEL                  57668
#define IDS_REDO_ACCEL                  57669
#define IDS_IMPORT_PATTERN_FROMMIDI     57670
#define IDS_MIDI_FILEEXT                57671
#define IDS_MIDI_FILEDESC               57672
#define IDS_UNNAMED_PARTREF             57673
#define IDS_SELECT_PARTREF_TEMPL        57674
#define IDS_IMPORT_MOTIF_FROMMIDI       57675
#define IDS_MIDI_DEFAULT_FILEEXT        57676
#define IDS_ERR_CANNOT_IMPORT_FILE      57677
#define IDS_SELECT_BCAST_PARTREF_TEMPLATE 57678

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        246
#define _APS_NEXT_COMMAND_VALUE         32818
#define _APS_NEXT_CONTROL_VALUE         313
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\RhythmDlg.h ===
#if !defined(AFX_RHYTHMDLG_H__DDA3C785_3389_11D2_89B4_00C04FD912C8__INCLUDED_)
#define AFX_RHYTHMDLG_H__DDA3C785_3389_11D2_89B4_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RhythmDlg.h : header file
//


#define MEASURE_LINE_COLOR		RGB(0,0,255)
#define BEAT_LINE_COLOR			RGB(255,0,255)


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid window

class CRhythmGrid : public CButton
{
friend class CRhythmDlg;

// Construction
public:
	CRhythmGrid();

// Attributes
public:
	CRhythmDlg*	m_pRhythmDlg;

// Operations
protected:
	void DrawOneBeat( CDC* pDC, long lBeat, BOOL fDrawOne );
	void DrawBeats( CDC* pDC, long lStartBeat );
	void DrawMeasureBeatLines( CDC* pDC, long lStartBeat );
	void DrawEntireGrid( CDC* pDC );
	int GetBeatsPerRhythmGrid();
	void SetClipRect( CDC* pDC );
	void GetGridRect( CRect* pRectGrid );
	long FindBeat( int nXPos, int nYPos );
	BOOL IsBeatChecked( long lBeat );
	void SetBeat( long lBeat, BOOL fRedraw );
	void ShiftClick( long lBeat );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRhythmGrid)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CRhythmGrid();

	// Generated message map functions
protected:
	//{{AFX_MSG(CRhythmGrid)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg dialog

class CRhythmDlg : public CDialog
{
friend class CRhythmGrid;

// Construction
public:
	CRhythmDlg( CWnd* pParent = NULL );
	virtual ~CRhythmDlg();

// Dialog Data
	//{{AFX_DATA(CRhythmDlg)
	enum { IDD = IDD_CUSTOM_RHYTHM };
	CScrollBar	m_scrollGrid;
	//}}AFX_DATA

// Member variables
private:
	CFont*					m_pFont;
	CRhythmGrid				m_btnGrid;			// Subclasses IDC_GRID

public:
	DWORD*					m_pRhythmMap;		// Variable array of rhythms for chord matching
	DirectMusicTimeSig		m_TimeSignature;	// Pattern time signature
	WORD					m_wNbrMeasures;		// Pattern length in measures

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRhythmDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRhythmDlg)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClear();
	afx_msg void OnHalf();
	afx_msg void OnQuarter();
	afx_msg void OnWhole();
	afx_msg void OnDestroy();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RHYTHMDLG_H__DDA3C785_3389_11D2_89B4_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Splitter.cpp ===
// Splitter.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Splitter.h"
#include "StyleDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//*****************************************************************************
//***** CSplitter
//*****************************************************************************

BEGIN_MESSAGE_MAP(CSplitter, CWnd)
	//{{AFX_MSG_MAP(CSplitter)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
	ON_WM_CAPTURECHANGED()
END_MESSAGE_MAP()

//*****************************************************************************
CSplitter::CSplitter() :
	m_rcTrack(0, 0, 0, 0),
	m_fTracking(FALSE),
	m_fVisible(FALSE),
	m_nTopBorder(0),
	m_pParent(NULL)
{
}

//*****************************************************************************
CSplitter::~CSplitter()
{
}

//*****************************************************************************
BOOL CSplitter::Create( CWnd *pParent, RECT *rect )
{
	UNREFERENCED_PARAMETER(rect);

	// Save our parent
	m_pParent = pParent;

	// Create our splitter class
	WNDCLASS wc;

	ZeroMemory( &wc, sizeof(wc) );
	wc.lpszClassName = "JzStyleSplitter";
	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_PARENTDC;
	wc.lpfnWndProc   = ::DefWindowProc;
	wc.hInstance     = theApp.m_hInstance;
	wc.hCursor       = ::LoadCursor( theApp.m_hInstance, MAKEINTRESOURCE(IDC_SPLITTER) );
	wc.hbrBackground = (HBRUSH)( COLOR_BTNFACE + 1 );

	// Register our splitter class
	AfxRegisterClass( &wc );

	// Create our splitter
	return CWnd::Create( wc.lpszClassName, "", WS_VISIBLE | WS_CHILD, 
						 CRect(0, 0, 0, 0), pParent, IDC_SPLITTER );
}

//*****************************************************************************
void CSplitter::SetTopBorder( int nTopBorder )
{
	m_nTopBorder = nTopBorder;
}

//*****************************************************************************
void CSplitter::OnPaint()
{
	CPaintDC dc( this );
	CBrush brush;

	if( brush.CreateSolidBrush( GetSysColor(COLOR_BTNFACE) ) )
	{
		CRect rect;
		GetClientRect( &rect );

		CBrush* pOldBrush = dc.SelectObject( &brush );
		dc.FillRect( &rect, &brush );
		dc.SelectObject( pOldBrush );
	}		
}

//*****************************************************************************
void CSplitter::OnLButtonDown( UINT /*nFlags*/, CPoint /*point*/ )
{
	ASSERT( m_pParent != NULL );

	// Capture the mouse
	SetCapture();

	// Set our initial splitter position in our parent's client coordinates
	GetWindowRect( &m_rcTrack );
	m_pParent->ScreenToClient( &m_rcTrack );

	// Set our tracking flag
	m_fTracking = TRUE;

	// Draw our initial tracker
	InvertTracker();
}

//*****************************************************************************
void CSplitter::OnLButtonUp(UINT /*nFlags*/, CPoint /*point*/)
{
	ASSERT( m_pParent != NULL );

	BOOL fWasTracking = m_fTracking;

	OnEndCapture();

	if( fWasTracking )
	{
		CRect rect;
		m_pParent->GetClientRect( &rect );
		static_cast<CStyleDlg*>(m_pParent)->EndTrack( m_rcTrack.top );
	}
}

//*****************************************************************************
void CSplitter::OnMouseMove( UINT /*nFlags*/, CPoint point )
{
	if( m_fTracking )
	{
		ASSERT( m_pParent != NULL );

		// Convert point to client coordinates of our parent window
		ClientToScreen( &point );
		m_pParent->ScreenToClient( &point );

		// Get the client are of our parent
		CRect rcClient;
		m_pParent->GetClientRect( &rcClient );

		// Force the point to be in our client area
		int nDiff = m_nTopBorder + SPLITTER_HEIGHT + 1;
		if( (point.y - nDiff) < rcClient.top )
		{
			point.y = rcClient.top + nDiff;
		}
		nDiff = SPLITTER_HEIGHT + STYLE_DLG_BORDER + 4;
		if( (point.y + nDiff) > rcClient.bottom)
		{
			point.y = rcClient.bottom - nDiff;
		}

		// If the point has changed since the last mouse move, then update change
		if( m_rcTrack.top != point.y )
		{
			InvertTracker();
			m_rcTrack.top  = point.y;
			m_rcTrack.bottom = point.y + SPLITTER_HEIGHT;
			InvertTracker();
		}
	}
}

//*****************************************************************************
void CSplitter::OnCancelMode()
{
	OnEndCapture();
	CWnd::OnCancelMode();
}

//*****************************************************************************
void CSplitter::OnCaptureChanged( CWnd *pWnd )
{
	OnEndCapture();
	CWnd::OnCaptureChanged( pWnd );
}

//*****************************************************************************
void CSplitter::OnEndCapture()
{
	if( m_fVisible )
	{
		InvertTracker();
	}

	if( m_fTracking )
	{
		ReleaseCapture();
		m_fTracking = FALSE;
	}
}

//*****************************************************************************
void CSplitter::InvertTracker()
{
	ASSERT( m_pParent != NULL );

	// Get the DC of our parent window
	CDC *pDC = GetDC();
	ASSERT( pDC != NULL );

	// Create our inverted brush pattern 
	CBrush *pBrush = CDC::GetHalftoneBrush();

	// Select the brush into our DC  
	HBRUSH hBrushStock = NULL;
	if( pBrush != NULL )
	{
		hBrushStock = (HBRUSH)SelectObject( pDC->m_hDC, pBrush->m_hObject );
	}

	// Convert top
	CRect rect( m_rcTrack );

	m_pParent->ClientToScreen( &rect );
	ScreenToClient( &rect );

	// Draw our tracking line
	pDC->PatBlt( m_rcTrack.left, rect.top,
				 m_rcTrack.Width() - (STYLE_DLG_BORDER << 1), m_rcTrack.Height() + 1,
				 PATINVERT );

	// Free our brush and DC
	if( hBrushStock != NULL )
	{
		SelectObject( pDC->m_hDC, hBrushStock );
	}

	ReleaseDC( pDC );

	// Toggle visible flag
	m_fVisible = !m_fVisible;
}

//*****************************************************************************
BOOL CSplitter::OnEraseBkgnd( CDC* pDC ) 
{
	UNREFERENCED_PARAMETER(pDC);

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\RhythmDlg.cpp ===
// RhythmDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DllBasePropPageManager.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "Pattern.h"
#include "RhythmDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Static variables
static int sg_nBeatWidth = 0;
static int sg_nBeatHeight = 0;
static int sg_nBeatTop = 0;
static int sg_nMeasureTop = 0;

static int sg_nMinScrollPos = 0;
static int sg_nMaxScrollPos = 0;
static int sg_nBeatsPerScrollPos = 0;

static long sg_lFirstSelectedBeat = -1;
static long sg_lLastSelectedBeat = -1;
static int sg_nSetBeatState = -1;

static int sg_dwScrollTick = 0;

/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid button

/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid constructor/destructor

CRhythmGrid::CRhythmGrid()
{
}

CRhythmGrid::~CRhythmGrid()
{
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::GetBeatsPerRhythmGrid

int CRhythmGrid::GetBeatsPerRhythmGrid( void )
{
	// Get grid rectangle
	CRect rectGrid;
	GetGridRect( &rectGrid );

	// Determine number of beats that can fit in the grid
	return rectGrid.Width() / sg_nBeatWidth;
}



/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::GetGridRect

void CRhythmGrid::GetGridRect( CRect* pRectGrid )
{
	// Get grid rectangle
	GetClientRect( pRectGrid );
	pRectGrid->InflateRect( -2, -4 );	// Leave room for embossing
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::SetClipRect

void CRhythmGrid::SetClipRect( CDC* pDC )
{
	// Get grid rectangle
	CRect rectGrid;
	GetGridRect( &rectGrid );

	// Create region
	CRgn rgn;
	rgn.CreateRectRgn( rectGrid.left, rectGrid.top, rectGrid.right, rectGrid.bottom );
	pDC->SelectClipRgn( &rgn );
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::DrawOneBeat

void CRhythmGrid::DrawOneBeat( CDC* pDC, long lBeat, BOOL fDrawOne )
{
	int nScrollPos = m_pRhythmDlg->m_scrollGrid.GetScrollPos();
	long lStartBeat = nScrollPos * sg_nBeatsPerScrollPos;

	long lNbrBeats = (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure *
					 (long)m_pRhythmDlg->m_wNbrMeasures;
	if( lBeat < lStartBeat
	||  lBeat >= lNbrBeats )
	{
		return;
	}

	// Calc measure and beat offset
	long lMeasure = lBeat / (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;
	long lBeatOffset = lBeat % (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;

	// Get grid rectangle
	CRect rectGrid;
	GetGridRect( &rectGrid );

	// Get beat rectangle
	CRect rectBeat;
	rectBeat.top = sg_nBeatTop;
	rectBeat.bottom = rectBeat.top + sg_nBeatHeight;
	rectBeat.left = rectGrid.left + ((lBeat - lStartBeat) * sg_nBeatWidth) + 1;
	rectBeat.right = rectBeat.left + sg_nBeatWidth;
	rectBeat.InflateRect( -5, -4 );

	// Draw 'X'
	SetClipRect( pDC );
	if( lBeatOffset >= 32 )
	{
		CBrush brushHatch;

		// DirectMusic does not support chord rhythms for BPM's over 32
		if( brushHatch.CreateHatchBrush( HS_DIAGCROSS, pDC->GetNearestColor(RGB(50,50,50)) ) )
		{
			int nOldBackgroundMode = pDC->SetBkMode( TRANSPARENT );
			CBrush* pOldBrush = pDC->SelectObject( &brushHatch );
			pDC->SetBkColor( 0 );
			rectBeat.InflateRect( 5, 3 );
			pDC->PatBlt( rectBeat.left, rectBeat.top, rectBeat.right - rectBeat.left, rectBeat.bottom - rectBeat.top, PATINVERT );
			rectBeat.InflateRect( -5, -3 );
			pDC->SetBkMode( nOldBackgroundMode );
			pDC->SelectObject( pOldBrush );
			brushHatch.DeleteObject();
		}
	}
	else if( m_pRhythmDlg->m_pRhythmMap[lMeasure] & (1 << lBeatOffset)  ) 
	{
		// Prepare the pen
		CPen pen;
		CPen *pPenOld = NULL;

		if( fDrawOne )
		{
			if( pen.CreatePen( PS_SOLID, 2, ::GetSysColor(COLOR_WINDOWTEXT) ) )
			{
				 pPenOld = pDC->SelectObject(&pen);
			}
		}

		// Draw the 'X'
		pDC->MoveTo( rectBeat.left, rectBeat.top );
		pDC->LineTo( rectBeat.right, rectBeat.bottom );
		pDC->MoveTo( rectBeat.right, rectBeat.top );
		pDC->LineTo( rectBeat.left, rectBeat.bottom );

		// Delete the pen
		if( pPenOld )
		{
			pDC->SelectObject( pPenOld );
			pen.DeleteObject();
		}
	}
	else
	{
		rectBeat.InflateRect( 1, 1 );
		pDC->FillSolidRect( &rectBeat, ::GetSysColor(COLOR_WINDOW) );
		rectBeat.InflateRect( -1, -1 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::DrawBeats

void CRhythmGrid::DrawBeats( CDC* pDC, long lStartBeat )
{
	// Determine the last beat currently being displayed
	long lNbrBeats = (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure *
					 (long)m_pRhythmDlg->m_wNbrMeasures;
	long lMaxBeat = min( lStartBeat + GetBeatsPerRhythmGrid(), lNbrBeats ); 

	// Prepare the pen
	CPen pen;
	CPen *pPenOld = NULL;

	if( pen.CreatePen( PS_SOLID, 2, ::GetSysColor(COLOR_WINDOWTEXT) ) )
	{
		 pPenOld = pDC->SelectObject(&pen);
	}

	// Draw the measure/beat lines
	long lBeat = lStartBeat;
	while( lBeat <= lMaxBeat )
	{
		DrawOneBeat( pDC, lBeat, FALSE );
		lBeat++;
	}

	// Delete the pen
	if( pPenOld )
	{
		pDC->SelectObject( pPenOld );
		pen.DeleteObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::DrawMeasureBeatLines

void CRhythmGrid::DrawMeasureBeatLines( CDC* pDC, long lStartBeat )
{
	long lBeat = lStartBeat;
	long lNbrBeats = (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure *
					 (long)m_pRhythmDlg->m_wNbrMeasures;

	// Get grid rectangle
	CRect rectGrid;
	GetGridRect( &rectGrid );

	// Determine max right
	int nMaxRight = min( rectGrid.right, rectGrid.left + ((lNbrBeats - lBeat) * sg_nBeatWidth) );

	// Set drawing rectangle for lines
	CRect rectBeatLine;
	rectBeatLine.top = sg_nBeatTop;
	rectBeatLine.bottom = rectBeatLine.top + sg_nBeatHeight;
	rectBeatLine.left = rectGrid.left;
	rectBeatLine.right = rectBeatLine.left + sg_nBeatWidth;
	rectBeatLine.InflateRect( 0, -1 );

	// Draw top and bottom lines
	pDC->MoveTo( rectBeatLine.left, rectBeatLine.top );
	pDC->LineTo( nMaxRight, rectBeatLine.top );
	pDC->MoveTo( rectBeatLine.left, rectBeatLine.bottom );
	pDC->LineTo( nMaxRight, rectBeatLine.bottom );

	// Create the pens
	CPen* pPenMeasureLine = new CPen( PS_SOLID, 1, MEASURE_LINE_COLOR );
	ASSERT( pPenMeasureLine != NULL );
	CPen* pPenBeatLine = new CPen( PS_SOLID, 1, BEAT_LINE_COLOR );
	ASSERT( pPenBeatLine != NULL );

	// Set text color
	pDC->SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );

	// Save the current pen
	CPen* pPenOld = pDC->SelectObject( pPenMeasureLine );
	
	// Draw the measure/beat lines
	while( rectBeatLine.right <= nMaxRight)
	{
		long lRemainder = lBeat % (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;
		
		if( lRemainder == 0 )
		{
			// Get measure number text
			CString strMeasure;
			long lMeasure = lBeat / (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;
			strMeasure.Format( "%d", lMeasure + 1 );

			// Set drawing rectangle for measure number
			CRect rectNbr;
			rectNbr.top = sg_nMeasureTop;
			rectNbr.bottom = sg_nBeatTop - 1;
			rectNbr.left = rectBeatLine.left;
			rectNbr.right = rectNbr.left + (sg_nBeatWidth << 1);

			// Draw measure number
			pDC->DrawText( strMeasure, -1, &rectNbr, (DT_SINGLELINE | DT_LEFT | DT_BOTTOM | DT_NOPREFIX) );
		}

		if( lRemainder == (m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure - 1) )
		{
			// Draw end of measure line
			pDC->SelectObject( pPenMeasureLine );
		}
		else
		{
			// Draw beat line
			pDC->SelectObject( pPenBeatLine );
		}

		pDC->MoveTo( rectBeatLine.right, rectBeatLine.top );
		pDC->LineTo( rectBeatLine.right, rectBeatLine.bottom );

		
		rectBeatLine.left = rectBeatLine.right;
		rectBeatLine.right = rectBeatLine.left + sg_nBeatWidth;
		lBeat++;
	}

	// Restore the previous pen
	pDC->SelectObject( pPenOld );

	// Cleanup
	if( pPenMeasureLine )
	{
		pPenMeasureLine->DeleteObject();
		delete pPenMeasureLine;
	}
	if( pPenBeatLine )
	{
		pPenBeatLine->DeleteObject();
		delete pPenBeatLine;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::DrawEntireGrid

void CRhythmGrid::DrawEntireGrid( CDC* pDC )
{
	int nScrollPos = m_pRhythmDlg->m_scrollGrid.GetScrollPos();
	long lStartBeat = nScrollPos * sg_nBeatsPerScrollPos;

	// Draw measure/beat markers
	DrawMeasureBeatLines( pDC, lStartBeat );

	// Draw beats
	DrawBeats( pDC, lStartBeat );
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::FindBeat

long CRhythmGrid::FindBeat( int nXPos, int nYPos )
{
	long lTheBeat = -1;

	// Find the beat
	if( nYPos > (sg_nBeatTop - 4)
	&&  nYPos < ((sg_nBeatTop + sg_nBeatHeight) + 4) )
	{
		// Store the first beat that is displaying
		int nScrollPos = m_pRhythmDlg->m_scrollGrid.GetScrollPos();
		long lStartBeat = nScrollPos * sg_nBeatsPerScrollPos;

		// Calc number of beats in the Pattern
		long lNbrBeats = (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure *
						 (long)m_pRhythmDlg->m_wNbrMeasures;

		// Get grid rectangle
		CRect rectGrid;
		GetGridRect( &rectGrid );
		nXPos -= rectGrid.left;

		// Calc the beat
		long lBeat = lStartBeat + (nXPos / sg_nBeatWidth);
		if( lBeat < lNbrBeats )
		{
			lTheBeat = lBeat;
		}
	}

	return lTheBeat;
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::IsBeatChecked

BOOL CRhythmGrid::IsBeatChecked( long lBeat )
{
	long lNbrBeats = (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure *
					 (long)m_pRhythmDlg->m_wNbrMeasures;

	if( lBeat >= 0
	&&  lBeat < lNbrBeats )
	{
		// Calc measure and beat offset
		long lMeasure = lBeat / (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;
		long lBeatOffset = lBeat % (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;

		// See whether or not beat is checked
		if( (lBeatOffset < 32)
		&&  (m_pRhythmDlg->m_pRhythmMap[lMeasure] & (1 << lBeatOffset)) )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::SetBeat

void CRhythmGrid::SetBeat( long lBeat, BOOL fRedraw )
{
	ASSERT( sg_nSetBeatState != -1 );

	long lNbrBeats = (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure *
					 (long)m_pRhythmDlg->m_wNbrMeasures;

	if( lBeat >= 0
	&&  lBeat < lNbrBeats )
	{
		// Calc measure and beat offset
		long lMeasure = lBeat / (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;
		long lBeatOffset = lBeat % (long)m_pRhythmDlg->m_TimeSignature.m_bBeatsPerMeasure;
		
		// Check the beeat according to sg_nSetBeatState 
		if( lBeatOffset < 32 )
		{
			// Set the beat
			if( sg_nSetBeatState )
			{
				m_pRhythmDlg->m_pRhythmMap[lMeasure] |= (1 << lBeatOffset);
			}
			else
			{
				m_pRhythmDlg->m_pRhythmMap[lMeasure] &= ~(1 << lBeatOffset);
			}

			// Redraw the beat
			if( fRedraw )
			{
				CDC* pDC = GetDC();
				if( pDC )
				{
					DrawOneBeat( pDC, lBeat, TRUE );
					ReleaseDC( pDC );
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::ShiftClick

void CRhythmGrid::ShiftClick( long lBeat ) 
{
	ASSERT( m_pRhythmDlg != NULL );

	if( sg_lFirstSelectedBeat == -1 )
	{
		sg_lFirstSelectedBeat = lBeat;

		// Set sg_nSetBeatState
		if( IsBeatChecked( lBeat ) )
		{
			sg_nSetBeatState = FALSE;
		}
		else
		{
			sg_nSetBeatState = TRUE;
		}
	}
	sg_lLastSelectedBeat = lBeat;

	long lFirstBeat = sg_lFirstSelectedBeat <= sg_lLastSelectedBeat ?
					  sg_lFirstSelectedBeat : sg_lLastSelectedBeat; 
	long lLastBeat = sg_lFirstSelectedBeat <= sg_lLastSelectedBeat ?
					  sg_lLastSelectedBeat : sg_lFirstSelectedBeat; 

	// Set beats inside the range
	for( lBeat = lFirstBeat ;  lBeat <= lLastBeat ;  lBeat++ )
	{
		// Set the beat
		SetBeat( lBeat, FALSE );
	}

	// Initialize fields to force a new SHIFT-click operation
	if( lFirstBeat != lLastBeat )
	{
		sg_lFirstSelectedBeat = -1;
		sg_lLastSelectedBeat = -1;
		sg_nSetBeatState = -1;
	}

	Invalidate();
	UpdateWindow();
}


BEGIN_MESSAGE_MAP(CRhythmGrid, CButton)
	//{{AFX_MSG_MAP(CRhythmGrid)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
	ON_WM_ERASEBKGND()
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid message handlers

/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::OnLButtonDown

void CRhythmGrid::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	UNREFERENCED_PARAMETER(nFlags);

	ASSERT( m_pRhythmDlg != NULL );

	// Get the beat under the cursor
	long lBeat = FindBeat( point.x, point.y );
	if( lBeat != -1 )
	{
		// First set capture
		SetCapture();

		// See if the SHIFT key is down
		if( GetAsyncKeyState(VK_SHIFT) & 0x8000 )
		{
			// SHIFT key is down
			ShiftClick( lBeat );
		}
		else
		{
			// Reset SHIFT-click fields
			sg_lFirstSelectedBeat = -1;
			sg_lLastSelectedBeat = -1;

			// Toggle this beat
			if( IsBeatChecked( lBeat ) )
			{
				sg_nSetBeatState = FALSE;
			}
			else
			{
				sg_nSetBeatState = TRUE;
			}
			SetBeat( lBeat, TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::OnLButtonDblClk

void CRhythmGrid::OnLButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::OnLButtonUp

void CRhythmGrid::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	UNREFERENCED_PARAMETER(nFlags);
	UNREFERENCED_PARAMETER(point);

	ASSERT( m_pRhythmDlg != NULL );

	if( CWnd::GetCapture() == this )
	{
		::ReleaseCapture();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::OnMouseMove

void CRhythmGrid::OnMouseMove( UINT nFlags, CPoint point ) 
{
	UNREFERENCED_PARAMETER(nFlags);

	ASSERT( m_pRhythmDlg != NULL );

	if( CWnd::GetCapture() == this )
	{
		// Reset m_dwScrollTick to zero
		DWORD dwScrollTick = sg_dwScrollTick;
		sg_dwScrollTick = 0;

		// Get grid rect
		CRect rectGrid;
		GetGridRect( &rectGrid );

		// Get scroll position
		int nScrollPos = m_pRhythmDlg->m_scrollGrid.GetScrollPos();
		
		// Does position of cursor indicate user wants to scroll?
		short nDirection = -1;
		if( point.x > rectGrid.right )
		{
			if( nScrollPos < sg_nMaxScrollPos )
			{
				nDirection = SB_PAGERIGHT;
			}
		}
		else if( point.x < rectGrid.left )
		{
			if( nScrollPos > sg_nMinScrollPos )
			{
				nDirection = SB_PAGELEFT;
			}
		}
		if( nDirection != -1 )
		{
			// We may need to scroll
			DWORD dwTick = GetTickCount();
			if( dwScrollTick )
			{
				// scroll only if the proper amount of time has elapsed
				// since the last scroll
				if( dwTick >= dwScrollTick )
				{
					m_pRhythmDlg->SendMessage( WM_HSCROLL,
											   MAKELONG(nDirection, nScrollPos),
											   (LPARAM)m_pRhythmDlg->m_scrollGrid.m_hWnd );

					sg_dwScrollTick = dwTick + 350;	// wait 350 ms

					// Get new scroll position
					int nNewScrollPos = m_pRhythmDlg->m_scrollGrid.GetScrollPos();

					if( nNewScrollPos != nScrollPos )
					{
						long lScrollPosBeat = nScrollPos * sg_nBeatsPerScrollPos;
						long lNewScrollPosBeat = nNewScrollPos * sg_nBeatsPerScrollPos;
						if( nDirection == SB_PAGERIGHT )
						{
							lNewScrollPosBeat += (GetBeatsPerRhythmGrid() - 1);
							lScrollPosBeat += (GetBeatsPerRhythmGrid() - 1);
						}

						// Determine first/last beats
						long lFirstBeat = lNewScrollPosBeat <= lScrollPosBeat ?
										  lNewScrollPosBeat : lScrollPosBeat; 
						long lLastBeat  = lNewScrollPosBeat <= lScrollPosBeat ?
										  lScrollPosBeat : lNewScrollPosBeat; 

						// Update beats within the range
						for( long lBeat = lFirstBeat ;  lBeat <= lLastBeat ;  lBeat++ )
						{
							// Set the beat
							SetBeat( lBeat, FALSE );
						}

						// Redraw the grid
						Invalidate();
						UpdateWindow();
					}
				}
				else
				{
					sg_dwScrollTick = dwScrollTick;	// still waiting...
				}
			}
			else
			{
				sg_dwScrollTick = dwTick + 200;		// wait 200 ms
			}
			return;
		}

		// Handle the mouse move
		long lBeat = FindBeat( point.x, point.y );
		if( lBeat != -1 )
		{
			if( sg_nSetBeatState == -1 )
			{
				// Set sg_nSetBeatState
				if( IsBeatChecked( lBeat ) )
				{
					sg_nSetBeatState = FALSE;
				}
				else
				{
					sg_nSetBeatState = TRUE;
				}
			}

			// Set the beat
			SetBeat( lBeat, TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::OnEraseBkgnd

BOOL CRhythmGrid::OnEraseBkgnd( CDC* pDC ) 
{
	UNREFERENCED_PARAMETER(pDC);

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmGrid::DrawItem

void CRhythmGrid::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	ASSERT( m_pRhythmDlg != NULL );

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC )
	{
		CDC cdcMem;
		CBitmap bmpMem;
		CBitmap* pBitmapOld;
		CFont* pFontOld;
		int nBkModeOld;
		CRect rectGrid;

		// Calc grid width/height
		m_pRhythmDlg->m_btnGrid.GetClientRect( &rectGrid );
		int nGridWidth = rectGrid.Width();
		int nGridHeight = rectGrid.Height();

		// Create memory DC and bitmap
		if( cdcMem.CreateCompatibleDC( pDC ) == FALSE
		||  bmpMem.CreateCompatibleBitmap( pDC, nGridWidth, nGridHeight ) == FALSE )
		{
			return;
		}

		// Prepare memory DC
		pBitmapOld = cdcMem.SelectObject( &bmpMem );
		pFontOld = cdcMem.SelectObject( m_pRhythmDlg->m_pFont );
		nBkModeOld = cdcMem.SetBkMode( TRANSPARENT );
		
		// Erase memory DC background
		cdcMem.FillSolidRect( &rectGrid, ::GetSysColor(COLOR_WINDOW) );
		cdcMem.DrawEdge( &rectGrid, EDGE_SUNKEN, BF_RECT );

		// Draw the grid
		DrawEntireGrid( &cdcMem );
		pDC->BitBlt( 0, 0, nGridWidth, nGridHeight,
					 &cdcMem, 0, 0, SRCCOPY );

		// Cleanup memory DC
		cdcMem.SelectObject( pBitmapOld );
		cdcMem.SelectObject( pFontOld );
		cdcMem.SetBkMode( nBkModeOld );
		cdcMem.DeleteDC();
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg dialog

CRhythmDlg::CRhythmDlg( CWnd* pParent /*=NULL*/ )
			: CDialog( CRhythmDlg::IDD, pParent )
{
	//{{AFX_DATA_INIT(CRhythmDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pRhythmMap = NULL;
	m_wNbrMeasures = 0;
	m_pFont = NULL;
}

CRhythmDlg::~CRhythmDlg()
{
	if( m_pRhythmMap )
	{
		delete [] m_pRhythmMap;
	}
}


void CRhythmDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRhythmDlg)
	DDX_Control(pDX, IDC_GRID_SCROLL, m_scrollGrid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRhythmDlg, CDialog)
	//{{AFX_MSG_MAP(CRhythmDlg)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_BN_CLICKED(IDC_HALF, OnHalf)
	ON_BN_CLICKED(IDC_QUARTER, OnQuarter)
	ON_BN_CLICKED(IDC_WHOLE, OnWhole)
	ON_WM_DESTROY()
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnInitDialog

BOOL CRhythmDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();
	
	ASSERT( m_pRhythmMap != NULL );
	ASSERT( m_pFont != NULL );

	// Subclass controls
	m_btnGrid.SubclassDlgItem( IDC_GRID, this );
	m_btnGrid.m_pRhythmDlg = this;

	// Get grid rectangle
	CRect rectGrid;
	m_btnGrid.GetGridRect( &rectGrid );

	// Set static variables
	{
		sg_nBeatWidth = 16;
		sg_nBeatHeight = 17;

		sg_nBeatTop = rectGrid.bottom - sg_nBeatHeight - 1; 
		sg_nMeasureTop = sg_nBeatTop - sg_nBeatHeight - 1;
		
		sg_lFirstSelectedBeat = -1;
		sg_lLastSelectedBeat = -1;
		sg_nSetBeatState = -1;

		long lNbrBeats = (long)m_TimeSignature.m_bBeatsPerMeasure * (long)m_wNbrMeasures;
		sg_nBeatsPerScrollPos = min( m_TimeSignature.m_bBeatsPerMeasure, m_btnGrid.GetBeatsPerRhythmGrid() );
		sg_nMinScrollPos = 0;
		sg_nMaxScrollPos = lNbrBeats / sg_nBeatsPerScrollPos;
		if( !(lNbrBeats % sg_nBeatsPerScrollPos) )
		{
			sg_nMaxScrollPos--;
		}

		sg_dwScrollTick = 0;
	}

	// Set scroll range
	m_scrollGrid.SetScrollRange( sg_nMinScrollPos, sg_nMaxScrollPos, FALSE );
	m_scrollGrid.SetScrollPos( sg_nMinScrollPos );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnCreate

int CRhythmDlg::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Create Font
	m_pFont = new CFont;
	if( m_pFont == NULL )
	{
		return FALSE;
	}
	if( m_pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 							 DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							 DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) == FALSE )
	{
		return FALSE;
	}

	if( CDialog::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	// TODO: Add your specialized creation code here
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnDestroy

void CRhythmDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnDestroy();

	// Delete normal font
	if( m_pFont )
	{
		m_pFont->DeleteObject();
		delete m_pFont;
		m_pFont = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnClear

void CRhythmDlg::OnClear() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(	m_pRhythmMap )
	{
		for( int i = 0 ;  i < m_wNbrMeasures ;  ++i )
		{
			m_pRhythmMap[i] = 0;
		}

		m_btnGrid.Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnHalf

void CRhythmDlg::OnHalf() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pRhythmMap )
	{
		int nHalfway = m_TimeSignature.m_bBeatsPerMeasure >> 1;
		if( m_TimeSignature.m_bBeatsPerMeasure % 2 )
		{
			nHalfway++;
		}
		if( nHalfway >= 32 )
		{
			nHalfway = 0;
		}

		DWORD dwRhythm = (1 << nHalfway) | 0x01;	// Turn on halfway point and start of measure

		for( int i = 0 ;  i < m_wNbrMeasures ;  ++i )
		{
			m_pRhythmMap[i] = dwRhythm;
		}

		m_btnGrid.Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnQuarter

void CRhythmDlg::OnQuarter() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pRhythmMap )
	{
		for( int i = 0 ;  i < m_wNbrMeasures ;  ++i )
		{
			m_pRhythmMap[i] = 0xFFFFFFFF;
		}

		m_btnGrid.Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnWhole

void CRhythmDlg::OnWhole() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pRhythmMap )
	{
		for( int i = 0 ;  i < m_wNbrMeasures ;  ++i )
		{
			m_pRhythmMap[i] = 0x01;
		}

		m_btnGrid.Invalidate();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CRhythmDlg::OnHScroll

void CRhythmDlg::OnHScroll( UINT nSBCode, UINT nThumbPos, CScrollBar* pScrollBar ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if( pScrollBar->GetDlgCtrlID() != IDC_GRID_SCROLL )
	{
		CDialog::OnHScroll( nSBCode, nThumbPos, pScrollBar );
		return;
	}
	int nCurPos = pScrollBar->GetScrollPos();

	int nNewPos = nCurPos;
	
	switch( nSBCode )
	{
		case SB_LEFT:
			nNewPos = sg_nMinScrollPos;
			break;

		case SB_RIGHT:
			nNewPos = sg_nMaxScrollPos;
			break;

		case SB_LINELEFT:
			nNewPos--;
			nNewPos = max( nNewPos, sg_nMinScrollPos ); 
			break;

		case SB_LINERIGHT:
			nNewPos++;
			nNewPos = min( nNewPos, sg_nMaxScrollPos ); 
			break;

		case SB_PAGELEFT:
			nNewPos = nCurPos - (m_btnGrid.GetBeatsPerRhythmGrid() / sg_nBeatsPerScrollPos);
			nNewPos = max( nNewPos, sg_nMinScrollPos ); 
			break;

		case SB_PAGERIGHT:
			nNewPos = nCurPos + (m_btnGrid.GetBeatsPerRhythmGrid() / sg_nBeatsPerScrollPos);
			nNewPos = min( nNewPos, sg_nMaxScrollPos ); 
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			nNewPos = nThumbPos;
			break;
	}

	if( nNewPos != nCurPos )
	{
		pScrollBar->SetScrollPos( nNewPos );
		m_btnGrid.Invalidate();
		m_btnGrid.UpdateWindow();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Splitter.h ===
#ifndef __SPLITTER_H__
#define __SPLITTER_H__

// Splitter.h : header file
//

#define SPLITTER_HEIGHT			3
#define STYLE_DLG_BORDER		2

/////////////////////////////////////////////////////////////////////////////
// CSplitter class

class CSplitter : public CWnd
{
protected:
   CRect	m_rcTrack;
   BOOL		m_fTracking;
   BOOL		m_fVisible;
   int		m_nTopBorder;
   CWnd		*m_pParent;

public:
   CSplitter();
   BOOL Create(CWnd *pParent, RECT *rect = NULL);
   void SetTopBorder( int nTopBorder );

protected:
   void OnEndCapture();
   void InvertTracker();

   //{{AFX_VIRTUAL(CSplitter)
   //}}AFX_VIRTUAL

public:
   virtual ~CSplitter();

protected:
   //{{AFX_MSG(CSplitter)
   afx_msg void OnPaint();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnCancelMode();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
   afx_msg void OnCaptureChanged(CWnd *pWnd);
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __SPLITTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StdAfx.h ===
#if !defined(STDAFX_H__3BD2BA19_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define STDAFX_H__3BD2BA19_46E7_11D0_89AC_00A0C9054129__INCLUDED_

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <Afxdisp.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(STDAFX_H__3BD2BA19_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleBands.h ===
#ifndef __STYLEBANDS_H__
#define __STYLEBANDS_H__

// StyleBands.h : header file
//

#include <afxtempl.h>

class CDirectMusicStyle;

class CStyleBands : public IDMUSProdNode
{
friend class CDirectMusicStyle;
friend class CStyleDlg;

public:
    CStyleBands();
	~CStyleBands();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
    HRESULT InsertChildNodeAtPos( IDMUSProdNode* pIChildNode, IDMUSProdNode* pIPositionNode );

public:
	BOOL IsDirty();
	void SetModified( BOOL fModified );
	void CleanUp();

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstBands;
	CDirectMusicStyle*		m_pStyle;
	BOOL					m_fModified;
	BOOL					m_fInCleanUp;
};

#endif // __STYLEBANDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Style.cpp ===
// Style.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"

#include "Style.h"
#include "Pattern.h"
#include "Personality.h"
#include "PatternDlg.h"
#include "PatternCtl.h"
#include <mmreg.h>
#include <math.h>
#include <ioDMStyle.h>
#include "TabStyleStyle.h"
#include "TabStyleInfo.h"
#include "StyleCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {06776460-C27E-11d0-8AC1-444553540000}
static const GUID GUID_StylePropPageManager = 
{ 0x6776460, 0xc27e, 0x11d0, { 0x8a, 0xc1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };

// {16B7FC40-84F7-11d1-8AC1-444553540000}
static const GUID GUID_StyleUndo = 
{ 0x16b7fc40, 0x84f7, 0x11d1, { 0x8a, 0xc1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };


short CStylePropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CStylePropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CStylePropPageManager::CStylePropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabStyle = NULL;
	m_pTabInfo = NULL;
}

CStylePropPageManager::~CStylePropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabStyle )
	{
		delete m_pTabStyle;
	}

	if( m_pTabInfo )
	{
		delete m_pTabInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager::RemoveCurrentObject

void CStylePropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IUnknown implementation

HRESULT CStylePropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStylePropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CStylePropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CStylePropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_STYLE_TEXT );

	CDirectMusicStyle *pStyle;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pStyle))) )
	{
		CString strNodeName;
		BSTR bstrNodeName;

		if( SUCCEEDED ( pStyle->GetNodeName( &bstrNodeName ) ) )
		{
			strNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
		strTitle = strNodeName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CStylePropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Style tab
	m_pTabStyle = new CTabStyleStyle( this );
	if( m_pTabStyle )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabStyle->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Info tab
	m_pTabInfo = new CTabStyleInfo( this );
	if( m_pTabInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CStylePropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CStylePropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CStylePropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CStylePropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CStylePropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CStylePropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicStyle* pStyle;
	
	if( m_pIPropPageObject == NULL )
	{
		pStyle = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pStyle ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Style are processed in OnKillFocus
	// messages before setting the new Style
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabStyle->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Style
	m_pTabStyle->SetStyle( pStyle);
	m_pTabInfo->SetStyle( pStyle);

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CStylePropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_StylePropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle constructor/destructor

CDirectMusicStyle::CDirectMusicStyle()
{
	ASSERT( theApp.m_pStyleComponent != NULL );

	// Style needs Style Component
	theApp.m_pStyleComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pUndoMgr = NULL;
	m_fModified = FALSE;

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pIDMStyle = NULL;

	m_hWndEditor = NULL;
	m_pStyleCtrl = NULL;
	m_pINodeBeingDeleted = NULL;
	m_pIProject = NULL;

	m_pIActiveBandNode = NULL;

	m_dwNextPatternID = 0;
	m_fPChannelChange = FALSE;

	m_StyleBands.m_pStyle = this;
	m_StylePatterns.m_pStyle = this;
	m_StyleMotifs.m_pStyle = this;
	m_StylePersonalities.m_pStyle = this;

// Style UI fields
	m_nSplitterYPos = 0;
	m_dwNotationType = 0;

// Style data for Music Engine
	TCHAR achName[SMALL_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_STYLE_TEXT, achName, SMALL_BUFFER );
    m_strName.Format( "%s%d", achName, ++theApp.m_pStyleComponent->m_nNextStyle );

	CoCreateGuid( &m_guidStyle ); 

	m_dwVersionMS = 0x00010000;
	m_dwVersionLS = 0x00000000;

	m_TimeSignature.m_bBeatsPerMeasure = 4;
	m_TimeSignature.m_bBeat = 4;
	m_TimeSignature.m_wGridsPerBeat = 4;

	m_dblTempo = 120;

	m_wUseId = 0x003F;
}

CDirectMusicStyle::~CDirectMusicStyle()
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Remove Style from clipboard
	theApp.FlushClipboard( this );

	// Remove Style from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup the Undo Manager
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
	}

	// Cleanup DirectMusic references
	RELEASE( m_pIDMStyle );

	// Cleanup active Band
	RELEASE( m_pIActiveBandNode );

	// m_lstStyleParts gets freed as Patterns
	// delete their Part References

	// Style no longer needs Style Component
	theApp.m_pStyleComponent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::CreateUndoMgr

BOOL CDirectMusicStyle::CreateUndoMgr()
{
	// Should only be called once - after Style first created
	ASSERT( m_pUndoMgr == NULL );

	ASSERT( theApp.m_pStyleComponent != NULL ); 
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL ); 

	m_pUndoMgr = new CJazzUndoMan( theApp.m_pStyleComponent->m_pIFramework );
	if( m_pUndoMgr )
	{
		m_pUndoMgr->SetStreamAttributes( FT_DESIGN, GUID_StyleUndo );
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::Initialize

HRESULT CDirectMusicStyle::Initialize( void )
{
	HRESULT hr;
	IDMUSProdNode* pINode;
	IDMUSProdDocType* pIDocType;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// This method should only be called immedialtely
	// after construction to create a default Style
	ASSERT( m_pIDocRootNode == NULL );

	// Set root and parent node of ALL children
	// Must do this now to prevent ASSERT's
//	theApp.SetNodePointers( this, this, NULL );
		
	// Create the Undo Manager
	if( CreateUndoMgr() == FALSE )
	{
		return E_OUTOFMEMORY;
	}

	// Create a default Band
	hr = theApp.m_pStyleComponent->m_pIFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_BandNode, &pINode );
		if( SUCCEEDED ( hr ) )
		{
			IDMUSProdBandEdit* pIBandEdit;

			// Set "Default" flag
			if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
			{
				pIBandEdit->SetDefaultFlag( TRUE );
				RELEASE( pIBandEdit );
			}

			// Make sure Band name is unique
			GetUniqueBandName( pINode );

			// Add to CDirectMusicStyle Band list
			m_StyleBands.m_lstBands.AddTail( pINode );
		}

		RELEASE( pIDocType );
	}
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Create a default Pattern
	CDirectMusicPattern* pPattern = new CDirectMusicPattern( this, FALSE );
	if( pPattern == NULL )
	{
		hr = E_OUTOFMEMORY ;
	}
	if( SUCCEEDED ( hr ) )
	{
		hr = pPattern->Initialize();
		if( SUCCEEDED ( hr ) )
		{
			// Add to CDirectMusicStyle Pattern list
			m_StylePatterns.m_lstPatterns.AddTail( pPattern );
		}
	}
	if( FAILED ( hr ) )
	{
		RELEASE( pPattern );
		return hr;
	}

	// Set root and parent node of ALL children
	// Must do this again because we added more nodes
	theApp.SetNodePointers( this, this, NULL );

	//	Allocate a new DirectMusic Style and Persist it to the DirectMusic DLLs.
	ASSERT( m_pIDMStyle == NULL );

	hr = ::CoCreateInstance( CLSID_DirectMusicStyle, NULL, CLSCTX_INPROC_SERVER,
							 IID_IDirectMusicStyle, (void**)&m_pIDMStyle );
	if( SUCCEEDED (  hr ) )
	{
		hr = SyncStyleWithDirectMusic();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SyncStyleEditor

void CDirectMusicStyle::SyncStyleEditor( DWORD dwFlags )
{
	if( m_pStyleCtrl
	&&  m_pStyleCtrl->m_pStyleDlg )
	{
		m_pStyleCtrl->m_pStyleDlg->RefreshControls( dwFlags );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::ForceSyncStyleWithDirectMusic

HRESULT CDirectMusicStyle::ForceSyncStyleWithDirectMusic( void )
{
	CWaitCursor wait;
	IStream* pIMemStream;
	IPersistStream* pIPersistStream;
	HRESULT hr;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pIDMStyle == NULL )
	{
		// Nothing to do
		return S_OK;
	}

	hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );

	if( SUCCEEDED ( hr ) )
	{
		hr = Save( pIMemStream, FALSE );
		if( SUCCEEDED ( hr ) )
		{
			m_pIDMStyle->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( pIPersistStream )
			{
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load( pIMemStream );

				RELEASE( pIPersistStream );
			}
		}

		RELEASE( pIMemStream );
	}

	// Check to see if any of the Style PChannels have changed
	if( m_fPChannelChange )
	{
		m_fPChannelChange = FALSE;

		// Notify connected nodes that a PChannel has changed
		theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, STYLE_PChannelChange, NULL );
	}

	// Check to see if any of the Motifs have changed
	POSITION pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		CDirectMusicPattern* pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
	
		if( pMotif->m_fSendChangeNotification )
		{
			pMotif->SendChangeNotification();
			pMotif->m_fSendChangeNotification = FALSE;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SyncStyleWithDirectMusic

HRESULT CDirectMusicStyle::SyncStyleWithDirectMusic( void )
{
	HRESULT hr;

	IDirectMusicSegment* pIDMSegment = GetSegmentThatIsPlaying();
	if( pIDMSegment )
	{
		// No need to sync if one of the Style's Patterns is playing.
		// Patterns do not play Style objects.
		// CDirectMusicPattern::Stop will perform the sync when the
		// Pattern is finished playing.
		RELEASE( pIDMSegment );
		hr = S_OK;
	}
	else
	{
		hr =  ForceSyncStyleWithDirectMusic();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SyncMidiStripMgrsThatUsePart

void CDirectMusicStyle::SyncMidiStripMgrsThatUsePart( CDirectMusicPart* pDMPart )
{
	CDirectMusicPattern* pPatternList;
	CDirectMusicPartRef* pDMPartRef;
	POSITION pos;
	POSITION pos2;

	ASSERT( pDMPart != NULL );

	// Handle Motifs
	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pPatternList = m_StyleMotifs.m_lstMotifs.GetNext( pos );
	
		pos2 = pPatternList->m_lstPartRefs.GetHeadPosition();
		while( pos2 )
		{
			pDMPartRef = pPatternList->m_lstPartRefs.GetNext( pos2 );

			if( pDMPartRef->m_pDMPart == pDMPart )
			{
				pPatternList->SyncPatternWithMidiStripMgr();
				break;
			}
		}
	}
		
	// Handle Patterns
	pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
	{
		pPatternList = m_StylePatterns.m_lstPatterns.GetNext( pos );
	
		pos2 = pPatternList->m_lstPartRefs.GetHeadPosition();
		while( pos2 )
		{
			pDMPartRef = pPatternList->m_lstPartRefs.GetNext( pos2 );

			if( pDMPartRef->m_pDMPart == pDMPart )
			{
				pPatternList->SyncPatternWithMidiStripMgr();
				break;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetBandNodeByName

IDMUSProdNode* CDirectMusicStyle::GetBandNodeByName( LPCTSTR szBandName )
{
	IDMUSProdNode* pIBandNodeList;
	CString strBandName;
	BSTR bstrBandName;

	POSITION pos = m_StyleBands.m_lstBands.GetHeadPosition();
	while( pos )
	{
		pIBandNodeList = m_StyleBands.m_lstBands.GetNext( pos );

		if( SUCCEEDED ( pIBandNodeList->GetNodeName( &bstrBandName ) ) )
		{
			strBandName = bstrBandName;
			::SysFreeString( bstrBandName );

			if( strBandName.CompareNoCase( szBandName ) == 0 )
			{
				pIBandNodeList->AddRef();
				return pIBandNodeList;
			}
		}
	}

	return NULL; 
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::IsBandNameUnique

BOOL CDirectMusicStyle::IsBandNameUnique( IDMUSProdNode* pIBandNode, LPCTSTR szBandName )
{
	IDMUSProdNode* pIBandNodeList;
	CString strBandName;
	BSTR bstrBandName;

	POSITION pos = m_StyleBands.m_lstBands.GetHeadPosition();
	while( pos )
	{
		pIBandNodeList = m_StyleBands.m_lstBands.GetNext( pos );
		if( pIBandNodeList != pIBandNode )
		{
			if( SUCCEEDED ( pIBandNodeList->GetNodeName( &bstrBandName ) ) )
			{
				strBandName = bstrBandName;
				::SysFreeString( bstrBandName );

				if( strBandName.CompareNoCase( szBandName ) == 0 )
				{
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetUniqueBandName

void CDirectMusicStyle::GetUniqueBandName( IDMUSProdNode* pIBandNode )
{
	CString	strOrigBandName;
	CString strBandName;
	BSTR bstrBandName;
	CString	strName;
	CString	strNbr;
	short nMaxLength;
	int	nNameLength;
	int	nNbrLength;
	int	i;

	if( FAILED ( pIBandNode->GetNodeName( &bstrBandName ) ) )
	{
		return;
	}

	strOrigBandName = bstrBandName;
	strName = strOrigBandName;
	::SysFreeString( bstrBandName );

	i = 0;
	while( !strName.IsEmpty()  &&  _istdigit(strName[strName.GetLength() - 1]) )
	{
		strNbr = strName.Right(1) + strNbr;
		strName = strName.Left( strName.GetLength() - 1 );
		if( ++i > 6 )
		{
			break;
		}
	}

	pIBandNode->GetNodeNameMaxLength( &nMaxLength );
	nNameLength = strName.GetLength();
	i = _ttoi( strNbr );

	strBandName = strOrigBandName;

	while( IsBandNameUnique( pIBandNode, strBandName ) == FALSE )
	{
		strNbr.Format( "%d", ++i ); 
		nNbrLength = strNbr.GetLength();
		
		if( (nNameLength + nNbrLength) <= nMaxLength )
		{
			strBandName = strName + strNbr;
		}
		else
		{
			strBandName = strName.Left(nMaxLength - nNbrLength) + strNbr;
		}
	}

	if( strBandName.CompareNoCase( strOrigBandName ) != 0 )
	{
		bstrBandName = strBandName.AllocSysString();
		pIBandNode->SetNodeName( bstrBandName );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::IsPatternNameUnique

BOOL CDirectMusicStyle::IsPatternNameUnique( CDirectMusicPattern* pPattern )
{
	CDirectMusicPattern* pPatternList;
	POSITION pos;

	if( pPattern->m_wEmbellishment & EMB_MOTIF )
	{
		pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pPatternList = m_StyleMotifs.m_lstMotifs.GetNext( pos );
			if( pPatternList != pPattern )
			{
				if( pPatternList->m_strName.CompareNoCase( pPattern->m_strName ) == 0 )
				{
					return FALSE;
				}
			}
		}
	}
	else
	{
		pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			pPatternList = m_StylePatterns.m_lstPatterns.GetNext( pos );
			if( pPatternList != pPattern )
			{
				if( pPatternList->m_strName.CompareNoCase( pPattern->m_strName ) == 0 )
				{
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetUniquePatternName

void CDirectMusicStyle::GetUniquePatternName( CDirectMusicPattern* pPattern )
{
	CString	strOrigName;
	CString	strNbr;
	int	nOrigNameLength;
	int	nNbrLength;
	int	i;

	if( pPattern->m_strName.GetLength() > DMUS_MAX_NAME )
	{
		pPattern->m_strName = pPattern->m_strName.Left( DMUS_MAX_NAME );
		pPattern->m_strName.TrimRight();
	}

	strOrigName = pPattern->m_strName;

	i = 0;
	while( !strOrigName.IsEmpty()  &&  _istdigit(strOrigName[strOrigName.GetLength() - 1]) )
	{
		strNbr = strOrigName.Right(1) + strNbr;
		strOrigName = strOrigName.Left( strOrigName.GetLength() - 1 );
		if( ++i > 6 )
		{
			break;
		}
	}

	nOrigNameLength = strOrigName.GetLength();
	i = _ttoi( strNbr );

	while( IsPatternNameUnique( pPattern ) == FALSE )
	{
		strNbr.Format( "%d", ++i ); 
		nNbrLength = strNbr.GetLength();
		
		if( (nOrigNameLength + nNbrLength) <= DMUS_MAX_NAME )
		{
			pPattern->m_strName = strOrigName + strNbr;
		}
		else
		{
			pPattern->m_strName = strOrigName.Left(DMUS_MAX_NAME - nNbrLength) + strNbr;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SetModified

void CDirectMusicStyle::SetModified( BOOL fModified )
{
	m_fModified = fModified;

	if( m_fModified == FALSE )
	{
		m_StyleBands.SetModified( FALSE );
		m_StyleMotifs.SetModified( FALSE );
		m_StylePatterns.SetModified( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IUnknown implementation

HRESULT CDirectMusicStyle::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink) )
	{
		*ppvObj = (IDMUSProdNotifySink*) this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdStyleInfo) )
	{
		*ppvObj = (IDMUSProdStyleInfo*) this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicStyle::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicStyle::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicStyle::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return( theApp.m_pStyleComponent->GetStyleImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicStyle::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	m_StyleBands.AddRef();
	*ppIFirstChildNode = (IDMUSProdNode *)&m_StyleBands;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetNextChild

HRESULT CDirectMusicStyle::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIChildNode == (IDMUSProdNode *)&m_StyleBands )
	{
		m_StylePatterns.AddRef();
		*ppINextChildNode = (IDMUSProdNode *)&m_StylePatterns;
	}
	else if( pIChildNode == (IDMUSProdNode *)&m_StylePatterns )
	{
		m_StyleMotifs.AddRef();
		*ppINextChildNode = (IDMUSProdNode *)&m_StyleMotifs;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetComponent

HRESULT CDirectMusicStyle::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicStyle::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicStyle::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetParentNode

HRESULT CDirectMusicStyle::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::SetParentNode

HRESULT CDirectMusicStyle::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetNodeId

HRESULT CDirectMusicStyle::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_StyleNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetNodeName

HRESULT CDirectMusicStyle::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicStyle::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicStyle::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::SetNodeName

HRESULT CDirectMusicStyle::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_STYLE_NAME );
	m_strName = strName;

	// Sync change with property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		RELEASE( pIPropSheet );
	}
	
	SetModified( TRUE );
	SyncStyleWithDirectMusic();

	// Notify connected nodes that Style name has changed
	theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, STYLE_NameChange, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicStyle::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

	strDescriptor.Format( "%d/%d", m_TimeSignature.m_bBeatsPerMeasure, m_TimeSignature.m_bBeat );

	if( !(m_TimeSignature.m_wGridsPerBeat % 3) )
	{
		strDescriptor += _T("  3");
	}

    pListInfo->bstrName = m_strName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidStyle, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicStyle::GetEditorClsId( CLSID* pClsId )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   *pClsId = CLSID_StyleEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicStyle::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_STYLE_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_strName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicStyle::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicStyle::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicStyle::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicStyle::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_STYLE_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicStyle::OnRightClickMenuInit( HMENU hMenu )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicStyle::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pINode;

	switch( lCommandId )
	{
		case IDM_NEW_BAND:
			pINode = (IDMUSProdNode *)&m_StyleBands;
			if( SUCCEEDED ( pINode->InsertChildNode(NULL) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_NEW_MOTIF:
			hr = m_StyleMotifs.CreateNewMotif();
			break;

		case IDM_NEW_PATTERN:
			hr = m_StylePatterns.CreateNewPattern();
			break;

		case IDM_PATTERN_FROMMIDI:
			ImportMidiFileAsPattern( FALSE );
			break;

		case IDM_MOTIF_FROMMIDI:
			ImportMidiFileAsPattern( TRUE );
			break;
	
		case IDM_RENAME:
			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicStyle::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Cannot delete folders under style
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicStyle::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// Cannot insert additional folders under style
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::DeleteNode

HRESULT CDirectMusicStyle::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	// No parent so we will delete ourself
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Remove from Project Tree
	if( theApp.m_pStyleComponent->m_pIFramework->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		// User cancelled delete
		return E_FAIL;
	}

	// Style no longer needs Transport Controls
	UnRegisterWithTransport();

	// Make sure that Bands cleanup properly.  Otherwisea 
	// Band that happens to be in the Framework's notification
	// list will never have its destructor called.
	m_StyleBands.CleanUp();

	// Remove from Component Style list
	theApp.m_pStyleComponent->RemoveFromStyleFileList( this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicStyle::OnNodeSelChanged( BOOL fSelected )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicStyle::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Style into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_STYLE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pStyleComponent->m_cfStyle, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->SaveClipFormat( theApp.m_pStyleComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Style nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pStyleComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CanCut

HRESULT CDirectMusicStyle::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CanCopy

HRESULT CDirectMusicStyle::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CanDelete

HRESULT CDirectMusicStyle::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicStyle::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Cannot delete folders under Style
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle ContainsClipFormat

HRESULT CDirectMusicStyle::ContainsClipFormat( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, UINT cfClipFormat )
{
	if( pDataObject == NULL 
	||  pIDataObject == NULL 
	||  cfClipFormat == 0 )
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
	{
		IStream* pIStream;

		if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline, &pIStream ) ) )
		{
			// Create a RIFF stream
			IDMUSProdRIFFStream* pIRiffStream;
			if( SUCCEEDED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				MMCKINFO ck1;
				MMCKINFO ck2;

				ck1.fccType = FOURCC_TIMELINE_LIST;
				if( pIRiffStream->Descend( &ck1, NULL, MMIO_FINDLIST ) == 0 )
				{
					ck2.fccType = FOURCC_TIMELINE_CLIPBOARD;
					while( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDLIST ) == 0 )
					{
						ck2.ckid = FOURCC_TIMELINE_CLIP_NAME;
						if( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDCHUNK ) == 0 )
						{
							DWORD dwSize;
							DWORD dwBytesRead;
							TCHAR achText[MAX_PATH];

							memset( achText, 0, sizeof( achText ) );

							dwSize = min( ck2.cksize, MAX_PATH );
							if( SUCCEEDED ( pIStream->Read( achText, dwSize, &dwBytesRead ) ) 
							&&  dwBytesRead == dwSize )
							{
								if( ::RegisterClipboardFormat(achText) == cfClipFormat )
								{
									// We found what we are looking for - CF_BANDTRACK format
									hr = S_OK;
									break;
								}
							}
						}

						pIRiffStream->Ascend( &ck2, 0 );
					}
				}

				RELEASE( pIRiffStream );
			}

			RELEASE( pIStream );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_BAND

HRESULT CDirectMusicStyle::PasteCF_BAND( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
										 IDMUSProdNode* pIPositionNode )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfBand, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Band
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				if( pIPositionNode )
				{
					m_StyleBands.InsertChildNodeAtPos( pINode, pIPositionNode );
				}
				else
				{
					m_StyleBands.InsertChildNode( pINode );
				}

				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_BANDLIST

HRESULT CDirectMusicStyle::PasteCF_BANDLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
											 IDMUSProdNode* pIPositionNode )
{
	UNREFERENCED_PARAMETER(pIPositionNode);
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfBandList, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::LoadCF_BANDTRACK

HRESULT CDirectMusicStyle::LoadCF_BANDTRACK( IStream* pIStream, IDMUSProdNode* pIPositionNode )
{
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	// Create a RIFF stream
	IDMUSProdRIFFStream* pIRiffStream;
	if( SUCCEEDED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		MMCKINFO ckMain;
		MMCKINFO ckList;

		// Look for the list of Bands in the RIFF stream
		ckMain.fccType = DMUS_FOURCC_BANDS_LIST;
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
		{
			while( pIRiffStream->Descend( &ckList, &ckMain, 0 ) == 0 )
			{
				switch( ckList.ckid )
				{
					case FOURCC_LIST :
						switch( ckList.fccType )
						{
							case DMUS_FOURCC_BAND_LIST:
							{
								MMCKINFO ck;

								// Extract individual Bands and add them to the Style's list of Bands
								while( pIRiffStream->Descend( &ck, &ckList, 0 ) == 0 )
								{
									switch( ck.ckid )
									{
										case FOURCC_RIFF:
											switch( ck.fccType )
											{
												case DMUS_FOURCC_BAND_FORM:
												{
													StreamSeek( pIStream, -12, STREAM_SEEK_CUR );

													// Create and load a new Band
													IDMUSProdRIFFExt* pIRIFFExt;
													IDMUSProdNode* pINode;

													if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
													{
														if( SUCCEEDED ( pIRIFFExt->LoadRIFFChunk( pIStream, &pINode ) ) )
														{
															// We were able to paste something so return S_OK
															hr = S_OK;

															if( pIPositionNode )
															{
																m_StyleBands.InsertChildNodeAtPos( pINode, pIPositionNode );
															}
															else
															{
																m_StyleBands.InsertChildNode( pINode );
															}

															RELEASE( pINode );
														}

														RELEASE( pIRIFFExt );
													}
													break;
												}
											}
									}

									pIRiffStream->Ascend( &ck, 0 );
								}
								break;
							}
						}
						break;
				}

				pIRiffStream->Ascend( &ckList, 0 );
			}
		}

		RELEASE( pIRiffStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_BANDTRACK

HRESULT CDirectMusicStyle::PasteCF_BANDTRACK( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
											  IDMUSProdNode* pIPositionNode )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		hr = LoadCF_BANDTRACK( pIStream, pIPositionNode );

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_TIMELINE

HRESULT CDirectMusicStyle::PasteCF_TIMELINE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
											 IDMUSProdNode* pIPositionNode )
{
	if( pDataObject == NULL 
	||  pIDataObject == NULL ) 
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
	{
		IStream* pIStream;

		if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline, &pIStream ) ) )
		{
			// Create a RIFF stream
			IDMUSProdRIFFStream* pIRiffStream;
			if( SUCCEEDED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				MMCKINFO ck1;
				MMCKINFO ck2;

				ck1.fccType = FOURCC_TIMELINE_LIST;
				if( pIRiffStream->Descend( &ck1, NULL, MMIO_FINDLIST ) == 0 )
				{
					ck2.fccType = FOURCC_TIMELINE_CLIPBOARD;
					while( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDLIST ) == 0 )
					{
						ck2.ckid = FOURCC_TIMELINE_CLIP_NAME;
						if( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDCHUNK ) == 0 )
						{
							DWORD dwSize;
							DWORD dwBytesRead;
							TCHAR achText[MAX_PATH];

							memset( achText, 0, sizeof( achText ) );

							dwSize = min( ck2.cksize, MAX_PATH );
							if( SUCCEEDED ( pIStream->Read( achText, dwSize, &dwBytesRead ) ) 
							&&  dwBytesRead == dwSize )
							{
								if( ::RegisterClipboardFormat(achText) == theApp.m_pStyleComponent->m_cfBandTrack )
								{
									pIRiffStream->Ascend( &ck2, 0 );

									// Handle CF_BANDTRACK format
									ck2.ckid = FOURCC_TIMELINE_CLIP_DATA;
									if( pIRiffStream->Descend( &ck2, &ck1, MMIO_FINDCHUNK ) == 0 )
									{
										hr = LoadCF_BANDTRACK( pIStream, pIPositionNode );
									}
									break;
								}
							}
						}

						pIRiffStream->Ascend( &ck2, 0 );
					}
				}

				RELEASE( pIRiffStream );
			}

			RELEASE( pIStream );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_MOTIF

HRESULT CDirectMusicStyle::PasteCF_MOTIF( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
										  CDirectMusicPattern* pPositionMotif )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfMotif, &pIStream  ) ) 
	||  SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfPattern, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Motif
		CDirectMusicPattern* pMotif = new CDirectMusicPattern( this, TRUE );

		if( pMotif )
		{
			hr = pMotif->Load( pIStream );
			if( SUCCEEDED( hr ) )
			{
				if( !(pMotif->m_wEmbellishment & EMB_MOTIF) )
				{
					// Convert the Pattern into a Motif
					pMotif->m_wEmbellishment = EMB_MOTIF;
					pMotif->m_bGrooveBottom = 1; 
					pMotif->m_bGrooveTop = 100;
					pMotif->m_bDestGrooveBottom = 1; 
					pMotif->m_bDestGrooveTop = 100;
					ASSERT( pMotif->m_pIBandNode == NULL );
				}
				if( pPositionMotif )
				{
					m_StyleMotifs.InsertChildNodeAtPos( pMotif, pPositionMotif );
				}
				else
				{
					m_StyleMotifs.InsertChildNode( pMotif );
				}
			}

			RELEASE( pMotif );
		}
		else
		{
			hr = E_OUTOFMEMORY ;
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_MOTIFLIST

HRESULT CDirectMusicStyle::PasteCF_MOTIFLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
											  CDirectMusicPattern* pPositionMotif )
{
	UNREFERENCED_PARAMETER(pPositionMotif);
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList, &pIStream  ) ) 
	||  SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		RELEASE( pIStream );

		// Remember to convert Patterns into Motifs when this method is actually implemented
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_PATTERN

HRESULT CDirectMusicStyle::PasteCF_PATTERN( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
											CDirectMusicPattern* pPositionPattern )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfPattern, &pIStream  ) ) 
	||  SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfMotif, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Pattern
		CDirectMusicPattern* pPattern = new CDirectMusicPattern( this, FALSE );

		if( pPattern )
		{
			hr = pPattern->Load( pIStream );
			if( SUCCEEDED( hr ) )
			{
				if( pPattern->m_wEmbellishment & EMB_MOTIF )
				{
					// Convert the Motif into a Pattern
					pPattern->m_wEmbellishment = EMB_NORMAL;
					pPattern->m_dwRepeats = 0;
					pPattern->m_mtPlayStart = 0;
					pPattern->m_mtLoopStart = 0;
					pPattern->m_mtLoopEnd = pPattern->m_dwLength;
					pPattern->m_dwResolution = DMUS_SEGF_BEAT;
					RELEASE( pPattern->m_pIBandNode );	// Patterns do not have Bands
				}
				if( pPositionPattern )
				{
					m_StylePatterns.InsertChildNodeAtPos( pPattern, pPositionPattern );
				}
				else
				{
					m_StylePatterns.InsertChildNode( pPattern );
				}
			}

			RELEASE( pPattern );
		}
		else
		{
			hr = E_OUTOFMEMORY ;
		}
		
		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PasteCF_PATTERNLIST

HRESULT CDirectMusicStyle::PasteCF_PATTERNLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject,
												CDirectMusicPattern* pPositionPattern )
{
	UNREFERENCED_PARAMETER(pPositionPattern);
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList, &pIStream  ) ) 
	||  SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		RELEASE( pIStream );

		// Remember to convert Motifs into Patterns when this method is actually implemented
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicStyle::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) )
	||  SUCCEEDED ( ContainsClipFormat( pDataObject, pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::PasteFromData

HRESULT CDirectMusicStyle::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) ) )
	{
		// Handle CF_BAND format
		hr = PasteCF_BAND( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) )
	{
		// Handle CF_BANDLIST format
		hr = PasteCF_BANDLIST( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) )
	{
		// Handle CF_BANDTRACK format
		hr = PasteCF_BANDTRACK( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
	{
		// Handle CF_TIMELINE format
		hr = PasteCF_TIMELINE( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) ) )
	{
		// Handle CF_MOTIF format
		hr = PasteCF_MOTIF( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		// Handle CF_MOTIFLIST format
		hr = PasteCF_MOTIFLIST( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) ) )
	{
		// Handle CF_PATTERN format
		hr = PasteCF_PATTERN( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) )
	{
		// Handle CF_PATTERNLIST format
		hr = PasteCF_PATTERNLIST( pDataObject, pIDataObject, NULL );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicStyle::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	ASSERT( 0 );

	return E_NOTIMPL;	// Style children handle themselves
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicStyle::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Style children handle themselves
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNode::GetObject

HRESULT CDirectMusicStyle::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DMStyle object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicStyle ) )
	{
		if( m_pIDMStyle )
		{
			return m_pIDMStyle->QueryInterface( riid, ppvObject );
		}
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicStyle::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicStyle::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicStyle::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Get the Style page manager
	CStylePropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_StylePropPageManager ) == S_OK )
	{
		pPageManager = (CStylePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CStylePropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Style properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CStylePropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicStyle::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersist::GetClassID

HRESULT CDirectMusicStyle::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo::GetActiveBandForStyle

HRESULT CDirectMusicStyle::GetActiveBandForStyle( IUnknown** ppIActiveBandNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIActiveBandNode == NULL )
	{
		return E_POINTER;
	}

	if( m_pIActiveBandNode == NULL )
	{
		SetActiveBand( GetTheDefaultBand() );
	}

	if( m_pIActiveBandNode )
	{
		m_pIActiveBandNode->AddRef();
		*ppIActiveBandNode = m_pIActiveBandNode;
		return S_OK;
	}

	*ppIActiveBandNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo::GetDefaultBand

HRESULT CDirectMusicStyle::GetDefaultBand( IUnknown** ppIDefaultBandNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDefaultBandNode == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdNode* pIBandNode = GetTheDefaultBand();

	if( pIBandNode )
	{
		pIBandNode->AddRef();
		*ppIDefaultBandNode = pIBandNode;
		return S_OK;
	}

	*ppIDefaultBandNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo::GetTempo

HRESULT CDirectMusicStyle::GetTempo( double* pTempo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pTempo == NULL )
	{
		return E_POINTER;
	}

	*pTempo = m_dblTempo;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo::GetTimeSignature

HRESULT CDirectMusicStyle::GetTimeSignature( DMUSProdTimeSignature* pTimeSignature )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !pTimeSignature )
	{
		return E_POINTER;
	}

	pTimeSignature->bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	pTimeSignature->bBeat = m_TimeSignature.m_bBeat;
	pTimeSignature->wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo::GetNotationType

HRESULT CDirectMusicStyle::GetNotationType( DWORD *pdwType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !pdwType )
	{
		return E_POINTER;
	}

	*pdwType = m_dwNotationType;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdStyleInfo::GetActiveBandForObject

HRESULT CDirectMusicStyle::GetActiveBandForObject( IUnknown* punkObject, IUnknown** ppIActiveBandNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIActiveBandNode == NULL )
	{
		return E_POINTER;
	}

	*ppIActiveBandNode = NULL;

	// Find motif with matching IDMUSProdStripMgr interface pointer
	IDMUSProdStripMgr* pIStripMgr;
	if( SUCCEEDED ( punkObject->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
	{
		CDirectMusicPattern* pMotif;

		POSITION pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

			if( pMotif->m_pPatternCtrl
			&&  pMotif->m_pPatternCtrl->m_pPatternDlg
			&&  pMotif->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr == pIStripMgr )
			{
				// Found matching motif - use motif's band
				if( pMotif->m_pIBandNode )
				{
					pMotif->m_pIBandNode->AddRef();
				}
				*ppIActiveBandNode = pMotif->m_pIBandNode;
				break;
			}
		}

		RELEASE( pIStripMgr );
	}

	if( *ppIActiveBandNode == NULL )
	{
		// Find motif with matching IDMUSProdNode interface pointer
		IDMUSProdNode* pINode;
		if( SUCCEEDED ( punkObject->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
		{
			CDirectMusicPattern* pMotif;

			POSITION pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
			while( pos )
			{
				pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

				if( pINode == (IDMUSProdNode *)pMotif )
				{
					// Found matching motif - use motif's band
					if( pMotif->m_pIBandNode )
					{
						pMotif->m_pIBandNode->AddRef();
					}
					*ppIActiveBandNode = pMotif->m_pIBandNode;
					break;
				}
			}

			RELEASE( pINode );
		}
	}

	if( *ppIActiveBandNode )
	{
		return S_OK;
	}

	return GetActiveBandForStyle( ppIActiveBandNode );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersistStream::IsDirty

HRESULT CDirectMusicStyle::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fModified
	||  m_StyleBands.IsDirty() 
	||  m_StyleMotifs.IsDirty() 
	||  m_StylePatterns.IsDirty() )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersistStream::Load

HRESULT CDirectMusicStyle::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD dwPos = StreamTell( pIStream );

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	BOOL fFoundFormat = FALSE;

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = DM_LoadStyle( pIRiffStream, &ckMain );
			fFoundFormat = TRUE;
		}

		if( fFoundFormat )
		{
			if( m_pIDocRootNode )
			{
				// Already in Project Tree so sync changes
				// Refresh Style editor (when open)
				SyncStyleEditor( SSE_ALL );

				// Sync change with property sheet
				IDMUSProdPropSheet* pIPropSheet;
				if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
				{
					pIPropSheet->RefreshTitle();
					pIPropSheet->RefreshActivePage();
					RELEASE( pIPropSheet );
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	// Check for IMA 2.5 format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = FOURCC_STYLE_FORM;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = IMA25_LoadStyle( pIRiffStream, &ckMain );
				fFoundFormat = TRUE;
			}

			if( fFoundFormat )
			{
				if( m_pIDocRootNode )
				{
					// Already in Project Tree so sync changes
					// Refresh Style editor (when open)
					SyncStyleEditor( SSE_ALL );

					// Sync change with property sheet
					IDMUSProdPropSheet* pIPropSheet;
					if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
					{
						pIPropSheet->RefreshTitle();
						pIPropSheet->RefreshActivePage();
						RELEASE( pIPropSheet );
					}
				}
			}

			RELEASE( pIRiffStream );
		}
	}

	// Check for "Undo" format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_STYLE_UNDO_FORM;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = UNDO_LoadStyle( pIRiffStream, &ckMain );
				fFoundFormat = TRUE;
			}

			if( fFoundFormat )
			{
				if( m_pIDocRootNode )
				{
					// Already in Project Tree so sync changes
					// Refresh Style editor (when open)
					SyncStyleEditor( (SSE_STYLE | SSE_PATTERNS | SSE_MOTIFS | SSE_BANDS) );

					// Sync change with property sheet
					IDMUSProdPropSheet* pIPropSheet;
					if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
					{
						pIPropSheet->RefreshTitleByObject( this );
						pIPropSheet->RefreshActivePageByObject( this );
						RELEASE( pIPropSheet );
					}
				}
			}

			RELEASE( pIRiffStream );
		}
	}

	//	Persist Style to the DirectMusic DLLs.
	if( SUCCEEDED( hr ) )
	{
		// Make sure we have a default Band
		IDMUSProdNode* pIBandNode = GetTheDefaultBand();
		if( pIBandNode == NULL )
		{
			if( !m_StyleBands.m_lstBands.IsEmpty() )
			{
				pIBandNode = m_StyleBands.m_lstBands.GetHead();
				if( pIBandNode )
				{
					SetDefaultBand( pIBandNode, TRUE );
				}
			}
		}

		// Make sure we have a Music Engine Style
		if( m_pIDMStyle == NULL )
		{
			hr = ::CoCreateInstance( CLSID_DirectMusicStyle, NULL, CLSCTX_INPROC_SERVER,
									 IID_IDirectMusicStyle, (void**)&m_pIDMStyle );
		}

		if( SUCCEEDED( hr ) )
		{
			hr = SyncStyleWithDirectMusic();
		}

		// 21492: Need to notify Segment Designer that the Style's timesig changed during an Undo
		// AFTER we sync with DirectMusic, since a slaved TimeSig track gets its information
		// from the DirectMusic style.
		// Notify connected nodes that Style time signature has changed
		theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, STYLE_TimeSigChange, &m_TimeSignature );
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersistStream::Save

HRESULT CDirectMusicStyle::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Save the Style
	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
	{
		// DirectMusic format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( DM_SaveStyle( pIRiffStream, fClearDirty ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}

				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

	else if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_StyleUndo ) )
	{
		// Style "Undo" format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_STYLE_UNDO_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( UNDO_SaveStyle( pIRiffStream, StreamInfo.ftFileType ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IPersistStream::GetSizeMax

HRESULT CDirectMusicStyle::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle Additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::UNDO_SaveStyle

HRESULT CDirectMusicStyle::UNDO_SaveStyle( IDMUSProdRIFFStream* pIRiffStream, FileType ftFileType )
{
	HRESULT hr = S_OK;
	IStream* pIMemStream = NULL;
	IStream* pIStream;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Style chunk
	hr = DM_SaveStyleChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Style UI chunk
	if( ftFileType == FT_DESIGN )
	{
		hr = DM_SaveStyleUIChunk( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Save Style GUID
	hr = DM_SaveStyleGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Style info
	hr = DM_SaveStyleInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}


// Save name of default Band
	hr = DM_SaveStyleDefaultBand( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Style version
	hr = DM_SaveStyleVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save node being deleted
	if( m_pINodeBeingDeleted )
	{
		STATSTG	statstg;
		ULARGE_INTEGER uliSizeOut, uliSizeRead, uliSizeWritten;
		GUID guidNodeId;

		hr = E_FAIL;

		m_pINodeBeingDeleted->GetNodeId( &guidNodeId );

		if( ::IsEqualGUID( guidNodeId, GUID_PatternNode )
		||  ::IsEqualGUID( guidNodeId, GUID_MotifNode ) )
		{
			CDirectMusicPattern* pPattern = (CDirectMusicPattern *)m_pINodeBeingDeleted;

			hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_SinglePattern, &pIMemStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}

			hr = pPattern->Save( pIMemStream, FALSE );
		}

		else if( ::IsEqualGUID( guidNodeId, GUID_BandNode ) )
		{
			IPersistStream* pIPersistStream;

			hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}

			hr = m_pINodeBeingDeleted->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}

			hr = pIPersistStream->Save( pIMemStream, FALSE );
			RELEASE( pIPersistStream );
		}

		// Get node's data into "Undo" style RIFF file
		if( SUCCEEDED ( hr ) )
		{
			hr = pIMemStream->Stat( &statstg, STATFLAG_NONAME );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}

			// Store size of memory stream
			uliSizeOut = statstg.cbSize;

			// Seek to beginning of memory stream
			StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );

			// Copy memory stream to 
			hr = pIMemStream->CopyTo( pIStream, uliSizeOut, &uliSizeRead, &uliSizeWritten );
			if( FAILED( hr )
			||  uliSizeRead.QuadPart != uliSizeOut.QuadPart
			||  uliSizeWritten.QuadPart != uliSizeOut.QuadPart )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

ON_ERROR:
	RELEASE( pIMemStream );
	RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyle

HRESULT CDirectMusicStyle::DM_SaveStyle( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	HRESULT hr = S_OK;
	POSITION pos;
	IStream* pIStream;
	IPersistStream* pIPersistStream;
	IDMUSProdNode* pIDefaultBandNode;
	IDMUSProdNode* pINode;
	CDirectMusicPattern* pPattern;
	CDirectMusicPattern* pMotif;
	CDirectMusicPart* pPart;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

// Save Style chunk
	hr = DM_SaveStyleChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Style UI chunk
	if( StreamInfo.ftFileType == FT_DESIGN )
	{
		hr = DM_SaveStyleUIChunk( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Save Style GUID
	hr = DM_SaveStyleGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Style info
	hr = DM_SaveStyleInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Style version
	hr = DM_SaveStyleVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save default Band
	pIDefaultBandNode = GetTheDefaultBand();
	if( pIDefaultBandNode )
	{
		hr = pIDefaultBandNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = pIPersistStream->Save( pIStream, fClearDirty );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Save other Bands
	pos = m_StyleBands.m_lstBands.GetHeadPosition();
	while( pos )
	{
		pINode = m_StyleBands.m_lstBands.GetNext( pos );

		if( pINode != pIDefaultBandNode )
		{
			hr = pINode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
			hr = pIPersistStream->Save( pIStream, fClearDirty );
			RELEASE( pIPersistStream );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

// Save Parts
	pos = m_lstStyleParts.GetHeadPosition();
	while( pos )
	{
		pPart = m_lstStyleParts.GetNext( pos );
		hr = pPart->DM_SavePart( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Sort Patterns
	m_StylePatterns.SortPatternList();

// Save Patterns
    pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
    {
        pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		hr = pPattern->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = pIPersistStream->Save( pIStream, fClearDirty );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
    }

// Sort Motifs
	m_StyleMotifs.SortMotifList();

// Save Motifs
    pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
    {
        pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		hr = pMotif->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = pIPersistStream->Save( pIStream, fClearDirty );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
    }

// Save Personality References
	hr = DM_SaveStylePersonalityList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyleChunk

HRESULT CDirectMusicStyle::DM_SaveStyleChunk( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_STYLE dmusStyleIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Style chunk header
	ck.ckid = DMUS_FOURCC_STYLE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_STYLE structure
	memset( &dmusStyleIO, 0, sizeof(DMUS_IO_STYLE) );

	dmusStyleIO.timeSig.bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	dmusStyleIO.timeSig.bBeat = m_TimeSignature.m_bBeat;
	dmusStyleIO.timeSig.wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;

	dmusStyleIO.dblTempo = m_dblTempo;

	// Write Style chunk data
	hr = pIStream->Write( &dmusStyleIO, sizeof(DMUS_IO_STYLE), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_STYLE) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyleUIChunk

HRESULT CDirectMusicStyle::DM_SaveStyleUIChunk( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	ioDMStyleUI oDMStyleUI;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Style UI chunk header
	ck.ckid = DMUS_FOURCC_STYLE_UI_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioDMStyleUI structure
	memset( &oDMStyleUI, 0, sizeof(ioDMStyleUI) );

	oDMStyleUI.m_nSplitterYPos = m_nSplitterYPos;
	oDMStyleUI.m_dwNotationType = m_dwNotationType;

	// Write Style UI chunk data
	hr = pIStream->Write( &oDMStyleUI, sizeof(ioDMStyleUI), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioDMStyleUI) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyleGUID

HRESULT CDirectMusicStyle::DM_SaveStyleGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Style GUID
	hr = pIStream->Write( &m_guidStyle, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyleInfoList

HRESULT CDirectMusicStyle::DM_SaveStyleInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty()
	&&  m_strCategoryName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty()
	&&  m_strInfo.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Style name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Style category
	if( !m_strCategoryName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_CATEGORY_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCategoryName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Style author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Style copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Style subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Style comments
	if( !m_strInfo.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCMT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strInfo );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyleDefaultBand

HRESULT CDirectMusicStyle::DM_SaveStyleDefaultBand( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ck;

	// Find default Band
	IDMUSProdNode* pIBandNode = GetTheDefaultBand();
	if( pIBandNode == NULL )
	{
		return S_OK;
	}

	// Get name of default Band
	CString strBandName;
	BSTR bstrBandName;
	if( SUCCEEDED ( pIBandNode->GetNodeName( &bstrBandName ) ) )
	{
		strBandName = bstrBandName;
		::SysFreeString( bstrBandName );
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write default Band name
	if( !strBandName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_DEFAULT_BAND_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &strBandName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStyleVersion

HRESULT CDirectMusicStyle::DM_SaveStyleVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusStyleVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write StyleVersion chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusStyleVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusStyleVersionIO.dwVersionMS = m_dwVersionMS ;
	dmusStyleVersionIO.dwVersionLS = m_dwVersionLS;

	// Write StyleVersion chunk data
	hr = pIStream->Write( &dmusStyleVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_SaveStylePersonalityList

HRESULT CDirectMusicStyle::DM_SaveStylePersonalityList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
	POSITION pos;
	CPersonality* pPersonality;

	if( m_StylePersonalities.m_lstPersonalities.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	hr = E_FAIL;

	// Write PERSONALITY LIST header
	ckMain.fccType = DMUS_FOURCC_STYLE_PERS_REF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// First, save the default Personality
	pos = m_StylePersonalities.m_lstPersonalities.GetHeadPosition();
	while( pos )
	{
		pPersonality = m_StylePersonalities.m_lstPersonalities.GetNext( pos );

		if( pPersonality->m_fDefault )
		{
			hr = pPersonality->DM_SavePersonalityRefChunk( pIRiffStream );
			break;
		}
	}

	// Save remaining Personalities
	pos = m_StylePersonalities.m_lstPersonalities.GetHeadPosition();
	while( pos )
	{
		pPersonality = m_StylePersonalities.m_lstPersonalities.GetNext( pos );

		if( pPersonality->m_fDefault == FALSE )
		{
			hr = pPersonality->DM_SavePersonalityRefChunk( pIRiffStream );
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::IMA25_LoadStyle

HRESULT CDirectMusicStyle::IMA25_LoadStyle( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
    IDMUSProdRIFFExt* pIRIFFExt;
    IDMUSProdNode*    pINode;
	MMCKINFO	  ck;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;
    ioStyle       iStyle;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIBandComponent != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_STYLE:
				dwSize = min( ck.cksize, sizeof( iStyle ) );
				hr = pIStream->Read( &iStyle, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				m_strName = iStyle.wstrName;
				m_strCategoryName = iStyle.wstrCategory;
				m_TimeSignature.m_bBeatsPerMeasure = (BYTE)iStyle.wBPM;
				m_TimeSignature.m_bBeat = (BYTE)iStyle.wBeat;
				m_TimeSignature.m_wGridsPerBeat = iStyle.wClocksPerBeat / iStyle.wClocksPerClick;
				m_dblTempo = iStyle.wTempo;
				memcpy( &m_guidStyle, &iStyle.guid, sizeof( m_guidStyle ) );
				break;

			case FOURCC_STYLEINFO:
				ReadMBSfromWCS( pIStream, ck.cksize, &m_strInfo );
				break;

			case FOURCC_PERSONALITYREF:
			{
				CPersonality* pPersonality = new CPersonality();
				if( pPersonality == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}
				hr = pPersonality->IMA25_LoadPersonalityRef( pIStream, &ck );
				if( FAILED( hr ) )
				{
					delete pPersonality;
	                goto ON_ERROR;
				}
				m_StylePersonalities.m_lstPersonalities.AddTail( pPersonality );
				break;
			}

			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case FOURCC_BAND_FORM:
						hr = theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						// Make sure Band name is unique
						GetUniqueBandName( pINode );
						m_StyleBands.m_lstBands.AddTail( pINode );
						break;

					case FOURCC_PATTERN_FORM:
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						CDirectMusicPattern* pPattern = new CDirectMusicPattern( this, FALSE );
						if( pPattern == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPattern->Load( pIStream );
						if( FAILED( hr ) )
						{
							RELEASE( pPattern );
			                goto ON_ERROR;
						}
						if( pPattern->m_wEmbellishment & EMB_MOTIF )
						{
							m_StyleMotifs.m_lstMotifs.AddTail( pPattern );
						}
						else
						{
							m_StylePatterns.m_lstPatterns.AddTail( pPattern );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DM_LoadStyle

HRESULT CDirectMusicStyle::DM_LoadStyle( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	CDirectMusicPart* pPart;
    IStream*      pIStream;
    IDMUSProdRIFFExt* pIRIFFExt;
    IDMUSProdNode*    pINode;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	POSITION	  pos;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIBandComponent != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_STYLE_CHUNK:
			{
			    DMUS_IO_STYLE dmusStyleIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
				hr = pIStream->Read( &dmusStyleIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_TimeSignature.m_bBeatsPerMeasure = dmusStyleIO.timeSig.bBeatsPerMeasure;
				m_TimeSignature.m_bBeat = dmusStyleIO.timeSig.bBeat;
				m_TimeSignature.m_wGridsPerBeat = dmusStyleIO.timeSig.wGridsPerBeat;
				m_dblTempo = dmusStyleIO.dblTempo;
				break;
			}

			case DMUS_FOURCC_STYLE_UI_CHUNK:
			{
			    ioDMStyleUI iDMStyleUI;
				ZeroMemory( &iDMStyleUI, sizeof(ioDMStyleUI ) );

				dwSize = min( ck.cksize, sizeof( ioDMStyleUI ) );
				hr = pIStream->Read( &iDMStyleUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_nSplitterYPos = iDMStyleUI.m_nSplitterYPos;
				m_dwNotationType = iDMStyleUI.m_dwNotationType;
				break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidStyle, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusStyleVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusStyleVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwVersionMS = dmusStyleVersionIO.dwVersionMS;
				m_dwVersionLS = dmusStyleVersionIO.dwVersionLS;
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_INFO_LIST:
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case DMUS_FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;

								case RIFFINFO_IART:
								case DMUS_FOURCC_UART_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
									break;

								case RIFFINFO_ICOP:
								case DMUS_FOURCC_UCOP_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
									break;

								case RIFFINFO_ISBJ:
								case DMUS_FOURCC_USBJ_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
									break;

								case RIFFINFO_ICMT:
								case DMUS_FOURCC_UCMT_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
									break;

								case DMUS_FOURCC_CATEGORY_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCategoryName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_PART_LIST:
						pPart = AllocPart();
						if( pPart == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPart->DM_LoadPart( pIRiffStream, &ck );
						if( FAILED( hr ) )
						{
							DeletePart( pPart );
			                goto ON_ERROR;
						}
						if( hr == S_FALSE )
						{
							// This should not happen when loading a Style!
							ASSERT( 0 );
							// Bypass this Part because Style already contains a Part
							// whose GUID matches pPart->m_guidPartID
							DeletePart( pPart );
						}
						break;

					case DMUS_FOURCC_PATTERN_LIST:
					{
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						CDirectMusicPattern* pPattern = new CDirectMusicPattern( this, FALSE );
						if( pPattern == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPattern->Load( pIStream );
						if( FAILED( hr ) )
						{
							RELEASE( pPattern );
			                goto ON_ERROR;
						}
						if( pPattern->m_wEmbellishment & EMB_MOTIF )
						{
							m_StyleMotifs.m_lstMotifs.AddTail( pPattern );
						}
						else
						{
							m_StylePatterns.m_lstPatterns.AddTail( pPattern );
						}
						break;
					}

					case DMUS_FOURCC_STYLE_PERS_REF_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_REF_LIST:
										{
											CPersonality* pPersonality = new CPersonality();
											if( pPersonality == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}
											hr = pPersonality->DM_LoadPersonalityRef( pIRiffStream, &ckList );
											if( FAILED( hr ) )
											{
												delete pPersonality;
												goto ON_ERROR;
											}
											if( m_StylePersonalities.m_lstPersonalities.IsEmpty() )
											{
												pPersonality->m_fDefault = TRUE;
											}
											m_StylePersonalities.m_lstPersonalities.AddTail( pPersonality );
											break;
										}
									}
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;

			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_BAND_FORM: //ECW DM band within IMA2.5 Style (mainly for testing/conversion)
					case FOURCC_BAND_FORM:
						hr = theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						// Make sure Band name is unique
						GetUniqueBandName( pINode );
						m_StyleBands.m_lstBands.AddTail( pINode );
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

	// Delete Parts with m_dwUseCount of zero
    pos = m_lstStyleParts.GetHeadPosition();
    while( pos )
    {
        pPart = m_lstStyleParts.GetNext( pos );

		if( pPart->m_dwUseCount == 0 )
		{
			// This should not happen!
			ASSERT( 0 );
			DeletePart( pPart );
		}
	}

	// Mark all 'linked' PartRefs that point to a part with m_dwUseCount of one as 'unlinked'
	UpdateLinkFlags();

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::UNDO_LoadStyle

HRESULT CDirectMusicStyle::UNDO_LoadStyle( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
    IDMUSProdRIFFExt* pIRIFFExt;
    IDMUSProdNode*    pINode;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIBandComponent != NULL );

	// Following strings only saved when they have values
	// So make sure they are initialized!!
	m_strCategoryName.Empty();
	m_strAuthor.Empty();
	m_strCopyright.Empty();
	m_strSubject.Empty();
	m_strInfo.Empty();

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_STYLE_CHUNK:
			{
			    DMUS_IO_STYLE dmusStyleIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
				hr = pIStream->Read( &dmusStyleIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				DirectMusicTimeSig	timeSig;
			
				timeSig.m_bBeatsPerMeasure = dmusStyleIO.timeSig.bBeatsPerMeasure;
				timeSig.m_bBeat = dmusStyleIO.timeSig.bBeat;
				timeSig.m_wGridsPerBeat = dmusStyleIO.timeSig.wGridsPerBeat;

				SetTimeSignature( timeSig, TRUE );
				SetTempo( dmusStyleIO.dblTempo, TRUE );
				break;
			}

			case DMUS_FOURCC_STYLE_UI_CHUNK:
			{
			    ioDMStyleUI iDMStyleUI;

				dwSize = min( ck.cksize, sizeof( ioDMStyleUI ) );
				hr = pIStream->Read( &iDMStyleUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// m_nSplitterYPos = iDMStyleUI.m_nSplitterYPos;
				// m_dwNotationType = iDMStyleUI.m_dwNotationType;
				break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidStyle, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusStyleVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusStyleVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwVersionMS = dmusStyleVersionIO.dwVersionMS;
				m_dwVersionLS = dmusStyleVersionIO.dwVersionLS;
				break;
			}

			case DMUS_FOURCC_DEFAULT_BAND_UI_CHUNK:
			{
				CString strBandName;

				ReadMBSfromWCS( pIStream, ck.cksize, &strBandName );
				IDMUSProdNode* pIBandNode = GetBandNodeByName( strBandName );
				if( pIBandNode )
				{
					SetDefaultBand( pIBandNode, TRUE );
					pIBandNode->Release();
				}
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_INFO_LIST:
					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case DMUS_FOURCC_UNAM_CHUNK:
								{
									CString strName;

									ReadMBSfromWCS( pIStream, ckList.cksize, &strName );
									if( strName.CompareNoCase( m_strName ) != 0 )
									{
										m_strName = strName;
										theApp.m_pStyleComponent->m_pIFramework->RefreshNode( this );

										// Notify connected nodes that Style name has changed
										theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, STYLE_NameChange, NULL );
									}
									break;
								}

								case RIFFINFO_IART:
								case DMUS_FOURCC_UART_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
									break;

								case RIFFINFO_ICOP:
								case DMUS_FOURCC_UCOP_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
									break;

								case RIFFINFO_ISBJ:
								case DMUS_FOURCC_USBJ_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
									break;

								case RIFFINFO_ICMT:
								case DMUS_FOURCC_UCMT_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
									break;

								case DMUS_FOURCC_CATEGORY_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCategoryName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;

			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case FOURCC_BAND_FORM:
						hr = theApp.m_pStyleComponent->m_pIBandComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						m_StyleBands.InsertChildNode( pINode );
						break;

					case DMUS_FOURCC_PATTERN_LIST:
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						CDirectMusicPattern* pPattern = new CDirectMusicPattern( this, FALSE );
						if( pPattern == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}
						hr = pPattern->Load( pIStream );
						if( FAILED( hr ) )
						{
							RELEASE( pPattern );
			                goto ON_ERROR;
						}
						if( pPattern->m_wEmbellishment & EMB_MOTIF )
						{
							m_StyleMotifs.InsertChildNode( pPattern );
						}
						else
						{
							m_StylePatterns.InsertChildNode( pPattern );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle IDMUSProdNotifySink implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::OnUpdate

HRESULT CDirectMusicStyle::OnUpdate( IDMUSProdNode* pINode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	if( ::IsEqualGUID( guidUpdateType, BAND_ValidateNameChange ) )
	{
		BSTR bstrBandName;

		// Make sure name of Band is unique
		if( SUCCEEDED ( pINode->GetNodeName( &bstrBandName ) ) )
		{
			CString strBandName = bstrBandName;
			::SysFreeString( bstrBandName );

			if( IsBandNameUnique( pINode, strBandName ) == FALSE )
			{
				CString strMsg;

				AfxFormatString1( strMsg, IDS_DUPE_BAND_NAME, strBandName );
				AfxMessageBox( strMsg, MB_OK );
				return S_FALSE;
			}
		}
	}
	else if( ::IsEqualGUID( guidUpdateType, BAND_NameChange ) )
	{
		// Refresh Style editor (when open)
		SyncStyleEditor( SSE_BANDS );
	}
	else if( ::IsEqualGUID( guidUpdateType, GUID_BAND_ChangeNotifyMsg )
		 ||  ::IsEqualGUID( guidUpdateType, GUID_BAND_ActivateNotifyMsg ) )
	{
		if( IsInStyleBandList( pINode ) )
		{
			if( m_pIActiveBandNode != pINode )
			{
				SetActiveBand( pINode );
				if( m_pStyleCtrl
				&&  m_pStyleCtrl->m_pStyleDlg )
				{
					m_pStyleCtrl->m_pStyleDlg->SelectBand( pINode );
				}

				// Set SetActiveBand takes care of sending everything so return S_FALSE
				return S_FALSE;	
			}
		}
		else
		{
			if( ::IsEqualGUID( guidUpdateType, GUID_BAND_ChangeNotifyMsg ) )
			{
				// Check to see which Motif contains the Band
				POSITION pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
				while( pos )
				{
					CDirectMusicPattern* pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
				
					if( pMotif->m_pIBandNode == pINode )
					{
						pMotif->SetModified( TRUE );
						pMotif->SyncPatternWithDirectMusic();
						break;
					}
				}
			}
		}

		if( SyncBand( pINode ) != S_OK )
		{
			return S_FALSE;
		}
	}
	else if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileNameChange) 
		 &&  (pINode == this) )
	{
		// Updates the names of the Style's Patterns in the Transport toolbar
		POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			CDirectMusicPattern* pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
			BSTR bstrTransportName;

			if( SUCCEEDED ( pPattern->GetName( &bstrTransportName ) ) )
			{
				theApp.m_pStyleComponent->m_pIConductor->SetTransportName( pPattern, bstrTransportName );
			}
		}

		// Updates the names of the Style's Motifs in the Transport toolbars
		pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			CDirectMusicPattern* pPattern = m_StyleMotifs.m_lstMotifs.GetNext( pos );
			BSTR bstrTransportName;

			if( SUCCEEDED ( pPattern->GetName( &bstrTransportName ) ) )
			{
				theApp.m_pStyleComponent->m_pIConductor->SetTransportName( pPattern, bstrTransportName );
				if( SUCCEEDED ( pPattern->GetName( &bstrTransportName ) ) )
				{
					theApp.m_pStyleComponent->m_pIConductor->SetSecondaryTransportName( pPattern, bstrTransportName );
				}
			}
		}
	}
	else if( ::IsEqualGUID( guidUpdateType, STYLE_NotationTypeChange ) )
	{
		ASSERT( pData );
		if( pData )
		{
			if( m_dwNotationType != *(static_cast<DWORD *>(pData)) )
			{
				m_dwNotationType = *(static_cast<DWORD *>(pData));

				// Update the Style's Patterns with the new notation type
				POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
				while( pos )
				{
					CDirectMusicPattern* pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
					if( pPattern->m_pPatternCtrl
					&&	pPattern->m_pPatternCtrl->m_pPatternDlg
					&&	pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr )
					{
						pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->OnUpdate( STYLE_NotationTypeChange, 0xFFFFFFFF, pData );
					}
				}

				// Update the Style's Motifs with the new notation type
				pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
				while( pos )
				{
					CDirectMusicPattern* pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
					if( pMotif->m_pPatternCtrl
					&&	pMotif->m_pPatternCtrl->m_pPatternDlg
					&&	pMotif->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr )
					{
						pMotif->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->OnUpdate( STYLE_NotationTypeChange, 0xFFFFFFFF, pData );
					}
				}
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::RegisterWithTransport

HRESULT CDirectMusicStyle::RegisterWithTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicPattern* pPattern;
	CDirectMusicPattern* pMotif;
	HRESULT hr;

	// Register the Style's Patterns with the Transport Controls
    POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
    {
        pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		hr = pPattern->RegisterWithTransport();
		if( FAILED( hr ) )
		{
			return hr;
		}
    }

	// Register the Style's Motifs with the Transport Controls
    pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
    {
        pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		hr = pMotif->RegisterWithTransport();
		if( FAILED( hr ) )
		{
			return hr;
		}
    }

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::UnRegisterWithTransport

HRESULT CDirectMusicStyle::UnRegisterWithTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicPattern* pPattern;
	CDirectMusicPattern* pMotif;

	// Unregister the Style's Patterns with the Transport Controls
    POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
    {
        pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		pPattern->UnRegisterWithTransport();
    }

	// Register the Style's Motifs with the Transport Controls
    pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
    {
        pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		pMotif->UnRegisterWithTransport();
    }

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::FindPartByGUID

CDirectMusicPart* CDirectMusicStyle::FindPartByGUID( GUID guidPartID )
{
	CDirectMusicPart* pThePart = NULL;
	CDirectMusicPart* pPart;

	POSITION pos = m_lstStyleParts.GetHeadPosition();
	while( pos )
	{
		pPart = m_lstStyleParts.GetNext( pos );
		
		if( ::IsEqualGUID( pPart->m_guidPartID, guidPartID ) )
		{
			pThePart = pPart;
			break;
		}
	}

	return pThePart;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::AllocPart

CDirectMusicPart* CDirectMusicStyle::AllocPart( void )
{
	CDirectMusicPart* pPart = new CDirectMusicPart( this );

	if( pPart )
	{
		pPart->m_pPartDesignData = (ioDMStylePartDesign *)GlobalAlloc( GPTR, sizeof(ioDMStylePartDesign) );

		if( pPart->m_pPartDesignData )
		{
			pPart->m_dwPartDesignDataSize = sizeof(ioDMStylePartDesign);

			// Add Part to Style's list of Parts
			m_lstStyleParts.AddTail( pPart );
		}
		else
		{
			delete pPart;
			pPart = NULL;
		}
	}

	return pPart;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::DeletePart

void CDirectMusicStyle::DeletePart( CDirectMusicPart* pPart )
{
	ASSERT( pPart != NULL );
	ASSERT( pPart->m_dwUseCount == 0 );

	// Remove Part from Style's Part list
	POSITION pos = m_lstStyleParts.Find( pPart );

	if( pos )
	{
		m_lstStyleParts.RemoveAt( pos );
	}

	delete pPart;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::AddPattern

HRESULT CDirectMusicStyle::AddPattern( CDirectMusicPattern* pPattern,
									   CDirectMusicPattern* pPositionPattern )
{
	ASSERT( pPattern != NULL );
	if( pPattern == NULL )
	{
		return E_INVALIDARG;
	}

	pPattern->AddRef();

	// Add to CDirectMusicStyle Pattern list
	POSITION pos = NULL;

	if( pPositionPattern )
	{
		pos = m_StylePatterns.m_lstPatterns.Find( pPositionPattern );
	}

	if( pos )
	{
		m_StylePatterns.m_lstPatterns.InsertBefore( pos, pPattern );
	}
	else
	{
		m_StylePatterns.m_lstPatterns.AddTail( pPattern );
	}

	// Sync Style editor (when open)
	SyncStyleEditor( SSE_PATTERNS );
	if( m_pStyleCtrl
	&&  m_pStyleCtrl->m_pStyleDlg )
	{
		m_pStyleCtrl->m_pStyleDlg->SelectPattern( pPattern );
	}

	// Update the DirectMusic Style object
	HRESULT hr = SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	// Pattern needs transport controls
	hr = pPattern->RegisterWithTransport();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::RemovePattern

HRESULT CDirectMusicStyle::RemovePattern( CDirectMusicPattern* pPattern )
{
	BOOL fChange = FALSE;
	
	ASSERT( pPattern != NULL );

	// Pattern no longer needs transport controls
	pPattern->UnRegisterWithTransport();

	// Remove from CDirectMusicStyle Pattern list
	POSITION pos = m_StylePatterns.m_lstPatterns.Find( pPattern );
	if( pos )
	{
		m_StylePatterns.m_lstPatterns.RemoveAt( pos );

		pPattern->PreDeleteCleanup();

		// See if we need to deal with link flags or the var. choices window
		POSITION pos2 = pPattern->m_lstPartRefs.GetHeadPosition();
		while( pos2 )
		{
			CDirectMusicPartRef* pDMPartRef = pPattern->m_lstPartRefs.GetNext( pos2 );

			if( pDMPartRef->m_pDMPart
			&&	(pDMPartRef->m_pDMPart->m_pVarChoicesPartRef == pDMPartRef) )
			{
				// Close the variation choices dialog
				if( pDMPartRef->m_pDMPart->m_pVarChoicesNode )
				{
					HWND hWndEditor;
					pDMPartRef->m_pDMPart->m_pVarChoicesNode->GetEditorWindow( &hWndEditor );
					if( hWndEditor )
					{
						theApp.m_pStyleComponent->m_pIFramework->CloseEditor( pDMPartRef->m_pDMPart->m_pVarChoicesNode );
					}
					RELEASE( pDMPartRef->m_pDMPart->m_pVarChoicesNode );
				}
				pDMPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
			}

			if( pDMPartRef->m_fHardLink )
			{
				pPattern->DeletePartRef( pDMPartRef );
				fChange = TRUE;
			}
		}

		RELEASE( pPattern );
	}

	// Sync Style editor (when open)
	SyncStyleEditor( SSE_PATTERNS );

	// Update link flags when necessary
	if( fChange )
	{
		UpdateLinkFlags();
	}

	// Update the DirectMusic Style object
	HRESULT hr = SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::AddMotif

HRESULT CDirectMusicStyle::AddMotif( CDirectMusicPattern* pMotif,
									 CDirectMusicPattern* pPositionMotif )
{
	ASSERT( pMotif != NULL );
	if( pMotif == NULL )
	{
		return E_INVALIDARG;
	}

	pMotif->AddRef();

	// Add to CDirectMusicStyle Motif list
	POSITION pos = NULL;

	if( pPositionMotif )
	{
		pos = m_StyleMotifs.m_lstMotifs.Find( pPositionMotif );
	}

	if( pos )
	{
		m_StyleMotifs.m_lstMotifs.InsertBefore( pos, pMotif );
	}
	else
	{
		m_StyleMotifs.m_lstMotifs.AddTail( pMotif );
	}

	// Sync Style editor (when open)
	SyncStyleEditor( SSE_MOTIFS );
	if( m_pStyleCtrl
	&&  m_pStyleCtrl->m_pStyleDlg )
	{
		m_pStyleCtrl->m_pStyleDlg->SelectMotif( pMotif );
	}

	// Update the DirectMusic Style object
	HRESULT hr = SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	// Motif needs transport controls
	hr = pMotif->RegisterWithTransport();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::RemoveMotif

HRESULT CDirectMusicStyle::RemoveMotif( CDirectMusicPattern* pMotif )
{
	CDirectMusicPartRef* pDMPartRef;
	BOOL fChange = FALSE;
	
	ASSERT( pMotif != NULL );

	// Motif no longer needs transport controls
	pMotif->UnRegisterWithTransport();

	// Remove from CDirectMusicStyle Motif list
	POSITION pos = m_StyleMotifs.m_lstMotifs.Find( pMotif );
	if( pos )
	{
		m_StyleMotifs.m_lstMotifs.RemoveAt( pos );

		pMotif->PreDeleteCleanup();

		// See if we need to deal with link flags
		POSITION pos2 = pMotif->m_lstPartRefs.GetHeadPosition();
		while( pos2 )
		{
			pDMPartRef = pMotif->m_lstPartRefs.GetNext( pos2 );

			if( pDMPartRef->m_fHardLink )
			{
				pMotif->DeletePartRef( pDMPartRef );
				fChange = TRUE;
			}
		}
		
		RELEASE( pMotif );
	}

	// Sync Style editor (when open)
	SyncStyleEditor( SSE_MOTIFS );

	// Update link flags when necessary
	if( fChange )
	{
		UpdateLinkFlags();
	}

	// Update the DirectMusic Style object
	HRESULT hr = SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SyncBand

HRESULT CDirectMusicStyle::SyncBand( IDMUSProdNode* pIBandNode )
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	IDirectMusicSegment* pIDMSegment = NULL;

	if( IsInStyleBandList( pIBandNode ) )
	{
		CDirectMusicPattern* pPattern;
		CDirectMusicPattern* pMotif;

		// See if Conductor is playing a Pattern in this Style
		POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );

			if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pPattern ) == S_OK )
			{
				if( pPattern->m_pIDMSegment )
				{
					// We are playing a Pattern in this Style...
					// so we must sync the Band we are hearing 
					pPattern->m_pIDMSegment->AddRef();
					pIDMSegment = pPattern->m_pIDMSegment;
				}
			}

			// Redraw the functionbar areas, since the band may have changed
			if( pPattern->m_pPatternCtrl
			&&	pPattern->m_pPatternCtrl->m_pPatternDlg
			&&	pPattern->m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
			{
				pPattern->m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->NotifyStripMgrs( GUID_Segment_BandTrackChange, 0xFFFFFFFF, NULL );
			}
		}

		// See if Conductor is playing a Motif in this Style
		pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

			if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pMotif ) == S_OK )
			{
				if( pMotif->m_pIDMSegment )
				{
					// We are playing a Motif that does not have an associated Band...
					// so we must sync the Band we are hearing 
					if( pMotif->m_pIBandNode == NULL )
					{
						pMotif->m_pIDMSegment->AddRef();
						pIDMSegment = pMotif->m_pIDMSegment;
					}
				}
			}

			// Redraw the functionbar areas, since the band may have changed
			if( pMotif->m_pPatternCtrl
			&&	pMotif->m_pPatternCtrl->m_pPatternDlg
			&&	pMotif->m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl )
			{
				pMotif->m_pPatternCtrl->m_pPatternDlg->m_pITimelineCtl->NotifyStripMgrs( GUID_Segment_BandTrackChange, 0xFFFFFFFF, NULL );
			}
		}
	}
	else
	{
		CDirectMusicPattern* pMotif;

		// See if Conductor is playing a Motif in this Style
		POSITION pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

			if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pMotif ) == S_OK )
			{
				if( pMotif->m_pIDMSegment )
				{
					// We are playing this Motif 
					if( pMotif->m_pIBandNode == pIBandNode )
					{
						// Motif's Band has changed...
						// so we must sync the Band we are hearing 
						pMotif->m_pIDMSegment->AddRef();
						pIDMSegment = pMotif->m_pIDMSegment;
					}
				}
			}
		}
	}

	if( pIDMSegment )
	{
		// We need to sync the Band we are hearing
		CWaitCursor wait;

		// Persist the Band into a DirectMusicBand object
		IDirectMusicBand* pIDMBand = GetDMBand( pIBandNode );
		if( pIDMBand )
		{
			// Update the Band in the Band Track
			IDirectMusicTrack* pIDMTrack;

			if( SUCCEEDED ( pIDMSegment->GetTrack( CLSID_DirectMusicBandTrack, 1, 0, &pIDMTrack ) ) )
			{
				// Just clear the Band track so that it won't interfere
				// with realtime changes when the Pattern loops
				pIDMTrack->SetParam( GUID_Clear_All_Bands, 0, NULL );
				RELEASE( pIDMTrack );
			}

			RELEASE( pIDMBand );
		}

		RELEASE( pIDMSegment );
		
		// S_OK means this Band is playing
		return S_OK;
	}


	IDirectMusicSegment* pIDMSegmentTemp = GetSegmentThatIsPlaying();
	if( pIDMSegmentTemp )
	{
		// Nothing in Style is playing so we need to sync with DirectMusic now
		RELEASE( pIDMSegmentTemp );
		ForceSyncStyleWithDirectMusic();
	}

	// S_FALSE means this Band is not playing
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SendBand

void CDirectMusicStyle::SendBand( IDMUSProdNode* pIBandNode )
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	IDirectMusicSegment* pIDMSegment = NULL;

	if( IsInStyleBandList( pIBandNode ) )
	{
		CDirectMusicPattern* pPattern;
		CDirectMusicPattern* pMotif;

		// See if Conductor is playing a Pattern in this Style
		POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );

			if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pPattern ) == S_OK )
			{
				if( pPattern->m_pIDMSegment )
				{
					// We are playing a Pattern in this Style...
					// so we must sync the Band we are hearing 
					pPattern->m_pIDMSegment->AddRef();
					pIDMSegment = pPattern->m_pIDMSegment;
				}
			}
		}

		if( pIDMSegment == NULL )
		{
			// See if Conductor is playing a Motif in this Style
			pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
			while( pos )
			{
				pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

				if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pMotif ) == S_OK )
				{
					if( pMotif->m_pIDMSegment )
					{
						// We are playing a Motif that does not have an associated Band...
						// so we must sync the Band we are hearing 
						if( pMotif->m_pIBandNode == NULL )
						{
							pMotif->m_pIDMSegment->AddRef();
							pIDMSegment = pMotif->m_pIDMSegment;
						}
					}
				}
			}
		}
	}
	else
	{
		CDirectMusicPattern* pMotif;

		// See if Conductor is playing a Motif in this Style
		POSITION pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

			if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pMotif ) == S_OK )
			{
				if( pMotif->m_pIDMSegment )
				{
					// We are playing this Motif 
					if( pMotif->m_pIBandNode == pIBandNode )
					{
						// Motif's Band has changed...
						// so we must sync the Band we are hearing 
						pMotif->m_pIDMSegment->AddRef();
						pIDMSegment = pMotif->m_pIDMSegment;
					}
				}
			}
		}
	}

	if( pIDMSegment )
	{
		// This Style is playing
		CWaitCursor wait;

		// Persist the Band into a DirectMusicBand object
		IDirectMusicBand* pIDMBand = GetDMBand( pIBandNode );
		if( pIDMBand )
		{
			// Update the Band in the Band Track
			IDirectMusicTrack* pIDMTrack;

			if( SUCCEEDED ( pIDMSegment->GetTrack( CLSID_DirectMusicBandTrack, 1, 0, &pIDMTrack ) ) )
			{
				pIDMTrack->SetParam( GUID_Clear_All_Bands, 0, NULL );
				pIDMTrack->SetParam( GUID_IDirectMusicBand, 0, pIDMBand );

				// Invalidate queued events
				MUSIC_TIME mtTimeNow;
				theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtTimeNow );
				theApp.m_pStyleComponent->m_pIDMPerformance->Invalidate( mtTimeNow, 0 );

				RELEASE( pIDMTrack );
			}

			// Send the Band
			IDirectMusicSegment* pIDMSegmentBand;

			if( SUCCEEDED ( pIDMBand->CreateSegment( &pIDMSegmentBand ) ) )
			{
				theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegment( pIDMSegmentBand,
										 (DMUS_SEGF_SECONDARY | 0), 0, NULL );
				RELEASE( pIDMSegmentBand );
			}

			RELEASE( pIDMBand );
		}

		RELEASE( pIDMSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetActiveBand

IDMUSProdNode* CDirectMusicStyle::GetActiveBand()
{
	return m_pIActiveBandNode;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetDMBand

IDirectMusicBand* CDirectMusicStyle::GetDMBand( IDMUSProdNode* pIBandNode )
{
	ASSERT( pIBandNode != NULL );

	IDirectMusicBand* pIDMBand = NULL;
	BOOL fSuccess = FALSE;

	// Persist the Band into a DirectMusicBand object
	if( SUCCEEDED ( ::CoCreateInstance( CLSID_DirectMusicBand, NULL, CLSCTX_INPROC, 
										IID_IDirectMusicBand, (void**)&pIDMBand ) ) )
	{
		IStream* pIMemStream;
		IPersistStream* pIPersistStream;
		IPersistStream* pIPersistStreamEngine;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream ) ) )
		{
			if( SUCCEEDED ( pIBandNode->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
			{
				if( SUCCEEDED ( pIPersistStream->Save( pIMemStream, FALSE ) ) )
				{
					if( SUCCEEDED ( pIDMBand->QueryInterface( IID_IPersistStream, (void **)&pIPersistStreamEngine ) ) )
					{
						StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
						if( SUCCEEDED ( pIPersistStreamEngine->Load( pIMemStream ) ) )
						{
							fSuccess = TRUE;
						}

						RELEASE( pIPersistStreamEngine );
					}
				}

				RELEASE( pIPersistStream );
			}

			RELEASE( pIMemStream );
		}
	}

	if( fSuccess == FALSE )
	{
		if( pIDMBand )
		{
			pIDMBand->Release();
			pIDMBand = NULL;
		}
	}

	return pIDMBand;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::IsInStyleBandList

BOOL CDirectMusicStyle::IsInStyleBandList( IDMUSProdNode* pIBandNode )
{
	BOOL fInList = FALSE;
 
	POSITION pos = m_StyleBands.m_lstBands.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = m_StyleBands.m_lstBands.GetNext( pos );

		if( pINode == pIBandNode )
		{
			fInList = TRUE;
			break;
		}
	}

	return fInList;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SetActiveBand

void CDirectMusicStyle::SetActiveBand( IDMUSProdNode* pIBandNode )
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pIActiveBandNode == pIBandNode )
	{
		return;
	}

	// pIBandNode must be in m_StyleBands list of bands
	if( IsInStyleBandList( pIBandNode ) == FALSE )
	{
		return;
	}

	RELEASE( m_pIActiveBandNode );

	if( pIBandNode )
	{
		CDirectMusicPattern* pPattern;
		CDirectMusicPattern* pMotif;

		m_pIActiveBandNode = pIBandNode;
		m_pIActiveBandNode->AddRef();

		SendBand( m_pIActiveBandNode );

		// Refresh all Pattern editors to display proper DLS names
		POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );

			if( pPattern->m_pPatternCtrl
			&&  pPattern->m_pPatternCtrl->m_pPatternDlg )
			{
				pPattern->m_pPatternCtrl->m_pPatternDlg->Invalidate();
			}
		}

		// Refresh all Motif editors to display proper DLS names
		pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

			if( pMotif->m_pPatternCtrl
			&&  pMotif->m_pPatternCtrl->m_pPatternDlg )
			{
				pMotif->m_pPatternCtrl->m_pPatternDlg->Invalidate();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::RemoveActiveBand

void CDirectMusicStyle::RemoveActiveBand( IDMUSProdNode* pIBandNode )
{
	ASSERT( pIBandNode != NULL );

	if( m_pIActiveBandNode == pIBandNode )
	{
		RELEASE( m_pIActiveBandNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetSegmentThatIsPlaying

IDirectMusicSegment* CDirectMusicStyle::GetSegmentThatIsPlaying()
{
	CDirectMusicPattern* pPattern;
	CDirectMusicPattern* pMotif;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIConductor != NULL );

	// See if Conductor is playing a Pattern in this Style
	POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );

		if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pPattern ) == S_OK )
		{
			if( pPattern->m_pIDMSegment )
			{
				pPattern->m_pIDMSegment->AddRef();
				return pPattern->m_pIDMSegment;
			}
		}
	}

	// See if Conductor is playing a Motif in this Style
	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );

		if( theApp.m_pStyleComponent->m_pIConductor->IsTransportPlaying( pMotif ) == S_OK )
		{
			if( pMotif->m_pIDMSegment )
			{
				pMotif->m_pIDMSegment->AddRef();
				return pMotif->m_pIDMSegment;
			}
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SetTempo

void CDirectMusicStyle::SetTempo( double dblTempo, BOOL fInUndo )
{
	ASSERT( m_pIDMStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );

	if( dblTempo != m_dblTempo )
	{
		// Change tempo if currently auditioning this Style
		IDirectMusicSegment* pIDMSegment = GetSegmentThatIsPlaying();
		if( pIDMSegment )
		{
			// Change tempo now!!!
			DMUS_TEMPO_PMSG* pTempo;

			if( SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
				(DMUS_PMSG**)&pTempo ) ) )
			{
				// Queue tempo event
				ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
				pTempo->dblTempo = dblTempo;
				pTempo->dwFlags = DMUS_PMSGF_REFTIME;
				pTempo->dwType = DMUS_PMSGT_TEMPO;
				theApp.m_pStyleComponent->m_pIDMPerformance->SendPMsg( (DMUS_PMSG*)pTempo );
			}

			RELEASE( pIDMSegment );
		}

		// Change default tempo of Style
		if( fInUndo == FALSE )
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_STYLE_TEMPO );
		}

		m_dblTempo = dblTempo;
		
		CDirectMusicPattern* pPattern;
		CDirectMusicPattern* pMotif;

		// Change timeline "tempo" in all Pattern editors
		POSITION pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
			pPattern->SyncTempo();
		}
		
		// Change timeline "tempo" in all Motif editors
		pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
			pMotif->SyncTempo();
		}
		
		// Update DirectMusic Style object
		SyncStyleWithDirectMusic();

		if( fInUndo == FALSE )
		{
			// Refresh Style editor (when open)
			SyncStyleEditor( SSE_STYLE );

			// Sync change with property sheet
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				pIPropSheet->RefreshActivePageByObject( this );
				RELEASE( pIPropSheet );
			}
		
			SetModified( TRUE );
		}

		// Notify connected nodes that Style tempo has changed
		theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, STYLE_TempoChange, &m_dblTempo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SetTimeSignature

void CDirectMusicStyle::SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fInUndo )
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( timeSig.m_bBeatsPerMeasure != m_TimeSignature.m_bBeatsPerMeasure
	||  timeSig.m_bBeat != m_TimeSignature.m_bBeat
	||  timeSig.m_wGridsPerBeat != m_TimeSignature.m_wGridsPerBeat )
	{
		CWaitCursor wait;

		CDirectMusicPart* pPart;
		CDirectMusicPattern* pPattern;
		CDirectMusicPattern* pMotif;

		// FIRST!! - Change time signature of all Parts
		POSITION pos = m_lstStyleParts.GetHeadPosition();
		while( pos )
		{
			pPart = m_lstStyleParts.GetNext( pos );
			pPart->SetTimeSignature( timeSig, fInUndo, TRUE );
		}
		
		// Change time signature of all Patterns
		pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
		while( pos )
		{
			pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
			pPattern->SetTimeSignature( timeSig, FALSE );
		}
		
		// Change time signature of all Motifs
		pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
		while( pos )
		{
			pMotif = m_StyleMotifs.m_lstMotifs.GetNext( pos );
			pMotif->SetTimeSignature( timeSig, FALSE );
		}
		
		// Change time signature of Style
		if( fInUndo == FALSE )
		{
			m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_STYLE_TIME_SIGNATURE );
		}
		m_TimeSignature = timeSig;

		if( fInUndo == FALSE )
		{
			// Refresh Style editor (when open)
			SyncStyleEditor( (SSE_STYLE | SSE_PATTERNS | SSE_MOTIFS) );

			// Sync change with property sheet
			IDMUSProdPropSheet* pIPropSheet;
			if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				pIPropSheet->RefreshActivePageByObject( this );
				RELEASE( pIPropSheet );
			}

			SetModified( TRUE );
			SyncStyleWithDirectMusic();
		}

		// Notify connected nodes that Style time signature has changed
		theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, STYLE_TimeSigChange, &m_TimeSignature );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetTheDefaultBand

IDMUSProdNode* CDirectMusicStyle::GetTheDefaultBand()
{
	IDMUSProdBandEdit* pIBandEdit;
	IDMUSProdNode* pINode;
	BOOL fDefaultFlag;

    POSITION pos = m_StyleBands.m_lstBands.GetHeadPosition();
	while( pos )
    {
        pINode = m_StyleBands.m_lstBands.GetNext( pos );

		if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
		{
			if( FAILED ( pIBandEdit->GetDefaultFlag( &fDefaultFlag ) ) )
			{
				fDefaultFlag = FALSE;
			}

			RELEASE( pIBandEdit );

			if( fDefaultFlag )
			{
				return pINode;
			}
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SetDefaultBand

void CDirectMusicStyle::SetDefaultBand( IDMUSProdNode* pIDefaultBandNode, BOOL fInUndo )
{
	IDMUSProdBandEdit* pIBandEdit;
	IDMUSProdNode* pINode;

    POSITION pos = m_StyleBands.m_lstBands.GetHeadPosition();
	while( pos )
    {
        pINode = m_StyleBands.m_lstBands.GetNext( pos );

		if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
		{
			pIBandEdit->SetDefaultFlag( pINode == pIDefaultBandNode );
			RELEASE( pIBandEdit );
		}
    }

	if( pIDefaultBandNode == NULL )
	{
		// Set first Band to be the "Default" Band
		pos = m_StyleBands.m_lstBands.GetHeadPosition();
		if( pos )
		{
			pINode = m_StyleBands.m_lstBands.GetNext( pos );

			if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
			{
				pIBandEdit->SetDefaultFlag( TRUE );
				RELEASE( pIBandEdit );
			}
		}
	}

	if( fInUndo == FALSE )
	{
		// Refresh Style editor (when open)
		SyncStyleEditor( SSE_STYLE );
	
		SetModified( TRUE );
		SyncStyleWithDirectMusic();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////
// AddOffset, correct time, offset for specified meter
static void AddOffsets(FullSeqEvent* lstEvent, DirectMusicTimeSig TimeSig)
//static void AddOffsets(FullSeqEvent* lstEvent, DMUS_IO_TIMESIGNATURE_ITEM timesig)
//
//	Add offsets relative to measure/beat/grid
//
{
//	HRESULT hr;
//	timesig.bBeat = 4;
//	timesig.bBeatsPerMeasure =  4;
//	timesig.wGridsPerBeat = 4;
//	timesig.lTime = 0;
	short nClocksPerGrid = static_cast<short>(((DMUS_PPQ * 4) / TimeSig.m_bBeat) / TimeSig.m_wGridsPerBeat);
	//short nClocksPerGrid = static_cast<short>(((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat);


	for( FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
	{
		if ( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			long lGrid = TS_GRID_TO_CLOCKS( TS_CLOCKS_TO_GRID( pEvent->mtTime, TimeSig ), TimeSig );
			pEvent->nOffset = (short)(pEvent->mtTime - lGrid);
			//pEvent->nOffset = (short) ((pEvent->mtTime - timesig.lTime) % nClocksPerGrid);
			pEvent->mtTime -= pEvent->nOffset;
			if (pEvent->nOffset > (nClocksPerGrid / 2))
			{
				// make it a negative offset and bump the time a corresponding amount
				pEvent->nOffset = static_cast<short>(pEvent->nOffset - nClocksPerGrid);
				pEvent->mtTime += nClocksPerGrid;
			}
		}
	}

}




/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::CreatePatternFromMIDIStream

bool gbIsXG;

bool IsXG()
{
	return gbIsXG;
}

HRESULT CDirectMusicStyle::CreatePatternFromMIDIStream(CDirectMusicPattern* pPattern, IDMUSProdNode* pBandNode, LPSTREAM pStream, CString strFile)
{

	gbIsXG = false;

	if(pPattern == NULL || pBandNode == NULL, pStream == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;
    DWORD dwID;
    DWORD dwCurTime;
    DWORD dwLength;
	DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
    FullSeqEvent** lstEvent;
    LPSTR* lstTrackNames = NULL;
	DMUS_IO_PATCH_ITEM* lstPatchEvent;
	FullSeqEvent* lstTrackEvent;
	IDMUSProdRIFFStream*	pRiffStream = 0;

	/*
	MIDITimeSigFlag() = 1;
	MIDITimeSig().lTime = 0;
	MIDITimeSig().bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
	MIDITimeSig().bBeat = m_TimeSignature.m_bBeat;
	MIDITimeSig().wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;
	*/

    lstPatchEvent = NULL;
    nNumTracks = nTracksRead = 0;
    dwLength = 0;
	DWORD dwMaxLength = 0;
	long iTrack = 0;

	MIDIInit();
//	MIDIInitBankSelect();
//	MIDIInitChordOfComposition();

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
		!GetMLong( pStream, dwSize ) )
    {
		return E_FAIL;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
		StreamSeek( pStream, 12, STREAM_SEEK_CUR );
		if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
			!GetMLong( pStream, dwSize ) )
		{
			return E_FAIL;
		}
    }
// check for normal MIDI files
	if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
	{
		return E_FAIL;
	}

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    
	lstEvent = new FullSeqEvent*[nNumTracks];
	if( lstEvent == NULL )
	{
		return E_OUTOFMEMORY;
	}
	for( int i=0 ;  i < nNumTracks ; i++ )
	{
		lstEvent[i] = NULL;
	}

    lstTrackNames = new LPSTR[nNumTracks];
	if( lstTrackNames == NULL )
	{
		return E_OUTOFMEMORY;
	}
	for( i=0 ;  i < nNumTracks ; i++ )
	{
		lstTrackNames[i] = NULL;
	}

    GetMShort( pStream, MIDIsnPPQN() );
    if( dwSize > 6 )
    {
		StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
		GetMLong( pStream, dwSize );
		dwCurTime = 0;
		lstTrackEvent = NULL;
		while( dwSize > 0 )
		{
			dwSize -= MIDIGetVarLength( pStream, dwID );
			dwCurTime += dwID;
			DWORD localSize = MIDIReadEvent( pStream, dwCurTime, &lstTrackEvent, &lstPatchEvent, &lstTrackNames[nTracksRead] );
			if(localSize == 0)
			{
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( theApp.m_hInstance );

				CString strMsg;
				AfxFormatString1( strMsg, IDS_ERR_CANNOT_IMPORT_FILE, strFile );
				AfxMessageBox( strMsg );

				AfxSetResourceHandle( hInstance );
				hr = E_FAIL;
				// lstPatchEvent and rest get deleted below.  Since this guy becomes part of lstEvent if
				// we're successful, we can't delete him below, so we delete him here.
				List_Free(lstTrackEvent);
				goto EXIT;
			}
			else
			{
				dwSize -= localSize;
			}
		}
		/*
		if( MIDITimeSigFlag() > 1 )
		{
			// if glTimeSig is greater than 1, it means we've read some time sigs
			// from this track (it was set to 2 inside ReadEvent.) This means that
			// we no longer want ReadEvent to pay any attention to time sigs, so
			// we set this to 0.
			MIDITimeSigFlag() = 0;
		}
		*/
		if( dwCurTime > dwLength )
		{
			dwLength = dwCurTime;
		}

		// Remove duplicated controller messages - lstOther must be in reverse order for this to work
		lstTrackEvent = MIDIRemoveDuplicateCCs( lstTrackEvent );
		lstTrackEvent = MIDIReverseEventList( lstTrackEvent );
		lstTrackEvent = MIDICompressEventList( lstTrackEvent );
//		lstEvent = List_Cat( lstEvent, lstTrackEvent );
	    lstEvent[nTracksRead] = MIDISortEventList( lstTrackEvent );
		AddOffsets(lstEvent[nTracksRead], m_TimeSignature);
		if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
		{
			break;
		}
		nTracksRead++;
    }
	dwLength = MIDIConvertTime(dwLength);

//    lstEvent= MIDISortEventList( lstEvent );

	//AddOffsets(lstEvent, MIDITimeSig());

	DWORD dwClocksPerMeasure;
	MIDIGetChordOfComposition(	pPattern->m_dwDefaultKeyPattern,
								pPattern->m_dwDefaultChordPattern,
								pPattern->m_bDefaultKeyRoot,
								pPattern->m_bDefaultChordRoot,
								pPattern->m_fKeyFlatsNotSharps,
								pPattern->m_fChordFlatsNotSharps);

	for(iTrack = 0; pPattern && iTrack < nNumTracks; iTrack++)
	{
		if(iTrack == 0 && lstPatchEvent && (hr == S_OK))
		{
			IStream* pStream = 0;
			hr = theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream );
			if(SUCCEEDED(hr))
			{
				hr = AllocRIFFStream( pStream, &pRiffStream );
				if(SUCCEEDED(hr))
				{
					hr = WriteBandTrack(pRiffStream, &lstPatchEvent, nNumTracks, lstEvent);
					if(SUCCEEDED(hr))
					{
						// stream node into band
						StreamSeek(pStream, 0, STREAM_SEEK_SET);
						STATSTG stg;
						hr = pStream->Stat(&stg, STATFLAG_NONAME);
						if(hr == S_OK)
						{
							IPersistStream* pIPS = NULL;
							hr = pBandNode->QueryInterface(IID_IPersistStream, (void **)&pIPS);
							if(SUCCEEDED(hr))
							{
								pIPS->Load(pStream);
								pIPS->Release();
							}
						}
					}
				}
				pRiffStream->Release();
				pStream->Release();
			}
		}

		// Populate Parts
		//
		if(hr == S_OK)
		{
			
			dwLength = 0;

			if(iTrack == 0)
			{
				// set up time grid
				pPattern->m_TimeSignature.m_bBeatsPerMeasure = m_TimeSignature.m_bBeatsPerMeasure;
				pPattern->m_TimeSignature.m_bBeat = m_TimeSignature.m_bBeat;
				pPattern->m_TimeSignature.m_wGridsPerBeat = m_TimeSignature.m_wGridsPerBeat;
				DWORD dwClocksPerBeat = DM_PPQNx4 / pPattern->m_TimeSignature.m_bBeat;
				dwClocksPerMeasure = dwClocksPerBeat * (DWORD)pPattern->m_TimeSignature.m_bBeatsPerMeasure;
			}
			// potentially 16 parts
			CDirectMusicPart* apPart[NUM_MIDI_CHANNELS];
			int iPart = 0;
			for(iPart; iPart < NUM_MIDI_CHANNELS; iPart++)
			{
				apPart[iPart] = 0;
			}

			// scan event list
			FullSeqEvent* pEvent;
			for( pEvent = lstEvent[iTrack]; pEvent; pEvent = pEvent->pNext )
			{
				if( dwLength < (DWORD)(pEvent->mtTime + pEvent->nOffset + pEvent->mtDuration) )
				{
					dwLength = pEvent->mtTime + pEvent->nOffset + pEvent->mtDuration;
				}
				// convert event
				CDirectMusicEventItem* pDirectMusicEventItem = pPattern->MakeDirectMusicEventItem(pEvent);
				int nCh = pEvent->dwPChannel;
				if(apPart[nCh] == 0)
				{
					apPart[nCh] = AllocPart();
					// disable all variations except for 1
					for(int j = 0; j < NBR_VARIATIONS; j++)
					{
						if(j == 0)
						{
							apPart[nCh]->m_dwVariationChoices[j] = (DM_VF_MODE_DMUSIC | DM_VF_FLAG_BITS);	// Enable variations (DirectMusic mode)
						}
						else
						{
							apPart[nCh]->m_dwVariationChoices[j] = DM_VF_MODE_DMUSIC;	// Disable variations (DirectMusic mode)
						}
					}
					if(nCh == 9 /* drum channel*/)
					{
						apPart[nCh]->m_bPlayModeFlags = DMUS_PLAYMODE_FIXED;
					}
					else
					{
						apPart[nCh]->m_bPlayModeFlags = DMUS_PLAYMODE_PURPLEIZED;
					}
					CDirectMusicPartRef* pRef = pPattern->AllocPartRef();
					ASSERT(pRef);
					if(!pRef)
					{
						hr = E_FAIL;
						return hr;
					}
					pRef->SetPart(apPart[nCh]);
					pRef->SetPChannel(nCh);
					pRef->SetName(lstTrackNames[iTrack]);
				}

				if( pDirectMusicEventItem->m_bType == ET_CURVE )
				{
					CDirectMusicStyleCurve* pDMCurve = (CDirectMusicStyleCurve *)pDirectMusicEventItem;
					pDMCurve->SetDefaultResetValues( 0 );	// Correct reset duration will be set in SetNbrMeasures()

				}
				apPart[nCh]->m_lstEvents.AddTail(pDirectMusicEventItem);
			}
		}
		if(dwLength > dwMaxLength)
			dwMaxLength = dwLength;
		dwLength = 0;
	}
	if(!pPattern)
	{
		hr = E_POINTER;
	}
	else
	{
		// set the length of the Pattern. Round up to the next measure
		WORD wMeasures = static_cast<unsigned short>(dwMaxLength / dwClocksPerMeasure);
		if(dwMaxLength % dwClocksPerMeasure)
		{
			wMeasures++;
		}
		pPattern->SetNbrMeasures(wMeasures);
	}
EXIT:

	for(int jTrack = 0; jTrack < nNumTracks; jTrack++)
	{
		List_Free( lstEvent[jTrack] );
	}

	delete lstEvent;
	lstEvent = 0;
	List_Free( lstPatchEvent );

	if( lstTrackNames )
	{
		for( jTrack = 0; jTrack < nNumTracks; jTrack++)
		{
			if( lstTrackNames[jTrack] )
			{
				delete lstTrackNames[jTrack];
				lstTrackNames[jTrack] = NULL;
			}
		}
		delete lstTrackNames;
		lstTrackNames = NULL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::ImportMidiFileAsPattern

HRESULT CDirectMusicStyle::ImportMidiFileAsPattern( BOOL fMotif )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_OK;
	CString strFileNames, strFileName, strPrompt;

	BOOL succeeded = FALSE;

	if( fMotif )
	{
		strPrompt.LoadString( IDS_IMPORT_MOTIF_FROMMIDI );
	}
	else
	{
		strPrompt.LoadString( IDS_IMPORT_PATTERN_FROMMIDI );
	}

	CString	strExt, strDefaultExt, strFilterDesc;
	CFileDialog dlg(TRUE);

	if(strExt.LoadString(IDS_MIDI_FILEEXT)
	&& strDefaultExt.LoadString(IDS_MIDI_DEFAULT_FILEEXT))
	{
		if(!strPrompt.IsEmpty())
		{
			dlg.m_ofn.lpstrTitle = strPrompt;
		}
		if(strFilterDesc.LoadString(IDS_MIDI_FILEDESC))
		{
			dlg.m_ofn.lpstrDefExt = strDefaultExt;
			dlg.m_ofn.nFilterIndex = dlg.m_ofn.nMaxCustFilter + 1;  // 1 based number

			// add *.mid to filter
			ASSERT(!strFilterDesc.IsEmpty());   // must have a file type name
			strFilterDesc += (TCHAR)'\0';		// next string please
			strFilterDesc += strExt;
			strFilterDesc += (TCHAR)'\0';		// next string please
			dlg.m_ofn.nMaxCustFilter++;

			// Append the "*.*" all files filter
			CString allFilter;
			VERIFY( allFilter.LoadString( AFX_IDS_ALLFILTER ) );
			strFilterDesc += allFilter;
			strFilterDesc += (TCHAR)'\0';   // next string please
			strFilterDesc += _T("*.*");
			strFilterDesc += (TCHAR)'\0';   // last string
			dlg.m_ofn.lpstrFilter = strFilterDesc;
			dlg.m_ofn.nMaxCustFilter++;

			// Set File Open dialog flags
			dlg.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT );

			dlg.m_ofn.lpstrFile = strFileNames.GetBuffer(_MAX_PATH);
			succeeded = dlg.DoModal() == IDOK;
			strFileNames.ReleaseBuffer();
		}
	}

	if(succeeded)
	{
		// Fix 23679: Display wait cursor during import
		CWaitCursor wait;

		POSITION pos = dlg.GetStartPosition();
		while( pos )
		{
			strFileName = dlg.GetNextPathName( pos );

			// Determine name of MIDI file
			CString strName;
			BSTR bstrName;
			TCHAR achName[_MAX_FNAME];
			_tsplitpath( strFileName, NULL, NULL, achName, NULL );
			strName = achName;
			strName.TrimLeft();
			strName.TrimRight();

			CDirectMusicPattern* pPattern = new CDirectMusicPattern(this,  fMotif);
			ASSERT(pPattern);
			if(pPattern)
			{
				IDMUSProdDocType* pIDocType;
				IDMUSProdNode* pBandNode = NULL;
				pPattern->Initialize1();	// creates rhythm map
				hr = theApp.m_pStyleComponent->m_pIFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType );
				if( SUCCEEDED ( hr ) ) 
				{
					pIDocType->AllocNode( GUID_BandNode, &pBandNode );
					if( !SUCCEEDED ( hr ) )
					{
						pBandNode = NULL;
					}
					RELEASE( pIDocType );
				}

				if( pBandNode == NULL )
				{
					delete pPattern;
					return E_OUTOFMEMORY;
				}
				// make a stream for file
				BSTR bstrPathName = strFileName.AllocSysString();
				IStream* pIStream;
				if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocFileStream(bstrPathName, GENERIC_READ, FT_UNKNOWN,
														  GUID_AllZeros, NULL, &pIStream) ) )
				{
					hr = CreatePatternFromMIDIStream( pPattern, pBandNode, pIStream, strFileName );
					if( SUCCEEDED ( hr ) )
					{
						CString strBandName = strName;
						if( strBandName.GetLength() > DMUS_MAX_NAME )
						{
							strBandName = strBandName.Left( DMUS_MAX_NAME );
							strBandName.TrimRight();
						}
						bstrName = strBandName.AllocSysString();
						pBandNode->SetNodeName( bstrName );
						GetUniqueBandName( pBandNode );
						m_StyleBands.InsertChildNode( pBandNode );
						
						bstrName = strName.AllocSysString();
						pPattern->SetNodeName( bstrName );
						GetUniquePatternName( pPattern );
						if( fMotif )
						{
							// Convert the Pattern into a Motif
							pPattern->m_wEmbellishment = EMB_MOTIF;
							pPattern->m_bGrooveBottom = 1; 
							pPattern->m_bGrooveTop = 100;
							pPattern->m_bDestGrooveBottom = 1; 
							pPattern->m_bDestGrooveTop = 100;
							m_StyleMotifs.InsertChildNode( pPattern );
						}
						else
						{
							m_StylePatterns.InsertChildNode( pPattern );
						}

						pPattern->Release();	// needed as AddPattern (called by InsertChildNode) does a ref
						pBandNode->Release();	// ditto, this time CStyleBands::InsertChildNode is the culprit
						SetActiveBand( pBandNode );
						if( m_pStyleCtrl &&  m_pStyleCtrl->m_pStyleDlg )
						{
								m_pStyleCtrl->m_pStyleDlg->SelectBand( pBandNode );
						}				
					}
					else
					{
						pPattern->Release();
						pBandNode->Release();
					}

					pIStream->Release();
				}
			}

			if( FAILED ( hr ) )
			{
				break;
			}
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::UpdateLinkedParts

void CDirectMusicStyle::UpdateLinkedParts( CDirectMusicPartRef* pPartRef, LPCTSTR pcstrText )
{
	ASSERT( pPartRef );
	ASSERT( pPartRef->m_pDMPart );
	if( ::IsEqualGUID( pPartRef->m_guidOldPartID, GUID_AllZeros  ) )
	{
		//ASSERT( FALSE );
		return;
	}

	CDirectMusicPattern* pPattern;
	POSITION pos;
	pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		if( pPattern != pPartRef->m_pPattern )
		{
			pPattern->UpdateLinkedParts( pPartRef, pcstrText );
		}
	}

	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		if( pPattern != pPartRef->m_pPattern )
		{
			pPattern->UpdateLinkedParts( pPartRef, pcstrText );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::UpdateLinkFlags

void CDirectMusicStyle::UpdateLinkFlags()
{
	CDirectMusicPattern* pPattern;
	POSITION pos;
	pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		pPattern->UpdateLinkFlags( );
	}

	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		pPattern->UpdateLinkFlags( );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::OnOutputPortsChanged

void CDirectMusicStyle::OnOutputPortsChanged()
{
	POSITION pos;
	CDirectMusicPattern *pPattern;
	IDMUSProdPortNotify *pIPortNotify;

    pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
    {
        pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		if( pPattern &&
			pPattern->m_pPatternCtrl &&
			pPattern->m_pPatternCtrl->m_pPatternDlg )
		{
			if( pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr &&
				SUCCEEDED( pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IDMUSProdPortNotify, (void**)&pIPortNotify ) ) )
			{
				pIPortNotify->OnOutputPortsChanged();
				pIPortNotify->Release();
			}

			// If the window is active, play the pattern's band
			if( pPattern->m_pPatternCtrl->m_fDocWindowActive 
			&&	pPattern->m_fDialogActive )
			{
				MUSIC_TIME mtNow;
				if( SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtNow ) ) )
				{
					IDirectMusicSegmentState *pSegmentState = NULL;
					if( FAILED( theApp.m_pStyleComponent->m_pIDMPerformance->GetSegmentState( &pSegmentState, mtNow ) ) )
					{
						pPattern->PlayBand();
					}
					else
					{
						if( pSegmentState )
						{
							pSegmentState->Release();
						}
					}
				}
			}
		}
	}

	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		if( pPattern &&
			pPattern->m_pPatternCtrl &&
			pPattern->m_pPatternCtrl->m_pPatternDlg &&
			pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr &&
			SUCCEEDED( pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IDMUSProdPortNotify, (void**)&pIPortNotify ) ) )
		{
			pIPortNotify->OnOutputPortsChanged();
			pIPortNotify->Release();

			// If the window is active, play the pattern's band
			if( pPattern->m_pPatternCtrl->m_fDocWindowActive 
			&&	pPattern->m_fDialogActive )
			{
				MUSIC_TIME mtNow;
				if( SUCCEEDED( theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtNow ) ) )
				{
					IDirectMusicSegmentState *pSegmentState = NULL;
					if( FAILED( theApp.m_pStyleComponent->m_pIDMPerformance->GetSegmentState( &pSegmentState, mtNow ) ) )
					{
						pPattern->PlayBand();
					}
					else
					{
						if( pSegmentState )
						{
							pSegmentState->Release();
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::OnOutputPortsRemoved

void CDirectMusicStyle::OnOutputPortsRemoved()
{
	POSITION pos;
	CDirectMusicPattern *pPattern;
	IDMUSProdPortNotify *pIPortNotify;

    pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
    {
        pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		if( pPattern &&
			pPattern->m_pPatternCtrl &&
			pPattern->m_pPatternCtrl->m_pPatternDlg &&
			pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr &&
			SUCCEEDED( pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IDMUSProdPortNotify, (void**)&pIPortNotify ) ) )
		{
			pIPortNotify->OnOutputPortsRemoved();
			pIPortNotify->Release();
		}
	}

	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		if( pPattern &&
			pPattern->m_pPatternCtrl &&
			pPattern->m_pPatternCtrl->m_pPatternDlg &&
			pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr &&
			SUCCEEDED( pPattern->m_pPatternCtrl->m_pPatternDlg->m_pIMIDIStripMgr->QueryInterface( IID_IDMUSProdPortNotify, (void**)&pIPortNotify ) ) )
		{
			pIPortNotify->OnOutputPortsRemoved();
			pIPortNotify->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::UpdateMIDIMgrsAndChangePartPtrs

void CDirectMusicStyle::UpdateMIDIMgrsAndChangePartPtrs( CDirectMusicPart* pOldPart, CDirectMusicPartRef* pNewPartRef, LPCTSTR pcstrText )
{
	ASSERT( pOldPart );
	ASSERT( pNewPartRef );

	CDirectMusicPattern* pPattern;
	POSITION pos;
	pos = m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StylePatterns.m_lstPatterns.GetNext( pos );
		if( pPattern != pNewPartRef->m_pPattern )
		{
			pPattern->UpdateMIDIMgrsAndChangePartPtrs( pOldPart, pNewPartRef->m_pDMPart, pcstrText );
		}
	}

	pos = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( pos )
	{
		pPattern = m_StyleMotifs.m_lstMotifs.GetNext( pos );
		if( pPattern != pNewPartRef->m_pPattern )
		{
			pPattern->UpdateMIDIMgrsAndChangePartPtrs( pOldPart, pNewPartRef->m_pDMPart, pcstrText );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::PreChangePartRef

void CDirectMusicStyle::PreChangePartRef( CDirectMusicPartRef* pDMPartRef )
{
	ASSERT( pDMPartRef != NULL );
	ASSERT( pDMPartRef->m_pDMPart != NULL );
	ASSERT( pDMPartRef->m_pDMPart->m_pStyle != NULL );

	// If other PartRef's use the part that will change
	if( pDMPartRef->m_pDMPart->m_dwUseCount > 1 )
	{
		// If we're not linked to the part
		if( !pDMPartRef->m_fHardLink )
		{
			// Create a new part
			CDirectMusicPart *pDMPart = AllocPart();
			if( pDMPart )
			{
				// Copy the existing part to the new part
				pDMPartRef->m_pDMPart->CopyTo( pDMPart );

				// If the variation choices editor is pointing to this partref
				if( pDMPartRef->m_pDMPart->m_pVarChoicesPartRef == pDMPartRef )
				{
					// Move the variation choices editor to the new part
					pDMPart->m_pVarChoicesNode = pDMPartRef->m_pDMPart->m_pVarChoicesNode;
					pDMPart->m_pVarChoicesPartRef = pDMPartRef;

					// Remove the variation choices editor from the old part
					pDMPartRef->m_pDMPart->m_pVarChoicesNode = NULL;
					pDMPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
				}

				// Point ourself to the new part
				pDMPartRef->SetPart( pDMPart );
			}
		}
		// If we ARE linked to the part
		else // pPartRef->m_fHardLink IS set
		{
			// Check if all other PartRefs are also linked to our part
			BOOL fOtherHardLinkNotSet = FALSE;

			// Iterate through all Patterns
			POSITION posPattern;
			posPattern = m_StylePatterns.m_lstPatterns.GetHeadPosition();
			while( posPattern && !fOtherHardLinkNotSet )
			{
				CDirectMusicPattern *pPatternList = m_StylePatterns.m_lstPatterns.GetNext( posPattern );
			
				// Iterate through all PartRefs
				POSITION posPartRef;
				posPartRef = pPatternList->m_lstPartRefs.GetHeadPosition();
				while( posPartRef != NULL )
				{
					CDirectMusicPartRef *pTmpPartRef = pPatternList->m_lstPartRefs.GetNext( posPartRef );

					// If this PartRef points to the same part, and does NOT
					// have the m_fHardLink set, set fOtherHardLinkNotSet and
					// break out
					if( (pTmpPartRef->m_pDMPart == pDMPartRef->m_pDMPart) &&
						!pTmpPartRef->m_fHardLink )
					{
						fOtherHardLinkNotSet = TRUE;
						break;
					}
				}
			}

			// Iterate through all Motifs
			posPattern = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
			while( posPattern && !fOtherHardLinkNotSet )
			{
				CDirectMusicPattern *pPatternList = m_StyleMotifs.m_lstMotifs.GetNext( posPattern );
			
				// Iterate through all PartRefs
				POSITION posPartRef;
				posPartRef = pPatternList->m_lstPartRefs.GetHeadPosition();
				while( posPartRef != NULL )
				{
					CDirectMusicPartRef *pTmpPartRef = pPatternList->m_lstPartRefs.GetNext( posPartRef );

					// If this PartRef points to the same part, and does NOT
					// have the m_fHardLink set, set fOtherHardLinkNotSet and
					// break out
					if( (pTmpPartRef->m_pDMPart == pDMPartRef->m_pDMPart) &&
						!pTmpPartRef->m_fHardLink )
					{
						fOtherHardLinkNotSet = TRUE;
						break;
					}
				}
			}

			// Another PartRef references this part, but does not have the
			// m_fHardLink flag set
			if( fOtherHardLinkNotSet )
			{
				// Create a new part
				CDirectMusicPart *pDMPart = AllocPart();
				if( pDMPart )
				{
					// Copy the existing part to the new part
					pDMPartRef->m_pDMPart->CopyTo( pDMPart );

					// Store the old variation choices partref
					const CDirectMusicPartRef *pOldVarChoicesPartRef = pDMPartRef->m_pDMPart->m_pVarChoicesPartRef;

					// Iterate through all Patterns
					posPattern = m_StylePatterns.m_lstPatterns.GetHeadPosition();
					while( posPattern )
					{
						CDirectMusicPattern *pPatternList = m_StylePatterns.m_lstPatterns.GetNext( posPattern );
					
						// Iterate through all PartRefs
						POSITION posPartRef;
						posPartRef = pPatternList->m_lstPartRefs.GetHeadPosition();
						while( posPartRef != NULL )
						{
							CDirectMusicPartRef *pTmpPartRef = pPatternList->m_lstPartRefs.GetNext( posPartRef );

							// Move all hard-linked partrefs to the new part
							if( pTmpPartRef->m_fHardLink )
							{
								// If the variation choices editor is pointing to this partref
								if( pOldVarChoicesPartRef == pTmpPartRef )
								{
									// Move the variation choices editor to the new part
									pDMPart->m_pVarChoicesNode = pTmpPartRef->m_pDMPart->m_pVarChoicesNode;
									pDMPart->m_pVarChoicesPartRef = pTmpPartRef;

									// Remove the variation choices editor from the old part
									pTmpPartRef->m_pDMPart->m_pVarChoicesNode = NULL;
									pTmpPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
								}

								pTmpPartRef->SetPart( pDMPart );
							}
						}
					}

					// Iterate through all Motifs
					posPattern = m_StyleMotifs.m_lstMotifs.GetHeadPosition();
					while( posPattern )
					{
						CDirectMusicPattern *pPatternList = m_StyleMotifs.m_lstMotifs.GetNext( posPattern );
					
						// Iterate through all PartRefs
						POSITION posPartRef;
						posPartRef = pPatternList->m_lstPartRefs.GetHeadPosition();
						while( posPartRef != NULL )
						{
							CDirectMusicPartRef *pTmpPartRef = pPatternList->m_lstPartRefs.GetNext( posPartRef );

							// Move all hard-linked partrefs to the new part
							if( pTmpPartRef->m_fHardLink )
							{
								// If the variation choices editor is pointing to this partref
								if( pOldVarChoicesPartRef == pTmpPartRef )
								{
									// Move the variation choices editor to the new part
									pDMPart->m_pVarChoicesNode = pTmpPartRef->m_pDMPart->m_pVarChoicesNode;
									pDMPart->m_pVarChoicesPartRef = pTmpPartRef;

									// Remove the variation choices editor from the old part
									pTmpPartRef->m_pDMPart->m_pVarChoicesNode = NULL;
									pTmpPartRef->m_pDMPart->m_pVarChoicesPartRef = NULL;
								}

								pTmpPartRef->SetPart( pDMPart );
							}
						}
					}
				}
			}
		}
	}

	// Update Part's GUID
	GUID newGuid;
	if( SUCCEEDED(CoCreateGuid( &newGuid )) )
	{
		// Set m_guidOldPartID if it is unset
		if( pDMPartRef->m_fSetGUIDOldPartID )
		{
			memcpy( &pDMPartRef->m_guidOldPartID, &pDMPartRef->m_pDMPart->m_guidPartID, sizeof(GUID) );
			pDMPartRef->m_fSetGUIDOldPartID = FALSE;
		}

		// Just copy the new guid 
		memcpy( &pDMPartRef->m_pDMPart->m_guidPartID, &newGuid, sizeof(GUID) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetObjectDescriptor

HRESULT CDirectMusicStyle::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidStyle, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicStyle, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_strName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::GetGUID

void CDirectMusicStyle::GetGUID( GUID* pguidStyle )
{
	if( pguidStyle )
	{
		*pguidStyle = m_guidStyle;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyle::SetGUID

void CDirectMusicStyle::SetGUID( GUID guidStyle )
{
	m_guidStyle = guidStyle;

	// Sync Style with DirectMusic
	SetModified( TRUE );
	SyncStyleWithDirectMusic();

	// Notify connected nodes that Style GUID has changed
	theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleComponent.cpp ===
// StyleComponent.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "StyleRef.h"
#include "VarChoices.h"


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent constructor/destructor 

CStyleComponent::CStyleComponent()
{
    m_dwRef = 0;
	
	m_pIDMPerformance = NULL;
	m_pIFramework = NULL;

	m_pIBandComponent = NULL;

	m_pIStyleDocType8 = NULL;
	m_pIConductor = NULL;
	m_nFirstImage = 0;

	m_nNextStyle = 0;

	m_cfStyle = 0;
	m_cfBand = 0;
	m_cfBandList = 0;
	m_cfBandTrack = 0;
	m_cfTimeline = 0;
	m_cfMotif = 0;
	m_cfMotifList = 0;
	m_cfPattern = 0;
	m_cfPatternList = 0;
	m_cfVarChoices = 0;
}

CStyleComponent::~CStyleComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::ReleaseAll

void CStyleComponent::ReleaseAll( void )
{
	CDirectMusicStyle *pStyle;

	while( !m_lstStyles.IsEmpty() )
	{
		pStyle = static_cast<CDirectMusicStyle*>( m_lstStyles.RemoveHead() );
		RELEASE( pStyle );
	}

	RELEASE( m_pIFramework );
	RELEASE( m_pIBandComponent );
	RELEASE( m_pIStyleDocType8 );
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIConductor );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IUnknown implementation

HRESULT CStyleComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdComponent *)this;
    }
	else if( ::IsEqualIID(riid, IID_IDMUSProdPortNotify) )
	{
		*ppvObj = (IDMUSProdPortNotify *)this;
	}
    else if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        *ppvObj = (IDMUSProdRIFFExt *)this;
    }
	else if( ::IsEqualIID(riid, IID_IAllocVarChoices) )
	{
		*ppvObj = (IAllocVarChoices *)this;
	}
	else
	{
	    *ppvObj = NULL;
		return E_NOINTERFACE;
	}

	static_cast<IUnknown *>(*ppvObj)->AddRef();
	return S_OK;
}

ULONG CStyleComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CStyleComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdComponent::Initialize

HRESULT CStyleComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	theApp.m_pStyleComponent = this;
//	theApp.m_pStyleComponent->AddRef();	intentionally missing

	// Get IConductor and IDirectMusicPerformance interface pointers 
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			RELEASE( pIComponent );
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );

	// Get the IDMUSProdComponent interface for the Band component 
	if( FAILED ( pIFramework->FindComponent( CLSID_BandComponent,  &m_pIBandComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_BAND, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add applicable images to the Project Tree control's image list 
	if( FAILED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .stp file 
	CString strExt = _T(".stp");
	BSTR bstrExt = strExt.AllocSysString();
	if( FAILED ( pIFramework->RegisterClipFormatForFile(m_cfStyle, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIStyleDocType8 = new CStyleDocType;
    if( m_pIStyleDocType8 == NULL )
    {
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIStyleDocType8->AddRef();

	if( FAILED ( pIFramework->AddDocType(m_pIStyleDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdComponent::CleanUp

HRESULT CStyleComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicStyle *pStyle;

	while( !m_lstStyles.IsEmpty() )
	{
		pStyle = static_cast<CDirectMusicStyle*>( m_lstStyles.RemoveHead() );
		RELEASE( pStyle );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdComponent::GetName

HRESULT CStyleComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_STYLE_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CStyleComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_StyleRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create StyleRefNode
	CStyleRef* pStyleRef = new CStyleRef;
	if( pStyleRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pStyleRef;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdComponent::OnActivateApp

HRESULT CStyleComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdPortNotify implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdPortNotify::OnOutputPortsChanged

HRESULT CStyleComponent::OnOutputPortsChanged( void )
{
	CDirectMusicStyle *pStyle;

	POSITION pos = m_lstStyles.GetHeadPosition();
	while( pos )
	{
		pStyle = m_lstStyles.GetNext( pos );
		pStyle->OnOutputPortsChanged();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdPortNotify::OnOutputPortsRemoved

HRESULT CStyleComponent::OnOutputPortsRemoved( void )
{
	CDirectMusicStyle *pStyle;

	POSITION pos = m_lstStyles.GetHeadPosition();
	while( pos )
	{
		pStyle = m_lstStyles.GetNext( pos );
		pStyle->OnOutputPortsRemoved();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdRIFFExt implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CStyleComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicStyle* pStyle;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Style 
	pStyle = new CDirectMusicStyle;
	if( pStyle == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Load the Style file
	hr = pStyle->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		pStyle->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pStyle;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IAllocVarChoices implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleComponent IAllocVarChoices::GetVarChoicesNode

HRESULT CStyleComponent::GetVarChoicesNode( IUnknown** ppIVarChoicesNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIVarChoicesNode == NULL )
	{
		return E_POINTER;
	}

	*ppIVarChoicesNode = NULL;

	// Create a new Variation Choices node 
	CVarChoices* pVarChoices = new CVarChoices;
	if( pVarChoices == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Query for an IUnknown interface
	HRESULT hr = pVarChoices->QueryInterface( IID_IUnknown, (void**)ppIVarChoicesNode );

	// Release our reference on the node
	pVarChoices->Release();

	// Return the QI result
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::AddNodeImageLists

HRESULT CStyleComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 10, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_STYLE_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_STYLE_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_MOTIF_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_MOTIF_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_PATTERN_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_PATTERN_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_STYLEREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_STYLEREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstImage ) ) )
	{
		return E_FAIL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::RegisterClipboardFormats

BOOL CStyleComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfStyle = ::RegisterClipboardFormat( CF_STYLE );
	m_cfBand = ::RegisterClipboardFormat( CF_BAND );
	m_cfBandList = ::RegisterClipboardFormat( CF_BANDLIST );
	m_cfBandTrack = ::RegisterClipboardFormat( CF_BANDTRACK );
	m_cfTimeline = ::RegisterClipboardFormat( CF_TIMELINE );
	m_cfMotif = ::RegisterClipboardFormat( CF_MOTIF );
	m_cfMotifList = ::RegisterClipboardFormat( CF_MOTIFLIST );
	m_cfPattern = ::RegisterClipboardFormat( CF_PATTERN );
	m_cfPatternList = ::RegisterClipboardFormat( CF_PATTERNLIST );
	m_cfVarChoices = ::RegisterClipboardFormat( CF_VARCHOICES );

	if( m_cfProducerFile == 0
	||  m_cfStyle == 0
	||  m_cfBand == 0
	||  m_cfBandList == 0
	||  m_cfBandTrack == 0
	||  m_cfTimeline == 0
	||  m_cfMotif == 0
	||  m_cfMotifList == 0
	||  m_cfPattern == 0
	||  m_cfPatternList == 0
	||  m_cfVarChoices == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::GetStyleImageIndex

HRESULT CStyleComponent::GetStyleImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_STYLE_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::GetFolderImageIndex

HRESULT CStyleComponent::GetFolderImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_FOLDER_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::GetMotifImageIndex

HRESULT CStyleComponent::GetMotifImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_MOTIF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::GetPatternImageIndex

HRESULT CStyleComponent::GetPatternImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_PATTERN_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::GetStyleRefImageIndex

HRESULT CStyleComponent::GetStyleRefImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_STYLEREF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::AddToStyleFileList

void CStyleComponent::AddToStyleFileList( CDirectMusicStyle* pStyle )
{
	if( pStyle )
	{
		GUID guidStyle;
		pStyle->GetGUID( &guidStyle );

		// Prevent duplicate object GUIDs
		GUID guidStyleList;
		POSITION pos = m_lstStyles.GetHeadPosition();
		while( pos )
		{
			CDirectMusicStyle* pStyleList = m_lstStyles.GetNext( pos );

			pStyleList->GetGUID( &guidStyleList );
			if( ::IsEqualGUID( guidStyleList, guidStyle ) )
			{
				::CoCreateGuid( &guidStyle );
				pStyle->SetGUID( guidStyle );
				break;
			}
		}

		// Add to list
		pStyle->AddRef();
		m_lstStyles.AddTail( pStyle );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComponent::RemoveFromStyleFileList

void CStyleComponent::RemoveFromStyleFileList( CDirectMusicStyle* pStyle )
{
	if( pStyle )
	{
		// Remove from list
		POSITION pos = m_lstStyles.Find( pStyle );
		if( pos )
		{
			m_lstStyles.RemoveAt( pos );
			pStyle->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\Style.h ===
#ifndef __STYLE_H__
#define __STYLE_H__

// Style.h : header file
//

#include "StyleComponent.h"
#include "StyleDocType.h"
#include "StyleBands.h"
#include "Pattern.h"
#include "StylePatterns.h"
#include "StyleMotifs.h"
#include "StylePersonalities.h"


class CDirectMusicStyle;
interface IDMUSProdRIFFStream;

//////////////////////////////////////////////////////////////////////
//  CStylePropPageManager

class CStylePropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabStyleStyle;
friend class CTabStyleInfo;

public:
	CStylePropPageManager();
	virtual ~CStylePropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD					m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabStyleStyle*			m_pTabStyle;
	CTabStyleInfo*			m_pTabInfo;

public:
	static short			sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CDirectMusicStyle

class CDirectMusicStyle : public IDMUSProdNode, public IDMUSProdStyleInfo, public IPersistStream,
	public IDMUSProdPropPageObject, public IDMUSProdNotifySink
{
friend class CStyleCtrl;
friend class CStyleDlg;
friend class CStyleBands;
friend class CStylePatterns;
friend class CStyleMotifs;
friend class CStylePersonalities;
friend class CTabStyleStyle;
friend class CTabStyleInfo;
friend class CDirectMusicPattern;
friend class CDirectMusicPart;
friend class CVarChoices;
friend class CVarChoicesPropPageManager;
friend class CTabVarChoices;
friend class CPatternCtrl;
friend class CDialogLinkExisting;

public:
    CDirectMusicStyle();
	~CDirectMusicStyle();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// IDMUSProdStyleInfo functions
	HRESULT STDMETHODCALLTYPE GetActiveBandForStyle( IUnknown** ppIActiveBandNode );
	HRESULT STDMETHODCALLTYPE GetDefaultBand( IUnknown** ppIDefaultBandNode );
    HRESULT STDMETHODCALLTYPE GetTempo( double* pTempo );
    HRESULT STDMETHODCALLTYPE GetTimeSignature( DMUSProdTimeSignature* pTimeSignature );
	HRESULT STDMETHODCALLTYPE GetNotationType( DWORD *pdwType );
	HRESULT STDMETHODCALLTYPE GetActiveBandForObject( IUnknown* punkObject, IUnknown** ppIActiveBandNode );

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate( IDMUSProdNode* pINode, GUID guidUpdateType, VOID* pData );

	//Additional functions
protected:
    HRESULT DM_SaveStyle( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
    HRESULT DM_SaveStyleChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveStyleUIChunk( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveStyleGUID( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveStyleInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveStyleDefaultBand( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveStyleVersion( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT DM_SaveStylePersonalityList( IDMUSProdRIFFStream* pIRiffStream );

    HRESULT DM_LoadStyle( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    
    HRESULT IMA25_LoadStyle( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

    HRESULT UNDO_SaveStyle( IDMUSProdRIFFStream* pIRiffStream, FileType ftFileType );
    HRESULT UNDO_LoadStyle( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

	HRESULT ContainsClipFormat( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, UINT cfClipFormat );
	HRESULT LoadCF_BANDTRACK( IStream* pIStream, IDMUSProdNode* pIPositionNode );

	HRESULT PasteCF_BAND( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, IDMUSProdNode* pIPositionNode );
	HRESULT PasteCF_BANDLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, IDMUSProdNode* pIPositionNode );
	HRESULT PasteCF_BANDTRACK( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, IDMUSProdNode* pIPositionNode );
	HRESULT PasteCF_TIMELINE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, IDMUSProdNode* pIPositionNode );
	HRESULT PasteCF_MOTIF( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, CDirectMusicPattern* pPositionMotif );
	HRESULT PasteCF_MOTIFLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, CDirectMusicPattern* pPositionMotif );
	HRESULT PasteCF_PATTERN( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, CDirectMusicPattern* pPositionPattern );
	HRESULT PasteCF_PATTERNLIST( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, CDirectMusicPattern* pPositionPattern );

	BOOL IsBandNameUnique( IDMUSProdNode* pIBandNode, LPCTSTR szBandName );
	void GetUniqueBandName( IDMUSProdNode* pIBandNode );
	IDMUSProdNode* GetBandNodeByName( LPCTSTR szBandName );

public:
	HRESULT Initialize();
	BOOL CreateUndoMgr();
	BOOL IsPatternNameUnique( CDirectMusicPattern* pPattern );
	void GetUniquePatternName( CDirectMusicPattern* pPattern );
	void SetModified( BOOL fModified );
	void SyncStyleEditor( DWORD dwFlags );
	HRESULT SyncStyleWithDirectMusic();
	HRESULT ForceSyncStyleWithDirectMusic();
	HRESULT UnRegisterWithTransport();
	HRESULT RegisterWithTransport();
    HRESULT GetObjectDescriptor( void* pObjectDesc );
	IDirectMusicSegment* GetSegmentThatIsPlaying();
	IDMUSProdNode* GetActiveBand();
	IDirectMusicBand* GetDMBand( IDMUSProdNode* pIBandNode );
	void SetActiveBand( IDMUSProdNode* pIBandNode );
	void SendBand( IDMUSProdNode* pIBandNode );
	HRESULT SyncBand( IDMUSProdNode* pIBandNode );
	void SyncMidiStripMgrsThatUsePart( CDirectMusicPart* pDMPart );
	void RemoveActiveBand( IDMUSProdNode* pIBandNode );
	void UpdateLinkedParts( CDirectMusicPartRef* pPartRef, LPCTSTR pcstrText );
	void UpdateLinkFlags( void );
	void OnOutputPortsChanged( void );
	void OnOutputPortsRemoved( void );
	void UpdateMIDIMgrsAndChangePartPtrs( CDirectMusicPart* pOldPart, CDirectMusicPartRef* pNewPartRef, LPCTSTR pcstrText );
	void PreChangePartRef( CDirectMusicPartRef* pDMPartRef );
	BOOL IsInStyleBandList( IDMUSProdNode* pIBandNode );

	HRESULT AddPattern( CDirectMusicPattern* pPattern, CDirectMusicPattern* pPositionPattern );
	HRESULT RemovePattern( CDirectMusicPattern* pPattern );

	HRESULT AddMotif( CDirectMusicPattern* pMotif, CDirectMusicPattern* pPositionMotif );
	HRESULT RemoveMotif( CDirectMusicPattern* pMotif );

	CDirectMusicPart* FindPartByGUID( GUID guidPartID );
	CDirectMusicPart* AllocPart();
	void DeletePart( CDirectMusicPart* pPart );

	HRESULT ImportMidiFileAsPattern( BOOL fMotif );
	HRESULT CreatePatternFromMIDIStream(CDirectMusicPattern* pPattern, IDMUSProdNode* pBandNode, LPSTREAM pStream, CString strFile);

	// Methods to set Style data
	void SetTempo( double dblTempo, BOOL fInUndo );
	void SetTimeSignature( DirectMusicTimeSig timeSig, BOOL fInUndo );
	void SetDefaultBand( IDMUSProdNode* pIDefaultBandNode, BOOL fInUndo );
	IDMUSProdNode* GetTheDefaultBand();

	void GetGUID( GUID* pguidStyle );
	void SetGUID( GUID guidStyle);

private:
    DWORD				m_dwRef;
	BOOL				m_fModified;

	CJazzUndoMan*		m_pUndoMgr;

	IDirectMusicStyle*	m_pIDMStyle;

	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;
	IDMUSProdNode*		m_pIActiveBandNode;

	HWND				m_hWndEditor;

	DWORD				m_dwNextPatternID;
	BOOL				m_fPChannelChange;

public:
	CString				m_strOrigFileName;
	CStyleCtrl*			m_pStyleCtrl;
	IDMUSProdNode*		m_pINodeBeingDeleted;
	IDMUSProdProject*	m_pIProject;

public:
	CTypedPtrList<CPtrList, CDirectMusicPart*> m_lstStyleParts;
	CStyleBands			m_StyleBands;
	CStylePatterns		m_StylePatterns;
	CStyleMotifs		m_StyleMotifs;
	CStylePersonalities	m_StylePersonalities;

	// UI fields
	int					m_nSplitterYPos;
	DWORD				m_dwNotationType;

private:
    CString				m_strName;
    CString				m_strCategoryName;
    CString				m_strInfo;
    CString				m_strAuthor;
    CString				m_strCopyright;
	CString				m_strSubject;

    GUID				m_guidStyle;

	DWORD				m_dwVersionMS;		 // Version # high-order 32 bits
	DWORD				m_dwVersionLS;		 // Version # low-order 32 bits

	DirectMusicTimeSig	m_TimeSignature;	 // The style's time signature
	double				m_dblTempo;			 // The style's tempo

	// IMA 2.5 data
	WORD				m_wUseId;
};

#endif // __STYLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleBands.cpp ===
// StyleBands.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "StyleCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleBands constructor/destructor

CStyleBands::CStyleBands()
{
	m_pStyle = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_fModified = FALSE;
	m_fInCleanUp = FALSE;
}

CStyleBands::~CStyleBands()
{
	IDMUSProdNode* pINode;

	while( !m_lstBands.IsEmpty() )
	{
		pINode = static_cast<IDMUSProdNode*>( m_lstBands.RemoveHead() );
		RELEASE( pINode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands::IsDirty

BOOL CStyleBands::IsDirty( void )
{
	// Check to see if the list of Bands was changed
	if( m_fModified )
	{
		return TRUE;
	}

	// Check to see if any of the Bands were changed
	IDMUSProdNode* pINode;
	IPersistStream* pIPS;
	HRESULT hr;

    POSITION pos = m_lstBands.GetHeadPosition();

    while( pos )
    {
        pINode = m_lstBands.GetNext( pos );

		pINode->QueryInterface( IID_IPersistStream, (void **)&pIPS );
		if( pIPS )
		{
			hr = pIPS->IsDirty();
			RELEASE( pIPS );

			if( hr == S_OK )
			{
				return TRUE;
			}
		}
    }

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands::SetModified

void CStyleBands::SetModified( BOOL fModified )
{
	// Set modified flag of Band folder
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands::CleanUp

void CStyleBands::CleanUp( void )
{
	m_fInCleanUp = TRUE;

	IDMUSProdNode* pINode;
	while( !m_lstBands.IsEmpty() )
	{
		pINode = static_cast<IDMUSProdNode*>( m_lstBands.RemoveHead() );
		pINode->DeleteNode( FALSE );
		RELEASE( pINode );
	}

	m_fInCleanUp = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands::InsertChildNodeAtPos

HRESULT CStyleBands::InsertChildNodeAtPos( IDMUSProdNode* pIChildNode, IDMUSProdNode* pIPositionNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( pIPositionNode != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	pIChildNode->AddRef();

	// add to CDirectMusicStyle Band list
	POSITION pos = NULL;

	if( pIPositionNode )
	{
		pos = m_lstBands.Find( pIPositionNode );
	}
	if( pos )
	{
		m_lstBands.InsertBefore( pos, pIChildNode );
	}
	else
	{
		m_lstBands.AddTail( pIChildNode );
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, (IDMUSProdNode *)m_pStyle, (IDMUSProdNode *)this );

	// Make sure Band name is unique
	m_pStyle->GetUniqueBandName( pIChildNode );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	// Make sure "Default" flag is off
	IDMUSProdBandEdit* pIBandEdit;

	if( SUCCEEDED ( pIChildNode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
	{
		pIBandEdit->SetDefaultFlag( FALSE );
		RELEASE( pIBandEdit );
	}

	// Sync Style editor (when open)
	m_pStyle->SyncStyleEditor( SSE_BANDS );
	if( m_pStyle->m_pStyleCtrl
	&&  m_pStyle->m_pStyleCtrl->m_pStyleDlg )
	{
		m_pStyle->m_pStyleCtrl->m_pStyleDlg->SelectBand( pIChildNode );
	}

	// Update the DirectMusic Style object
	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IUnknown implementation

HRESULT CStyleBands::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pStyle )
		{
	        return m_pStyle->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStyleBands::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	AfxOleLockApp(); 

	return m_pStyle->AddRef();
}

ULONG CStyleBands::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	AfxOleUnlockApp(); 

	return m_pStyle->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetNodeImageIndex

HRESULT CStyleBands::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return( theApp.m_pStyleComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetFirstChild

HRESULT CStyleBands::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstBands.IsEmpty() )
	{
		IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>( m_lstBands.GetHead() );
		
		if( pINode )
		{
			pINode->AddRef();
			*ppIFirstChildNode = pINode;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetNextChild

HRESULT CStyleBands::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode;

    POSITION pos = m_lstBands.GetHeadPosition();

    while( pos )
    {
        pINode = m_lstBands.GetNext( pos );
		if( pINode == pIChildNode )
		{
			if( pos )
			{
				pINode = m_lstBands.GetNext( pos );

				pINode->AddRef();
				*ppINextChildNode = pINode;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetComponent

HRESULT CStyleBands::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetDocRootNode

HRESULT CStyleBands::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::SetDocRootNode

HRESULT CStyleBands::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetParentNode

HRESULT CStyleBands::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::SetParentNode

HRESULT CStyleBands::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetNodeId

HRESULT CStyleBands::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_StyleBandFolderNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetNodeName

HRESULT CStyleBands::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_BAND_FOLDER_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetNodeNameMaxLength

HRESULT CStyleBands::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a band folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::ValidateNodeName

HRESULT CStyleBands::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::SetNodeName

HRESULT CStyleBands::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetNodeListInfo

HRESULT CStyleBands::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );
	UNREFERENCED_PARAMETER(pListInfo);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetEditorClsId

HRESULT CStyleBands::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pClsId);

	return E_NOTIMPL;	// Can't edit a band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetEditorTitle

HRESULT CStyleBands::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pbstrTitle);

	return E_NOTIMPL;	// Can't edit a band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetEditorWindow

HRESULT CStyleBands::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hWndEditor);

	return E_NOTIMPL;	// Can't edit a band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::SetEditorWindow

HRESULT CStyleBands::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hWndEditor);

	return E_NOTIMPL;	// Can't edit a band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::UseOpenCloseImages

HRESULT CStyleBands::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetRightClickMenuId

HRESULT CStyleBands::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_STYLEBANDS_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::OnRightClickMenuInit

HRESULT CStyleBands::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		IDMUSProdPropPageObject* pIPageObject;

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::OnRightClickMenuSelect

HRESULT CStyleBands::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_BAND:
			hr = InsertChildNode( NULL );
			break;

		case IDM_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::DeleteChildNode

HRESULT CStyleBands::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_fInCleanUp )
	{
		// Nothing to do
		return S_OK;
	}

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pStyleComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Reset Style's active Band to NULL (when applicable)
	m_pStyle->RemoveActiveBand( pIChildNode );

	// Save undo state
//	m_pStyle->m_pINodeBeingDeleted = pIChildNode;
//	m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_DELETE_BAND );
//	m_pStyle->m_pINodeBeingDeleted = NULL;

	// Need to keep node until after SyncStyleEditor() 
	pIChildNode->AddRef();

	// Remove from CDirectMusicStyle Band list
	POSITION pos = m_lstBands.Find( pIChildNode );
	if( pos )
	{
		m_lstBands.RemoveAt( pos );
		pIChildNode->Release();
	}

	// Make sure Style still has a "Default" Band
	IDMUSProdBandEdit* pIBandEdit;

	if( SUCCEEDED ( pIChildNode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
	{
		BOOL fDefaultFlag;

		if( FAILED ( pIBandEdit->GetDefaultFlag( &fDefaultFlag ) ) )
		{
			fDefaultFlag = FALSE;
		}
		if( fDefaultFlag )
		{
			m_pStyle->SetDefaultBand( NULL, FALSE );
		}

		RELEASE( pIBandEdit );
	}

	// Sync Style editor (when open)
	m_pStyle->SyncStyleEditor( SSE_BANDS );
	RELEASE( pIChildNode );

	// Update the DirectMusic Style object
	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::InsertChildNode

HRESULT CStyleBands::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdDocType* pIDocType;

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( pIChildNode == NULL )
	{
		HRESULT hr;

		hr = theApp.m_pStyleComponent->m_pIFramework->FindDocTypeByNodeId( GUID_BandNode, &pIDocType );
		if( SUCCEEDED ( hr ) ) 
		{
			// Create a new Band 
			hr = pIDocType->AllocNode( GUID_BandNode, &pIChildNode );
			if( !SUCCEEDED ( hr ) )
			{
				pIChildNode = NULL;
			}

			RELEASE( pIDocType );
		}

		if( pIChildNode == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		pIChildNode->AddRef();
	}

	// Make sure Band name is unique
	m_pStyle->GetUniqueBandName( pIChildNode );

	// Add to CDirectMusicStyle Band list
	m_lstBands.AddTail( pIChildNode );

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, (IDMUSProdNode *)m_pStyle, (IDMUSProdNode *)this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	// Make sure "Default" flag is off
	IDMUSProdBandEdit* pIBandEdit;

	if( SUCCEEDED ( pIChildNode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
	{
		pIBandEdit->SetDefaultFlag( FALSE );
		RELEASE( pIBandEdit );
	}

	// Sync Style editor (when open)
	m_pStyle->SyncStyleEditor( SSE_BANDS );
	if( m_pStyle->m_pStyleCtrl
	&&  m_pStyle->m_pStyleCtrl->m_pStyleDlg )
	{
		m_pStyle->m_pStyleCtrl->m_pStyleDlg->SelectBand( pIChildNode );
	}

	// Update the DirectMusic Style object
	HRESULT hr = m_pStyle->SyncStyleWithDirectMusic();
	ASSERT( SUCCEEDED ( hr ) );

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::DeleteNode

HRESULT CStyleBands::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Can't delete a Band folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::OnNodeSelChanged

HRESULT CStyleBands::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CreateDataObject

HRESULT CStyleBands::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CanCut

HRESULT CStyleBands::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove Band folder from Style
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CanCopy

HRESULT CStyleBands::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CanDelete

HRESULT CStyleBands::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't delete Band folder from Style
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CanDeleteChildNode

HRESULT CStyleBands::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure node is in Band list
	POSITION pos = m_lstBands.Find( pIChildNode );
	if( pos == NULL )
	{
		return E_FAIL;
	}

	// Cannot delete the last Band from a Style
	if( m_lstBands.GetCount() < 2 )
	{
		return S_FALSE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CanPasteFromData

HRESULT CStyleBands::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) 
	||  SUCCEEDED ( m_pStyle->ContainsClipFormat( pDataObject, pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) ) 
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::PasteFromData

HRESULT CStyleBands::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Do not continue unless CStyleBands can accept data
	BOOL fWillSetReference;
	if( CanPasteFromData( pIDataObject, &fWillSetReference ) != S_OK )
	{
		return E_FAIL;
	}

	// Let CDirectMusicStyle do the work
	return m_pStyle->PasteFromData( pIDataObject );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::CanChildPasteFromData

HRESULT CStyleBands::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										    BOOL *pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) 
	||  SUCCEEDED ( m_pStyle->ContainsClipFormat( pDataObject, pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::ChildPasteFromData

HRESULT CStyleBands::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pIDataObject == NULL
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBand ) ) )
	{
		// Handle CF_BAND format
		hr = m_pStyle->PasteCF_BAND( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandList ) ) )
	{
		// Handle CF_BANDLIST format
		hr = m_pStyle->PasteCF_BANDLIST( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfBandTrack ) ) )
	{
		// Handle CF_BANDTRACK format
		hr = m_pStyle->PasteCF_BANDTRACK( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfTimeline ) ) )
	{
		// Handle CF_TIMELINE format
		hr = m_pStyle->PasteCF_TIMELINE ( pDataObject, pIDataObject, NULL );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleBands IDMUSProdNode::GetObject

HRESULT CStyleBands::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleComponent.h ===
#ifndef __STYLECOMPONENT_H__
#define __STYLECOMPONENT_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// StyleComponent.h : header file
//

#include <afxtempl.h>
#include <Conductor.h>

class CDirectMusicStyle;

class CStyleComponent : public IDMUSProdComponent, public IDMUSProdPortNotify, public IDMUSProdRIFFExt, public IAllocVarChoices
{
public:
    CStyleComponent();
	~CStyleComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

	// IDMUSProdPortNotify functions
	HRESULT STDMETHODCALLTYPE OnOutputPortsChanged( void );
	HRESULT STDMETHODCALLTYPE OnOutputPortsRemoved( void );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

	// IAllocVarChoices functions
	HRESULT	STDMETHODCALLTYPE GetVarChoicesNode( IUnknown** ppIVarChoicesNode );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();

public:
    HRESULT STDMETHODCALLTYPE GetStyleImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetMotifImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetPatternImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetStyleRefImageIndex( short* pnNbrFirstImage );
	void AddToStyleFileList( CDirectMusicStyle* pStyle );
	void RemoveFromStyleFileList( CDirectMusicStyle* pStyle );

public:
	IDMUSProdFramework*			m_pIFramework;
	IDirectMusicPerformance8*	m_pIDMPerformance;
	IDMUSProdConductor*			m_pIConductor;
	IDMUSProdComponent*			m_pIBandComponent;
	short						m_nNextStyle;		// appended to name of new Style
	UINT						m_cfProducerFile;	// CF_DMUSPROD_FILE clipboard format
	UINT						m_cfStyle;			// CF_STYLE clipboard format
	UINT						m_cfBand;			// CF_BAND clipboard format
	UINT						m_cfBandList;		// CF_BANDLIST clipboard format
	UINT						m_cfBandTrack;		// CF_BANDTRACK clipboard format
	UINT						m_cfTimeline;		// CF_TIMELINE clipboard format
	UINT						m_cfMotif;			// CF_MOTIF clipboard format
	UINT						m_cfMotifList;		// CF_MOTIFLIST clipboard format
	UINT						m_cfPattern;		// CF_PATTERN clipboard format
	UINT						m_cfPatternList;	// CF_PATTERNLIST clipboard format
	UINT						m_cfVarChoices;		// CF_VARCHOICES clipboard format

private:
    DWORD						m_dwRef;
	IDMUSProdDocType8*			m_pIStyleDocType8;
	short						m_nFirstImage;

	CTypedPtrList<CPtrList, CDirectMusicStyle*> m_lstStyles;
};

#endif // __STYLECOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleCtl.cpp ===
// StyleCtl.cpp : Implementation of the CStyleCtrl ActiveX Control class.

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "StyleCtl.h"
#include "StyleRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CStyleCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CStyleCtrl, COleControl)
	//{{AFX_MSG_MAP(CStyleCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(WM_SYNC_STYLEEDITOR, OnSyncStyleEditor)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CStyleCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CStyleCtrl)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CStyleCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CStyleCtrl, COleControl)
	//{{AFX_EVENT_MAP(CStyleCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl Interface map

BEGIN_INTERFACE_MAP(CStyleCtrl, COleControl)
    INTERFACE_PART(CStyleCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CStyleCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CStyleCtrl, "STYLEDESIGNER.StyleCtrl.1",
	0x3bd2ba05, 0x46e7, 0x11d0, 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CStyleCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DStyle =
		{ 0x3bd2ba03, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DStyleEvents =
		{ 0x3bd2ba04, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwStyleOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CStyleCtrl, IDS_STYLE, _dwStyleOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::CStyleCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CStyleCtrl

BOOL CStyleCtrl::CStyleCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_STYLE,
			IDB_STYLE,
			afxRegApartmentThreading,
			_dwStyleOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::CStyleCtrl - Constructor

CStyleCtrl::CStyleCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DStyle, &IID_DStyleEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DStyle;
	m_piidEvents = &IID_DStyleEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pStyleDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_pToolBar = NULL;
	m_pStyle = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::~CStyleCtrl - Destructor

CStyleCtrl::~CStyleCtrl()
{
	RELEASE( m_pStyle );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CStyleCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CStyleCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CStyleCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CStyleCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::QueryInterface

STDMETHODIMP CStyleCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CStyleCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::AttachObjects implementation

HRESULT CStyleCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_StyleRefNode ) )
	{
		CStyleRef* pStyleRef = (CStyleRef *)pINode;
		ASSERT( pStyleRef->m_pStyle != NULL );
		pThis->m_pStyle = pStyleRef->m_pStyle;
	}
	else
	{
		pThis->m_pStyle = (CDirectMusicStyle *)pINode;
	}

	ASSERT( pThis->m_pStyle != NULL );
	pThis->m_pStyle->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::OnInitMenuFilePrint

HRESULT CStyleCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::OnFilePrint

HRESULT CStyleCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CStyleCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::OnFilePrintPreview

HRESULT CStyleCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::OnViewProperties

HRESULT CStyleCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pStyleDlg )
	{
		if( pThis->m_pStyleDlg->OnViewProperties() )
		{
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XEditor::OnF1Help

HRESULT CStyleCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CStyleCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/StyleDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CStyleCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CStyleCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	
//	OLEINPLACEFRAMEINFO frameInfo = pThis->m_frameInfo;
//	if( ::OleTranslateAccelerator(pThis->m_pInPlaceFrame, &frameInfo, lpmsg) == S_OK )
//	{
//		return S_OK;
//	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CStyleCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CStyleCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnDraw - Drawing function

void CStyleCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::DoPropExchange - Persistence support

void CStyleCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CStyleAbout dialog used for Style Editor About Box

class CStyleAbout : public CDialog
{
public:
	CStyleAbout();

// Dialog Data
	//{{AFX_DATA(CStyleAbout)
	enum { IDD = IDD_ABOUTBOX_STYLE };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStyleAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CStyleAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CStyleAbout::CStyleAbout() : CDialog(CStyleAbout::IDD)
{
	//{{AFX_DATA_INIT(CStyleAbout)
	//}}AFX_DATA_INIT
}

void CStyleAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStyleAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CStyleAbout, CDialog)
	//{{AFX_MSG_MAP(CStyleAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CStyleAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_STYLE_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::AboutBox - Display an "About" box to the user

void CStyleCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CStyleAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnCreate

int CStyleCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if( COleControl::OnCreate(lpCreateStruct) == -1 )
		return -1;

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_STYLE_EDITOR) );

	// Create control's toolbar
//	CWnd* pWndParent = CWnd::FromHandle( m_hWndContainer );
//	if( pWndParent )
//	{
//		m_pToolBar = new CToolBar;
//		m_pToolBar->Create( pWndParent );
//		m_pToolBar->LoadToolBar( IDR_STYLE_EDITOR );
//		m_pToolBar->SetBarStyle( m_pToolBar->GetBarStyle() | CBRS_SIZE_DYNAMIC );
//		m_pToolBar->SetOwner( this );
//	}

	// Create control's dialog
	m_pStyleDlg = new CStyleDlg;
	if( m_pStyleDlg == NULL )
	{
		return -1;
	}

	m_pStyle->m_pStyleCtrl = this;

	m_pStyleDlg->m_pStyle = m_pStyle;
	m_pStyleDlg->m_pStyleCtrl = this;
	m_pStyleDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL );
	m_pStyleDlg->OnInitialUpdate();
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnDestroy

void CStyleCtrl::OnDestroy() 
{
	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	if( m_pToolBar )
	{
		delete m_pToolBar;	
		m_pToolBar = NULL;
	}

	ASSERT( m_pStyle != NULL );

	m_pStyle->m_pStyleCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnGetInPlaceMenu

HMENU CStyleCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnHideToolBars

void CStyleCtrl::OnHideToolBars() 
{
	COleControl::OnHideToolBars();
	return;

	if( m_pToolBar )
	{
		BORDERWIDTHS border;

		border.top = 0;
		border.left = 0;
		border.right = 0;
		border.bottom = 0;

		if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
		{
			m_pInPlaceFrame->SetBorderSpace( &border );
			m_pToolBar->ShowWindow( SW_HIDE );
			return;
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnShowToolBars

void CStyleCtrl::OnShowToolBars() 
{
	BORDERWIDTHS border;
	CRect rectBorder;

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	COleControl::OnShowToolBars();
	return;

	// Show the ToolBar
	if( m_pToolBar )
	{
		if( SUCCEEDED ( m_pInPlaceFrame->GetBorder(&rectBorder) ) )
		{
			border.top = TOOLBAR_HEIGHT;
			border.left = 0;
			border.right = 0;
			border.bottom = 0;

			if( SUCCEEDED ( m_pInPlaceFrame->RequestBorderSpace(&border) ) )
			{
				m_pInPlaceFrame->SetBorderSpace( &border );

				m_pToolBar->MoveWindow( rectBorder.left,
										rectBorder.top,
										rectBorder.Width(),
										TOOLBAR_HEIGHT );
				m_pToolBar->ShowWindow( SW_SHOWNORMAL );
				return;
			}
		}
	}

	m_pInPlaceFrame->SetBorderSpace( NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnSize

void CStyleCtrl::OnSize( UINT nType, int cx, int cy ) 
{
	COleControl::OnSize( nType, cx, cy );

	m_pStyleDlg->MoveWindow( 0, 0, cx, cy );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditUndo

void CStyleCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pStyle )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pStyle->m_pUndoMgr != NULL );

		if( m_pStyle->m_pUndoMgr )
		{
			if( m_pStyle->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditUndo

void CStyleCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( m_pStyle )
	{
		ASSERT( m_pStyle->m_pUndoMgr != NULL );

		if( m_pStyle->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pStyle->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				m_pStyle->m_pUndoMgr->Undo( m_pStyle );
				m_pStyle->SetModified( TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditRedo

void CStyleCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pStyle )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pStyle->m_pUndoMgr != NULL );

		if( m_pStyle->m_pUndoMgr )
		{
			if( m_pStyle->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditRedo

void CStyleCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( m_pStyle )
	{
		ASSERT( m_pStyle->m_pUndoMgr != NULL );

		if( m_pStyle->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pStyle->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				m_pStyle->m_pUndoMgr->Redo( m_pStyle );
				m_pStyle->SetModified( TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditCut

void CStyleCtrl::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnUpdateEditCut( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditCut

void CStyleCtrl::OnEditCut() 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnEditCut();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditCopy

void CStyleCtrl::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnUpdateEditCopy( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditCopy

void CStyleCtrl::OnEditCopy() 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnEditCopy();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditPaste

void CStyleCtrl::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnUpdateEditPaste( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditPaste

void CStyleCtrl::OnEditPaste() 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnEditPaste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditInsert

void CStyleCtrl::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnUpdateEditInsert( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditInsert

void CStyleCtrl::OnEditInsert() 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnEditInsert();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnUpdateEditDelete

void CStyleCtrl::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnUpdateEditDelete( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnEditDelete

void CStyleCtrl::OnEditDelete() 
{
	if( m_pStyleDlg )
	{
		m_pStyleDlg->OnEditDelete();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnSyncStyleEditor

LRESULT CStyleCtrl::OnSyncStyleEditor( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(lParam);

	ASSERT( m_pStyle != NULL );

	m_pStyle->SyncStyleEditor( wParam );

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::PreTranslateMessage

BOOL CStyleCtrl::PreTranslateMessage( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case 0x59:	// VK_Y		(Redo)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditRedo();
						return TRUE;
					}
					break;

				case 0x5A:	// VK_Z		(Undo)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditUndo();
						return TRUE;
					}
					break;

				default:
					if( m_pStyleDlg )
					{
						if( m_pStyleDlg->HandleKeyDown( pMsg ) )
						{
							return TRUE;
						}
					}
					break;
			}
			break;
	}

	if( IsDialogMessage( pMsg ) )
	{
		return TRUE;
	}
	
	return COleControl::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl::OnHelpFinder

void CStyleCtrl::OnHelpFinder() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleDlg.cpp ===
// StyleDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "TimeSignatureDlg.h"
#include "StyleCtl.h"
#include "StyleDlg.h"
#include "Splitter.h"
#include <math.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox

CStyleComboBox::CStyleComboBox()
{
	m_pStyleDlg = NULL;
}

CStyleComboBox::~CStyleComboBox()
{
}


BEGIN_MESSAGE_MAP(CStyleComboBox, CComboBox)
	//{{AFX_MSG_MAP(CStyleComboBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CAPTURECHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox message handlers

/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnMouseMove

void CStyleComboBox::OnMouseMove( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyleDlg != NULL );

	CComboBox::OnMouseMove( nFlags, point );
	
	if( CWnd::GetCapture() == this )
	{
		if( m_pStyleDlg->m_dwMouseDownButton != 0 )
		{
			// See if user is moving the mouse
			if( m_pStyleDlg->m_rectMouseDown.PtInRect( point ) == FALSE )
			{
				// Start drag drop
				m_pStyleDlg->DoDrag( m_pStyleDlg->m_pIMouseDownNode, m_pStyleDlg->m_dwMouseDownButton ); 
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnCaptureChanged

void CStyleComboBox::OnCaptureChanged( CWnd *pWnd ) 
{
	if( pWnd == this )
	{
		return;
	}

	m_pStyleDlg->m_dwMouseDownButton = 0;
	m_pStyleDlg->m_pIMouseDownNode = NULL;
	m_pStyleDlg->m_rectMouseDown.SetRectEmpty();
	
	CComboBox::OnCaptureChanged( pWnd );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnLButtonDown

void CStyleComboBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyleDlg != NULL );

	CRect rect;

	GetClientRect( &rect );
	rect.right -= 18;

	if( rect.PtInRect( point ) == TRUE )
	{
		// Cursor in edit box
		SetFocus();
		m_pStyleDlg->OnSelChangeBandCombo();

		if( m_pStyleDlg->m_dwMouseDownButton == 0 )
		{
			// Get the Band
			int nPos = GetCurSel();
			if( nPos != CB_ERR )
			{
				IDMUSProdNode* pINode = (IDMUSProdNode *)GetItemDataPtr( nPos ); 
				if( pINode
				&&  pINode != (IDMUSProdNode *)-1 )
				{
					// First set capture
					SetCapture();

					// Now store fields used when drag drop is initiated
					m_pStyleDlg->m_dwMouseDownButton = MK_LBUTTON;
					m_pStyleDlg->m_pIMouseDownNode = pINode;

					m_pStyleDlg->m_rectMouseDown.left = point.x - 5;
					m_pStyleDlg->m_rectMouseDown.top = point.y - 5;
					m_pStyleDlg->m_rectMouseDown.right = point.x + 5;
					m_pStyleDlg->m_rectMouseDown.bottom = point.y + 5;
				}
			}
		}
		return;
	}

	CComboBox::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnLButtonUp

void CStyleComboBox::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	if( m_pStyleDlg->m_dwMouseDownButton == MK_LBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CComboBox::OnLButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnLButtonDblClk

void CStyleComboBox::OnLButtonDblClk( UINT nFlags, CPoint point ) 
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CRect rect;

	GetClientRect( &rect );
	rect.right -= 18;

	if( rect.PtInRect( point ) == TRUE )
	{
		// Cursor in edit box
		IDMUSProdNode* pINode = NULL;

		// Get the Band
		int nPos = GetCurSel();
		if( nPos != CB_ERR )
		{
			pINode = (IDMUSProdNode *)GetItemDataPtr( nPos ); 
		}

		if( pINode )
		{
			theApp.m_pStyleComponent->m_pIFramework->OpenEditor( pINode );
		}

		return;
	}

	CComboBox::OnLButtonDblClk(nFlags, point);
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnRButtonDown

void CStyleComboBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyleDlg != NULL );

	SetFocus();
	m_pStyleDlg->OnSelChangeBandCombo();

	if( m_pStyleDlg->m_dwMouseDownButton == 0 )
	{
		// Get the Band
		int nPos = GetCurSel();
		if( nPos != CB_ERR )
		{
			IDMUSProdNode* pINode = (IDMUSProdNode *)GetItemDataPtr( nPos ); 
			if( pINode
			&&  pINode != (IDMUSProdNode *)-1 )
			{
				// First set capture
				SetCapture();

				// Now store fields used when drag drop is initiated
				m_pStyleDlg->m_dwMouseDownButton = MK_RBUTTON;
				m_pStyleDlg->m_pIMouseDownNode = pINode;

				m_pStyleDlg->m_rectMouseDown.left = point.x - 5;
				m_pStyleDlg->m_rectMouseDown.top = point.y - 5;
				m_pStyleDlg->m_rectMouseDown.right = point.x + 5;
				m_pStyleDlg->m_rectMouseDown.bottom = point.y + 5;
			}
		}
	}

	CComboBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox::OnRButtonUp

void CStyleComboBox::OnRButtonUp( UINT nFlags, CPoint point ) 
{
	if( m_pStyleDlg->m_dwMouseDownButton == MK_RBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CComboBox::OnRButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox

CStyleListBox::CStyleListBox()
{
	m_pStyleDlg = NULL;
}

CStyleListBox::~CStyleListBox()
{
}


BEGIN_MESSAGE_MAP(CStyleListBox, CListBox)
	//{{AFX_MSG_MAP(CStyleListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CAPTURECHANGED()
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStyleListBox message handlers

/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnMouseMove

void CStyleListBox::OnMouseMove( UINT nFlags, CPoint point ) 
{
	UNREFERENCED_PARAMETER( nFlags );

	ASSERT( m_pStyleDlg != NULL );
	
	if( CWnd::GetCapture() == this )
	{
		if( m_pStyleDlg->m_dwMouseDownButton != 0 )
		{
			// See if user is moving the mouse
			if( m_pStyleDlg->m_rectMouseDown.PtInRect( point ) == FALSE )
			{
				// Start drag drop
				m_pStyleDlg->DoDrag( m_pStyleDlg->m_pIMouseDownNode, m_pStyleDlg->m_dwMouseDownButton ); 
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnCaptureChanged

void CStyleListBox::OnCaptureChanged( CWnd *pWnd ) 
{
	if( pWnd == this )
	{
		return;
	}

	m_pStyleDlg->m_dwMouseDownButton = 0;
	m_pStyleDlg->m_pIMouseDownNode = NULL;
	m_pStyleDlg->m_rectMouseDown.SetRectEmpty();
	
	CListBox::OnCaptureChanged( pWnd );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnLButtonDown

void CStyleListBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyleDlg != NULL );

	if( m_pStyleDlg->m_dwMouseDownButton == 0 )
	{
		BOOL fOutside;

		// Get nearest item
		int nPos = ItemFromPoint( point, fOutside );
		if( fOutside == FALSE
		&&  nPos != LB_ERR )
		{ 
			CRect rect;

			GetItemRect( nPos, &rect );
			if( rect.PtInRect( point ) )
			{
				// Cursor is in the nearest item
				SetCurSel( nPos );
				
				switch( GetDlgCtrlID() )
				{
					case IDC_PATTERN_LIST:
						m_pStyleDlg->OnSelChangePatternList();
						break;

					case IDC_MOTIF_LIST:
						m_pStyleDlg->OnSelChangeMotifList();
						m_pStyleDlg->PlayMotif();
						break;
				}

				CDirectMusicPattern* pPattern = (CDirectMusicPattern *)GetItemData( nPos );

				if( pPattern
				&&  pPattern != (CDirectMusicPattern *)LB_ERR )
				{
					// First set capture
					SetCapture();

					// Now store fields used when drag drop is initiated
					m_pStyleDlg->m_dwMouseDownButton = MK_LBUTTON;
					m_pStyleDlg->m_pIMouseDownNode = pPattern;

					m_pStyleDlg->m_rectMouseDown.left = point.x - 5;
					m_pStyleDlg->m_rectMouseDown.top = point.y - 5;
					m_pStyleDlg->m_rectMouseDown.right = point.x + 5;
					m_pStyleDlg->m_rectMouseDown.bottom = point.y + 5;
				}
			}
		}
	}

	CListBox::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnLButtonUp

void CStyleListBox::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	if( m_pStyleDlg->m_dwMouseDownButton == MK_LBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CListBox::OnLButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnRButtonDown

void CStyleListBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyleDlg != NULL );

	if( m_pStyleDlg->m_dwMouseDownButton == 0 )
	{
		BOOL fOutside;

		// Get nearest item
		int nPos = ItemFromPoint( point, fOutside );
		if( fOutside == FALSE
		&&  nPos != LB_ERR )
		{
			CRect rect;

			GetItemRect( nPos, &rect );
			if( rect.PtInRect( point ) )
			{
				// Cursor is in the nearest item
				SetCurSel( nPos ); 
				
				switch( GetDlgCtrlID() )
				{
					case IDC_PATTERN_LIST:
						m_pStyleDlg->OnSelChangePatternList();
						break;

					case IDC_MOTIF_LIST:
						m_pStyleDlg->OnSelChangeMotifList();
						break;
				}

				CDirectMusicPattern* pPattern = (CDirectMusicPattern *)GetItemData( nPos );

				if( pPattern
				&&  pPattern != (CDirectMusicPattern *)LB_ERR )
				{
					// First set capture
					SetCapture();

					// Now store fields used when drag drop is initiated
					m_pStyleDlg->m_dwMouseDownButton = MK_RBUTTON;
					m_pStyleDlg->m_pIMouseDownNode = pPattern;

					m_pStyleDlg->m_rectMouseDown.left = point.x - 5;
					m_pStyleDlg->m_rectMouseDown.top = point.y - 5;
					m_pStyleDlg->m_rectMouseDown.right = point.x + 5;
					m_pStyleDlg->m_rectMouseDown.bottom = point.y + 5;
				}
			}
		}
	}

	CListBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnRButtonUp

void CStyleListBox::OnRButtonUp( UINT nFlags, CPoint point ) 
{
	if( m_pStyleDlg->m_dwMouseDownButton == MK_RBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CListBox::OnRButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox::OnHScroll

void CStyleListBox::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) 
{
	CListBox::OnHScroll( nSBCode, nPos, pScrollBar );

	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg

IMPLEMENT_DYNCREATE(CStyleDlg, CFormView)

CStyleDlg::CStyleDlg()
	: CFormView(CStyleDlg::IDD)
{
	//{{AFX_DATA_INIT(CStyleDlg)
	//}}AFX_DATA_INIT

	m_dwRef = 0;
	AddRef();
	
	m_pStyleCtrl = NULL;
	m_pStyle = NULL;

	m_pIDataObject = NULL;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_pIDragNode = NULL;

	m_dwMouseDownButton = 0;
	m_pIMouseDownNode = NULL;

	m_pINodeRightMenu = NULL;
	m_nEditMenuCtrlID = 0;
	m_pFont = NULL;
}

CStyleDlg::~CStyleDlg()
{
}

void CStyleDlg::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStyleDlg)
	DDX_Control(pDX, IDC_SEPARATOR_LINE, m_staticSeparator);
	DDX_Control(pDX, IDC_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_TEMPO_SPIN, m_spinTempo);
	DDX_Control(pDX, IDC_TEMPO, m_editTempo);
	DDX_Control(pDX, IDC_BAND_DEFAULT, m_checkBandDefault);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::SetTempoControlText

void CStyleDlg::SetTempoControlText( void ) 
{
	if( m_pStyle )
	{
		CString strTempo;

		strTempo.Format( "%.2f", m_pStyle->m_dblTempo );
		m_editTempo.SetWindowText( strTempo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::DoDrag

void CStyleDlg::DoDrag( IDMUSProdNode* pINode, DWORD dwStartDragButton )
{
	ASSERT( pINode != NULL );

	// If already dragging, just return
	if( m_pDragImage )
	{
		return;
	}

	if( pINode )
	{
		IDataObject* pIDataObject;
		DWORD dwEffect;
		HRESULT hr;

		if( SUCCEEDED ( pINode->CreateDataObject( &pIDataObject ) ) )
		{
			// Create image used for drag-drop feedback
			if( m_pDragImage )
			{
				m_pDragImage->BeginDrag( 0, CPoint(8, 12) );
			}

			// Start drag-drop operation
			DWORD dwOKDragEffects = DROPEFFECT_COPY;
			if( pINode->CanCut() == S_OK )
			{
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			m_pIDragNode = pINode;
			m_dwStartDragButton = dwStartDragButton;
			
			hr = ::DoDragDrop( pIDataObject, (IDropSource *)this, dwOKDragEffects, &dwEffect );

			m_pIDragNode = NULL;
			m_dwStartDragButton = 0;

			// Delete image used for drag-drop feedback
			if( m_pDragImage )
			{
				m_pDragImage->EndDrag();

				delete m_pDragImage;
				m_pDragImage = NULL;
			}

			switch( hr )
			{
				case DRAGDROP_S_DROP:
					if( dwEffect & DROPEFFECT_MOVE )
					{
						pINode->DeleteNode( FALSE );
					}
					break;
			}
			
			RELEASE( pIDataObject );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::EndTrack

void CStyleDlg::EndTrack( int nHeight )
{
	ASSERT( m_pStyle != NULL );

	m_pStyle->m_nSplitterYPos = nHeight;
	m_pStyle->SetModified( TRUE );

	CRect rect;
	GetClientRect( &rect );

    m_lstbxMotif.InvalidateRect( NULL );
	OnSize( SIZE_RESTORED, rect.Width(), rect.Height() );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::RefreshControls

void CStyleDlg::RefreshControls( DWORD dwFlags )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( dwFlags & SSE_STYLE )
	{
		// Update bitmap on time signature button
		SetTimeSignatureBitmap();

		// Set tempo control
		SetTempoControlText();
	}

	if( dwFlags & SSE_BANDS )
	{
		FillBandComboBox();
	}

	if( dwFlags & SSE_PATTERNS )
	{
		FillPatternListBox();
	}

	if( dwFlags & SSE_MOTIFS )
	{
		FillMotifListBox();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::SelectPattern

void CStyleDlg::SelectPattern( CDirectMusicPattern* pPattern )
{
	ASSERT( pPattern != NULL );

	int nPos = m_lstbxPattern.FindStringExact( -1, (LPCTSTR)pPattern );

	if( nPos != LB_ERR )
	{
		m_lstbxPattern.SetCurSel( nPos );
		m_lstbxPattern.SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::SelectMotif

void CStyleDlg::SelectMotif( CDirectMusicPattern* pMotif )
{
	ASSERT( pMotif != NULL );

	int nPos = m_lstbxMotif.FindStringExact( -1, (LPCTSTR)pMotif );

	if( nPos != LB_ERR )
	{
		m_lstbxMotif.SetCurSel( nPos );
		m_lstbxMotif.SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::SelectBand

void CStyleDlg::SelectBand( IDMUSProdNode* pINode )
{
	ASSERT( pINode != NULL );
	ASSERT( m_pStyle != NULL );

	// Get name of Band
	CString strName;
	BSTR bstrName;

	if( SUCCEEDED ( pINode->GetNodeName ( &bstrName ) ) )
	{
		strName = bstrName;
		::SysFreeString( bstrName );
	}

	// Search combo box for Band
	IDMUSProdNode* pINodeList;

	int nPos = m_cmbxBand.FindStringExact( 0, strName );
	while( nPos != CB_ERR )
	{
		pINodeList = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
		if( pINodeList == pINode )
		{
			break;
		}

		nPos = m_cmbxBand.FindStringExact( nPos, strName );
	}

	if( nPos != CB_ERR )
	{
		m_cmbxBand.SetCurSel( nPos );
		OnSelChangeBandCombo();

		// Set the Style's active Band
		m_pStyle->SetActiveBand( pINode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::SetTimeSignatureBitmap

void CStyleDlg::SetTimeSignatureBitmap( void )
{
	HBITMAP hNewBits = NULL;

	ASSERT( m_pStyle != NULL );

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	// Write text
	CString strTimeSignature;

	CFont font;
	CFont* pfontOld = NULL;

	if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		pfontOld = cdcDest.SelectObject( &font );
	}

	strTimeSignature.Format( "%d/%d",
							 m_pStyle->m_TimeSignature.m_bBeatsPerMeasure,
							 m_pStyle->m_TimeSignature.m_bBeat );
	rect.left += 6;
	cdcDest.SetTextColor( COLOR_BTNTEXT );
	cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_NOPREFIX) );
	rect.left -= 6;

	if( pfontOld )
	{
		cdcDest.SelectObject( pfontOld );
		font.DeleteObject();
	}

	// Set x coord for 'Grids Per Beat' image
	CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
	int nX = max( 48, (sizeText.cx + 8) );

	// Draw "splitter"
	{
		CPen pen1;
		CPen pen2;
		CPen* ppenOld;

		int nPlace = nX - 6;
		int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

		// Highlight
		if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen1 );
			cdcDest.MoveTo( nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		// Shadow
		if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen2 );
			cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		if( nModeOld )
		{
			cdcDest.SetROP2( nModeOld );
		}
	}

	// Add 'Grids Per Beat' bitmap
	{
		int nResourceID = m_pStyle->m_TimeSignature.m_wGridsPerBeat - 1;
		if( m_pStyle->m_TimeSignature.m_bBeat != 4 )		// 4 = quarter note gets the beat
		{
			nResourceID += MAX_GRIDS_PER_BEAT;
		}
		ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );
		
		if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
		{
			BITMAP bm;

			bmpGridsPerBeat.GetBitmap( &bm );

			int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

			CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

			{
				CDC cdcMono;
				CBitmap bmpMono;

				if( cdcMono.CreateCompatibleDC( &cdcDest )
				&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
				{
					CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
					
					cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
					cdcDest.SetBkColor( RGB(255,255,255) );

					cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCCOPY);
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT );
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcMono, 0, 0, SRCAND );
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT );

					cdcMono.SelectObject( pbmpOldMono );
				}
			}

			cdcGridsPerBeat.SelectObject( pbmpOld );
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::FillPatternListBox

void CStyleDlg::FillPatternListBox()
{
	CDirectMusicPattern * pCurPattern;

	ASSERT( m_pStyle != NULL );

	// Store the current Pattern selection
	int nCurPos = m_lstbxPattern.GetCurSel();
	if( nCurPos != LB_ERR )
	{
		pCurPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nCurPos ); 
	}

	// Initialize the list box
	m_lstbxPattern.ResetContent();
	m_lstbxPattern.SetHorizontalExtent( 0 );

	// Fill the list box
	CDirectMusicPattern * pPattern;
	CDC* pDC;
	TEXTMETRIC tm;
	int nTextWidth;
	int nChordRhythmWidth;
	int nMaxBPM;
	int nCurExtent;

    POSITION pos = m_pStyle->m_StylePatterns.m_lstPatterns.GetHeadPosition();
    while( pos )
    {
        pPattern = m_pStyle->m_StylePatterns.m_lstPatterns.GetNext( pos );

		m_lstbxPattern.AddString( (LPCTSTR)pPattern  );

		// Set horizontal extent
		nCurExtent = m_lstbxPattern.GetHorizontalExtent();

		pDC = m_lstbxPattern.GetDC();
		if( pDC )
		{
			// Calc width of chord rhythm
			nMaxBPM = min( 32, pPattern->m_TimeSignature.m_bBeatsPerMeasure ); 
			nChordRhythmWidth  = (nMaxBPM * pPattern->m_wNbrMeasures) * 3;
			nChordRhythmWidth += pPattern->m_wNbrMeasures * 3; 

			// Calc width of left-hand text + chord rhythm
			pDC->GetTextMetrics( &tm );
			nTextWidth = (tm.tmAveCharWidth * 52) + nChordRhythmWidth;
			
//			if( nTextWidth > nCurExtent )
//			{
//				m_lstbxPattern.SetHorizontalExtent( nTextWidth );
//			}

			m_lstbxPattern.ReleaseDC( pDC );
		}
	}

	// Set the current selection
	if( nCurPos == LB_ERR )
	{
		m_lstbxPattern.SetCurSel( -1 );
	}
	else
	{
		int nPos = LB_ERR;

		pos = m_pStyle->m_StylePatterns.m_lstPatterns.Find( pCurPattern );
		if( pos )
		{
			nPos = m_lstbxPattern.FindStringExact( -1, (LPCTSTR)pCurPattern );
		}

		if( nPos == LB_ERR )
		{
			nPos = nCurPos;

			int nCount = m_lstbxPattern.GetCount();
			if( nCount > 0 )
			{
				if( nPos > (nCount - 1) )
				{
					nPos = 0;
				}
			}
		}

		m_lstbxPattern.SetCurSel( nPos );
	}

	m_lstbxPattern.UpdateWindow();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::FillMotifListBox

void CStyleDlg::FillMotifListBox()
{
	CDirectMusicPattern * pCurMotif;

	ASSERT( m_pStyle != NULL );

	// Store the current Motif selection
	int nCurPos = m_lstbxMotif.GetCurSel();
	if( nCurPos != LB_ERR )
	{
		pCurMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nCurPos ); 
	}

	// Initialize the list box
	m_lstbxMotif.ResetContent();

	// Fill the list box
	CDirectMusicPattern * pMotif;

    POSITION pos = m_pStyle->m_StyleMotifs.m_lstMotifs.GetHeadPosition();
    while( pos )
    {
        pMotif = m_pStyle->m_StyleMotifs.m_lstMotifs.GetNext( pos );

		m_lstbxMotif.AddString( (LPCTSTR)pMotif  );
	}

	// Set the current selection
	if( nCurPos == LB_ERR )
	{
		m_lstbxMotif.SetCurSel( -1 );
	}
	else
	{
		int nPos = LB_ERR;

		pos = m_pStyle->m_StyleMotifs.m_lstMotifs.Find( pCurMotif );
		if( pos )
		{
			nPos = m_lstbxMotif.FindStringExact( -1, (LPCTSTR)pCurMotif );
		}

		if( nPos == LB_ERR )
		{
			nPos = nCurPos;

			int nCount = m_lstbxMotif.GetCount();
			if( nCount > 0 )
			{
				if( nPos > (nCount - 1) )
				{
					nPos = 0;
				}
			}
		}

		m_lstbxMotif.SetCurSel( nPos );
	}

	m_lstbxMotif.UpdateWindow();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::FillBandComboBox

void CStyleDlg::FillBandComboBox()
{
	IDMUSProdNode* pINodeCurSel;
	BSTR bstrNameCurSel;
	CString	strNameCurSel;

	ASSERT( m_pStyle != NULL );

	// Store the current Band selection
	int nCurPos = m_cmbxBand.GetCurSel();
	if( nCurPos != CB_ERR )
	{
		pINodeCurSel = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nCurPos ); 
		if( SUCCEEDED ( pINodeCurSel->GetNodeName ( &bstrNameCurSel ) ) )
		{
			strNameCurSel = bstrNameCurSel;
			::SysFreeString( bstrNameCurSel );
		}
	}

	// Initialize the list box
	m_cmbxBand.ResetContent();

	// Fill the combo box
	IDMUSProdNode* pINode;
	CString strName;
	BSTR bstrName;
	int nPos;

    POSITION pos = m_pStyle->m_StyleBands.m_lstBands.GetHeadPosition();
    while( pos )
    {
        pINode = m_pStyle->m_StyleBands.m_lstBands.GetNext( pos );

		if( SUCCEEDED ( pINode->GetNodeName ( &bstrName ) ) )
		{
			strName = bstrName;
			::SysFreeString( bstrName );
		}

		nPos = m_cmbxBand.AddString( strName );
		if( nPos != CB_ERR )
		{
			m_cmbxBand.SetItemDataPtr( nPos, pINode );
		}
	}

	// Set the current selection
	nPos = 0;

	if( nCurPos != CB_ERR )
	{
		int nStartPos = m_cmbxBand.FindStringExact( 0, strNameCurSel );

		nPos = nStartPos;
		while( nPos != CB_ERR )
		{
			pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
			if( pINode == pINodeCurSel )
			{
				break;
			}

			nPos = m_cmbxBand.FindStringExact( nPos, strNameCurSel );
			if( nPos <= nStartPos )
			{
				// Already searched through entire list
				// Force error
				nPos = CB_ERR;
			}
		}
		if( nPos == CB_ERR )
		{
			nPos = nCurPos;
		}
	}
	int nCount = m_cmbxBand.GetCount();
	if( nCount > 0 )
	{
		if( nPos > (nCount - 1) )
		{
			nPos = 0;
		}
	}
	m_cmbxBand.SetCurSel( nPos );
	OnSelChangeBandCombo();
}


#define NBR_EMBELLISHMENT_FLAGS	4
#define NBR_CHORD_CHANGE_FLAGS	3

static LONG lEmbFlags[NBR_EMBELLISHMENT_FLAGS] = { EMB_INTRO, EMB_FILL, EMB_BREAK, EMB_END };
static char chEmbText[NBR_EMBELLISHMENT_FLAGS]  = { 'I', 'F', 'B', 'E' } ; 

static char chChordChangeText[NBR_CHORD_CHANGE_FLAGS]  = { 'W', 'H', 'Q' } ; 

/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::DrawPatternItem

void CStyleDlg::DrawPatternItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	// Get the Pattern
	CDirectMusicPattern* pPattern = (CDirectMusicPattern *)lpDrawItemStruct->itemData; 
	ASSERT( pPattern != NULL );

	// Get the DC
	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
    int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

    CRect rect( 0, 0, nWidth, nHeight );

	CDC dc;
	CBitmap bmp;
	CString strText;
	int i;

	if( dc.CreateCompatibleDC( pDC )
	&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
	{
		CFont* pFontOld = dc.SelectObject( m_pFont );
		CBitmap* pBitmapOld = dc.SelectObject( &bmp );
        int nBkModeOld = dc.SetBkMode( TRANSPARENT );

		TEXTMETRIC tm;
		dc.GetTextMetrics( &tm );
		if( lpDrawItemStruct->itemState & ODS_SELECTED )
		{
			if( ::GetFocus() == m_lstbxPattern.GetSafeHwnd() )
			{
		        dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
				dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			}
			else
			{
		        dc.FillSolidRect( &rect, ::GetSysColor(COLOR_INACTIVECAPTION) );
				dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
			}
		}
		else
		{
	        dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
			dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
		}

		// Draw Pattern name
        rect.left  += 3;
        rect.right  = tm.tmAveCharWidth * 17;
        dc.DrawText( pPattern->m_strName, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern length
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 7);
        strText.Format( "%d    ", pPattern->m_wNbrMeasures );
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern time signature
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 11);
		strText.Format( "%d/%d", pPattern->m_TimeSignature.m_bBeatsPerMeasure, pPattern->m_TimeSignature.m_bBeat );
		if( !(pPattern->m_TimeSignature.m_wGridsPerBeat % 3) )
		{
			strText += _T("  3");
		}
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern groove bottom
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 5);
        strText.Format( "%u    ", pPattern->m_bGrooveBottom );
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern groove top
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 10);
        strText.Format( "%u    ", pPattern->m_bGrooveTop );
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern dest groove bottom
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 5);
        strText.Format( "%u    ", pPattern->m_bDestGrooveBottom );
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern dest groove top
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 8);
        strText.Format( "%u    ", pPattern->m_bDestGrooveTop );
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Pattern embellishment flags
        for( i = 0 ;  i < NBR_EMBELLISHMENT_FLAGS ;  i++ )
        {
	        rect.left  = rect.right;
            rect.right = rect.left + tm.tmMaxCharWidth + 1;
            if( pPattern->m_wEmbellishment & lEmbFlags[i] )
            {
                strText = chEmbText[i];
                dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_CENTER | DT_NOPREFIX) );
            }
        }

		// Draw Pattern user-defined embellishment number
		{
			strText.Empty();
			rect.left  = ++rect.right;
			rect.right = rect.left + tm.tmMaxCharWidth * 3;
			if( HIBYTE(pPattern->m_wEmbellishment) )
			{
		        strText.Format( "%d    ", HIBYTE(pPattern->m_wEmbellishment) );
			}
			dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
		}
		rect.right += tm.tmMaxCharWidth >> 1; 

		// Draw Pattern chord rhythm
		int j;
		int nMaxRight = nWidth - 4;
		rect.InflateRect( 0, -3 );
		int nTickHeight = (rect.Height() >> 1) - 1;
		for( i = 0 ;  i < pPattern->m_wNbrMeasures ; i++ )
		{
			for( j = 0 ;  j < 32 ;  j++ )
			{
				if( j >= pPattern->m_TimeSignature.m_bBeatsPerMeasure )
				{
					break;
				}

				rect.left  = rect.right + 2;
			    rect.right = rect.left + 1;
				if( rect.left >= nMaxRight )
				{
					break;
				}

				if( pPattern->m_pRhythmMap[i] & (1 << j) )
				{
					dc.FillSolidRect( &rect, RGB(0,0,0) );
				}
				else
				{
					rect.InflateRect( 0, -nTickHeight );
					dc.FillSolidRect( &rect, RGB(0,0,0) );
					rect.InflateRect( 0, nTickHeight );
				}
			}
			
			rect.left += 3;
			rect.right += 3;
			if( rect.left >= nMaxRight )
			{
				break;
			}
		}
		rect.InflateRect( 0, 3 );

		// Draw the item
        pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
                     &dc, 0, 0, SRCCOPY );

		// Clean up
		dc.SetBkMode( nBkModeOld );
		if( pFontOld )
		{
			dc.SelectObject( pFontOld );
		}
		if( pBitmapOld )
		{
			dc.SelectObject( pBitmapOld );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::DrawMotifItem

void CStyleDlg::DrawMotifItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	// Get the Motif
	CDirectMusicPattern* pMotif = (CDirectMusicPattern *)lpDrawItemStruct->itemData; 
	ASSERT( pMotif != NULL );

	// Get the DC
	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
    int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

    CRect rect( 0, 0, nWidth, nHeight );

	CDC dc;
	CBitmap bmp;
	CString strText;

	if( dc.CreateCompatibleDC( pDC )
	&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
	{
		CFont* pFontOld = dc.SelectObject( m_pFont );
		CBitmap* pBitmapOld = dc.SelectObject( &bmp );
        int nBkModeOld = dc.SetBkMode( TRANSPARENT );

		TEXTMETRIC tm;
		dc.GetTextMetrics( &tm );
		if( lpDrawItemStruct->itemState & ODS_SELECTED )
		{
			if( ::GetFocus() == m_lstbxMotif.GetSafeHwnd() )
			{
		        dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
				dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			}
			else
			{
		        dc.FillSolidRect( &rect, ::GetSysColor(COLOR_INACTIVECAPTION) );
				dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
			}
		}
		else
		{
	        dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
			dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
		}

		// Draw Motif name
        rect.left  += 3;
        rect.right  = tm.tmAveCharWidth * 17;
        dc.DrawText( pMotif->m_strName, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Motif length
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 7);
        strText.Format( "%d    ", pMotif->m_wNbrMeasures );
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw Motif time signature
        rect.left  = ++rect.right;
        rect.right = rect.left + (tm.tmAveCharWidth * 11);
		strText.Format( "%d/%d", pMotif->m_TimeSignature.m_bBeatsPerMeasure, pMotif->m_TimeSignature.m_bBeat );
		if( !(pMotif->m_TimeSignature.m_wGridsPerBeat % 3) )
		{
			strText += _T("  3");
		}
        dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );

		// Draw the item
        pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
                     &dc, 0, 0, SRCCOPY );

		// Clean up
		dc.SetBkMode( nBkModeOld );
		if( pFontOld )
		{
			dc.SelectObject( pFontOld );
		}
		if( pBitmapOld )
		{
			dc.SelectObject( pBitmapOld );
		}
	}
}


BEGIN_MESSAGE_MAP(CStyleDlg, CFormView)
	//{{AFX_MSG_MAP(CStyleDlg)
	ON_COMMAND(IDM_DRAG_MOVE, OnDragRMenuMove)
	ON_COMMAND(IDM_DRAG_COPY, OnDragRMenuCopy)
	ON_COMMAND(IDM_DRAG_CANCEL, OnDragRMenuCancel)
	ON_WM_SETCURSOR()
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_EN_KILLFOCUS(IDC_TEMPO, OnKillFocusTempo)
	ON_NOTIFY(UDN_DELTAPOS, IDC_TEMPO_SPIN, OnDeltaPosTempoSpin)
	ON_BN_CLICKED(IDC_TIME_SIGNATURE, OnTimeSignature)
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	ON_WM_COMPAREITEM()
	ON_LBN_DBLCLK(IDC_PATTERN_LIST, OnDblClkPatternList)
	ON_LBN_DBLCLK(IDC_MOTIF_LIST, OnDblClkMotifList)
	ON_LBN_SELCHANGE(IDC_MOTIF_LIST, OnSelChangeMotifList)
	ON_LBN_SELCHANGE(IDC_PATTERN_LIST, OnSelChangePatternList)
	ON_CBN_SELCHANGE(IDC_BAND_COMBO, OnSelChangeBandCombo)
	ON_CBN_SETFOCUS(IDC_BAND_COMBO, OnSetFocusBandCombo)
	ON_CBN_KILLFOCUS(IDC_BAND_COMBO, OnKillFocusBandCombo)
	ON_LBN_SETFOCUS(IDC_PATTERN_LIST, OnSetFocusPatternList)
	ON_LBN_KILLFOCUS(IDC_PATTERN_LIST, OnKillFocusPatternList)
	ON_LBN_SETFOCUS(IDC_MOTIF_LIST, OnSetFocusMotifList)
	ON_LBN_KILLFOCUS(IDC_MOTIF_LIST, OnKillFocusMotifList)
	ON_WM_CONTEXTMENU()
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_RBUTTONUP()
	ON_WM_CAPTURECHANGED()
	ON_BN_CLICKED(IDC_BAND_DEFAULT, OnBandDefault)
	ON_BN_DOUBLECLICKED(IDC_BAND_DEFAULT, OnDblClkBandDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg diagnostics

#ifdef _DEBUG
void CStyleDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CStyleDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG




/////////////////////////////////////////////////////////////////////////////
// CStyleDlg IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// IUknown CStyleDlg::QueryInterface

HRESULT CStyleDlg::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDropSource)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDropSource *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDropTarget) )
    {
        AddRef();
        *ppvObj = (IDropTarget *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CStyleDlg::AddRef

ULONG CStyleDlg::AddRef( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CStyleDlg::Release

ULONG CStyleDlg::Release( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    ASSERT( m_dwRef != 0 );	// m_dwRef should never get to zero.

//  if( m_dwRef == 0 )		   CStyleDlg should be deleted when		
//  {						   control is destroyed. 						
//		delete this;		
//		return 0;
//  }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg IDropSource implementation

/////////////////////////////////////////////////////////////////////////////
// IDropSource CStyleDlg::QueryContinueDrag

HRESULT CStyleDlg::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton == MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton == MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropSource CStyleDlg::GiveFeedback

HRESULT CStyleDlg::GiveFeedback( DWORD dwEffect )
{
	UNREFERENCED_PARAMETER( dwEffect );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg IDropTarget implementation

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CStyleDlg::DragEnter

HRESULT CStyleDlg::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pIDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pIDataObject = pIDataObject;
	m_pIDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetDesktopWindow (), point );
	}

	// Make sure editor is on top
	if( m_pStyle->m_hWndEditor )
	{
		::BringWindowToTop( m_pStyle->m_hWndEditor );
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CStyleDlg::DragOver

HRESULT CStyleDlg::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	UNREFERENCED_PARAMETER( pt );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;
	BOOL fWillSetReference;

	if( m_pStyle->CanPasteFromData( m_pIDataObject, &fWillSetReference ) == S_OK )
	{
		if( fWillSetReference )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CStyleDlg::DragLeave

HRESULT CStyleDlg::DragLeave( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Release IDataObject
	RELEASE( m_pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CStyleDlg::Drop

HRESULT CStyleDlg::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	UNREFERENCED_PARAMETER( grfKeyState );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDataObject != NULL );
	ASSERT( m_pIDataObject == pIDataObject );
	ASSERT( m_pStyle != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( theApp.m_hInstance, IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Display and track menu
			CPoint point( pt.x, pt.y );
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			DestroyMenu( hMenu );

			// Need to process WM_COMMAND from TrackPopupMenu
			MSG msg;
			while( ::PeekMessage( &msg, GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}

			// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
			m_dwOverDragEffect = m_dwDragRMenuEffect;
			m_dwDragRMenuEffect = DROPEFFECT_NONE;
		}
	}

	if( m_dwOverDragEffect & DROPEFFECT_MOVE 
	&&  m_pIDragNode )
	{
		// No point in moving node to same Style
		hr = E_FAIL;
	}
	else
	{
		if( m_dwOverDragEffect != DROPEFFECT_NONE )
		{
			// Paste data
			hr = m_pStyle->PasteFromData( pIDataObject );
			if( SUCCEEDED ( hr ) )
			{
				*pdwEffect = m_dwOverDragEffect;
			}
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg message handlers


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::Create

BOOL CStyleDlg::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext ) 
{
	// Create Font
	m_pFont = new CFont;
	if( m_pFont == NULL )
	{
		return FALSE;
	}
	if( m_pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 							 DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							 DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) == FALSE )
	{
		return FALSE;
	}

	if( !CFormView::Create( lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext ) )
	{
		return FALSE;
	}

	// Create the splitter bar
	m_wndSplitter.Create( this );
	m_wndSplitter.SetTopBorder( GetTopBorder() );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnInitialUpdate

void CStyleDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	CFormView::OnInitialUpdate();
	
	HRESULT hr = ::RegisterDragDrop( GetSafeHwnd(), (IDropTarget *)this );
	ASSERT(SUCCEEDED(hr));

	// Subclass controls
	m_cmbxBand.SubclassDlgItem( IDC_BAND_COMBO, this );
	m_cmbxBand.m_pStyleDlg = this;
	m_lstbxPattern.SubclassDlgItem( IDC_PATTERN_LIST, this );
	m_lstbxPattern.m_pStyleDlg = this;
	m_lstbxMotif.SubclassDlgItem( IDC_MOTIF_LIST, this );
	m_lstbxMotif.m_pStyleDlg = this;

	m_spinTempo.SetRange( DMUS_TEMPO_MIN, DMUS_TEMPO_MAX );
	m_editTempo.LimitText( 6 ); // 350.00

	IDMUSProdNode* pINode = m_pStyle->GetActiveBand();
	if( pINode == NULL )
	{
		pINode = m_pStyle->GetTheDefaultBand();
	}

	RefreshControls( SSE_ALL );

	if( pINode )
	{
		SelectBand( pINode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDestroy

void CStyleDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Delete the font
	if( m_pFont )
	{
		m_pFont->DeleteObject();
		delete m_pFont;
		m_pFont = NULL;
	}

	HRESULT hr = ::RevokeDragDrop( GetSafeHwnd() );
	ASSERT( SUCCEEDED( hr ) );
	
	CFormView::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDragRMenuMove

void CStyleDlg::OnDragRMenuMove() 
{
	m_dwDragRMenuEffect = DROPEFFECT_MOVE;	
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDragRMenuCopy

void CStyleDlg::OnDragRMenuCopy() 
{
	m_dwDragRMenuEffect = DROPEFFECT_COPY;	
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDragRMenuCancel

void CStyleDlg::OnDragRMenuCancel() 
{
	m_dwDragRMenuEffect = DROPEFFECT_NONE;	
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::GetTopBorder

int CStyleDlg::GetTopBorder()
{
	int nTopBorder = 54;

	CWnd* pWnd = GetDlgItem( IDC_NAME_PROMPT );
	if( pWnd )
	{
		RECT rect;

		pWnd->GetClientRect( &rect );
		pWnd->ClientToScreen( &rect );
		ScreenToClient( &rect );
		nTopBorder = rect.bottom + STYLE_DLG_BORDER;
	}

	return nTopBorder;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSize

void CStyleDlg::OnSize( UINT nType, int cx, int cy ) 
{
    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	// Exit if we are not fully created yet
	if( !::IsWindow(m_wndSplitter) )
	{
		return;
	}

	ASSERT( m_pStyle != NULL );

	// Determine top border
	int nTopBorder = GetTopBorder();

	CRect rect;

	// Set default splitter position
	if( m_pStyle->m_nSplitterYPos == 0 )
	{
		GetClientRect( &rect );
		m_pStyle->m_nSplitterYPos = rect.Height() -
								    ((rect.Height() - nTopBorder) >> 2) +
									nTopBorder;
		m_pStyle->m_nSplitterYPos = max( m_pStyle->m_nSplitterYPos, nTopBorder + SPLITTER_HEIGHT + 1 ); 
	}

	// Resize the separator line
	m_staticSeparator.GetClientRect( &rect );
	m_staticSeparator.ClientToScreen( &rect );
	ScreenToClient( &rect );
	m_staticSeparator.MoveWindow( 0, rect.top - 1, cx, 2, TRUE );

	// Determine splitter bar position
	int nSplitterYPos = min( m_pStyle->m_nSplitterYPos, cy - (SPLITTER_HEIGHT + STYLE_DLG_BORDER + 4) );
	if( nSplitterYPos != m_pStyle->m_nSplitterYPos )
	{
		int nMinSplitterYPos = max( nSplitterYPos, nTopBorder + SPLITTER_HEIGHT + 1 ); 
		if( nMinSplitterYPos > nSplitterYPos )
		{
			nSplitterYPos = m_pStyle->m_nSplitterYPos;
		}
	}
	
	// Move the splitter bar
    m_wndSplitter.MoveWindow( STYLE_DLG_BORDER, nSplitterYPos,
							  cx - (STYLE_DLG_BORDER << 1), SPLITTER_HEIGHT, TRUE );

	int nX  = STYLE_DLG_BORDER;
	int nCX = cx - (STYLE_DLG_BORDER << 1);

	// Recalc size of Pattern listbox
	int nY  = nTopBorder;
	int nCY = nSplitterYPos - nTopBorder;

    m_lstbxPattern.MoveWindow( nX, nY, nCX, nCY, TRUE );

	// Recalc size of Motif listbox
	nY  = nSplitterYPos + SPLITTER_HEIGHT;
	nCY = cy - ((nSplitterYPos + SPLITTER_HEIGHT) + STYLE_DLG_BORDER);

    m_lstbxMotif.MoveWindow( nX, nY, nCX, nCY, TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnKillFocusTempo

void CStyleDlg::OnKillFocusTempo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	CString strNewTempo;

	m_editTempo.GetWindowText( strNewTempo );

	// Strip leading and trailing spaces
	strNewTempo.TrimRight();
	strNewTempo.TrimLeft();

	if( strNewTempo.IsEmpty() )
	{
		SetTempoControlText();
	}
	else
	{
		double dblNewTempo;

		TCHAR* pszTempo;
		pszTempo = new TCHAR[strNewTempo.GetLength() + 1];

		if( pszTempo )
		{
			pszTempo[0] = 0;

			if( _stscanf( strNewTempo, "%lf%s", &dblNewTempo, pszTempo ) )
			{
				// Check bounds
				if( dblNewTempo > DMUS_TEMPO_MAX )
				{
					dblNewTempo = DMUS_TEMPO_MAX;
				}
				else if( dblNewTempo < DMUS_TEMPO_MIN )
				{
					dblNewTempo = DMUS_TEMPO_MIN;
				}

				m_pStyle->SetTempo( dblNewTempo, FALSE );
			}

			SetTempoControlText();	// Make sure edit control
									// reflects the tempo of m_pStyle
			delete pszTempo;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDeltaPosTempoSpin

void CStyleDlg::OnDeltaPosTempoSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusTempo();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	double dblNewTempo = floor( m_pStyle->m_dblTempo + pNMUpDown->iDelta );

	// If too small, wrap to DMUS_TEMPO_MAX
	if( dblNewTempo < DMUS_TEMPO_MIN )
	{
		dblNewTempo = DMUS_TEMPO_MAX;
	}
	// If too large, wrap to DMUS_TEMPO_MIN
	else if( dblNewTempo > DMUS_TEMPO_MAX )
	{
		dblNewTempo = DMUS_TEMPO_MIN;
	}

	// Sync edit control so OnKillFocus doesn't change it back
	CString strTempo;
	strTempo.Format( "%.2f", dblNewTempo );
	m_editTempo.SetWindowText( strTempo );

	m_pStyle->SetTempo( dblNewTempo, FALSE );
	SetTempoControlText();	// Make sure edit control
							// reflects results of SetTempo()
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnTimeSignature

void CStyleDlg::OnTimeSignature() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	CTimeSignatureDlg tsDlg;

	tsDlg.m_TimeSignature = m_pStyle->m_TimeSignature;
	tsDlg.m_nContext = IDS_STYLE_TEXT;

	if( tsDlg.DoModal() == IDOK )
	{
		// Update time signature
		m_pStyle->SetTimeSignature( tsDlg.m_TimeSignature, FALSE );

		// Update bitmap on time signature button
		SetTimeSignatureBitmap();
	}

	m_btnTimeSignature.SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSelChangePatternList

void CStyleDlg::OnSelChangePatternList() 
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pPattern = NULL;

	// Get the Pattern
	int nPos = m_lstbxPattern.GetCurSel();
	if( nPos != LB_ERR )
	{
		pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos ); 
	}

	if( pPattern )
	{
		// Sync property sheet
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				pPattern->OnShowProperties();
			}

			RELEASE( pIPropSheet );
		}

		pPattern->OnNodeSelChanged( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDblClkPatternList

void CStyleDlg::OnDblClkPatternList() 
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pPattern = NULL;

	// Get the Pattern
	int nPos = m_lstbxPattern.GetCurSel();
	if( nPos != LB_ERR )
	{
		pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos ); 
	}

	if( pPattern )
	{
		theApp.m_pStyleComponent->m_pIFramework->OpenEditor( pPattern );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::PlayMotif

void CStyleDlg::PlayMotif( void ) 
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIDMPerformance != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pMotif = NULL;

	// Get the Motif
	int nPos = m_lstbxMotif.GetCurSel();
	if( nPos != LB_ERR )
	{
		pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos ); 
	}

	if( pMotif )
	{
		// Trigger Motif to play
		ASSERT( pMotif->m_pStyle != NULL );
		ASSERT( pMotif->m_pStyle->m_pIDMStyle != NULL );

		IDirectMusicSegmentState* pIDMSegmentState;
		MUSIC_TIME mtTimeNow;

		theApp.m_pStyleComponent->m_pIDMPerformance->GetTime( NULL, &mtTimeNow );
		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIDMPerformance->GetSegmentState( &pIDMSegmentState, mtTimeNow ) ) )
		{
			IDirectMusicSegment* pIDMSegmentMotif;

			BSTR bstrName = pMotif->m_strName.AllocSysString();

			if( m_pStyle->m_pIDMStyle->GetMotif( bstrName, &pIDMSegmentMotif ) == S_OK )
			{
				theApp.m_pStyleComponent->m_pIDMPerformance->PlaySegment( pIDMSegmentMotif,
																		 (DMUS_SEGF_SECONDARY | pMotif->m_dwResolution),
																		  0, NULL );
				RELEASE( pIDMSegmentMotif );
			}

			SysFreeString( bstrName );
			RELEASE( pIDMSegmentState );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSelChangeMotifList

void CStyleDlg::OnSelChangeMotifList() 
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pMotif = NULL;

	// Get the Motif
	int nPos = m_lstbxMotif.GetCurSel();
	if( nPos != LB_ERR )
	{
		pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos ); 
	}

	if( pMotif )
	{
		// Sync property sheet
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				pMotif->OnShowProperties();
			}

			RELEASE( pIPropSheet );
		}

		pMotif->OnNodeSelChanged( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDblClkMotifList

void CStyleDlg::OnDblClkMotifList() 
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pMotif = NULL;

	// Get the Motif
	int nPos = m_lstbxMotif.GetCurSel();
	if( nPos != LB_ERR )
	{
		pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos ); 
	}

	if( pMotif )
	{
		theApp.m_pStyleComponent->m_pIFramework->OpenEditor( pMotif );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSelChangeBandCombo

void CStyleDlg::OnSelChangeBandCombo() 
{
	ASSERT( m_pStyle != NULL );

	IDMUSProdNode* pINode = NULL;

	// Get the Band
	int nPos = m_cmbxBand.GetCurSel();
	if( nPos != CB_ERR )
	{
		pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
	}

	if( pINode )
	{
		// Set the Band "Default" control
		IDMUSProdBandEdit* pIBandEdit;
		BOOL fDefaultFlag = FALSE;

		if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdBandEdit, (void**)&pIBandEdit ) ) )
		{
			if( FAILED ( pIBandEdit->GetDefaultFlag( &fDefaultFlag ) ) )
			{
				fDefaultFlag = FALSE;
			}

			RELEASE( pIBandEdit );
		}
		m_checkBandDefault.SetCheck( fDefaultFlag );

		// Sync property sheet
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				IDMUSProdPropPageObject* pIPageObject;

				if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
				{
					pIPageObject->OnShowProperties();
					RELEASE( pIPageObject );
				}
			}

			RELEASE( pIPropSheet );
		}

		// Set the Style's active Band
		m_pStyle->SetActiveBand( pINode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnMeasureItem

void CStyleDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_PATTERN_LIST:
		case IDC_MOTIF_LIST:
		{
			ASSERT( m_pFont != NULL );

			TEXTMETRIC tm;
			CDC* pDC;

			pDC = GetDC();
			if( pDC )
			{
				CFont* pFontOld = pDC->SelectObject( m_pFont );
				pDC->GetTextMetrics( &tm );
				lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
				if( pFontOld )
				{
					pDC->SelectObject( pFontOld );
				}
				ReleaseDC( pDC );
				return;
			}
		}
	}
	
	CFormView::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnCompareItem

int CStyleDlg::OnCompareItem( int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern1 = (CDirectMusicPattern *)lpCompareItemStruct->itemData1;
			CDirectMusicPattern* pPattern2 = (CDirectMusicPattern *)lpCompareItemStruct->itemData2;

			// Place embellishments at the bottom of the list
			if( pPattern1->m_wEmbellishment == EMB_NORMAL
			&&  pPattern2->m_wEmbellishment != EMB_NORMAL )
			{
				return -1;
			}
			if( pPattern1->m_wEmbellishment != EMB_NORMAL
			&&  pPattern2->m_wEmbellishment == EMB_NORMAL )
			{
				return 1;
			}

			return pPattern1->m_strName.CompareNoCase( pPattern2->m_strName );
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif1 = (CDirectMusicPattern *)lpCompareItemStruct->itemData1;
			CDirectMusicPattern* pMotif2 = (CDirectMusicPattern *)lpCompareItemStruct->itemData2;

			return pMotif1->m_strName.CompareNoCase( pMotif2->m_strName );
		}
	}
	
	return CFormView::OnCompareItem( nIDCtl, lpCompareItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDrawItem

void CStyleDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_PATTERN_LIST:
		case IDC_MOTIF_LIST:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT 
            ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
				switch( nIDCtl )
				{
					case IDC_PATTERN_LIST:
					{
						DrawPatternItem( lpDrawItemStruct );
						if( ::GetFocus() == m_lstbxPattern.GetSafeHwnd() )
						{
							if( lpDrawItemStruct->itemAction & ODA_FOCUS )
							{
								InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
								pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
								InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
							}
						}
						break;
					}

					case IDC_MOTIF_LIST:
					{
						DrawMotifItem( lpDrawItemStruct );
						if( ::GetFocus() == m_lstbxMotif.GetSafeHwnd() )
						{
							if( lpDrawItemStruct->itemAction & ODA_FOCUS )
							{
								InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
								pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
								InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
							}
						}
						break;
					}
				}
			}

			return;
		}
	}
	
	CFormView::OnDrawItem( nIDCtl, lpDrawItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnUpdateEditCut

void CStyleDlg::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pStyle != NULL );

	// Initialize menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( pINode->CanCut() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( pPattern->CanCut() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( pMotif->CanCut() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnEditCut

void CStyleDlg::OnEditCut() 
{
	ASSERT( m_pStyle != NULL );

	// Handle menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		IDataObject* pIDataObject;
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( pINode->CanCut() == S_OK )
					{
						if( SUCCEEDED ( pINode->CreateDataObject( &pIDataObject ) ) )
						{
							if( theApp.PutDataInClipboard( pIDataObject, pINode ) )
							{
								pINode->DeleteNode( FALSE );
								m_cmbxBand.SetFocus();
							}

							RELEASE( pIDataObject );
						}
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( pPattern->CanCut() == S_OK )
					{
						if( SUCCEEDED ( pPattern->CreateDataObject( &pIDataObject ) ) )
						{
							if( theApp.PutDataInClipboard( pIDataObject, pPattern ) )
							{
								pPattern->DeleteNode( FALSE );
								m_lstbxPattern.SetFocus();
							}

							RELEASE( pIDataObject );
						}
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( pMotif->CanCut() == S_OK )
					{
						if( SUCCEEDED ( pMotif->CreateDataObject( &pIDataObject ) ) )
						{
							if( theApp.PutDataInClipboard( pIDataObject, pMotif ) )
							{
								pMotif->DeleteNode( FALSE );
								m_lstbxMotif.SetFocus();
							}

							RELEASE( pIDataObject );
						}
					}
				}
			}
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnUpdateEditCopy

void CStyleDlg::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pStyle != NULL );

	// Initialize menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( pINode->CanCopy() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( pPattern->CanCopy() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( pMotif->CanCopy() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnEditCopy

void CStyleDlg::OnEditCopy() 
{
	ASSERT( m_pStyle != NULL );

	// Handle menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		IDataObject* pIDataObject;
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( pINode->CanCopy() == S_OK )
					{
						if( SUCCEEDED ( pINode->CreateDataObject( &pIDataObject ) ) )
						{
							theApp.PutDataInClipboard( pIDataObject, pINode );

							RELEASE( pIDataObject );
						}
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( pPattern->CanCopy() == S_OK )
					{
						if( SUCCEEDED ( pPattern->CreateDataObject( &pIDataObject ) ) )
						{
							theApp.PutDataInClipboard( pIDataObject, pPattern );

							RELEASE( pIDataObject );
						}
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( pMotif->CanCopy() == S_OK )
					{
						if( SUCCEEDED ( pMotif->CreateDataObject( &pIDataObject ) ) )
						{
							theApp.PutDataInClipboard( pIDataObject, pMotif );

							RELEASE( pIDataObject );
						}
					}
				}
			}
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnUpdateEditPaste

void CStyleDlg::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pStyle != NULL );

	IDataObject* pIDataObject;

	// Get the IDataObject
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		// Determine if Style can paste this object
		BOOL fWillSetReference;
		HRESULT hr = m_pStyle->CanPasteFromData( pIDataObject, &fWillSetReference );
		
		RELEASE( pIDataObject );
		
		if( hr == S_OK )
		{
			pCmdUI->Enable( TRUE );
			return;
		}
	}
	
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnEditPaste

void CStyleDlg::OnEditPaste() 
{
	ASSERT( m_pStyle != NULL );

	IDataObject* pIDataObject;

	// Get the IDataObject
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		// Determine if Style can paste this object
		m_pStyle->PasteFromData( pIDataObject );
		
		RELEASE( pIDataObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnUpdateEditInsert

void CStyleDlg::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pStyle != NULL );

	// Initialize menu item based on "Edit Menu" control
	if( m_nEditMenuCtrlID )
	{
		pCmdUI->Enable( TRUE );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnEditInsert

void CStyleDlg::OnEditInsert() 
{
	ASSERT( m_pStyle != NULL );

	// Handle menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		case IDC_BAND_COMBO:
			m_pStyle->m_StyleBands.InsertChildNode( NULL );
			m_cmbxBand.SetFocus();
			break;

		case IDC_PATTERN_LIST:
			m_pStyle->m_StylePatterns.InsertChildNode( NULL );
			m_lstbxPattern.SetFocus();
			break;

		case IDC_MOTIF_LIST:
			m_pStyle->m_StyleMotifs.InsertChildNode( NULL );
			m_lstbxMotif.SetFocus();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnUpdateEditDelete

void CStyleDlg::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pStyle != NULL );

	// Initialize menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( pINode->CanDelete() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( pPattern->CanDelete() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( pMotif->CanDelete() == S_OK )
					{
						pCmdUI->Enable( TRUE );
						return;
					}
				}
			}
			break;
		}
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnEditDelete

void CStyleDlg::OnEditDelete() 
{
	ASSERT( m_pStyle != NULL );

	// Handle menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( pINode->CanDelete() == S_OK )
					{
						pINode->DeleteNode( TRUE );
						m_cmbxBand.SetFocus();
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( pPattern->CanDelete() == S_OK )
					{
						pPattern->DeleteNode( TRUE );
						m_lstbxPattern.SetFocus();
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( pMotif->CanDelete() == S_OK )
					{
						pMotif->DeleteNode( TRUE );
						m_lstbxMotif.SetFocus();
					}
				}
			}
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnViewProperties

BOOL CStyleDlg::OnViewProperties( void )
{
	IDMUSProdPropSheet* pIPropSheet;

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( FAILED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return FALSE;
	}

	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return TRUE;
	}

	BOOL fSuccess = FALSE;

	// Handle menu item based on "Edit Menu" control
	switch( m_nEditMenuCtrlID )
	{
		int nPos;

		case IDC_BAND_COMBO:
		{
			IDMUSProdNode* pINode;

			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					IDMUSProdPropPageObject* pIPageObject;

					if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
					{
						if( SUCCEEDED ( pIPageObject->OnShowProperties() ) )
						{
							fSuccess = TRUE;
						}
						RELEASE( pIPageObject );
					}
				}
			}
			break;
		}

		case IDC_PATTERN_LIST:
		{
			CDirectMusicPattern* pPattern;

			nPos = m_lstbxPattern.GetCurSel();
			if( nPos != LB_ERR )
			{
				pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos );
				if( pPattern )
				{
					if( SUCCEEDED ( pPattern->OnShowProperties() ) )
					{
						fSuccess = TRUE;
					}
				}
			}
			break;
		}

		case IDC_MOTIF_LIST:
		{
			CDirectMusicPattern* pMotif;

			nPos = m_lstbxMotif.GetCurSel();
			if( nPos != LB_ERR )
			{
				pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos );
				if( pMotif )
				{
					if( SUCCEEDED ( pMotif->OnShowProperties() ) )
					{
						fSuccess = TRUE;
					}
				}
			}
			break;
		}

		default:
			if( SUCCEEDED ( m_pStyle->OnShowProperties() ) )
			{
				fSuccess = TRUE;
			}
			break;
	}

	RELEASE( pIPropSheet );

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnBandDefault

void CStyleDlg::OnBandDefault() 
{
	ASSERT( m_pStyle != NULL );
	
	BOOL fDefaultFlag = m_checkBandDefault.GetCheck();
	if( fDefaultFlag == 0 )
	{
		// Cannot uncheck the default Band!!!
		m_checkBandDefault.SetCheck( 1 );
		return;
	}

	// Get the Band
	int nPos = m_cmbxBand.GetCurSel();
	if( nPos != CB_ERR )
	{
		IDMUSProdNode* pIBandNode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
		if( pIBandNode )
		{
			// Set the Style's default Band
			m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_DEFAULT_BAND );
			m_pStyle->SetDefaultBand( pIBandNode, FALSE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnDblClkBandDefault

void CStyleDlg::OnDblClkBandDefault() 
{
	// Throw it away
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSetFocusBandCombo

void CStyleDlg::OnSetFocusBandCombo() 
{
	m_nEditMenuCtrlID = IDC_BAND_COMBO;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnKillFocusBandCombo

void CStyleDlg::OnKillFocusBandCombo() 
{
	if( m_nEditMenuCtrlID == IDC_BAND_COMBO )
	{
		// Get the control that stole the focus
		CWnd* pWnd = CWnd::GetFocus();

		if( pWnd == NULL
		||  pWnd->GetParent() == NULL )
		{
			return;
		}

		m_nEditMenuCtrlID = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSetFocusPatternList

void CStyleDlg::OnSetFocusPatternList() 
{
	m_nEditMenuCtrlID = IDC_PATTERN_LIST;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnKillFocusPatternList

void CStyleDlg::OnKillFocusPatternList() 
{
	if( m_nEditMenuCtrlID == IDC_PATTERN_LIST )
	{
		// Get the control that stole the focus
		CWnd* pWnd = CWnd::GetFocus();

		if( pWnd == NULL
		||  pWnd->GetParent() == NULL )
		{
			return;
		}

		m_nEditMenuCtrlID = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnSetFocusMotifList

void CStyleDlg::OnSetFocusMotifList() 
{
	m_nEditMenuCtrlID = IDC_MOTIF_LIST;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnKillFocusMotifList

void CStyleDlg::OnKillFocusMotifList() 
{
	if( m_nEditMenuCtrlID == IDC_MOTIF_LIST )
	{
		// Get the control that stole the focus
		CWnd* pWnd = CWnd::GetFocus();

		if( pWnd == NULL
		||  pWnd->GetParent() == NULL )
		{
			return;
		}

		m_nEditMenuCtrlID = 0;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnContextMenu

void CStyleDlg::OnContextMenu( CWnd* pWnd, CPoint point ) 
{
	ASSERT( pWnd != NULL );
	ASSERT( m_pStyle != NULL );

	switch( pWnd->GetDlgCtrlID() )
	{
		HINSTANCE hInstance;
		UINT nResourceId;
		HMENU hMenu;
		HMENU hMenuPopup;
		BOOL fOutside;
		int nPos;

		case IDC_BAND_COMBO:
			nPos = m_cmbxBand.GetCurSel();
			if( nPos != CB_ERR )
			{
				m_cmbxBand.SetFocus(); 

				IDMUSProdNode* pINode = (IDMUSProdNode *)m_cmbxBand.GetItemDataPtr( nPos ); 
				if( pINode )
				{
					if( SUCCEEDED ( pINode->GetRightClickMenuId(&hInstance, &nResourceId) ) )
					{
						hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );
						if( hMenu )
						{
							hMenuPopup = ::GetSubMenu( hMenu, 0 );
							pINode->OnRightClickMenuInit( hMenuPopup );

							m_pINodeRightMenu = pINode;
							::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
											  point.x, point.y, 0, GetSafeHwnd(), NULL );

							DestroyMenu( hMenu );
						}
					}
				}
			}
			break;
			 
		case IDC_PATTERN_LIST:
		{
			CPoint ptLstBx( point );

			m_lstbxPattern.ScreenToClient( &ptLstBx );
			nPos = m_lstbxPattern.ItemFromPoint( ptLstBx, fOutside );
			if( fOutside == FALSE
			&&  nPos != LB_ERR )
			{
				m_lstbxPattern.SetCurSel( nPos ); 
				m_lstbxPattern.SetFocus(); 

				CDirectMusicPattern* pPattern = (CDirectMusicPattern *)m_lstbxPattern.GetItemData( nPos ); 
				if( pPattern )
				{
					if( SUCCEEDED ( pPattern->GetRightClickMenuId(&hInstance, &nResourceId) ) )
					{
						hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );
						if( hMenu )
						{
							hMenuPopup = ::GetSubMenu( hMenu, 0 );
							pPattern->OnRightClickMenuInit( hMenuPopup );

							m_pINodeRightMenu = pPattern;
							::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
											  point.x, point.y, 0, GetSafeHwnd(), NULL );

							DestroyMenu( hMenu );
						}
					}
				}
			}
			break;
		}
			 
		case IDC_MOTIF_LIST:
		{
			CPoint ptLstBx( point );

			m_lstbxMotif.ScreenToClient( &ptLstBx );
			nPos = m_lstbxMotif.ItemFromPoint( ptLstBx, fOutside );
			if( fOutside == FALSE
			&&  nPos != LB_ERR )
			{
				m_lstbxMotif.SetCurSel( nPos ); 
				m_lstbxMotif.SetFocus(); 

				CDirectMusicPattern* pMotif = (CDirectMusicPattern *)m_lstbxMotif.GetItemData( nPos ); 
				if( pMotif )
				{
					if( SUCCEEDED ( pMotif->GetRightClickMenuId(&hInstance, &nResourceId) ) )
					{
						hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );
						if( hMenu )
						{
							hMenuPopup = ::GetSubMenu( hMenu, 0 );
							pMotif->OnRightClickMenuInit( hMenuPopup );

							m_pINodeRightMenu = pMotif;
							::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
											  point.x, point.y, 0, GetSafeHwnd(), NULL );

							DestroyMenu( hMenu );
						}
					}
				}
			}
			break;
		}

		default:
			if( SUCCEEDED ( m_pStyle->GetRightClickMenuId(&hInstance, &nResourceId) ) )
			{
				hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );
				if( hMenu )
				{
					hMenuPopup = ::GetSubMenu( hMenu, 0 );
					m_pStyle->OnRightClickMenuInit( hMenuPopup );

					m_pINodeRightMenu = m_pStyle;
					::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
									  point.x, point.y, 0, GetSafeHwnd(), NULL );

					DestroyMenu( hMenu );
				}
			}
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnCommand

BOOL CStyleDlg::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	if( HIWORD(wParam) == 0 )	// menu command
	{
		if( m_pINodeRightMenu )	// can receive menu commands when m_pINodeRightMenu is NULL
		{
			m_pINodeRightMenu->OnRightClickMenuSelect( LOWORD(wParam) );
			m_pINodeRightMenu = NULL ;
			return TRUE;
		}
	}
	
	return CFormView::OnCommand( wParam, lParam );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnMouseMove

void CStyleDlg::OnMouseMove( UINT nFlags, CPoint point ) 
{
	CFormView::OnMouseMove( nFlags, point );
	
	if( CWnd::GetCapture() == this )
	{
		if( m_dwMouseDownButton != 0 )
		{
			// See if user is moving the mouse
			if( m_rectMouseDown.PtInRect( point ) == FALSE )
			{
				// Start drag drop
				DoDrag( m_pIMouseDownNode, m_dwMouseDownButton ); 
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnCaptureChanged

void CStyleDlg::OnCaptureChanged( CWnd *pWnd ) 
{
	if( pWnd == this )
	{
		return;
	}
	
	m_dwMouseDownButton = 0;
	m_pIMouseDownNode = NULL;
	m_rectMouseDown.SetRectEmpty();

	CFormView::OnCaptureChanged( pWnd );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnLButtonDown

void CStyleDlg::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyle != NULL );

	if( m_dwMouseDownButton == 0 )
	{
		// Sync property sheet
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				m_pStyle->OnShowProperties();
			}

			RELEASE( pIPropSheet );
		}

		// First set capture
		SetCapture();

		// Now store fields used when drag drop is initiated
		m_dwMouseDownButton = MK_LBUTTON;
		m_pIMouseDownNode = m_pStyle;

		m_rectMouseDown.left = point.x - 5;
		m_rectMouseDown.top = point.y - 5;
		m_rectMouseDown.right = point.x + 5;
		m_rectMouseDown.bottom = point.y + 5;
	}

	CFormView::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnLButtonUp

void CStyleDlg::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	if( m_dwMouseDownButton == MK_LBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}
	
	CFormView::OnLButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnRButtonDown

void CStyleDlg::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pStyle != NULL );

	if( m_dwMouseDownButton == 0 )
	{
		// Sync property sheet
		IDMUSProdPropSheet* pIPropSheet;

		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
			{
				m_pStyle->OnShowProperties();
			}

			RELEASE( pIPropSheet );
		}

		// First set capture
		SetCapture();

		// Now store fields used when drag drop is initiated
		m_dwMouseDownButton = MK_RBUTTON;
		m_pIMouseDownNode = m_pStyle;

		m_rectMouseDown.left = point.x - 5;
		m_rectMouseDown.top = point.y - 5;
		m_rectMouseDown.right = point.x + 5;
		m_rectMouseDown.bottom = point.y + 5;
	}

	CFormView::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::OnRButtonUp

void CStyleDlg::OnRButtonUp( UINT nFlags, CPoint point ) 
{
	if( m_dwMouseDownButton == MK_RBUTTON )
	{
		if( CWnd::GetCapture() == this )
		{
			::ReleaseCapture();
		}
	}

	CFormView::OnRButtonUp( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg::HandleKeyDown

BOOL CStyleDlg::HandleKeyDown( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_DELETE:
					if( m_nEditMenuCtrlID )
					{
						OnEditDelete();
						return TRUE;
					}
					break;

				case VK_INSERT:
					if( m_nEditMenuCtrlID )
					{
						OnEditInsert();
						return TRUE;
					}
					break;

				case 0x43:  // VK_C		(Copy)
					if( m_nEditMenuCtrlID )
					{
						if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
						{
							OnEditCopy();
							return TRUE;
						}
					}
					break;

				case 0x56:	// VK_V		(Paste)
					if( m_nEditMenuCtrlID )
					{
						if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
						{
							OnEditPaste();
							return TRUE;
						}
					}
					break;

				case 0x58:	// VK_X		(Cut)
					if( m_nEditMenuCtrlID )
					{
						if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
						{
							OnEditCut();
							return TRUE;
						}
					}
					break;

				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_TEMPO: 
								SetTempoControlText();
								return TRUE;
						}
					}
					break;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_TEMPO:
								::SetFocus( NULL );
								pWnd->SetFocus();
								return TRUE;

							case IDC_TIME_SIGNATURE:
								if( m_btnTimeSignature.GetButtonStyle() & BS_DEFPUSHBUTTON )
								{
									OnTimeSignature();
									return TRUE;
								}
								break;

							case IDC_PATTERN_LIST:
								OnDblClkPatternList();
								return TRUE;

							case IDC_MOTIF_LIST:
								OnDblClkMotifList();
								return TRUE;
						}
					}
					break;
				}
			}
			break;
	}
	
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleCtl.h ===
#if !defined(STYLECTL_H__3BD2BA23_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define STYLECTL_H__3BD2BA23_46E7_11D0_89AC_00A0C9054129__INCLUDED_

// StyleCtl.h : Declaration of the CStyleCtrl ActiveX Control class.

#include "StyleDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CStyleCtrl : See StyleCtl.cpp for implementation.

class CStyleCtrl : public COleControl
{
	DECLARE_DYNCREATE(CStyleCtrl)

// Constructor
public:
	CStyleCtrl();

// Attributes
public:
	CStyleDlg*			m_pStyleDlg;

private:
	HWND				m_hWndContainer;
	HMENU				m_hMenuInPlace;
	CToolBar*			m_pToolBar;
	CDirectMusicStyle*	m_pStyle;

private:
	LRESULT OnSyncStyleEditor( WPARAM wParam, LPARAM lParam );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStyleCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CStyleCtrl();

	DECLARE_OLECREATE_EX(CStyleCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CStyleCtrl)      // GetTypeInfo
	DECLARE_OLECTLTYPE(CStyleCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CStyleCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditInsert();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditRedo();
	afx_msg void OnHelpFinder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CStyleCtrl)
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CStyleCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CStyleCtrl)
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(STYLECTL_H__3BD2BA23_46E7_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleDesignerDLL.cpp ===
// StyleDesignerDLL.cpp : Implementation of CStyleDesignerApp and DLL registration.

#include "stdafx.h"

#include <initguid.h>
#include "StyleDesignerDLL.h"
#include "StyleComponent.h"
#include <PChannelName.h>
#include <SegmentGUIDS.h>
#include <ioDMStyle.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CStyleDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x3bd2ba02, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const UINT g_nGridsPerBeatBitmaps[MAX_GRIDS_PER_BEAT_ENTRIES] =
	{ 
	  IDB_GPB1,     IDB_GPB2,     IDB_GPB3,     IDB_GPB4,     IDB_GPB5,		// Beat = quarter note
	  IDB_GPB6,     IDB_GPB7,     IDB_GPB8,     IDB_GPB9,     IDB_GPBa10,
	  IDB_GPBa11,   IDB_GPBa12,   IDB_GPBa13,   IDB_GPBa14,   IDB_GPBa15,
	  IDB_GPBa16,   IDB_GPBa17,   IDB_GPBa18,   IDB_GPBa19,   IDB_GPBb20,
	  IDB_GPBb21,   IDB_GPBb22,   IDB_GPBb23,   IDB_GPBb24,
	  IDB_GPB1_ALT, IDB_GPB2_ALT, IDB_GPB3_ALT, IDB_GPB4_ALT, IDB_GPB5,		// Beat != quarter note
	  IDB_GPB6_ALT, IDB_GPB7,     IDB_GPB8_ALT, IDB_GPB9,     IDB_GPBa10,
	  IDB_GPBa11,   IDB_GPBa12,   IDB_GPBa13,   IDB_GPBa14,   IDB_GPBa15,
	  IDB_GPBa16,   IDB_GPBa17,   IDB_GPBa18,   IDB_GPBa19,   IDB_GPBb20,
	  IDB_GPBb21,   IDB_GPBb22,   IDB_GPBb23,   IDB_GPBb24
	};


////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::InitInstance - DLL initialization

BOOL CStyleDesignerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	m_pIPageManager = NULL;
	m_pStyleComponent = NULL;

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::ExitInstance - DLL termination

int CStyleDesignerApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::GetHelpFileName

BOOL CStyleDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::SetNodePointers  (used by all components)

void CStyleDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::PutDataInClipboard

BOOL CStyleDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			RELEASE( m_pIClipboardDataObject );

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::FlushClipboard

void CStyleDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		RELEASE( m_pIClipboardDataObject );

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp::GetFileVersion  (used by all components)

BOOL CStyleDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    TCHAR    szContainerPath[MAX_BUFFER];
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	
// Register Style Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_StyleEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_STYLE_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_PatternEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_STYLE_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_VarChoicesEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_STYLE_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_StyleComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_STYLE_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_StyleNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_StyleRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_StyleComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicStyle, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_STYLE_OBJECT_TEXT );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
    TCHAR    szGuid[MID_BUFFER];
    TCHAR    szComponentPath[MAX_BUFFER];
    TCHAR    szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
    
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister Style Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_StyleEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_PatternEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_VarChoicesEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_StyleComponent, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_StyleNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp(); 
        }
        else
        {
			AfxOleUnlockApp(); 
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CStyleComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_StyleComponent) )
	{
        pfunc = CStyleComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_StyleEditor)
		 ||  IsEqualCLSID(rclsid, CLSID_PatternEditor)
		 ||  IsEqualCLSID(rclsid, CLSID_VarChoicesEditor) )
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleDlg.h ===
#ifndef __STYLEDLG_H__
#define __STYLEDLG_H__

// StyleDlg.h : header file
//

#include "Splitter.h"

/////////////////////////////////////////////////////////////////////////////
// CStyleDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#define SSE_STYLE		1
#define SSE_BANDS		2
#define SSE_PATTERNS	4
#define SSE_MOTIFS		8
#define SSE_ALL			0xFFFFFFFF

class CStyleCtrl;


/////////////////////////////////////////////////////////////////////////////
// CStyleComboBox window

class CStyleComboBox : public CComboBox
{
// Construction
public:
	CStyleComboBox();

// Attributes
public:
	CStyleDlg*	m_pStyleDlg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStyleComboBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStyleComboBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CStyleComboBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CStyleListBox window

class CStyleListBox : public CListBox
{
// Construction
public:
	CStyleListBox();

// Attributes
public:
	CStyleDlg*	m_pStyleDlg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStyleListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStyleListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CStyleListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CStyleDlg window

class CStyleDlg : public CFormView, public IDropSource, public IDropTarget
{
friend class CStyleListBox;
friend class CStyleComboBox;

public:
	CStyleDlg();
	virtual ~CStyleDlg();

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDropSource methods
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

	// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

	// Additional methods
protected:
	void SetTempoControlText();
	void SetTimeSignatureBitmap();
	void FillPatternListBox();
	void FillMotifListBox();
	void FillBandComboBox();
	void DrawPatternItem( LPDRAWITEMSTRUCT lpDrawItemStruct );
	void DrawMotifItem( LPDRAWITEMSTRUCT lpDrawItemStruct );
	void PlayMotif();
	int GetTopBorder();

public:
	void DoDrag( IDMUSProdNode* pINode, DWORD dwStartDragButton ); 
	BOOL HandleKeyDown( MSG* pMsg );
	void OnUpdateEditCut( CCmdUI* pCmdUI );
	void OnEditCut();
	void OnUpdateEditCopy( CCmdUI* pCmdUI );
	void OnEditCopy();
	void OnUpdateEditPaste( CCmdUI* pCmdUI );
	void OnEditPaste();
	void OnUpdateEditInsert( CCmdUI* pCmdUI );
	void OnEditInsert();
	void OnUpdateEditDelete( CCmdUI* pCmdUI );
	void OnEditDelete();
	BOOL OnViewProperties();
	void RefreshControls( DWORD dwFlags );
	void EnableTimer( BOOL fEnable );
	void EndTrack( int nHeight );
	void SelectPattern( CDirectMusicPattern* pPattern );
	void SelectMotif( CDirectMusicPattern* pMotif );
	void SelectBand( IDMUSProdNode* pINode );

protected:
	DECLARE_DYNCREATE(CStyleDlg)

// Form Data
public:
	//{{AFX_DATA(CStyleDlg)
	enum { IDD = IDD_DLG_STYLE };
	CStatic	m_staticSeparator;
	CButton	m_btnTimeSignature;
	CSpinButtonCtrl	m_spinTempo;
	CEdit	m_editTempo;
	CButton	m_checkBandDefault;
	CListBox	m_PatternList;
	//}}AFX_DATA

// Member variables
private:
	DWORD			m_dwRef;
	IDataObject*	m_pIDataObject;			// Object being dragged	
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	IDMUSProdNode*	m_pIDragNode;			// Node being dragged
	IDMUSProdNode*	m_pINodeRightMenu;		// Recipient of right menu command id
	int				m_nEditMenuCtrlID;		// Last "list" control to have the focus
	short			m_nTimerID;				// Used to display transport cursor

	DWORD			m_dwMouseDownButton;	// MK_RBUTTON or MK_LBUTTON
	IDMUSProdNode*		m_pIMouseDownNode;		// Object under cursor when mouse button pressed
	CRect			m_rectMouseDown;		// If user moves out of this rect start drag-drop

	CStyleComboBox	m_cmbxBand;				// Subclasses Band combo box
	CStyleListBox	m_lstbxPattern;			// Subclasses Pattern list box
	CStyleListBox	m_lstbxMotif;			// Subclasses Motif list box

	CSplitter		m_wndSplitter;
	CFont*			m_pFont;

public:
	CStyleCtrl*			m_pStyleCtrl;
	CDirectMusicStyle*	m_pStyle;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStyleDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CStyleDlg)
	afx_msg void OnDragRMenuMove();
	afx_msg void OnDragRMenuCopy();
	afx_msg void OnDragRMenuCancel();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKillFocusTempo();
	afx_msg void OnDeltaPosTempoSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimeSignature();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnDblClkPatternList();
	afx_msg void OnDblClkMotifList();
	afx_msg void OnSelChangeMotifList();
	afx_msg void OnSelChangePatternList();
	afx_msg void OnSelChangeBandCombo();
	afx_msg void OnSetFocusBandCombo();
	afx_msg void OnKillFocusBandCombo();
	afx_msg void OnSetFocusPatternList();
	afx_msg void OnKillFocusPatternList();
	afx_msg void OnSetFocusMotifList();
	afx_msg void OnKillFocusMotifList();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg void OnBandDefault();
	afx_msg void OnDblClkBandDefault();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __STYLEDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleEditorGuids.c ===
// StyleEditorGuids.c : Contains GUIDs not found in MIDL generated StyleEditor_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */

const GUID CLSID_StyleComponent = {0x44207721,0x487B,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}};

const GUID GUID_SinglePattern = {0x10521900,0x4549,0x11d1,{0x89,0xae,0x00,0xa0,0xc9,0x05,0x41,0x29}};

const GUID GUID_MotifNode = {0xFAE21E41,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};  
const GUID GUID_PatternNode = {0xFAE21E43,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};  
const GUID GUID_StyleNode = {0xFAE21E45,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};  
const GUID GUID_VarChoicesNode = {0x9409E740,0x86B3,0x11D1,{0x89,0xAF,0x00,0xA0,0xC9,0x05,0x41,0x29}}; 
const GUID GUID_StyleBandFolderNode = {0xFAE21E47,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};  
const GUID GUID_StyleMotifFolderNode = {0xFAE21E48,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};  
const GUID GUID_StylePatternFolderNode = {0xFAE21E49,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};  

const GUID GUID_StyleRefNode = {0x408FBB21,0xB009,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}};   

const GUID GUID_ChordStripChanged = {0xb2597270,0x1a0a,0x11d3,{0xb4,0x47,0x00,0x10,0x5a,0x27,0x96,0xde}};  

const GUID STYLE_NameChange = {0x666ce421,0x3034,0x11d1,{0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29}};
const GUID STYLE_TimeSigChange = {0x666ce422,0x3034,0x11d1,{0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29}};
const GUID STYLE_TempoChange = {0x666ce423,0x3034,0x11d1,{0x89,0xae,0x0,0xa0,0xc9,0x5,0x41,0x29}};
const GUID STYLE_NotationTypeChange = {0x5f6e7492,0xed3f,0x11d2,{0xa6,0xe6,0x0,0x10,0x5a,0x26,0x62,0xb}};
const GUID STYLE_PatternWindowClose = {0x8e8c33a2,0xf774,0x11d2,{0xa6,0xeb,0x0,0x10,0x5a,0x26,0x62,0xb}};
const GUID STYLE_PChannelChange = {0x593f7830,0x3b14,0x11d3,{0xb4,0x4e,0x0,0x10,0x5a,0x27,0x96,0xde}};

const GUID STYLE_MotifNameChange = {0x6a87ab75,0xd696,0x4bbd,{0x92,0x15,0xf9,0x54,0x83,0x94,0x8a,0x56}};
const GUID STYLE_MotifChanged = {0x6a87ab76,0xd696,0x4bbd,{0x92,0x15,0xf9,0x54,0x83,0x94,0x8a,0x56}};
const GUID STYLE_MotifDeleted = {0x6a87ab77,0xd696,0x4bbd,{0x92,0x15,0xf9,0x54,0x83,0x94,0x8a,0x56}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleDocType.cpp ===
// StyleDocType.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType constructor/destructor

CStyleDocType::CStyleDocType()
{
    m_dwRef = 0;
}

CStyleDocType::~CStyleDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType IUnknown implementation

HRESULT CStyleDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStyleDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CStyleDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::GetResourceId

HRESULT CStyleDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_STYLE_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::DoesExtensionMatch

HRESULT CStyleDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_STYLE_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::DoesIdMatch

HRESULT CStyleDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_StyleNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::AllocNode

HRESULT STDMETHODCALLTYPE CStyleDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_StyleNode) )
	{
		// Create a new Style 
		CDirectMusicStyle* pStyle = new CDirectMusicStyle;
		if( pStyle == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		// Initialize Style
		HRESULT hr = pStyle->Initialize();
		if( FAILED ( hr ) )
		{
			RELEASE( pStyle );
			return hr;
		}

		*ppINode = (IDMUSProdNode *)pStyle;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType:::OnFileNew

HRESULT CStyleDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
								  IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIStyleNode;

	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Style 
	hr = AllocNode( GUID_StyleNode, &pIStyleNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIStyleNode, pIStyleNode, NULL );

		// Add node to Project Tree
		if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pIStyleNode, NULL) ) )
		{
			CDirectMusicStyle* pStyle = (CDirectMusicStyle *)pIStyleNode;

			// Store the Style's Project
			pStyle->m_pIProject = pITargetProject;
//			pStyle->m_pIProject->AddRef();			intentionally missing

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pIStyleNode->GetNodeName( &bstrName ) ) )
			{
				pStyle->m_strOrigFileName = bstrName;
				pStyle->m_strOrigFileName += _T(".stp");
				::SysFreeString( bstrName );
			}

			// Add Style to Style component list 
			theApp.m_pStyleComponent->AddToStyleFileList( pStyle );

			// Advise the ConnectionPoint for this CDirectMusicStyle
			// Register CDirectMusicStyle with the Transport.
			pStyle->RegisterWithTransport();

			*ppIDocRootNode = pIStyleNode;
			pStyle->SetModified( TRUE );

			hr = S_OK;
		}
		else
		{
			RELEASE( pIStyleNode );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::OnFileOpen

HRESULT CStyleDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
								   IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;
	CDirectMusicStyle* pStyle;
	CString strFileName;
	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Style 
	pStyle = new CDirectMusicStyle;
	if( pStyle == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	theApp.m_pStyleComponent->m_nNextStyle--;

	if( pStyle->CreateUndoMgr() == FALSE )
	{
		RELEASE( pStyle );
		return E_OUTOFMEMORY;
	}

	// Store the Style's Project
	pStyle->m_pIProject = pITargetProject;
//	pStyle->m_pIProject->AddRef();			intentionally missing

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pStyle->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pStyle->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pStyle->m_strOrigFileName = pStyle->m_strOrigFileName.Right( pStyle->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the Style file
	hr = pStyle->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		RELEASE( pStyle );
		return hr;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pStyle, pStyle, NULL );

	// Add node to Project Tree
	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pStyle, NULL) ) )
	{
		pStyle->SetModified( FALSE );

		// Add Style to Style component list 
		theApp.m_pStyleComponent->AddToStyleFileList( pStyle );

		// Advise the ConnectionPoint for this CDirectMusicStyle
		// Register CDirectMusicStyle with the Transport.
		pStyle->RegisterWithTransport();

		*ppIDocRootNode = pStyle;

		hr = S_OK;
	}
	else
	{
		RELEASE( pStyle );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::OnFileSave

HRESULT CStyleDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::GetListInfo

HRESULT CStyleDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidStyle;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidStyle, 0, sizeof(GUID) );

	DWORD dwPos = StreamTell( pIStream );

	BOOL fFoundFormat = FALSE;

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_STYLE_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;

			// Get Style descriptor
			ck.ckid = DMUS_FOURCC_STYLE_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				DMUS_IO_STYLE dmusStyleIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_STYLE ) );
				if( SUCCEEDED ( pIStream->Read( &dmusStyleIO, dwSize, &dwByteCount ) )
				&&  dwByteCount == dwSize )
				{
					strDescriptor.Format( "%d/%d", dmusStyleIO.timeSig.bBeatsPerMeasure,
										  dmusStyleIO.timeSig.bBeat );
					if( !(dmusStyleIO.timeSig.wGridsPerBeat % 3) )
					{
						strDescriptor += _T("  3");
					}
				}
			}

			// Get Style GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidStyle, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidStyle, 0, sizeof(GUID) );
				}
			}

			// Get Style name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				DWORD dwPosName = StreamTell( pIStream );
			
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
				else
				{
				    StreamSeek( pIStream, dwPosName, STREAM_SEEK_SET );

					ck.ckid = RIFFINFO_INAM;
					if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
					{
						ReadMBSfromWCS( pIStream, ck.cksize, &strName );
					}
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	// Check for IMA 2.5 format
	if( fFoundFormat == FALSE )
	{
	    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = FOURCC_STYLE_FORM;

			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				fFoundFormat = TRUE;

				ck.ckid = FOURCC_STYLE;

				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ioStyle iStyle;

					dwSize = min( ck.cksize, sizeof( iStyle ) );

					if( SUCCEEDED ( pIStream->Read( &iStyle, dwSize, &dwByteCount ) )
					&&  dwByteCount == dwSize )
					{
						// Get Style name
						strName = iStyle.wstrName;
						
						// Get Style descriptor
						WORD wGridsPerBeat = iStyle.wClocksPerBeat / iStyle.wClocksPerClick;
						strDescriptor.Format( "%d/%d", iStyle.wBPM, iStyle.wBeat );
						if( !(wGridsPerBeat % 3) )
						{
							strDescriptor += _T("  3");
						}

						// Get Style GUID
						memcpy( &guidStyle, &iStyle.guid, sizeof(GUID) );
					}
				}
			}

			RELEASE( pIRiffStream );
		}
	}

	if( !strName.IsEmpty()
	&&  !strDescriptor.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidStyle, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::IsFileTypeExtension

HRESULT CStyleDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".stp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".sty") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::GetObjectDescriptorFromNode

HRESULT CStyleDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Style Node
	CDirectMusicStyle* pStyle;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_StyleNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pStyle = (CDirectMusicStyle *)pIDocRootNode;

	return pStyle->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::GetObjectRiffId

HRESULT CStyleDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Style Node
	if( IsEqualGUID ( guidNodeId, GUID_StyleNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_STYLE_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleDocType::GetObjectExt

HRESULT CStyleDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Style Node
	if( IsEqualGUID ( guidNodeId, GUID_StyleNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".stp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".sty";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleDesignerDLL.h ===
#if !defined(STYLEDESIGNER_H__3BD2BA1B_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define STYLEDESIGNER_H__3BD2BA1B_46E7_11D0_89AC_00A0C9054129__INCLUDED_

// StyleDesignerDLL.h : main header file for STYLEDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"		// main symbols
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicc.h>
#include <dmusici.h>
#pragma warning( pop )
#include "DMUSProd.h"
#include "StyleDesigner.h"
#include "BandEditor.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "StyleRiffId.h"	// Style file RIFF chunk id's
#include "DllJazzDataObject.h"
#include "DllBasePropPageManager.h"
#include "JazzUndoMan.h"


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define CF_VARCHOICES "DMUSProd v.1 VarChoices"
#define CF_BANDTRACK "DMUSProd v.1 Band Track"

#define WM_OPEN_VARCHOICES	(WM_USER + 0xE0)
#define WM_SYNC_STYLEEDITOR (WM_USER + 0xE1)

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256
#define TOOLBAR_HEIGHT	30
#define WM_MYPROPVERB	WM_USER+1267 

#define PPQN            192				// IMA pulses per quarter note
#define PPQNx4          ( PPQN << 2 )
#define PPQN_2          ( PPQN >> 1 )

#define DM_PPQN         768				// Direct Music pulses per quarter note
#define DM_PPQNx4       ( DM_PPQN << 2 )
#define DM_PPQN_2       ( DM_PPQN >> 1 )

#define MIN_TEMPO		10
#define MAX_TEMPO		350

#define MIN_GROOVE		1
#define MAX_GROOVE		100

#define MIN_EMB_CUSTOM_ID	100
#define MAX_EMB_CUSTOM_ID	199

#define MIN_PATTERN_LENGTH		1
#define MAX_PATTERN_LENGTH		999

#define MIN_BEATS_PER_MEASURE	1
#define MAX_BEATS_PER_MEASURE	100

#define MIN_GRIDS_PER_BEAT			1
#define MAX_GRIDS_PER_BEAT			24
#define MAX_GRIDS_PER_BEAT_ENTRIES	48

#define SS_STOP_MUSIC			1
#define SS_KEEP_MUSIC			2

#define GRID_BMP_CX				16			
#define GRID_BMP_CX				16			
#define GRID_BMP_COLUMNS		6
#define GRID_BMP_ROWS			4

#define FIRST_FOLDER_IMAGE		0
#define FIRST_STYLE_IMAGE		2
#define FIRST_MOTIF_IMAGE		4
#define FIRST_PATTERN_IMAGE		6
#define FIRST_STYLEREF_IMAGE	8

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE


class CStyleComponent;

/////////////////////////////////////////////////////////////////////////////
// DLL externs
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifdef __cplusplus
}
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleDesignerApp : See StyleDesigner.cpp for implementation.

class CStyleDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	CStyleComponent*		m_pStyleComponent;
};

extern CStyleDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

extern const UINT g_nGridsPerBeatBitmaps[];

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(STYLEDESIGNER_H__3BD2BA1B_46E7_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleDocType.h ===
#ifndef __STYLEDOCTYPE_H__
#define __STYLEDOCTYPE_H__

// StyleDocType.h : header file
//


class CStyleDocType : public IDMUSProdDocType8
{
public:
    CStyleDocType();
	~CStyleDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IStyleDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

	// Member variables
private:
    DWORD m_dwRef;
};

#endif // __STYLEDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleMotifs.h ===
#ifndef __STYLEMOTIFS_H__
#define __STYLEMOTIFS_H__

// StyleMotifs.h : header file
//

#include <afxtempl.h>

class CDirectMusicStyle;

class CStyleMotifs : public IDMUSProdNode
{
friend class CDirectMusicStyle;
friend class CDirectMusicPattern;
friend class CStyleDlg;
friend class CDialogLinkExisting;
friend class CNewPatternDlg;

public:
    CStyleMotifs();
	~CStyleMotifs();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
    HRESULT InsertChildNodeAtPos( CDirectMusicPattern* pMotif, CDirectMusicPattern* pPositionMotif );
    HRESULT CreateNewMotif();
	void SortMotifList();

public:
	BOOL IsDirty();
	void SetModified( BOOL fModified );

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	CTypedPtrList<CPtrList, CDirectMusicPattern*> m_lstMotifs;
	CDirectMusicStyle*	m_pStyle;
	BOOL				m_fModified;
};

#endif // __STYLEMOTIFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleMotifs.cpp ===
// StyleMotifs.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "NewPatternDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs constructor/destructor

CStyleMotifs::CStyleMotifs()
{
	m_pStyle = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_fModified = FALSE;
}

CStyleMotifs::~CStyleMotifs()
{
	CDirectMusicPattern* pMotif;

	while( !m_lstMotifs.IsEmpty() )
	{
		pMotif = static_cast<CDirectMusicPattern*>( m_lstMotifs.RemoveHead() );
		pMotif->PreDeleteCleanup();
		RELEASE( pMotif );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs::IsDirty

BOOL CStyleMotifs::IsDirty( void )
{
	// Check to see if the list of Motifs was changed
	if( m_fModified )
	{
		return TRUE;
	}

	// Check to see if any of the Motifs were changed
	CDirectMusicPattern* pMotif;
	IPersistStream* pIPS;
	HRESULT hr;

    POSITION pos = m_lstMotifs.GetHeadPosition();
    while( pos )
    {
        pMotif = m_lstMotifs.GetNext( pos );

		if( SUCCEEDED ( pMotif->QueryInterface( IID_IPersistStream, (void **)&pIPS ) ) )
		{
			hr = pIPS->IsDirty();
			RELEASE( pIPS );

			if( hr == S_OK )
			{
				return TRUE;
			}
		}
    }

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs::SetModified

void CStyleMotifs::SetModified( BOOL fModified )
{
	// Set modified flag of Motif folder
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs::InsertChildNodeAtPos

HRESULT CStyleMotifs::InsertChildNodeAtPos( CDirectMusicPattern* pMotif, CDirectMusicPattern* pPositionMotif )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pMotif != NULL );
	ASSERT( pPositionMotif != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Add to CDirectMusicStyle Motif list
	m_pStyle->AddMotif( pMotif, pPositionMotif );

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pMotif, m_pStyle, this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pMotif, this) ) )
	{
		DeleteChildNode( pMotif, FALSE );
		return E_FAIL;
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IUnknown implementation

HRESULT CStyleMotifs::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pStyle )
		{
	        return m_pStyle->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStyleMotifs::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	AfxOleLockApp(); 

	return m_pStyle->AddRef();
}

ULONG CStyleMotifs::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	AfxOleUnlockApp(); 

	return m_pStyle->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetNodeImageIndex

HRESULT CStyleMotifs::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return( theApp.m_pStyleComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetFirstChild

HRESULT CStyleMotifs::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstMotifs.IsEmpty() )
	{
		CDirectMusicPattern* pMotif = static_cast<CDirectMusicPattern*>( m_lstMotifs.GetHead() );
		
		if( pMotif )
		{
			pMotif->AddRef();
			*ppIFirstChildNode = pMotif;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetNextChild

HRESULT CStyleMotifs::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	CDirectMusicPattern* pMotif;

    POSITION pos = m_lstMotifs.GetHeadPosition();

    while( pos )
    {
        pMotif = m_lstMotifs.GetNext( pos );
		if( pMotif == pIChildNode )
		{
			if( pos )
			{
				pMotif = m_lstMotifs.GetNext( pos );

				pMotif->AddRef();
				*ppINextChildNode = pMotif;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetComponent

HRESULT CStyleMotifs::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetDocRootNode

HRESULT CStyleMotifs::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::SetDocRootNode

HRESULT CStyleMotifs::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetParentNode

HRESULT CStyleMotifs::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::SetParentNode

HRESULT CStyleMotifs::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetNodeId

HRESULT CStyleMotifs::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_StyleMotifFolderNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetNodeName

HRESULT CStyleMotifs::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_MOTIF_FOLDER_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetNodeNameMaxLength

HRESULT CStyleMotifs::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a Motif folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::ValidateNodeName

HRESULT CStyleMotifs::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::SetNodeName

HRESULT CStyleMotifs::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetNodeListInfo

HRESULT CStyleMotifs::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetEditorClsId

HRESULT CStyleMotifs::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetEditorTitle

HRESULT CStyleMotifs::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetEditorWindow

HRESULT CStyleMotifs::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::SetEditorWindow

HRESULT CStyleMotifs::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::UseOpenCloseImages

HRESULT CStyleMotifs::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetRightClickMenuId

HRESULT CStyleMotifs::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_STYLEMOTIFS_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::OnRightClickMenuInit

HRESULT CStyleMotifs::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		IDMUSProdPropPageObject* pIPageObject;

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::OnRightClickMenuSelect

HRESULT CStyleMotifs::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_MOTIF:
			hr = CreateNewMotif();
			break;

		case IDM_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_MOTIF_FROMMIDI:
			if(m_pStyle != NULL)
			{
				m_pStyle->ImportMidiFileAsPattern( TRUE );
			}
			break;

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::DeleteChildNode

HRESULT CStyleMotifs::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pStyleComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Save undo state
//	m_pStyle->m_pINodeBeingDeleted = pIChildNode;
//	m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_DELETE_MOTIF );
//	m_pStyle->m_pINodeBeingDeleted = NULL;

	// Store motif's name for NotifyNodes() call
	CString strMotifName;
	BSTR bstrMotifName;
	if( SUCCEEDED ( pIChildNode->GetNodeName( &bstrMotifName ) ) )
	{
		strMotifName = bstrMotifName;
		::SysFreeString( bstrMotifName );
	}

	// Remove from CDirectMusicStyle Motif list
	m_pStyle->RemoveMotif( (CDirectMusicPattern *)pIChildNode );

	// Notify connected nodes that Motif has been deleted
	{
		DMUSProdMotifData	mtfData;
		WCHAR				wstrMotifName[MAX_PATH];
	
		MultiByteToWideChar( CP_ACP, 0, strMotifName, -1, wstrMotifName, MAX_PATH );
		mtfData.pwszMotifName = wstrMotifName;
		mtfData.pwszOldMotifName = NULL;
		
		theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( m_pStyle, STYLE_MotifDeleted, &mtfData );
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::InsertChildNode

HRESULT CStyleMotifs::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pMotif = (CDirectMusicPattern *)pIChildNode;

	if( pMotif )
	{
		// Add to CDirectMusicStyle Motif list
		m_pStyle->AddMotif( pMotif, NULL );
	}
	else
	{
		pMotif = new CDirectMusicPattern( m_pStyle, TRUE );
		if( pMotif == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		HRESULT hr = pMotif->Initialize();
		if( FAILED( hr ) )
		{
			RELEASE( pMotif );
			return hr;
		}

		// Add to CDirectMusicStyle Pattern list
		m_pStyle->AddMotif( pMotif, NULL );
		pMotif->Release();
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pMotif, m_pStyle, this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pMotif, this) ) )
	{
		DeleteChildNode( pMotif, FALSE );
		return E_FAIL;
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::DeleteNode

HRESULT CStyleMotifs::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't delete a Motif folder
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::OnNodeSelChanged

HRESULT CStyleMotifs::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CreateDataObject

HRESULT CStyleMotifs::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CanCut

HRESULT CStyleMotifs::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove Motif folder from Style
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CanCopy

HRESULT CStyleMotifs::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CanDelete

HRESULT CStyleMotifs::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't delete Motif folder from Style
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CanDeleteChildNode

HRESULT CStyleMotifs::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure node is in Motif list
	POSITION pos = m_lstMotifs.Find( pIChildNode );
	if( pos == NULL )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CanPasteFromData

HRESULT CStyleMotifs::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::PasteFromData

HRESULT CStyleMotifs::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) ) 
	||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERN and CF_MOTIF formats
		hr = m_pStyle->PasteCF_MOTIF( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) 
		 ||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERNLIST and CF_MOTIFLIST formats
		hr = m_pStyle->PasteCF_MOTIFLIST( pDataObject, pIDataObject, NULL );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::CanChildPasteFromData

HRESULT CStyleMotifs::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											 BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::ChildPasteFromData

HRESULT CStyleMotifs::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pIDataObject == NULL
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) ) 
	||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERN and CF_MOTIF formats
		hr = m_pStyle->PasteCF_MOTIF( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) 
		 ||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERNLIST and CF_MOTIFLIST formats
		hr = m_pStyle->PasteCF_MOTIFLIST( pDataObject, pIDataObject, NULL );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs IDMUSProdNode::GetObject

HRESULT CStyleMotifs::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs CreateNewMotif

HRESULT CStyleMotifs::CreateNewMotif( void )
{
	CNewPatternDlg dlgNewMotif;

	dlgNewMotif.m_wEmbellishment = EMB_MOTIF;
	dlgNewMotif.m_pStyle = m_pStyle;

	HRESULT	hr = E_FAIL;

	int nReturn = dlgNewMotif.DoModal();

	if( nReturn == IDC_NEW_PATTERN )
	{
		hr = InsertChildNode( NULL );
	}
	else if( nReturn == IDC_LINK_PATTERN )
	{
		ASSERT( dlgNewMotif.m_pPattern != NULL );

		CDirectMusicPattern* pMotif = new CDirectMusicPattern( m_pStyle, TRUE );
		if( pMotif )
		{
			// Copy pertinent information from the original Pattern (or Motif)
			if( SUCCEEDED ( dlgNewMotif.m_pPattern->CopyToForLinkAllParts( pMotif ) ) )
			{
				// Add to CDirectMusicStyle Motif list
				InsertChildNode( pMotif );

				// Sync original Pattern (or Motif) because Parts are now linked
				dlgNewMotif.m_pPattern->SyncPatternWithMidiStripMgr();
				dlgNewMotif.m_pPattern->SyncPatternWithDirectMusic();

				hr = S_OK;
			}

			pMotif->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleMotifs SortMotifList

void CStyleMotifs::SortMotifList( void )
{
	// Do a simple bubble sort on the list of Motifs
	// Order them by m_strName

	bool fContinue = true;

	while( fContinue )
	{
		fContinue = false;

		POSITION posCur = m_lstMotifs.GetHeadPosition();
		while( posCur )
		{
			POSITION posPrev = posCur;

			m_lstMotifs.GetNext( posCur );
			if( posCur )
			{
				CDirectMusicPattern* pMotifPrev = m_lstMotifs.GetAt( posPrev );
				CDirectMusicPattern* pMotifCur = m_lstMotifs.GetAt( posCur );

				if( pMotifPrev->m_strName.CompareNoCase(pMotifCur->m_strName) > 0 )
				{
					m_lstMotifs.RemoveAt( posPrev );
					posCur = m_lstMotifs.InsertAfter( posCur, pMotifPrev );

					fContinue = true;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StylePersonalities.h ===
#ifndef __STYLEPERSONALITIES_H__
#define __STYLEPERSONALITIES_H__

// StylePersonalities.h : header file
//

#include <afxtempl.h>

class CDirectMusicStyle;
class CPersonality;

class CStylePersonalities
{
friend class CDirectMusicStyle;

public:
    CStylePersonalities();
	~CStylePersonalities();

private:
	CTypedPtrList<CPtrList, CPersonality*> m_lstPersonalities;
	CDirectMusicStyle*	m_pStyle;
};

#endif // __STYLEPERSONALITIES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StylePatterns.cpp ===
// StylePatterns.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "NewPatternDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns constructor/destructor

CStylePatterns::CStylePatterns()
{
	m_pStyle = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_fModified = FALSE;
}

CStylePatterns::~CStylePatterns()
{
	CDirectMusicPattern* pPattern;

	while( !m_lstPatterns.IsEmpty() )
	{
		pPattern = static_cast<CDirectMusicPattern*>( m_lstPatterns.RemoveHead() );
		pPattern->PreDeleteCleanup();
		RELEASE( pPattern );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns::IsDirty

BOOL CStylePatterns::IsDirty( void )
{
	// Check to see if the list of Patterns was changed
	if( m_fModified )
	{
		return TRUE;
	}

	// Check to see if any of the Patterns were changed
	CDirectMusicPattern* pPattern;
	IPersistStream* pIPS;
	HRESULT hr;

    POSITION pos = m_lstPatterns.GetHeadPosition();
    while( pos )
    {
        pPattern = m_lstPatterns.GetNext( pos );

		if( SUCCEEDED ( pPattern->QueryInterface( IID_IPersistStream, (void **)&pIPS ) ) )
		{
			hr = pIPS->IsDirty();
			RELEASE( pIPS );

			if( hr == S_OK )
			{
				return TRUE;
			}
		}
    }

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns::SetModified

void CStylePatterns::SetModified( BOOL fModified )
{
	// Set modified flag of Pattern folder
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns::InsertChildNodeAtPos

HRESULT CStylePatterns::InsertChildNodeAtPos( CDirectMusicPattern* pPattern, CDirectMusicPattern* pPositionPattern )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pPattern != NULL );
	ASSERT( pPositionPattern != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Add to CDirectMusicStyle Pattern list
	m_pStyle->AddPattern( pPattern, pPositionPattern );

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pPattern, m_pStyle, this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pPattern, this) ) )
	{
		DeleteChildNode( pPattern, FALSE );
		return E_FAIL;
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IUnknown implementation

HRESULT CStylePatterns::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pStyle )
		{
	        return m_pStyle->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStylePatterns::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	AfxOleLockApp(); 

	return m_pStyle->AddRef();
}

ULONG CStylePatterns::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	AfxOleUnlockApp(); 

	return m_pStyle->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetNodeImageIndex

HRESULT CStylePatterns::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return( theApp.m_pStyleComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetFirstChild

HRESULT CStylePatterns::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstPatterns.IsEmpty() )
	{
		CDirectMusicPattern* pPattern = static_cast<CDirectMusicPattern*>( m_lstPatterns.GetHead() );
		
		if( pPattern )
		{
			pPattern->AddRef();
			*ppIFirstChildNode = pPattern;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetNextChild

HRESULT CStylePatterns::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	CDirectMusicPattern* pPattern;

    POSITION pos = m_lstPatterns.GetHeadPosition();
    while( pos )
    {
        pPattern = m_lstPatterns.GetNext( pos );
		if( pPattern == pIChildNode )
		{
			if( pos )
			{
				pPattern = m_lstPatterns.GetNext( pos );

				pPattern->AddRef();
				*ppINextChildNode = pPattern;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetComponent

HRESULT CStylePatterns::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetDocRootNode

HRESULT CStylePatterns::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::SetDocRootNode

HRESULT CStylePatterns::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetParentNode

HRESULT CStylePatterns::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::SetParentNode

HRESULT CStylePatterns::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetNodeId

HRESULT CStylePatterns::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_StylePatternFolderNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetNodeName

HRESULT CStylePatterns::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_PATTERN_FOLDER_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetNodeNameMaxLength

HRESULT CStylePatterns::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a Pattern folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::ValidateNodeName

HRESULT CStylePatterns::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::SetNodeName

HRESULT CStylePatterns::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetNodeListInfo

HRESULT CStylePatterns::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetEditorClsId

HRESULT CStylePatterns::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetEditorTitle

HRESULT CStylePatterns::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetEditorWindow

HRESULT CStylePatterns::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::SetEditorWindow

HRESULT CStylePatterns::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::UseOpenCloseImages

HRESULT CStylePatterns::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetRightClickMenuId

HRESULT CStylePatterns::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_STYLEPATTERNS_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::OnRightClickMenuInit

HRESULT CStylePatterns::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		IDMUSProdPropPageObject* pIPageObject;

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::OnRightClickMenuSelect

HRESULT CStylePatterns::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_PATTERN:
			hr = CreateNewPattern();
			break;

		case IDM_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_PATTERN_FROMMIDI:
			if(m_pStyle != NULL)
			{
				m_pStyle->ImportMidiFileAsPattern( FALSE );
			}
			break;

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::DeleteChildNode

HRESULT CStylePatterns::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pStyleComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Save undo state
//	m_pStyle->m_pINodeBeingDeleted = pIChildNode;
//	m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_DELETE_PATTERN );
//	m_pStyle->m_pINodeBeingDeleted = NULL;

	// Remove from CDirectMusicStyle Pattern list
	m_pStyle->RemovePattern( (CDirectMusicPattern *)pIChildNode );

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::InsertChildNode

HRESULT CStylePatterns::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	CDirectMusicPattern* pPattern = (CDirectMusicPattern *)pIChildNode;

	if( pPattern )
	{
		// Add to CDirectMusicStyle Pattern list
		m_pStyle->AddPattern( pPattern, NULL );
	}
	else
	{
		pPattern = new CDirectMusicPattern( m_pStyle, FALSE );
		if( pPattern == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		HRESULT hr = pPattern->Initialize();
		if( FAILED( hr ) )
		{
			RELEASE( pPattern );
			return hr;
		}

		// Add to CDirectMusicStyle Pattern list
		m_pStyle->AddPattern( pPattern, NULL );
		pPattern->Release();
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pPattern, m_pStyle, this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AddNode(pPattern, this) ) )
	{
		DeleteChildNode( pPattern, FALSE );
		return E_FAIL;
	}

	SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::DeleteNode

HRESULT CStylePatterns::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't delete a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::OnNodeSelChanged

HRESULT CStylePatterns::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CreateDataObject

HRESULT CStylePatterns::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CanCut

HRESULT CStylePatterns::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove Pattern folder from Style
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CanCopy

HRESULT CStylePatterns::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CanDelete

HRESULT CStylePatterns::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't delete Pattern folder from Style
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CanDeleteChildNode

HRESULT CStylePatterns::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure node is in Pattern list
	POSITION pos = m_lstPatterns.Find( pIChildNode );
	if( pos == NULL )
	{
		return E_FAIL;
	}

	// Cannot delete the last Pattern from a Style
	if( m_lstPatterns.GetCount() < 2 )
	{
		return S_FALSE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CanPasteFromData

HRESULT CStylePatterns::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::PasteFromData

HRESULT CStylePatterns::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) ) 
	||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERN and CF_MOTIF formats
		hr = m_pStyle->PasteCF_PATTERN( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) 
		 ||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERNLIST and CF_MOTIFLIST formats
		hr = m_pStyle->PasteCF_PATTERNLIST( pDataObject, pIDataObject, NULL );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::CanChildPasteFromData

HRESULT CStylePatterns::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											   BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) 
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::ChildPasteFromData

HRESULT CStylePatterns::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pStyle != NULL );

	if( pIDataObject == NULL 
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPattern ) ) 
	||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotif ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERN and CF_MOTIF formats
		hr = m_pStyle->PasteCF_PATTERN( pDataObject, pIDataObject, NULL );
	}

	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfPatternList ) ) 
		 ||  SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfMotifList ) ) )
	{
		// Let CDirectMusicStyle handle CF_PATTERNLIST and CF_MOTIFLIST formats
		hr = m_pStyle->PasteCF_PATTERNLIST( pDataObject, pIDataObject, NULL );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns IDMUSProdNode::GetObject

HRESULT CStylePatterns::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns CreateNewPattern

HRESULT CStylePatterns::CreateNewPattern( void )
{
	CNewPatternDlg dlgNewPattern;

	dlgNewPattern.m_wEmbellishment = EMB_NORMAL;
	dlgNewPattern.m_pStyle = m_pStyle;

	HRESULT	hr = E_FAIL;

	int nReturn = dlgNewPattern.DoModal();

	if( nReturn == IDC_NEW_PATTERN )
	{
		hr = InsertChildNode( NULL );
	}
	else if( nReturn == IDC_LINK_PATTERN )
	{
		ASSERT( dlgNewPattern.m_pPattern != NULL );

		CDirectMusicPattern* pPattern = new CDirectMusicPattern( m_pStyle, FALSE );
		if( pPattern )
		{
			// Copy pertinent information from the original Pattern (or Motif)
			if( SUCCEEDED ( dlgNewPattern.m_pPattern->CopyToForLinkAllParts( pPattern ) ) )
			{
				// Add to CDirectMusicStyle Pattern list
				InsertChildNode( pPattern );

				// Sync original Pattern (or Motif) because Parts are now linked
				dlgNewPattern.m_pPattern->SyncPatternWithMidiStripMgr();
				dlgNewPattern.m_pPattern->SyncPatternWithDirectMusic();

				hr = S_OK;
			}

			pPattern->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStylePatterns SortPatternList

void CStylePatterns::SortPatternList( void )
{
	// Do a simple bubble sort on the list of Patterns
	// Order them by m_strName

	bool fContinue = true;

	while( fContinue )
	{
		fContinue = false;

		POSITION posCur = m_lstPatterns.GetHeadPosition();
		while( posCur )
		{
			POSITION posPrev = posCur;

			m_lstPatterns.GetNext( posCur );
			if( posCur )
			{
				CDirectMusicPattern* pPatternPrev = m_lstPatterns.GetAt( posPrev );
				CDirectMusicPattern* pPatternCur = m_lstPatterns.GetAt( posCur );

				if( pPatternPrev->m_strName.CompareNoCase(pPatternCur->m_strName) > 0 )
				{
					m_lstPatterns.RemoveAt( posPrev );
					posCur = m_lstPatterns.InsertAfter( posCur, pPatternPrev );

					fContinue = true;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StylePatterns.h ===
#ifndef __STYLEPATTERNS_H__
#define __STYLEPATTERNS_H__

// StylePatterns.h : header file
//

#include <afxtempl.h>

class CDirectMusicStyle;

class CStylePatterns : public IDMUSProdNode
{
friend class CDirectMusicStyle;
friend class CDirectMusicPattern;
friend class CStyleDlg;
friend class CDialogLinkExisting;
friend class CNewPatternDlg;

public:
    CStylePatterns();
	~CStylePatterns();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
    HRESULT InsertChildNodeAtPos( CDirectMusicPattern* pPattern, CDirectMusicPattern* pPositionPattern );
    HRESULT CreateNewPattern();
	void SortPatternList();

public:
	BOOL IsDirty();
	void SetModified( BOOL fModified );

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*		    m_pIParentNode;

	CTypedPtrList<CPtrList, CDirectMusicPattern*> m_lstPatterns;
	CDirectMusicStyle*	m_pStyle;
	BOOL				m_fModified;
};

#endif // __STYLEPATTERNS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleRef.cpp ===
// StyleRef.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"

#include "Style.h"
#include "StyleRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleRef constructor/destructor

CStyleRef::CStyleRef()
{
    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pStyle = NULL;
}

CStyleRef::~CStyleRef()
{
	RELEASE( m_pStyle );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IUnknown implementation

HRESULT CStyleRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CStyleRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CStyleRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetNodeImageIndex

HRESULT CStyleRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return( theApp.m_pStyleComponent->GetStyleRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetFirstChild

HRESULT CStyleRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// StyleRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetNextChild

HRESULT CStyleRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// StyleRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetComponent

HRESULT CStyleRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetDocRootNode

HRESULT CStyleRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::SetDocRootNode

HRESULT CStyleRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetParentNode

HRESULT CStyleRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::SetParentNode

HRESULT CStyleRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetNodeId

HRESULT CStyleRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_StyleRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetNodeName

HRESULT CStyleRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle == NULL )
	{
		TCHAR achNoStyle[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_STYLE, achNoStyle, MID_BUFFER );
		CString strNoStyle = achNoStyle;
		*pbstrName = strNoStyle.AllocSysString();
		return S_OK;
	}

    return m_pStyle->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CStyleRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a StyleRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::ValidateNodeName

HRESULT CStyleRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a StyleRef node
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::SetNodeName

HRESULT CStyleRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a StyleRef node
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetNodeListInfo

HRESULT CStyleRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle == NULL )
	{
		return E_FAIL;
	}

    return m_pStyle->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetEditorClsId

HRESULT CStyleRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_StyleEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetEditorTitle

HRESULT CStyleRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle == NULL )
	{
		return E_FAIL;
	}

    return m_pStyle->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetEditorWindow

HRESULT CStyleRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle == NULL )
	{
		return E_FAIL;
	}

    return m_pStyle->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::SetEditorWindow

HRESULT CStyleRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle == NULL )
	{
		return E_FAIL;
	}

    return m_pStyle->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::UseOpenCloseImages

HRESULT CStyleRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetRightClickMenuId

HRESULT CStyleRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_STYLEREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CStyleRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CStyleRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pStyle )
			{
				return m_pStyle->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::DeleteChildNode

HRESULT CStyleRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// StyleRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::InsertChildNode

HRESULT CStyleRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// StyleRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::DeleteNode

HRESULT CStyleRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete StyleRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::OnNodeSelChanged

HRESULT CStyleRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CreateDataObject

HRESULT CStyleRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pStyle )
	{
		// Let Style create data object
		return m_pStyle->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CanCut

HRESULT CStyleRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CanCopy

HRESULT CStyleRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pStyle )
	{
		return S_OK;	// Will copy the Style
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CanDelete

HRESULT CStyleRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CanDeleteChildNode

HRESULT CStyleRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Style Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CanPasteFromData

HRESULT CStyleRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Style
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfStyle );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Style
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pStyle )
	{
		// Let Style decide what can be dropped
		return m_pStyle->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::PasteFromData

HRESULT CStyleRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Style
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfStyle );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Style
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pStyle )
	{
		// Let Style handle paste
		return m_pStyle->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::CanChildPasteFromData

HRESULT CStyleRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Style Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::ChildPasteFromData

HRESULT CStyleRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Style Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdNode::GetObject

HRESULT CStyleRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CStyleRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pStyle )
	{
		m_pStyle->AddRef();
		*ppIDocRootNode = m_pStyle;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CStyleRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

// AMC TEST THIS CODE

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Style Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_StyleNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pStyle );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pStyle = (CDirectMusicStyle *)pIDocRootNode;
		m_pStyle->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StylePersonalities.cpp ===
// StylePersonalities.cpp : implementation file
//

#include "stdafx.h"

#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Personality.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStylePersonalities constructor/destructor

CStylePersonalities::CStylePersonalities()
{
	m_pStyle = NULL;
}

CStylePersonalities::~CStylePersonalities()
{
	CPersonality* pPersonality;

	while( !m_lstPersonalities.IsEmpty() )
	{
		pPersonality = static_cast<CPersonality*>( m_lstPersonalities.RemoveHead() );
		delete pPersonality;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\StyleRef.h ===
#ifndef __STYLEREF_H__
#define __STYLEREF_H__

// StyleRef.h : header file
//

#include "StyleComponent.h"
#include "StyleDocType.h"
#include "RiffStrm.h"
#include "RiffStructs.h"

class CStyleRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CStyleRef();
	~CStyleRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CDirectMusicStyle*	m_pStyle;		// StyleRef refers to this Style

private:
    DWORD				m_dwRef;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*		    m_pIParentNode;
};

#endif // __STYLEREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabMotifLoop.cpp ===
// TabMotifLoop.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "TabMotifLoop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop property page

CTabMotifLoop::CTabMotifLoop( CMotifPropPageManager* pMotifPropPageManager ) : CPropertyPage(CTabMotifLoop::IDD)
{
	//{{AFX_DATA_INIT(CTabMotifLoop)
	//}}AFX_DATA_INIT
	
	ASSERT( pMotifPropPageManager != NULL );

	m_pMotif = NULL;
	m_pPageManager = pMotifPropPageManager;
	m_fNeedToDetach = FALSE;
	m_dwLastLoopRepeatCount = 0;
}

CTabMotifLoop::~CTabMotifLoop()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::RefreshTab

void CTabMotifLoop::RefreshTab( IDMUSProdPropPageObject* pIPropPageObject )
{
	PPGMotif ppgMotif;
	PPGMotif* pPPGMotif = &ppgMotif;

	if( pIPropPageObject
	&& ( SUCCEEDED ( pIPropPageObject->GetData((void **)&pPPGMotif ) ) ) )
	{
		m_pMotif = ppgMotif.pMotif;
	}
	else
	{
		m_pMotif = NULL;
	}

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::EnableControls

void CTabMotifLoop::EnableControls( BOOL fEnable ) 
{
	// Disable Repeats edit/spin controls if Motif repeats is DMUS_SEG_REPEAT_INFINITE
	BOOL fEnableRepeats = fEnable;
	if( m_pMotif
	&&  m_pMotif->m_dwRepeats == DMUS_SEG_REPEAT_INFINITE )
	{
		fEnableRepeats = FALSE;
	}
	m_editRepeats.EnableWindow( fEnableRepeats );
	m_spinRepeats.EnableWindow( fEnableRepeats );

	// Disable Loop Point buttons if Motif repeats is zero
	if( m_pMotif
	&&  m_pMotif->m_dwRepeats == 0 )
	{
		fEnable = FALSE;
	}

	m_btnResetLoop.EnableWindow( fEnable );

	m_editStartBar.EnableWindow( fEnable );
	m_spinStartBar.EnableWindow( fEnable );
	m_editStartBeat.EnableWindow( fEnable );
	m_spinStartBeat.EnableWindow( fEnable );
	m_editStartGrid.EnableWindow( fEnable );
	m_spinStartGrid.EnableWindow( fEnable );
	m_editStartTick.EnableWindow( fEnable );
	m_spinStartTick.EnableWindow( fEnable );

	m_editEndBar.EnableWindow( fEnable );
	m_spinEndBar.EnableWindow( fEnable );
	m_editEndBeat.EnableWindow( fEnable );
	m_spinEndBeat.EnableWindow( fEnable );
	m_editEndGrid.EnableWindow( fEnable );
	m_spinEndGrid.EnableWindow( fEnable );
	m_editEndTick.EnableWindow( fEnable );
	m_spinEndTick.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::UpdateLoopStartEndControls

void CTabMotifLoop::UpdateLoopStartEndControls()
{
	long lBar;
	long lBeat;
	long lGrid;
	long lTick;

	if( m_pMotif )
	{
		// Get Bar, Beat, Grid, Tick of mtLoopStart
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart, &lBar, &lBeat, &lGrid, &lTick );

		// Set Start Bar, beat, Grid, Tick
		m_spinStartBar.SetPos( lBar );
		m_spinStartBeat.SetPos( lBeat );
		m_spinStartGrid.SetPos( lGrid );
		m_spinStartTick.SetPos( lTick );

		// Get Bar, Beat, Grid, Tick of mtLoopEnd
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd, &lBar, &lBeat, &lGrid, &lTick );

		// Set End Bar, beat, Grid, Tick
		m_spinEndBar.SetPos( lBar );
		m_spinEndBeat.SetPos( lBeat );
		m_spinEndGrid.SetPos( lGrid );
		m_spinEndTick.SetPos( lTick );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::UpdateControls

void CTabMotifLoop::UpdateControls()
{
	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	if( m_pMotif )
	{
		EnableControls( TRUE );

		// Set Repeats
		if( m_pMotif->m_dwRepeats == DMUS_SEG_REPEAT_INFINITE )
		{
			m_checkInfinite.SetCheck( 1 );
			m_editRepeats.SetWindowText( NULL );
			m_dwLastLoopRepeatCount = 0;
		}
		else
		{
			m_checkInfinite.SetCheck( 0 );
			m_spinRepeats.SetPos( m_pMotif->m_dwRepeats );
			m_dwLastLoopRepeatCount = m_pMotif->m_dwRepeats;
		}

		// Set Loop Start/End Bar, Beat, Grid, Tick
		UpdateLoopStartEndControls();
	}
	else
	{
		m_spinRepeats.SetPos( 0 );
		m_editRepeats.SetWindowText( NULL );
		m_checkInfinite.SetCheck( 0 );

		m_spinStartBar.SetPos( 1 );
		m_spinStartBeat.SetPos( 1 );
		m_spinStartGrid.SetPos( 1 );
		m_spinStartTick.SetPos( 0 );
		
		m_spinEndBar.SetPos( 1 );
		m_spinEndBeat.SetPos( 1 );
		m_spinEndGrid.SetPos( 1 );
		m_spinEndTick.SetPos( 0 );

		EnableControls( FALSE );
	}
}


void CTabMotifLoop::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabMotifLoop)
	DDX_Control(pDX, IDC_CHECK_REPEAT_FOREVER, m_checkInfinite);
	DDX_Control(pDX, IDC_RESET_LOOP, m_btnResetLoop);
	DDX_Control(pDX, IDC_EDIT_LOOP_REPEAT, m_editRepeats);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_BAR, m_editStartBar);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_BAR, m_editEndBar);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_BEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_GRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_TICK, m_editEndTick);
	DDX_Control(pDX, IDC_SPIN_LOOP_REPEAT, m_spinRepeats);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_BAR, m_spinStartBar);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_BAR, m_spinEndBar);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_BEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_GRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_TICK, m_spinEndTick);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabMotifLoop, CPropertyPage)
	//{{AFX_MSG_MAP(CTabMotifLoop)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_REPEAT, OnKillFocusEditRepeats)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_REPEAT, OnDeltaPosSpinRepeats)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_BAR, OnKillFocusEditLoopStartBar)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_BEAT, OnKillFocusEditLoopStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_GRID, OnKillFocusEditLoopStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_TICK, OnKillFocusEditLoopStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_BAR, OnDeltaPosSpinLoopStartBar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_BEAT, OnDeltaPosSpinLoopStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_GRID, OnDeltaPosSpinLoopStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_TICK, OnDeltaPosSpinLoopStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_BAR, OnKillFocusEditLoopEndBar)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_BEAT, OnKillFocusEditLoopEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_GRID, OnKillFocusEditLoopEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_TICK, OnKillFocusEditLoopEndTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_BAR, OnDeltaPosSpinLoopEndBar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_BEAT, OnDeltaPosSpinLoopEndBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_GRID, OnDeltaPosSpinLoopEndGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_TICK, OnDeltaPosSpinLoopEndTick)
	ON_BN_CLICKED(IDC_RESET_LOOP, OnResetLoop)
	ON_BN_DOUBLECLICKED(IDC_RESET_LOOP, OnDoubleClickedResetLoop)
	ON_BN_CLICKED(IDC_CHECK_REPEAT_FOREVER, OnCheckInfinite)
	ON_BN_DOUBLECLICKED(IDC_CHECK_REPEAT_FOREVER, OnDoubleClickedInfinite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnSetActive

BOOL CTabMotifLoop::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnCreate

int CTabMotifLoop::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDestroy

void CTabMotifLoop::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnInitDialog

BOOL CTabMotifLoop::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// Set control ranges

	m_spinRepeats.SetRange( 0, 32767 );
	m_editRepeats.LimitText( 5 );

	m_spinStartBar.SetRange( 1, 32767 );
	m_editStartBar.LimitText( 5 );
	m_spinStartBeat.SetRange( 1, 256 );
	m_editStartBeat.LimitText( 3 );
	m_spinStartGrid.SetRange( 1, 256 );
	m_editStartGrid.LimitText( 3 );
	m_spinStartTick.SetRange( 0, 32767 );
	m_editStartTick.LimitText( 5 );
	
	m_spinEndBar.SetRange( 1, 32767 );
	m_editEndBar.LimitText( 5 );
	m_spinEndBeat.SetRange( 1, 256 );
	m_editEndBeat.LimitText( 3 );
	m_spinEndGrid.SetRange( 1, 256 );
	m_editEndGrid.LimitText( 3 );
	m_spinEndTick.SetRange( 0, 32767 );
	m_editEndTick.LimitText( 5 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditRepeats

void CTabMotifLoop::OnKillFocusEditRepeats() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get string from control
		CString strNewRepeats;
		m_editRepeats.GetWindowText( strNewRepeats );

		// Strip leading and trailing spaces
		strNewRepeats.TrimRight();
		strNewRepeats.TrimLeft();

		if( strNewRepeats.IsEmpty() )
		{
			m_spinRepeats.SetPos( m_pMotif->m_dwRepeats );
		}
		else
		{
			long lNewRepeats = _ttoi( strNewRepeats );
			lNewRepeats = max( lNewRepeats, 0 );
			lNewRepeats = min( lNewRepeats, 32767 );

			// Set new Repeats 
			m_pMotif->SetMotifRepeats( lNewRepeats );
			m_dwLastLoopRepeatCount = m_pMotif->m_dwRepeats;
			EnableControls( TRUE );

			// Update controls
			m_checkInfinite.SetCheck( 0 );
			m_spinRepeats.SetPos( m_pMotif->m_dwRepeats );
			if( m_pMotif->m_dwRepeats == 0 )
			{
				OnResetLoop();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinRepeats

void CTabMotifLoop::OnDeltaPosSpinRepeats( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get new Repeats
		long lNewRepeats = m_spinRepeats.GetPos() + pNMUpDown->iDelta;
		lNewRepeats = max( lNewRepeats, 0 );
		lNewRepeats = min( lNewRepeats, 32767 );

		// Set new Repeats 
		m_pMotif->SetMotifRepeats( lNewRepeats );
		m_dwLastLoopRepeatCount = m_pMotif->m_dwRepeats;
		EnableControls( TRUE );

		// Update controls
		m_checkInfinite.SetCheck( 0 );
		m_spinRepeats.SetPos( m_pMotif->m_dwRepeats );
		if( m_pMotif->m_dwRepeats == 0 )
		{
			OnResetLoop();
		}
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnCheckInfinite

void CTabMotifLoop::OnCheckInfinite() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Set new Repeats 
		m_pMotif->SetMotifRepeats( m_checkInfinite.GetCheck() ? DMUS_SEG_REPEAT_INFINITE : m_dwLastLoopRepeatCount );
		EnableControls( TRUE );

		// Update controls
		if( m_checkInfinite.GetCheck() )
		{
			m_editRepeats.SetWindowText( NULL );
		}
		else
		{
			SetDlgItemInt( IDC_EDIT_LOOP_REPEAT, m_pMotif->m_dwRepeats, FALSE );
		}
		if( m_pMotif->m_dwRepeats == 0 )
		{
			OnResetLoop();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDoubleClickedInfinite

void CTabMotifLoop::OnDoubleClickedInfinite() 
{
	OnCheckInfinite();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnResetLoop

void CTabMotifLoop::OnResetLoop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Reset Loop Start/End 
		m_pMotif->ResetMotifLoopPoints();

		// Update Loop Start Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDoubleClickedResetLoop

void CTabMotifLoop::OnDoubleClickedResetLoop() 
{
	OnResetLoop();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopStartBar

void CTabMotifLoop::OnKillFocusEditLoopStartBar() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartBar;
		m_editStartBar.GetWindowText( strNewStartBar );

		// Strip leading and trailing spaces
		strNewStartBar.TrimRight();
		strNewStartBar.TrimLeft();

		if( strNewStartBar.IsEmpty() )
		{
			m_spinStartBar.SetPos( lOrigBar );
		}
		else
		{
			long lNewBar = _ttoi( strNewStartBar );
			lNewBar = max( lNewBar, 1 );
			lNewBar = min( lNewBar, m_pMotif->m_wNbrMeasures );

			// Set new Loop Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
			m_pMotif->SetMotifLoopStart( mtNewMusicTime );

			// Update Loop Start Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopStartBeat

void CTabMotifLoop::OnKillFocusEditLoopStartBeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartBeat;
		m_editStartBeat.GetWindowText( strNewStartBeat );

		// Strip leading and trailing spaces
		strNewStartBeat.TrimRight();
		strNewStartBeat.TrimLeft();

		if( strNewStartBeat.IsEmpty() )
		{
			m_spinStartBeat.SetPos( lOrigBeat );
		}
		else
		{
			long lNewBeat = _ttoi( strNewStartBeat );
			lNewBeat = max( lNewBeat, 1 );
			lNewBeat = min( lNewBeat, m_pMotif->m_TimeSignature.m_bBeatsPerMeasure );

			// Set new Loop Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				lNewBeat--;
				m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifLoopStart( mtNewMusicTime );

			// Update Loop Start Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopStartGrid

void CTabMotifLoop::OnKillFocusEditLoopStartGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartGrid;
		m_editStartGrid.GetWindowText( strNewStartGrid );

		// Strip leading and trailing spaces
		strNewStartGrid.TrimRight();
		strNewStartGrid.TrimLeft();

		if( strNewStartGrid.IsEmpty() )
		{
			m_spinStartGrid.SetPos( lOrigGrid );
		}
		else
		{
			long lNewGrid = _ttoi( strNewStartGrid );
			lNewGrid = max( lNewGrid, 1 );
			lNewGrid = min( lNewGrid, m_pMotif->m_TimeSignature.m_wGridsPerBeat );

			// Set new Loop Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				lNewGrid--;
				m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifLoopStart( mtNewMusicTime );

			// Update Loop Start Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopStartTick

void CTabMotifLoop::OnKillFocusEditLoopStartTick() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		long lClocksPerBeat = DM_PPQNx4 / (long)m_pMotif->m_TimeSignature.m_bBeat;
		long lClocksPerGrid = lClocksPerBeat / (long)m_pMotif->m_TimeSignature.m_wGridsPerBeat;
				
		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartTick;
		m_editStartTick.GetWindowText( strNewStartTick );

		// Strip leading and trailing spaces
		strNewStartTick.TrimRight();
		strNewStartTick.TrimLeft();

		if( strNewStartTick.IsEmpty() )
		{
			m_spinStartTick.SetPos( lOrigTick );
		}
		else
		{
			long lNewTick = _ttoi( strNewStartTick );
			lNewTick = max( lNewTick, 0 );
			lNewTick = min( lNewTick, lClocksPerGrid - 1 );

			// Set new Loop Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lOrigGrid, lNewTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				m_pMotif->SetMotifLoopStart( (long)m_pMotif->m_dwLength - 1 );
			}
			else
			{
				m_pMotif->SetMotifLoopStart( mtNewMusicTime );
			}

			// Update Loop Start Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopStartBar

void CTabMotifLoop::OnDeltaPosSpinLoopStartBar( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Bar
		long lNewBar = m_spinStartBar.GetPos() + pNMUpDown->iDelta;
		lNewBar = max( lNewBar, 1 );
		lNewBar = min( lNewBar, m_pMotif->m_wNbrMeasures );

		// Set new Loop Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
											  &mtNewMusicTime );
		if( m_pMotif->SetMotifLoopStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartBar.SetFocus();
		}

		// Update Loop Start Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopStartBeat

void CTabMotifLoop::OnDeltaPosSpinLoopStartBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Beat
		long lNewBeat = m_spinStartBeat.GetPos() + pNMUpDown->iDelta;
		lNewBeat = max( lNewBeat, 1 );

		// Set new Loop Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
		{
			lNewBeat--;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
		}

		if( m_pMotif->SetMotifLoopStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartBeat.SetFocus();
		}

		// Update Loop Start Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopStartGrid

void CTabMotifLoop::OnDeltaPosSpinLoopStartGrid( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Grid
		long lNewGrid = m_spinStartGrid.GetPos() + pNMUpDown->iDelta;
		lNewGrid = max( lNewGrid, 1 );

		// Set new Loop Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
		{
			lNewGrid--;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
												  &mtNewMusicTime );
		}

		if( m_pMotif->SetMotifLoopStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartGrid.SetFocus();
		}

		// Update Loop Start Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopStartTick

void CTabMotifLoop::OnDeltaPosSpinLoopStartTick( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Tick
		long lNewTick = m_spinStartTick.GetPos() + pNMUpDown->iDelta;
		lNewTick = max( lNewTick, 0 );

		// Set new Loop Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lOrigGrid, lNewTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
		{
			mtNewMusicTime = (long)m_pMotif->m_dwLength - 1;
		}

		if( m_pMotif->SetMotifLoopStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartTick.SetFocus();
		}

		// Update Loop Start Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopEndBar

void CTabMotifLoop::OnKillFocusEditLoopEndBar() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewEndBar;
		m_editEndBar.GetWindowText( strNewEndBar );

		// Strip leading and trailing spaces
		strNewEndBar.TrimRight();
		strNewEndBar.TrimLeft();

		if( strNewEndBar.IsEmpty() )
		{
			m_spinEndBar.SetPos( lOrigBar );
		}
		else
		{
			long lNewBar = _ttoi( strNewEndBar );
			lNewBar = max( lNewBar, 1 );
			lNewBar = min( lNewBar, m_pMotif->m_wNbrMeasures + 1 );

			// Set new Loop End 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
			m_pMotif->SetMotifLoopEnd( mtNewMusicTime );

			// Update Loop End Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopEndBeat

void CTabMotifLoop::OnKillFocusEditLoopEndBeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewEndBeat;
		m_editEndBeat.GetWindowText( strNewEndBeat );

		// Strip leading and trailing spaces
		strNewEndBeat.TrimRight();
		strNewEndBeat.TrimLeft();

		if( strNewEndBeat.IsEmpty() )
		{
			m_spinEndBeat.SetPos( lOrigBeat );
		}
		else
		{
			long lNewBeat = _ttoi( strNewEndBeat );
			lNewBeat = max( lNewBeat, 1 );
			lNewBeat = min( lNewBeat, m_pMotif->m_TimeSignature.m_bBeatsPerMeasure );

			// Set new Loop End 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime > (long)m_pMotif->m_dwLength )
			{
				lNewBeat--;
				m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifLoopEnd( mtNewMusicTime );

			// Update Loop End Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopEndGrid

void CTabMotifLoop::OnKillFocusEditLoopEndGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewEndGrid;
		m_editEndGrid.GetWindowText( strNewEndGrid );

		// Strip leading and trailing spaces
		strNewEndGrid.TrimRight();
		strNewEndGrid.TrimLeft();

		if( strNewEndGrid.IsEmpty() )
		{
			m_spinEndGrid.SetPos( lOrigGrid );
		}
		else
		{
			long lNewGrid = _ttoi( strNewEndGrid );
			lNewGrid = max( lNewGrid, 1 );
			lNewGrid = min( lNewGrid, m_pMotif->m_TimeSignature.m_wGridsPerBeat );

			// Set new Loop End 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime > (long)m_pMotif->m_dwLength )
			{
				lNewGrid--;
				m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifLoopEnd( mtNewMusicTime );

			// Update Loop End Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnKillFocusEditLoopEndTick

void CTabMotifLoop::OnKillFocusEditLoopEndTick() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		long lClocksPerBeat = DM_PPQNx4 / (long)m_pMotif->m_TimeSignature.m_bBeat;
		long lClocksPerGrid = lClocksPerBeat / (long)m_pMotif->m_TimeSignature.m_wGridsPerBeat;
				
		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewEndTick;
		m_editEndTick.GetWindowText( strNewEndTick );

		// Strip leading and trailing spaces
		strNewEndTick.TrimRight();
		strNewEndTick.TrimLeft();

		if( strNewEndTick.IsEmpty() )
		{
			m_spinEndTick.SetPos( lOrigTick );
		}
		else
		{
			long lNewTick = _ttoi( strNewEndTick );
			lNewTick = max( lNewTick, 0 );
			lNewTick = min( lNewTick, lClocksPerGrid - 1 );

			// Set new Loop End 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lOrigGrid, lNewTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime > (long)m_pMotif->m_dwLength )
			{
				m_pMotif->SetMotifLoopEnd( (long)m_pMotif->m_dwLength );
			}
			else
			{
				m_pMotif->SetMotifLoopEnd( mtNewMusicTime );
			}

			// Update Loop End Bar, Beat, Grid, Tick controls
			UpdateLoopStartEndControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopEndBar

void CTabMotifLoop::OnDeltaPosSpinLoopEndBar( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Bar
		long lNewBar = m_spinEndBar.GetPos() + pNMUpDown->iDelta;
		lNewBar = max( lNewBar, 1 );
		lNewBar = min( lNewBar, m_pMotif->m_wNbrMeasures + 1 );

		// Set new Loop End 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
											  &mtNewMusicTime );
		if( m_pMotif->SetMotifLoopEnd( mtNewMusicTime ) == FALSE )
		{
			m_editEndBar.SetFocus();
		}

		// Update Loop End Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopEndBeat

void CTabMotifLoop::OnDeltaPosSpinLoopEndBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Beat
		long lNewBeat = m_spinEndBeat.GetPos() + pNMUpDown->iDelta;
		lNewBeat = max( lNewBeat, 1 );

		// Set new Loop End 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime > (long)m_pMotif->m_dwLength )
		{
			lNewBeat--;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
		}

		if( m_pMotif->SetMotifLoopEnd( mtNewMusicTime ) == FALSE )
		{
			m_editEndBeat.SetFocus();
		}

		// Update Loop End Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopEndGrid

void CTabMotifLoop::OnDeltaPosSpinLoopEndGrid( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Grid
		long lNewGrid = m_spinEndGrid.GetPos() + pNMUpDown->iDelta;
		lNewGrid = max( lNewGrid, 1 );

		// Set new Loop End 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime > (long)m_pMotif->m_dwLength )
		{
			lNewGrid--;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
												  &mtNewMusicTime );
		}

		if( m_pMotif->SetMotifLoopEnd( mtNewMusicTime ) == FALSE )
		{
			m_editEndGrid.SetFocus();
		}

		// Update Loop End Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop::OnDeltaPosSpinLoopEndTick

void CTabMotifLoop::OnDeltaPosSpinLoopEndTick( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtLoopEnd
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtLoopEnd,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Tick
		long lNewTick = m_spinEndTick.GetPos() + pNMUpDown->iDelta;
		lNewTick = max( lNewTick, 0 );

		// Set new Loop End 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lOrigGrid, lNewTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime > (long)m_pMotif->m_dwLength )
		{
			mtNewMusicTime = (long)m_pMotif->m_dwLength;
		}

		if( m_pMotif->SetMotifLoopEnd( mtNewMusicTime ) == FALSE )
		{
			m_editEndTick.SetFocus();
		}

		// Update Loop End Bar, Beat, Grid, Tick controls
		UpdateLoopStartEndControls();
	}

	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\styleriff.cpp ===
#include "stdafx.h"
#include "templates.h"
#include "..\includes\DMUSProd.h"
#include "DLLJazzDataObject.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#include <dmusicf.h>
#pragma warning( pop )

#include "styleriff.h"
#include "MIDIFile.h"


HRESULT SequenceChunk :: Extract(const DMUS_IO_SEQ_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_SEQ_ITEM*>(this), &item, sizeof(DMUS_IO_SEQ_ITEM));
	return S_OK;
}

HRESULT SequenceChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_SEQ_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_SEQ_ITEM*>(this), sizeof(DMUS_IO_SEQ_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_SEQ_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

HRESULT TempoChunk :: Extract(const DMUS_IO_TEMPO_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_TEMPO_ITEM*>(this), &item, sizeof(DMUS_IO_TEMPO_ITEM));
	return S_OK;
}

HRESULT TempoChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_TEMPO_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_TEMPO_ITEM*>(this), sizeof(DMUS_IO_TEMPO_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_TEMPO_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

HRESULT SysexChunk :: Extract(const DMUS_IO_SYSEX_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_SYSEX_ITEM*>(this), &item, sizeof(DMUS_IO_SYSEX_ITEM));
	return S_OK;
}

HRESULT SysexChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_SYSEX_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_SYSEX_ITEM*>(this), sizeof(DMUS_IO_SYSEX_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_SYSEX_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

HRESULT TimeSignatureChunk :: Extract(const DMUS_IO_TIMESIGNATURE_ITEM& item)
{
	memcpy(dynamic_cast<DMUS_IO_TIMESIGNATURE_ITEM*>(this), &item, sizeof(DMUS_IO_TIMESIGNATURE_ITEM));
	return S_OK;
}

HRESULT TimeSignatureChunk :: Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(pRiffStream == 0)
		return E_INVALIDARG;
	WriteChunk chunk(pRiffStream, DMUS_FOURCC_TIMESIGNATURE_TRACK);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		IStream* pStream = pRiffStream->GetStream();
		ASSERT(pStream);
		if(pStream == 0)
			return E_FAIL;
		DWORD dw;
		hr = pStream->Write(dynamic_cast<DMUS_IO_TIMESIGNATURE_ITEM*>(this), sizeof(DMUS_IO_TIMESIGNATURE_ITEM), &dw);
		hr = (hr == S_OK) && (dw == sizeof(DMUS_IO_TIMESIGNATURE_ITEM)) ? S_OK : E_FAIL;
		pStream->Release();
	}
	return hr;
}

///////////////////////////////////////////////////// Band Riff Objects
///



HRESULT ListOfBands::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	HRESULT hr;
	WriteListChunk	list(pRiffStream, DMUS_FOURCC_BANDS_LIST);
	hr = list.State();
	if(hr == S_OK)
	{
		// put all patch changes occurring simultaneously in same band
		DMUS_IO_PATCH_ITEM*	plist = pPatchList;
		while(SUCCEEDED(hr) && plist)
		{
			DMUS_IO_PATCH_ITEM*	phead = plist;
			DMUS_IO_PATCH_ITEM* ptemp;
			while(plist->pNext && plist->lTime == plist->pNext->lTime)
			{
				plist = plist->pNext;
			}
			if(plist->pNext)
			{
				ptemp = plist->pNext;
				plist->pNext = 0;
				plist = ptemp;	// start here next time around
			}
			else
			{
				plist = 0;
			}
			BandList bandlist(phead);
			hr = bandlist.Write(pRiffStream);
			List_Free(phead);
		}
	}
	return hr;
	
}


HRESULT ListOfInst::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(!pRiffStream)
		return E_INVALIDARG;

	WriteListChunk list(pRiffStream, DMUS_FOURCC_INSTRUMENTS_LIST);
	HRESULT hr = list.State();
	if(hr == S_OK)
	{
		for(DMUS_IO_PATCH_ITEM* p = pPatchList; p && (hr == S_OK); p = p->pNext)
		{
			InstList instlist(*p);
			hr = instlist.Write(pRiffStream, lstVol ? lstVol[(p->byStatus & 0xF)] : NULL, lstPan ? lstPan[(p->byStatus & 0xF)] : NULL);
		}
	}
	return hr;
}

HRESULT InstList::Write(IDMUSProdRIFFStream* pRiffStream, FullSeqEvent *pVol, FullSeqEvent *pPan)
{
	ASSERT(pRiffStream);
	if(!pRiffStream)
		return E_INVALIDARG;
	WriteListChunk list(pRiffStream, DMUS_FOURCC_INSTRUMENT_LIST);
	HRESULT hr = list.State();
	if(hr == S_OK)
	{
		InstChunk inst(*this);
		if( pVol )
		{
			inst.bVolume = pVol->bByte2;
			inst.dwFlags |= DMUS_IO_INST_VOLUME;
		}
		if( pPan )
		{
			inst.bPan = pPan->bByte2;
			inst.dwFlags |= DMUS_IO_INST_PAN;
		}
		hr = inst.Write(pRiffStream);
	}
	return hr;
}

HRESULT BandList::Write(IDMUSProdRIFFStream* pRiffStream)
{
	ASSERT(pRiffStream);
	if(!pRiffStream)
		return E_INVALIDARG;

	WriteListChunk list(pRiffStream, DMUS_FOURCC_BAND_LIST);
	HRESULT hr = list.State();
	if(hr == S_OK)
	{
		BandHeader header(*pPatchList);
		hr = header.Write(pRiffStream);
		if(hr == S_OK)
		{
			WriteRiffChunk riff(pRiffStream, DMUS_FOURCC_BAND_FORM);
			hr = riff.State();
			if(hr == S_OK)
			{
				ListOfInst listinst(pPatchList, NULL, NULL);
				hr = listinst.Write(pRiffStream);
			}
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\styleriff.h ===
#ifndef SEGMENTRIFF_H
#define SEGMENTRIFF_H


#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicf.h>
#pragma warning( pop )
#include "..\shared\dmuspriv.h"
#include "riffstrm.h"

bool IsXG();	// defined in style.cpp

inline HRESULT ReadWord(IDMUSProdRIFFStream* pIRiffStream, WORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteWord(IDMUSProdRIFFStream* pIRiffStream, WORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}
// chunk navigators
class WriteChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.ckid = id;
		m_pRiffStream = pRiffStream;
		m_hr = pRiffStream->CreateChunk( &m_ck, 0 );
	}
	HRESULT	State(MMCKINFO* pck = 0)
	{
		if(pck)
		{
			memcpy(pck,  &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid == FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};

// list navigators
class WriteListChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteListChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATELIST );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteListChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

// Riff navigators
class WriteRiffChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteRiffChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATERIFF );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteRiffChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

////////////////////////////////////////////////////// Segment RIFF Objects
//
class SequenceChunk : public DMUS_IO_SEQ_ITEM
{
public:
	SequenceChunk() {}
	SequenceChunk(const DMUS_IO_SEQ_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_SEQ_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class TempoChunk : public DMUS_IO_TEMPO_ITEM
{
public:
	TempoChunk() {}
	TempoChunk(const DMUS_IO_TEMPO_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_TEMPO_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class SysexChunk : public DMUS_IO_SYSEX_ITEM
{
public:
	SysexChunk() {}
	SysexChunk(const DMUS_IO_SYSEX_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_SYSEX_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class TimeSignatureChunk : public DMUS_IO_TIMESIGNATURE_ITEM
{
	TimeSignatureChunk() {}
	TimeSignatureChunk(const DMUS_IO_TIMESIGNATURE_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_TIMESIGNATURE_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class TrackHeaderChunk : public DMUS_IO_TRACK_HEADER
{
public:
	TrackHeaderChunk(GUID guid, FOURCC id, FOURCC type) 
	{
		guidClassID = guid;
		ckid = id;
		fccType = type;
		dwPosition = 0;	// this is undetermined
		dwGroup = 1;	// so is this
	}
	TrackHeaderChunk(GUID guid, FOURCC id, FOURCC type, DWORD position, DWORD group)
	{
		guidClassID = guid;
		ckid = id;
		fccType = type;
		dwPosition = position;
		dwGroup = group;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_TRACK_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_TRACK_HEADER*>(this),
											  sizeof(DMUS_IO_TRACK_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_TRACK_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////// BandTrack Riff Objects
///
#ifndef DMBI_PATCH
// Flags for CBandInstrument::m_dwFlags. When set, a flag indicates that the 
// corresponding field in CBandInstrument should be used to generate
// a MIDI event as well as information about the instrument

#define DMBI_PATCH			(1 << 0)		// m_dwPatch is valid.
#define DMBI_VOLUME			(1 << 1)		// m_bVolume is valid
#define DMBI_PAN			(1 << 2)		// m_bPan is valid
#define DMBI_BANKSELECT_MSB	(1 << 3)		// m_dwPatch contains a valid Bank Select MSB part
#define DMBI_BANKSELECT_LSB	(1 << 4)		// m_dwPatch contains a valid Bank Select LSB part
#define DMBI_GM				(1 << 5)		// Instrument is from GM collection
#define DMBI_GS				(1 << 6)		// Instrument is from GS collection
#define DMBI_ASSIGN_PATCH	(1 << 7)		// m_AssignPatch is valid
#define DMBI_TRANSPOSE		(1 << 8)		// m_nTranspose
#endif

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time



class BandTrackHeader : public DMUS_IO_BAND_TRACK_HEADER
{
public:
	BandTrackHeader(BOOL fAutoDownload = TRUE) 
	{
		bAutoDownload = fAutoDownload;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_BANDTRACK_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_BAND_TRACK_HEADER*>(this),
											  sizeof(DMUS_IO_BAND_TRACK_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_BAND_TRACK_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

struct FullSeqEvent;

class ListOfInst
{
	DMUS_IO_PATCH_ITEM*	pPatchList;
	FullSeqEvent** lstVol;
	FullSeqEvent** lstPan;
public:
	ListOfInst(DMUS_IO_PATCH_ITEM* p, FullSeqEvent* pVol[16], FullSeqEvent* pPan[16]) : pPatchList(p), lstVol(pVol), lstPan(pPan) {}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class InstList : public DMUS_IO_PATCH_ITEM
{
public:
	InstList(const DMUS_IO_PATCH_ITEM& item)
	{
		memcpy(dynamic_cast<DMUS_IO_PATCH_ITEM*>(this), &item, sizeof(DMUS_IO_PATCH_ITEM));
		pIDMCollection = 0;
		pNext = 0;	
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream, FullSeqEvent *pVol, FullSeqEvent *pPan);
};

class InstChunk : public DMUS_IO_INSTRUMENT
{
public:
	InstChunk(const DMUS_IO_PATCH_ITEM& item)
	{
		memset(dynamic_cast<DMUS_IO_INSTRUMENT*>(this), 0, sizeof(DMUS_IO_INSTRUMENT));
		dwFlags = item.dwFlags;
		if(dwFlags & DMBI_PATCH)
		{
			dwPatch |= item.byPChange & 0x7F;
		}
		if(dwFlags & DMBI_BANKSELECT_LSB)
		{
			dwPatch |= (item.byLSB & 0x7F) << 16;
		}
		if(dwFlags & DMBI_BANKSELECT_MSB)
		{
			dwPatch |= (item.byMSB & 0x7F) << 24;
		}

		dwPChannel = item.byStatus & 0xF;
		if(dwPChannel == 0x9 && !IsXG())
		{
			dwPatch |= F_INSTRUMENT_DRUMS;
		}

		bVolume = 64;
		bPan = 64;
		nPitchBendRange = 2;

		for(int i= 0; i < 4; i++)
			dwNoteRanges[i] = 0xFFFFFFFF;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_INSTRUMENT_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_INSTRUMENT*>(this),
											  sizeof(DMUS_IO_INSTRUMENT), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_INSTRUMENT)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

class BandHeader : public DMUS_IO_BAND_ITEM_HEADER
{
public:
	BandHeader(const DMUS_IO_PATCH_ITEM& item)
	{
		lBandTime = item.lTime;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_BANDITEM_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_BAND_ITEM_HEADER*>(this),
											  sizeof(DMUS_IO_BAND_ITEM_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_BAND_ITEM_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

class BandList
{
	DMUS_IO_PATCH_ITEM*	pPatchList;
public:
	BandList(DMUS_IO_PATCH_ITEM* p) : pPatchList(p) {}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class ListOfBands
{
	DMUS_IO_PATCH_ITEM*	pPatchList;
public:
	ListOfBands(DMUS_IO_PATCH_ITEM* p) : pPatchList(p) {}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);	// deletes pPatchList
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabMotifMotif.cpp ===
// TabMotifMotif.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "PatternLengthDlg.h"
#include "TimeSignatureDlg.h"
#include "TabMotifMotif.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif property page

CTabMotifMotif::CTabMotifMotif( CMotifPropPageManager* pMotifPropPageManager ) : CPropertyPage(CTabMotifMotif::IDD)
{
	//{{AFX_DATA_INIT(CTabMotifMotif)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	ASSERT( pMotifPropPageManager != NULL );

	m_pMotif = NULL;
	m_pPageManager = pMotifPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabMotifMotif::~CTabMotifMotif()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::RefreshTab

void CTabMotifMotif::RefreshTab( IDMUSProdPropPageObject* pIPropPageObject )
{
	PPGMotif ppgMotif;
	PPGMotif* pPPGMotif = &ppgMotif;

	if( pIPropPageObject
	&& ( SUCCEEDED ( pIPropPageObject->GetData((void **)&pPPGMotif ) ) ) )
	{
		m_pMotif = ppgMotif.pMotif;
	}
	else
	{
		m_pMotif = NULL;
	}

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::EnableControls

void CTabMotifMotif::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_btnLength.EnableWindow( fEnable );

	m_editStartBar.EnableWindow( fEnable );
	m_spinStartBar.EnableWindow( fEnable );
	m_editStartBeat.EnableWindow( fEnable );
	m_spinStartBeat.EnableWindow( fEnable );
	m_editStartGrid.EnableWindow( fEnable );
	m_spinStartGrid.EnableWindow( fEnable );
	m_editStartTick.EnableWindow( fEnable );
	m_spinStartTick.EnableWindow( fEnable );
	m_btnTimeSignature.EnableWindow( fEnable );

	m_btnResetVarOrder.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::UpdatePlayStartControls

void CTabMotifMotif::UpdatePlayStartControls()
{
	if( m_pMotif )
	{
		// Get Bar, Beat, Grid, Tick of mtPlayStart
		long lBar;
		long lBeat;
		long lGrid;
		long lTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart, &lBar, &lBeat, &lGrid, &lTick );

		// Set Start Bar, beat, Grid, Tick
		m_spinStartBar.SetPos( lBar );
		m_spinStartBeat.SetPos( lBeat );
		m_spinStartGrid.SetPos( lGrid );
		m_spinStartTick.SetPos( lTick );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::UpdateControls

void CTabMotifMotif::UpdateControls()
{
	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pMotif )
	{
		EnableControls( TRUE );

		// Set Name
		m_editName.SetWindowText( m_pMotif->m_strName );
		
		// Set Length
		CString strLength;
		strLength.Format( "%d", m_pMotif->m_wNbrMeasures );
		m_btnLength.SetWindowText( strLength );

		// Set Bar, Beat, Grid, Tick
		UpdatePlayStartControls();

		// Update bitmap on time signature button
		SetTimeSignatureBitmap();

		// Update the Reset Variation Order checkbox (the button state is the inverse of the flag setting)
		m_btnResetVarOrder.SetCheck( m_pMotif->m_dwFlags & DMUS_PATTERNF_PERSIST_CONTROL ? BST_UNCHECKED : BST_CHECKED );
	}
	else
	{
		m_editName.SetWindowText( _T("") );
		m_btnLength.SetWindowText( _T("") );
		m_spinStartBar.SetPos( 1 );
		m_spinStartBeat.SetPos( 1 );
		m_spinStartGrid.SetPos( 1 );
		m_spinStartTick.SetPos( 0 );

		m_btnResetVarOrder.SetCheck( BST_UNCHECKED );

		EnableControls( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::SetTimeSignatureBitmap

void CTabMotifMotif::SetTimeSignatureBitmap( void )
{
	if( !::IsWindow( m_btnTimeSignature.m_hWnd ) )
	{
		return;
	}

	HBITMAP hNewBits = NULL;

	ASSERT( m_pMotif != NULL );

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	// Write text
	CString strTimeSignature;

	CFont font;
	CFont* pfontOld = NULL;
	
	if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		pfontOld = cdcDest.SelectObject( &font );
	}

	strTimeSignature.Format( "%d/%d",
							 m_pMotif->m_TimeSignature.m_bBeatsPerMeasure,
							 m_pMotif->m_TimeSignature.m_bBeat );
	rect.left += 6;
	cdcDest.SetTextColor( COLOR_BTNTEXT );
	cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_NOPREFIX) );
	rect.left -= 6;

	if( pfontOld )
	{
		cdcDest.SelectObject( pfontOld );
		font.DeleteObject();
	}

	// Set x coord for 'Grids Per Beat' image
	CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
	int nX = max( 48, (sizeText.cx + 8) );

	// Draw "splitter"
	{
		CPen pen1;
		CPen pen2;
		CPen* ppenOld;

		int nPlace = nX - 6;
		int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

		// Highlight
		if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen1 );
			cdcDest.MoveTo( nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		// Shadow
		if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen2 );
			cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		if( nModeOld )
		{
			cdcDest.SetROP2( nModeOld );
		}
	}

	// Add 'Grids Per Beat' bitmap
	{
		int nResourceID = m_pMotif->m_TimeSignature.m_wGridsPerBeat - 1;
		if( m_pMotif->m_TimeSignature.m_bBeat != 4 )		// 4 = quarter note gets the beat
		{
			nResourceID += MAX_GRIDS_PER_BEAT;
		}
		ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );

		if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
		{
			BITMAP bm;

			bmpGridsPerBeat.GetBitmap( &bm );

			int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

			CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

			{
				CDC cdcMono;
				CBitmap bmpMono;

				if( cdcMono.CreateCompatibleDC( &cdcDest )
				&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
				{
					CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
					
					cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
					cdcDest.SetBkColor( RGB(255,255,255) );

					cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCCOPY);
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcMono, 0, 0, SRCAND ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;

					cdcMono.SelectObject( pbmpOldMono ) ;
				}
			}

			cdcGridsPerBeat.SelectObject( pbmpOld );
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}


void CTabMotifMotif::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabMotifMotif)
	DDX_Control(pDX, IDC_CHECK_RESET_VAR_ORDER, m_btnResetVarOrder);
	DDX_Control(pDX, IDC_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_BAR, m_editStartBar);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_LENGTH, m_btnLength);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_BAR, m_spinStartBar);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_TICK, m_spinStartTick);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabMotifMotif, CPropertyPage)
	//{{AFX_MSG_MAP(CTabMotifMotif)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_LENGTH, OnLength)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_BAR, OnKillFocusEditPlayStartBar)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_BEAT, OnKillFocusEditPlayStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_GRID, OnKillFocusEditPlayStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_TICK, OnKillFocusEditPlayStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_BAR, OnDeltaPosSpinPlayStartBar)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_BEAT, OnDeltaPosSpinPlayStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_GRID, OnDeltaPosSpinPlayStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_TICK, OnDeltaPosSpinPlayStartTick)
	ON_BN_CLICKED(IDC_TIME_SIGNATURE, OnTimeSignature)
	ON_BN_CLICKED(IDC_CHECK_RESET_VAR_ORDER, OnCheckResetVarOrder)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnSetActive

BOOL CTabMotifMotif::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnCreate

int CTabMotifMotif::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnDestroy

void CTabMotifMotif::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnInitDialog

BOOL CTabMotifMotif::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// Set control ranges
	m_spinStartBar.SetRange( 1, 32767 );
	m_editStartBar.LimitText( 5 );

	m_spinStartBeat.SetRange( 1, 256 );
	m_editStartBeat.LimitText( 3 );

	m_spinStartGrid.SetRange( 1, 256 );
	m_editStartGrid.LimitText( 3 );

	m_spinStartTick.SetRange( 0, 32767 );
	m_editStartTick.LimitText( 5 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnKillFocusName

void CTabMotifMotif::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pMotif )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pMotif->m_strName );
		}
		else
		{
			if( strName.Compare( m_pMotif->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pMotif->SetNodeName( bstrName );
				theApp.m_pStyleComponent->m_pIFramework->RefreshNode( m_pMotif );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnLength

void CTabMotifMotif::OnLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		CPatternLengthDlg plDlg( m_pMotif );

		if( plDlg.DoModal() == IDOK )
		{
			CString strLength;

			strLength.Format( "%d", m_pMotif->m_wNbrMeasures );
			m_btnLength.SetWindowText( strLength );
		}

		m_btnLength.SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnKillFocusEditPlayStartBar

void CTabMotifMotif::OnKillFocusEditPlayStartBar() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartBar;
		m_editStartBar.GetWindowText( strNewStartBar );

		// Strip leading and trailing spaces
		strNewStartBar.TrimRight();
		strNewStartBar.TrimLeft();

		if( strNewStartBar.IsEmpty() )
		{
			m_spinStartBar.SetPos( lOrigBar );
		}
		else
		{
			long lNewBar = _ttoi( strNewStartBar );
			lNewBar = max( lNewBar, 1 );
			lNewBar = min( lNewBar, m_pMotif->m_wNbrMeasures );

			// Set new Play Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				lNewBar--;
				m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifPlayStart( mtNewMusicTime );

			// Update Play Start Bar, Beat, Grid, Tick controls
			UpdatePlayStartControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnKillFocusEditPlayStartBeat

void CTabMotifMotif::OnKillFocusEditPlayStartBeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartBeat;
		m_editStartBeat.GetWindowText( strNewStartBeat );

		// Strip leading and trailing spaces
		strNewStartBeat.TrimRight();
		strNewStartBeat.TrimLeft();

		if( strNewStartBeat.IsEmpty() )
		{
			m_spinStartBeat.SetPos( lOrigBeat );
		}
		else
		{
			long lNewBeat = _ttoi( strNewStartBeat );
			lNewBeat = max( lNewBeat, 1 );
			lNewBeat = min( lNewBeat, m_pMotif->m_TimeSignature.m_bBeatsPerMeasure );

			// Set new Play Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				lNewBeat--;
				m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifPlayStart( mtNewMusicTime );

			// Update Play Start Bar, Beat, Grid, Tick controls
			UpdatePlayStartControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnKillFocusEditPlayStartGrid

void CTabMotifMotif::OnKillFocusEditPlayStartGrid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartGrid;
		m_editStartGrid.GetWindowText( strNewStartGrid );

		// Strip leading and trailing spaces
		strNewStartGrid.TrimRight();
		strNewStartGrid.TrimLeft();

		if( strNewStartGrid.IsEmpty() )
		{
			m_spinStartGrid.SetPos( lOrigGrid );
		}
		else
		{
			long lNewGrid = _ttoi( strNewStartGrid );
			lNewGrid = max( lNewGrid, 1 );
			lNewGrid = min( lNewGrid, m_pMotif->m_TimeSignature.m_wGridsPerBeat );

			// Set new Play Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				lNewGrid--;
				m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
													  &mtNewMusicTime );
			}
			m_pMotif->SetMotifPlayStart( mtNewMusicTime );

			// Update Play Start Bar, Beat, Grid, Tick controls
			UpdatePlayStartControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnKillFocusEditPlayStartTick

void CTabMotifMotif::OnKillFocusEditPlayStartTick() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		long lClocksPerBeat = DM_PPQNx4 / (long)m_pMotif->m_TimeSignature.m_bBeat;
		long lClocksPerGrid = lClocksPerBeat / (long)m_pMotif->m_TimeSignature.m_wGridsPerBeat;
				
		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get string from control
		CString strNewStartTick;
		m_editStartTick.GetWindowText( strNewStartTick );

		// Strip leading and trailing spaces
		strNewStartTick.TrimRight();
		strNewStartTick.TrimLeft();

		if( strNewStartTick.IsEmpty() )
		{
			m_spinStartTick.SetPos( lOrigTick );
		}
		else
		{
			long lNewTick = _ttoi( strNewStartTick );
			lNewTick = max( lNewTick, 0 );
			lNewTick = min( lNewTick, lClocksPerGrid - 1 );

			// Set new Play Start 
			MUSIC_TIME mtNewMusicTime;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lOrigGrid, lNewTick,
												  &mtNewMusicTime );
			if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
			{
				m_pMotif->SetMotifPlayStart( (long)m_pMotif->m_dwLength - 1 );
			}
			else
			{
				m_pMotif->SetMotifPlayStart( mtNewMusicTime );
			}

			// Update Play Start Bar, Beat, Grid, Tick controls
			UpdatePlayStartControls();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnDeltaPosSpinPlayStartBar

void CTabMotifMotif::OnDeltaPosSpinPlayStartBar( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Bar
		long lNewBar = m_spinStartBar.GetPos() + pNMUpDown->iDelta;
		lNewBar = max( lNewBar, 1 );
		lNewBar = min( lNewBar, m_pMotif->m_wNbrMeasures );

		// Set new Play Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lNewBar, lOrigBeat, lOrigGrid, lOrigTick,
											  &mtNewMusicTime );

		if( m_pMotif->SetMotifPlayStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartBar.SetFocus();
		}

		// Update Play Start Bar, Beat, Grid, Tick controls
		UpdatePlayStartControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnDeltaPosSpinPlayStartBeat

void CTabMotifMotif::OnDeltaPosSpinPlayStartBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Beat
		long lNewBeat = m_spinStartBeat.GetPos() + pNMUpDown->iDelta;
		lNewBeat = max( lNewBeat, 1 );

		// Set new Play Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
		{
			lNewBeat--;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lNewBeat, lOrigGrid, lOrigTick,
												  &mtNewMusicTime );
		}

		if( m_pMotif->SetMotifPlayStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartBeat.SetFocus();
		}

		// Update Play Start Bar, Beat, Grid, Tick controls
		UpdatePlayStartControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnDeltaPosSpinPlayStartGrid

void CTabMotifMotif::OnDeltaPosSpinPlayStartGrid( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Grid
		long lNewGrid = m_spinStartGrid.GetPos() + pNMUpDown->iDelta;
		lNewGrid = max( lNewGrid, 1 );

		// Set new Play Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
		{
			lNewGrid--;
			m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lNewGrid, lOrigTick,
												  &mtNewMusicTime );
		}

		if( m_pMotif->SetMotifPlayStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartGrid.SetFocus();
		}

		// Update Play Start Bar, Beat, Grid, Tick controls
		UpdatePlayStartControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnDeltaPosSpinPlayStartTick

void CTabMotifMotif::OnDeltaPosSpinPlayStartTick( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Get original Bar, Beat, Grid, Tick of mtPlayStart
		long lOrigBar;
		long lOrigBeat;
		long lOrigGrid;
		long lOrigTick;
		m_pMotif->MusicTimeToBarBeatGridTick( m_pMotif->m_mtPlayStart,
											  &lOrigBar, &lOrigBeat, &lOrigGrid, &lOrigTick );

		// Get new Tick
		long lNewTick = m_spinStartTick.GetPos() + pNMUpDown->iDelta;
		lNewTick = max( lNewTick, 0 );

		// Set new Play Start 
		MUSIC_TIME mtNewMusicTime;
		m_pMotif->BarBeatGridTickToMusicTime( lOrigBar, lOrigBeat, lOrigGrid, lNewTick,
											  &mtNewMusicTime );
		if( mtNewMusicTime >= (long)m_pMotif->m_dwLength )
		{
			mtNewMusicTime = (long)m_pMotif->m_dwLength - 1;
		}

		if( m_pMotif->SetMotifPlayStart( mtNewMusicTime ) == FALSE )
		{
			m_editStartTick.SetFocus();
		}

		// Update Play Start Bar, Beat, Grid, Tick controls
		UpdatePlayStartControls();
	}

	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif::OnTimeSignature

void CTabMotifMotif::OnTimeSignature() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		CTimeSignatureDlg tsDlg;

		tsDlg.m_TimeSignature = m_pMotif->m_TimeSignature;
		tsDlg.m_nContext = IDS_MOTIF_TEXT;

		if( tsDlg.DoModal() == IDOK )
		{
			// Update time signature
			AfxMessageBox( "Not yet implemented." );
// AMC??	m_pMotif->SetTimeSignature( tsDlg.m_TimeSignature, FALSE );

			// Update bitmap on time signature button
			SetTimeSignatureBitmap();
		}

		if( ::IsWindow( m_btnTimeSignature.m_hWnd ) )
		{
			m_btnTimeSignature.SetFocus();
		}
	}
}

void CTabMotifMotif::OnCheckResetVarOrder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pMotif )
	{
		DWORD dwFlags = m_pMotif->m_dwFlags;

		// Get the state of the Reset Variation Order checkbox
		// (the button state is the inverse of the flag setting)
		if( m_btnResetVarOrder.GetCheck() == BST_CHECKED )
		{
			dwFlags &= ~DMUS_PATTERNF_PERSIST_CONTROL;
		}
		else
		{
			dwFlags |= DMUS_PATTERNF_PERSIST_CONTROL;
		}

		m_pMotif->SetFlags( dwFlags );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabPatternPattern.cpp ===
// TabPatternPattern.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "Pattern.h"
#include "PatternLengthDlg.h"
#include "TimeSignatureDlg.h"
#include "RhythmDlg.h"
#include "TabPatternPattern.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern property page

CTabPatternPattern::CTabPatternPattern( CPatternPropPageManager* pPatternPropPageManager ) : CPropertyPage(CTabPatternPattern::IDD)
{
	//{{AFX_DATA_INIT(CTabPatternPattern)
	//}}AFX_DATA_INIT
	
	ASSERT( pPatternPropPageManager != NULL );

	m_pPattern = NULL;
	m_pPageManager = pPatternPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabPatternPattern::~CTabPatternPattern()
{
	// Work around 27331
	m_pPattern = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::RefreshTab

void CTabPatternPattern::RefreshTab( IDMUSProdPropPageObject* pIPropPageObject )
{
	PPGPattern ppgPattern;
	PPGPattern* pPPGPattern = &ppgPattern;

	if( pIPropPageObject
	&& ( SUCCEEDED ( pIPropPageObject->GetData((void **)&pPPGPattern ) ) ) )
	{
		m_pPattern = ppgPattern.pPattern;
	}
	else
	{
		m_pPattern = NULL;
	}

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::EnableControls

void CTabPatternPattern::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_btnLength.EnableWindow( fEnable );
	m_editGrooveBottom.EnableWindow( fEnable );
	m_spinGrooveBottom.EnableWindow( fEnable );
	m_editGrooveTop.EnableWindow( fEnable );
	m_spinGrooveTop.EnableWindow( fEnable );
	m_editDestBottom.EnableWindow( fEnable );
	m_spinDestBottom.EnableWindow( fEnable );
	m_editDestTop.EnableWindow( fEnable );
	m_spinDestTop.EnableWindow( fEnable );
	m_btnIntro.EnableWindow( fEnable );
	m_btnFill.EnableWindow( fEnable );
	m_btnBreak.EnableWindow( fEnable );
	m_btnEnd.EnableWindow( fEnable );
	m_btnCustom.EnableWindow( fEnable );
	m_editCustomId.EnableWindow( fEnable );
	m_spinCustomId.EnableWindow( fEnable );
	m_btnTimeSignature.EnableWindow( fEnable );
	m_btnCustomDlg.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::UpdateControls

void CTabPatternPattern::UpdateControls()
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );
	m_editGrooveBottom.LimitText( 3 );
	m_editGrooveTop.LimitText( 3 );
	m_editDestBottom.LimitText( 3 );
	m_editDestTop.LimitText( 3 );
	m_editCustomId.LimitText( 3 );

	if( m_pPattern )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pPattern->m_strName );
		
		// Set length
		CString strLength;
		strLength.Format( "%d", m_pPattern->m_wNbrMeasures );
		m_btnLength.SetWindowText( strLength );

		// Set Bottom Groove
		m_spinGrooveBottom.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinGrooveBottom.SetPos( m_pPattern->m_bGrooveBottom );

		// Set Top Groove 
		m_spinGrooveTop.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinGrooveTop.SetPos( m_pPattern->m_bGrooveTop );

		// Set Destination Bottom Groove
		m_spinDestBottom.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinDestBottom.SetPos( m_pPattern->m_bDestGrooveBottom );

		// Set Destination Top Groove 
		m_spinDestTop.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinDestTop.SetPos( m_pPattern->m_bDestGrooveTop );

		// Set Embellishments 
		m_btnIntro.SetCheck( (m_pPattern->m_wEmbellishment & EMB_INTRO) ? TRUE : FALSE );
		m_btnFill.SetCheck( (m_pPattern->m_wEmbellishment & EMB_FILL) ? TRUE : FALSE );
		m_btnBreak.SetCheck( (m_pPattern->m_wEmbellishment & EMB_BREAK) ? TRUE : FALSE );
		m_btnEnd.SetCheck( (m_pPattern->m_wEmbellishment & EMB_END) ? TRUE : FALSE );

		// Set User-defined Embellishment
		BOOL fCustomEmbellishment = FALSE;
		if( HIBYTE(m_pPattern->m_wEmbellishment) >= MIN_EMB_CUSTOM_ID
		&&  HIBYTE(m_pPattern->m_wEmbellishment) <= MAX_EMB_CUSTOM_ID )
		{
			fCustomEmbellishment = TRUE;
			ASSERT( LOBYTE(m_pPattern->m_wEmbellishment) == 0 );
		}
		m_btnCustom.SetCheck( fCustomEmbellishment );
		m_spinCustomId.SetRange( MIN_EMB_CUSTOM_ID, MAX_EMB_CUSTOM_ID );
		if( fCustomEmbellishment )
		{
			m_editCustomId.EnableWindow( TRUE );
			m_spinCustomId.EnableWindow( TRUE );
			m_spinCustomId.SetPos( HIBYTE(m_pPattern->m_wEmbellishment) );
		}
		else
		{
			m_spinCustomId.SetPos( m_pPattern->m_nLastCustomId );
			m_editCustomId.EnableWindow( FALSE );
			m_spinCustomId.EnableWindow( FALSE );
		}

		// Draw rhythm map
		m_btnRhythmMap.Invalidate();

		// Update bitmap on time signature button
		SetTimeSignatureBitmap();
	}
	else
	{
		m_editName.SetWindowText( _T("") );
		m_btnLength.SetWindowText( _T("") );
		m_spinGrooveBottom.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinGrooveBottom.SetPos( MIN_GROOVE );
		m_spinGrooveTop.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinGrooveTop.SetPos( MAX_GROOVE );
		m_spinDestBottom.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinDestBottom.SetPos( MIN_GROOVE );
		m_spinDestTop.SetRange( MIN_GROOVE, MAX_GROOVE );
		m_spinDestTop.SetPos( MAX_GROOVE );
		m_btnIntro.SetCheck( 0 );
		m_btnFill.SetCheck( 0 );
		m_btnBreak.SetCheck( 0 );
		m_btnEnd.SetCheck( 0 );
		m_btnCustom.SetCheck( 0 );
		m_spinCustomId.SetRange( MIN_EMB_CUSTOM_ID, MAX_EMB_CUSTOM_ID );
		m_spinCustomId.SetPos( MIN_EMB_CUSTOM_ID );
		m_btnRhythmMap.Invalidate();

		EnableControls( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::SetTimeSignatureBitmap

void CTabPatternPattern::SetTimeSignatureBitmap( void )
{
	if( !::IsWindow( m_btnTimeSignature.m_hWnd ) )
	{
		return;
	}

	HBITMAP hNewBits = NULL;

	ASSERT( m_pPattern != NULL );

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	// Write text
	CString strTimeSignature;

	CFont font;
	CFont* pfontOld = NULL;
	
	if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		pfontOld = cdcDest.SelectObject( &font );
	}

	strTimeSignature.Format( "%d/%d",
							 m_pPattern->m_TimeSignature.m_bBeatsPerMeasure,
							 m_pPattern->m_TimeSignature.m_bBeat );
	rect.left += 6;
	cdcDest.SetTextColor( COLOR_BTNTEXT );
	cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_NOPREFIX) );
	rect.left -= 6;

	if( pfontOld )
	{
		cdcDest.SelectObject( pfontOld );
		font.DeleteObject();
	}

	// Set x coord for 'Grids Per Beat' image
	CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
	int nX = max( 48, (sizeText.cx + 8) );

	// Draw "splitter"
	{
		CPen pen1;
		CPen pen2;
		CPen* ppenOld;

		int nPlace = nX - 6;
		int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

		// Highlight
		if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen1 );
			cdcDest.MoveTo( nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		// Shadow
		if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen2 );
			cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		if( nModeOld )
		{
			cdcDest.SetROP2( nModeOld );
		}
	}

	// Add 'Grids Per Beat' bitmap
	{
		int nResourceID = m_pPattern->m_TimeSignature.m_wGridsPerBeat - 1;
		if( m_pPattern->m_TimeSignature.m_bBeat != 4 )		// 4 = quarter note gets the beat
		{
			nResourceID += MAX_GRIDS_PER_BEAT;
		}
		ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );

		if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
		{
			BITMAP bm;

			bmpGridsPerBeat.GetBitmap( &bm );

			int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

			CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

			{
				CDC cdcMono;
				CBitmap bmpMono;

				if( cdcMono.CreateCompatibleDC( &cdcDest )
				&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
				{
					CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
					
					cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
					cdcDest.SetBkColor( RGB(255,255,255) );

					cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCCOPY);
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcMono, 0, 0, SRCAND ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;

					cdcMono.SelectObject( pbmpOldMono ) ;
				}
			}

			cdcGridsPerBeat.SelectObject( pbmpOld );
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}


void CTabPatternPattern::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabPatternPattern)
	DDX_Control(pDX, IDC_EMB_CUSTOM, m_btnCustom);
	DDX_Control(pDX, IDC_CUSTOM_ID, m_editCustomId);
	DDX_Control(pDX, IDC_CUSTOM_ID_SPIN, m_spinCustomId);
	DDX_Control(pDX, IDC_DEST_TOP_SPIN, m_spinDestTop);
	DDX_Control(pDX, IDC_DEST_BOTTOM_SPIN, m_spinDestBottom);
	DDX_Control(pDX, IDC_DEST_TOP, m_editDestTop);
	DDX_Control(pDX, IDC_DEST_BOTTOM, m_editDestBottom);
	DDX_Control(pDX, IDC_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_RHYTHM_MAP, m_btnRhythmMap);
	DDX_Control(pDX, IDC_CUSTOM_DLG, m_btnCustomDlg);
	DDX_Control(pDX, IDC_EMB_INTRO, m_btnIntro);
	DDX_Control(pDX, IDC_EMB_FILL, m_btnFill);
	DDX_Control(pDX, IDC_EMB_END, m_btnEnd);
	DDX_Control(pDX, IDC_EMB_BREAK, m_btnBreak);
	DDX_Control(pDX, IDC_GROOVE_TOP_SPIN, m_spinGrooveTop);
	DDX_Control(pDX, IDC_GROOVE_TOP, m_editGrooveTop);
	DDX_Control(pDX, IDC_GROOVE_BOTTOM_SPIN, m_spinGrooveBottom);
	DDX_Control(pDX, IDC_GROOVE_BOTTOM, m_editGrooveBottom);
	DDX_Control(pDX, IDC_NAME, m_editName);
	DDX_Control(pDX, IDC_LENGTH, m_btnLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabPatternPattern, CPropertyPage)
	//{{AFX_MSG_MAP(CTabPatternPattern)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_LENGTH, OnLength)
	ON_EN_KILLFOCUS(IDC_GROOVE_BOTTOM, OnKillFocusGrooveBottom)
	ON_NOTIFY(UDN_DELTAPOS, IDC_GROOVE_BOTTOM_SPIN, OnDeltaPosGrooveBottomSpin)
	ON_EN_KILLFOCUS(IDC_GROOVE_TOP, OnKillFocusGrooveTop)
	ON_NOTIFY(UDN_DELTAPOS, IDC_GROOVE_TOP_SPIN, OnDeltaPosGrooveTopSpin)
	ON_BN_CLICKED(IDC_EMB_INTRO, OnEmbIntro)
	ON_BN_CLICKED(IDC_EMB_FILL, OnEmbFill)
	ON_BN_CLICKED(IDC_EMB_BREAK, OnEmbBreak)
	ON_BN_CLICKED(IDC_EMB_END, OnEmbEnd)
	ON_BN_CLICKED(IDC_CUSTOM_DLG, OnCustomDlg)
	ON_WM_DRAWITEM()
	ON_BN_CLICKED(IDC_TIME_SIGNATURE, OnTimeSignature)
	ON_EN_KILLFOCUS(IDC_DEST_BOTTOM, OnKillFocusDestBottom)
	ON_NOTIFY(UDN_DELTAPOS, IDC_DEST_BOTTOM_SPIN, OnDeltaPosDestBottomSpin)
	ON_EN_KILLFOCUS(IDC_DEST_TOP, OnKillFocusDestTop)
	ON_NOTIFY(UDN_DELTAPOS, IDC_DEST_TOP_SPIN, OnDeltaPosDestTopSpin)
	ON_BN_CLICKED(IDC_EMB_CUSTOM, OnEmbCustom)
	ON_EN_KILLFOCUS(IDC_CUSTOM_ID, OnKillFocusCustomId)
	ON_NOTIFY(UDN_DELTAPOS, IDC_CUSTOM_ID_SPIN, OnDeltaPosCustomIdSpin)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnSetActive

BOOL CTabPatternPattern::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnCreate

int CTabPatternPattern::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDestroy

void CTabPatternPattern::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusName

void CTabPatternPattern::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pPattern )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pPattern->m_strName );
		}
		else
		{
			if( strName.Compare( m_pPattern->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pPattern->SetNodeName( bstrName );
				theApp.m_pStyleComponent->m_pIFramework->RefreshNode( m_pPattern );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnLength

void CTabPatternPattern::OnLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CPatternLengthDlg plDlg( m_pPattern );

		if( plDlg.DoModal() == IDOK )
		{
			CString strLength;

			if( ::IsWindow( m_btnLength.m_hWnd ) )
			{
				strLength.Format( "%d", m_pPattern->m_wNbrMeasures );
				m_btnLength.SetWindowText( strLength );
			}

			// Redraw rhythm map
			if( ::IsWindow( m_btnRhythmMap.m_hWnd ) )
			{
				m_btnRhythmMap.Invalidate();
				m_btnRhythmMap.UpdateWindow();
			}
		}

		if( ::IsWindow( m_btnLength.m_hWnd ) )
		{
			m_btnLength.SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusGrooveBottom

void CTabPatternPattern::OnKillFocusGrooveBottom() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CString strNewGrooveBottom;

		m_editGrooveBottom.GetWindowText( strNewGrooveBottom );

		// Strip leading and trailing spaces
		strNewGrooveBottom.TrimRight();
		strNewGrooveBottom.TrimLeft();

		if( strNewGrooveBottom.IsEmpty() )
		{
			m_spinGrooveBottom.SetPos( m_pPattern->m_bGrooveBottom );
		}
		else
		{
			int nNewGrooveBottom = _ttoi( strNewGrooveBottom );
			int nNewGrooveTop = m_pPattern->m_bGrooveTop;
		
			if( nNewGrooveBottom < MIN_GROOVE)
			{
				nNewGrooveBottom = MIN_GROOVE;
			}
		
			if( nNewGrooveBottom > MAX_GROOVE)
			{
				nNewGrooveBottom = MAX_GROOVE;
			}

			m_spinGrooveBottom.SetPos( nNewGrooveBottom );

			if( nNewGrooveBottom > nNewGrooveTop )
			{
				nNewGrooveTop = nNewGrooveBottom;
				m_spinGrooveTop.SetPos( nNewGrooveTop );
			}

			m_pPattern->SetGrooveRange( (BYTE)nNewGrooveBottom, (BYTE)nNewGrooveTop );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDeltaPosGrooveBottomSpin

void CTabPatternPattern::OnDeltaPosGrooveBottomSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nGrooveBottom = m_spinGrooveBottom.GetPos();

		if( HIWORD(nGrooveBottom) == 0 )
		{
			int nNewGrooveBottom = LOWORD(nGrooveBottom) + pNMUpDown->iDelta;
			int nNewGrooveTop = m_pPattern->m_bGrooveTop;

			if( nNewGrooveBottom < MIN_GROOVE)
			{
				nNewGrooveBottom = MIN_GROOVE;
			}
		
			if( nNewGrooveBottom > MAX_GROOVE)
			{
				nNewGrooveBottom = MAX_GROOVE;
			}

			m_spinGrooveBottom.SetPos( nNewGrooveBottom );

			if( nNewGrooveBottom > nNewGrooveTop )
			{
				nNewGrooveTop = nNewGrooveBottom;
				m_spinGrooveTop.SetPos( nNewGrooveTop );
			}

			m_pPattern->SetGrooveRange( (BYTE)nNewGrooveBottom, (BYTE)nNewGrooveTop );
		}
	}
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusGrooveTop

void CTabPatternPattern::OnKillFocusGrooveTop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CString strNewGrooveTop;

		m_editGrooveTop.GetWindowText( strNewGrooveTop );

		// Strip leading and trailing spaces
		strNewGrooveTop.TrimRight();
		strNewGrooveTop.TrimLeft();

		if( strNewGrooveTop.IsEmpty() )
		{
			m_spinGrooveTop.SetPos( m_pPattern->m_bGrooveTop );
		}
		else
		{
			int nNewGrooveTop = _ttoi( strNewGrooveTop );
			int nNewGrooveBottom = m_pPattern->m_bGrooveBottom;

			if( nNewGrooveTop < MIN_GROOVE)
			{
				nNewGrooveTop = MIN_GROOVE;
			}

			if( nNewGrooveTop > MAX_GROOVE)
			{
				nNewGrooveTop = MAX_GROOVE;
			}

			m_spinGrooveTop.SetPos( nNewGrooveTop );

			if( nNewGrooveTop < nNewGrooveBottom )
			{
				nNewGrooveBottom = nNewGrooveTop;
				m_spinGrooveBottom.SetPos( nNewGrooveBottom );
			}

			m_pPattern->SetGrooveRange( (BYTE)nNewGrooveBottom, (BYTE)nNewGrooveTop );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDeltaPosGrooveTopSpin

void CTabPatternPattern::OnDeltaPosGrooveTopSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nGrooveTop = m_spinGrooveTop.GetPos();

		if( HIWORD(nGrooveTop) == 0 )
		{
			int nNewGrooveTop = LOWORD(nGrooveTop) + pNMUpDown->iDelta;
			int nNewGrooveBottom = m_pPattern->m_bGrooveBottom;

			if( nNewGrooveTop < MIN_GROOVE)
			{
				nNewGrooveTop = MIN_GROOVE;
			}

			if( nNewGrooveTop > MAX_GROOVE)
			{
				nNewGrooveTop = MAX_GROOVE;
			}

			m_spinGrooveTop.SetPos( nNewGrooveTop );

			if( nNewGrooveTop < nNewGrooveBottom )
			{
				nNewGrooveBottom = nNewGrooveTop;
				m_spinGrooveBottom.SetPos( nNewGrooveBottom );
			}

			m_pPattern->SetGrooveRange( (BYTE)nNewGrooveBottom, (BYTE)nNewGrooveTop );
		}
	}
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnEmbIntro

void CTabPatternPattern::OnEmbIntro() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		if( m_btnIntro.GetCheck() )
		{
			m_pPattern->SetEmbellishment( EMB_INTRO, 0, 0 );
		}
		else
		{
			m_pPattern->SetEmbellishment( 0, EMB_INTRO, 0 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnEmbFill

void CTabPatternPattern::OnEmbFill() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		if( m_btnFill.GetCheck() )
		{
			m_pPattern->SetEmbellishment( EMB_FILL, 0, 0 );
		}
		else
		{
			m_pPattern->SetEmbellishment( 0, EMB_FILL, 0 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnEmbBreak

void CTabPatternPattern::OnEmbBreak() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		if( m_btnBreak.GetCheck() )
		{
			m_pPattern->SetEmbellishment( EMB_BREAK, 0, 0 );
		}
		else
		{
			m_pPattern->SetEmbellishment( 0, EMB_BREAK, 0 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnEmbEnd

void CTabPatternPattern::OnEmbEnd() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		if( m_btnEnd.GetCheck() )
		{
			m_pPattern->SetEmbellishment( EMB_END, 0, 0 );
		}
		else
		{
			m_pPattern->SetEmbellishment( 0, EMB_END, 0 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnCustomDlg

void CTabPatternPattern::OnCustomDlg() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		// Display rhythmDlg
		CRhythmDlg rhythmDlg;
		rhythmDlg.m_TimeSignature = m_pPattern->m_TimeSignature;
		rhythmDlg.m_wNbrMeasures = m_pPattern->m_wNbrMeasures;
		rhythmDlg.m_pRhythmMap = new DWORD[m_pPattern->m_wNbrMeasures];
		if( rhythmDlg.m_pRhythmMap )
		{
			for( int i = 0 ;  i < m_pPattern->m_wNbrMeasures ;  ++i )
			{
				rhythmDlg.m_pRhythmMap[i] = m_pPattern->m_pRhythmMap[i];
			}

			if( rhythmDlg.DoModal() == IDOK )
			{
				// Update rhythm map
				m_pPattern->SetRhythmMap( rhythmDlg.m_pRhythmMap );

				// Redraw rhythm map
				if( ::IsWindow( m_btnRhythmMap.m_hWnd ) )
				{
					m_btnRhythmMap.Invalidate();
					m_btnRhythmMap.UpdateWindow();
				}
			}
		}

		if( ::IsWindow( m_btnCustomDlg.m_hWnd ) )
		{
			m_btnCustomDlg.SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDrawItem

void CTabPatternPattern::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern == NULL )
	{
		CPropertyPage::OnDrawItem( nIDCtl, lpDrawItemStruct );
		return;
	}

	switch( nIDCtl )
	{
		case IDC_RHYTHM_MAP:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				int i, j;
				int nMaxRight = lpDrawItemStruct->rcItem.right - 4;

				CRect rect( lpDrawItemStruct->rcItem );
				rect.right = rect.left;
				rect.InflateRect( 0, -3 );
				int nTickHeight = (rect.Height() >> 1) - 1;
				for( i = 0 ;  i < m_pPattern->m_wNbrMeasures ; i++ )
				{
					for( j = 0 ;  j < 32 ;  j++ )
					{
						if( j >= m_pPattern->m_TimeSignature.m_bBeatsPerMeasure )
						{
							break;
						}

						rect.left  = rect.right + 2;
						rect.right = rect.left + 1;
						if( rect.left >= nMaxRight )
						{
							break;
						}

						if( m_pPattern->m_pRhythmMap[i] & (1 << j) )
						{
							pDC->FillSolidRect( &rect, RGB(0,0,0) );
						}
						else
						{
							rect.InflateRect( 0, -nTickHeight );
							pDC->FillSolidRect( &rect, RGB(0,0,0) );
							rect.InflateRect( 0, nTickHeight );
						}
					}
					
					rect.left += 3;
					rect.right += 3;
					if( rect.left >= nMaxRight )
					{
						break;
					}
				}
				rect.InflateRect( 0, 3 );
			}

			return;
		}
	}
	
	CPropertyPage::OnDrawItem( nIDCtl, lpDrawItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnTimeSignature

void CTabPatternPattern::OnTimeSignature() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CTimeSignatureDlg tsDlg;

		tsDlg.m_TimeSignature = m_pPattern->m_TimeSignature;
		tsDlg.m_nContext = IDS_PATTERN_TEXT;

		if( tsDlg.DoModal() == IDOK )
		{
			// Update time signature
			AfxMessageBox( "Not yet implemented." );
// AMC??	m_pPattern->SetTimeSignature( tsDlg.m_TimeSignature, FALSE );

			// Update bitmap on time signature button
			SetTimeSignatureBitmap();
		}

		if( ::IsWindow( m_btnTimeSignature.m_hWnd ) )
		{
			m_btnTimeSignature.SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusDestBottom

void CTabPatternPattern::OnKillFocusDestBottom() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CString strNewDestBottom;

		m_editDestBottom.GetWindowText( strNewDestBottom );

		// Strip leading and trailing spaces
		strNewDestBottom.TrimRight();
		strNewDestBottom.TrimLeft();

		if( strNewDestBottom.IsEmpty() )
		{
			m_spinDestBottom.SetPos( m_pPattern->m_bDestGrooveBottom );
		}
		else
		{
			int nNewDestBottom = _ttoi( strNewDestBottom );
			int nNewDestTop = m_pPattern->m_bDestGrooveTop;
		
			if( nNewDestBottom < MIN_GROOVE)
			{
				nNewDestBottom = MIN_GROOVE;
			}
		
			if( nNewDestBottom > MAX_GROOVE)
			{
				nNewDestBottom = MAX_GROOVE;
			}

			m_spinDestBottom.SetPos( nNewDestBottom );

			if( nNewDestBottom > nNewDestTop )
			{
				nNewDestTop = nNewDestBottom;
				m_spinDestTop.SetPos( nNewDestTop );
			}

			m_pPattern->SetDestGrooveRange( (BYTE)nNewDestBottom, (BYTE)nNewDestTop );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDeltaPosDestBottomSpin

void CTabPatternPattern::OnDeltaPosDestBottomSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nDestBottom = m_spinDestBottom.GetPos();
		int nNewDestTop = m_pPattern->m_bDestGrooveTop;

		if( HIWORD(nDestBottom) == 0 )
		{
			int nNewDestBottom = LOWORD(nDestBottom) + pNMUpDown->iDelta;

			if( nNewDestBottom < MIN_GROOVE)
			{
				nNewDestBottom = MIN_GROOVE;
			}
		
			if( nNewDestBottom > MAX_GROOVE)
			{
				nNewDestBottom = MAX_GROOVE;
			}

			m_spinDestBottom.SetPos( nNewDestBottom );

			if( nNewDestBottom > nNewDestTop )
			{
				nNewDestTop = nNewDestBottom;
				m_spinDestTop.SetPos( nNewDestTop );
			}

			m_pPattern->SetDestGrooveRange( (BYTE)nNewDestBottom, (BYTE)nNewDestTop );
		}
	}
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusDestTop

void CTabPatternPattern::OnKillFocusDestTop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CString strNewDestTop;

		m_editDestTop.GetWindowText( strNewDestTop );

		// Strip leading and trailing spaces
		strNewDestTop.TrimRight();
		strNewDestTop.TrimLeft();

		if( strNewDestTop.IsEmpty() )
		{
			m_spinDestTop.SetPos( m_pPattern->m_bDestGrooveTop );
		}
		else
		{
			int nNewDestTop = _ttoi( strNewDestTop );
			int nNewDestBottom = m_pPattern->m_bDestGrooveBottom;

			if( nNewDestTop < MIN_GROOVE)
			{
				nNewDestTop = MIN_GROOVE;
			}

			if( nNewDestTop > MAX_GROOVE)
			{
				nNewDestTop = MAX_GROOVE;
			}

			m_spinDestTop.SetPos( nNewDestTop );

			if( nNewDestTop < nNewDestBottom )
			{
				nNewDestBottom = nNewDestTop;
				m_spinDestBottom.SetPos( nNewDestBottom );
			}

			m_pPattern->SetDestGrooveRange( (BYTE)nNewDestBottom, (BYTE)nNewDestTop );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDeltaPosDestTopSpin

void CTabPatternPattern::OnDeltaPosDestTopSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nDestTop = m_spinDestTop.GetPos();

		if( HIWORD(nDestTop) == 0 )
		{
			int nNewDestTop = LOWORD(nDestTop) + pNMUpDown->iDelta;
			int nNewDestBottom = m_pPattern->m_bDestGrooveBottom;

			if( nNewDestTop < MIN_GROOVE)
			{
				nNewDestTop = MIN_GROOVE;
			}

			if( nNewDestTop > MAX_GROOVE)
			{
				nNewDestTop = MAX_GROOVE;
			}

			m_spinDestTop.SetPos( nNewDestTop );

			if( nNewDestTop < nNewDestBottom )
			{
				nNewDestBottom = nNewDestTop;
				m_spinDestBottom.SetPos( nNewDestBottom );
			}

			m_pPattern->SetDestGrooveRange( (BYTE)nNewDestBottom, (BYTE)nNewDestTop );
		}
	}
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnEmbCustom

void CTabPatternPattern::OnEmbCustom() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		if( m_btnCustom.GetCheck() )
		{
			m_pPattern->SetEmbellishment( 0, EMB_ALL, m_pPattern->m_nLastCustomId );
		}
		else
		{
			m_pPattern->SetEmbellishment( 0, EMB_ALL, 0 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnKillFocusCustomId

void CTabPatternPattern::OnKillFocusCustomId() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		CString strNewCustomId;

		m_editCustomId.GetWindowText( strNewCustomId );

		// Strip leading and trailing spaces
		strNewCustomId.TrimRight();
		strNewCustomId.TrimLeft();

		if( strNewCustomId.IsEmpty() )
		{
			ASSERT( HIBYTE(m_pPattern->m_wEmbellishment) >= MIN_EMB_CUSTOM_ID
			    &&  HIBYTE(m_pPattern->m_wEmbellishment) <= MAX_EMB_CUSTOM_ID );
			m_spinCustomId.SetPos( HIBYTE(m_pPattern->m_wEmbellishment) );
		}
		else
		{
			int nNewCustomId = _ttoi( strNewCustomId );
		
			if( nNewCustomId < MIN_EMB_CUSTOM_ID)
			{
				nNewCustomId = MIN_EMB_CUSTOM_ID;
			}
		
			if( nNewCustomId > MAX_EMB_CUSTOM_ID)
			{
				nNewCustomId = MAX_EMB_CUSTOM_ID;
			}

			m_spinCustomId.SetPos( nNewCustomId );
			m_pPattern->SetEmbellishment( 0, EMB_ALL, (BYTE)nNewCustomId );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern::OnDeltaPosCustomIdSpin

void CTabPatternPattern::OnDeltaPosCustomIdSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pPattern )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		int nCustomId = m_spinCustomId.GetPos();

		if( HIWORD(nCustomId) == 0 )
		{
			int nNewCustomId = LOWORD(nCustomId) + pNMUpDown->iDelta;

			if( nNewCustomId < MIN_EMB_CUSTOM_ID)
			{
				nNewCustomId = MIN_EMB_CUSTOM_ID;
			}

			if( nNewCustomId > MAX_EMB_CUSTOM_ID)
			{
				nNewCustomId = MAX_EMB_CUSTOM_ID;
			}

			m_spinCustomId.SetPos( nNewCustomId );
			m_pPattern->SetEmbellishment( 0, EMB_ALL, (BYTE)nNewCustomId );
		}
	}
	
	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabMotifLoop.h ===
#if !defined(AFX_TABMOTIFLOOP_H__6B0A7543_2AF4_11D2_89B4_00C04FD912C8__INCLUDED_)
#define AFX_TABMOTIFLOOP_H__6B0A7543_2AF4_11D2_89B4_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabMotifLoop.h : header file
//

class CMotifPropPageManager;

/////////////////////////////////////////////////////////////////////////////
// CTabMotifLoop dialog

class CTabMotifLoop : public CPropertyPage
{
// Construction
public:
	CTabMotifLoop( CMotifPropPageManager* pMotifPropPageManager );
	~CTabMotifLoop();
	void RefreshTab( IDMUSProdPropPageObject* pIPropPageObject );

// Dialog Data
	//{{AFX_DATA(CTabMotifLoop)
	enum { IDD = IDD_TAB_MOTIF_LOOP };
	CButton	m_checkInfinite;
	CButton	m_btnResetLoop;
	CEdit	m_editRepeats;
	CEdit	m_editStartBar;
	CEdit	m_editStartBeat;
	CEdit	m_editStartGrid;
	CEdit	m_editStartTick;
	CEdit	m_editEndBar;
	CEdit	m_editEndBeat;
	CEdit	m_editEndGrid;
	CEdit	m_editEndTick;
	CSpinButtonCtrl	m_spinRepeats;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinEndBar;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndTick;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabMotifLoop)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicPattern*	m_pMotif;
	CMotifPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;
	DWORD					m_dwLastLoopRepeatCount;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void UpdateLoopStartEndControls();

	// Generated message map functions
	//{{AFX_MSG(CTabMotifLoop)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocusEditRepeats();
	afx_msg void OnDeltaPosSpinRepeats(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusEditLoopStartBar();
	afx_msg void OnKillFocusEditLoopStartBeat();
	afx_msg void OnKillFocusEditLoopStartGrid();
	afx_msg void OnKillFocusEditLoopStartTick();
	afx_msg void OnDeltaPosSpinLoopStartBar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLoopStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLoopStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLoopStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusEditLoopEndBar();
	afx_msg void OnKillFocusEditLoopEndBeat();
	afx_msg void OnKillFocusEditLoopEndGrid();
	afx_msg void OnKillFocusEditLoopEndTick();
	afx_msg void OnDeltaPosSpinLoopEndBar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLoopEndBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLoopEndGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinLoopEndTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnResetLoop();
	afx_msg void OnDoubleClickedResetLoop();
	afx_msg void OnCheckInfinite();
	afx_msg void OnDoubleClickedInfinite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABMOTIFLOOP_H__6B0A7543_2AF4_11D2_89B4_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabMotifMotif.h ===
#if !defined(AFX_TABMOTIFMOTIF_H__819A7F03_7332_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABMOTIFMOTIF_H__819A7F03_7332_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabMotifMotif.h : header file
//

class CMotifPropPageManager;

/////////////////////////////////////////////////////////////////////////////
// CTabMotifMotif dialog

class CTabMotifMotif : public CPropertyPage
{
// Construction
public:
	CTabMotifMotif( CMotifPropPageManager* pMotifPropPageManager );
	virtual ~CTabMotifMotif();
	void RefreshTab( IDMUSProdPropPageObject* pIPropPageObject );

// Dialog Data
	//{{AFX_DATA(CTabMotifMotif)
	enum { IDD = IDD_TAB_MOTIF_MOTIF };
	CButton	m_btnResetVarOrder;
	CButton	m_btnTimeSignature;
	CEdit	m_editName;
	CEdit	m_editStartBar;
	CEdit	m_editStartBeat;
	CEdit	m_editStartGrid;
	CEdit	m_editStartTick;
	CButton	m_btnLength;
	CSpinButtonCtrl	m_spinStartBar;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartTick;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabMotifMotif)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicPattern*	m_pMotif;
	CMotifPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void UpdatePlayStartControls();
	void SetTimeSignatureBitmap();

	// Generated message map functions
	//{{AFX_MSG(CTabMotifMotif)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	afx_msg void OnLength();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocusEditPlayStartBar();
	afx_msg void OnKillFocusEditPlayStartBeat();
	afx_msg void OnKillFocusEditPlayStartGrid();
	afx_msg void OnKillFocusEditPlayStartTick();
	afx_msg void OnDeltaPosSpinPlayStartBar(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinPlayStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinPlayStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosSpinPlayStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimeSignature();
	afx_msg void OnCheckResetVarOrder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABMOTIFMOTIF_H__819A7F03_7332_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabPatternPattern.h ===
#if !defined(AFX_TABPATTERNPATTERN_H__819A7F02_7332_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABPATTERNPATTERN_H__819A7F02_7332_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabPatternPattern.h : header file
//

class CPatternPropPageManager;
class CDirectMusicPattern;

/////////////////////////////////////////////////////////////////////////////
// CTabPatternPattern dialog

class CTabPatternPattern : public CPropertyPage
{
// Construction
public:
	CTabPatternPattern( CPatternPropPageManager* pPatternPropPageManager );
	virtual ~CTabPatternPattern();
	void RefreshTab( IDMUSProdPropPageObject* pIPropPageObject );

// Dialog Data
	//{{AFX_DATA(CTabPatternPattern)
	enum { IDD = IDD_TAB_PATTERN_PATTERN };
	CButton	m_btnCustom;
	CEdit	m_editCustomId;
	CSpinButtonCtrl	m_spinCustomId;
	CSpinButtonCtrl	m_spinDestTop;
	CSpinButtonCtrl	m_spinDestBottom;
	CEdit	m_editDestTop;
	CEdit	m_editDestBottom;
	CButton	m_btnTimeSignature;
	CButton	m_btnRhythmMap;
	CButton	m_btnCustomDlg;
	CButton	m_btnIntro;
	CButton	m_btnFill;
	CButton	m_btnEnd;
	CButton	m_btnBreak;
	CButton	m_btnWhole;
	CButton	m_btnQuarter;
	CButton	m_btnHalf;
	CSpinButtonCtrl	m_spinGrooveTop;
	CEdit	m_editGrooveTop;
	CSpinButtonCtrl	m_spinGrooveBottom;
	CEdit	m_editGrooveBottom;
	CEdit	m_editName;
	CButton	m_btnLength;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabPatternPattern)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicPattern*		m_pPattern;
	CPatternPropPageManager*	m_pPageManager;
	BOOL						m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void SetTimeSignatureBitmap();

	// Generated message map functions
	//{{AFX_MSG(CTabPatternPattern)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	afx_msg void OnLength();
	afx_msg void OnKillFocusGrooveBottom();
	afx_msg void OnDeltaPosGrooveBottomSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusGrooveTop();
	afx_msg void OnDeltaPosGrooveTopSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEmbIntro();
	afx_msg void OnEmbFill();
	afx_msg void OnEmbBreak();
	afx_msg void OnEmbEnd();
	afx_msg void OnCustomDlg();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnTimeSignature();
	afx_msg void OnKillFocusDestBottom();
	afx_msg void OnDeltaPosDestBottomSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusDestTop();
	afx_msg void OnDeltaPosDestTopSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEmbCustom();
	afx_msg void OnKillFocusCustomId();
	afx_msg void OnDeltaPosCustomIdSpin(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABPATTERNPATTERN_H__819A7F02_7332_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabStyleInfo.cpp ===
// TabStyleInfo.cpp : implementation file
//

#include "stdafx.h"
#include "TabStyleInfo.h"
#include "StyleDesignerDll.h"
#include "Style.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo property page

CTabStyleInfo::CTabStyleInfo( CStylePropPageManager* pStylePropPageManager ) : CPropertyPage(CTabStyleInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabStyleInfo)
	//}}AFX_DATA_INIT
	
	ASSERT( pStylePropPageManager != NULL );

	m_pStyle = NULL;
	m_pPageManager = pStylePropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabStyleInfo::~CTabStyleInfo()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::SetStyle

void CTabStyleInfo::SetStyle( CDirectMusicStyle* pStyle )
{
	m_pStyle = pStyle;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::SetModifiedFlag

void CTabStyleInfo::SetModifiedFlag( void ) 
{
	ASSERT( m_pStyle != NULL );

	m_pStyle->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::EnableControls

void CTabStyleInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editInfo.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::UpdateControls

void CTabStyleInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pStyle )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pStyle->m_strAuthor );
		m_editCopyright.SetWindowText( m_pStyle->m_strCopyright );
		m_editInfo.SetWindowText( m_pStyle->m_strInfo );
		m_editSubject.SetWindowText( m_pStyle->m_strSubject );
		
		strText.Format( "%u", ((m_pStyle->m_dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pStyle->m_dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pStyle->m_dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pStyle->m_dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editInfo.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabStyleInfo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabStyleInfo)
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_INFO, m_editInfo);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabStyleInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabStyleInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_INFO, OnKillFocusInfo)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnSetActive

BOOL CTabStyleInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CStylePropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnCreate

int CTabStyleInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnDestroy

void CTabStyleInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusAuthor

void CTabStyleInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pStyle->m_strAuthor ) != 0 )
		{
			m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_AUTHOR );
			m_pStyle->m_strAuthor = strAuthor;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusCopyright

void CTabStyleInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pStyle->m_strCopyright ) != 0 )
		{
			m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_COPYRIGHT );
			m_pStyle->m_strCopyright = strCopyright;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusInfo

void CTabStyleInfo::OnKillFocusInfo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strInfo;

		m_editInfo.GetWindowText( strInfo );

		// Strip leading and trailing spaces
		strInfo.TrimRight();
		strInfo.TrimLeft();

		if( strInfo.Compare( m_pStyle->m_strInfo ) != 0 )
		{
			m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_INFO );
			m_pStyle->m_strInfo = strInfo;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusSubject

void CTabStyleInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pStyle->m_strSubject ) != 0 )
		{
			m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_SUBJECT );
			m_pStyle->m_strSubject = strSubject;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusVersion_1

void CTabStyleInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strVersion_1;
		CString strStyleVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pStyle->m_dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strStyleVersion_1.Format( "%u", ((m_pStyle->m_dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strStyleVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_VERSION );
				m_pStyle->m_dwVersionMS &= 0x0000FFFF;
				m_pStyle->m_dwVersionMS |= dwVersion_1;
				SetModifiedFlag();

				// Sync Style with DirectMusic
				m_pStyle->SyncStyleWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusVersion_2

void CTabStyleInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strVersion_2;
		CString strStyleVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pStyle->m_dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strStyleVersion_2.Format( "%u", (m_pStyle->m_dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strStyleVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_VERSION );
				m_pStyle->m_dwVersionMS &= 0xFFFF0000;
				m_pStyle->m_dwVersionMS |= dwVersion_2;
				SetModifiedFlag();

				// Sync Style with DirectMusic
				m_pStyle->SyncStyleWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusVersion_3

void CTabStyleInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strVersion_3;
		CString strStyleVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pStyle->m_dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strStyleVersion_3.Format( "%u", ((m_pStyle->m_dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strStyleVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_VERSION );
				m_pStyle->m_dwVersionLS &= 0x0000FFFF;
				m_pStyle->m_dwVersionLS |= dwVersion_3;
				SetModifiedFlag();

				// Sync Style with DirectMusic
				m_pStyle->SyncStyleWithDirectMusic();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo::OnKillFocusVersion_4

void CTabStyleInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strVersion_4;
		CString strStyleVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pStyle->m_dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strStyleVersion_4.Format( "%u", (m_pStyle->m_dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strStyleVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_VERSION );
				m_pStyle->m_dwVersionLS &= 0xFFFF0000;
				m_pStyle->m_dwVersionLS |= dwVersion_4;
				SetModifiedFlag();

				// Sync Style with DirectMusic
				m_pStyle->SyncStyleWithDirectMusic();
			}
		}
	}
}

void CTabStyleInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CGuidDlg dlg;
		memcpy( &dlg.m_guid, &m_pStyle->m_guidStyle, sizeof(GUID) );
		if( dlg.DoModal() == IDOK )
		{
			m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_GUID );
			memcpy( &m_pStyle->m_guidStyle, &dlg.m_guid, sizeof(GUID) );
			SetModifiedFlag();

			// Sync Style with DirectMusic
			m_pStyle->SyncStyleWithDirectMusic();

			// Notify connected nodes that Style GUID has changed
			theApp.m_pStyleComponent->m_pIFramework->NotifyNodes( m_pStyle, DOCROOT_GuidChange, NULL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabStyleStyle.cpp ===
// TabStyleStyle.cpp : implementation file
//

#include "stdafx.h"
#include "TabStyleStyle.h"
#include "StyleDesignerDll.h"
#include "Style.h"
#include "TimeSignatureDlg.h"
#include <math.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle property page

CTabStyleStyle::CTabStyleStyle( CStylePropPageManager* pStylePropPageManager ) : CPropertyPage(CTabStyleStyle::IDD)
{
	//{{AFX_DATA_INIT(CTabStyleStyle)
	//}}AFX_DATA_INIT
	
	ASSERT( pStylePropPageManager != NULL );

	m_pStyle = NULL;
	m_pPageManager = pStylePropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabStyleStyle::~CTabStyleStyle()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::SetStyle

void CTabStyleStyle::SetStyle( CDirectMusicStyle* pStyle )
{
	m_pStyle = pStyle;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::SetModifiedFlag

void CTabStyleStyle::SetModifiedFlag( void ) 
{
	ASSERT( m_pStyle != NULL );

	m_pStyle->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::SetTempoControlText

void CTabStyleStyle::SetTempoControlText( void ) 
{
	if( m_pStyle
	&&	::IsWindow( m_editTempo.m_hWnd ) )
	{
		CString strTempo;

		strTempo.Format( "%.2f", m_pStyle->m_dblTempo );
		m_editTempo.SetWindowText( strTempo );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::EnableControls

void CTabStyleStyle::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_editTempo.EnableWindow( fEnable );
	m_spinTempo.EnableWindow( fEnable );
	m_btnTimeSignature.EnableWindow( fEnable );
	m_cmbxCategory.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::UpdateControls

void CTabStyleStyle::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );
	m_spinTempo.SetRange( DMUS_TEMPO_MIN, DMUS_TEMPO_MAX );
	m_editTempo.LimitText( 6 ); // 350.00

	if( m_pStyle )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pStyle->m_strName );

		// Set tempo
		SetTempoControlText();

		// Set category
		int nPos = m_cmbxCategory.FindStringExact( -1, m_pStyle->m_strCategoryName );
		if( nPos == CB_ERR )
		{
			TCHAR achNone[MID_BUFFER];

			::LoadString( theApp.m_hInstance, IDS_NONE_TEXT, achNone, MID_BUFFER );
			nPos = m_cmbxCategory.FindStringExact( -1, achNone );

		}
		m_cmbxCategory.SetCurSel( nPos );

		// Update bitmap on time signature button
		SetTimeSignatureBitmap();
	}
	else
	{
		m_editName.SetWindowText( _T("") );
		m_spinTempo.SetPos( MIN_TEMPO );

		EnableControls( FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::SetTimeSignatureBitmap

void CTabStyleStyle::SetTimeSignatureBitmap( void )
{
	if( !::IsWindow( m_btnTimeSignature.m_hWnd ) )
	{
		return;
	}

	HBITMAP hNewBits = NULL;

	ASSERT( m_pStyle != NULL );

	RECT rect;
	m_btnTimeSignature.GetClientRect( &rect );

	// Create a DC for the new bitmap
	// a DC for the 'Grids Per Beat' bitmap
	// a Bitmap for the new bits
	CDC cdcDest;
	CDC cdcGridsPerBeat;
	CBitmap bmpNewBits;
	CBitmap bmpGridsPerBeat;

	CDC* pDC = m_btnTimeSignature.GetDC();
	if( pDC )
	{

		if( cdcDest.CreateCompatibleDC( pDC ) == FALSE
		||  cdcGridsPerBeat.CreateCompatibleDC( pDC ) == FALSE
		||  bmpNewBits.CreateCompatibleBitmap( pDC, rect.right, rect.bottom ) == FALSE )
		{
			m_btnTimeSignature.ReleaseDC( pDC );
			return;
		}

		m_btnTimeSignature.ReleaseDC( pDC );
	}

	// Create the new bitmap
	CBitmap* pbmpOldMem = cdcDest.SelectObject( &bmpNewBits );

	// Fill Rect with button color
	cdcDest.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
	cdcDest.ExtTextOut( 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);

	// Write text
	CString strTimeSignature;

	CFont font;
	CFont* pfontOld = NULL;
	
	if( font.CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		pfontOld = cdcDest.SelectObject( &font );
	}

	strTimeSignature.Format( "%d/%d",
							 m_pStyle->m_TimeSignature.m_bBeatsPerMeasure,
							 m_pStyle->m_TimeSignature.m_bBeat );
	rect.left += 6;
	cdcDest.SetTextColor( COLOR_BTNTEXT );
	cdcDest.DrawText( strTimeSignature, -1, &rect, (DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_NOPREFIX) );
	rect.left -= 6;

	if( pfontOld )
	{
		cdcDest.SelectObject( pfontOld );
		font.DeleteObject();
	}

	// Set x coord for 'Grids Per Beat' image
	CSize sizeText = cdcDest.GetTextExtent( strTimeSignature );
	int nX = max( 48, (sizeText.cx + 8) );

	// Draw "splitter"
	{
		CPen pen1;
		CPen pen2;
		CPen* ppenOld;

		int nPlace = nX - 6;
		int nModeOld = cdcDest.SetROP2( R2_COPYPEN );

		// Highlight
		if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen1 );
			cdcDest.MoveTo( nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		// Shadow
		if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
		{
			ppenOld = cdcDest.SelectObject( &pen2 );
			cdcDest.MoveTo( ++nPlace, (rect.top + 3) );
			cdcDest.LineTo( nPlace, (rect.bottom - 3) );
			cdcDest.SelectObject( ppenOld );
		}

		if( nModeOld )
		{
			cdcDest.SetROP2( nModeOld );
		}
	}

	// Add 'Grids Per Beat' bitmap
	{
		int nResourceID = m_pStyle->m_TimeSignature.m_wGridsPerBeat - 1;
		if( m_pStyle->m_TimeSignature.m_bBeat != 4 )		// 4 = quarter note gets the beat
		{
			nResourceID += MAX_GRIDS_PER_BEAT;
		}
		ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) );

		if( bmpGridsPerBeat.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
		{
			BITMAP bm;

			bmpGridsPerBeat.GetBitmap( &bm );

			int nY = ((rect.bottom - rect.top) - bm.bmHeight) >> 1;

			CBitmap* pbmpOld = cdcGridsPerBeat.SelectObject( &bmpGridsPerBeat );

			{
				CDC cdcMono;
				CBitmap bmpMono;

				if( cdcMono.CreateCompatibleDC( &cdcDest )
				&&  bmpMono.CreateBitmap( bm.bmWidth, bm.bmHeight, 1, 1, NULL ) )
				{
					CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpMono );
					
					cdcGridsPerBeat.SetBkColor( RGB(255,255,255) );
					cdcDest.SetBkColor( RGB(255,255,255) );

					cdcMono.BitBlt( 0, 0, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCCOPY);
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcMono, 0, 0, SRCAND ) ;
					cdcDest.BitBlt( nX, nY, bm.bmWidth, bm.bmHeight,
									&cdcGridsPerBeat, 0, 0, SRCINVERT ) ;

					cdcMono.SelectObject( pbmpOldMono ) ;
				}
			}

			cdcGridsPerBeat.SelectObject( pbmpOld );
		}
	}

	cdcDest.SelectObject( pbmpOldMem );

	// Set the new bitmap
	hNewBits = (HBITMAP)bmpNewBits.Detach();
	if( hNewBits )
	{
		HBITMAP hBitmapOld = m_btnTimeSignature.SetBitmap( hNewBits );
		if( hBitmapOld )
		{
			::DeleteObject( hBitmapOld );
		}
	}
}


void CTabStyleStyle::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabStyleStyle)
	DDX_Control(pDX, IDC_TIME_SIGNATURE, m_btnTimeSignature);
	DDX_Control(pDX, IDC_TEMPO_SPIN, m_spinTempo);
	DDX_Control(pDX, IDC_TEMPO, m_editTempo);
	DDX_Control(pDX, IDC_CATEGORY, m_cmbxCategory);
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabStyleStyle, CPropertyPage)
	//{{AFX_MSG_MAP(CTabStyleStyle)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_EN_KILLFOCUS(IDC_TEMPO, OnKillFocusTempo)
	ON_NOTIFY(UDN_DELTAPOS, IDC_TEMPO_SPIN, OnDeltaPosTempoSpin)
	ON_CBN_KILLFOCUS(IDC_CATEGORY, OnKillFocusCategory)
	ON_BN_CLICKED(IDC_TIME_SIGNATURE, OnTimeSignature)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnInitDialog

BOOL CTabStyleStyle::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	// Fill Category list box
	TCHAR achCategory[MID_BUFFER];
	int i;

	for ( i = IDS_CATEGORY1 ;  i <= IDS_CATEGORY15 ;  i++ )
	{
		::LoadString( theApp.m_hInstance, i, achCategory, MID_BUFFER );
		m_cmbxCategory.AddString( achCategory );
	}

	::LoadString( theApp.m_hInstance, IDS_NONE_TEXT, achCategory, MID_BUFFER );
	m_cmbxCategory.AddString( achCategory );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnSetActive

BOOL CTabStyleStyle::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CStylePropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnCreate

int CTabStyleStyle::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnDestroy

void CTabStyleStyle::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Delete the time signature button's bitmap
	HBITMAP hBitmap = m_btnTimeSignature.GetBitmap();
	if( hBitmap )
	{
		::DeleteObject( hBitmap );
	}

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnKillFocusName

void CTabStyleStyle::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( m_pStyle )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pStyle->m_strName );
		}
		else
		{
			if( strName.Compare( m_pStyle->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pStyle->SetNodeName( bstrName );
				theApp.m_pStyleComponent->m_pIFramework->RefreshNode( m_pStyle );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnKillFocusCategory

void CTabStyleStyle::OnKillFocusCategory() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strCategoryName;
		TCHAR achNone[MID_BUFFER];

		int nPos = m_cmbxCategory.GetCurSel();
		if( nPos != CB_ERR )
		{
			m_cmbxCategory.GetLBText( nPos, strCategoryName );

			::LoadString( theApp.m_hInstance, IDS_NONE_TEXT, achNone, MID_BUFFER );
			if( strCategoryName.Compare( achNone ) == 0 )
			{
				strCategoryName.Empty();
			}
		}

		m_pStyle->m_pUndoMgr->SaveState( m_pStyle, theApp.m_hInstance, IDS_UNDO_STYLE_CATEGORY );
		m_pStyle->m_strCategoryName = strCategoryName;
		SetModifiedFlag();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnKillFocusTempo

void CTabStyleStyle::OnKillFocusTempo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CString strNewTempo;

		m_editTempo.GetWindowText( strNewTempo );

		// Strip leading and trailing spaces
		strNewTempo.TrimRight();
		strNewTempo.TrimLeft();

		if( strNewTempo.IsEmpty() )
		{
			SetTempoControlText();
		}
		else
		{
			double dblNewTempo;

			TCHAR* pszTempo;
			pszTempo = new TCHAR[strNewTempo.GetLength() + 1];

			if( pszTempo )
			{
				pszTempo[0] = 0;

				if( _stscanf( strNewTempo, "%lf%s", &dblNewTempo, pszTempo ) )
				{
					// Check bounds
					if( dblNewTempo > DMUS_TEMPO_MAX )
					{
						dblNewTempo = DMUS_TEMPO_MAX;
					}
					else if( dblNewTempo < DMUS_TEMPO_MIN )
					{
						dblNewTempo = DMUS_TEMPO_MIN;
					}

					m_pStyle->SetTempo( dblNewTempo, FALSE );
				}

				SetTempoControlText();	// Make sure edit control
										// reflects the tempo of m_pStyle
				delete pszTempo;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnDeltaPosTempoSpin

void CTabStyleStyle::OnDeltaPosTempoSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillFocusTempo();

		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		double dblNewTempo = floor( m_pStyle->m_dblTempo + pNMUpDown->iDelta );

		// If too small, wrap to DMUS_TEMPO_MAX
		if( dblNewTempo < DMUS_TEMPO_MIN )
		{
			dblNewTempo = DMUS_TEMPO_MAX;
		}
		// If too large, wrap to DMUS_TEMPO_MIN
		else if( dblNewTempo > DMUS_TEMPO_MAX )
		{
			dblNewTempo = DMUS_TEMPO_MIN;
		}

		// Sync edit control so OnKillFocus doesn't change it back
		CString strTempo;
		strTempo.Format( "%.2f", dblNewTempo );
		m_editTempo.SetWindowText( strTempo );

		m_pStyle->SetTempo( dblNewTempo, FALSE );
		SetTempoControlText();	// Make sure edit control
								// reflects results of SetTempo()
	}
	
	*pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle::OnTimeSignature

void CTabStyleStyle::OnTimeSignature() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pStyle )
	{
		CTimeSignatureDlg tsDlg;

		tsDlg.m_TimeSignature = m_pStyle->m_TimeSignature;
		tsDlg.m_nContext = IDS_STYLE_TEXT;

		if( tsDlg.DoModal() == IDOK )
		{
			// Update time signature
			m_pStyle->SetTimeSignature( tsDlg.m_TimeSignature, FALSE );

			// Update bitmap on time signature button
			SetTimeSignatureBitmap();
		}

		if( ::IsWindow( m_btnTimeSignature.m_hWnd ) )
		{
			m_btnTimeSignature.SetFocus();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabStyleStyle.h ===
#if !defined(AFX_TABSTYLESTYLE_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSTYLESTYLE_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabStyleStyle.h : header file
//

#include "resource.h"

class CStylePropPageManager;
class CDirectMusicStyle;

/////////////////////////////////////////////////////////////////////////////
// CTabStyleStyle dialog

class CTabStyleStyle : public CPropertyPage
{
// Construction
public:
	CTabStyleStyle( CStylePropPageManager* pStylePropPageManager );
	virtual ~CTabStyleStyle();
	void SetStyle( CDirectMusicStyle* pStyle );

// Dialog Data
	//{{AFX_DATA(CTabStyleStyle)
	enum { IDD = IDD_TAB_STYLE_STYLE };
	CButton	m_btnTimeSignature;
	CSpinButtonCtrl	m_spinTempo;
	CEdit	m_editTempo;
	CComboBox	m_cmbxCategory;
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabStyleStyle)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicStyle*		m_pStyle;
	CStylePropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetTempoControlText();
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void SetTimeSignatureBitmap();

	// Generated message map functions
	//{{AFX_MSG(CTabStyleStyle)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	afx_msg void OnKillFocusTempo();
	afx_msg void OnDeltaPosTempoSpin(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocusCategory();
	afx_msg void OnTimeSignature();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSTYLESTYLE_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabStyleInfo.h ===
#if !defined(AFX_TABSTYLEINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSTYLEINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabStyleInfo.h : header file
//

#include "resource.h"

class CStylePropPageManager;
class CDirectMusicStyle;

/////////////////////////////////////////////////////////////////////////////
// CTabStyleInfo dialog

class CTabStyleInfo : public CPropertyPage
{
// Construction
public:
	CTabStyleInfo( CStylePropPageManager* pStylePropPageManager );
	virtual ~CTabStyleInfo();
	void SetStyle( CDirectMusicStyle* pStyle );

// Dialog Data
	//{{AFX_DATA(CTabStyleInfo)
	enum { IDD = IDD_TAB_STYLE_INFO };
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editInfo;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabStyleInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicStyle*		m_pStyle;
	CStylePropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabStyleInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusInfo();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSTYLEINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabVarChoices.h ===
#if !defined(AFX_TABVARCHOICES_H__F3571522_8865_11D1_89AF_00A0C9054129__INCLUDED_)
#define AFX_TABVARCHOICES_H__F3571522_8865_11D1_89AF_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabVarChoices.h : header file
//

class CVarChoicesPropPageManager;

/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices dialog

class CTabVarChoices : public CPropertyPage
{
// Construction
public:
	CTabVarChoices( CVarChoicesPropPageManager* pVarChoicesPropPageManager );
	virtual ~CTabVarChoices();
	void SetVarChoices( CVarChoices* pVarChoices );

// Dialog Data
	//{{AFX_DATA(CTabVarChoices)
	enum { IDD = IDD_TAB_VARCHOICES };
	CSpinButtonCtrl	m_spinVariation;
	CEdit	m_editVariation;
	CButton	m_btnOther;
	CButton	m_btnMinor;
	CButton	m_btnMajor;
	CComboBox	m_comboFunction;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabVarChoices)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CVarChoices*				m_pVarChoices;
	CVarChoicesPropPageManager*	m_pPageManager;
	BOOL						m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabVarChoices)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABVARCHOICES_H__F3571522_8865_11D1_89AF_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TimeSignatureDlg.cpp ===
// TimeSignatureDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDll.h"
#include "Style.h"
#include "TimeSignatureDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg dialog

CTimeSignatureDlg::CTimeSignatureDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CTimeSignatureDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTimeSignatureDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_TimeSignature.m_bBeatsPerMeasure = 4;
	m_TimeSignature.m_bBeat = 4;
	m_TimeSignature.m_wGridsPerBeat = 4;

	m_nContext = IDS_STYLE_TEXT;
}


void CTimeSignatureDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTimeSignatureDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_GRID, m_cmbxGrid);
	DDX_Control(pDX, IDC_BPM_SPIN, m_spinBPM);
	DDX_Control(pDX, IDC_BPM, m_editBPM);
	DDX_Control(pDX, IDC_BEAT, m_cmbxBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTimeSignatureDlg, CDialog)
	//{{AFX_MSG_MAP(CTimeSignatureDlg)
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	ON_CBN_SELCHANGE(IDC_BEAT, OnSelChangeBeat)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnInitDialog

BOOL CTimeSignatureDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Set title
	CString strTitle;
	CString strContext;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );
	strContext.LoadString( m_nContext );
	AfxFormatString1( strTitle, IDS_SET_TIME_SIGNATURE, strContext );
	AfxSetResourceHandle( hInstance );
	SetWindowText( strTitle );

	// Set beats per measure
	m_editBPM.LimitText( 3 );
	m_spinBPM.SetRange( MIN_BEATS_PER_MEASURE, MAX_BEATS_PER_MEASURE );
	m_spinBPM.SetPos( m_TimeSignature.m_bBeatsPerMeasure );

	// Fill beat combo box
	TCHAR achBeat[SMALL_BUFFER];
	int i;

	for ( i = IDS_BEAT1 ;  i <= IDS_BEAT6 ;  i++ )
	{
		::LoadString( theApp.m_hInstance, i, achBeat, SMALL_BUFFER );
		m_cmbxBeat.AddString( achBeat );
	}

	// Set beat
	CString strBeat;

	strBeat.Format( "%d", m_TimeSignature.m_bBeat );
	int nPos = m_cmbxBeat.FindStringExact( -1, strBeat ); 
	m_cmbxBeat.SetCurSel( nPos );

	// Fill grids per beat combo box
	for( i = MIN_GRIDS_PER_BEAT ;  i <= MAX_GRIDS_PER_BEAT ;  i++ )
	{
		m_cmbxGrid.AddString( _T("") );
	}

	// Set grids per beat
	m_cmbxGrid.SetCurSel( m_TimeSignature.m_wGridsPerBeat - 1 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnSelChangeBeat

void CTimeSignatureDlg::OnSelChangeBeat() 
{
	m_cmbxGrid.Invalidate();	
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateBeatsPerMeasure

BOOL CTimeSignatureDlg::ValidateBeatsPerMeasure()
{
	CString strBeatsPerMeasure;

	m_editBPM.GetWindowText( strBeatsPerMeasure );

	// Strip leading and trailing spaces
	strBeatsPerMeasure.TrimRight();
	strBeatsPerMeasure.TrimLeft();

	WORD wBeatsPerMeasure = (WORD)_ttoi( strBeatsPerMeasure );

	// Validate new length
	if( wBeatsPerMeasure < MIN_BEATS_PER_MEASURE
	||  wBeatsPerMeasure > MAX_BEATS_PER_MEASURE )
	{
		CString strMsg;
		CString strMin;
		CString strMax;
		
		strMin.Format( "%d", MIN_BEATS_PER_MEASURE );
		strMax.Format( "%d", MAX_BEATS_PER_MEASURE );
		
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( theApp.m_hInstance );
		AfxFormatString2( strMsg, IDS_ERR_MIN_MAX, strMin, strMax );
		AfxSetResourceHandle( hInstance );
		AfxMessageBox( strMsg );

		m_editBPM.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateBeat

BOOL CTimeSignatureDlg::ValidateBeat()
{
	int nPos = m_cmbxBeat.GetCurSel();
	if( nPos == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( theApp.m_hInstance );
		AfxMessageBox( IDS_ERR_BEAT );
		AfxSetResourceHandle( hInstance );

		m_cmbxBeat.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::ValidateGridsPerBeat

BOOL CTimeSignatureDlg::ValidateGridsPerBeat()
{
	int nPos = m_cmbxGrid.GetCurSel();
	if( nPos == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( theApp.m_hInstance );
		AfxMessageBox( IDS_ERR_GRIDS_PER_BEAT );
		AfxSetResourceHandle( hInstance );

		m_cmbxGrid.SetFocus();
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnOK

void CTimeSignatureDlg::OnOK() 
{
	if( ValidateBeatsPerMeasure() == FALSE
	||  ValidateBeat() == FALSE
	||  ValidateGridsPerBeat() == FALSE )
	{
		return;
	}

	// Get beats per measure
	CString strBeatsPerMeasure;

	m_editBPM.GetWindowText( strBeatsPerMeasure );
	strBeatsPerMeasure.TrimRight();
	strBeatsPerMeasure.TrimLeft();
	m_TimeSignature.m_bBeatsPerMeasure = (BYTE)_ttoi( strBeatsPerMeasure );

	// Get beat
	int nPos = m_cmbxBeat.GetCurSel();
	if( nPos != CB_ERR )
	{
		CString strBeat;

		m_cmbxBeat.GetLBText( nPos, strBeat );
		m_TimeSignature.m_bBeat = (BYTE)_ttoi( strBeat );
	}

	// Get grids per beat
	nPos = m_cmbxGrid.GetCurSel();
	if( nPos != CB_ERR )
	{
		m_TimeSignature.m_wGridsPerBeat = (WORD)(nPos + 1);
	}

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnMeasureItem

void CTimeSignatureDlg::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			CBitmap bitmap;

			// Set height
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( theApp.m_hInstance );
			if( bitmap.LoadBitmap( IDB_GPB1 ) )
			{
				BITMAP bm;

				bitmap.GetBitmap( &bm );
				lpMeasureItemStruct->itemHeight = bm.bmHeight + 3;
			}
			AfxSetResourceHandle( hInstance );

			// Set width
			RECT rect;

			CWnd* pWnd = GetDlgItem( IDC_GRID );
			if( pWnd )
			{
				pWnd->GetClientRect( &rect );
				lpMeasureItemStruct->itemWidth = rect.right - rect.left;
			}
			return;
		}
	}
	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg::OnDrawItem

void CTimeSignatureDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_GRID:
		{
			if( lpDrawItemStruct->itemID == -1 )
			{
				return;
			}

			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_FOCUS )
			{
		        InflateRect( &lpDrawItemStruct->rcItem, -1, -1 ) ;
                pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
		        InflateRect( &lpDrawItemStruct->rcItem, 1, 1 ) ;
				return;
			}

            if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
            ||  lpDrawItemStruct->itemAction & ODA_SELECT )
			{
				CBitmap bitmap;

				// Get the resource id for the bitmap
				int nBeatPos = m_cmbxBeat.GetCurSel();
				int nResourceID = lpDrawItemStruct->itemID;
				if( nBeatPos != CB_ERR
				&&  nBeatPos != 2 )		// 2 = quarter note gets the beat
				{
					nResourceID += MAX_GRIDS_PER_BEAT;
				}
				ASSERT( (nResourceID >= 0) && (nResourceID <= MAX_GRIDS_PER_BEAT_ENTRIES) ); 

				// Load the bitmap
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( theApp.m_hInstance );

				if( bitmap.LoadBitmap( g_nGridsPerBeatBitmaps[nResourceID] ) )
				{
					CDC dcBitmap;

					if( dcBitmap.CreateCompatibleDC( pDC ) )
					{
						BITMAP bm;

						// Get the size of the bitmap
						bitmap.GetBitmap( &bm );

						// Clear the rectangle
						pDC->FillRect( &lpDrawItemStruct->rcItem,
									   CBrush::FromHandle( (HBRUSH)GetStockObject(WHITE_BRUSH) ) );

						// Paint the bitmap
						CBitmap* pOldBitmap = dcBitmap.SelectObject( &bitmap );
						pDC->BitBlt( lpDrawItemStruct->rcItem.left + 5, lpDrawItemStruct->rcItem.top + 1,
									 bm.bmWidth, bm.bmHeight,
									 &dcBitmap, 0, 0, SRCCOPY );
						dcBitmap.SelectObject( pOldBitmap );
					}
				}

				AfxSetResourceHandle( hInstance );

				// Invert if selected
                if( lpDrawItemStruct->itemState & ODS_SELECTED )
				{
					pDC->InvertRect( &lpDrawItemStruct->rcItem );
				}
			}

			return;
		}
	}
	
	CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TimeSignatureDlg.h ===
#if !defined(AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TimeSignatureDlg.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CTimeSignatureDlg dialog

class CTimeSignatureDlg : public CDialog
{
// Construction
public:
	CTimeSignatureDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTimeSignatureDlg)
	enum { IDD = IDD_TIME_SIGNATURE };
	CButton	m_btnOK;
	CComboBox	m_cmbxGrid;
	CSpinButtonCtrl	m_spinBPM;
	CEdit	m_editBPM;
	CComboBox	m_cmbxBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTimeSignatureDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DirectMusicTimeSig	m_TimeSignature;
	UINT				m_nContext;

protected:
	BOOL ValidateBeatsPerMeasure();
	BOOL ValidateBeat();
	BOOL ValidateGridsPerBeat();

	// Generated message map functions
	//{{AFX_MSG(CTimeSignatureDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnSelChangeBeat();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TIMESIGNATUREDLG_H__B2B7FA23_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\VarChoices.cpp ===
// CVarChoices.cpp : implementation file
//

#include "stdafx.h"
#include "VarChoices.h"
#include "Timeline.h"
#include "StyleDesignerDLL.h"
#include "StyleComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {EE59D340-88D9-11d1-89AF-00A0C9054129}
static const GUID GUID_VarChoicesPropPageManager = 
{ 0xee59d340, 0x88d9, 0x11d1, { 0x89, 0xaf, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


//////////////////////////////////////////////////////////////////////
// CVarChoicesPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVarChoicesPropPageManager::CVarChoicesPropPageManager()
{
	m_pTabVarChoices = NULL;
	m_GUIDManager = GUID_VarChoicesPropPageManager;
}

CVarChoicesPropPageManager::~CVarChoicesPropPageManager()
{
	if( m_pTabVarChoices )
	{
		delete m_pTabVarChoices;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesPropPageManager::RemoveCurrentObject

void CVarChoicesPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CVarChoicesPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strVarChoices;

	strVarChoices.LoadString( IDS_VARIATIONS_TEXT );

	CString strTitle = strVarChoices;

	CVarChoices* pVarChoices;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pVarChoices))) )
	{
		strTitle = pVarChoices->m_strTitle;
		/*
		strTitle.Empty();

		// "Style name - "
		if( pVarChoices->m_pPattern
		&&  pVarChoices->m_pPattern->m_pStyle )
		{
			strTitle = pVarChoices->m_pPattern->m_pStyle->m_strName;
			strTitle += _T(" - " );
		}

		// "Pattern name "
		if( pVarChoices->m_pPattern )
		{
			strTitle += pVarChoices->m_pPattern->m_strName;
			strTitle += _T(" " );
		}

		// "(Track name)"
		if( pVarChoices->m_pPartRef )
		{
			CString strTrack;
			TCHAR achTemp[MID_BUFFER];

			strTrack.LoadString( IDS_TRACK );
			sprintf( achTemp, "%s %d", strTrack, pVarChoices->m_pPartRef->m_dwPChannel + 1 );
			strTrack = achTemp;

			strTitle += _T("(" );
			strTitle += strTrack;
			strTitle += _T(") " );
		}
		*/

		// "Variation Choices"
		strTitle += _T(" ") + strVarChoices;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CVarChoicesPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);


	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add VarChoices tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	m_pTabVarChoices = new CTabVarChoices( this );
	if( m_pTabVarChoices )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabVarChoices->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CVarChoicesPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDllBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CVarChoicesPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CVarChoices* pVarChoices;
	
	if( m_pIPropPageObject == NULL )
	{
		pVarChoices = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pVarChoices ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current VarChoices are processed in OnKillFocus
	// messages before setting the new VarChoices
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabVarChoices->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new VarChoices
	m_pTabVarChoices->SetVarChoices( pVarChoices );

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVarChoices constructor/destructor

CVarChoices::CVarChoices()
{
    m_dwRef = 0;
	AddRef();

	/*
	if( m_pPattern->m_pStyle )
	{
		m_pIDocRootNode = m_pPattern->m_pStyle;
	}
	else
	*/
	{
		m_pIDocRootNode = NULL;
	}

	m_pIParentNode = NULL;

	m_hWndEditor = NULL;
	m_pVarChoicesCtrl = NULL;
	m_pCallback = NULL;
	m_nUndoText = 0;
	m_fInPaste = false;

	memset( &m_wp, 0, sizeof(WINDOWPLACEMENT) );
	memset( &m_dwSelectedFlagBtns, 0, sizeof(m_dwSelectedFlagBtns) );
	memset( &m_bSelectedRowBtns, 0, sizeof(m_bSelectedRowBtns) );

	for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
	{
		m_dwVariationChoices[i] = (DM_VF_MODE_DMUSIC | DM_VF_FLAG_BITS);	
	}
}

CVarChoices::~CVarChoices()
{
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Remove CVarChoices from clipboard
	theApp.FlushClipboard( this );

	// Remove CVarChoices from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Release the callback pointer
	RELEASE( m_pCallback );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IUnknown implementation

HRESULT CVarChoices::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }
	else if( ::IsEqualIID(riid, IID_IVarChoices) )
	{
		*ppvObj = (IVarChoices *)this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
	{
		*ppvObj = (IDMUSProdPropPageObject *)this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CVarChoices::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CVarChoices::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetNodeImageIndex

HRESULT CVarChoices::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return( theApp.m_pStyleComponent->GetPatternImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetFirstChild

HRESULT CVarChoices::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// VarChoices node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetNextChild

HRESULT CVarChoices::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// VarChoices node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetComponent

HRESULT CVarChoices::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );

	return theApp.m_pStyleComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetDocRootNode

HRESULT CVarChoices::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::SetDocRootNode

HRESULT CVarChoices::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetParentNode

HRESULT CVarChoices::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::SetParentNode

HRESULT CVarChoices::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetNodeId

HRESULT CVarChoices::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_VarChoicesNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetNodeName

HRESULT CVarChoices::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	strName.LoadString( IDS_NONE_TEXT );
	*pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetNodeNameMaxLength

HRESULT CVarChoices::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a VarChoices node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::ValidateNodeName

HRESULT CVarChoices::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a VarChoices node
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::SetNodeName

HRESULT CVarChoices::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a VarChoices node
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetNodeListInfo

HRESULT CVarChoices::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );
	UNREFERENCED_PARAMETER(pListInfo);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetEditorClsId

HRESULT CVarChoices::GetEditorClsId( CLSID* pClsId )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   *pClsId = CLSID_VarChoicesEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetEditorTitle

HRESULT CVarChoices::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	// "Variations: "
	::LoadString( theApp.m_hInstance, IDS_VARIATIONS_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );

	strTitle += m_strTitle;

	/*
	// "Style name - "
	if( m_pPattern
	&&  m_pPattern->m_pStyle )
	{
		strTitle += m_pPattern->m_pStyle->m_strName;
		strTitle += _T(" - " );
	}

	// "Pattern name "
	if( m_pPattern )
	{
		strTitle += m_pPattern->m_strName;
		strTitle += _T(" " );
	}

	// "(Track name)"
	if( m_pPartRef )
	{
		CString strTrack;
		TCHAR achTemp[MID_BUFFER];

		strTrack.LoadString( IDS_TRACK );
		sprintf( achTemp, "%s %d", strTrack, m_pPartRef->m_dwPChannel + 1 );
		strTrack = achTemp;

		strTitle += _T("(" );
		strTitle += strTrack;
		strTitle += _T(")" );
	}
	*/

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetEditorWindow

HRESULT CVarChoices::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::SetEditorWindow

HRESULT CVarChoices::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::UseOpenCloseImages

HRESULT CVarChoices::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetRightClickMenuId

HRESULT CVarChoices::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(phInstance);
	UNREFERENCED_PARAMETER(pnMenuId);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::OnRightClickMenuInit

HRESULT CVarChoices::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::OnRightClickMenuSelect

HRESULT CVarChoices::OnRightClickMenuSelect( long lCommandId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(lCommandId);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::DeleteChildNode

HRESULT CVarChoices::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// VarChoices nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::InsertChildNode

HRESULT CVarChoices::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// VarChoices nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::DeleteNode

HRESULT CVarChoices::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	// Remove from Component Style list
	ASSERT( 0 );
	// Remove from pattern or part ref or part list
	// Or set part's single varchoices class to null

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::OnNodeSelChanged

HRESULT CVarChoices::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CreateDataObject

HRESULT CVarChoices::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Style into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_VARCHOICES into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pStyleComponent->m_cfVarChoices, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CanCut

HRESULT CVarChoices::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove a VarChoices node
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CanCopy

HRESULT CVarChoices::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
	{
		if( m_bSelectedRowBtns[nRow] )
		{
			return S_OK;
		}
	}
 
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CanDelete

HRESULT CVarChoices::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove a VarChoices node
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CanDeleteChildNode

HRESULT CVarChoices::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// VarChoices nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CanPasteFromData

HRESULT CVarChoices::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pVarChoicesCtrl == NULL
	||  m_pVarChoicesCtrl->m_pVarChoicesDlg == NULL )
	{
		return E_UNEXPECTED;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfVarChoices ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::PasteFromData

HRESULT CVarChoices::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pVarChoicesCtrl == NULL
	||  m_pVarChoicesCtrl->m_pVarChoicesDlg == NULL )
	{
		return E_UNEXPECTED;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pStyleComponent->m_cfVarChoices ) ) )
	{
		// Handle CF_VARCHOICES format
		hr = PasteCF_VARCHOICES( pDataObject, pIDataObject );
		if( SUCCEEDED ( hr ) )
		{
			m_pVarChoicesCtrl->m_pVarChoicesDlg->m_fDirty = true;
			m_pVarChoicesCtrl->m_pVarChoicesDlg->SyncPattern();
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::CanChildPasteFromData

HRESULT CVarChoices::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	ASSERT( 0 );

	return E_NOTIMPL;	// VarChoices nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::ChildPasteFromData

HRESULT CVarChoices::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// VarChoices nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdNode::GetObject

HRESULT CVarChoices::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdPropPageObject::GetData

HRESULT CVarChoices::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdPropPageObject::SetData

HRESULT CVarChoices::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdPropPageObject::OnShowProperties

HRESULT CVarChoices::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	// Get the VarChoices page manager
	CVarChoicesPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_VarChoicesPropPageManager ) == S_OK )
	{
		pPageManager = (CVarChoicesPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CVarChoicesPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the VarChoices properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CVarChoices::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersist::GetClassID

HRESULT CVarChoices::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersistStream::IsDirty

HRESULT CVarChoices::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersistStream::Load

HRESULT CVarChoices::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DM_FOURCC_VARCHOICES_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = LoadVarChoices( pIRiffStream, &ckMain );

			if( m_fInPaste == false )
			{
				// Sync change with property sheet
				IDMUSProdPropSheet* pIPropSheet;
				if( SUCCEEDED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
				{
					pIPropSheet->RefreshTitleByObject( this );
					pIPropSheet->RefreshActivePageByObject( this );
					RELEASE( pIPropSheet );
				}

				// Sync changes with the dialog
				if( m_pVarChoicesCtrl
				&&	m_pVarChoicesCtrl->m_pVarChoicesDlg )
				{
					m_pVarChoicesCtrl->m_pVarChoicesDlg->RefreshControls();
				}
			}
		}

		RELEASE( pIRiffStream );
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersistStream::Save

HRESULT CVarChoices::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fClearDirty);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DM_FOURCC_VARCHOICES_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveVarChoices( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IPersistStream::GetSizeMax

HRESULT CVarChoices::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices Additional functions

/////////////////////////////////////////////////////////////////////////////
// CVarChoices::PasteCF_VARCHOICES

HRESULT CVarChoices::PasteCF_VARCHOICES( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	DWORD dwCurVariationChoices[NBR_VARIATIONS];
	DWORD dwCurSelectedFlagBtns[NBR_VARIATIONS];
	BYTE bCurSelectedRowBtns[NBR_VARIATIONS];	

	DWORD dwClipVariationChoices[NBR_VARIATIONS];
	DWORD dwClipSelectedFlagBtns[NBR_VARIATIONS];
	BYTE bClipSelectedRowBtns[NBR_VARIATIONS];	

	IStream* pIStream;
	HRESULT hr = E_FAIL;

	// Save current flags
	memcpy( &dwCurVariationChoices, &m_dwVariationChoices, sizeof(dwCurVariationChoices) );
	memcpy( &dwCurSelectedFlagBtns, &m_dwSelectedFlagBtns, sizeof(dwCurSelectedFlagBtns) );
	memcpy( &bCurSelectedRowBtns, &m_bSelectedRowBtns, sizeof(bCurSelectedRowBtns) );

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pStyleComponent->m_cfVarChoices, &pIStream  ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		m_fInPaste = true;
		hr = Load( pIStream );
		m_fInPaste = false;

		if( SUCCEEDED ( hr ) )
		{
			// Save clipboard flags
			memcpy( &dwClipVariationChoices, &m_dwVariationChoices, sizeof(dwClipVariationChoices) );
			memcpy( &dwClipSelectedFlagBtns, &m_dwSelectedFlagBtns, sizeof(dwClipSelectedFlagBtns) );
			memcpy( &bClipSelectedRowBtns, &m_bSelectedRowBtns, sizeof(bClipSelectedRowBtns) );

			// Restore current flags
			memcpy( &m_dwVariationChoices, &dwCurVariationChoices, sizeof(m_dwVariationChoices) );
			memcpy( &m_dwSelectedFlagBtns, &dwCurSelectedFlagBtns, sizeof(m_dwSelectedFlagBtns) );
			memcpy( &m_bSelectedRowBtns, &bCurSelectedRowBtns, sizeof(m_bSelectedRowBtns) );

			short nNbrCurRows = 0;
			short nNbrClipRows = 0;

			for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
			{
				if( bClipSelectedRowBtns[nRow] )
				{
					nNbrClipRows++;
				}

				if( bCurSelectedRowBtns[nRow] )
				{
					nNbrCurRows++;
				}
			}

			// Paste takes place here!!!
			if( nNbrClipRows == nNbrCurRows )
			{
				short nClipRow = 0;
				
				m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES_PASTE;

				for( short nCurRow = 0 ; nCurRow < NBR_VARIATIONS ; nCurRow++ )
				{
					if( bCurSelectedRowBtns[nCurRow] )
					{
						for( ;  nClipRow < NBR_VARIATIONS ;  nClipRow++ )
						{
							if( bClipSelectedRowBtns[nClipRow] )
							{
								m_dwVariationChoices[nCurRow] = dwClipVariationChoices[nClipRow];
								nClipRow++;
								break;
							}
							ASSERT( nClipRow != (NBR_VARIATIONS - 1) );
						}
					}
				}
			}
			else
			{
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( theApp.m_hInstance );
				AfxMessageBox( IDS_ERR_VARCHOICES_PASTE );
				AfxSetResourceHandle( hInstance );
				hr = E_FAIL;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		memset( &m_dwSelectedFlagBtns, 0, sizeof(m_dwSelectedFlagBtns) );
		memset( &m_bSelectedRowBtns, 0, sizeof(m_bSelectedRowBtns) );
	}
	else
	{
		// Restore current flags
		memcpy( &m_dwVariationChoices, &dwCurVariationChoices, sizeof(m_dwVariationChoices) );
		memcpy( &m_dwSelectedFlagBtns, &dwCurSelectedFlagBtns, sizeof(m_dwSelectedFlagBtns) );
		memcpy( &m_bSelectedRowBtns, &bCurSelectedRowBtns, sizeof(m_bSelectedRowBtns) );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices::SaveVarChoices

HRESULT CVarChoices::SaveVarChoices( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	int i;
	ioVarChoices oVarChoices;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write VarChoices chunk header
	ck.ckid = DM_FOURCC_VARCHOICES_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioVarChoices structure
	memset( &oVarChoices, 0, sizeof(ioVarChoices) );

	for( i = 0 ;  i < NBR_VARIATIONS ;  i++ )
	{
		oVarChoices.m_dwVariationChoices[i] = m_dwVariationChoices[i];
		oVarChoices.m_dwSelectedFlagBtns[i] = m_dwSelectedFlagBtns[i];
		oVarChoices.m_bSelectedRowBtns[i] = m_bSelectedRowBtns[i];	
	}

	// Write VarChoices chunk data
	hr = pIStream->Write( &oVarChoices, sizeof(ioVarChoices), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioVarChoices) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices::LoadVarChoices

HRESULT CVarChoices::LoadVarChoices( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream* pIStream;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
	int	i;
    HRESULT hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DM_FOURCC_VARCHOICES_CHUNK:
			{
				ioVarChoices iVarChoices;

				dwSize = min( ck.cksize, sizeof( ioVarChoices ) );
				hr = pIStream->Read( &iVarChoices, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				for( i = 0 ;  i < NBR_VARIATIONS ;  i++ )
				{
					m_dwVariationChoices[i] = iVarChoices.m_dwVariationChoices[i];
					m_dwSelectedFlagBtns[i] = iVarChoices.m_dwSelectedFlagBtns[i];
					m_bSelectedRowBtns[i] = iVarChoices.m_bSelectedRowBtns[i];	
				}
				break;
			}
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IVarChoices implementation

/////////////////////////////////////////////////////////////////////////////
// CVarChoices IVarChoices::SetVarChoicesTitle

HRESULT CVarChoices::SetVarChoicesTitle(BSTR bstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( bstrTitle == NULL )
	{
		return E_POINTER;
	}

	m_strTitle = bstrTitle;

	::SysFreeString( bstrTitle );

	// TODO: Update name of open windows?

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IVarChoices::SetDataChangedCallback

HRESULT CVarChoices::SetDataChangedCallback( IUnknown *punkCallback )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( punkCallback == NULL )
	{
		return E_POINTER;
	}

	RELEASE( m_pCallback );

	return punkCallback->QueryInterface( IID_IDMUSProdTimelineCallback, (void **)&m_pCallback );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoices IVarChoices::GetUndoText

HRESULT CVarChoices::GetUndoText( BSTR *pbstrUndoText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrUndoText == NULL )
	{
		return E_POINTER;
	}

	CString strUndoText;
	if( strUndoText.LoadString( m_nUndoText ) )
	{
		*pbstrUndoText = strUndoText.AllocSysString();
		return S_OK;
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\TabVarChoices.cpp ===
// TabVarChoices.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "VarChoices.h"
#include "TabVarChoices.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices property page

CTabVarChoices::CTabVarChoices( CVarChoicesPropPageManager* pVarChoicesPropPageManager ) : CPropertyPage(CTabVarChoices::IDD)
{
	//{{AFX_DATA_INIT(CTabVarChoices)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	ASSERT( pVarChoicesPropPageManager != NULL );

	m_pVarChoices = NULL;
	m_pPageManager = pVarChoicesPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabVarChoices::~CTabVarChoices()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices::SetVarChoices

void CTabVarChoices::SetVarChoices( CVarChoices* pVarChoices )
{
	m_pVarChoices = pVarChoices;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices::EnableControls

void CTabVarChoices::EnableControls( BOOL fEnable ) 
{
	m_editVariation.EnableWindow( fEnable );
	m_spinVariation.EnableWindow( fEnable );
	m_comboFunction.EnableWindow( fEnable );
	m_btnMajor.EnableWindow( fEnable );
	m_btnMinor.EnableWindow( fEnable );
	m_btnOther.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices::UpdateControls

void CTabVarChoices::UpdateControls()
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVariation.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVariation.LimitText( 2 );

	if( m_pVarChoices )
	{
		EnableControls( TRUE );

		// Set Variation
		m_spinVariation.SetRange( 1, NBR_VARIATIONS );
		m_spinVariation.SetPos( 1 );

		// Set Function
		m_comboFunction.SetCurSel( 0 );

		// Set Major
		m_btnMajor.SetCheck( 0 );

		// Set Minor
		m_btnMinor.SetCheck( 0 );

		// Set Other
		m_btnOther.SetCheck( 0 );
	}
	else
	{
		m_spinVariation.SetRange( 1, NBR_VARIATIONS );
		m_spinVariation.SetPos( 1 );
		m_btnMajor.SetCheck( 0 );
		m_btnMinor.SetCheck( 0 );
		m_btnOther.SetCheck( 0 );

		EnableControls( FALSE );
	}
}


void CTabVarChoices::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabVarChoices)
	DDX_Control(pDX, IDC_VARIATION_SPIN, m_spinVariation);
	DDX_Control(pDX, IDC_VARIATION, m_editVariation);
	DDX_Control(pDX, IDC_OTHER, m_btnOther);
	DDX_Control(pDX, IDC_MINOR, m_btnMinor);
	DDX_Control(pDX, IDC_MAJOR, m_btnMajor);
	DDX_Control(pDX, IDC_FUNCTION, m_comboFunction);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabVarChoices, CPropertyPage)
	//{{AFX_MSG_MAP(CTabVarChoices)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices::OnSetActive

BOOL CTabVarChoices::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices::OnCreate

int CTabVarChoices::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVarChoices::OnDestroy

void CTabVarChoices::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\VarChoices.h ===
#ifndef __VARCHOICES_H__
#define __VARCHOICES_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// VarChoices.h : header file
//

#include "RiffStrm.h"
#include "VarChoicesCtl.h"
#include "TabVarChoices.h"
#include "Pattern.h"
#include "StyleDesigner.h"
#include "SharedPattern.h"

interface IDMUSProdTimelineCallback;


//////////////////////////////////////////////////////////////////////
//  CVarChoicesPropPageManager

class CVarChoicesPropPageManager : public CDllBasePropPageManager 
{
friend class CTabVarChoices;

public:
	CVarChoicesPropPageManager();
	virtual ~CVarChoicesPropPageManager();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
	CTabVarChoices*		m_pTabVarChoices;
};


//////////////////////////////////////////////////////////////////////
//  CVarChoices

class CVarChoices : public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject, public IVarChoices
{
friend class CVarChoicesCtrl;
friend class CVarChoicesDlg;
friend class CVarChoicesFlagsBtn;
friend class CVarChoicesRowsBtn;
friend class CVarChoicesPropPageManager;
friend class CTabVarChoices;

public:
    CVarChoices();
	~CVarChoices();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

    // IVarChoices functions
	HRESULT	STDMETHODCALLTYPE SetVarChoicesTitle( BSTR bstrTitle );
	HRESULT STDMETHODCALLTYPE SetDataChangedCallback( IUnknown *punkCallback );
	HRESULT STDMETHODCALLTYPE GetUndoText( BSTR *pbstrUndoText );

	//Additional functions
protected:
	HRESULT PasteCF_VARCHOICES( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
    HRESULT SaveVarChoices( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT LoadVarChoices( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

private:
    DWORD					m_dwRef;

	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	CString					m_strTitle;
	IDMUSProdTimelineCallback* m_pCallback;

	int						m_nUndoText;
	HWND					m_hWndEditor;
	WINDOWPLACEMENT			m_wp;
	DWORD					m_dwVariationChoices[NBR_VARIATIONS];		// MOAW choices bitfield
	DWORD				    m_dwSelectedFlagBtns[NBR_VARIATIONS];		// selected function buttons
	BYTE				    m_bSelectedRowBtns[NBR_VARIATIONS];			// selected function buttons
	
	bool					m_fInPaste;

public:
	CVarChoicesCtrl*		m_pVarChoicesCtrl;
};

#endif // __VARCHOICES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\VarChoicesCtl.cpp ===
// VarChoicesCtl.cpp : Implementation of the CVarChoicesCtrl ActiveX Control class.

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "VarChoices.h"
#include "VarChoicesCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CVarChoicesCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CVarChoicesCtrl, COleControl)
	//{{AFX_MSG_MAP(CVarChoicesCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CVarChoicesCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CVarChoicesCtrl)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CVarChoicesCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CVarChoicesCtrl, COleControl)
	//{{AFX_EVENT_MAP(CVarChoicesCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl Interface map

BEGIN_INTERFACE_MAP(CVarChoicesCtrl, COleControl)
    INTERFACE_PART(CVarChoicesCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CVarChoicesCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CVarChoicesCtrl, "STYLEDESIGNER.VarChoicesCtrl.1",
	0x3bd2ba15, 0x46e7, 0x11d0, 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CVarChoicesCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DVarChoices =
		{ 0x3bd2ba13, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DVarChoicesEvents =
		{ 0x3bd2ba14, 0x46e7, 0x11d0, { 0x89, 0xac, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwVarChoicesOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CVarChoicesCtrl, IDS_VARCHOICES, _dwVarChoicesOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::CVarChoicesCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CVarChoicesCtrl

BOOL CVarChoicesCtrl::CVarChoicesCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_VARCHOICES,
			IDB_VARCHOICES,
			afxRegApartmentThreading,
			_dwVarChoicesOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::CVarChoicesCtrl - Constructor

CVarChoicesCtrl::CVarChoicesCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DVarChoices, &IID_DVarChoicesEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DVarChoices;
	m_piidEvents = &IID_DVarChoicesEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pVarChoicesDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_pVarChoices = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::~CVarChoicesCtrl - Destructor

CVarChoicesCtrl::~CVarChoicesCtrl()
{
	RELEASE( m_pVarChoices );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CVarChoicesCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CVarChoicesCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CVarChoicesCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CVarChoicesCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::QueryInterface

STDMETHODIMP CVarChoicesCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CVarChoicesCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::AttachObjects implementation

HRESULT CVarChoicesCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	pThis->m_pVarChoices = (CVarChoices *)pINode;

	ASSERT( pThis->m_pVarChoices != NULL );
	pThis->m_pVarChoices->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::OnInitMenuFilePrint

HRESULT CVarChoicesCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::OnFilePrint

HRESULT CVarChoicesCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CVarChoicesCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::OnFilePrintPreview

HRESULT CVarChoicesCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::OnViewProperties

HRESULT CVarChoicesCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pVarChoicesDlg )
	{
		if( pThis->m_pVarChoicesDlg->OnViewProperties() )
		{
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XEditor::OnF1Help

HRESULT CVarChoicesCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/VariationChoicesWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CVarChoicesCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CVarChoicesCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	
//	OLEINPLACEFRAMEINFO frameInfo = pThis->m_frameInfo;
//	if( ::OleTranslateAccelerator(pThis->m_pInPlaceFrame, &frameInfo, lpmsg) == S_OK )
//	{
//		return S_OK;
//	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CVarChoicesCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CVarChoicesCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnDraw - Drawing function

void CVarChoicesCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::DoPropExchange - Persistence support

void CVarChoicesCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CVarChoicesAbout dialog used for VarChoices Editor About Box

class CVarChoicesAbout : public CDialog
{
public:
	CVarChoicesAbout();

// Dialog Data
	//{{AFX_DATA(CVarChoicesAbout)
	enum { IDD = IDD_ABOUTBOX_VARCHOICES };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarChoicesAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CVarChoicesAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CVarChoicesAbout::CVarChoicesAbout() : CDialog(CVarChoicesAbout::IDD)
{
	//{{AFX_DATA_INIT(CVarChoicesAbout)
	//}}AFX_DATA_INIT
}

void CVarChoicesAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVarChoicesAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CVarChoicesAbout, CDialog)
	//{{AFX_MSG_MAP(CVarChoicesAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CVarChoicesAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_VARCHOICES_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::AboutBox - Display an "About" box to the user

void CVarChoicesCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CVarChoicesAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnCreate

int CVarChoicesCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if( COleControl::OnCreate(lpCreateStruct) == -1 )
		return -1;

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_VARCHOICES_EDITOR) );


	// Create control's dialog
	{
		CDC* pDC = GetDC();
		if( pDC )
		{
			TEXTMETRIC tm;

			pDC->GetTextMetrics( &tm );

			if( tm.tmAveCharWidth < 8 )	// Small Fonts
			{
				HRSRC hRes = ::FindResource( theApp.m_hInstance, MAKEINTRESOURCE(IDD_DLG_VARCHOICES), RT_DIALOG );
				if( hRes )
				{
					HGLOBAL hTemplate = ::LoadResource( theApp.m_hInstance, hRes );
					if( hTemplate )
					{
						DLGTEMPLATE* pTemplate = (DLGTEMPLATE *)::LockResource( hTemplate );
						if( pTemplate )
						{
							pTemplate->cx = 530;
							pTemplate->cy = 368;

							UnlockResource( hTemplate );
						}

						::FreeResource( hTemplate );
					}
				}
			}

			ReleaseDC( pDC );
		}

		m_pVarChoicesDlg = new CVarChoicesDlg;
		if( m_pVarChoicesDlg == NULL )
		{
			return -1;
		}

		m_pVarChoices->m_pVarChoicesCtrl = this;

		m_pVarChoicesDlg->m_pVarChoices = m_pVarChoices;
		m_pVarChoicesDlg->m_pVarChoicesCtrl = this;
		m_pVarChoicesDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL );
		m_pVarChoicesDlg->OnInitialUpdate();
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnDestroy

void CVarChoicesCtrl::OnDestroy() 
{
	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	ASSERT( m_pVarChoices != NULL );

	// Get Frame's WINDOWPLACEMENT information
	CWnd* pWndParent = GetParent();
	if( pWndParent )
	{
		pWndParent = pWndParent->GetParent();
		if( pWndParent )
		{
			pWndParent = pWndParent->GetParent();
			if( pWndParent )
			{
				m_pVarChoices->m_wp.length = sizeof(m_pVarChoices->m_wp);
				if( pWndParent->GetWindowPlacement( &m_pVarChoices->m_wp ) == FALSE )
				{
					memset( &m_pVarChoices->m_wp, 0, sizeof(WINDOWPLACEMENT) );
				}
			}
		}
	}

	m_pVarChoices->m_pVarChoicesCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnGetInPlaceMenu

HMENU CVarChoicesCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnHideToolBars

void CVarChoicesCtrl::OnHideToolBars() 
{
	COleControl::OnHideToolBars();
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnShowToolBars

void CVarChoicesCtrl::OnShowToolBars() 
{
	CRect rectBorder;

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	COleControl::OnShowToolBars();
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnSize

void CVarChoicesCtrl::OnSize( UINT nType, int cx, int cy ) 
{
	COleControl::OnSize( nType, cx, cy );

	m_pVarChoicesDlg->MoveWindow( 0, 0, cx, cy );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnUpdateEditUndo

void CVarChoicesCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	ASSERT( m_pVarChoices != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pVarChoices
	&&  m_pVarChoices->m_pPattern )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pVarChoices->m_pPattern->m_pUndoMgr != NULL );

		if( m_pVarChoices->m_pPattern->m_pUndoMgr )
		{
			if( m_pVarChoices->m_pPattern->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
	*/
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnEditUndo

void CVarChoicesCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices
	&&  m_pVarChoices->m_pPattern )
	{
		ASSERT( m_pVarChoices->m_pPattern->m_pUndoMgr != NULL );

		if( m_pVarChoices->m_pPattern->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pVarChoices->m_pPattern->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				m_pVarChoices->m_pPattern->m_pUndoMgr->Undo( m_pVarChoices->m_pPattern );
				m_pVarChoices->m_pPattern->SetModified( TRUE );
			}
		}
	}
	*/
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnUpdateEditRedo

void CVarChoicesCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	ASSERT( m_pVarChoices != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pVarChoices
	&&  m_pVarChoices->m_pPattern )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pVarChoices->m_pPattern->m_pUndoMgr != NULL );

		if( m_pVarChoices->m_pPattern->m_pUndoMgr )
		{
			if( m_pVarChoices->m_pPattern->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
	*/
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnEditRedo

void CVarChoicesCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices
	&&  m_pVarChoices->m_pPattern )
	{
		ASSERT( m_pVarChoices->m_pPattern->m_pUndoMgr != NULL );

		if( m_pVarChoices->m_pPattern->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pVarChoices->m_pPattern->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				m_pVarChoices->m_pPattern->m_pUndoMgr->Redo( m_pVarChoices->m_pPattern );
				m_pVarChoices->m_pPattern->SetModified( TRUE );
			}
		}
	}
	*/
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnUpdateEditCopy

void CVarChoicesCtrl::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	if( m_pVarChoicesDlg )
	{
		m_pVarChoicesDlg->OnUpdateEditCopy( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnEditCopy

void CVarChoicesCtrl::OnEditCopy() 
{
	if( m_pVarChoicesDlg )
	{
		m_pVarChoicesDlg->OnEditCopy();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnUpdateEditPaste

void CVarChoicesCtrl::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	if( m_pVarChoicesDlg )
	{
		m_pVarChoicesDlg->OnUpdateEditPaste( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnEditPaste

void CVarChoicesCtrl::OnEditPaste() 
{
	if( m_pVarChoicesDlg )
	{
		m_pVarChoicesDlg->OnEditPaste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::PreTranslateMessage

BOOL CVarChoicesCtrl::PreTranslateMessage( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case 0x59:	// VK_Y		(Redo)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditRedo();
						return TRUE;
					}
					break;

				case 0x5A:	// VK_Z		(Undo)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditUndo();
						return TRUE;
					}
					break;

				default:
					if( m_pVarChoicesDlg )
					{
						if( m_pVarChoicesDlg->HandleKeyDown( pMsg ) )
						{
							return TRUE;
						}
					}
					break;
			}
			break;
	}
	
	return COleControl::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl::OnHelpFinder

void CVarChoicesCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\VarChoicesCtl.h ===
#if !defined(VARCHOICESCTL_H__3BD2BA23_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
#define VARCHOICESCTL_H__3BD2BA23_46E7_11D0_89AC_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// VarChoicesCtl.h : Declaration of the CVarChoicesCtrl ActiveX Control class.

#include "VarChoicesDlg.h"
#include "DMusProd.h"

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesCtrl : See VarChoicesCtl.cpp for implementation.

class CVarChoicesCtrl : public COleControl
{
friend class CVarChoices;
friend class CVarChoicesDlg;

	DECLARE_DYNCREATE(CVarChoicesCtrl)

// Constructor
public:
	CVarChoicesCtrl();

// Attributes
public:
	CVarChoicesDlg*			m_pVarChoicesDlg;

private:
	HWND					m_hWndContainer;
	HMENU					m_hMenuInPlace;
	CVarChoices*			m_pVarChoices;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarChoicesCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CVarChoicesCtrl();

	DECLARE_OLECREATE_EX(CVarChoicesCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CVarChoicesCtrl)      // GetTypeInfo
	DECLARE_OLECTLTYPE(CVarChoicesCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CVarChoicesCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditRedo();
	afx_msg void OnHelpFinder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CVarChoicesCtrl)
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CVarChoicesCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CVarChoicesCtrl)
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(VARCHOICESCTL_H__3BD2BA23_46E7_11D0_89AC_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\VarChoicesDlg.cpp ===
// VarChoicesDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "Style.h"
#include "VarChoices.h"
#include "VarChoicesCtl.h"
#include "VarChoicesDlg.h"
#include <ioDMStyle.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SMALL_BTN			0
#define MEDIUM_BTN			6
#define LARGE_BTN			12

#define BIT_ON				0
#define BIT_ON_SEL			1
#define BIT_ON_DIS			2
#define BIT_OFF				3
#define BIT_OFF_SEL			4
#define BIT_OFF_DIS			5

#define BTN_SM_BIT_ON		0
#define BTN_SM_BIT_ON_SEL	1
#define BTN_SM_BIT_ON_DIS	2
#define BTN_SM_BIT_OFF		3
#define BTN_SM_BIT_OFF_SEL	4
#define BTN_SM_BIT_OFF_DIS	5
#define BTN_MD_BIT_ON		6
#define BTN_MD_BIT_ON_SEL	7
#define BTN_MD_BIT_ON_DIS	8
#define BTN_MD_BIT_OFF		9
#define BTN_MD_BIT_OFF_SEL	10
#define BTN_MD_BIT_OFF_DIS	11
#define BTN_LG_BIT_ON		12
#define BTN_LG_BIT_ON_SEL	13
#define BTN_LG_BIT_ON_DIS	14
#define BTN_LG_BIT_OFF		15
#define BTN_LG_BIT_OFF_SEL	16
#define BTN_LG_BIT_OFF_DIS	17
#define NBR_BTN_BITMAPS		18

// Button bitmap array
static CBitmap	abmpButton[NBR_BTN_BITMAPS];

// Button sizes
static int sg_nBtnHeight = 0;
static int sg_nSmallBtnWidth = 0;
static int sg_nMediumBtnWidth = 0;
static int sg_nLargeBtnWidth = 0;

// Button bitmaps
static CBitmap sg_bmpRowOnUp;
static CBitmap sg_bmpRowOnDown;


// Used when tracking the mouse
static short sg_nSetBitFlagState = -1;
static short sg_nSetBitSelectState = -1;
static short sg_nFirstSelectedRow = -1;
static short sg_nFirstSelectedBtnRow = -1;
static short sg_nFirstSelectedBtnColumn = -1;


// DirectMusic mode /////////////////////////////////////////
#define DM_NBR_COLUMNS		30

// X positions associated with DirectMusic buttons
static short sga_DM_XPos[DM_NBR_COLUMNS];

// Text associated with DirectMusic buttons
static TCHAR sga_DM_Text[DM_NBR_COLUMNS][SMALL_BUFFER];

// Bitmaps associated with DirectMusic buttons
const static short sga_DM_AssociatedBmp[DM_NBR_COLUMNS] =
		{ SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  SMALL_BTN, SMALL_BTN, SMALL_BTN,
		  MEDIUM_BTN, MEDIUM_BTN, MEDIUM_BTN, SMALL_BTN, SMALL_BTN, MEDIUM_BTN,
		  MEDIUM_BTN, MEDIUM_BTN, MEDIUM_BTN };


// IMA mode /////////////////////////////////////////////////
#define IMA_NBR_COLUMNS		15

// X positions associated with IMA buttons
static short sga_IMA_XPos[IMA_NBR_COLUMNS];

// Text associated with IMA buttons
static TCHAR sga_IMA_Text[IMA_NBR_COLUMNS][SMALL_BUFFER];

// Bitmaps associated with IMA buttons
const static short sga_IMA_AssociatedBmp[IMA_NBR_COLUMNS] =
		{ LARGE_BTN,
		  LARGE_BTN,
		  LARGE_BTN,
		  LARGE_BTN,
		  LARGE_BTN,
		  LARGE_BTN,
		  LARGE_BTN,
		  MEDIUM_BTN, SMALL_BTN, SMALL_BTN, MEDIUM_BTN, MEDIUM_BTN, MEDIUM_BTN,
		  LARGE_BTN, LARGE_BTN };


// Various types of modes (rows) ////////////////////////////
#define IMA_ROWTYPE		0
#define DM_ROWTYPE		1
#define NBR_ROWTYPES	2

// Arrays associated with buttons
const static short* sga_nBtnXPos[NBR_ROWTYPES] = {			// Button X positions
	&sga_IMA_XPos[0],
	&sga_DM_XPos[0] };
const static short* sga_nBtnBmp[NBR_ROWTYPES] = {			// Associated bitmaps
	&sga_IMA_AssociatedBmp[0],
	&sga_DM_AssociatedBmp[0] };
// This array is defined in SharedPattern.cpp
extern const short* sga_nBtnBit[NBR_ROWTYPES];	// Associated dwVariationChoices bits


/////////////////////////////////////////////////////////////////////////////
// Function DrawBitMap

static void DrawBitMap( CDC* pDC, CBitmap* pBitmap, int nDestX, int nDestY,
						int nSourceX, int nSourceY )
{
	// This is a much quicker and simpler way to send a bitmap to the screen.
	// Note: You MUST set the dimensions earlier via a call to SetBitmapDimension()!
	pDC->DrawState( CPoint(nDestX, nDestY), pBitmap->GetBitmapDimension(), pBitmap, DSS_NORMAL );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn

CVarChoicesFlagsBtn::CVarChoicesFlagsBtn()
{
}

CVarChoicesFlagsBtn::~CVarChoicesFlagsBtn()
{
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::IMA_DrawButtonText

void CVarChoicesFlagsBtn::IMA_DrawButtonText( CDC* pDC, CRect* pRect, short nRow, short nColumn )
{
    pDC->DrawText( sga_IMA_Text[nColumn], -1, pRect, (DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_NOPREFIX) );
} 


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::DM_DrawButtonText

void CVarChoicesFlagsBtn::DM_DrawButtonText( CDC* pDC, CRect* pRect, short nRow, short nColumn )
{
	CFont* pFontOld;
	BOOL fItalics = FALSE;

	ASSERT( m_pVarChoicesDlg != NULL );
	ASSERT( m_pVarChoicesDlg->m_pVarChoices != NULL );

	if( nColumn < 21
	&& (nColumn % 3) == 2 )
	{
		fItalics = TRUE;
	}

	if( fItalics )
	{
		if( m_pVarChoicesDlg->IsBitOn( nRow, nColumn )
		||  m_pVarChoicesDlg->IsRowDisabled( nRow ) )
		{
			pFontOld = pDC->SelectObject( m_pVarChoicesDlg->m_pFontItalicsBold );
		}
		else
		{
			pFontOld = pDC->SelectObject( m_pVarChoicesDlg->m_pFontItalics );
		}
	}

    pDC->DrawText( sga_DM_Text[nColumn], -1, pRect, (DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_NOPREFIX) );

	if( fItalics )
	{
		pDC->SelectObject( pFontOld );
	}
} 


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::DrawOneButton

void CVarChoicesFlagsBtn::DrawOneButton( CDC* pDC, short nRow, short nColumn, BOOL fDrawOne )
{
	CFont* pFontOld;
	int nBkModeOld;
	CRect rect;

	ASSERT( m_pVarChoicesDlg != NULL );
	ASSERT( m_pVarChoicesDlg->m_pVarChoices != NULL );

	// Determine what kind of buttons are in the row
	short nRowType = m_pVarChoicesDlg->GetRowType( nRow );

    // Determine rectangle of button
	if( fDrawOne )
	{
        rect.top = sg_nBtnHeight * nRow;
	}
    else
	{
        rect.top = 0;
	}
    rect.bottom = rect.top + sg_nBtnHeight;
    rect.left   = sga_nBtnXPos[nRowType][nColumn];
    rect.right  = rect.left + m_pVarChoicesDlg->GetBtnWidth( nRow, nColumn );
	
	// Draw the background
	short nAssociatedBmp = sga_nBtnBmp[nRowType][nColumn];

	if( m_pVarChoicesDlg->IsBtnSelected( nRow, nColumn ) )
    {
		// Button is selected
		if( m_pVarChoicesDlg->IsBitOn( nRow, nColumn ) )
		{
		    // Bit is on
			pDC->SetTextColor( RGB(0,0,0) );
			DrawBitMap( pDC, &abmpButton[nAssociatedBmp + BIT_ON_SEL], rect.left, rect.top, 0, 0 );
			rect.top  += 2; 
			rect.left += 2;
		}
		else
		{
		    // Bit is off
			pDC->SetTextColor( ::GetSysColor(COLOR_BTNSHADOW) );
			DrawBitMap( pDC, &abmpButton[nAssociatedBmp + BIT_OFF_SEL], rect.left, rect.top, 0, 0 );
		}
    }
    else
    {
		// Button is not selected
		if( m_pVarChoicesDlg->IsRowDisabled( nRow ) )
		{
			// Row is disabled
			pDC->SetTextColor( ::GetSysColor(COLOR_BTNSHADOW) );
			if( m_pVarChoicesDlg->IsBitOn( nRow, nColumn ) )
			{
				// Bit is on
				DrawBitMap( pDC, &abmpButton[nAssociatedBmp + BIT_ON_DIS], rect.left, rect.top, 0, 0 );
				rect.top  += 2; 
				rect.left += 2;
			}
			else
			{
			    // Bit is off
				DrawBitMap( pDC, &abmpButton[nAssociatedBmp + BIT_OFF_DIS], rect.left, rect.top, 0, 0 );
			}
		}
		else if( m_pVarChoicesDlg->IsBitOn( nRow, nColumn ) )
		{
		    // Bit is on
		    pDC->SetTextColor( RGB(0,0,0) );
			DrawBitMap( pDC, &abmpButton[nAssociatedBmp + BIT_ON], rect.left, rect.top, 0, 0 );
			rect.top  += 2; 
			rect.left += 2;
		}
		else
		{
		    // Bit is off
			pDC->SetTextColor( ::GetSysColor(COLOR_BTNSHADOW) );
			DrawBitMap( pDC, &abmpButton[nAssociatedBmp + BIT_OFF], rect.left, rect.top, 0, 0 );
		}
    }

	rect.left++;

	if( fDrawOne )
	{
        nBkModeOld = pDC->SetBkMode( TRANSPARENT );
	}

	if( m_pVarChoicesDlg->IsBitOn( nRow, nColumn )
	||  m_pVarChoicesDlg->IsRowDisabled( nRow ) )
	{
		pFontOld = pDC->SelectObject( m_pVarChoicesDlg->m_pFontBold );
	}
	else
	{
		pFontOld = pDC->SelectObject( m_pVarChoicesDlg->m_pFont );
	}

	switch( nRowType )
	{
		case IMA_ROWTYPE:
			IMA_DrawButtonText( pDC, &rect, nRow, nColumn );
			break;

		case DM_ROWTYPE:
			DM_DrawButtonText( pDC, &rect, nRow, nColumn );
			break;

		default:
			ASSERT( 0 );
	}

	pDC->SelectObject( pFontOld );

    if( fDrawOne )
    {
        pDC->SetBkMode( nBkModeOld );
    }
} 


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::DrawRowOfButtons

void CVarChoicesFlagsBtn::DrawRowOfButtons( CDC* pDC, short nRow )
{
	CDC cdcMem;
	CBitmap bmpMem;
	CBitmap* pBitmapOld;
	CFont* pFontOld;
	int nBkModeOld;
	CRect rect;

	GetClientRect( &rect );
	int nRowWidth = rect.Width();

	ASSERT( m_pVarChoicesDlg != NULL );

	if( cdcMem.CreateCompatibleDC( pDC ) == FALSE
	||  bmpMem.CreateCompatibleBitmap( pDC, nRowWidth, sg_nBtnHeight ) == FALSE )
	{
		return;
	}

    pBitmapOld = cdcMem.SelectObject( &bmpMem );
	pFontOld = cdcMem.SelectObject( m_pVarChoicesDlg->m_pFont );
    nBkModeOld = cdcMem.SetBkMode( TRANSPARENT );

    rect.left   = 0;
    rect.top    = 0;
    rect.right  = nRowWidth;
    rect.bottom = sg_nBtnHeight; 

	cdcMem.FillSolidRect( &rect, ::GetSysColor(COLOR_BTNFACE) );

    short nNbrColumns = m_pVarChoicesDlg->GetNbrColumns( nRow );

	for( short nColumn = 0 ;  nColumn < nNbrColumns ;  nColumn++ )
    {
        DrawOneButton( &cdcMem, nRow, nColumn, FALSE );
    }

    rect.top = sg_nBtnHeight * nRow;
    rect.bottom = rect.top + sg_nBtnHeight; 
    pDC->BitBlt( 0, rect.top, nRowWidth, rect.bottom,
				 &cdcMem, 0, 0, SRCCOPY );

    cdcMem.SelectObject( pBitmapOld );
    cdcMem.SelectObject( pFontOld );
    cdcMem.SetBkMode( nBkModeOld );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::DrawAllButtons

void CVarChoicesFlagsBtn::DrawAllButtons( CDC* pDC )
{
    for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
    {
        DrawRowOfButtons( pDC, nRow );
    }
}


BEGIN_MESSAGE_MAP(CVarChoicesFlagsBtn, CButton)
	//{{AFX_MSG_MAP(CVarChoicesFlagsBtn)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
	ON_WM_ERASEBKGND()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn message handlers

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnLButtonDown

void CVarChoicesFlagsBtn::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );
	ASSERT( m_pVarChoicesDlg->m_pVarChoices != NULL );

	short nRow = m_pVarChoicesDlg->FindRow( point.y );

	if( nRow != -1 )
	{
		short nColumn = m_pVarChoicesDlg->FindColumn( nRow, point.x );

		if( nColumn != -1 )
		{
			// First set capture
			m_pVarChoicesDlg->CaptureMouse( this );

			// Select this button
			if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
			{
				// CTRL key is down
				sg_nFirstSelectedBtnRow = nRow;
				sg_nFirstSelectedBtnColumn = nColumn;

				// Set sg_nSetBitSelectState
				if( m_pVarChoicesDlg->IsBtnSelected( nRow, nColumn ) )
				{
					sg_nSetBitSelectState = FALSE;
				}
				else
				{
					sg_nSetBitSelectState = TRUE;
				}

				// Unselect all "row" buttons
				for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
				{
					m_pVarChoicesDlg->m_pVarChoices->m_bSelectedRowBtns[i] = 0;
				}

				// Toggle the state of this button
				m_pVarChoicesDlg->m_pVarChoices->m_dwSelectedFlagBtns[nRow] ^= (1 << nColumn);
				CDC* pDC = GetDC();
				if( pDC )
				{
					DrawOneButton( pDC, nRow, nColumn, TRUE );
					ReleaseDC( pDC );
				}

				// Redraw "row" buttons
				m_pVarChoicesDlg->m_btnRows.InvalidateRect( NULL, FALSE );
				m_pVarChoicesDlg->m_btnRows.UpdateWindow();
			}
			else if( GetAsyncKeyState(VK_SHIFT) & 0x8000 )
			{
				int i;
				int j;

				// SHIFT key is down
				if( sg_nFirstSelectedBtnRow == -1
				||  sg_nFirstSelectedBtnColumn == -1 )
				{
					sg_nFirstSelectedBtnRow = nRow;
					sg_nFirstSelectedBtnColumn = nColumn;
				}

				// Unselect all buttons
				for( i = 0 ;  i < NBR_VARIATIONS ;  i++ )
				{
					m_pVarChoicesDlg->m_pVarChoices->m_bSelectedRowBtns[i] = 0;
					m_pVarChoicesDlg->m_pVarChoices->m_dwSelectedFlagBtns[i] = 0x0000000;
				}

				int nFirstRow;
				int nFirstRowColumn;
				int nFirstXPos;
				int nLastRow;
				int nLastRowColumn;
				int nLastXPos;

				// Determine first/last fields
				if( nRow <= sg_nFirstSelectedBtnRow )
				{
					nFirstRow = nRow; 
					nFirstRowColumn = nColumn;
					nLastRow = sg_nFirstSelectedBtnRow;
					nLastRowColumn = sg_nFirstSelectedBtnColumn;
				}
				else
				{
					nFirstRow = sg_nFirstSelectedBtnRow;
					nFirstRowColumn = sg_nFirstSelectedBtnColumn;
					nLastRow = nRow; 
					nLastRowColumn = nColumn;
				}

				short nFirstRowType = m_pVarChoicesDlg->GetRowType( nFirstRow );
				short nLastRowType = m_pVarChoicesDlg->GetRowType( nLastRow );

				int nFirstRowXPos = sga_nBtnXPos[nFirstRowType][nFirstRowColumn];
				int nLastRowXPos = sga_nBtnXPos[nLastRowType][nLastRowColumn];
			
				if( nFirstRowXPos <= nLastRowXPos )
				{
					nFirstXPos = nFirstRowXPos;
					nLastXPos = nLastRowXPos;
					nLastXPos += m_pVarChoicesDlg->GetBtnWidth( nLastRow, nLastRowColumn );
				}
				else
				{
					nFirstXPos = nLastRowXPos;
					nLastXPos = nFirstRowXPos;
					nLastXPos += m_pVarChoicesDlg->GetBtnWidth( nFirstRow, nFirstRowColumn );
				}

				int nXPos;
				int nNbrColumns;
				int nRowType;

				// Select buttons inside the range
				for( i = 0 ;  i < NBR_VARIATIONS ;  i++ )
				{
					if( i >= nFirstRow
					&&  i <= nLastRow )
					{
						nRowType = m_pVarChoicesDlg->GetRowType( i );
						nNbrColumns = m_pVarChoicesDlg->GetNbrColumns( i );
		
						for( j = 0 ;  j < nNbrColumns ;  j++ )
						{
							nXPos = sga_nBtnXPos[nRowType][j];

							if( nXPos >= nFirstXPos 
							&&  nXPos < nLastXPos )
							{
								m_pVarChoicesDlg->m_pVarChoices->m_dwSelectedFlagBtns[i] |= (1 << j);
							}
						}
					}
				}

				// Redraw buttons
				m_pVarChoicesDlg->m_btnRows.InvalidateRect( NULL, FALSE );
				m_pVarChoicesDlg->m_btnRows.UpdateWindow();

				InvalidateRect( NULL, FALSE );
				UpdateWindow();
			}
			else
			{
				// Unselect all buttons
				m_pVarChoicesDlg->UnselectAllButtons( TRUE );

				// Set sg_nSetBitFlagState
				if( m_pVarChoicesDlg->IsBitOn( nRow, nColumn ) )
				{
					sg_nSetBitFlagState = FALSE;
				}
				else
				{
					sg_nSetBitFlagState = TRUE;
				}

				// Set the bit
				m_pVarChoicesDlg->SetBit( nRow, nColumn );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnLButtonDblClk

void CVarChoicesFlagsBtn::OnLButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnLButtonUp

void CVarChoicesFlagsBtn::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );

	if( CWnd::GetCapture() == this )
	{
		m_pVarChoicesDlg->ReleaseMouse( this );
	}

	sg_nSetBitFlagState = -1;
	sg_nSetBitSelectState = -1;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnRButtonDown

void CVarChoicesFlagsBtn::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	CButton::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnRButtonDblClk

void CVarChoicesFlagsBtn::OnRButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnMouseMove

void CVarChoicesFlagsBtn::OnMouseMove( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );

	if( CWnd::GetCapture() == this )
	{
		short nRow = m_pVarChoicesDlg->FindRow( point.y );

		if( nRow != -1 )
		{
			short nColumn = m_pVarChoicesDlg->FindColumn( nRow, point.x );

			if( nColumn != -1 )
			{
				if( sg_nSetBitFlagState == -1 )
				{
					// CTRL/SHIFT key down in WM_LBUTTONDOWN
					if( sg_nSetBitSelectState )
					{
						m_pVarChoicesDlg->m_pVarChoices->m_dwSelectedFlagBtns[nRow] |= (1 << nColumn);
					}
					else
					{
						m_pVarChoicesDlg->m_pVarChoices->m_dwSelectedFlagBtns[nRow] &= ~(1 << nColumn);
					}
					CDC* pDC = GetDC();
					if( pDC )
					{
						DrawOneButton( pDC, nRow, nColumn, TRUE );
						ReleaseDC( pDC );
					}
				}
				else
				{
					// Set the bit
					m_pVarChoicesDlg->SetBit( nRow, nColumn );
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::OnEraseBkgnd

BOOL CVarChoicesFlagsBtn::OnEraseBkgnd( CDC* pDC ) 
{
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn::DrawItem

void CVarChoicesFlagsBtn::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC )
	{
	    DrawAllButtons( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn

CVarChoicesRowsBtn::CVarChoicesRowsBtn()
{
}

CVarChoicesRowsBtn::~CVarChoicesRowsBtn()
{
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::DrawOneButton

void CVarChoicesRowsBtn::DrawOneButton( CDC* pDC, short nRow )
{
	int nDestY;

	ASSERT( m_pVarChoicesDlg != NULL );
	ASSERT( m_pVarChoicesDlg->m_pVarChoices != NULL );

    // Determine rectangle of button
    nDestY = sg_nBtnHeight * nRow;

	if( m_pVarChoicesDlg->IsRowSelected( nRow ) )
    {
		// Button is selected - draw down state
		DrawBitMap( pDC, &sg_bmpRowOnDown, 0, nDestY, 0, 0 );
    }
	else
	{
		// Button is not selected - draw up state
		DrawBitMap( pDC, &sg_bmpRowOnUp, 0, nDestY, 0, 0 );
    }
} 


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::DrawAllButtons

void CVarChoicesRowsBtn::DrawAllButtons( CDC* pDC )
{
	CDC cdcMem;
	CBitmap bmpMem;
	CBitmap* pBitmapOld;
	CRect rect;

	GetClientRect( &rect );

	if( cdcMem.CreateCompatibleDC( pDC ) == FALSE
	||  bmpMem.CreateCompatibleBitmap( pDC, rect.Width(), rect.Height() ) == FALSE )
	{
		return;
	}

    pBitmapOld = cdcMem.SelectObject( &bmpMem );
	cdcMem.FillSolidRect( &rect, ::GetSysColor(COLOR_BTNFACE) );

    for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
    {
        DrawOneButton( &cdcMem, nRow );
    }

    pDC->BitBlt( 0, 0, rect.Width(), rect.Height(),
				 &cdcMem, 0, 0, SRCCOPY );

    cdcMem.SelectObject( pBitmapOld );
}


BEGIN_MESSAGE_MAP(CVarChoicesRowsBtn, CButton)
	//{{AFX_MSG_MAP(CVarChoicesRowsBtn)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_ERASEBKGND()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn message handlers

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnLButtonDown

void CVarChoicesRowsBtn::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );
	ASSERT( m_pVarChoicesDlg->m_pVarChoices != NULL );

	short nRow = m_pVarChoicesDlg->FindRow( point.y );

	if( nRow != -1 )
	{
		// First set capture
		m_pVarChoicesDlg->CaptureMouse( this );

		// Select this row
		if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
		{
			// CTRL key is down - toggle select state of this row
			// See how many rows are selected
			short nNbrSelectedRows = 0;

			for( short nTheRow = 0 ;  nTheRow < NBR_VARIATIONS ;  nTheRow++ )
			{
				if( m_pVarChoicesDlg->IsRowSelected( nTheRow ) )
				{
					nNbrSelectedRows++;
				}
			}

			// If we are selecting the first row unselect all other buttons
			if( nNbrSelectedRows == 0 )
			{
				m_pVarChoicesDlg->UnselectAllButtons( TRUE );
			}

			if( m_pVarChoicesDlg->IsRowSelected( nRow ) )
			{
				m_pVarChoicesDlg->SelectRow( nRow, FALSE );
			}
			else
			{
				m_pVarChoicesDlg->SelectRow( nRow, TRUE );
			}
		}
		else if( GetAsyncKeyState(VK_SHIFT) & 0x8000 )
		{
			// SHIFT key is down
			if( sg_nFirstSelectedRow == -1 )
			{
				sg_nFirstSelectedRow = nRow;
			}

			int nFirstRow = min( sg_nFirstSelectedRow, nRow ); 
			int nLastRow = max( sg_nFirstSelectedRow, nRow ); 

			for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
			{
				if( i >= nFirstRow
				&&  i <= nLastRow )
				{
					// Select rows inside the range
					m_pVarChoicesDlg->SelectRow( i, TRUE );
				}
				else
				{
					// Unselect rows outside of range
					m_pVarChoicesDlg->SelectRow( i, FALSE );
				}
			}
		}
		else
		{
			short nNbrSelectedRows = 0;

			if( m_pVarChoicesDlg->IsRowSelected( nRow ) )
			{
				for( short nTheRow = 0 ;  nTheRow < NBR_VARIATIONS ;  nTheRow++ )
				{
					if( m_pVarChoicesDlg->IsRowSelected( nTheRow ) )
					{
						nNbrSelectedRows++;
					}
				}
			}

			// Unselect all buttons
			m_pVarChoicesDlg->UnselectAllButtons( TRUE );

			if( nNbrSelectedRows != 1 )
			{
				sg_nFirstSelectedRow = nRow;
				m_pVarChoicesDlg->SelectRow( sg_nFirstSelectedRow, TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnLButtonDblClk

void CVarChoicesRowsBtn::OnLButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnLButtonUp

void CVarChoicesRowsBtn::OnLButtonUp( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );

	if( CWnd::GetCapture() == this )
	{
		m_pVarChoicesDlg->ReleaseMouse( this );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnRButtonDown

void CVarChoicesRowsBtn::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );
	ASSERT( m_pVarChoicesDlg->m_pVarChoices != NULL );

	short nRow = m_pVarChoicesDlg->FindRow( point.y );

	if( nRow != -1 )
	{
		// Select this row
		if( !(GetAsyncKeyState(VK_CONTROL) & 0x8000)
		&&  !(GetAsyncKeyState(VK_SHIFT) & 0x8000) )
		{
			// If this row is selected don't do anything
			if( m_pVarChoicesDlg->IsRowSelected( nRow ) == FALSE )
			{
				// Unselect all buttons
				m_pVarChoicesDlg->UnselectAllButtons( TRUE );

				sg_nFirstSelectedRow = nRow;
				m_pVarChoicesDlg->SelectRow( sg_nFirstSelectedRow, TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnRButtonDblClk

void CVarChoicesRowsBtn::OnRButtonDblClk( UINT nFlags, CPoint point ) 
{
	OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnMouseMove

void CVarChoicesRowsBtn::OnMouseMove( UINT nFlags, CPoint point ) 
{
	ASSERT( m_pVarChoicesDlg != NULL );

	if( CWnd::GetCapture() == this )
	{
		short nRow = m_pVarChoicesDlg->FindRow( point.y );

		if( nRow != -1 )
		{
			// Select this row
			m_pVarChoicesDlg->SelectRow( nRow, TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::OnEraseBkgnd

BOOL CVarChoicesRowsBtn::OnEraseBkgnd( CDC* pDC ) 
{
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn::DrawItem

void CVarChoicesRowsBtn::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC )
	{
	    DrawAllButtons( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg

IMPLEMENT_DYNCREATE(CVarChoicesDlg, CFormView)

CVarChoicesDlg::CVarChoicesDlg()
	: CFormView(CVarChoicesDlg::IDD)
{
	//{{AFX_DATA_INIT(CVarChoicesDlg)
	//}}AFX_DATA_INIT

	m_pVarChoicesCtrl = NULL;
	m_pVarChoices = NULL;

	m_fRowRightMenu = FALSE;
	m_pFont = NULL;
	m_pFontBold = NULL;
	m_pFontItalics = NULL;
	m_pFontItalicsBold = NULL;
	m_fDirty = false;
}

CVarChoicesDlg::~CVarChoicesDlg()
{
}

void CVarChoicesDlg::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVarChoicesDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVarChoicesDlg, CFormView)
	//{{AFX_MSG_MAP(CVarChoicesDlg)
	ON_WM_DESTROY()
	ON_WM_CONTEXTMENU()
	ON_WM_DRAWITEM()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg diagnostics

#ifdef _DEBUG
void CVarChoicesDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CVarChoicesDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::Create

BOOL CVarChoicesDlg::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext ) 
{
	// Create normal Font
	m_pFont = new CFont;
	if( m_pFont == NULL )
	{
		return FALSE;
	}
	if( m_pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 							   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) == FALSE )
	{
		return FALSE;
	}

	// Create bold Font
	m_pFontBold = new CFont;
	if( m_pFontBold == NULL )
	{
		return FALSE;
	}
	if( m_pFontBold->CreateFont( 10, 0, 0, 0, FW_SEMIBOLD, 0, 0, 0,
 							   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) == FALSE )
	{
		return FALSE;
	}

	// Create italics Font
	m_pFontItalics = new CFont;
	if( m_pFontItalics == NULL )
	{
		return FALSE;
	}
	if( m_pFontItalics->CreateFont( 10, 0, 0, 0, FW_NORMAL, TRUE, 0, 0,
 							   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) == FALSE )
	{
		return FALSE;
	}

	// Create italics bold Font
	m_pFontItalicsBold = new CFont;
	if( m_pFontItalicsBold == NULL )
	{
		return FALSE;
	}
	if( m_pFontItalicsBold->CreateFont( 10, 0, 0, 0, FW_SEMIBOLD, TRUE, 0, 0,
 							   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
							   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) == FALSE )
	{
		return FALSE;
	}

	if( !CFormView::Create( lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext ) )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnInitialUpdate

void CVarChoicesDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pVarChoices != NULL );
	ASSERT( m_pFont != NULL );

	CFormView::OnInitialUpdate();

	// Subclass controls
	m_btnRows.SubclassDlgItem( IDC_SELECT_ROWS, this );
	m_btnRows.m_pVarChoicesDlg = this;

	m_btnFlags.SubclassDlgItem( IDC_FLAGS, this );
	m_btnFlags.m_pVarChoicesDlg = this;

	// Resize controls
	CWnd* pWnd = GetDlgItem( IDC_ROW_HEADINGS );
	if( pWnd )
	{
	    pWnd->MoveWindow( 6, 16, 22, 576, FALSE );
	}
	m_btnRows.MoveWindow( 30, 16, 12, 576, FALSE );
	m_btnFlags.MoveWindow( 42, 16, 760, 576, FALSE );

	// Set static variables
	if( sg_nSmallBtnWidth == 0 )
	{
		CRect rect;

		sg_nSmallBtnWidth = 20;
		sg_nMediumBtnWidth = sg_nSmallBtnWidth * 2;
		sg_nLargeBtnWidth = sg_nSmallBtnWidth * 3;

		m_btnFlags.GetClientRect( &rect );
		sg_nBtnHeight = rect.Height() / NBR_VARIATIONS;

		// Create button bitmaps
		CreateBtnBitmaps();

		// Prepare the arrays used to manage the buttons
		PrepareXPosArray();
		PrepareTextArrays();
	}

	// Size column headings
	PrepareColumnHeadings();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnDestroy

void CVarChoicesDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Set m_hWndEditor to NULL to avoid recirsive call to OnDestroy()
	ASSERT( m_pVarChoices != NULL );
	if( m_pVarChoices )
	{
		m_pVarChoices->SetEditorWindow( NULL );
	}

	// Delete normal font
	if( m_pFont )
	{
		m_pFont->DeleteObject();
		delete m_pFont;
		m_pFont = NULL;
	}

	// Delete bold font
	if( m_pFontBold )
	{
		m_pFontBold->DeleteObject();
		delete m_pFontBold;
		m_pFontBold = NULL;
	}

	// Delete italics font
	if( m_pFontItalics )
	{
		m_pFontItalics->DeleteObject();
		delete m_pFontItalics;
		m_pFontItalics = NULL;
	}

	// Delete italics bold font
	if( m_pFontItalicsBold )
	{
		m_pFontItalicsBold->DeleteObject();
		delete m_pFontItalicsBold;
		m_pFontItalicsBold = NULL;
	}

	CFormView::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::CreateBtnBitmaps

BOOL CVarChoicesDlg::CreateBtnBitmaps() 
{
	CDC* pDC;
	CDC cdcMem;
	CBitmap* pBitmapOld;
	CRect rect;
	BOOL fResult = FALSE;

	int nBtnWidth;
	int nOffset;

	pDC = GetDC();
	if( pDC )
	{
		if( cdcMem.CreateCompatibleDC( pDC ) )
		{
			CDC cdcMono;
			CDC cdcBackground;
			CBitmap bmpDisabledMono;
			CBitmap bmpDisabled;
			CBitmap bmpSelectedMono;
			CBitmap bmpSelected;
			BOOL fBackgroundBmp = FALSE;

			// Prepare background bitmaps
			if( bmpDisabled.LoadBitmap( IDB_DISABLED )
			&&  bmpSelected.LoadBitmap( IDB_SELECTED ) )
			{
				BITMAP bmDisabled;
				BITMAP bmSelected;

				bmpDisabled.GetBitmap( &bmDisabled );
				bmpSelected.GetBitmap( &bmSelected );

				if( cdcBackground.CreateCompatibleDC( pDC )
				&&  cdcMono.CreateCompatibleDC( pDC )
				&&  bmpDisabledMono.CreateBitmap( bmDisabled.bmWidth, bmDisabled.bmHeight, 1, 1, NULL )
				&&  bmpSelectedMono.CreateBitmap( bmSelected.bmWidth, bmSelected.bmHeight, 1, 1, NULL ) )
				{
					fBackgroundBmp = TRUE;
				}
			}

			// Create flag buttons
			for( int i = 0 ;  i < NBR_BTN_BITMAPS ;  i++ )
			{	
				// Determine button width
				if( i >= BTN_LG_BIT_ON )
				{
					nBtnWidth = sg_nLargeBtnWidth + 1;
				}
				else if( i >= BTN_MD_BIT_ON )
				{
					nBtnWidth = sg_nMediumBtnWidth + 1;
				}
				else
				{
					nBtnWidth = sg_nSmallBtnWidth + 1;
				}

				if( abmpButton[i].CreateCompatibleBitmap( pDC, nBtnWidth, sg_nBtnHeight ) )
				{
					abmpButton[i].SetBitmapDimension( nBtnWidth, sg_nBtnHeight );
					pBitmapOld = cdcMem.SelectObject( &abmpButton[i] );

					rect.left = 0;
					rect.top = 0;
					rect.right = nBtnWidth;
					rect.bottom = sg_nBtnHeight;

					// Draw black frame
					cdcMem.FrameRect( &rect, CBrush::FromHandle((HBRUSH)::GetStockObject(BLACK_BRUSH)) );
					rect.InflateRect( -1, -1 );

					int nMod = i % 6;	// Six different button states

					if( nMod == BIT_ON_SEL
					||  nMod == BIT_OFF_SEL )
					{
						// Selected
						cdcMem.FillSolidRect( &rect, RGB(255,0,0) );
					}
					else
					{
						// Not selected
						cdcMem.FillSolidRect( &rect, ::GetSysColor(COLOR_BTNFACE) );
					}

					if( nMod == BIT_ON
					||  nMod == BIT_ON_SEL
					||  nMod == BIT_ON_DIS )
					{
						// Sunken
						cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHIGHLIGHT) );
						rect.InflateRect( -1, -1 );
						cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHIGHLIGHT) );
						rect.InflateRect( -1, -1 );
					}
					else
					{
						// Raised
						cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNHIGHLIGHT), ::GetSysColor(COLOR_BTNSHADOW) );
						rect.InflateRect( -1, -1 );
						cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNHIGHLIGHT), ::GetSysColor(COLOR_BTNSHADOW) );
						rect.InflateRect( -1, -1 );
					}

					if( nMod == BIT_ON_DIS
					||  nMod == BIT_OFF_DIS )
					{
						if( fBackgroundBmp )
						{

							CBitmap* pbmpOld = cdcBackground.SelectObject( &bmpDisabled );
							CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpDisabledMono );
							
							cdcBackground.SetBkColor( RGB(255,0,255) );
							cdcMem.SetBkColor( RGB(255,255,255) );
							rect.right--;
							rect.bottom--;

							if( nMod == BIT_ON_DIS )
							{
								// Raised
								nOffset = 4;
							}
							else
							{
								// Raised
								nOffset = 3;
							}

							cdcMono.BitBlt( 0, 0, rect.Width(), rect.Height(),
											&cdcBackground, 0, 0, SRCCOPY);
							cdcMem.BitBlt( nOffset, nOffset, rect.Width(), rect.Height(),
											&cdcBackground, 0, 0, SRCINVERT ) ;
							cdcMem.BitBlt( nOffset, nOffset, rect.Width(), rect.Height(),
											&cdcMono, 0, 0, SRCAND ) ;
							cdcMem.BitBlt( nOffset, nOffset, rect.Width(), rect.Height(),
											&cdcBackground, 0, 0, SRCINVERT ) ;

							cdcMono.SelectObject( pbmpOldMono ) ;
							cdcBackground.SelectObject( pbmpOld );
						}
						else
						{
							cdcMem.FillRect( &rect, CBrush::FromHandle((HBRUSH)::GetStockObject(DKGRAY_BRUSH)) );
						}
					}

					if( nMod == BIT_ON )
					{
						if( fBackgroundBmp )
						{

							CBitmap* pbmpOld = cdcBackground.SelectObject( &bmpSelected );
							CBitmap* pbmpOldMono = cdcMono.SelectObject( &bmpSelectedMono );
							
							cdcBackground.SetBkColor( RGB(255,0,255) );
							cdcMem.SetBkColor( RGB(255,255,255) );
							rect.right--;
							rect.bottom--;

							// Sunken
							nOffset = 4;

							cdcMono.BitBlt( 0, 0, rect.Width(), rect.Height(),
											&cdcBackground, 0, 0, SRCCOPY);
							cdcMem.BitBlt( nOffset, nOffset, rect.Width(), rect.Height(),
											&cdcBackground, 0, 0, SRCINVERT ) ;
							cdcMem.BitBlt( nOffset, nOffset, rect.Width(), rect.Height(),
											&cdcMono, 0, 0, SRCAND ) ;
							cdcMem.BitBlt( nOffset, nOffset, rect.Width(), rect.Height(),
											&cdcBackground, 0, 0, SRCINVERT ) ;

							cdcMono.SelectObject( pbmpOldMono ) ;
							cdcBackground.SelectObject( pbmpOld );
						}
						else
						{
							cdcMem.FillRect( &rect, CBrush::FromHandle((HBRUSH)::GetStockObject(WHITE_BRUSH)) );
						}
					}

					cdcMem.SelectObject( pBitmapOld );
				}
			}

			m_btnRows.GetClientRect( &rect );
			int nSelWidth = rect.Width() - 1;
			
			if( sg_bmpRowOnUp.CreateCompatibleBitmap( pDC, nSelWidth, sg_nBtnHeight )
			&&  sg_bmpRowOnDown.CreateCompatibleBitmap( pDC, nSelWidth, sg_nBtnHeight ) )
			{

				// Create enabled "up" row selector
				cdcMem.SelectObject( &sg_bmpRowOnUp );
				rect.left = 0;
				rect.top = 0;
				rect.right = nSelWidth;
				rect.bottom = sg_nBtnHeight;
				cdcMem.FrameRect( &rect, CBrush::FromHandle((HBRUSH)::GetStockObject(BLACK_BRUSH)) );
				rect.InflateRect( -1, -1 );
				cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNHIGHLIGHT), ::GetSysColor(COLOR_BTNSHADOW) );
				rect.InflateRect( -1, -1 );
				cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNHIGHLIGHT), ::GetSysColor(COLOR_BTNSHADOW) );
				rect.InflateRect( -1, -1 );
				cdcMem.FillSolidRect( &rect, ::GetSysColor(COLOR_BTNFACE) );

				// Create enabled "down" row selector
				cdcMem.SelectObject( &sg_bmpRowOnDown );
				rect.left = 0;
				rect.top = 0;
				rect.right = nSelWidth;
				rect.bottom = sg_nBtnHeight;
				cdcMem.FrameRect( &rect, CBrush::FromHandle((HBRUSH)::GetStockObject(BLACK_BRUSH)) );
				rect.InflateRect( -1, -1 );
				cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHIGHLIGHT) );
				rect.InflateRect( -1, -1 );
				cdcMem.Draw3dRect( &rect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHIGHLIGHT) );
				rect.InflateRect( -1, -1 );
				cdcMem.FillSolidRect( &rect, RGB(255,0,0) );
			}
		}
		
		ReleaseDC( pDC );
	}

	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::PrepareXPosArray

void CVarChoicesDlg::PrepareXPosArray( void )
{
	int i, j;

	// Initialized already to these values
	//sga_nBtnXPos[IMA_ROWTYPE] = &sga_IMA_XPos[0];
	//sga_nBtnXPos[DM_ROWTYPE] = &sga_DM_XPos[0];

	// Set X positions for IMA row of buttons
	sga_IMA_XPos[0] = 0;

	for( i = 0, j = 1 ;  j < IMA_NBR_COLUMNS ;  i++, j++ )
	{
		switch( sga_IMA_AssociatedBmp[i] )
		{
			case SMALL_BTN:
				sga_IMA_XPos[j] = sga_IMA_XPos[i] + sg_nSmallBtnWidth;
				break;

			case MEDIUM_BTN:
				sga_IMA_XPos[j] = sga_IMA_XPos[i] + sg_nMediumBtnWidth;
				break;

			case LARGE_BTN:
				sga_IMA_XPos[j] = sga_IMA_XPos[i] + sg_nLargeBtnWidth;
				break;
		}

		// Add extra pixel to separate groups (i.e. function, root, type, dest)
		if( i == 6		// Last "function" button
		||  i == 10		// Last "root" button
		||  i == 12 )	// Last "type" button
		{
			sga_IMA_XPos[j] += 2;
		}
	}

	// Set X positions for DirectMusic row of buttons
	sga_DM_XPos[0] = 0;

	for( i = 0, j = 1 ;  j < DM_NBR_COLUMNS ;  i++, j++ )
	{
		switch( sga_DM_AssociatedBmp[i] )
		{
			case SMALL_BTN:
				sga_DM_XPos[j] = sga_DM_XPos[i] + sg_nSmallBtnWidth;
				break;

			case MEDIUM_BTN:
				sga_DM_XPos[j] = sga_DM_XPos[i] + sg_nMediumBtnWidth;
				break;

			case LARGE_BTN:
				sga_DM_XPos[j] = sga_DM_XPos[i] + sg_nLargeBtnWidth;
				break;
		}

		// Add extra pixel to separate groups (i.e. function, root, type, dest)
		if( i == 20		// Last "function" button
		||  i == 23		// Last "root" button
		||  i == 26 )	// Last "type" button
		{
			sga_DM_XPos[j] += 2;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::PrepareTextArrays

void CVarChoicesDlg::PrepareTextArrays( void )
{
	int i;

	// Fill "IMA" text array
	for( i = 0 ;  i < IMA_NBR_COLUMNS ;  i++ )
	{
		::LoadString( theApp.m_hInstance, i + IDS_IMA_FLAGS_TEXT_1, &sga_IMA_Text[i][0], SMALL_BUFFER );
	}

	// Fill "DM" text array
	for( i = 0 ;  i < DM_NBR_COLUMNS ;  i++ )
	{
		::LoadString( theApp.m_hInstance, i + IDS_DM_FLAGS_TEXT_1, &sga_DM_Text[i][0], SMALL_BUFFER );
	}
}



/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::PrepareColumnHeadings

void CVarChoicesDlg::PrepareColumnHeadings( void )
{
	CWnd* pWnd;
	CRect rect;
	int nX;
	int nCX;
	int nXOffset;

	m_btnFlags.GetClientRect( &rect );
	m_btnFlags.ClientToScreen( &rect );
	ScreenToClient( &rect );
	nXOffset = rect.left;

	pWnd = GetDlgItem( IDC_HEADING_1 );
	if( pWnd )
	{
		nX = nXOffset + sga_DM_XPos[0];
		nCX = sga_DM_XPos[21] - sga_DM_XPos[0];

		pWnd->GetClientRect( &rect );
	    pWnd->MoveWindow( nX, rect.top, nCX, rect.Height(), FALSE );
	}

	pWnd = GetDlgItem( IDC_HEADING_2 );
	if( pWnd )
	{
		nX = nXOffset + sga_DM_XPos[21];
		nCX = sga_DM_XPos[24] - sga_DM_XPos[21];

		pWnd->GetClientRect( &rect );
	    pWnd->MoveWindow( nX, rect.top, nCX, rect.Height(), FALSE );
	}

	pWnd = GetDlgItem( IDC_HEADING_3 );
	if( pWnd )
	{
		nX = nXOffset + sga_DM_XPos[24];
		nCX = sga_DM_XPos[27] - sga_DM_XPos[24];

		pWnd->GetClientRect( &rect );
	    pWnd->MoveWindow( nX, rect.top, nCX, rect.Height(), FALSE );
	}

	pWnd = GetDlgItem( IDC_HEADING_4 );
	if( pWnd )
	{
		nX = nXOffset + sga_DM_XPos[27];
		nCX = sga_DM_XPos[DM_NBR_COLUMNS - 1] - sga_DM_XPos[27] + 2;

		switch( sga_DM_AssociatedBmp[DM_NBR_COLUMNS - 1] )
		{
			case SMALL_BTN:
				nCX += sg_nSmallBtnWidth;
				break;

			case MEDIUM_BTN:
				nCX += sg_nMediumBtnWidth;
				break;

			case LARGE_BTN:
				nCX += sg_nLargeBtnWidth;
				break;
		}

		pWnd->GetClientRect( &rect );
	    pWnd->MoveWindow( nX, rect.top, nCX, rect.Height(), FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::SyncPattern

void CVarChoicesDlg::SyncPattern()
{
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices->m_pCallback )
	{
		m_pVarChoices->m_pCallback->OnDataChanged( (IPersistStream *)m_pVarChoices );
	}

	m_fDirty = false;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::RefreshRowOfButtons

void CVarChoicesDlg::RefreshRowOfButtons( short nRow )
{
	CDC* pDC = m_btnRows.GetDC();
	if( pDC )
	{
		m_btnRows.DrawOneButton( pDC, nRow );
		m_btnRows.ReleaseDC( pDC );
	}

	pDC = m_btnFlags.GetDC();
	if( pDC )
	{
		m_btnFlags.DrawRowOfButtons( pDC, nRow );
		m_btnFlags.ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::GetRowType

short CVarChoicesDlg::GetRowType( short nRow )
{
	ASSERT( m_pVarChoices != NULL );

	return (short)((m_pVarChoices->m_dwVariationChoices[nRow] & DM_VF_MODE_BITS) >> 29);
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::GetNbrColumns

short CVarChoicesDlg::GetNbrColumns( short nRow )
{
	short nNbrColumns = 0;
	
	switch( GetRowType(nRow) )
	{
		case IMA_ROWTYPE:
			nNbrColumns = IMA_NBR_COLUMNS;
			break;

		case DM_ROWTYPE:
			nNbrColumns = DM_NBR_COLUMNS;
			break;
	}

	ASSERT( nNbrColumns != 0 );
	return nNbrColumns;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::GetBtnWidth

short CVarChoicesDlg::GetBtnWidth( short nRow, short nColumn )
{
	short nBtnWidth = 0;
	
	switch( GetRowType(nRow) )
	{
		case IMA_ROWTYPE:
			switch( sga_IMA_AssociatedBmp[nColumn] )
			{
				case SMALL_BTN:
					nBtnWidth = sg_nSmallBtnWidth;
					break;

				case MEDIUM_BTN:
					nBtnWidth = sg_nMediumBtnWidth;
					break;

				case LARGE_BTN:
					nBtnWidth = sg_nLargeBtnWidth;
					break;
			}
			break;

		case DM_ROWTYPE:
			switch( sga_DM_AssociatedBmp[nColumn] )
			{
				case SMALL_BTN:
					nBtnWidth = sg_nSmallBtnWidth;
					break;

				case MEDIUM_BTN:
					nBtnWidth = sg_nMediumBtnWidth;
					break;

				case LARGE_BTN:
					nBtnWidth = sg_nLargeBtnWidth;
					break;
			}
			break;
	}

	ASSERT( nBtnWidth != 0 );
	return nBtnWidth;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::FindRow

short CVarChoicesDlg::FindRow( int nYPos )
{
	short nRow;

	if( nYPos < 0 )
	{
		return -1;
	}

	nRow = nYPos / sg_nBtnHeight;

	if( nRow >= NBR_VARIATIONS )
	{
		return -1;
	}

	return nRow;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::FindColumn

short CVarChoicesDlg::FindColumn( short nRow, int nXPos )
{
	if( nXPos < 0 )
	{
		return -1;
	}
   
	short nRowType = GetRowType( nRow );
	short nNbrColumns = GetNbrColumns( nRow );

	CRect rectBtn;

	for( int i = 0 ;  i < nNbrColumns ;  i++ )
	{
	    rectBtn.left = sga_nBtnXPos[nRowType][i];
		rectBtn.right = rectBtn.left + GetBtnWidth( nRow, i );

		if( nXPos <= rectBtn.right )
		{
			return i;
		}
	}

	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::SetBit

void CVarChoicesDlg::SetBit( short nRow, short nColumn )
{
	ASSERT( sg_nSetBitFlagState != -1 );
	ASSERT( m_pVarChoices != NULL );

	// Determine bit offset
	short nRowType = GetRowType( nRow );
	DWORD dwOffset = sga_nBtnBit[nRowType][nColumn];

	BOOL fUpdated = FALSE;

	// Set the bit
	if( IsBitOn( nRow, nColumn ) )
	{
		if( sg_nSetBitFlagState == FALSE )
		{
			short nThisRowType;
			BOOL fAllDisabled = TRUE;

			// Cannot disable all variations
			for( short nThisRow = 0 ;  nThisRow < NBR_VARIATIONS ;  nThisRow++ )
			{
				if( nThisRow == nRow )
				{
					DWORD dwVariationChoices = m_pVarChoices->m_dwVariationChoices[nRow] & ~(1 << dwOffset);

					switch( nRowType )
					{
						case IMA_ROWTYPE:
							if( (dwVariationChoices & IMA_VF_FLAG_BITS) != 0 )
							{
								fAllDisabled = FALSE;
							}
							break;

						case DM_ROWTYPE:
							if( (dwVariationChoices & DM_VF_FLAG_BITS) != 0 )
							{
								fAllDisabled = FALSE;
							}
							break;

						default:
							ASSERT( 0 );
					}
				}
				else
				{
					nThisRowType = GetRowType( nThisRow );
					switch( nThisRowType )
					{
						case IMA_ROWTYPE:
							if( (m_pVarChoices->m_dwVariationChoices[nThisRow] & IMA_VF_FLAG_BITS) != 0 )
							{
								fAllDisabled = FALSE;
							}
							break;

						case DM_ROWTYPE:
							if( (m_pVarChoices->m_dwVariationChoices[nThisRow] & DM_VF_FLAG_BITS) != 0 )
							{
								fAllDisabled = FALSE;
							}
							break;

						default:
							ASSERT( 0 );
					}
				}

				if( fAllDisabled == FALSE )
				{
					break;
				}
			}

			if( fAllDisabled == FALSE )
			{
				m_pVarChoices->m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES;
				m_pVarChoices->m_dwVariationChoices[nRow] &= ~(1 << dwOffset);
				fUpdated = TRUE;
			}
		}
	}
	else
	{
		if( sg_nSetBitFlagState == TRUE )
		{
			m_pVarChoices->m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES;
			m_pVarChoices->m_dwVariationChoices[nRow] |= (1 << dwOffset);
			fUpdated = TRUE;
		}
	}

	if( fUpdated )
	{
		// Redraw the button
		CDC* pDC = m_btnFlags.GetDC();
		if( pDC )
		{
			m_btnFlags.DrawRowOfButtons( pDC, nRow );
			m_btnFlags.ReleaseDC( pDC );
		}

		m_fDirty = true;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::SetSelectedBits

void CVarChoicesDlg::SetSelectedBits( short nNewState )
{
	short nRowType;
    short nNbrColumns;
	DWORD dwOffset;

	ASSERT( m_pVarChoices != NULL );

	short nFirstRow = -1;
	DWORD dwFirstRowVarChoices = 0;

	BOOL fStateSaved = FALSE;

	for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
	{
		nRowType = GetRowType( nRow );
		nNbrColumns = GetNbrColumns( nRow );

		for( short nColumn = 0 ; nColumn < nNbrColumns ;  nColumn++ )
		{
			// Only attempt to change selected buttons
			if( IsBtnSelected( nRow, nColumn ) )
			{
				// Determine bit offset
				dwOffset = sga_nBtnBit[nRowType][nColumn];

				// Set the bit
				if( IsBitOn( nRow, nColumn ) )
				{
					if( nNewState == FALSE )
					{
						if( fStateSaved == FALSE )
						{
							m_pVarChoices->m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES_DISABLE;
							
							nFirstRow = nRow;
							dwFirstRowVarChoices = m_pVarChoices->m_dwVariationChoices[nRow];
							fStateSaved = TRUE;
						}
						m_pVarChoices->m_dwVariationChoices[nRow] &= ~(1 << dwOffset);
						m_fDirty = true;
					}
				}
				else
				{
					if( nNewState == TRUE )
					{
						if( fStateSaved == FALSE )
						{
							m_pVarChoices->m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES_ENABLE;
							
							nFirstRow = nRow;
							dwFirstRowVarChoices = m_pVarChoices->m_dwVariationChoices[nRow];
							fStateSaved = TRUE;
						}
						m_pVarChoices->m_dwVariationChoices[nRow] |= (1 << dwOffset);
						m_fDirty = true;
					}
				}
			}
		}
	}

	// Cannot disable all variations
	if( nNewState == FALSE
	&&  nFirstRow != -1 )
	{
		BOOL fAllDisabled = TRUE;

		for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
		{
			nRowType = GetRowType( nRow );

			switch( nRowType )
			{
				case IMA_ROWTYPE:
					if( (m_pVarChoices->m_dwVariationChoices[nRow] & IMA_VF_FLAG_BITS) != 0 )
					{
						fAllDisabled = FALSE;
					}
					break;

				case DM_ROWTYPE:
					if( (m_pVarChoices->m_dwVariationChoices[nRow] & DM_VF_FLAG_BITS) != 0 )
					{
						fAllDisabled = FALSE;
					}
					break;

				default:
					ASSERT( 0 );
			}

			if( fAllDisabled ==  FALSE )
			{
				break;
			}
		}

		if( fAllDisabled == TRUE )
		{
			m_pVarChoices->m_dwVariationChoices[nFirstRow] = dwFirstRowVarChoices;
		}
	}	
	
	RefreshControls();
	if( m_fDirty )
	{
		SyncPattern();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::SelectRow

void CVarChoicesDlg::SelectRow( short nRow, BOOL fSelect )
{
	ASSERT( m_pVarChoices != NULL );

	if( nRow != -1 )
	{
		if( fSelect )
		{
			m_pVarChoices->m_bSelectedRowBtns[nRow] = 1;
			m_pVarChoices->m_dwSelectedFlagBtns[nRow] = 0xFFFFFFFF;
		}
		else
		{
			m_pVarChoices->m_bSelectedRowBtns[nRow] = 0;
			m_pVarChoices->m_dwSelectedFlagBtns[nRow] = 0x00000000;
		}

		RefreshRowOfButtons( nRow );
	}
}



/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::UnselectAllButtons
 
void CVarChoicesDlg::UnselectAllButtons( BOOL fRedraw )
{
	ASSERT( m_pVarChoices != NULL );

	short nRow;

	if( fRedraw )
	{
		short nColumn;
		short nNbrColumns;

		CDC* pDC = m_btnRows.GetDC();
		if( pDC )
		{
			for( nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
			{
				if( IsRowSelected( nRow ) )
				{
					m_pVarChoices->m_bSelectedRowBtns[nRow] = 0;
					m_btnRows.DrawOneButton( pDC, nRow );
				}
			}

			m_btnRows.ReleaseDC( pDC );
		}

		pDC = m_btnFlags.GetDC();
		if( pDC )
		{
			for( nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
			{
				nNbrColumns = GetNbrColumns( nRow );

				for( nColumn = 0 ;  nColumn < nNbrColumns ; nColumn++ )
				{
					if( IsBtnSelected( nRow, nColumn ) )
					{
						m_pVarChoices->m_dwSelectedFlagBtns[nRow] &= ~(1 << nColumn);
						m_btnFlags.DrawOneButton( pDC, nRow, nColumn, TRUE );
					}
				}

				// Make sure all bits beyond nNbrColumns are turned off
				m_pVarChoices->m_dwSelectedFlagBtns[nRow] = 0x00000000;
			}

			m_btnFlags.ReleaseDC( pDC );
		}
	}
	else
	{
		for( nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
		{
			m_pVarChoices->m_bSelectedRowBtns[nRow] = 0;
			m_pVarChoices->m_dwSelectedFlagBtns[nRow] = 0x0000000;
		}
	}

	sg_nFirstSelectedRow = -1;
	sg_nFirstSelectedBtnRow = -1;
	sg_nFirstSelectedBtnColumn = -1;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::RowsAreSelected

BOOL CVarChoicesDlg::RowsAreSelected()
{
	ASSERT( m_pVarChoices != NULL );

	for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
	{
		if( m_pVarChoices->m_bSelectedRowBtns[nRow] )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::BtnsAreSelected

BOOL CVarChoicesDlg::BtnsAreSelected()
{
	ASSERT( m_pVarChoices != NULL );

	for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
	{
		if( m_pVarChoices->m_dwSelectedFlagBtns[nRow] )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::IsBtnSelected

BOOL CVarChoicesDlg::IsBtnSelected( short nRow, short nColumn )
{
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices->m_dwSelectedFlagBtns[nRow] & (1 << nColumn) )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::IsRowSelected

BOOL CVarChoicesDlg::IsRowSelected( short nRow )
{
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices->m_bSelectedRowBtns[nRow] )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::IsRowDisabled

BOOL CVarChoicesDlg::IsRowDisabled( short nRow )
{
	ASSERT( m_pVarChoices != NULL );

	short nRowType = GetRowType( nRow );
    short nNbrColumns = GetNbrColumns( nRow );
	DWORD dwOffset;

	for( short nColumn = 0 ;  nColumn < nNbrColumns ;  nColumn++ )
    {
		dwOffset = sga_nBtnBit[nRowType][nColumn];

		if( m_pVarChoices->m_dwVariationChoices[nRow] & (1 << dwOffset) )
		{
			return FALSE;
		}
    }

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::IsBitOn

BOOL CVarChoicesDlg::IsBitOn( short nRow, short nColumn )
{
	ASSERT( nRow != -1 );
	ASSERT( nColumn != -1 );
	ASSERT( m_pVarChoices != NULL );

	short nRowType = GetRowType( nRow );
	DWORD dwOffset = sga_nBtnBit[nRowType][nColumn];

	if( m_pVarChoices->m_dwVariationChoices[nRow] & (1 << dwOffset ) )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnUpdateEditCopy

void CVarChoicesDlg::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices->CanCopy() == S_OK )
	{
		pCmdUI->Enable( TRUE );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnEditCopy

void CVarChoicesDlg::OnEditCopy() 
{
	ASSERT( m_pVarChoices != NULL );

	if( m_pVarChoices->CanCopy() == S_OK )
	{
		IDataObject* pIDataObject;

		if( SUCCEEDED ( m_pVarChoices->CreateDataObject( &pIDataObject ) ) )
		{
			theApp.PutDataInClipboard( pIDataObject, m_pVarChoices );

			RELEASE( pIDataObject );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnUpdateEditPaste

void CVarChoicesDlg::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pVarChoices != NULL );

	if( RowsAreSelected() )
	{
		IDataObject* pIDataObject;

		// Get the IDataObject
		if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
		{
			// Determine if VarChoices editor can paste this object
			BOOL fWillSetReference;
			HRESULT hr = m_pVarChoices->CanPasteFromData( pIDataObject, &fWillSetReference );
			
			RELEASE( pIDataObject );
			
			if( hr == S_OK )
			{
				pCmdUI->Enable( TRUE );
				return;
			}
		}
	}
	
	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnEditPaste

void CVarChoicesDlg::OnEditPaste() 
{
	ASSERT( m_pVarChoices != NULL );

	IDataObject* pIDataObject;

	// Get the IDataObject
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		// Paste the data
		if( SUCCEEDED ( m_pVarChoices->PasteFromData( pIDataObject ) ) )
		{
			RefreshControls();
		}
		else
		{
			m_btnRows.InvalidateRect( NULL, FALSE );
			m_btnRows.UpdateWindow();

			m_btnFlags.InvalidateRect( NULL, FALSE );
			m_btnFlags.UpdateWindow();
		}

		RELEASE( pIDataObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnViewProperties

BOOL CVarChoicesDlg::OnViewProperties( void )
{
	IDMUSProdPropSheet* pIPropSheet;

	ASSERT( m_pVarChoices != NULL );
	ASSERT( theApp.m_pStyleComponent != NULL );
	ASSERT( theApp.m_pStyleComponent->m_pIFramework != NULL );

	if( FAILED ( theApp.m_pStyleComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return FALSE;
	}

	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return TRUE;
	}

	BOOL fSuccess = FALSE;

	if( SUCCEEDED ( m_pVarChoices->OnShowProperties() ) )
	{
		fSuccess = TRUE;
	}

	RELEASE( pIPropSheet );

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnDrawItem

void CVarChoicesDlg::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	switch( nIDCtl )
	{
		case IDC_HEADING_1:
		case IDC_HEADING_2:
		case IDC_HEADING_3:
		case IDC_HEADING_4:
		{
			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

			CWnd* pWnd = GetDlgItem( nIDCtl );
			if( pWnd )
			{
				CPen pen1;
				CPen pen2;
				CPen* pPenOld = NULL;
				CString strText;
				CRect rect( &lpDrawItemStruct->rcItem );

				pWnd->GetWindowText( strText );
				strText.TrimRight();
				strText.TrimLeft();
				strText = _T(" ") + strText + _T(" ");

				pDC->FillSolidRect( &rect, ::GetSysColor(COLOR_BTNFACE) );

				if( pen1.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW) ) )
				{
					int nY = rect.Height() >> 1;

					pPenOld = pDC->SelectObject( &pen1 );
					pDC->MoveTo( 3, ++nY + 4 );
					pDC->LineTo( 3, nY );
					pDC->LineTo( (rect.Width() - 4), nY );
					pDC->LineTo( (rect.Width() - 4), nY + 5 );

					if( pen2.CreatePen( PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT) ) )
					{
						pDC->SelectObject( &pen2 );
						pDC->MoveTo( 2, --nY + 4 );
						pDC->LineTo( 2, nY );
						pDC->LineTo( (rect.Width() - 5), nY );
						pDC->LineTo( (rect.Width() - 5), nY + 5 );
					}
				}

				pDC->SetTextColor( RGB(0,0,0) );
				pDC->DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_NOPREFIX) );

				if( pPenOld )
				{
					pDC->SelectObject( pPenOld );
				}
			}
			return;
		}

		case IDC_ROW_HEADINGS:
		{
			CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
			if( pDC == NULL )
			{
				return;
			}

			CString strText;
			CRect rect( &lpDrawItemStruct->rcItem );

			pDC->FillSolidRect( &rect, ::GetSysColor(COLOR_BTNFACE) );
			pDC->SetTextColor( RGB(0,0,0) );

			rect.right -= 2;
		    rect.bottom = rect.top + sg_nBtnHeight;
			
			for( int i = 0 ;  i < NBR_VARIATIONS ;  i++ )
			{
				strText.Format( "%d", i + 1 );
				pDC->DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_RIGHT | DT_VCENTER | DT_NOPREFIX) );
				rect.top += sg_nBtnHeight;
			    rect.bottom = rect.top + sg_nBtnHeight;
			}
			return;
		}
	}
	
	CFormView::OnDrawItem( nIDCtl, lpDrawItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnContextMenu

void CVarChoicesDlg::OnContextMenu( CWnd* pWnd, CPoint point ) 
{
	ASSERT( pWnd != NULL );
	ASSERT( m_pVarChoices != NULL );

	switch( pWnd->GetDlgCtrlID() )
	{
		case IDC_FLAGS:
		case IDC_SELECT_ROWS:
		{
			CMenu menu;

			if( menu.LoadMenu( IDM_VARCHOICES_RMENU ) )
			{
				CMenu* pMenuPopup = menu.GetSubMenu( 0 );
				if( pMenuPopup )
				{
					pMenuPopup->EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );

					if( BtnsAreSelected() )
					{
						pMenuPopup->EnableMenuItem( IDM_ENABLE, (MF_ENABLED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( IDM_DISABLE, (MF_ENABLED| MF_BYCOMMAND) );
					}
					else
					{
						pMenuPopup->EnableMenuItem( IDM_ENABLE, (MF_GRAYED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( IDM_DISABLE, (MF_GRAYED| MF_BYCOMMAND) );
					}

					if( RowsAreSelected() )
					{
						IDataObject* pIDataObject;

						pMenuPopup->EnableMenuItem( ID_EDIT_COPY, (MF_ENABLED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED| MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( IDM_IMA_MODE, (MF_ENABLED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( IDM_DM_MODE, (MF_ENABLED | MF_BYCOMMAND) );

						// Get the IDataObject
						if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
						{
							// Determine if VarChoices editor can paste this object
							BOOL fWillSetReference;
							HRESULT hr = m_pVarChoices->CanPasteFromData( pIDataObject, &fWillSetReference );
							
							RELEASE( pIDataObject );
							
							if( hr == S_OK )
							{
								pMenuPopup->EnableMenuItem( ID_EDIT_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
							}
						}

						short nFirstSelectedRow = -1;
						short nNbrSelectedRows = 0;

						for( short nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
						{
							if( IsRowSelected( nRow ) )
							{
								if( nFirstSelectedRow == -1 )
								{
									nFirstSelectedRow = nRow;
								}
								nNbrSelectedRows++;
							}
						}

						if( nNbrSelectedRows == 1 )
						{
							short nRowType = GetRowType( nFirstSelectedRow );
							
							UINT nCheck = (nRowType == IMA_ROWTYPE) ? MF_CHECKED : MF_UNCHECKED;
							pMenuPopup->CheckMenuItem( IDM_IMA_MODE, (nCheck | MF_BYCOMMAND) );

							nCheck = (nRowType == DM_ROWTYPE) ? MF_CHECKED : MF_UNCHECKED;
							pMenuPopup->CheckMenuItem( IDM_DM_MODE, (nCheck | MF_BYCOMMAND) );
						}
						else
						{
							pMenuPopup->CheckMenuItem( IDM_IMA_MODE, (MF_UNCHECKED | MF_BYCOMMAND) );
							pMenuPopup->CheckMenuItem( IDM_DM_MODE, (MF_UNCHECKED | MF_BYCOMMAND) );
						}
					}
					else
					{
						pMenuPopup->EnableMenuItem( ID_EDIT_COPY, (MF_GRAYED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED | MF_BYCOMMAND) );
						pMenuPopup->CheckMenuItem( IDM_IMA_MODE, (MF_UNCHECKED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( IDM_IMA_MODE, (MF_GRAYED | MF_BYCOMMAND) );
						pMenuPopup->CheckMenuItem( IDM_DM_MODE, (MF_UNCHECKED | MF_BYCOMMAND) );
						pMenuPopup->EnableMenuItem( IDM_DM_MODE, (MF_GRAYED | MF_BYCOMMAND) );
					}

					m_fRowRightMenu = TRUE;
					pMenuPopup->TrackPopupMenu( (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
												point.x, point.y, this, NULL );
				}
			}
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::OnCommand

BOOL CVarChoicesDlg::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	ASSERT( m_pVarChoices != NULL );

	if( HIWORD(wParam) == 0 )	// menu command
	{
		if( m_fRowRightMenu )
		{
			//CJazzUndoMan* pUndoMgr = m_pVarChoices->m_pPattern->m_pUndoMgr;

			switch( LOWORD(wParam) )
			{
				BOOL fStateSaved;
				short nRow;

				case IDM_ENABLE:
					SetSelectedBits( TRUE );
					break;

				case IDM_DISABLE:
					SetSelectedBits( FALSE );
					break;

				case ID_EDIT_COPY:
					OnEditCopy();
					break;

				case ID_EDIT_PASTE:
					OnEditPaste();
					break;

				case IDM_PROPERTIES:
					m_pVarChoices->OnShowProperties();
					break;

				case IDM_IMA_MODE:
					fStateSaved = FALSE;
					for( nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
					{
						if( IsRowSelected( nRow ) )
						{
							if( GetRowType( nRow ) != IMA_ROWTYPE )
							{
								if( fStateSaved == FALSE )
								{
									m_pVarChoices->m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES_MODE;
									fStateSaved = TRUE;
								}
								m_pVarChoices->m_dwVariationChoices[nRow] = DM_VF_FLAG_BITS;
								m_fDirty = true;
							}
						}
					}
					RefreshControls();
					if( m_fDirty )
					{
						SyncPattern();
					}
					break;

				case IDM_DM_MODE:
					fStateSaved = FALSE;
					for( nRow = 0 ;  nRow < NBR_VARIATIONS ;  nRow++ )
					{
						if( IsRowSelected( nRow ) )
						{
							if( GetRowType( nRow ) != DM_ROWTYPE )
							{
								if( fStateSaved == FALSE )
								{
									m_pVarChoices->m_nUndoText = IDS_UNDO_PATTERN_VARCHOICES_MODE;
									fStateSaved = TRUE;
								}
								m_pVarChoices->m_dwVariationChoices[nRow] = DM_VF_FLAG_BITS;
								m_pVarChoices->m_dwVariationChoices[nRow] |= (DM_ROWTYPE << 29);
								m_fDirty = true;
							}
						}
					}
					RefreshControls();
					if( m_fDirty )
					{
						SyncPattern();
					}
					break;
			}

			m_fRowRightMenu = FALSE;
			return TRUE;
		}
	}
	
	return CFormView::OnCommand( wParam, lParam );
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::CaptureMouse

void CVarChoicesDlg::CaptureMouse( CWnd *pWnd ) 
{
	// First set capture
	pWnd->SetCapture();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::ReleaseMouse

void CVarChoicesDlg::ReleaseMouse( CWnd *pWnd ) 
{
	// First release capture
	::ReleaseCapture();

	if( m_fDirty )
	{
		SyncPattern();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::RefreshControls

void CVarChoicesDlg::RefreshControls()
{
	ASSERT( m_pVarChoices != NULL );

	UnselectAllButtons( FALSE );

	m_btnRows.InvalidateRect( NULL, FALSE );
	m_btnRows.UpdateWindow();

	m_btnFlags.InvalidateRect( NULL, FALSE );
	m_btnFlags.UpdateWindow();
}


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg::HandleKeyDown

BOOL CVarChoicesDlg::HandleKeyDown( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pVarChoices != NULL );

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case 0x43:  // VK_C		(Copy)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditCopy();
						return TRUE;
					}
					break;

				case 0x56:	// VK_V		(Paste)
					if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
					{
						OnEditPaste();
						return TRUE;
					}
					break;
			}
			break;
	}
	
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\VarChoicesDlg.h ===
#ifndef __VARCHOICESDLG_H__
#define __VARCHOICESDLG_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// VarChoicesDlg.h : header file
//

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "resource.h"

class CVarChoices;
class CVarChoicesCtrl;


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesFlagsBtn window

class CVarChoicesFlagsBtn : public CButton
{
friend class CVarChoicesDlg;

// Construction
public:
	CVarChoicesFlagsBtn();

// Attributes
public:
	CVarChoicesDlg*	m_pVarChoicesDlg;

// Operations
protected:
	void IMA_DrawButtonText( CDC* pDC, CRect* pRect, short nRow, short nColumn );
	void DM_DrawButtonText( CDC* pDC, CRect* pRect, short nRow, short nColumn );
	void DrawOneButton( CDC* pDC, short nRow, short nColumn, BOOL fDrawOne );
	void DrawRowOfButtons( CDC* pDC, short nRow );
	void DrawAllButtons( CDC* pDC );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarChoicesFlagsBtn)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVarChoicesFlagsBtn();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVarChoicesFlagsBtn)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesRowsBtn window

class CVarChoicesRowsBtn : public CButton
{
friend class CVarChoicesDlg;

// Construction
public:
	CVarChoicesRowsBtn();

// Attributes
public:
	CVarChoicesDlg*	m_pVarChoicesDlg;

// Operations
protected:
	void DrawOneButton( CDC* pDC, short nRow );
	void DrawAllButtons( CDC* pDC );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarChoicesRowsBtn)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVarChoicesRowsBtn();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVarChoicesRowsBtn)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVarChoicesDlg window

class CVarChoicesDlg : public CFormView
{
friend class CVarChoices;
friend class CVarChoicesFlagsBtn;
friend class CVarChoicesRowsBtn;

public:
	CVarChoicesDlg();
	virtual ~CVarChoicesDlg();

	// Additional methods
protected:
    void RefreshRowOfButtons( short nRow );

	BOOL CreateBtnBitmaps();
	void PrepareXPosArray();
	void PrepareTextArrays();
	void PrepareColumnHeadings();

	void SyncPattern();
	short GetRowType( short nRow );
    short GetNbrColumns( short nRow );
    short GetBtnWidth( short nRow, short nColumn );
    short FindRow( int nYPos );
    short FindColumn( short nRow, int nXPos );
    void SetBit( short nRow, short nColumn );
    void SetSelectedBits( short nState );
    void SelectRow( short nRow, BOOL fSelect );
    void UnselectAllButtons( BOOL fRedraw );
	BOOL RowsAreSelected();
	BOOL BtnsAreSelected();
	BOOL IsBtnSelected( short nRow, short nColumn );
	BOOL IsRowSelected( short nRow );
	BOOL IsRowDisabled( short nRow );
	BOOL IsBitOn( short nRow, short nColumn );
	void CaptureMouse( CWnd* pWnd );
	void ReleaseMouse( CWnd* pWnd );

public:
	void RefreshControls();
	BOOL HandleKeyDown( MSG* pMsg );
	void OnUpdateEditCopy( CCmdUI* pCmdUI );
	void OnEditCopy();
	void OnUpdateEditPaste( CCmdUI* pCmdUI );
	void OnEditPaste();
	BOOL OnViewProperties();

protected:
	DECLARE_DYNCREATE(CVarChoicesDlg)

// Form Data
public:
	//{{AFX_DATA(CVarChoicesDlg)
	enum { IDD = IDD_DLG_VARCHOICES };
	//}}AFX_DATA

// Member variables
private:
	BOOL					m_fRowRightMenu;	// May be recipient of right menu command id
	CFont*					m_pFont;
	CFont*					m_pFontBold;
	CFont*					m_pFontItalics;
	CFont*					m_pFontItalicsBold;
	bool					m_fDirty;

	CVarChoicesRowsBtn		m_btnRows;			// Subclasses IDC_SELECT_ROWS
	CVarChoicesFlagsBtn		m_btnFlags;			// Subclasses IDC_FLAGS

public:
	CVarChoicesCtrl*		m_pVarChoicesCtrl;
	CVarChoices*			m_pVarChoices;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarChoicesDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CVarChoicesDlg)
	afx_msg void OnDestroy();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __VARCHOICESDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\DialogEditSeed.cpp ===
// DialogEditSeed.cpp : implementation file
//

#include "stdafx.h"
#include "DialogEditSeed.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogEditSeed dialog


CDialogEditSeed::CDialogEditSeed(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogEditSeed::IDD, pParent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//{{AFX_DATA_INIT(CDialogEditSeed)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_dwVariationSeed = 1;
}


void CDialogEditSeed::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogEditSeed)
	DDX_Control(pDX, IDC_EDIT_VARIATION_SEED, m_editSeed);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialogEditSeed, CDialog)
	//{{AFX_MSG_MAP(CDialogEditSeed)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogEditSeed message handlers

void CDialogEditSeed::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	TCHAR tcstrText[20];
	ZeroMemory( tcstrText, sizeof(TCHAR) * 20 );
	m_editSeed.GetWindowText( tcstrText, 19 );
	if( _tcslen( tcstrText ) == 0 )
	{
		m_dwVariationSeed = 0;
	}
	else
	{
		_stscanf( tcstrText, "%u", &m_dwVariationSeed );
	}

	if( m_dwVariationSeed == 0 )
	{
		CString strText;
		if( strText.LoadString( IDS_ERR_SEED_ZERO ) )
		{
			MessageBox( strText, NULL, MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL );
			return;
		}
	}

	CDialog::OnOK();
}

BOOL CDialogEditSeed::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();
	
	TCHAR tcstrText[20];
	_stprintf( tcstrText, "%u", m_dwVariationSeed );
	m_editSeed.SetWindowText( tcstrText );

	_stprintf( tcstrText, "%u", UINT_MAX );
	m_editSeed.SetLimitText( _tcslen( tcstrText ) );
	m_editSeed.SetFocus();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\DialogEditSeed.h ===
#if !defined(AFX_DIALOGEDITSEED_H__4C00C9F8_1546_11D3_A71A_00105A26620B__INCLUDED_)
#define AFX_DIALOGEDITSEED_H__4C00C9F8_1546_11D3_A71A_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DialogEditSeed.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CDialogEditSeed dialog

class CDialogEditSeed : public CDialog
{
// Construction
public:
	CDialogEditSeed(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDialogEditSeed)
	enum { IDD = IDD_EDIT_VARIATION_SEED };
	CEdit	m_editSeed;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogEditSeed)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DWORD		m_dwVariationSeed;

protected:

	// Generated message map functions
	//{{AFX_MSG(CDialogEditSeed)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGEDITSEED_H__4C00C9F8_1546_11D3_A71A_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "PropPageVarSeed.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

short CGroupBitsPropPageMgr::sm_nActiveTab = 0;
short *CGroupBitsPPG::sm_pnActiveTab = NULL;

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	m_pVarSeedPPG = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	if( m_pVarSeedPPG )
	{
		delete m_pVarSeedPPG;
		m_pVarSeedPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add group bits tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add variation seed tab
	if( NULL == m_pVarSeedPPG )
	{
		m_pVarSeedPPG = new CPropPageVarSeed();
	}
	if( m_pVarSeedPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pVarSeedPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pVarSeedPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CPropPageVarSeed::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	if( m_pVarSeedPPG )
	{
		m_pVarSeedPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pVarSeedPPG )
	{
		m_pVarSeedPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if(::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	int iIndex;
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPGData *pioGroupBitsPPGData = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPGData ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	for (iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C64_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C64_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

typedef struct 
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
} ioGroupBitsPPGData;

// GroupBitsPPG.h : header file
//

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : CStaticPropPageManager
{
public:
	CGroupBitsPropPageMgr();
	~CGroupBitsPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CPropPageVarSeed*	m_pVarSeedPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;

	public:
	static short			sm_nActiveTab;
};

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_STYLE_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );
	void OnCheckHelper( int nButtonID, DWORD dwFlag );

	// Variables for keeping track of the active property tab
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPGData			m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C64_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

//#include <staticproppagemanager.h>
#include <StaticPropPageManager.h>

class PropPageStyleRef;
class CStyleRefMgr;

class CStyleRefPropPageMgr : CStaticPropPageManager
{
	friend PropPageStyleRef;
public:
	CStyleRefPropPageMgr(IDMUSProdFramework* pIFramework, CStyleRefMgr* pStyleRefMgr);
	~CStyleRefPropPageMgr();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
 
	// IDMUSProdPropPageManager methods
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional methods
	void UpdateObjectWithStyleRefData();

private:
	IDMUSProdFramework*		m_pIFramework;
	CStyleRefMgr*			m_pStyleRefMgr;
	PropPageStyleRef*		m_pPropPageStyleRef;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropPageStyleRef.h ===
#if !defined(AFX_PROPPAGESTYLE_REF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGESTYLE_REF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include <afxtempl.h>


class CStyleRefPropPageMgr;

// PropPageStyleRef.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef dialog
class CStyleRefPropPageMgr;

class PropPageStyleRef : public CPropertyPage
{
	friend CStyleRefPropPageMgr;
	DECLARE_DYNCREATE(PropPageStyleRef)

// Construction
public:
	PropPageStyleRef();
	~PropPageStyleRef();

// Dialog Data
	//{{AFX_DATA(PropPageStyleRef)
	enum { IDD = IDD_STYLE_REF_PROPPAGE };
	CComboBox	m_comboStyle;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageStyleRef)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageStyleRef)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditMeasure();
	afx_msg void OnSelchangeComboStyles();
	afx_msg void OnDropDownComboStyle();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void CopyDataToStyleRef( CPropStyleRef* pStyleRef );
	void GetDataFromStyleRef( CPropStyleRef* pStyleRef );

protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();
	void SetStyleComboBoxSelection();
	void GetComboBoxText( const StyleListInfo* pStyleListInfo, CString& strText );
	void InsertStyleInfoListInComboBox();
	void InsertStyleInfo( StyleListInfo* pStyleListInfo );
	void BuildStyleInfoList();
	int AdjustTime( int nNewValue, int nDelta );

private:
	CPropStyleRef*			m_pStyleRef;
	CStyleRefPropPageMgr*	m_pPropPageMgr;
	IDMUSProdFramework*		m_pIFramework;
	BOOL					m_fIgnoreSelChange;
	BOOL					m_fHaveData;
	BOOL					m_fMultipleStylesSelected;
	BOOL					m_fNeedToDetach;
    CTypedPtrList<CPtrList, StyleListInfo*> m_lstStyleListInfo;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGESTYLE_REF_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropPageStyleRef.cpp ===
// PropPageStyleRef.cpp : implementation file
//

#include "stdafx.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "StyleRefMgr.h"
#include "timeline.h"
#include "PropStyleRef.h"
#include "PropPageMgr.h"
#include "PropPageStyleRef.h"
#include <initguid.h>
#include <StyleDesigner.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr constructor/destructor

CStyleRefPropPageMgr::CStyleRefPropPageMgr(IDMUSProdFramework* pIFramework, CStyleRefMgr* pStyleRefMgr) : CStaticPropPageManager()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();

	m_pStyleRefMgr = pStyleRefMgr;

	m_pPropPageStyleRef = NULL;
//	CStaticPropPageManager::CStaticPropPageManager();
}

CStyleRefPropPageMgr::~CStyleRefPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageStyleRef )
	{
		delete m_pPropPageStyleRef;
		m_pPropPageStyleRef = NULL;
	}
	if( m_pIFramework )
	{
		m_pIFramework->Release();
		m_pIFramework = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr::QueryInterface

HRESULT STDMETHODCALLTYPE CStyleRefPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just call the base class implementation
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CStyleRefPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	// Get and store the title.
	strTitle.LoadString( IDS_PROPPAGE_STYLE_REF );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CStyleRefPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add StyleRef tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageStyleRef)
	{
		m_pPropPageStyleRef = new PropPageStyleRef;
		if( m_pPropPageStyleRef )
		{
			m_pPropPageStyleRef->m_pIFramework = m_pIFramework;
			m_pPropPageStyleRef->m_pIFramework->AddRef();

			m_pPropPageStyleRef->m_pPropPageMgr = this;
		}
	}

	if( m_pPropPageStyleRef )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageStyleRef->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageStyleRef->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CStyleRefPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CStyleRefPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropStyleRef* pStyleRef = NULL;
	HRESULT hr = S_OK;

	if( m_pIPropPageObject == NULL )
	{
		pStyleRef = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pStyleRef ) ) )
	{
		pStyleRef = NULL;
		hr = E_FAIL;
	}

	if( m_pPropPageStyleRef )
	{
		m_pPropPageStyleRef->m_fMultipleStylesSelected = FALSE;
		m_pPropPageStyleRef->m_fHaveData = FALSE;

		if( pStyleRef )
		{
			if( pStyleRef->m_dwMeasure == 0xFFFFFFFF )
			{
				m_pPropPageStyleRef->m_fMultipleStylesSelected = TRUE;
			}
			else
			{
				m_pPropPageStyleRef->m_fHaveData = TRUE;
			}
			m_pPropPageStyleRef->CopyDataToStyleRef( pStyleRef );
		}
		else
		{
			CPropStyleRef StyleRef;
			m_pPropPageStyleRef->CopyDataToStyleRef( &StyleRef );
		}

		m_pPropPageStyleRef->UpdateControls();
	}

	if( pStyleRef )
	{
		delete pStyleRef;
	}

	return hr;
};

void CStyleRefPropPageMgr::UpdateObjectWithStyleRefData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIPropPageObject != NULL );

	CPropStyleRef StyleRef;

	// Populate the StyleRef structure
	m_pPropPageStyleRef->GetDataFromStyleRef( &StyleRef );
	
	// Send the new data to the PropPageObject
	m_pIPropPageObject->SetData( (void *)&StyleRef );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef property page

IMPLEMENT_DYNCREATE(PropPageStyleRef, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef constructor/destructor

PropPageStyleRef::PropPageStyleRef() : CPropertyPage(PropPageStyleRef::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_STYLE_REF_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageStyleRef)
	//}}AFX_DATA_INIT
	m_pIFramework = NULL;

	m_fIgnoreSelChange = FALSE;
	m_fHaveData = FALSE;
	m_fMultipleStylesSelected = FALSE;
	m_pStyleRef = new CPropStyleRef;
	m_fNeedToDetach = FALSE;
}

PropPageStyleRef::~PropPageStyleRef()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StyleListInfo* pStyleListInfo;

	while( !m_lstStyleListInfo.IsEmpty() )
	{
		pStyleListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.RemoveHead() );
		delete pStyleListInfo;
	}

	if( m_pIFramework )
	{
		m_pIFramework->Release();
	}
	
	if( m_pStyleRef )
	{
		delete m_pStyleRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef::DoDataExchange

void PropPageStyleRef::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageStyleRef)
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_COMBO_STYLES, m_comboStyle);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageStyleRef, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageStyleRef)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_WM_KILLFOCUS()
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_CBN_SELCHANGE(IDC_COMBO_STYLES, OnSelchangeComboStyles)
	ON_CBN_DROPDOWN(IDC_COMBO_STYLES, OnDropDownComboStyle)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef::UpdateControls

void PropPageStyleRef::UpdateControls()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Controls not created yet
	if( IsWindow( m_hWnd ) == 0 )
	{
		return;
	}

	ASSERT( m_pStyleRef );
	if( m_pStyleRef == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	// Update the property page based on the new data.

	// Set enable state of controls
	EnableControls( m_fHaveData );

	// Style combo box
	m_fIgnoreSelChange = TRUE;
	SetStyleComboBoxSelection();
	m_fIgnoreSelChange = FALSE;

	// Measure
	if( m_pStyleRef->m_dwMeasure != (DWORD)(m_spinMeasure.GetPos() - 1) )
	{
		m_spinMeasure.SetPos( m_pStyleRef->m_dwMeasure + 1 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef::OnCreate

int PropPageStyleRef::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef::OnDestroy

void PropPageStyleRef::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef::OnInitDialog

BOOL PropPageStyleRef::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	m_spinMeasure.SetRange( 1, 32767 );
	m_editMeasure.LimitText( 5 );

	// Update the dialog
	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageStyleRef, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageStyleRef)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageStyleRef::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fHaveData )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditMeasure();

		int nNewValue = m_pStyleRef->m_dwMeasure + pNMUpDown->iDelta;
		int nDelta = pNMUpDown->iDelta;
		if( nNewValue < 0 )
		{
			nNewValue = 0;
			nDelta = -(signed(m_pStyleRef->m_dwMeasure));
		}
		else if( nNewValue > 32766 )
		{
			nNewValue = 32766;
			nDelta = 32766 - m_pStyleRef->m_dwMeasure;
		}

		if( (DWORD)nNewValue != m_pStyleRef->m_dwMeasure )
		{
			nNewValue = AdjustTime( nNewValue, nDelta );

			if( (DWORD)nNewValue != m_pStyleRef->m_dwMeasure )
			{
				m_pStyleRef->m_dwMeasure = nNewValue;
				m_spinMeasure.SetPos( nNewValue + 1 );
				m_pPropPageMgr->UpdateObjectWithStyleRefData();
			}
		}
	}

	// We handled this message - don't change the numbers further
	*pResult = 1;
}


void PropPageStyleRef::OnKillfocusEditMeasure() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get maximum number of measures
	long lMaxMeasure;
	VARIANT var;
	m_pPropPageMgr->m_pStyleRefMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	m_pPropPageMgr->m_pStyleRefMgr->m_pTimeline->ClocksToMeasureBeat( m_pPropPageMgr->m_pStyleRefMgr->m_dwGroupBits,
																	  0,
																	  V_I4( &var ),
																	  &lMaxMeasure,
																	  NULL );
	// Ensure lMaxMeasure is at least 1
	lMaxMeasure = max( 1, lMaxMeasure );

	CString strNewMeasure;

	m_editMeasure.GetWindowText( strNewMeasure );

	// Strip leading and trailing spaces
	strNewMeasure.TrimRight();
	strNewMeasure.TrimLeft();

	if( strNewMeasure.IsEmpty() )
	{
		m_spinMeasure.SetPos( m_pStyleRef->m_dwMeasure + 1 );
	}
	else
	{
		int iNewMeasure = _ttoi( strNewMeasure );
		if( iNewMeasure > lMaxMeasure )
		{
			iNewMeasure = lMaxMeasure;
		}
		else if( iNewMeasure < 1 )
		{
			iNewMeasure = 1;
		}

		m_spinMeasure.SetPos( iNewMeasure );
		
		iNewMeasure--;
		if( (DWORD)iNewMeasure != m_pStyleRef->m_dwMeasure )
		{
			m_pStyleRef->m_dwMeasure = iNewMeasure;
			m_pPropPageMgr->UpdateObjectWithStyleRefData();
		}
	}
}

void PropPageStyleRef::OnSelchangeComboStyles() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIFramework != NULL );
	ASSERT( m_pStyleRef != NULL );

	if( m_fIgnoreSelChange )
	{
		return;
	}

	int nItem = m_comboStyle.GetCurSel();
	if( nItem != CB_ERR )
	{
		StyleListInfo* pStyleListInfo = (StyleListInfo *)m_comboStyle.GetItemDataPtr( nItem );
		if( pStyleListInfo != (StyleListInfo *)-1 )
		{
			// fill in appropriate fields
			m_pStyleRef->m_StyleListInfo = *pStyleListInfo;

			IDMUSProdNode* pIStyleDocRootNode = NULL;
			
			// NOTE: styles must currently be selected to avoid killing
			// the property page while making this call
			if( SUCCEEDED ( m_pIFramework->FindDocRootNodeByFileGUID( pStyleListInfo->guidFile, &pIStyleDocRootNode ) ) )
			{
				if( m_pStyleRef->m_pIStyleDocRootNode )
				{
					m_pStyleRef->m_pIStyleDocRootNode->Release();
					m_pStyleRef->m_pIStyleDocRootNode = NULL;
				}
				
				m_pStyleRef->m_pIStyleDocRootNode = pIStyleDocRootNode;
				if( m_pStyleRef->m_pIStyleDocRootNode )
				{
					m_pStyleRef->m_pIStyleDocRootNode->AddRef();
				}

				m_pPropPageMgr->UpdateObjectWithStyleRefData();

				pIStyleDocRootNode->Release();	// ?????????
			}
		}
	}
	
}


BOOL PropPageStyleRef::OnSetActive( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
	
	return CPropertyPage::OnSetActive();
}


void PropPageStyleRef::EnableControls( BOOL fEnable ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_editMeasure.GetSafeHwnd() == NULL )
	{
		return;
	}

	m_spinMeasure.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_comboStyle.EnableWindow( fEnable );

	if( !fEnable )
	{
		m_comboStyle.SetCurSel( -1 );
	}
}


void PropPageStyleRef::SetStyleComboBoxSelection( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pIFramework != NULL );

	IDMUSProdProject* pIProject = NULL;
	CString strText;
	int nMatch;
	int nCount;
	int nCurPos;
	int nPos = -1;

	// Multiple Styles selected
	if( m_fMultipleStylesSelected )
	{
		CString strText;
		if( strText.LoadString( IDS_MULTIPLE_SELECT ) )
		{
			StyleListInfo* pSLI;

			// Delete old StyleInfo list
			while( !m_lstStyleListInfo.IsEmpty() )
			{
				pSLI = static_cast<StyleListInfo*>( m_lstStyleListInfo.RemoveHead() );
				delete pSLI;
			}

			// Remove old list from combo box
			m_comboStyle.ResetContent();

			// Add this string to the combo box list and select it
			m_comboStyle.AddString( strText );
			nPos = 0;
			goto LEAVE;
		}
	}

	// Nothing to select
	if( m_pStyleRef->m_pIStyleDocRootNode == NULL )
	{
		goto LEAVE;
	}

	// Create a StyleListInfo struct for the current Style
	DMUSProdListInfo ListInfo;
	StyleListInfo* pStyleListInfo;

	ZeroMemory( &ListInfo, sizeof(ListInfo) );
	ListInfo.wSize = sizeof(ListInfo);

	pStyleListInfo = new StyleListInfo;
	if( pStyleListInfo == NULL )
	{
		goto LEAVE;
	}

	// Update DocRoot file GUID
	m_pIFramework->GetNodeFileGUID ( m_pStyleRef->m_pIStyleDocRootNode, &pStyleListInfo->guidFile );

	if( SUCCEEDED ( m_pStyleRef->m_pIStyleDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
	{
		if( ListInfo.bstrName )
		{
			pStyleListInfo->strName = ListInfo.bstrName;
			::SysFreeString( ListInfo.bstrName );
		}
		
		if( ListInfo.bstrDescriptor )
		{
			pStyleListInfo->strDescriptor = ListInfo.bstrDescriptor;
			::SysFreeString( ListInfo.bstrDescriptor );
		}

		if( FAILED ( m_pIFramework->FindProject( m_pStyleRef->m_pIStyleDocRootNode, &pIProject ) ) )
		{
			delete pStyleListInfo;
			goto LEAVE;
		}

		pStyleListInfo->pIProject = pIProject;
//		pStyleListInfo->pIProject->AddRef();	intentionally missing

		GUID guidProject;
		if( FAILED ( pIProject->GetGUID( &guidProject ) ) )
		{
			delete pStyleListInfo;
			goto LEAVE;
		}

//		if( !IsEqualGUID( guidProject, m_guidProject ) )
		{
			BSTR bstrProjectName;

			if( FAILED ( pIProject->GetName( &bstrProjectName ) ) )
			{
				delete pStyleListInfo;
				goto LEAVE;
			}

			pStyleListInfo->strProjectName = bstrProjectName;
			::SysFreeString( bstrProjectName );
		}
	}
	else
	{
		delete pStyleListInfo;
		goto LEAVE;
	}

	// Select the Style in the combo box list
	nMatch = CB_ERR;
	nCount = m_comboStyle.GetCount();
	for( nCurPos = 0 ;  nCurPos < nCount ;  nCurPos++ )
	{
		StyleListInfo* pCurStyleListInfo = (StyleListInfo *)m_comboStyle.GetItemDataPtr( nCurPos );
		if( pCurStyleListInfo )
		{
			if( pCurStyleListInfo != (StyleListInfo *)-1 )
			{
				// See if GUIDs are equal
				if( ::IsEqualGUID( pCurStyleListInfo->guidFile, pStyleListInfo->guidFile ) )
				{
					nMatch = nCurPos;
					break;
				}
			}
		}
	}

	if( nMatch == CB_ERR )
	{
		StyleListInfo* pSLI;

		// Delete old StyleInfo list
		while( !m_lstStyleListInfo.IsEmpty() )
		{
			pSLI = static_cast<StyleListInfo*>( m_lstStyleListInfo.RemoveHead() );
			delete pSLI;
		}

		// Remove old list from combo box
		m_comboStyle.ResetContent();

		// Add this Style to the combo box list
		nPos = 0;
		m_lstStyleListInfo.AddTail( pStyleListInfo );
		InsertStyleInfoListInComboBox();
	}
	else
	{
		nPos = nMatch;
		delete pStyleListInfo;
		pStyleListInfo = NULL;
	}

LEAVE:
	m_comboStyle.SetCurSel( nPos );

	if( pIProject )
	{
		pIProject->Release();
	}
}


void PropPageStyleRef::GetComboBoxText( const StyleListInfo* pStyleListInfo, CString& strText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pStyleListInfo->strProjectName.IsEmpty() )
	{
		strText.Format( "%s %s", pStyleListInfo->strName, pStyleListInfo->strDescriptor );
	}
	else
	{
		strText.Format( "%s: %s %s", pStyleListInfo->strProjectName, pStyleListInfo->strName, pStyleListInfo->strDescriptor );
	}
}

void PropPageStyleRef::InsertStyleInfoListInComboBox( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strText;
	StyleListInfo* pStyleListInfo;
	int nPos;

	POSITION pos = m_lstStyleListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		pStyleListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.GetNext(pos) );
		if( pStyleListInfo )
		{
			GetComboBoxText( pStyleListInfo, strText );
			nPos = m_comboStyle.AddString( strText );
			if( nPos >= 0 )
			{
				m_comboStyle.SetItemDataPtr( nPos, pStyleListInfo );
			}
		}
	}
}

void PropPageStyleRef::InsertStyleInfo( StyleListInfo* pStyleListInfo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StyleListInfo* pListInfo;
	CString strListText;
	CString strStyleText;
	POSITION posList;

	GetComboBoxText( pStyleListInfo, strStyleText );

	POSITION pos = m_lstStyleListInfo.GetHeadPosition();
	while( pos != NULL )
	{
		posList = pos;

		pListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.GetNext(pos) );
		if( pListInfo )
		{
			if( !pStyleListInfo->strProjectName.IsEmpty()
			&&  pListInfo->strProjectName.IsEmpty() )
			{
				continue;
			}

			if( pStyleListInfo->strProjectName.IsEmpty()
			&&  !pListInfo->strProjectName.IsEmpty() )
			{
				if( pos )
				{
					m_lstStyleListInfo.InsertBefore( pos, pStyleListInfo );
				}
				else
				{
					m_lstStyleListInfo.AddTail( pStyleListInfo );
				}
				return;
			}

			GetComboBoxText( pListInfo, strListText );

			if( strListText.CompareNoCase( strStyleText ) > 0 )
			{
				m_lstStyleListInfo.InsertBefore( posList, pStyleListInfo );
				return;
			}
		}
	}

	m_lstStyleListInfo.AddTail( pStyleListInfo );
}


void PropPageStyleRef::BuildStyleInfoList( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	IDMUSProdDocType* pIDocType;
	IDMUSProdProject* pIProject;
	IDMUSProdProject* pINextProject;
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	BSTR bstrProjectName;
	GUID guidProject;
	DMUSProdListInfo ListInfo;
	StyleListInfo* pStyleListInfo;

	if( FAILED ( m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		return;
	}

	HRESULT hr = m_pIFramework->GetFirstProject( &pINextProject );

	while( SUCCEEDED( hr )  &&  pINextProject )
    {
		pIProject = pINextProject;

		HRESULT hr = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

		while( hr == S_OK )
		{
			pIFileNode = pINextFileNode;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
			{
				pStyleListInfo = new StyleListInfo;

				pStyleListInfo->pIProject = pIProject;
//				pStyleListInfo->pIProject->AddRef();	intentionally missing

				if( SUCCEEDED ( pIProject->GetGUID( &guidProject ) ) )
				{
//					if( !IsEqualGUID( guidProject, m_guidProject ) )
					{
						if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
						{
							pStyleListInfo->strProjectName = bstrProjectName;
							::SysFreeString( bstrProjectName );
						}
					}

				}

				if( ListInfo.bstrName )
				{
					pStyleListInfo->strName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				
				if( ListInfo.bstrDescriptor )
				{
					pStyleListInfo->strDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}

				// Update DocRoot file GUID
				m_pIFramework->GetNodeFileGUID ( pIFileNode, &pStyleListInfo->guidFile );

				InsertStyleInfo( pStyleListInfo );

				hr = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
				pIFileNode->Release();
			}
			else
			{
				hr = E_FAIL;
			}
		}
	
	    hr = m_pIFramework->GetNextProject( pIProject, &pINextProject );
		pIProject->Release();
	}

	pIDocType->Release();
}

void PropPageStyleRef::CopyDataToStyleRef( CPropStyleRef* pStyleRef )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pStyleRef != NULL );

	m_pStyleRef->m_dwMeasure	 = pStyleRef->m_dwMeasure;
	m_pStyleRef->m_dwBits		 = pStyleRef->m_dwBits;
	m_pStyleRef->m_StyleListInfo = pStyleRef->m_StyleListInfo;
	m_pStyleRef->m_TimeSignature = pStyleRef->m_TimeSignature;

	if( m_pStyleRef->m_pIStyleDocRootNode )
	{
		m_pStyleRef->m_pIStyleDocRootNode->Release();
		m_pStyleRef->m_pIStyleDocRootNode = NULL;
	}
	m_pStyleRef->m_pIStyleDocRootNode = pStyleRef->m_pIStyleDocRootNode;
	if( m_pStyleRef->m_pIStyleDocRootNode )
	{
		m_pStyleRef->m_pIStyleDocRootNode->AddRef();
	}

	memcpy( &m_pStyleRef->m_guidProject, &pStyleRef->m_guidProject, sizeof( m_pStyleRef->m_guidProject ) );
}


void PropPageStyleRef::GetDataFromStyleRef( CPropStyleRef* pStyleRef )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pStyleRef != NULL );

	pStyleRef->m_dwMeasure		= m_pStyleRef->m_dwMeasure;
	pStyleRef->m_dwBits			= m_pStyleRef->m_dwBits;
	pStyleRef->m_StyleListInfo	= m_pStyleRef->m_StyleListInfo;
	pStyleRef->m_TimeSignature	= m_pStyleRef->m_TimeSignature;

	if( pStyleRef->m_pIStyleDocRootNode )
	{
		pStyleRef->m_pIStyleDocRootNode->Release();
		pStyleRef->m_pIStyleDocRootNode = NULL;
	}
	pStyleRef->m_pIStyleDocRootNode = m_pStyleRef->m_pIStyleDocRootNode;
	if( pStyleRef->m_pIStyleDocRootNode )
	{
		pStyleRef->m_pIStyleDocRootNode->AddRef();
	}

	memcpy( &pStyleRef->m_guidProject, &m_pStyleRef->m_guidProject, sizeof( pStyleRef->m_guidProject ) );
}

void PropPageStyleRef::OnDropDownComboStyle( void ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StyleListInfo* pStyleListInfo;

	// Delete old StyleInfo list
	while( !m_lstStyleListInfo.IsEmpty() )
	{
		pStyleListInfo = static_cast<StyleListInfo*>( m_lstStyleListInfo.RemoveHead() );
		delete pStyleListInfo;
	}

	// Remove old list from combo box
	m_comboStyle.ResetContent();

	// Rebuild the StyleInfo list
	BuildStyleInfoList();
	InsertStyleInfoListInComboBox();

	// Select the current Style
	SetStyleComboBoxSelection();
}

BOOL PropPageStyleRef::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fHaveData )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_MEASURE: 
								m_spinMeasure.SetPos( m_pStyleRef->m_dwMeasure + 1 );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageStyleRef::AdjustTime

int PropPageStyleRef::AdjustTime( int nNewValue, int nDelta )
{
	IStyleRefMgr *pIStyleRefMgr;

	if( SUCCEEDED( m_pPropPageMgr->m_pIPropPageObject->QueryInterface( IID_IStyleRefMgr, (void**) &pIStyleRefMgr ) ) )
	{
		// Save the original value
		const int nOrigValue = nNewValue - nDelta;

		while( TRUE )
		{
			HRESULT hr = pIStyleRefMgr->IsMeasureOpen( nNewValue );
			if( FAILED(hr) )
			{
				// The measure is off the end of the segment - there are no open measures
				// after nNewValue.  Check between nOrigvalue and nNewValue
				ASSERT( nDelta > 0 );
				for( int i = nOrigValue + nDelta - 1; i > nOrigValue; i-- )
				{
					if( pIStyleRefMgr->IsMeasureOpen( i ) == S_OK )
					{
						break;
					}
				}

				// If we found an open measure, i will point to it.
				// If we didn't find an open measure, i will be nOrigValue
				nNewValue = i;
				break;
			}
			else
			{
				if( hr == S_OK )
				{
					break;
				}
				else
				{
					nNewValue += nDelta > 0 ? 1 : -1;
					if( nNewValue < 0 )
					{
						// The measure is before the start of the segment - there are no open measures
						// before nNewValue.  Check between nOrigvalue and nNewValue
						ASSERT( nDelta < 0 );
						for( int i = nOrigValue - 1; i > nOrigValue + nDelta; i-- )
						{
							if( pIStyleRefMgr->IsMeasureOpen( i ) == S_OK )
							{
								nNewValue = i;
								break;
							}
						}
						nNewValue = nOrigValue;
						break;
					}
				}
			}
		}
		pIStyleRefMgr->Release();

		return nNewValue;
	}
	else
	{
		return nNewValue;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropPageVarSeed.cpp ===
// PropPageVarSeed.cpp : implementation file
//

#include "stdafx.h"
#include "PropPageVarSeed.h"
#include "DMusProd.h"
#include <time.h>
#include "DialogEditSeed.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageVarSeed property page

short *CPropPageVarSeed::sm_pnActiveTab = NULL;

IMPLEMENT_DYNCREATE(CPropPageVarSeed, CPropertyPage)

CPropPageVarSeed::CPropPageVarSeed() : CPropertyPage(CPropPageVarSeed::IDD)
{
	//{{AFX_DATA_INIT(CPropPageVarSeed)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_fNeedToDetach = FALSE;
	m_fSeedVariationsEnabled = FALSE;
	time( reinterpret_cast<long *>(&m_dwVariationSeed) );
	srand(m_dwVariationSeed);
}

CPropPageVarSeed::~CPropPageVarSeed()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CPropPageVarSeed::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageVarSeed)
	DDX_Control(pDX, IDC_CHECK_ENABLE_SEED, m_checkEnableSeed);
	DDX_Control(pDX, IDC_BUTTON_NEW_SEED, m_btnNewSeed);
	DDX_Control(pDX, IDC_BUTTON_EDIT_SEED, m_btnEditSeed);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageVarSeed, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageVarSeed)
	ON_BN_CLICKED(IDC_CHECK_ENABLE_SEED, OnCheckEnableSeed)
	ON_BN_CLICKED(IDC_BUTTON_EDIT_SEED, OnButtonEditSeed)
	ON_BN_CLICKED(IDC_BUTTON_NEW_SEED, OnButtonNewSeed)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CPropPageVarSeed::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CPropPageVarSeed::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if(::IsWindow(m_checkEnableSeed.m_hWnd))
	{
		m_checkEnableSeed.EnableWindow(fEnable);
	}

	if( ::IsWindow(m_btnNewSeed.m_hWnd)
	&&	::IsWindow(m_btnEditSeed.m_hWnd) )
	{
		m_btnNewSeed.EnableWindow(fEnable && m_fSeedVariationsEnabled);
		m_btnEditSeed.EnableWindow(fEnable && m_fSeedVariationsEnabled);
	}
}

void CPropPageVarSeed::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioVarSeedPPGData iVarSeedPPGData;
	iVarSeedPPGData.dwPageIndex = 2;
	ioVarSeedPPGData *pioVarSeedPPGData = &iVarSeedPPGData;
	if( FAILED( m_pPPO->GetData( (void**)&pioVarSeedPPGData ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	m_fSeedVariationsEnabled = iVarSeedPPGData.fVariationSeedEnabled;
	m_dwVariationSeed = iVarSeedPPGData.dwVariationSeed;

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	m_checkEnableSeed.SetCheck( m_fSeedVariationsEnabled );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

/////////////////////////////////////////////////////////////////////////////
// CPropPageVarSeed message handlers

void CPropPageVarSeed::OnCheckEnableSeed() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_fSeedVariationsEnabled = m_checkEnableSeed.GetCheck();

	if( m_pPPO )
	{
		EnableControls( TRUE );
		UpdatePPO();
	}
}

void CPropPageVarSeed::OnButtonEditSeed() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialogEditSeed dlgEditSeed;
	dlgEditSeed.m_dwVariationSeed = m_dwVariationSeed;
	if( dlgEditSeed.DoModal() == IDOK )
	{
		m_dwVariationSeed = dlgEditSeed.m_dwVariationSeed;

		UpdatePPO();
	}

	m_btnEditSeed.SetFocus();
}

void CPropPageVarSeed::OnButtonNewSeed() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_dwVariationSeed = rand() * rand();

	UpdatePPO();
}

BOOL CPropPageVarSeed::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CPropPageVarSeed::UpdatePPO()
{
	if( m_pPPO )
	{
		ioVarSeedPPGData oVarSeedPPGData;
		oVarSeedPPGData.dwPageIndex = 2;
		oVarSeedPPGData.dwVariationSeed = m_dwVariationSeed;
		oVarSeedPPGData.fVariationSeedEnabled = m_fSeedVariationsEnabled;
		VERIFY( SUCCEEDED( m_pPPO->SetData(&oVarSeedPPGData) ) );
	}
}

int CPropPageVarSeed::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CPropPageVarSeed::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CPropPageVarSeed::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropPageVarSeed.h ===
#if !defined(AFX_PROPPAGEVARSEED_H__CF76B035_AF34_4CC1_99E9_A5753AFFCF0B__INCLUDED_)
#define AFX_PROPPAGEVARSEED_H__CF76B035_AF34_4CC1_99E9_A5753AFFCF0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropPageVarSeed.h : header file
//

#include "resource.h"

typedef struct 
{
	DWORD dwPageIndex;
	DWORD dwVariationSeed;
	BOOL fVariationSeedEnabled;
} ioVarSeedPPGData;

/////////////////////////////////////////////////////////////////////////////
// CPropPageVarSeed dialog

interface IDMUSProdPropPageObject;
interface IDMUSProdPropSheet;

class CPropPageVarSeed : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageVarSeed)

// Construction
public:
	CPropPageVarSeed();
	~CPropPageVarSeed();

// Dialog Data
	//{{AFX_DATA(CPropPageVarSeed)
	enum { IDD = IDD_PROPPAGE_STYLE_SEED };
	CButton	m_checkEnableSeed;
	CButton	m_btnNewSeed;
	CButton	m_btnEditSeed;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageVarSeed)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageVarSeed)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckEnableSeed();
	afx_msg void OnButtonEditSeed();
	afx_msg void OnButtonNewSeed();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	BOOL						m_fSeedVariationsEnabled;
	DWORD						m_dwVariationSeed;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEVARSEED_H__CF76B035_AF34_4CC1_99E9_A5753AFFCF0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by StyleRefStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_STYLE_REF          101
#define IDR_STYLE_REFMGR                102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDD_STYLE_REF_PROPPAGE          105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_FILE_OPEN_STYLE             108
#define IDS_FILE_OPEN_ANY_STYLE         109
#define IDS_MULTIPLE_SELECT             110
#define IDS_CHANGE                      111
#define IDS_TRACK_GROUP                 112
#define IDS_UNDO_MOVE                   113
#define IDS_CHANGE_NAME                 114
#define IDS_CHANGE_LINK                 115
#define IDS_EMPTY_TEXT                  116
#define IDS_STYLES_TEXT                 117
#define IDS_REPLACE                     118
#define IDS_ERR_SEED_ZERO               119
#define IDS_ENABLE_VARIATION_SEED       120
#define IDS_DISABLE_VARIATION_SEED      121
#define IDS_CHANGE_VARIATION_SEED       122
#define IDD_EDIT_VARIATION_SEED         213
#define IDD_PROPPAGE_STYLE_SEED         214
#define IDD_PROPPAGE_STYLE_GROUP        216
#define IDC_EDIT_MEASURE                224
#define IDC_SPIN_MEASURE                229
#define IDC_COMBO_GROUP_LIST            231
#define IDC_COMBO_STYLES                232
#define IDC_CHECK_ENABLE_SEED           233
#define IDC_BUTTON_NEW_SEED             234
#define IDC_BUTTON_EDIT_SEED            235
#define IDC_EDIT_VARIATION_SEED         236
#define IDM_DRAG_RMENU                  243
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         237
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropStyleRef.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "PropStyleRef.h"
#include "StyleRefIO.h"

CPropStyleRef::CPropStyleRef()
{
	m_dwMeasure = 0;
	m_dwBits = 0;

	m_StyleListInfo.pIProject = NULL;
	m_StyleListInfo.strProjectName.LoadString( IDS_EMPTY_TEXT );
	m_StyleListInfo.strName.LoadString( IDS_EMPTY_TEXT );
	m_StyleListInfo.strDescriptor.LoadString( IDS_EMPTY_TEXT );

	m_pIStyleDocRootNode = NULL;

	m_TimeSignature.mtTime = 0;
	m_TimeSignature.bBeatsPerMeasure = 4;
	m_TimeSignature.bBeat = 4;
	m_TimeSignature.wGridsPerBeat = 4;
	
	memset( &m_guidProject, 0, sizeof( m_guidProject ) );
}

CPropStyleRef::CPropStyleRef(const CStyleRefItem *pStyleRefItem)
{
	ASSERT( pStyleRefItem != NULL );

	m_dwMeasure = pStyleRefItem->m_dwMeasure;
	m_dwBits = 0;

	m_StyleListInfo.pIProject = pStyleRefItem->m_StyleListInfo.pIProject;
	m_StyleListInfo.strProjectName = pStyleRefItem->m_StyleListInfo.strProjectName;
	m_StyleListInfo.strName = pStyleRefItem->m_StyleListInfo.strName;
	m_StyleListInfo.strDescriptor = pStyleRefItem->m_StyleListInfo.strDescriptor;

	m_pIStyleDocRootNode = pStyleRefItem->m_pIStyleDocRootNode;
	if( m_pIStyleDocRootNode )
	{
		m_pIStyleDocRootNode->AddRef();
	}

	m_guidProject = pStyleRefItem->m_guidProject;
}

CPropStyleRef::~CPropStyleRef( ) 
{ 
	if( m_pIStyleDocRootNode )
	{
		m_pIStyleDocRootNode->Release(); 
		m_pIStyleDocRootNode = NULL; 
	}
}

void CPropStyleRef::ApplyToStyleRefItem( CStyleRefItem *pStyleRefItem )
{
	ASSERT( pStyleRefItem != NULL );
	if ( pStyleRefItem == NULL )
	{
		return;
	}

	pStyleRefItem->m_dwMeasure = m_dwMeasure;

	pStyleRefItem->m_StyleListInfo.pIProject = m_StyleListInfo.pIProject;
	pStyleRefItem->m_StyleListInfo.strProjectName = m_StyleListInfo.strProjectName;
	pStyleRefItem->m_StyleListInfo.strName = m_StyleListInfo.strName;
	pStyleRefItem->m_StyleListInfo.strDescriptor = m_StyleListInfo.strDescriptor;

	if( pStyleRefItem->m_pIStyleDocRootNode )
	{
		pStyleRefItem->m_pIStyleDocRootNode->Release();
	}
	pStyleRefItem->m_pIStyleDocRootNode = m_pIStyleDocRootNode;
	if( pStyleRefItem->m_pIStyleDocRootNode )
	{
		pStyleRefItem->m_pIStyleDocRootNode->AddRef();
	}

	pStyleRefItem->m_guidProject = m_guidProject;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\PropStyleRef.h ===
#ifndef __PROPSTYLE_REF_H_
#define __PROPSTYLE_REF_H_

#include <DMUSProd.h>
#include <dmusici.h>

#pragma pack(2)

typedef struct StyleListInfo
{
	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} StyleListInfo;

#pragma pack()

class CStyleRefItem;

class CPropStyleRef 
{
public:
	CPropStyleRef();
	CPropStyleRef( const CStyleRefItem *pStyleRefItem );
	~CPropStyleRef(); 
	void ApplyToStyleRefItem( CStyleRefItem *pStyleRefItem );

    DWORD				m_dwMeasure;		// What measure this style reference falls on
	DWORD				m_dwBits;			// Various bits
	StyleListInfo		m_StyleListInfo;
	GUID				m_guidProject;
	IDMUSProdNode*		m_pIStyleDocRootNode;
	DMUS_TIMESIGNATURE	m_TimeSignature;
};

#define UD_DRAGSELECT		0x0001
#define UD_CURRENTSELECTION 0x0002

#endif // __PROPSTYLE_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StyleRefIO.h ===
#ifndef __STYLE_REFIO_H_
#define __STYLE_REFIO_H_

#include "PropStyleRef.h"
#include <dmusici.h>

class CStyleRefMgr;

#define DMUS_FOURCC_STYLE_REF_DESIGN_CHUNK mmioFOURCC('p','s','r','d')

typedef struct _DMUS_IO_STYLE_REF_DESIGN
{
	DWORD		dwVariationSeed;
	BOOL		fVariationSeedActive;
} DMUS_IO_STYLE_REF_DESIGN;

class CStyleRefItem : public CPropStyleRef
{
public:
	CStyleRefItem( CStyleRefMgr* pStyleRefMgr );
	~CStyleRefItem();

	BOOL After(const CStyleRefItem& StyleRef);
	BOOL Before(const CStyleRefItem& StyleRef);
	void SetSelectFlag( BOOL fSelected );

	CStyleRefMgr*	m_pStyleRefMgr;

//	Used to track the selection of the style reference in display.
	BOOL		 m_fSelected;		// This style reference is currently selected.
	BOOL		 m_fRemoveNotify;
};

#endif // __STYLE_REFIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StyleRefIO.cpp ===
#include "stdafx.h"
#include "StyleRefIO.h"
#include "StyleRefStripMgr.h"
#include "StyleRefMgr.h"


CStyleRefItem::CStyleRefItem( CStyleRefMgr* pStyleRefMgr )
{
	ASSERT( pStyleRefMgr != NULL );
	m_pStyleRefMgr = pStyleRefMgr;

	m_fSelected = FALSE;
	m_fRemoveNotify = FALSE;
}

CStyleRefItem::~CStyleRefItem()
{
	// Turn off notifications for this node
	if( m_pIStyleDocRootNode )
	{
		if( m_fRemoveNotify )
		{
			if( m_pStyleRefMgr
			&&  m_pStyleRefMgr->m_pISegmentNode 
			&&  m_pStyleRefMgr->m_pDMProdFramework )
			{
				m_pStyleRefMgr->m_pDMProdFramework->RemoveFromNotifyList( m_pIStyleDocRootNode,
																		  m_pStyleRefMgr->m_pISegmentNode );
			}
		}
	}
}

BOOL CStyleRefItem::After(const CStyleRefItem& StyleRef)
{
	if( m_dwMeasure > StyleRef.m_dwMeasure )
	{
		return TRUE;
	}
	/*
	else if( m_dwMeasure == StyleRef.m_dwMeasure )
	{
	}
	*/
	return FALSE;
}

BOOL CStyleRefItem::Before(const CStyleRefItem& StyleRef)
{
	if( m_dwMeasure < StyleRef.m_dwMeasure )
	{
		return TRUE;
	}
	/*
	else if( m_dwMeasure == StyleRef.m_dwMeasure )
	{
	}
	*/
	return FALSE;
}
	
void CStyleRefItem::SetSelectFlag( BOOL fSelected )
{
	m_fSelected = fSelected;
	m_dwBits = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StyleRefMgr.cpp ===
// StyleRefMgr.cpp : implementation file
//

/*--------------
@doc STYLE_REFSAMPLE
--------------*/

#include "stdafx.h"
#include "StyleRefIO.h"
#include "StyleRefStripMgr.h"
#include "StyleRefMgr.h"
#include "timeline.h"
#include "DLLJazzDataObject.h"
#include "PropPageMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <mmreg.h>
#include <StyleDesigner.h>
#include <SegmentDesigner.h>
#include <RiffStrm.h>
#include <initguid.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INVALID_MEASURE 0xFFFFFFFF

inline MUSIC_TIME ClocksPerBeat(DMUS_TIMESIGNATURE& TimeSig)
{ return DMUS_PPQ * 4 / TimeSig.bBeat; }

inline MUSIC_TIME ClocksPerMeasure(DMUS_TIMESIGNATURE& TimeSig)
{ return ClocksPerBeat(TimeSig) * TimeSig.bBeatsPerMeasure; }

inline DWORD ClocksToMeasure(DWORD dwTotalClocks, DMUS_TIMESIGNATURE& TimeSig)
{ return (dwTotalClocks / ClocksPerMeasure(TimeSig)); }

POSITION GetFirstValidStyleRef(POSITION pos, const CTypedPtrList<CPtrList, CStyleRefItem*> &lstStyleRefs )
{
	CStyleRefItem* pItem;
	POSITION posToReturn;
	while( pos )
	{
		posToReturn = pos;
		pItem = lstStyleRefs.GetNext( pos );
		if( pItem->m_pIStyleDocRootNode )
		{
			return posToReturn;
		}
	}
	return NULL;
}

void CStyleRefMgr::ClocksToMeasure(MUSIC_TIME mtTime, DWORD& rdwMeasure)
{
	//ASSERT( mtTime >= 0 );
	if( mtTime <= 0 )
	{
		rdwMeasure = 0;
		return;
	}

	DMUS_TIMESIGNATURE TimeSignature;

	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );
	if( !pos )
	{
		// Default to 4/4, since this is what the Timeline defaults to
		TimeSignature.bBeatsPerMeasure = 4;
		TimeSignature.bBeat = 4;
		rdwMeasure = ::ClocksToMeasure(mtTime, TimeSignature);
		return;
	}

	CStyleRefItem* pStyleRefItem = NULL;
	MUSIC_TIME mtSRTime = 0;
	DWORD dwCurrentMeasure = 0;

	// Initialize TimeSignature with the TimeSig of the first valid item
	pStyleRefItem = m_lstStyleRefs.GetAt( pos );
	TimeSignature = pStyleRefItem->m_TimeSignature;

	while( pos )
	{
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );

		// This should be a real StyleRef
		ASSERT( !pStyleRefItem->m_StyleListInfo.strName.IsEmpty() );

		MUSIC_TIME mtMeasureClocks = ClocksPerMeasure(TimeSignature);
		long lNumMeasures = pStyleRefItem->m_dwMeasure - dwCurrentMeasure;
		if (mtSRTime + mtMeasureClocks * lNumMeasures > mtTime)
		{
			break;
		}
		else
		{
			mtSRTime += mtMeasureClocks * lNumMeasures;
			dwCurrentMeasure = pStyleRefItem->m_dwMeasure;
			TimeSignature = pStyleRefItem->m_TimeSignature;
		}

		// Get the next valid StyleRef
		pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );
	}

	mtTime -= mtSRTime;
	rdwMeasure = dwCurrentMeasure + ::ClocksToMeasure(mtTime, TimeSignature);
}

MUSIC_TIME CStyleRefMgr::MeasureToClocks(DWORD dwMeasure)
{ 
	DMUS_TIMESIGNATURE TimeSignature;

	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );
	if( !pos )
	{
		// Default to 4/4, since this is what the Timeline defaults to
		TimeSignature.bBeatsPerMeasure = 4;
		TimeSignature.bBeat = 4;
		return ClocksPerMeasure(TimeSignature) * (MUSIC_TIME) dwMeasure; 
	}

	CStyleRefItem* pStyleRefItem = NULL;
	MUSIC_TIME mtSRTime = 0;
	DWORD dwCurrentMeasure = 0;

	// Initialize TimeSignature with the TimeSig of the first valid item
	pStyleRefItem = m_lstStyleRefs.GetAt( pos );
	TimeSignature = pStyleRefItem->m_TimeSignature;

	while( pos )
	{
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );

		// This should be a real StyleRef
		ASSERT( !pStyleRefItem->m_StyleListInfo.strName.IsEmpty() );

		if( pStyleRefItem->m_dwMeasure <= dwMeasure)
		{
			mtSRTime += ClocksPerMeasure(TimeSignature) * 
				(MUSIC_TIME) (pStyleRefItem->m_dwMeasure - dwCurrentMeasure);
			dwCurrentMeasure = pStyleRefItem->m_dwMeasure;
			TimeSignature = pStyleRefItem->m_TimeSignature;
		}
		else break;

		// Get the next valid StyleRef
		pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );
	}
	return 
		mtSRTime + 
		ClocksPerMeasure(TimeSignature) * (MUSIC_TIME) (dwMeasure - dwCurrentMeasure);
}

////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr constructor/destructor 

CStyleRefMgr::CStyleRefMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pPropertyPage = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pStyleRefStrip = NULL;
	m_pIDMTrack = NULL;
	m_pISegmentNode = NULL;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to Group 1
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;

	// Initialize the track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	// By default, don't activate the variation seed
	m_fVariationSeedActive = FALSE;
	m_dwVariationSeed = 1;

	// Create a strip
	m_pStyleRefStrip = new CStyleRefStrip(this);
	ASSERT( m_pStyleRefStrip );
}

CStyleRefMgr::~CStyleRefMgr()
{
	// Delete all the style references in m_lstStyleRefs
	EmptyStyleRefList();

	// Clean up our references
	if( m_pStyleRefStrip )
	{
		m_pStyleRefStrip->Release();
		m_pStyleRefStrip = NULL;
	}

	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pPropertyPage == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
	}
	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr IStyleRefMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::IsMeasureBeatOpen

HRESULT STDMETHODCALLTYPE CStyleRefMgr::IsMeasureOpen( DWORD dwMeasure )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get maximum number of measures
	long lMaxMeasure;
	VARIANT var;
	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits,
									  0,
									   V_I4( &var ),
									  &lMaxMeasure,
									  NULL );
	// Ensure lMaxMeasure is at least 1
	lMaxMeasure = max( 1, lMaxMeasure );

	if( dwMeasure >= (unsigned)lMaxMeasure )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	CStyleRefItem* pStyleRefItem;
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if( pStyleRefItem->m_dwMeasure > dwMeasure )
		{
			pos = NULL;
		}
		else if( pStyleRefItem->m_pIStyleDocRootNode && (pStyleRefItem->m_dwMeasure == dwMeasure) ) // Styles must be on a measure boundary
		{
			hr = S_FALSE;
			pos = NULL;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::GetParam

HRESULT STDMETHODCALLTYPE CStyleRefMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID(guidType, GUID_TimeSignature) ||
	    ::IsEqualGUID(guidType, GUID_StyleNode) ||
		::IsEqualGUID(guidType, GUID_IDirectMusicStyle) )
	{
		if( ::IsEqualGUID( guidType, GUID_TimeSignature) )
		{
			// This is wrong - if we don't have any valid StyleRefs, we return an error code (not a default value)
			//*(DMUS_TIMESIGNATURE*) pData = m_DefaultTimeSignature;
		}
		else if( ::IsEqualGUID( guidType, GUID_StyleNode) )
		{
			*(IDMUSProdNode**) pData = NULL;
		}
		else
		{
			*(IDirectMusicStyle**) pData = NULL;
		}

		// Initialize pmtNext
		if( pmtNext )
		{
			*pmtNext = 0;
		}

		// Search through StyleRef list for first valid time signature
		CStyleRefItem* pItem = NULL;
		POSITION pos = m_lstStyleRefs.GetHeadPosition();
		pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );

		if( !pos )
		{
			// No valid StyleRefs in this track.
			return DMUS_E_NOT_FOUND;
		}

		// Initialize Previous StyleRef Item
		CStyleRefItem* pPrevious = m_lstStyleRefs.GetAt( pos );

		// Search through StyleRef list for valid StyleRefs
		MUSIC_TIME mtSRTime = 0;
		while( pos )
		{
			pItem = m_lstStyleRefs.GetNext( pos );
			ASSERT( pItem->m_pIStyleDocRootNode );

			mtSRTime = MeasureToClocks( pItem->m_dwMeasure );
			if( mtTime < mtSRTime )
			{
				// Set next	
				if( pmtNext )
				{
					*pmtNext = MeasureToClocks( pItem->m_dwMeasure ) - mtTime;
				}
				break;
			}

			pPrevious = pItem;

			// Get the next valid StyleRef
			pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );
		}

		// We should have found a valid TimeSig
		ASSERT( pPrevious );

		if( ::IsEqualGUID( guidType, GUID_TimeSignature) )
		{
			*(DMUS_TIMESIGNATURE*) pData = pPrevious->m_TimeSignature;
		}
		else if( ::IsEqualGUID( guidType, GUID_StyleNode) )
		{
			IDMUSProdNode *pIStyleNode = pPrevious->m_pIStyleDocRootNode;
			pIStyleNode->AddRef();

			*(IDMUSProdNode**) pData = pIStyleNode;
		}
		else
		{
			IDirectMusicStyle *pIDMStyle = NULL;
			pPrevious->m_pIStyleDocRootNode->GetObject( CLSID_DirectMusicStyle,
													IID_IDirectMusicStyle,
													(void**)&pIDMStyle );

			*(IDirectMusicStyle**) pData = pIDMStyle;
		}

		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pISegmentNode;
		if( m_pISegmentNode )
		{
			m_pISegmentNode->AddRef();
		}
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pStyleRefStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		DMUSProdReferencedNodes *pDMUSProdReferencedNodes = (DMUSProdReferencedNodes *)pData;

		// Search through StyleRef list for first valid time signature
		POSITION pos = m_lstStyleRefs.GetHeadPosition();
		pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );

		if( !pos )
		{
			// No valid StyleRefs in this track.
			pDMUSProdReferencedNodes->dwArraySize = 0;
			return S_OK;
		}

		DWORD dwIndex = 0;

		// Search through StyleRef list for valid StyleRefs
		while( pos )
		{
			CStyleRefItem* pItem = m_lstStyleRefs.GetNext( pos );
			ASSERT( pItem->m_pIStyleDocRootNode );

			if( pDMUSProdReferencedNodes->apIDMUSProdNode
			&&	pDMUSProdReferencedNodes->dwArraySize > dwIndex )
			{
				pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex] = pItem->m_pIStyleDocRootNode;
				pDMUSProdReferencedNodes->apIDMUSProdNode[dwIndex]->AddRef();
			}

			// Get the next valid StyleRef
			pos = GetFirstValidStyleRef( pos, m_lstStyleRefs );
			dwIndex++;
		}

		HRESULT hr = pDMUSProdReferencedNodes->apIDMUSProdNode && (pDMUSProdReferencedNodes->dwArraySize < dwIndex) ? S_FALSE : S_OK;

		// Store the number of nodes we returned (or that we require)
		pDMUSProdReferencedNodes->dwArraySize = dwIndex;

		return hr;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SetParam

HRESULT STDMETHODCALLTYPE CStyleRefMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pISegmentNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::IsParamSupported

// support GUID_TimeSignature for maintaining the time signature
// support GUID_DocRootNode for maintaining pointer to DocRoot node
HRESULT STDMETHODCALLTYPE CStyleRefMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	if( ::IsEqualGUID( guidType, GUID_TimeSignature ) 
	||  ::IsEqualGUID( guidType, GUID_DocRootNode )
	||  ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) 
	||  ::IsEqualGUID( guidType, GUID_StyleNode )
	||	::IsEqualGUID( guidType, GUID_IDirectMusicStyle )
	||	::IsEqualGUID( guidType, GUID_Segment_ReferencedNodes ) )
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CStyleRefMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStyleRefStrip != NULL );

	if( (m_pStyleRefStrip == NULL) 
	|| !(dwGroupBits & m_dwGroupBits) )
	{
		return E_FAIL;
	}

	HRESULT hr = E_INVALIDARG;

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Make sure host has latest version of data
		// May have changed during load if user prompted to choose Style from File Open dialog
		if( m_fDirty )
		{
			OnDataChanged();
			m_fDirty = FALSE;
		}
		return S_OK;
	}

	// Track deleted
	if( ::IsEqualGUID( rguidType, GUID_Segment_DeletedTrack ) )
	{
		// Notify other StripMgrs that we're removing a Style track, and that the
		// time signature may have changed
		IDMUSProdTimeline *pTimeline = (IDMUSProdTimeline *)pData;
		if( pTimeline )
		{
			pTimeline->NotifyStripMgrs( GUID_IDirectMusicStyle, dwGroupBits, NULL );
			pTimeline->NotifyStripMgrs( GUID_TimeSignature, dwGroupBits, NULL );
		}
		return S_OK;
	}

	// Track created
	if( ::IsEqualGUID( rguidType, GUID_Segment_CreateTrack ) )
	{
		// Notify other StripMgrs that we're creating a Style track, and that the
		// time signature may have changed
		if( m_pTimeline )
		{
			m_pTimeline->NotifyStripMgrs( GUID_IDirectMusicStyle, dwGroupBits, NULL );
			m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, dwGroupBits, NULL );
		}
		return S_OK;
	}

	// Framework message
	if( ::IsEqualGUID(rguidType, GUID_Segment_FrameworkMsg) )
	{
		DMUSProdFrameworkMsg* pFrameworkMsg =  (DMUSProdFrameworkMsg *)pData;
		ASSERT( pFrameworkMsg != NULL );

		IDMUSProdNode* pINode = NULL;

		if( pFrameworkMsg->punkIDMUSProdNode )
		{
			if( FAILED ( pFrameworkMsg->punkIDMUSProdNode->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
			{
				pINode = NULL;
			}
		}

		if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted)  
		||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileClosed) )
		{
			hr = E_FAIL;

			if( pINode)
			{
				// Find which Style changed
				POSITION pos = m_lstStyleRefs.GetHeadPosition();
				while( pos )
				{
					CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

					if( pStyleRefItem
					&&  pStyleRefItem->m_pIStyleDocRootNode == pINode )
					{
						// This Style was removed from the Project Tree
						SetStyleReference( NULL, pStyleRefItem );

						// Set undo text resource id
						if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileDeleted) )
						{
							m_pStyleRefStrip->m_nLastEdit = IDS_DELETE;
							hr = S_OK;
						}
						else
						{
							hr = S_FALSE;
						}
					}
				}
				if( m_pTimeline )
				{
					m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_dwGroupBits, NULL );
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileReplaced) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which Style changed
				POSITION pos = m_lstStyleRefs.GetHeadPosition();
				while( pos )
				{
					CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

					if( pStyleRefItem
					&&  pStyleRefItem->m_pIStyleDocRootNode == pINode )
					{
						// This Style was replaced in the Project Tree, set to new Style pointer
						SetStyleReference( (IDMUSProdNode *)pFrameworkMsg->pData, pStyleRefItem );

						// This Style may have a new time signature
						IDMUSProdStyleInfo* pIStyleInfo;
						if( SUCCEEDED ( pStyleRefItem->m_pIStyleDocRootNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
						{
							DMUSProdTimeSignature timeSig;
							pIStyleInfo->GetTimeSignature( &timeSig ); 

							pStyleRefItem->m_TimeSignature.bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
							pStyleRefItem->m_TimeSignature.bBeat = timeSig.bBeat;
							pStyleRefItem->m_TimeSignature.wGridsPerBeat = timeSig.wGridsPerBeat;

							pIStyleInfo->Release();
						}

						m_pStyleRefStrip->m_nLastEdit = IDS_REPLACE;
						hr = S_OK;
					}
				}
				if( m_pTimeline )
				{
					m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_dwGroupBits, NULL );
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, DOCROOT_GuidChange) 
			 ||  ::IsEqualGUID(pFrameworkMsg->guidUpdateType, FRAMEWORK_FileNameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which Style changed
				POSITION pos = m_lstStyleRefs.GetHeadPosition();
				while( pos )
				{
					CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

					if( pStyleRefItem
					&&  pStyleRefItem->m_pIStyleDocRootNode == pINode )
					{
						// Set undo text resource id
						m_pStyleRefStrip->m_nLastEdit = IDS_CHANGE_LINK;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_PChannelChange) ) 
		{
			SyncWithDirectMusic();
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_NameChange) ) 
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which Style changed
				POSITION pos = m_lstStyleRefs.GetHeadPosition();
				while( pos )
				{
					CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

					if( pStyleRefItem
					&&  pStyleRefItem->m_pIStyleDocRootNode == pINode )
					{
						// This Style was renamed
						DMUSProdListInfo ListInfo;
						ZeroMemory( &ListInfo, sizeof(ListInfo) );
						ListInfo.wSize = sizeof(ListInfo);

						if( SUCCEEDED ( pStyleRefItem->m_pIStyleDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
						{
							IDMUSProdProject* pIProject;

							if( ListInfo.bstrName )
							{
								pStyleRefItem->m_StyleListInfo.strName = ListInfo.bstrName;
								::SysFreeString( ListInfo.bstrName );
							}
							if( ListInfo.bstrDescriptor )
							{
								pStyleRefItem->m_StyleListInfo.strDescriptor = ListInfo.bstrDescriptor;
								::SysFreeString( ListInfo.bstrDescriptor );
							}
							if( SUCCEEDED ( m_pDMProdFramework->FindProject( pStyleRefItem->m_pIStyleDocRootNode, &pIProject ) ) )
							{
								BSTR bstrProjectName;

								pStyleRefItem->m_StyleListInfo.pIProject = pIProject;
	//							pStyleRefItem->m_StyleListInfo.pIProject->AddRef();		intentionally missing

								if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
								{
									pStyleRefItem->m_StyleListInfo.strProjectName = bstrProjectName;
									::SysFreeString( bstrProjectName );
								}

								pIProject->Release();
							}
						}

						// Update DocRoot file GUID
						m_pDMProdFramework->GetNodeFileGUID ( pStyleRefItem->m_pIStyleDocRootNode, &pStyleRefItem->m_StyleListInfo.guidFile );

						// Set undo text resource id
						m_pStyleRefStrip->m_nLastEdit = IDS_CHANGE_NAME;
						hr = S_OK;
					}
				}
			}
		}

		else if( ::IsEqualGUID(pFrameworkMsg->guidUpdateType, STYLE_TimeSigChange) )
		{
			hr = E_FAIL;

			if( pINode )
			{
				// Find which Style changed
				POSITION pos = m_lstStyleRefs.GetHeadPosition();
				while( pos )
				{
					CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

					if( pStyleRefItem
					&&  pStyleRefItem->m_pIStyleDocRootNode == pINode )
					{
						// This Style has a new time signature
						IDMUSProdStyleInfo* pIStyleInfo;
						if( SUCCEEDED ( pStyleRefItem->m_pIStyleDocRootNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
						{
							DMUSProdTimeSignature timeSig;
							pIStyleInfo->GetTimeSignature( &timeSig ); 

							pStyleRefItem->m_TimeSignature.bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
							pStyleRefItem->m_TimeSignature.bBeat = timeSig.bBeat;
							pStyleRefItem->m_TimeSignature.wGridsPerBeat = timeSig.wGridsPerBeat;

							pIStyleInfo->Release();
						}

						hr = S_FALSE;
					}
				}
				if( m_pTimeline )
				{
					m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_dwGroupBits, NULL );
				}
			}
		}

		if( pINode )
		{
			pINode->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Let our hosting editor know about the changes
		if( hr == S_OK )
		{
			OnDataChanged();
		}

		if( m_pTimeline )
		{
			m_pTimeline->StripInvalidateRect( m_pStyleRefStrip, NULL, TRUE );
		}

		// Update the property page
		if( m_pPropPageMgr != NULL )
		{
			m_pPropPageMgr->RefreshData();
		}

		SyncWithDirectMusic();
		m_fDirty = TRUE;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CStyleRefMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicStyleTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = NULL;
			pioTrackHeader->fccType = DMUS_FOURCC_STYLE_TRACK_LIST;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CStyleRefMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if ( m_pStyleRefStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pStyleRefStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pStyleRefStrip );
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwOldGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pStyleRefStrip, CLSID_DirectMusicStyleTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_FrameworkMsg, m_dwGroupBits);
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::GetClassID

HRESULT CStyleRefMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_StyleRefMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::IsDirty

HRESULT CStyleRefMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::Load

HRESULT CStyleRefMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing style references
	EmptyStyleRefList();

	m_strLastStyleName.Empty();

	// Clear variation seed info.
	m_fVariationSeedActive = FALSE;
	m_dwVariationSeed = 1;

	// Load the Track
	MMCKINFO ck;
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_STYLE_TRACK_LIST: // StyleRef List
						BOOL fChanged;
						LoadStyleRefList(pIRiffStream, &ck, FALSE, 0, fChanged);
						pIRiffStream->Ascend( &ck, 0 );
						hr = S_OK;
						break;
				}
				break;

			case DMUS_FOURCC_STYLE_REF_DESIGN_CHUNK:
				LoadStyleRefDesign( pIStream, &ck );
				break;

		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	m_strLastStyleName.Empty();

	pIRiffStream->Release();

	SyncWithDirectMusic();

	return hr;
}


HRESULT CStyleRefMgr::LoadStyleRefList( IDMUSProdRIFFStream* pIRiffStream,
										MMCKINFO* pckParent,
										BOOL fPaste,
										MUSIC_TIME mtPasteTime,
										BOOL &fChanged )
{
	MMCKINFO ckMain;
	MMCKINFO ck;
	HRESULT hr = S_OK;

	if( pIRiffStream == NULL )
	{
		return E_INVALIDARG;
	}
	
	IStream* pIStream = pIRiffStream->GetStream();
	if( pIStream == NULL )
	{
		return E_FAIL;
	}

	if( fPaste )
	{
		DWORD dwCurrentFilePos = StreamTell( pIStream );

		MUSIC_TIME mtAdjustment = 0;;

		ASSERT( m_pTimeline != NULL );
		if( m_pTimeline )
		{
			// Get Timeline length
			VARIANT var;
			m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
			MUSIC_TIME mtMaxTimelineLength = V_I4( &var );

			// Determine new paste time to enforce boundaries
			while ( pIRiffStream->Descend( &ckMain, pckParent, 0 ) == 0  )
			{
				if( ckMain.ckid == FOURCC_LIST
				&&  ckMain.fccType == DMUS_FOURCC_STYLE_REF_LIST )
				{

					while( pIRiffStream->Descend( &ck, &ckMain, 0 ) == 0 )
					{
						switch( ck.ckid )
						{
							case DMUS_FOURCC_TIME_STAMP_CHUNK:
							{
								DWORD dwTime;
								DWORD cb;
								hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
								if (FAILED(hr) || cb != sizeof( dwTime ) ) 
								{
									if (SUCCEEDED(hr)) hr = E_FAIL;
									pIRiffStream->Ascend( &ck, 0 );
									goto ON_END;
								}

								MUSIC_TIME mtTime = dwTime;
								mtTime += mtPasteTime;
								if( mtTime < 0 )
								{
									mtTime = 0 - mtTime;
									if( mtTime > mtAdjustment )
									{
										mtAdjustment = mtTime;
									}
								}
								else if( mtTime >= mtMaxTimelineLength )
								{
									mtTime = mtMaxTimelineLength - mtTime;
									if( mtTime < mtAdjustment )
									{
										mtAdjustment = mtTime - 1;
									}
								}
							}
							break;
						}

						pIRiffStream->Ascend( &ck, 0 );
					}

					pIRiffStream->Ascend( &ckMain, 0 );
				}

				pIRiffStream->Ascend( &ckMain, 0 );
			}
		}

		// New paste time which will enforce strip boundaries
		mtPasteTime += mtAdjustment;

		// Restore our position back to the start of the StyleRefs
		StreamSeek( pIStream, dwCurrentFilePos, STREAM_SEEK_SET );
	}

	while ( pIRiffStream->Descend( &ckMain, pckParent, 0 ) == 0  )
	{
		if( ckMain.ckid == FOURCC_LIST
		&&  ckMain.fccType == DMUS_FOURCC_STYLE_REF_LIST )
		{
			if( SUCCEEDED( LoadStyleRef(pIRiffStream, &ckMain, fPaste, mtPasteTime) ) )
			{
				fChanged = TRUE;
			}
			pIRiffStream->Ascend( &ckMain, 0 );
		}

		pIRiffStream->Ascend( &ckMain, 0 );
	}

	// If there are existing StyleRefs, we're not pasting, and there
	// are no valid StyleRefs, update all existing StyleRefs using a TimeSig of 4/4.
	if( !m_lstStyleRefs.IsEmpty() && !fPaste &&
		!GetFirstValidStyleRef( m_lstStyleRefs.GetHeadPosition(), m_lstStyleRefs ) )
	{
		long lMeasureClocks = DMUS_PPQ * 4; // 4 quarter note beats
		POSITION pos = m_lstStyleRefs.GetHeadPosition();
		while( pos )
		{
			CStyleRefItem* pTmpItem = m_lstStyleRefs.GetNext( pos );
			pTmpItem->m_dwMeasure = pTmpItem->m_dwMeasure / lMeasureClocks;
		}
	}

ON_END:
	pIStream->Release();
	return hr;
}

HRESULT CStyleRefMgr::LoadStyleRef( IDMUSProdRIFFStream* pIRiffStream, 
									MMCKINFO* pckParent,
									BOOL fPaste,
									MUSIC_TIME mtPasteTime )
{
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwCurrentFilePos;
	IDMUSProdNode* pIDocRoot = NULL;
	CString strStyleName;
	MUSIC_TIME mtTime = 0;

	if( pIRiffStream == NULL
	||  pckParent == NULL )
	{
		return E_INVALIDARG;
	}
	
	IStream* pIStream = pIRiffStream->GetStream();
	if( pIStream == NULL )
	{
		return E_FAIL;
	}

	CStyleRefItem* pItem = new CStyleRefItem( this );
	if( pItem == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto ON_END;
	}

	dwCurrentFilePos = StreamTell( pIStream );


	while( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case DMUS_FOURCC_TIME_STAMP_CHUNK:
			{
				DWORD dwTime;
				DWORD cb;
				hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
				if (FAILED(hr) || cb != sizeof( dwTime ) ) 
				{
					if (SUCCEEDED(hr)) hr = E_FAIL;
					pIRiffStream->Ascend( &ck, 0 );
					goto ON_END;
				}

				mtTime = dwTime;
				if( fPaste )
				{
					mtTime += mtPasteTime;
				}
			}
			break;

		case FOURCC_DMUSPROD_FILEREF:
		{
			IDMUSProdFileRefChunk* pIFileRef;

			hr = m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
			if( FAILED ( hr ) )
			{
				goto ON_END;
			}
			StreamSeek( pIStream, dwCurrentFilePos, 0 );
			pIFileRef->LoadRefChunk( pIStream, &pIDocRoot );
			pIFileRef->Release();
			break;
		}

		case FOURCC_LIST:
			if( ck.fccType == DMUS_FOURCC_REF_LIST )
			{
				MMCKINFO ckName;

				ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
				if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
				{
					// Store Style name
					ReadMBSfromWCS( pIStream, ckName.cksize, &strStyleName );
				}
			}
			break;
		}

		pIRiffStream->Ascend( &ck, 0 );
		dwCurrentFilePos = StreamTell( pIStream );
	}

	if( pIDocRoot == NULL )
	{
		// Do we have a Style name?
		if( !strStyleName.IsEmpty() )
		{
			// Framework could not resolve Style file reference
			// so we will ask user to help
			pIDocRoot = FindStyle( strStyleName, pIStream );
		}
	}

	if( pIDocRoot )
	{
		hr = SetStyleReference( pIDocRoot, pItem );
		pIDocRoot->Release();

		if( FAILED ( hr ) )
		{
			goto ON_END;
		}
	}

	// Set the measure this StyleRef belongs to
	if( !GetFirstValidStyleRef( m_lstStyleRefs.GetHeadPosition(), m_lstStyleRefs ) )
	{
		// If no valid StyleRefs, we need to use the TimeSig of this item to compute the measure #
		if( pIDocRoot )
		{
			// m_TimeSignature is only valid if pIDocRoot is non-NULL
			pItem->m_dwMeasure = mtTime / ClocksPerMeasure( pItem->m_TimeSignature );
		}
		else
		{
			// If return value is S_FALSE, we're using m_dwMeasure to store the item's time
			pItem->m_dwMeasure = mtTime;
			hr = S_FALSE;
		}
	}
	else
	{
		// Have valid StyleRefs, can use ClocksToMeasure
		ClocksToMeasure( mtTime, (DWORD&)pItem->m_dwMeasure );
	}
	ASSERT( pItem->m_dwMeasure >= 0 );

ON_END:
	if( FAILED ( hr ) )
	{
		if( pItem )
		{
			delete pItem;
		}
	}
	else
	{
		if( pItem->m_dwMeasure == INVALID_MEASURE )
		{
			delete pItem;
		}
		else
		{
			// If there are existing StyleRefs, we're not pasting, we have a valid StyleRef, and there
			// are no valid StyleRefs, update all existing StyleRefs using the TimeSig of this item.
			if( !m_lstStyleRefs.IsEmpty() && !fPaste && pIDocRoot &&
				!GetFirstValidStyleRef( m_lstStyleRefs.GetHeadPosition(), m_lstStyleRefs ) )
			{
				long lMeasureClocks = ClocksPerMeasure( pItem->m_TimeSignature );
				POSITION pos = m_lstStyleRefs.GetHeadPosition();
				while( pos )
				{
					CStyleRefItem* pTmpItem = m_lstStyleRefs.GetNext( pos );
					pTmpItem->m_dwMeasure = pTmpItem->m_dwMeasure / lMeasureClocks;
				}
			}

			InsertByAscendingTime( pItem );
			if( fPaste )
			{
				pItem->SetSelectFlag( TRUE );
			}
		}
	}

    pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::FindStyle

IDMUSProdNode* CStyleRefMgr::FindStyle( CString strStyleName, IStream* pIStream )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( m_pDMProdFramework != NULL );
	ASSERT( pIStream != NULL );

	// Get DocType for DLS Collections
	hr = m_pDMProdFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use the strip's DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		pITargetDirectoryNode = m_pISegmentNode;
	}

	// See if there is a Style named 'strStyleName' in this Project
	if( !strStyleName.IsEmpty() )
	{
		BSTR bstrStyleName = strStyleName.AllocSysString();

		if( FAILED ( m_pDMProdFramework->GetBestGuessDocRootNode( pIDocType,
										 						  bstrStyleName,
																  pITargetDirectoryNode,
																  &pIDocRootNode ) ) )
		{
			pIDocRootNode = NULL;
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Cannot find the Style
		// If user cancelled previous search for this Style, no need to ask again
		if( strStyleName.CompareNoCase( m_strLastStyleName ) == 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR; 
		}
		m_strLastStyleName = strStyleName;

		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strStyleName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_STYLE );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_STYLE, strStyleName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		if( m_pDMProdFramework->OpenFile(pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode) != S_OK )
		{
			// Did not open a file, or opened file other than Style file
			// so we do not want this DocRoot
			if( pIDocRootNode )
			{
				pIDocRootNode->Release();
				pIDocRootNode = NULL;
			}
		}
	}

	if( pIDocRootNode )
	{
		// Set dirty flag so that GUID_Segment_AllTracksAdded notification will call OnUpdate()
		m_fDirty = TRUE;
	}

ON_ERROR:
	if( pIDocType )
	{
		pIDocType->Release();
	}

	return pIDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SaveDMRef

HRESULT CStyleRefMgr::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
								 IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( m_pDMProdFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  CLSID_DirectMusicStyle,
																  NULL,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SaveProducerRef

HRESULT CStyleRefMgr::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( m_pDMProdFramework != NULL );
	if( m_pDMProdFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( m_pDMProdFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::Save

HRESULT CStyleRefMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(fClearDirty);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper file ref chunk
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}
	if( !(::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ))
	&&  !(::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

    MMCKINFO ckMain;

	// If the StyleRef list isn't empty, save it
	if ( !m_lstStyleRefs.IsEmpty() )
	{
		// Create a LIST chunk to store the StyleRef data
		ckMain.fccType = DMUS_FOURCC_STYLE_TRACK_LIST;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		POSITION pos = m_lstStyleRefs.GetHeadPosition();
		while( pos )
		{
			CStyleRefItem* pStyleRefItem;
			pStyleRefItem = m_lstStyleRefs.GetNext( pos );
			ASSERT( pStyleRefItem );
			if( pStyleRefItem
			&&  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
			{
				// Store each StyleRef in its own chunk.
				SaveStyleReference( pIStream, pIRiffStream, pStyleRefItem, 0 );
				//m_TimeSignature = pStyleRefItem->m_TimeSignature;
			}
		}
		// Ascend out of the StyleRef LIST chunk.
		pIRiffStream->Ascend( &ckMain, 0 );
	}

	if( ftFileType == FT_DESIGN )
	{
		SaveStyleRefDesign( pIStream, pIRiffStream );
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


HRESULT CStyleRefMgr::SaveStyleReference(
			IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream, CStyleRefItem* pStyleRefItem, MUSIC_TIME mtOffset )
{
	HRESULT hr = E_FAIL;

	ASSERT( pStyleRefItem != NULL );

	DMUSProdStreamInfo	StreamInfo;
	FileType ftFileType = FT_DESIGN;	// Default to FT_DESIGN so clipboard
										// gets proper file ref chunk
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pIPersistInfo->Release();
	}
	if( !(::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ))
	&&  !(::IsEqualGUID( guidDataFormat, GUID_CurrentVersion )) )
	{
		// Should not happen!
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Do not save empty style references to the DirectMusic object
	if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) && !pStyleRefItem->m_pIStyleDocRootNode )
	{
		return S_FALSE;
	}

	// Write DMUS_FOURCC_STYLE_REF_LIST header
	MMCKINFO ckStyleList;
	ckStyleList.fccType = DMUS_FOURCC_STYLE_REF_LIST;
	if( FAILED( pIRiffStream->CreateChunk( &ckStyleList, MMIO_CREATELIST ) ) )
	{
		return E_FAIL;
	}

	// Write 'stmp-ck' 
	{
		MMCKINFO ck;
		DWORD dwByteCount;

		ck.ckid = mmioFOURCC('s', 't', 'm', 'p');
		if( FAILED( pIRiffStream->CreateChunk( &ck, 0 ) ) )
		{
			return E_FAIL;
		}

		long lTime = MeasureToClocks( pStyleRefItem->m_dwMeasure );
		DWORD dwTime = lTime - mtOffset;
		hr = pIStream->Write( &dwTime, sizeof(dwTime), &dwByteCount );
		if( FAILED ( hr )
		||  dwByteCount != sizeof(dwTime) )
		{
			return E_FAIL;
		}

		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
			return E_FAIL;
		}
	}

	// Write Reference chunk(s)
	if( pStyleRefItem->m_pIStyleDocRootNode )
	{
		if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
		{
			SaveDMRef( pIRiffStream, pStyleRefItem->m_pIStyleDocRootNode, WL_PRODUCER );
		}
		else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
		{
			SaveDMRef( pIRiffStream, pStyleRefItem->m_pIStyleDocRootNode, WL_DIRECTMUSIC );
			if( ftFileType == FT_DESIGN )
			{
				SaveProducerRef( pIRiffStream, pStyleRefItem->m_pIStyleDocRootNode );
			}
		}
	}
	
	if( pIRiffStream->Ascend( &ckStyleList, 0 ) != 0 )
	{
		return E_FAIL;
	}
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SyncTimeSignatures

HRESULT CStyleRefMgr::SyncTimeSignatures( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CStyleRefItem* pStyleRefItem;

	// Sync timesig info
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );

		// Get Style from selected node
		if( pStyleRefItem->m_pIStyleDocRootNode )
		{
			IDMUSProdStyleInfo* pIStyleInfo;
			if( SUCCEEDED ( pStyleRefItem->m_pIStyleDocRootNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
			{
				DMUSProdTimeSignature timeSig;
				pIStyleInfo->GetTimeSignature( &timeSig ); 

				pStyleRefItem->m_TimeSignature.bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
				pStyleRefItem->m_TimeSignature.bBeat = timeSig.bBeat;
				pStyleRefItem->m_TimeSignature.wGridsPerBeat = timeSig.wGridsPerBeat;

				pIStyleInfo->Release();
			}
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SyncWithDirectMusic

HRESULT CStyleRefMgr::SyncWithDirectMusic( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pIDMTrack == NULL )
	{
		return E_FAIL;
	}

	IStream* pIMemStream;

	// Persist the strip into a stream
	HRESULT hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		hr = Save( pIMemStream, FALSE );
		if( SUCCEEDED ( hr ) )
		{
			IPersistStream* pIPersistStream;
			hr = m_pIDMTrack->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
			if( SUCCEEDED ( hr ) )
			{
				// Load into DirectMusic track
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load( pIMemStream );

				if( m_pISegmentNode )
				{
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pISegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				pIPersistStream->Release();
			}
		}

		pIMemStream->Release();
	}

	if( SUCCEEDED ( hr ) ) 
	{
		SyncTimeSignatures();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::GetSizeMax

HRESULT CStyleRefMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	UNREFERENCED_PARAMETER(pcbSize);
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::GetData

// This method is called by CStyleRefPropPageMgr to get data to send to the
// StyleRef property page.
// The CStyleRefStrip::GetData() method is called by CStyleRefStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CStyleRefMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected Style reference.
	BOOL fMultipleSelect = FALSE;
	CStyleRefItem* pFirstStyleRefItem = NULL;

	CStyleRefItem* pStyleRefItem;
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		if( pStyleRefItem->m_fSelected
		&&  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
		{
			pFirstStyleRefItem = pStyleRefItem;
			while( pos )
			{
				pStyleRefItem = m_lstStyleRefs.GetNext( pos );
				if( pStyleRefItem->m_fSelected
				&&  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
				{
					fMultipleSelect = TRUE;
					pos = NULL;
					break;
				}
			}
			break;
		}
	}

	*ppData = NULL;
	HRESULT hr = E_FAIL;

	// Multiple Styles selected
	if( fMultipleSelect )
	{
		CPropStyleRef* pPropStyleRef = new CPropStyleRef;
		if( pPropStyleRef )
		{
			pPropStyleRef->m_dwMeasure = 0xFFFFFFFF;		// Signifies multiple Styles selected
			*ppData = pPropStyleRef;
			hr = S_OK;
		}
	}

	// One Style selected
	else if( pFirstStyleRefItem )
	{
		CPropStyleRef* pPropStyleRef = new CPropStyleRef( pFirstStyleRefItem );
		if( pPropStyleRef )
		{
			*ppData = pPropStyleRef;
			hr = S_OK;
		}
	}

	// Nothing selected
	else
	{
		*ppData = NULL;
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SyncStyleBandAndTempo

HRESULT CStyleRefMgr::SyncStyleBandAndTempo( CStyleRefItem* pStyleRefItem )
{
	if( m_pISegmentNode )
	{
		IDMUSProdSegmentEdit* pISegmentEdit;
		if( SUCCEEDED( m_pISegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit, (void**)&pISegmentEdit ) ) )
		{
			IDMUSProdStripMgr* pIStripMgr;

			// Make sure there is a Band track
			if( SUCCEEDED( m_pTimeline->GetStripMgr( GUID_IDirectMusicBand, m_dwGroupBits, 0, &pIStripMgr ) ) )
			{
				pIStripMgr->Release();
			}
			else
			{
				IUnknown *punkStripMgr;

				// Create a Band track
				if( SUCCEEDED ( pISegmentEdit->AddStrip( CLSID_DirectMusicBandTrack, m_dwGroupBits, &punkStripMgr ) ) )
				{
					punkStripMgr->Release();
				}
			}

			// Make sure there is a Tempo track
			BOOL fHasTempoStrip;
			pISegmentEdit->ContainsTempoStrip( &fHasTempoStrip );
			if( fHasTempoStrip == FALSE )
			{
				IUnknown *punkStripMgr;

				// Create a Tempo track
				if( SUCCEEDED ( pISegmentEdit->AddStrip( CLSID_DirectMusicTempoTrack, m_dwGroupBits, &punkStripMgr ) ) )
				{
					punkStripMgr->Release();
				}
			}

			RELEASE( pISegmentEdit );
		}
	}

	// Notify the other strips that a new Style was just selected
	long lStyleTime = MeasureToClocks( pStyleRefItem->m_dwMeasure );
	m_pTimeline->NotifyStripMgrs( GUID_Segment_NewStyleSelected, m_dwGroupBits, (void *)&lStyleTime );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SetData

// This method is called by CStyleRefPropPageMgr in response to user actions
// in the StyleRef Property page.  It changes the currenly selected StyleRef. 
HRESULT STDMETHODCALLTYPE CStyleRefMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected style reference.
	CStyleRefItem* pStyleRefItem;
	pStyleRefItem = FirstSelectedRealStyleRef();

	if( pStyleRefItem )
	{
		CPropStyleRef* pPropStyleRef = new CPropStyleRef( pStyleRefItem );
		if ( pPropStyleRef )
		{
			BOOL fNewStyleAdded = FALSE;

			// Only update if the data has changed
			if( memcmp( pData, pPropStyleRef, sizeof(CPropStyleRef) ) )
			{
				CPropStyleRef* pStyleRef = (CPropStyleRef*)pData;
				HRESULT hr;

				// style has changed, NB, this catches newly created ref node as doc root will be null
				if( pStyleRefItem->m_pIStyleDocRootNode == NULL
				||  pStyleRefItem->m_pIStyleDocRootNode != pStyleRef->m_pIStyleDocRootNode )
				{
					m_pStyleRefStrip->m_nLastEdit = IDS_CHANGE;
					hr = SetStyleReference( pStyleRef->m_pIStyleDocRootNode, pStyleRefItem );

					if( pStyleRef->m_pIStyleDocRootNode )
					{
						fNewStyleAdded = TRUE;
					}
				}

				if( pStyleRefItem->m_dwMeasure != pStyleRef->m_dwMeasure )
				{
					m_pStyleRefStrip->m_nLastEdit = IDS_UNDO_MOVE;
				}

				// Update the first selected style reference
				pStyleRef->ApplyToStyleRefItem( pStyleRefItem );

				// Re-insert the style reference into the list, in case its measure info 
				// changed and it's now out of order w.r.t. the other elements.
				if( RemoveItem( pStyleRefItem ) )
				{
					InsertByAscendingTime( pStyleRefItem );
				}

				// Redraw the style reference strip
				// BUGBUG: Should be smarter and only redraw the style reference that changed
				m_pTimeline->StripInvalidateRect( m_pStyleRefStrip, NULL, TRUE );

				// Let our hosting editor know about the changes
				OnDataChanged();

				// Notify the other strips of possible TimeSig change
				m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_dwGroupBits, NULL );

				// Notify the other strips that a new Style was just selected
				if( fNewStyleAdded )
				{
					SyncStyleBandAndTempo( pStyleRefItem );
				}
			}

			delete pPropStyleRef;
			SyncWithDirectMusic();
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		return S_FALSE;
	}
}


HRESULT CStyleRefMgr::SetStyleReference( IDMUSProdNode* pINewStyleDocRootNode, CStyleRefItem* pItem )
{
	HRESULT hr = S_OK;

	// Clean up old DocRoot
	if( pItem->m_pIStyleDocRootNode )
	{
		// Turn off notifications for this node
		if( pItem->m_fRemoveNotify )
		{
			if( m_pISegmentNode )
			{
				hr = m_pDMProdFramework->RemoveFromNotifyList( pItem->m_pIStyleDocRootNode, m_pISegmentNode );
			}
			pItem->m_fRemoveNotify = FALSE;
		}

		// Initialize DocRoot list info
		pItem->m_StyleListInfo.pIProject = NULL;
		pItem->m_StyleListInfo.strProjectName.LoadString( IDS_EMPTY_TEXT );
		pItem->m_StyleListInfo.strName.LoadString( IDS_EMPTY_TEXT );
		pItem->m_StyleListInfo.strDescriptor.LoadString( IDS_EMPTY_TEXT );
		pItem->m_dwBits = 0;
		memset( &pItem->m_guidProject, 0, sizeof( pItem->m_guidProject ) );

		// Initialize timesig info
		pItem->m_TimeSignature.mtTime = 0;
		pItem->m_TimeSignature.bBeatsPerMeasure = 4;
		pItem->m_TimeSignature.bBeat = 4;
		pItem->m_TimeSignature.wGridsPerBeat = 4;

		// Release DocRoot
		pItem->m_pIStyleDocRootNode->Release();
		pItem->m_pIStyleDocRootNode = NULL;
	}

	// Set new DocRoot
	if( pINewStyleDocRootNode )
	{
		// Turn on notifications
		ASSERT( pItem->m_fRemoveNotify == FALSE );
		if( m_pISegmentNode )
		{
			hr = m_pDMProdFramework->AddToNotifyList( pINewStyleDocRootNode, m_pISegmentNode );
			if( SUCCEEDED ( hr ) )
			{
				pItem->m_fRemoveNotify = TRUE;
			}
		}
		
		// Update DocRoot member variable
		pItem->m_pIStyleDocRootNode = pINewStyleDocRootNode;
		pItem->m_pIStyleDocRootNode->AddRef();

		// Update DocRoot list info
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		if( SUCCEEDED ( pItem->m_pIStyleDocRootNode->GetNodeListInfo ( &ListInfo ) ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				pItem->m_StyleListInfo.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				pItem->m_StyleListInfo.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			if( SUCCEEDED ( m_pDMProdFramework->FindProject( pItem->m_pIStyleDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				pItem->m_StyleListInfo.pIProject = pIProject;
//				pItem->m_StyleListInfo.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					pItem->m_StyleListInfo.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}
		}

		// Update DocRoot file GUID
		m_pDMProdFramework->GetNodeFileGUID ( pItem->m_pIStyleDocRootNode, &pItem->m_StyleListInfo.guidFile );

		// Modify timesig info
		IDMUSProdStyleInfo* pIStyleInfo;
		if( SUCCEEDED ( pItem->m_pIStyleDocRootNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
		{
			DMUSProdTimeSignature timeSig;
			pIStyleInfo->GetTimeSignature( &timeSig ); 

			pItem->m_TimeSignature.bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
			pItem->m_TimeSignature.bBeat = timeSig.bBeat;
			pItem->m_TimeSignature.wGridsPerBeat = timeSig.wGridsPerBeat;

			pIStyleInfo->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CStyleRefMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CStyleRefPropPageMgr* pPPM = new CStyleRefPropPageMgr(m_pDMProdFramework, this);
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		m_pPropPageMgr->SetObject( this );

		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CStyleRefMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CStyleRefMgr::OnDataChanged( void)
{
	if ( m_pTimeline == NULL )
	{
		// Will be NULL if editor is closed and Framework 
		// sends notification that a referenced file has changed
		return E_FAIL;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (IStyleRefMgr*)this );

	return S_OK;
}


HRESULT CStyleRefMgr::GetDirectMusicStyle( IDMUSProdNode* pIStyleDocRoot, IDirectMusicStyle** ppIStyle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = E_FAIL;

	if( pIStyleDocRoot )
	{
		hr = pIStyleDocRoot->GetObject(CLSID_DirectMusicStyle, IID_IDirectMusicStyle, (void**)ppIStyle);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::DeleteSelectedStyleRefs

HRESULT CStyleRefMgr::DeleteSelectedStyleRefs()
{
	CStyleRefItem* pStyleRefItem;
	POSITION pos2, pos1 = m_lstStyleRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos1 );
		ASSERT( pStyleRefItem );
		if( pStyleRefItem )
		{
			if( pStyleRefItem->m_fSelected
			||  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() )
			{
				m_lstStyleRefs.RemoveAt( pos2 );
				delete pStyleRefItem;
			}
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SaveSelectedStyleRefs

HRESULT CStyleRefMgr::SaveSelectedStyleRefs(LPSTREAM pIStream, MUSIC_TIME mtOffset)
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the StyleRef list has anything in it, look for selected StyleRefs
	if( !m_lstStyleRefs.IsEmpty() )
	{
		POSITION pos;
		//MMCKINFO ckMain;

		pos = m_lstStyleRefs.GetHeadPosition();
		while( pos )
		{
			CStyleRefItem* pStyleRefItem;
			pStyleRefItem = m_lstStyleRefs.GetNext( pos );

			ASSERT( pStyleRefItem );
			if( pStyleRefItem
			&&  pStyleRefItem->m_fSelected
			&&  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
			{
				// Store each StyleRef in its own chunk.
				SaveStyleReference( pIStream, pIRiffStream, pStyleRefItem, mtOffset );
			}

		}
		//pIRiffStream->Ascend( &ckMain, 0 );
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::CreateStyleRef

HRESULT CStyleRefMgr::CreateStyleRef( DWORD dwMeasure, CStyleRefItem*& rpStyleRef )
{
	rpStyleRef = new CStyleRefItem( this );
	if( rpStyleRef == NULL )
	{
		return E_OUTOFMEMORY;
	}

	rpStyleRef->m_StyleListInfo.strProjectName.Empty();
	rpStyleRef->m_StyleListInfo.strName.Empty();
	rpStyleRef->m_StyleListInfo.strDescriptor.Empty();

	rpStyleRef->m_dwMeasure = dwMeasure;

	InsertByAscendingTime( rpStyleRef );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::CreateStyleRef

HRESULT CStyleRefMgr::CreateStyleRef( long lXPos, CStyleRefItem*& rpStyleRef )
{
	rpStyleRef = NULL;

	if( m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	rpStyleRef = new CStyleRefItem( this );
	if( rpStyleRef == NULL )
	{
		return E_OUTOFMEMORY;
	}

	long lMeasure = 0;
	long lBeat = 0;

	HRESULT hr;
	hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED ( hr ) );

	rpStyleRef->m_StyleListInfo.strProjectName.Empty();
	rpStyleRef->m_StyleListInfo.strName.Empty();
	rpStyleRef->m_StyleListInfo.strDescriptor.Empty();

	rpStyleRef->m_dwMeasure = lMeasure;

	//rpStyleRef->SetSelectFlag( TRUE );
	InsertByAscendingTime( rpStyleRef );

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::MarkSelectedStyleRefs

// marks m_dwUndermined field CStyleRefItems in list
void CStyleRefMgr::MarkSelectedStyleRefs( DWORD dwFlags )
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if ( pStyleRefItem )
		{
			if ( pStyleRefItem->m_fSelected )
			{
				pStyleRefItem->m_dwBits |= dwFlags;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::DeleteMarked

// deletes style references marked by given flag
void CStyleRefMgr::DeleteMarked( DWORD dwFlags )
{
	CStyleRefItem* pStyleRefItem;
	POSITION pos2, pos1 = m_lstStyleRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos1 );
		ASSERT( pStyleRefItem );
		if ( pStyleRefItem )
		{
			if( (pStyleRefItem->m_dwBits & dwFlags)
			||  (pStyleRefItem->m_StyleListInfo.strName.IsEmpty()) )
			{
				m_lstStyleRefs.RemoveAt( pos2 );
				delete pStyleRefItem;
			}
		}
	}

	// Update the property page
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->RefreshData();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::UnMarkStyleRefs

// unmarks flag m_dwUndermined field CStyleRefItems in list
void CStyleRefMgr::UnMarkStyleRefs( DWORD dwFlags )
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if ( pStyleRefItem )
		{
			pStyleRefItem->m_dwBits &= ~dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::UnselectAllKeepBits

void CStyleRefMgr::UnselectAllKeepBits()
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

		ASSERT( pStyleRefItem );
		if( pStyleRefItem )
		{
			pStyleRefItem->m_fSelected = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::UnselectAll

void CStyleRefMgr::UnselectAll()
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

		ASSERT( pStyleRefItem );
		if( pStyleRefItem )
		{
			pStyleRefItem->SetSelectFlag( FALSE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SelectAll

void CStyleRefMgr::SelectAll()
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if( pStyleRefItem
		&&  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
		{
			// Only select "real" StyleRefs
			pStyleRefItem->SetSelectFlag( TRUE );
		}
		else
		{
			pStyleRefItem->SetSelectFlag( FALSE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::IsSelected

BOOL CStyleRefMgr::IsSelected()
{
	// If anything "real" is selected, return TRUE.
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if( pStyleRefItem )
		{
			if( pStyleRefItem->m_fSelected
			&&  pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::FirstSelectedStyleRef

CStyleRefItem* CStyleRefMgr::FirstSelectedStyleRef()
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if ( pStyleRefItem )
		{
			if ( pStyleRefItem->m_fSelected )
			{
				return pStyleRefItem;
			}
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::FirstSelectedRealStyleRef

CStyleRefItem* CStyleRefMgr::FirstSelectedRealStyleRef()
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem = m_lstStyleRefs.GetNext( pos );

		if ( pStyleRefItem->m_fSelected
		&&   pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
		{
			return pStyleRefItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::CurrentlySelectedStyleRef

CStyleRefItem* CStyleRefMgr::CurrentlySelectedStyleRef()
{
	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if( pStyleRefItem )
		{
			if( pStyleRefItem->m_fSelected
			&& (pStyleRefItem->m_dwBits & UD_CURRENTSELECTION) )
			{
				return pStyleRefItem;
			}
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SelectSegment

BOOL CStyleRefMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	long lBeginMeas, lEndMeas;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBeginTime, &lBeginMeas, NULL );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lEndMeas, NULL );

	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pStyleRefItem;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem );
		if ( pStyleRefItem )
		{
			pStyleRefItem->SetSelectFlag( FALSE );
			if( (DWORD)lBeginMeas < pStyleRefItem->m_dwMeasure && pStyleRefItem->m_dwMeasure < (DWORD)lEndMeas )
			{
				pStyleRefItem->SetSelectFlag( TRUE );
				result = TRUE;
			}
			else if( (DWORD)lBeginMeas == pStyleRefItem->m_dwMeasure )
			{
				if( (DWORD)lEndMeas == pStyleRefItem->m_dwMeasure )
				{
					pStyleRefItem->SetSelectFlag( TRUE );
					result = TRUE;
				}
				else
				{
					pStyleRefItem->SetSelectFlag( TRUE );
					result = TRUE;
				}
			}
			else if( (DWORD)lEndMeas == pStyleRefItem->m_dwMeasure )
			{
				pStyleRefItem->SetSelectFlag( TRUE );
				result = TRUE;
			}
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::EmptyStyleRefList

void CStyleRefMgr::EmptyStyleRefList(void)
{
	if( !m_lstStyleRefs.IsEmpty() )
	{
		CStyleRefItem *pStyleRefItem;
		while ( !m_lstStyleRefs.IsEmpty() )
		{
			pStyleRefItem = m_lstStyleRefs.RemoveHead();
			delete pStyleRefItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::InsertByAscendingTime

void CStyleRefMgr::InsertByAscendingTime( CStyleRefItem *pStyleRef )
{
	ASSERT( pStyleRef );
	if ( pStyleRef == NULL )
	{
		return;
	}

	CStyleRefItem* pStyleRefItem;
	POSITION pos2, pos1 = m_lstStyleRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pStyleRefItem = m_lstStyleRefs.GetNext( pos1 );
		ASSERT( pStyleRefItem );
		if( pStyleRefItem )
		{
			if( pStyleRefItem->m_dwMeasure == pStyleRef->m_dwMeasure )
			{
				// replace item
				m_lstStyleRefs.InsertBefore( pos2, pStyleRef );
				m_lstStyleRefs.RemoveAt( pos2 );
				delete pStyleRefItem;
				return;
			}
			if( pStyleRefItem->m_dwMeasure > pStyleRef->m_dwMeasure )
			{
				// insert before pos2 (current position of pStyleRefItem)
				m_lstStyleRefs.InsertBefore( pos2, pStyleRef );
				return;
			}
		}
	}
	// insert at end of list
	m_lstStyleRefs.AddTail( pStyleRef );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::RemoveItem

BOOL CStyleRefMgr::RemoveItem( CStyleRefItem* pItem )
{
	POSITION pos2;
	POSITION pos1 = m_lstStyleRefs.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstStyleRefs.GetNext( pos1 ) == pItem )
		{
			m_lstStyleRefs.RemoveAt( pos2 );
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::GetBoundariesOfSelectedStyleRefs

void CStyleRefMgr::GetBoundariesOfSelectedStyleRefs( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	HRESULT hr;
	long lClocks;
	long lEnd = -1;
	BOOL fSetStart = FALSE;

	POSITION pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		CStyleRefItem* pItem = m_lstStyleRefs.GetNext( pos );

		if( pItem->m_fSelected ) 
//		&&	pItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
		{
			hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
												   0,
												   pItem->m_dwMeasure,
												   0,
												   &lClocks );
			ASSERT( SUCCEEDED ( hr ) );
			if( SUCCEEDED ( hr ) )
			{
				if( lEnd < lClocks )
				{
					lEnd = lClocks;
				}
				if( !fSetStart )
				{
					fSetStart = TRUE;
					*plStart = lClocks;
				}
			}
		}
	}

	if( lEnd >= 0 )
	{
		if( lEnd <= *plStart )
		{
			lEnd = *plStart + 1;
		}
		*plEnd = lEnd;
	}
	else
	{
		*plStart = -1;
		*plEnd = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::DeleteBetweenTimes

BOOL CStyleRefMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	BOOL fResult = FALSE;

	// Iterate through the list
	CStyleRefItem* pItem;
	POSITION pos2, pos = m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		pItem = m_lstStyleRefs.GetNext( pos );

		long lClocks;
		HRESULT hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits,
											   0,
											   pItem->m_dwMeasure,
											   0,
											   &lClocks );
		ASSERT( SUCCEEDED ( hr ) );
		if( SUCCEEDED ( hr ) )
		{
			// If the Style occurs between lStart and lEnd, delete it
			if( (lClocks >= lStart) && (lClocks <= lEnd) ) 
			{
				m_lstStyleRefs.RemoveAt( pos2 );
				delete pItem;
				fResult = TRUE;
			}
		}
	}

	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::LoadStyleRefDesign

HRESULT CStyleRefMgr::LoadStyleRefDesign( LPSTREAM pIStream, 
						MMCKINFO* pckParent )
{
	ASSERT( pIStream );
	ASSERT( pckParent );

	DMUS_IO_STYLE_REF_DESIGN iStyleRefDesign;
	iStyleRefDesign.fVariationSeedActive = FALSE;
	iStyleRefDesign.dwVariationSeed = 1;

	DWORD cbRead, dwSize = min( sizeof( DMUS_IO_STYLE_REF_DESIGN ), pckParent->cksize );
	if( FAILED( pIStream->Read( &iStyleRefDesign, dwSize, &cbRead ) )
	||	(cbRead != dwSize) )
	{
		return E_FAIL;
	}

	m_fVariationSeedActive = iStyleRefDesign.fVariationSeedActive;
	m_dwVariationSeed = iStyleRefDesign.dwVariationSeed;

	// Skip over the rest of the chunk
	if( dwSize < pckParent->cksize )
	{
		StreamSeek( pIStream, pckParent->cksize - dwSize, SEEK_CUR );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr::SaveStyleRefDesign

HRESULT CStyleRefMgr::SaveStyleRefDesign( LPSTREAM pIStream, IDMUSProdRIFFStream* pIRiffStream )
{
	ASSERT( pIStream );
	ASSERT( pIRiffStream );

	// Create a chunk to store the StyleRefMgr design data
    MMCKINFO ckDesign;
	ckDesign.ckid = DMUS_FOURCC_STYLE_REF_DESIGN_CHUNK;
	if( pIRiffStream->CreateChunk( &ckDesign, 0 ) != 0 )
	{
		return E_FAIL;
	}

	DMUS_IO_STYLE_REF_DESIGN oStyleRefDesign;
	oStyleRefDesign.dwVariationSeed = m_dwVariationSeed;
	oStyleRefDesign.fVariationSeedActive = m_fVariationSeedActive;
	DWORD cbWritten;
	if( FAILED( pIStream->Write( &oStyleRefDesign, sizeof( DMUS_IO_STYLE_REF_DESIGN ), &cbWritten ) )
	||	(cbWritten != sizeof( DMUS_IO_STYLE_REF_DESIGN ) ) )
	{
		return E_FAIL;
	}

	// Ascend out of the StyleRefMgr design data chunk.
	pIRiffStream->Ascend( &ckDesign, 0 );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StyleRefStrip.cpp ===
// StyleRefStrip.cpp : Implementation of CStyleRefStrip
#include "stdafx.h"
#include "StyleRefIO.h"
#include "StyleRefStripMgr.h"
#include "StyleRefMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include <RiffStrm.h>
#include <StyleDesigner.h>
#include "MusicTimeConverter.h"
#include "PropPageVarSeed.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip constructor/destructor

CStyleRefStrip::CStyleRefStrip( CStyleRefMgr* pStyleRefMgr )
{
	ASSERT( pStyleRefMgr );
	if ( pStyleRefMgr == NULL )
	{
		return;
	}

	m_pStyleRefMgr = pStyleRefMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pStyleRefMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;
	m_bGutterSelected = FALSE;

	m_cfStyleRefList = 0;
	m_cfStyle = 0;

	m_bSelecting = FALSE;
	m_bContextMenuPaste = FALSE;
	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_nStripIsDragDropSource = 0;
	m_dwStartDragButton = 0;
	m_lStartDragPosition = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_nLastEdit = 0;
	m_fShowStyleRefProps = FALSE;
	m_fPropPageActive = FALSE;
	m_fSingleSelect = FALSE;
	m_pPropPageMgr = NULL;
	m_fInRightClickMenu = FALSE;
}

CStyleRefStrip::~CStyleRefStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pStyleRefMgr = NULL;
	}
	RELEASE( m_pISourceDataObject );
	RELEASE( m_pITargetDataObject );
	RELEASE( m_pPropPageMgr );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::QueryInterface

STDMETHODIMP CStyleRefStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::AddRef

STDMETHODIMP_(ULONG) CStyleRefStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Release

STDMETHODIMP_(ULONG) CStyleRefStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Draw

HRESULT	STDMETHODCALLTYPE CStyleRefStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	BOOL fUseGutterSelectRange = FALSE;
	if( m_bGutterSelected
	&&  m_lGutterBeginSelect != m_lGutterEndSelect )
	{
		fUseGutterSelectRange = TRUE;
	}

	// locals for Ghosting
	long lFirstVisibleMeasure, lPartialVisibleMeasure;
	long lClocks;
	RECT rectGhost;
	CStyleRefItem* pGhostStyle = 0;

	rectGhost.top = rectGhost.left = rectGhost.right = 0;
	rectGhost.bottom = STRIP_HEIGHT;
	bool bGhostStyleCovered = false;	// indicates a real style exists where ghost would be

	// Validate pointer to the Timeline
	if( m_pStyleRefMgr->m_pTimeline )
	{
		IDMUSProdTimeline* pTimeline = m_pStyleRefMgr->m_pTimeline; // added later for use in ghosting

		// Draw Measure and Beat lines in our strip
		m_pStyleRefMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pStyleRefMgr->m_dwGroupBits, 0, lXOffset );

		// Validate our device context
		if( hDC )
		{
			CDC dc;		// added for use in ghosting
			dc.Attach(hDC);
			RECT	rectClip, rectHighlight;
			long	lStartTime, lPosition;
			CStyleRefItem* pStyleRefItem;
			SIZE	sizeText;

			::GetClipBox( hDC, &rectClip );
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;


			// find first visible measure for ghosting styles
			pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
			CMusicTimeConverter cmtFirstVisible(lClocks);
			cmtFirstVisible.GetMeasure(lPartialVisibleMeasure, pTimeline, m_pStyleRefMgr->m_dwGroupBits);
			CMusicTimeConverter cmtNearestMeasure(lPartialVisibleMeasure, 0, pTimeline, m_pStyleRefMgr->m_dwGroupBits);
			if(cmtNearestMeasure.Time() < cmtFirstVisible.Time())
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure + 1;
			}
			else
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure;
			}

			// find latest style before first visible measure
			POSITION pos = m_pStyleRefMgr->m_lstStyleRefs.GetHeadPosition();
			while(pos)
			{
				pStyleRefItem = m_pStyleRefMgr->m_lstStyleRefs.GetNext(pos);
				if(pStyleRefItem->m_dwMeasure < (unsigned)lFirstVisibleMeasure
					&& !pStyleRefItem->m_StyleListInfo.strName.IsEmpty())
				{
					pGhostStyle = pStyleRefItem;
				}
				else
				{
					break;
				}
			}
			if(pGhostStyle)
			{
				// get rect of style, will have to truncate if ghost style covers part of real style
				pTimeline->MeasureBeatToPosition(m_pStyleRefMgr->m_dwGroupBits, 0, lFirstVisibleMeasure,
												0, &lPosition);
				lPosition++;
				CSize csize;
				csize = dc.GetTextExtent(pGhostStyle->m_StyleListInfo.strName);
				rectGhost.left = lPosition - lXOffset;
				rectGhost.right = rectGhost.left + csize.cx;
			}

			// well draw ghost style after checking whether real style covers it

			m_pStyleRefMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );

			// Iterate through all styles
			pos = m_pStyleRefMgr->m_lstStyleRefs.GetHeadPosition();
			while( pos )
			{
				pStyleRefItem = m_pStyleRefMgr->m_lstStyleRefs.GetNext( pos );

				if(pStyleRefItem->m_dwMeasure == (unsigned)lFirstVisibleMeasure)
				{
					// real signpost covers ghost
					bGhostStyleCovered = true;
				}

				// Compute the position of the style
				m_pStyleRefMgr->m_pTimeline->MeasureBeatToPosition( m_pStyleRefMgr->m_dwGroupBits, 0, pStyleRefItem->m_dwMeasure, 0, &lPosition );

				// If it's not visible, break out of the loop
				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}

				if(pGhostStyle)
				{
					// truncate ghost style's text so it doesn't cover up real style's text
					long lTruePos = lPosition - lXOffset;
					if(lTruePos > rectGhost.left && lTruePos < rectGhost.right)
					{
						rectGhost.right = lTruePos;
					}
				}

				// Otherwise, draw it one pixel to the right (so it doesn't overwrite the measure line)
				::TextOut( hDC, lPosition - lXOffset + 1, 0, pStyleRefItem->m_StyleListInfo.strName, _tcslen(pStyleRefItem->m_StyleListInfo.strName) );
			}

			// make sure the first selected StyleRef is shown in its entirety
			pStyleRefItem = m_pStyleRefMgr->FirstSelectedStyleRef();
			if( pStyleRefItem )
			{
				pos = m_pStyleRefMgr->m_lstStyleRefs.Find( pStyleRefItem, NULL );
				while( pos )
				{
					if( pStyleRefItem->m_fSelected )
					{
						long lMeasureLength = 0;
						m_pStyleRefMgr->m_pTimeline->MeasureBeatToPosition( m_pStyleRefMgr->m_dwGroupBits, 0,
														  pStyleRefItem->m_dwMeasure, 0, &lPosition );
						m_pStyleRefMgr->m_pTimeline->MeasureBeatToPosition( m_pStyleRefMgr->m_dwGroupBits, 0,
														 (pStyleRefItem->m_dwMeasure + 1), 0, &lMeasureLength );
						lMeasureLength -= lPosition;

						// find extent of text
						::GetTextExtentPoint32( hDC, pStyleRefItem->m_StyleListInfo.strName, _tcslen(pStyleRefItem->m_StyleListInfo.strName), &sizeText );
						if( sizeText.cx < lMeasureLength )
						{
							sizeText.cx = lMeasureLength;
						}
						long lExtent = lPosition + sizeText.cx;

						// truncate if a selected StyleRef covers part of text
						POSITION pos2 = pos;
						CStyleRefItem* pTempStyleRef;
						bool fDone = false;
						while( pos2 && !fDone)
						{
							m_pStyleRefMgr->m_lstStyleRefs.GetNext( pos2 );
							if (!pos2) break;
							pTempStyleRef = m_pStyleRefMgr->m_lstStyleRefs.GetAt( pos2 );
							if( pTempStyleRef->m_fSelected )
							{	
								long lRPos;
								m_pStyleRefMgr->m_pTimeline->MeasureBeatToPosition( m_pStyleRefMgr->m_dwGroupBits, 0, pTempStyleRef->m_dwMeasure, 0, &lRPos );
								if( lRPos <= lExtent )
								{
									lExtent = lRPos;
								}
								fDone = true;
							}
						}

						if( fUseGutterSelectRange == FALSE )
						{
							rectHighlight.left = lPosition - lXOffset;
							rectHighlight.right = lExtent - lXOffset;
							::DrawText( hDC, pStyleRefItem->m_StyleListInfo.strName, _tcslen(pStyleRefItem->m_StyleListInfo.strName), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
							GrayOutRect( hDC, &rectHighlight );
						}
					}
					m_pStyleRefMgr->m_lstStyleRefs.GetNext( pos );
					if (pos) pStyleRefItem = m_pStyleRefMgr->m_lstStyleRefs.GetAt( pos );
				}
			}

			// now draw ghost style
			// but not if original style is still showing
			if(!bGhostStyleCovered && pGhostStyle)
			{
				pTimeline->MeasureBeatToPosition(m_pStyleRefMgr->m_dwGroupBits, 0,
													pGhostStyle->m_dwMeasure, 0, &lPosition);
						
				// lPosition -= lXOffset deliberately left off as left margin already has scrolling taking into accout
				CSize extent = dc.GetTextExtent(pGhostStyle->m_StyleListInfo.strName);
				if(!((lPosition + extent.cx) > LeftMargin(pTimeline)))
				{
					COLORREF cr = dc.SetTextColor(RGB(168, 168, 168));
					dc.DrawText(pGhostStyle->m_StyleListInfo.strName, &rectGhost, (DT_LEFT | DT_NOPREFIX));
					dc.SetTextColor(cr);
				}
			}

			// Highlight the selected range if there is one.
			if( fUseGutterSelectRange )
			{
				long lBeginSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect;
				long lEndSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect;

				long lMeasure;
				long lBeat;
				long lClocks;

				m_pStyleRefMgr->m_pTimeline->ClocksToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits, 0, lBeginSelect, &lMeasure, &lBeat );
				m_pStyleRefMgr->m_pTimeline->MeasureBeatToClocks( m_pStyleRefMgr->m_dwGroupBits, 0, lMeasure, 0, &lClocks );
				m_pStyleRefMgr->m_pTimeline->ClocksToPosition( lClocks, &(rectHighlight.left));

				m_pStyleRefMgr->m_pTimeline->ClocksToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits, 0, lEndSelect, &lMeasure, &lBeat );
				m_pStyleRefMgr->m_pTimeline->MeasureBeatToClocks( m_pStyleRefMgr->m_dwGroupBits, 0, (lMeasure + 1), 0, &lClocks );
				m_pStyleRefMgr->m_pTimeline->ClocksToPosition( (lClocks - 1), &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;

				// Invert it.
				GrayOutRect( hDC, &rectHighlight );
			}
			dc.Detach();
		}
	}
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CStyleRefStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			CString strStyles;

			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( _Module.GetModuleInstance() );
			strStyles.LoadString( IDS_STYLES_TEXT );
			AfxSetResourceHandle( hInstance );

			CString str = GetName(m_pStyleRefMgr->m_dwGroupBits, strStyles);
			BSTR bstr;

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pStyleRefMgr )
		{
			m_pStyleRefMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CStyleRefStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pStyleRefMgr->UnselectAll();
			m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}

		if( m_bGutterSelected )
		{
			m_pStyleRefMgr->UnselectAll();
			m_pStyleRefMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pStyleRefMgr->UnselectAll();
		}
		m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pStyleRefMgr->m_pPropPageMgr != NULL )
		{
			m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pStyleRefMgr->UnselectAll();
			m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}

		if( m_bGutterSelected )
		{
			m_pStyleRefMgr->UnselectAll();
			m_pStyleRefMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pStyleRefMgr->UnselectAll();
		}
		m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pStyleRefMgr->m_pPropPageMgr != NULL )
		{
			m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::GetStyleRefFromMeasureBeat

CStyleRefItem *CStyleRefStrip::GetStyleRefFromMeasureBeat( DWORD dwMeasure, BYTE bBeat )
{
	ASSERT( bBeat == 0 );	// Styles must be on a measure boundary
	
	CStyleRefItem* pStyleRefItem = NULL;

	POSITION pos = m_pStyleRefMgr->m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		pStyleRefItem = m_pStyleRefMgr->m_lstStyleRefs.GetNext( pos );
		ASSERT( pStyleRefItem != NULL );
		if ( pStyleRefItem != NULL )
		{
			if ( pStyleRefItem->m_dwMeasure == dwMeasure )
			{
				return pStyleRefItem;
			}
			else if ( pStyleRefItem->m_dwMeasure > dwMeasure )
			{
				break;
			}
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::GetStyleRefFromPoint

CStyleRefItem *CStyleRefStrip::GetStyleRefFromPoint( long lPos )
{
	CStyleRefItem*		pStyleRefReturn = NULL;

	if( m_pStyleRefMgr->m_pTimeline )
	{
		long lMeasure, lBeat;
		if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->PositionToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			pStyleRefReturn = GetStyleRefFromMeasureBeat( lMeasure, 0 );
		}
	}
	return pStyleRefReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CStyleRefStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	if( m_pStyleRefMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		m_fShowStyleRefProps = TRUE;
		hr = OnLButtonDown( wParam, lXPos );
		break;

	case WM_RBUTTONDOWN:
		hr = OnRButtonDown( wParam, lXPos );
		break;

	case WM_RBUTTONUP:
		// Display a right-click context menu.
		POINT pt;
		BOOL	bResult;
		// Get the cursor position (To put the menu there)
		bResult = GetCursorPos( &pt );
		ASSERT( bResult );
		if( !bResult )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Save the position of the click so we know where to insert a StyleRef. if Insert is selected.
		m_lXPos = lXPos;
		m_fInRightClickMenu = TRUE;
		m_pStyleRefMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
		m_fInRightClickMenu = FALSE;

		hr = S_OK;
		break;

	case WM_MOUSEMOVE:
		if( m_dwStartDragButton )
		{
			m_nStripIsDragDropSource = 1;
	
			if( DoDragDrop() )
			{
				// Redraw the strip and refresh the StyleRef property page
				m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_pStyleRefMgr->OnShowProperties();
				if( m_pStyleRefMgr->m_pPropPageMgr )
				{
					m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
				}
			}

			m_dwStartDragButton = 0;
			m_nStripIsDragDropSource = 0;
		}
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = DisplayPropertySheet(m_pStyleRefMgr->m_pTimeline);
			if (m_fShowStyleRefProps)
			{
				// Change to the style reference property page
				m_pStyleRefMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			if( m_lXPos >= 0 )
			{
				m_bContextMenuPaste = TRUE;
			}
			hr = Paste();
			m_bContextMenuPaste = FALSE;
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_LBUTTONUP:
		if( m_fSingleSelect )
		{
			CStyleRefItem* pStyleRef = GetStyleRefFromPoint( lXPos );
			if( pStyleRef
			&&  pStyleRef->m_StyleListInfo.strName.IsEmpty() == FALSE )
			{
				m_pStyleRefMgr->UnselectAll();
				pStyleRef->SetSelectFlag( TRUE );
				m_pStyleRefMgr->UnMarkStyleRefs( UD_CURRENTSELECTION );
				pStyleRef->m_dwBits |= UD_CURRENTSELECTION;

				// Redraw the strip and refresh the StyleRef property page
				m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_pStyleRefMgr->OnShowProperties();
				if( m_pStyleRefMgr->m_pPropPageMgr )
				{
					m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
				}
			}
			m_fSingleSelect = FALSE;
		}
		m_lXPos = lXPos;
		hr = S_OK;
		break;

	case WM_CREATE:
		m_cfStyleRefList = RegisterClipboardFormat( CF_STYLEREFLIST );
		m_cfStyle = RegisterClipboardFormat( CF_STYLE);

		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::FBDraw

HRESULT CStyleRefStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	UNREFERENCED_PARAMETER(sv);
	UNREFERENCED_PARAMETER(hDC);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::FBOnWMMessage

HRESULT CStyleRefStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_fShowStyleRefProps = FALSE;
		OnShowProperties();
		break;

	case WM_RBUTTONUP:
		m_fShowStyleRefProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pStyleRefMgr->m_pTimeline )
		{
			m_fInRightClickMenu = TRUE;
			m_pStyleRefMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
			m_fInRightClickMenu = FALSE;
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Cut

HRESULT CStyleRefStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Copy

HRESULT CStyleRefStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfStyleRefList == 0 )
	{
		m_cfStyleRefList = RegisterClipboardFormat( CF_STYLEREFLIST );
		if( m_cfStyleRefList == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	m_pStyleRefMgr->MarkSelectedStyleRefs(UD_DRAGSELECT);

	MUSIC_TIME mtTime;
	if( pITimelineDataObject )
	{
		// Get clock from pITimelineDataObject
		if( FAILED( pITimelineDataObject->GetBoundaries( &mtTime, NULL ) ) )
		{
			return E_UNEXPECTED;
		}
	}
	else
	{
		// Get clock of first selected Style's measure
		CStyleRefItem* pStyleRefAtDragPoint = m_pStyleRefMgr->FirstSelectedStyleRef();
		ASSERT( pStyleRefAtDragPoint != NULL );
		if( pStyleRefAtDragPoint == NULL )
		{
			return E_UNEXPECTED;
		}
		mtTime = m_pStyleRefMgr->MeasureToClocks( pStyleRefAtDragPoint->m_dwMeasure );
	}

	// Save the Styles into the stream.
	hr = m_pStyleRefMgr->SaveSelectedStyleRefs( pStreamCopy, mtTime );
	if( FAILED( hr ))
	{
		RELEASE( pStreamCopy );
		return E_UNEXPECTED;
	}
		
	if( pITimelineDataObject )
	{
		// add the stream to the passed IDMUSProdTimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfStyleRefList, pStreamCopy );
		RELEASE( pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pStyleRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pStyleRefMgr->GetBoundariesOfSelectedStyleRefs( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfStyleRefList, pStreamCopy );

		// Release the IStream we copied into
		RELEASE( pStreamCopy );

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the IDMUSProdTimelineDataObject
		RELEASE( pITimelineDataObject );

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		RELEASE( m_pStyleRefMgr->m_pCopyDataObject);

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pStyleRefMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// m_pStyleRefMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::PasteAt

HRESULT CStyleRefStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtPasteTime, BOOL fDropNotEditPaste, BOOL &fChanged, CStyleRefItem** pSyncBandTempoItem )
{
	ASSERT( m_pStyleRefMgr != NULL );
	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );

	if( pITimelineDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure everything in other strip is deselected first.
	if( fDropNotEditPaste == FALSE )
	{
		UnselectGutterRange();
	}

	// Determine paste measure
	long lMeasure;
	long lBeat;
	m_pStyleRefMgr->m_pTimeline->ClocksToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits,
				 									  0,
													  mtPasteTime,
													  &lMeasure,
													  &lBeat );

	// Don't bother to do anything if user simply moved cursor within same measure in same strip
	if( fDropNotEditPaste )
	{
		if( m_nStripIsDragDropSource )
		{
			long lSourceMeasure;
			long lSourceBeat;
			if( SUCCEEDED ( m_pStyleRefMgr->m_pTimeline->PositionToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits,
																				0,
																				m_lStartDragPosition,
																				&lSourceMeasure,
																				&lSourceBeat ) ) )
			{
				if( lSourceMeasure == lMeasure )
				{
					return S_FALSE;
				}
			}
		}
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfStyleRefList ) == S_OK )
	{
		IStream* pIStream;
		
		if( m_nStripIsDragDropSource )
		{
			m_pStyleRefMgr->UnselectAllKeepBits();
		}
		else
		{
			m_pStyleRefMgr->UnselectAll();
		}

		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfStyleRefList, &pIStream)))
		{
			// Check for RIFF format
			if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				goto Leave;
			}

			hr = m_pStyleRefMgr->LoadStyleRefList( pIRiffStream, NULL, TRUE, mtPasteTime, fChanged );
		}
	}
	else if( pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK )
	{
		IDMUSProdNode* pIDocRootNode;
		IDataObject* pIDataObject;

		if( m_nStripIsDragDropSource )
		{
			m_pStyleRefMgr->UnselectAllKeepBits();
		}
		else
		{
			m_pStyleRefMgr->UnselectAll();
		}

		hr = pITimelineDataObject->Export( &pIDataObject );
		if( SUCCEEDED ( hr ) )
		{
			hr = m_pStyleRefMgr->m_pDMProdFramework->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				CStyleRefItem* pItem = new CStyleRefItem( m_pStyleRefMgr );
				if( pItem )
				{
					m_pStyleRefMgr->ClocksToMeasure( mtPasteTime, (DWORD&)pItem->m_dwMeasure );

					hr = m_pStyleRefMgr->SetStyleReference( pIDocRootNode, pItem );
					if( SUCCEEDED ( hr ) )
					{
						m_pStyleRefMgr->InsertByAscendingTime( pItem );
						pItem->SetSelectFlag( TRUE );
						*pSyncBandTempoItem = pItem;
						fChanged = TRUE;
					}
					else
					{
						delete pItem;
					}
				}

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDataObject );
		}
	}

Leave:
	RELEASE( pIRiffStream );
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Paste

HRESULT CStyleRefStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );
	if( m_pStyleRefMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfStyleRefList == 0 )
	{
		m_cfStyleRefList = RegisterClipboardFormat( CF_STYLEREFLIST );
		if( m_cfStyleRefList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfStyle == 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
		if( m_cfStyle == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pStyleRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			RELEASE( pIDataObject );
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Determine paste measure
	MUSIC_TIME mtTime;
	DWORD dwMeasure;
	if( m_bContextMenuPaste )
	{
		m_pStyleRefMgr->m_pTimeline->PositionToClocks( m_lXPos, &mtTime );
	}
	else
	{
		if( FAILED( m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			RELEASE( pITimelineDataObject );
			return E_FAIL;
		}
	}
	m_pStyleRefMgr->ClocksToMeasure( mtTime, (DWORD&)dwMeasure );
	mtTime = m_pStyleRefMgr->MeasureToClocks( dwMeasure );

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pStyleRefMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		RELEASE( pITimelineDataObject );
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd, lDiff;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			ASSERT( lStart < lEnd );

			lDiff = lEnd - lStart;
			lStart = mtTime;
			lEnd = lStart + lDiff;

			fChanged = m_pStyleRefMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}

	// Unselect the existing StyleRefs
	m_pStyleRefMgr->UnselectAll();

	// Now, do the paste operation
	CStyleRefItem* pNotUsed = NULL;
	hr = PasteAt(pITimelineDataObject, mtTime, false, fChanged, &pNotUsed);
	RELEASE( pITimelineDataObject );

	// If successful and something changed, redraw our strip
	if( SUCCEEDED(hr) && fChanged )
	{
		// Set the last edit type
		m_nLastEdit = IDS_PASTE;

		// Update our hosting editor.
		m_pStyleRefMgr->OnDataChanged();

		// Redraw our strip
		m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
		m_pStyleRefMgr->SyncWithDirectMusic();

		// Notify the other strips of possible TimeSig change
		m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pStyleRefMgr->m_dwGroupBits, NULL );

		m_pStyleRefMgr->OnShowProperties();
		if( m_pStyleRefMgr->m_pPropPageMgr )
		{
			m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Insert

HRESULT CStyleRefStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Unselect all items in this strip 
	m_pStyleRefMgr->UnselectAll();
	
	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;
	long	lMeasure, lBeat;
	CStyleRefItem* pStyleRef = NULL;
	BOOL fNewStyleRef = FALSE;
	if( m_pStyleRefMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	hr = m_pStyleRefMgr->m_pTimeline->PositionToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits, 0, m_lXPos, &lMeasure, &lBeat );
	ASSERT( SUCCEEDED( hr ) );

	pStyleRef = GetStyleRefFromPoint( m_lXPos );
	if( pStyleRef == NULL
	||  pStyleRef->m_pIStyleDocRootNode )
	{
		pStyleRef = new CStyleRefItem( m_pStyleRefMgr );
		fNewStyleRef = TRUE;
	}
	if( pStyleRef == NULL )
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pStyleRef->m_StyleListInfo.strProjectName.LoadString( IDS_EMPTY_TEXT );
		pStyleRef->m_StyleListInfo.strName.LoadString( IDS_EMPTY_TEXT );
		pStyleRef->m_StyleListInfo.strDescriptor.LoadString( IDS_EMPTY_TEXT );
		pStyleRef->m_dwMeasure = lMeasure;
		pStyleRef->SetSelectFlag( TRUE );
		pStyleRef->m_TimeSignature.mtTime = 0;
		pStyleRef->m_TimeSignature.bBeatsPerMeasure = 4;
		pStyleRef->m_TimeSignature.bBeat = 4;
		pStyleRef->m_TimeSignature.wGridsPerBeat = 4;
		if( fNewStyleRef )
		{
			m_pStyleRefMgr->InsertByAscendingTime(pStyleRef);
		}
		m_pStyleRefMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
		DisplayPropertySheet(m_pStyleRefMgr->m_pTimeline);
		m_pStyleRefMgr->OnShowProperties();
			
		if( m_pStyleRefMgr->m_pPropPageMgr )
		{
			m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
		}
		m_nLastEdit = IDS_INSERT;
		m_pStyleRefMgr->OnDataChanged();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Delete

HRESULT CStyleRefStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* This may be part of a cut operation.  You can cut empty space, but you can't delete it.
	HRESULT hr = CanDelete();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );
	if( m_pStyleRefMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pStyleRefMgr->DeleteSelectedStyleRefs();

	m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	if( m_pStyleRefMgr->m_pPropPageMgr )
	{
		m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
	}
	m_pStyleRefMgr->SyncWithDirectMusic();

	m_nLastEdit = IDS_DELETE;
	m_pStyleRefMgr->OnDataChanged();

	// Notify the other strips of possible TimeSig change
	m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pStyleRefMgr->m_dwGroupBits, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::SelectAll

HRESULT CStyleRefStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );
	if( m_pStyleRefMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pStyleRefMgr->SelectAll();

	m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanCut

HRESULT CStyleRefStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanCopy

HRESULT CStyleRefStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pStyleRefMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pStyleRefMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanPaste

HRESULT CStyleRefStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr = S_FALSE;

	ASSERT( m_pStyleRefMgr != NULL );
	if( m_pStyleRefMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the formats haven't been registered yet, do it now.
	if( m_cfStyleRefList == 0 )
	{
		m_cfStyleRefList = RegisterClipboardFormat( CF_STYLEREFLIST );
		if( m_cfStyleRefList == 0 )
		{
			return E_FAIL;
		}
	}
	if( m_cfStyle== 0 )
	{
		m_cfStyle = RegisterClipboardFormat( CF_STYLE );
		if( m_cfStyle == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		if( (pITimelineDataObject->IsClipFormatAvailable( m_cfStyleRefList ) == S_OK)
		||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK) )
		{
			hr = S_OK;
		}
		else
		{
			hr = S_FALSE;
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					if( (pITimelineDataObject->IsClipFormatAvailable( m_cfStyleRefList ) == S_OK)
					||  (pITimelineDataObject->IsClipFormatAvailable( m_cfStyle ) == S_OK) )
					{
						hr = S_OK;
					}
					else
					{
						hr = S_FALSE;
					}
				}
				RELEASE( pITimelineDataObject );
			}
			RELEASE( pIDataObject );
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanInsert

HRESULT CStyleRefStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pStyleRefMgr != NULL );
	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pStyleRefMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Get clock at XPos
	long lClock;
	m_pStyleRefMgr->m_pTimeline->PositionToClocks( m_lXPos, &lClock );

	// Make sure XPos is within strip
	if( lClock > 0 
	&&  lClock < lTimelineLength )
	{
		// User clicked within boundaries of strip
		long lMeasure;
		long lBeat;

		if( SUCCEEDED ( m_pStyleRefMgr->m_pTimeline->PositionToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits,
																			0,
																			m_lXPos,
																			&lMeasure,
																			&lBeat ) ) )
		{
			CPropStyleRef* pStyleRef = GetStyleRefFromPoint( m_lXPos );
			if( pStyleRef == NULL
			||  pStyleRef->m_StyleListInfo.strName.IsEmpty() )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanDelete

HRESULT CStyleRefStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pStyleRefMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanSelectAll

HRESULT CStyleRefStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fInRightClickMenu == FALSE )
	{
		// Always enable when gutter is selected
		if( m_bGutterSelected )
		{
			return S_OK;
		}
	}

	CStyleRefItem* pStyleRefItem;

	POSITION pos = m_pStyleRefMgr->m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		pStyleRefItem = m_pStyleRefMgr->m_lstStyleRefs.GetNext( pos );

		if( pStyleRefItem->m_StyleListInfo.strName.IsEmpty() == FALSE )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::QueryContinueDrag

HRESULT CStyleRefStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::GiveFeedback

HRESULT CStyleRefStrip::GiveFeedback( DWORD dwEffect )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CreateDataObject

HRESULT	CStyleRefStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Convert lPosition from pixels to clocks
	long lMeasure, lBeat;
	if( FAILED( m_pStyleRefMgr->m_pTimeline->PositionToMeasureBeat( m_pStyleRefMgr->m_dwGroupBits, 0, lPosition, &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}
	long lClocks;
	if( FAILED( m_pStyleRefMgr->m_pTimeline->MeasureBeatToClocks( m_pStyleRefMgr->m_dwGroupBits, 0, lMeasure, 0, &lClocks ) ) )
	{
		return E_UNEXPECTED;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected StyleRefs into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pStyleRefMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// mark the style references as being dragged: this used later for deleting style references in drag move
		m_pStyleRefMgr->MarkSelectedStyleRefs(UD_DRAGSELECT);
		if( SUCCEEDED ( m_pStyleRefMgr->SaveSelectedStyleRefs( pIStream, lClocks ) ) )
		{
			// Place CF_STYLE_REFLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfStyleRefList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;

}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::DragEnter

HRESULT CStyleRefStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::DragOver

HRESULT CStyleRefStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	MUSIC_TIME mtTime;
	if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
	{
		if( (mtTime >= 0) && (CanPasteFromData( m_pITargetDataObject ) == S_OK) )
		{
			BOOL fCF_STYLE = FALSE;

			// Does m_pITargetDataObject contain format CF_STYLE?
			CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
			if( pDataObject )
			{
				if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( m_pITargetDataObject, m_cfStyle ) ) )
				{
					fCF_STYLE = TRUE;
				}
				pDataObject->Release();
			}

			// Can only copy CF_STYLE data!
			if( fCF_STYLE )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( grfKeyState & MK_RBUTTON )
				{
					dwEffect = *pdwEffect;
				}
				else
				{
					if( grfKeyState & MK_CONTROL )
					{
						dwEffect = DROPEFFECT_COPY;
					}
					else
					{
						if( *pdwEffect & DROPEFFECT_COPY
						&&  *pdwEffect & DROPEFFECT_MOVE )
						{
							dwEffect = DROPEFFECT_MOVE;
						}
						else
						{
							dwEffect = *pdwEffect;
						}
					}
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::DragLeave

HRESULT CStyleRefStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		RELEASE( m_pITargetDataObject );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::Drop

HRESULT CStyleRefStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if( pWnd )
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				MUSIC_TIME mtTime;
				if( SUCCEEDED( m_pStyleRefMgr->m_pTimeline->PositionToClocks( pt.x, &mtTime ) ) )
				{
					BOOL fChanged = FALSE;
					CStyleRefItem* pSyncBandTempoItem = NULL;
					hr = PasteAt( pITimelineDataObject, mtTime, true, fChanged, &pSyncBandTempoItem );
					if( hr == S_OK )
					{
						*pdwEffect = m_dwOverDragEffect;

						// If we pasted anything
						if( fChanged )
						{
							if( m_nStripIsDragDropSource )
							{
								// Drag/drop Target and Source are the same StyleRef strip
								m_nStripIsDragDropSource = 2;
							}
							else
							{
								// Set the last edit type
								m_nLastEdit = IDS_PASTE;

								// Update our hosting editor.
								m_pStyleRefMgr->OnDataChanged();

								// Insert style's tempo and default band (only when style dragged from project tree)
								if( pSyncBandTempoItem )
								{
									m_pStyleRefMgr->SyncStyleBandAndTempo( pSyncBandTempoItem );
								}

								// Redraw our strip
								m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

								// Update the property page
								if( m_pStyleRefMgr->m_pPropPageMgr != NULL )
								{
									m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
								}

								m_pStyleRefMgr->SyncWithDirectMusic();

								// Notify the other strips of possible TimeSig change
								m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pStyleRefMgr->m_dwGroupBits, NULL );
							}
						}
					}
					else if( hr == S_FALSE )
					{
						*pdwEffect = DROPEFFECT_NONE;
					}
				}
			}
			RELEASE( pITimelineDataObject );
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::GetTimelineCWnd

CWnd* CStyleRefStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pStyleRefMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pStyleRefMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::CanPasteFromData

HRESULT CStyleRefStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfStyleRefList ) )
	||  SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfStyle ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::GetData

HRESULT CStyleRefStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPGData *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPGData *>(*ppData);
		pGroupBitsPPGData->dwGroupBits = m_pStyleRefMgr->m_dwGroupBits;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pStyleRefMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pStyleRefMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	case 2:
	{
		ioVarSeedPPGData *pVarSeedPPGData = reinterpret_cast<ioVarSeedPPGData *>(*ppData);
		pVarSeedPPGData->fVariationSeedEnabled = m_pStyleRefMgr->m_fVariationSeedActive;
		pVarSeedPPGData->dwVariationSeed = m_pStyleRefMgr->m_dwVariationSeed;
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::SetData

HRESULT CStyleRefStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPGData *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPGData *>(pData);

		if( pGroupBitsPPGData->dwGroupBits != m_pStyleRefMgr->m_dwGroupBits )
		{
			DWORD dwOrigGroupBits = m_pStyleRefMgr->m_dwGroupBits; 
			m_pStyleRefMgr->m_dwGroupBits = pGroupBitsPPGData->dwGroupBits;

			m_nLastEdit = IDS_TRACK_GROUP;
			m_pStyleRefMgr->m_pTimeline->OnDataChanged( (IStyleRefMgr*)m_pStyleRefMgr );
			m_pStyleRefMgr->m_dwOldGroupBits = pGroupBitsPPGData->dwGroupBits;

			// Time signature may have changed
			m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature,
														 (dwOrigGroupBits | m_pStyleRefMgr->m_dwGroupBits),
														  NULL );
		}
		return S_OK;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pStyleRefMgr->m_dwTrackExtrasFlags )
		{
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pStyleRefMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
			m_pStyleRefMgr->m_pTimeline->OnDataChanged( (IStyleRefMgr*)m_pStyleRefMgr );
		}
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pStyleRefMgr->m_dwProducerOnlyFlags )
		{
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pStyleRefMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
			m_pStyleRefMgr->m_pTimeline->OnDataChanged( (IStyleRefMgr*)m_pStyleRefMgr );
		}
		return S_OK;
		break;
	}
	case 2:
	{
		ioVarSeedPPGData *pVarSeedPPGData = reinterpret_cast<ioVarSeedPPGData *>(pData);

		if( pVarSeedPPGData->fVariationSeedEnabled != m_pStyleRefMgr->m_fVariationSeedActive )
		{
			m_pStyleRefMgr->m_fVariationSeedActive = pVarSeedPPGData->fVariationSeedEnabled;

			if( m_pStyleRefMgr->m_pIDMTrack )
			{
				DWORD dwSeed = m_pStyleRefMgr->m_fVariationSeedActive ? m_pStyleRefMgr->m_dwVariationSeed : 0;
				VERIFY( SUCCEEDED( m_pStyleRefMgr->m_pIDMTrack->SetParam( GUID_SeedVariations, 0, &dwSeed ) ) );
			}

			if( m_pStyleRefMgr->m_fVariationSeedActive )
			{
				m_nLastEdit = IDS_ENABLE_VARIATION_SEED;
			}
			else
			{
				m_nLastEdit = IDS_DISABLE_VARIATION_SEED;
			}
			m_pStyleRefMgr->m_pTimeline->OnDataChanged( (IStyleRefMgr*)m_pStyleRefMgr );

			return S_OK;
		}

		else if( m_pStyleRefMgr->m_fVariationSeedActive )
		{
			if( pVarSeedPPGData->dwVariationSeed != m_pStyleRefMgr->m_dwVariationSeed )
			{
				m_pStyleRefMgr->m_dwVariationSeed = pVarSeedPPGData->dwVariationSeed;

				if( m_pStyleRefMgr->m_pIDMTrack )
				{
					VERIFY( SUCCEEDED( m_pStyleRefMgr->m_pIDMTrack->SetParam( GUID_SeedVariations, 0, &m_pStyleRefMgr->m_dwVariationSeed ) ) );
				}

				m_nLastEdit = IDS_CHANGE_VARIATION_SEED;
				m_pStyleRefMgr->m_pTimeline->OnDataChanged( (IStyleRefMgr*)m_pStyleRefMgr );
			}

			return S_OK;
		}
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::OnShowProperties

HRESULT CStyleRefStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( m_pStyleRefMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pStyleRefMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	RELEASE( pIFramework );
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// If our property page is already displayed, refresh its data and exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );

        if (m_pPropPageMgr)
        {
            m_pPropPageMgr->RefreshData();
        }

		// release our reference to the property sheet
		RELEASE( pIPropSheet );
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the groupbits and/or variation seed property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pStyleRefMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	RELEASE( pIPropSheet );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::OnRemoveFromPageManager

HRESULT CStyleRefStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::DisplayPropertySheet

HRESULT CStyleRefStrip::DisplayPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				RELEASE( pIPropSheet );
			}
			RELEASE( punk );
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::DoDragDrop

BOOL CStyleRefStrip::DoDragDrop( void )
{
	// Drag drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pStyleRefMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Query ourself for our IDropSource interface
	IDropSource* pIDropSource;
	if( FAILED ( QueryInterface(IID_IDropSource, (void**)&pIDropSource) ) )
	{
		return FALSE;
	}

	DWORD dwEffect = DROPEFFECT_NONE;

	// Create a data object from the selected style references
	HRESULT hr = CreateDataObject( &m_pISourceDataObject, m_lStartDragPosition );
	if( SUCCEEDED( hr ) )
	{
		// We can always copy style references.
		DWORD dwOKDragEffects = DROPEFFECT_COPY;
		if( CanCut() == S_OK )
		{
			// If we can Cut(), allow the user to move the style references as well.
			dwOKDragEffects |= DROPEFFECT_MOVE;
		}

		// Do the Drag/Drop.
		hr = ::DoDragDrop( m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect );

		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					m_pStyleRefMgr->DeleteMarked( UD_DRAGSELECT );
				}
				break;

			default:
				dwEffect = DROPEFFECT_NONE;
				break;
		}
		hr = S_OK;
		RELEASE( m_pISourceDataObject );
	}

	RELEASE( pIDropSource );

	m_pStyleRefMgr->UnMarkStyleRefs(UD_DRAGSELECT);
	m_pStyleRefMgr->SyncWithDirectMusic();

	if( dwEffect != DROPEFFECT_NONE )
	{
		if( m_nStripIsDragDropSource == 2 )
		{
			// Drag/drop target and source are the same StyleRef strip
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_UNDO_MOVE;
				m_pStyleRefMgr->OnDataChanged();
				// Notify the other strips of possible TimeSig change
				m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pStyleRefMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_nLastEdit = IDS_PASTE;
				m_pStyleRefMgr->OnDataChanged();
				// Notify the other strips of possible TimeSig change
				m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pStyleRefMgr->m_dwGroupBits, NULL );
			}
		}
		else
		{
			if( dwEffect == DROPEFFECT_MOVE )
			{
				m_nLastEdit = IDS_DELETE;
				m_pStyleRefMgr->OnDataChanged();
				// Notify the other strips of possible TimeSig change
				m_pStyleRefMgr->m_pTimeline->NotifyStripMgrs( GUID_TimeSignature, m_pStyleRefMgr->m_dwGroupBits, NULL );
			}
			else
			{
				m_pStyleRefMgr->UnselectAll();
			}
		}
	}

	if( dwEffect == DROPEFFECT_NONE )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::OnLButtonDown

HRESULT CStyleRefStrip::OnLButtonDown( WPARAM wParam, LONG lXPos )
{
	ASSERT( m_pStyleRefMgr != NULL );
	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );

	m_fSingleSelect = FALSE;

	// If we're already dragging, just return
	// BUGBUG: Need to a better indicator
	/*
	if( m_pDragImage )
	{
		return S_OK;
	}
	*/

	// Get Timeline length
	VARIANT var;
	m_pStyleRefMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pStyleRefMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}
	
	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pStyleRefMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// See if there is a style reference under the cursor.
	CStyleRefItem* pStyleRef = GetStyleRefFromPoint( lXPos );
	if( pStyleRef
	&&  pStyleRef->m_StyleListInfo.strName.IsEmpty() == FALSE )
	{
		// There is a StyleRef on this measure
		if( wParam & MK_CONTROL )
		{
			if( pStyleRef->m_fSelected )
			{
				// Do drag/drop
				m_dwStartDragButton = (unsigned long)wParam;
				m_lStartDragPosition = lXPos;
				m_nStripIsDragDropSource = 1;
		
				BOOL fDrop = DoDragDrop();

				m_dwStartDragButton = 0;
				m_nStripIsDragDropSource = 0;

				if( !fDrop )
				{
					pStyleRef->SetSelectFlag( !pStyleRef->m_fSelected );
					m_pStyleRefMgr->UnMarkStyleRefs( UD_CURRENTSELECTION );
					pStyleRef->m_dwBits |= UD_CURRENTSELECTION;
				}
			}
			else
			{
				pStyleRef->SetSelectFlag( !pStyleRef->m_fSelected );
				if( pStyleRef->m_fSelected )
				{
					// Set fields to initiate drag/drop on next mousemove
					m_dwStartDragButton = (unsigned long)wParam;
					m_lStartDragPosition = lXPos;
				}
				m_pStyleRefMgr->UnMarkStyleRefs( UD_CURRENTSELECTION );
				pStyleRef->m_dwBits |= UD_CURRENTSELECTION;
			}
		}
		else if( wParam & MK_SHIFT )
		{
			pStyleRef->SetSelectFlag( TRUE );
			SelectRange( pStyleRef );
		}
		else
		{
			if( pStyleRef->m_fSelected == FALSE )
			{
				m_pStyleRefMgr->UnselectAll();
				pStyleRef->SetSelectFlag( TRUE );
				m_pStyleRefMgr->UnMarkStyleRefs( UD_CURRENTSELECTION );
				pStyleRef->m_dwBits |= UD_CURRENTSELECTION;
			}
			else
			{
				m_fSingleSelect = TRUE;
			}
			
			// Set fields to initiate drag/drop on next mousemove
			m_dwStartDragButton = (unsigned long)wParam;
			m_lStartDragPosition = lXPos;
		}
	}
	else
	{
		// There is not a "real" StyleRef on this measure
		hr = S_OK;
		if( pStyleRef == NULL )
		{
			// Create a "fake" StyleRef
			hr = m_pStyleRefMgr->CreateStyleRef( lXPos, pStyleRef );
		}

		if( SUCCEEDED ( hr ) )
		{
			if( wParam & MK_CONTROL )
			{
				pStyleRef->SetSelectFlag( !pStyleRef->m_fSelected );
				m_pStyleRefMgr->UnMarkStyleRefs( UD_CURRENTSELECTION );
				pStyleRef->m_dwBits |= UD_CURRENTSELECTION;
			}
			else if( wParam & MK_SHIFT )
			{
				pStyleRef->SetSelectFlag( TRUE );
				SelectRange( pStyleRef );
			}
			else
			{
				// Click on empty space deselects all
				m_pStyleRefMgr->UnselectAll();

				pStyleRef->SetSelectFlag( TRUE );
				m_pStyleRefMgr->UnMarkStyleRefs( UD_CURRENTSELECTION );
				pStyleRef->m_dwBits |= UD_CURRENTSELECTION;
			}
		}
	}

	// Redraw the strip and refresh the StyleRef property page
	m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	m_pStyleRefMgr->OnShowProperties();
	if( m_pStyleRefMgr->m_pPropPageMgr )
	{
		m_pStyleRefMgr->m_pPropPageMgr->RefreshData();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::OnRButtonDown

HRESULT CStyleRefStrip::OnRButtonDown( WPARAM wParam, LONG lXPos )
{
	ASSERT( m_pStyleRefMgr != NULL );
	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );

	// Get Timeline length
	VARIANT var;
	m_pStyleRefMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	long lTimelineLength = V_I4( &var );

	// Exit if user clicked past end of Strip
	long lClock;
	m_pStyleRefMgr->m_pTimeline->PositionToClocks( lXPos, &lClock );
	if( lClock >= lTimelineLength )
	{
		return S_OK;
	}

	UnselectGutterRange();

	// Get the item at the mouse click.
	CStyleRefItem* pStyleRef = GetStyleRefFromPoint( lXPos );
	
	if( pStyleRef == NULL )
	{
		// No StyleRef so create a "fake" one
		m_pStyleRefMgr->UnselectAll();
		if( SUCCEEDED ( m_pStyleRefMgr->CreateStyleRef( lXPos, pStyleRef ) ) )
		{
			pStyleRef->SetSelectFlag( TRUE );
		}
	}
	else if( !(wParam & MK_CONTROL)
		 &&  !(wParam & MK_SHIFT) )
	{
		if( pStyleRef )
		{
			if( pStyleRef->m_fSelected == FALSE )
			{
				m_pStyleRefMgr->UnselectAll();
				pStyleRef->SetSelectFlag( TRUE );
			}
		}
	}

	m_pStyleRefMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	
	m_fShowStyleRefProps = TRUE;
	m_pStyleRefMgr->OnShowProperties(); 
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::UnselectGutterRange

void CStyleRefStrip::UnselectGutterRange( void )
{
	ASSERT( m_pStyleRefMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pStyleRefMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pStyleRefMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CStyleRefStrip::SelectRange

HRESULT CStyleRefStrip::SelectRange( CStyleRefItem* pStyleRef )
{
	HRESULT hr = S_OK;

	// Select inclusive, find StyleRef to start from
	CStyleRefItem* pCurrent = m_pStyleRefMgr->CurrentlySelectedStyleRef();

	// Find measure for StyleRef to start from and StyleRef to end at
	DWORD dwEarlyMeasure = (pCurrent) ? pCurrent->m_dwMeasure : 0;
	DWORD dwLateMeasure = pStyleRef->m_dwMeasure;

	// If the order is backwards, swap
	if( dwLateMeasure < dwEarlyMeasure )
	{
		DWORD dwTemp = dwEarlyMeasure;
		dwEarlyMeasure = dwLateMeasure;
		dwLateMeasure = dwTemp;
	}

	// Add empty empty StyleRefs to fill in gaps
	CStyleRefItem* pStyleRefItem = NULL;
	DWORD dwCurrentMeasure = dwEarlyMeasure;
	while( dwCurrentMeasure <= dwLateMeasure )
	{
		if( GetStyleRefFromMeasureBeat(dwCurrentMeasure, 0) == NULL )
		{
			pStyleRefItem = NULL;
			hr = m_pStyleRefMgr->CreateStyleRef( dwCurrentMeasure, pStyleRefItem );
		}
		dwCurrentMeasure++;
	}

	// Unselect all StyleRefs in the strip
	m_pStyleRefMgr->UnselectAllKeepBits();

	// Select all StyleRefs in the range (can't simply select StyleRefs in the
	// above loop, because there may be multiple StyleRefs at the same measure)
	POSITION pos = m_pStyleRefMgr->m_lstStyleRefs.GetHeadPosition();
	while( pos )
	{
		pStyleRefItem = m_pStyleRefMgr->m_lstStyleRefs.GetNext( pos );

		if( pStyleRefItem->m_dwMeasure >= dwEarlyMeasure
		&&	pStyleRefItem->m_dwMeasure <= dwLateMeasure )
		{
			pStyleRefItem->m_fSelected = TRUE;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StyleRefMgr.h ===
// StyleRefMgr.h : Declaration of the CStyleRefMgr

#ifndef __STYLE_REFMGR_H_
#define __STYLE_REFMGR_H_

#include "resource.h"		// main symbols
#include "StyleRefStripMgr.h"
#include "timeline.h"
#include <DMUSProd.h>
#include <afxtempl.h>
#include "proppagemgr.h"
#include <mmsystem.h>
#include <dmusici.h>
#include <dmusicf.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CStyleRefStrip;
class CStyleRefItem;
interface IDirectMusicTrack;
interface IDirectMusicStyle;
interface IDMUSProdRIFFStream;

/////////////////////////////////////////////////////////////////////////////
// CStyleRefMgr
class ATL_NO_VTABLE CStyleRefMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CStyleRefMgr, &CLSID_StyleRefMgr>,
	public IStyleRefMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CStyleRefStrip;
friend CStyleRefItem;
friend PropPageStyleRef;

public:
	CStyleRefMgr();
	~CStyleRefMgr();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_STYLE_REFMGR)

BEGIN_COM_MAP(CStyleRefMgr)
	COM_INTERFACE_ENTRY_IID(IID_IStyleRefMgr,IStyleRefMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IStyleRefMgr methods
	HRESULT STDMETHODCALLTYPE IsMeasureOpen( DWORD dwMeasure );

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

protected:
	HRESULT SyncWithDirectMusic();
	HRESULT SyncTimeSignatures();
	HRESULT SyncStyleBandAndTempo( CStyleRefItem* pStyleRefItem );
	void ClocksToMeasure(MUSIC_TIME mtTime, DWORD& rdwMeasure);
	MUSIC_TIME MeasureToClocks(DWORD dwMeasure);
	HRESULT LoadStyleRefList( IDMUSProdRIFFStream* pIRiffStream, 
								MMCKINFO* pckParent,
								BOOL fPaste,
								MUSIC_TIME mtPasteTime,
								BOOL &fChanged );
	HRESULT LoadStyleRef( IDMUSProdRIFFStream* pIRiffStream, 
							MMCKINFO* pckParent,
							BOOL fPaste,
							MUSIC_TIME mtPasteTime );
	HRESULT LoadStyleRefDesign( LPSTREAM pIStream, 
							MMCKINFO* pckParent );
	HRESULT SaveStyleRefDesign( LPSTREAM pIStream, IDMUSProdRIFFStream* pIRiffStream );
	IDMUSProdNode* FindStyle( CString strStyleName, IStream* pIStream );
	HRESULT SaveStyleReference(
		IStream* pIStream, IDMUSProdRIFFStream* pIRiffStream, CStyleRefItem* pStyleRefItem, MUSIC_TIME mtOffset );
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode );
	HRESULT SetStyleReference( IDMUSProdNode* pINewStyleDocRootNode, CStyleRefItem* pItem );
	HRESULT STDMETHODCALLTYPE OnDataChanged();
	void	EmptyStyleRefList();
	void	InsertByAscendingTime( CStyleRefItem *pStyleRef );
	void	GetBoundariesOfSelectedStyleRefs( long *plStart, long *plEnd );
	BOOL	DeleteBetweenTimes( long lStart, long lEnd );

	BOOL	SelectSegment(long begintime, long endtime);

protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CStyleRefItem*> m_lstStyleRefs;
	IDMUSProdFramework* 		m_pDMProdFramework;
	CPropertyPage*				m_pPropertyPage;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwVariationSeed;
	BOOL						m_fVariationSeedActive;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	IDMUSProdNode*				m_pISegmentNode; // DocRoot node of Segment
	BOOL						m_fDirty;

	CStyleRefStrip*				m_pStyleRefStrip;
	CString 					m_strLastStyleName;

protected:
	HRESULT DeleteSelectedStyleRefs();
	HRESULT SaveSelectedStyleRefs(LPSTREAM pIStream, MUSIC_TIME mtOffset);
	HRESULT GetDirectMusicStyle(IDMUSProdNode* pIStyleDocRoot, IDirectMusicStyle** ppIStyle);
	HRESULT CreateStyleRef( long lXPos, CStyleRefItem*& rpStyleRef );
	HRESULT CreateStyleRef( DWORD dwMeasure, CStyleRefItem*& rpStyleRef );

// general helpers
	void MarkSelectedStyleRefs(DWORD flags);
	void UnMarkStyleRefs(DWORD flags);
	void DeleteMarked(DWORD flags);
	void UnselectAllKeepBits();
	void UnselectAll();
	void SelectAll();
	BOOL RemoveItem( CStyleRefItem* pItem );

// Misc
	BOOL		IsSelected();	// returns if one or more style references are selected.
	CStyleRefItem* FirstSelectedStyleRef();
	CStyleRefItem* FirstSelectedRealStyleRef();
	CStyleRefItem* CurrentlySelectedStyleRef();
};


class CStyleRefStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CStyleRefMgr;

public:
	CStyleRefStrip( CStyleRefMgr* pStyleRefMgr );
	~CStyleRefStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT 	CreateDataObject(IDataObject**, long position);

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	CWnd*	GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL bDropNotEditPaste, BOOL &fChanged, CStyleRefItem** pSyncBandTempoItem );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

private:
	HRESULT	DisplayPropertySheet( IDMUSProdTimeline* );
	void UnselectGutterRange( void );

protected:
// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LONG lXPos );
	HRESULT OnRButtonDown( WPARAM wParam, LONG lXPos );
	BOOL DoDragDrop();

	long				m_cRef;
	CStyleRefMgr*		m_pStyleRefMgr;
	IDMUSProdStripMgr*	m_pStripMgr;

	LONG			m_lGutterBeginSelect;
	LONG			m_lGutterEndSelect;
	BOOL			m_bGutterSelected;	// whether the gutter select is selected, use

	BOOL			m_bSelecting;
	BOOL			m_bContextMenuPaste;

private:
	CStyleRefItem* GetStyleRefFromPoint( long lPos );
	CStyleRefItem* GetStyleRefFromMeasureBeat( DWORD dwMeasure, BYTE bBeat );
	HRESULT SelectRange( CStyleRefItem* pStyleRef );

	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	short		m_nStripIsDragDropSource;	
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	UINT		m_cfStyleRefList;			// CF_STYLEREFLIST Clipboard format
	UINT		m_cfStyle;					// CF_STYLE Clipboard format
	LONG		m_lStartDragPosition;	// xpos where drag was started
	UINT		m_nLastEdit;			// resource id of last edit
	BOOL		m_fShowStyleRefProps;		// if TRUE, show StyleRef property page, else show group property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	BOOL		m_fSingleSelect;
	BOOL		m_fInRightClickMenu;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
};
#endif //__STYLE_REFMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\PropPageMgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include <staticproppagemanager.h>

class PropPageTempo;

class CTempoPropPageMgr : CStaticPropPageManager
{
	friend PropPageTempo;
public:
	CTempoPropPageMgr();
	~CTempoPropPageMgr();

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

	// IDMUSProdPropPageManager methods
	HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
	HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE RefreshData();

private:
	PropPageTempo*			m_pPropPageTempo;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\PropPageTempo.cpp ===
// PropPageTempo.cpp : implementation file
//

#include "stdafx.h"
#include <DMUSProd.h>
#include <Conductor.h>
#include "PropTempo.h"
#include "PropPageMgr.h"
#include "PropPageTempo.h"
#include <dmusici.h>
#include <math.h>
#include "TempoMgr.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DIALOG_LEN 15

// CLockoutNotification class

CLockoutNotification::CLockoutNotification( HWND hWnd )
{
	// prevent control notifications from being dispatched
	m_pThreadState = AfxGetThreadState();
	m_hWndOldLockout = m_pThreadState->m_hLockoutNotifyWindow;
	m_fReset = FALSE;
	if( m_hWndOldLockout != hWnd )
	{
		m_fReset = TRUE;
		m_pThreadState->m_hLockoutNotifyWindow = hWnd;
	}
}

CLockoutNotification::~CLockoutNotification()
{
	// Reinstate control notifications
	if( m_fReset )
	{
		m_pThreadState->m_hLockoutNotifyWindow = m_hWndOldLockout;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr constructor/destructor

CTempoPropPageMgr::CTempoPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPageTempo = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CTempoPropPageMgr::~CTempoPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageTempo )
	{
		delete m_pPropPageTempo;
		m_pPropPageTempo = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}


/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr::QueryInterface

HRESULT STDMETHODCALLTYPE CTempoPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Just call the base class implementation
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};


/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr::GetPropertySheetTitle

HRESULT STDMETHODCALLTYPE CTempoPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	// Get and store the title.
	strTitle.LoadString( IDS_PROPPAGE_TEMPO );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr::GetPropertySheetPages

HRESULT STDMETHODCALLTYPE CTempoPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Tempo tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageTempo)
		m_pPropPageTempo = new PropPageTempo();

	if( m_pPropPageTempo )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageTempo->m_psp, sizeof(PROPSHEETPAGE) );

		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageTempo->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// CTempoPropPageMgr::RefreshData

HRESULT STDMETHODCALLTYPE CTempoPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropTempo* pTempo;
	if( m_pIPropPageObject == NULL )
	{
		pTempo = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pTempo ) ) )
	{
		return E_FAIL;
	}
	if (m_pPropPageTempo )
	{
		// pTempo may be NULL, meaning multiple items are selected
		m_pPropPageTempo->SetTempo( pTempo );
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// PropPageTempo property page

IMPLEMENT_DYNCREATE(PropPageTempo, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// PropPageTempo constructor/destructor

PropPageTempo::PropPageTempo(): CPropertyPage(PropPageTempo::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

//	CPropertyPage(IDD_TEMPO_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageTempo)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_fValidTempo = FALSE;
	m_fNeedToDetach = FALSE;
	m_fMultipleSelect = FALSE;
}

PropPageTempo::~PropPageTempo()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTempo::DoDataExchange

void PropPageTempo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageTempo)
	DDX_Control(pDX, IDC_SPIN_TICK, m_spinTick);
	DDX_Control(pDX, IDC_EDIT_TICK, m_editTick);
	DDX_Control(pDX, IDC_SPIN_TEMPO, m_spinTempo);
	DDX_Control(pDX, IDC_EDIT_BEAT, m_editBeat);
	DDX_Control(pDX, IDC_EDIT_TEMPO, m_editTempo);
	DDX_Control(pDX, IDC_EDIT_MEASURE, m_editMeasure);
	DDX_Control(pDX, IDC_SPIN_MEASURE, m_spinMeasure);
	DDX_Control(pDX, IDC_SPIN_BEAT, m_spinBeat);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageTempo, CPropertyPage)
	//{{AFX_MSG_MAP(PropPageTempo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_BEAT, OnDeltaposSpinBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_MEASURE, OnDeltaposSpinMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_BEAT, OnKillfocusEditBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_TEMPO, OnKillfocusEditTempo)
	ON_EN_KILLFOCUS(IDC_EDIT_MEASURE, OnKillfocusEditMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TEMPO, OnDeltaposSpinTempo)
	ON_EN_KILLFOCUS(IDC_EDIT_TICK, OnKillfocusEditTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TICK, OnDeltaposSpinTick)
	ON_WM_KILLFOCUS()
	ON_EN_UPDATE(IDC_EDIT_TEMPO, OnUpdateEditTempo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageTempo custom functions

/////////////////////////////////////////////////////////////////////////////
// PropPageTempo::SetTempo

void PropPageTempo::SetTempo( const CPropTempo* pTempo )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pTempo == NULL || (pTempo->m_wFlags & BF_MULTIPLE) )
	{
		// prevent control notifications from being dispatched when changing edit text
		CLockoutNotification LockoutNotification( m_hWnd );
		m_fValidTempo = FALSE;
		m_fMultipleSelect = (pTempo != NULL) ? TRUE : FALSE;
		EnableControls( FALSE );
		m_Tempo.Clear();
		return;
	}

	m_fMultipleSelect = FALSE;

	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		m_fValidTempo = TRUE;
		m_Tempo.Copy( pTempo );
		return;
	}

	// Here you update the property page based on the new data.
	// It is usually profitable to check to see if the data actually changed
	// before updating the controls in the property page.
	EnableControls( TRUE );

	// prevent control notifications from being dispatched when changing edit text
	CLockoutNotification LockoutNotification( m_hWnd );

	CString strTemp, strTemp2;
	strTemp.Format("%.2f", pTempo->m_dblTempo );
	m_editTempo.GetWindowText( strTemp2 );
	if( strTemp2 != strTemp )
	{
		m_editTempo.SetWindowText( strTemp );
	}

	if( m_spinMeasure.GetPos() != pTempo->m_lMeasure + 1 )
	{
		m_spinMeasure.SetPos( pTempo->m_lMeasure + 1 );
	}
	if( m_spinBeat.GetPos() != pTempo->m_lBeat + 1 )
	{
		m_spinBeat.SetPos( pTempo->m_lBeat + 1 );
	}
	if( (m_editTick.GetWindowTextLength() == 0) || (m_spinTick.GetPos() != pTempo->m_lOffset) )
	{
		m_editTick.SetWindowText("0");
		m_spinTick.SetPos( pTempo->m_lOffset );
	}

	m_fValidTempo = TRUE;
	m_Tempo.Copy( pTempo );
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTempo message handlers

/////////////////////////////////////////////////////////////////////////////
// PropPageTempo::OnCreate

int PropPageTempo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTempo::OnDestroy

void PropPageTempo::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();	
}


/////////////////////////////////////////////////////////////////////////////
// PropPageTempo::OnInitDialog

BOOL PropPageTempo::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// TODO: Implement range limits for edit controls?
	/*
	if( m_pTempoMgr && m_pTempoMgr->m_pTimeline )
	{
		VARIANT var;
		if( FAILED( m_pTempoMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var ) ) )
		{
			ASSERT(FALSE);
			return FALSE;
		}

		long lMeasure;
		if( FAILED( m_pTempoMgr->m_pTimeline->ClocksToMeasureBeat( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, V_I4(&var), &lMeasure, NULL ) ) )
		{
			ASSERT(FALSE);
			return FALSE;
		}
		// Ensure lMeasure is at least 1
		lMeasure = max( 1, lMaxMeasure );

		// Set range of Measure control
		TCHAR tcstr[DIALOG_LEN];
		_itot( lMeasure + 1, tcstr, 10 );
		m_editMeasure.LimitText( _tcslen( tcstr ) );
		m_spinMeasure.SetRange( 1, lMeasure );

		m_spinBeat.SetRange( 1, 256 );
		m_editBeat.LimitText( 3 );

		m_spinTick.SetRange( -32768, 32767 );
		m_editTick.LimitText( 5 );
	}
	else
	*/
	{
		//ASSERT(FALSE);
		m_spinMeasure.SetRange( 1, 32767 );
		m_editMeasure.LimitText( 5 );

		m_spinBeat.SetRange( 1, 256 );
		m_editBeat.LimitText( 3 );

		m_spinTick.SetRange( -32768, 32767 );
		m_editTick.LimitText( 5 );
	}

	m_spinTempo.SetRange( DMUS_TEMPO_MIN, DMUS_TEMPO_MAX );
	m_editTempo.LimitText( 6 ); // 350.00

	if(	m_fValidTempo )
	{
		m_fValidTempo = FALSE;
		// Update the dialog
		SetTempo( &m_Tempo );
	}

	EnableControls( m_fValidTempo );

	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_EVENTSINK_MAP(PropPageTempo, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageTempo)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageTempo::OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditBeat();

	int nNewValue = m_Tempo.m_lBeat + pNMUpDown->iDelta;

	if( nNewValue != m_Tempo.m_lBeat )
	{
		m_Tempo.m_lBeat = nNewValue;
		UpdateObject();
	}

	*pResult = 1;
}

void PropPageTempo::OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillfocusEditMeasure();

	int nNewValue = m_Tempo.m_lMeasure + pNMUpDown->iDelta;

	if( nNewValue != m_Tempo.m_lMeasure )
	{
		m_Tempo.m_lMeasure = nNewValue;
		UpdateObject();
	}

	*pResult = 1;
}

void PropPageTempo::OnKillfocusEditBeat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewBeat;

	m_editBeat.GetWindowText( strNewBeat );

	// Strip leading and trailing spaces
	strNewBeat.TrimRight();
	strNewBeat.TrimLeft();

	if( strNewBeat.IsEmpty() )
	{
		m_spinBeat.SetPos( m_Tempo.m_lBeat + 1 );
	}
	else
	{
		int iNewBeat = _ttoi( strNewBeat );
		if( iNewBeat > 256 )
		{
			iNewBeat = 256;
		}
		else if( iNewBeat < 1 )
		{
			iNewBeat = 1;
		}

		m_spinBeat.SetPos( iNewBeat );
	
		iNewBeat--;
		if( iNewBeat != m_Tempo.m_lBeat )
		{
			m_Tempo.m_lBeat = (BYTE)iNewBeat;
			UpdateObject();
		}
	}
}

void PropPageTempo::OnKillfocusEditMeasure() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewMeasure;

	m_editMeasure.GetWindowText( strNewMeasure );

	// Strip leading and trailing spaces
	strNewMeasure.TrimRight();
	strNewMeasure.TrimLeft();

	if( strNewMeasure.IsEmpty() )
	{
		m_spinMeasure.SetPos( m_Tempo.m_lMeasure + 1 );
	}
	else
	{
		int iNewMeasure = _ttoi( strNewMeasure );
		if( iNewMeasure > 32767 )
		{
			iNewMeasure = 32767;
		}
		else if( iNewMeasure < 1 )
		{
			iNewMeasure = 1;
		}

		m_spinMeasure.SetPos( iNewMeasure );
		
		iNewMeasure--;
		if( iNewMeasure != m_Tempo.m_lMeasure )
		{
			m_Tempo.m_lMeasure = iNewMeasure;
			UpdateObject();
		}
	}
}

void PropPageTempo::OnKillfocusEditTempo() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewTempo;
	m_editTempo.GetWindowText( strNewTempo );

	// Strip leading and trailing spaces
	strNewTempo.TrimRight();
	strNewTempo.TrimLeft();

	// If empty set value to previous one
	if( strNewTempo.IsEmpty() )
	{
		strNewTempo.Format( "%.2f",m_Tempo.m_dblTempo );
		m_editTempo.SetWindowText( strNewTempo );
	}
	else
	{
		// Convert from text to double;
		double dblNewTempo;
		TCHAR *tcstrTmp;
		tcstrTmp = new TCHAR[strNewTempo.GetLength() + 1];
		tcstrTmp[0] = 0;
		if( _stscanf( strNewTempo, "%lf%s", &dblNewTempo, tcstrTmp ) )
		{
			// Check bounds
			if( dblNewTempo > DMUS_TEMPO_MAX )
			{
				dblNewTempo = DMUS_TEMPO_MAX;
				strNewTempo.Format( "%.2f",dblNewTempo );
				m_editTempo.SetWindowText( strNewTempo );
			}
			else if( dblNewTempo < DMUS_TEMPO_MIN )
			{
				dblNewTempo = DMUS_TEMPO_MIN;
				strNewTempo.Format( "%.2f",dblNewTempo );
				m_editTempo.SetWindowText( strNewTempo );
			}

			// If invalid text after the number, reset m_editTempo
			if( tcstrTmp[0] != 0 )
			{
				strNewTempo.Format( "%.2f",dblNewTempo );
				m_editTempo.SetWindowText( strNewTempo );
			}

			// Check if value changed
			if( dblNewTempo != m_Tempo.m_dblTempo )
			{
				m_Tempo.m_dblTempo = dblNewTempo;
				UpdateObject();
			}
		}
		else
		{
			// Invalid data - reset control with previous value
			strNewTempo.Format( "%.2f",m_Tempo.m_dblTempo );
			m_editTempo.SetWindowText( strNewTempo );
		}

		delete tcstrTmp;
	}
}

void PropPageTempo::UpdateObject( void )
{
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Tempo);
	}
}

void PropPageTempo::EnableControls( BOOL fEnable )
{
	if( m_editBeat.GetSafeHwnd() == NULL )
	{
		return;
	}

	m_spinBeat.EnableWindow( fEnable );
	m_spinMeasure.EnableWindow( fEnable );
	m_editBeat.EnableWindow( fEnable );
	m_editMeasure.EnableWindow( fEnable );
	m_editTempo.EnableWindow( fEnable );
	m_spinTempo.EnableWindow( fEnable );
	m_editTick.EnableWindow( fEnable );
	m_spinTick.EnableWindow( fEnable );

	if( !fEnable )
	{
		// If multiply selected, display the 'multiple select' string.
		// If not multiply selected, display the 'none' string.
		CString strText;
		if( (m_fMultipleSelect && strText.LoadString( IDS_MULTIPLE_SELECT ))
		||	(!m_fMultipleSelect && strText.LoadString( IDS_NONE_SELECTED )) )
		{
			m_editTempo.SetWindowText( strText );
		}
		else
		{
			m_editTempo.SetWindowText( NULL );
		}

		m_editMeasure.SetWindowText( NULL );
		m_editBeat.SetWindowText( NULL );
		m_editTick.SetWindowText( NULL );
	}
}

BOOL PropPageTempo::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_fValidTempo )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_TEMPO: 
								{
									CString strNewTempo;
									strNewTempo.Format( "%.2f",m_Tempo.m_dblTempo );
									m_editTempo.SetWindowText( strNewTempo );
								}
								break;

							case IDC_EDIT_MEASURE: 
								m_spinMeasure.SetPos( m_Tempo.m_lMeasure + 1 );
								break;

							case IDC_EDIT_BEAT:
								m_spinBeat.SetPos( m_Tempo.m_lBeat + 1 );								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
	
	return CPropertyPage::PreTranslateMessage( pMsg );
}

void PropPageTempo::OnDeltaposSpinTempo(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fValidTempo )
	{
		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditTempo();

		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Modify the current tempo
		double dblNewValue = floor(m_Tempo.m_dblTempo + pNMUpDown->iDelta);

		// If too small, wrap to DMUS_TEMPO_MAX
		if( dblNewValue < DMUS_TEMPO_MIN )
		{
			dblNewValue = DMUS_TEMPO_MIN;
			m_spinTempo.SetPos( DMUS_TEMPO_MIN );
		}
		// If too large, wrap to DMUS_TEMPO_MIN
		else if( dblNewValue > DMUS_TEMPO_MAX )
		{
			dblNewValue = DMUS_TEMPO_MAX;
			m_spinTempo.SetPos( DMUS_TEMPO_MAX );
		}

		// If value changed
		if( dblNewValue != m_Tempo.m_dblTempo )
		{
			// Set current value
			m_Tempo.m_dblTempo = dblNewValue;
			
			// Update m_editTempo
			CString strNewTempo;
			strNewTempo.Format( "%.2f",m_Tempo.m_dblTempo );
			m_editTempo.SetWindowText( strNewTempo );

			// Update the Tempo strip
			UpdateObject();
		}
	}

	*pResult = 0;
}

void PropPageTempo::OnKillfocusEditTick() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CString strNewTick;

	m_editTick.GetWindowText( strNewTick );

	// Strip leading and trailing spaces
	strNewTick.TrimRight();
	strNewTick.TrimLeft();

	if( strNewTick.IsEmpty() )
	{
		m_spinTick.SetPos( m_Tempo.m_lOffset );
	}
	else
	{
		int iNewTick = _ttoi( strNewTick );
		if( iNewTick > 32767 )
		{
			iNewTick = 32767;
		}
		else if( (iNewTick < 0) && (m_Tempo.m_lBeat > 0 || m_Tempo.m_lMeasure > 0) )
		{
			iNewTick = 0;
		}

		m_spinTick.SetPos( iNewTick );

		if( iNewTick != m_Tempo.m_lOffset )
		{
			m_Tempo.m_lOffset = iNewTick;
			UpdateObject();
		}
	}
}

void PropPageTempo::OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fValidTempo )
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		// Need to do this in case the user clicked the spin control immediately after
		// typing in a value
		OnKillfocusEditTick();

		int nNewValue = m_Tempo.m_lOffset + pNMUpDown->iDelta;

		if( nNewValue != m_Tempo.m_lOffset )
		{
			m_Tempo.m_lOffset = nNewValue;
			UpdateObject();
		}
	}

	*pResult = 1;
}

void PropPageTempo::OnUpdateEditTempo() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_editTempo.GetSafeHwnd() != NULL)
	{
		CString strNewTempo;
		m_editTempo.GetWindowText( strNewTempo );
		if ( !strNewTempo.IsEmpty() )
		{
			// Strip leading and trailing spaces
			strNewTempo.TrimRight();
			strNewTempo.TrimLeft();

			// Convert from text to double;
			double dblNewTempo;
			TCHAR tcstrTmp[DIALOG_LEN];
			tcstrTmp[0] = 0;
			if( _stscanf( strNewTempo, "%lf%s", &dblNewTempo, tcstrTmp ) )
			{
				// Check if value changed and is valid
				if( (dblNewTempo >= DMUS_TEMPO_MIN) && (dblNewTempo <= DMUS_TEMPO_MAX) &&
					(dblNewTempo != m_Tempo.m_dblTempo) )
				{
					m_Tempo.m_dblTempo = dblNewTempo;
					UpdateObject();
				}
			}
		}
	}
}


IMPLEMENT_DYNCREATE( CMyEdit, CEdit )

CMyEdit::CMyEdit() : CEdit()
{
}

LRESULT CMyEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8:  // Backspace
		case '-':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 71: // Home
		case 75: // Left
		case 77: // Right
		case 79: // End
		case 82: // Ins
		case 83: // Del
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleRefStripMgr\StyleRefStripMgr.cpp ===
// StyleRefStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f StyleRefStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "StyleRefStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "StyleRefMgr.h"
#include <dmusici.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_StyleRefMgr, CStyleRefMgr)
END_OBJECT_MAP()

class CStyleRefStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CStyleRefStripMgrApp theApp;

BOOL CStyleRefStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CStyleRefStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_StyleRefMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicStyleTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicStyleTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_STYLEREFSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\PropTempo.h ===
#ifndef __PROPTEMPO_H_
#define __PROPTEMPO_H_

#ifndef MUSIC_TIME
#include <dmusici.h>
#endif

class CTempoItem;

class CPropTempo 
{
public:
				CPropTempo( );
				CPropTempo( const CTempoItem *pTempoItem );
	void		Clear();
	void		ApplyToTempoItem( CTempoItem *pTempoItem ) const;
	void		Copy( const CPropTempo* pPropTempo );

	MUSIC_TIME	m_mtTime;	// The time of this tempo
	double		m_dblTempo;	// The tempo

	long		m_lMeasure;
	long		m_lBeat;
	long		m_lOffset;
	DWORD		m_dwBits;	// Various bits used for selection
	WORD		m_wFlags;	// Various flags
};

// m_dwBits
#define UD_DRAGSELECT		0x0001

// m_wFlags
#define BF_TOPTEMPO			0x0001
#define BF_MULTIPLE			0x0002

#endif // __PROPTEMPO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\PropTempo.cpp ===
#include "stdafx.h"
#include "PropTempo.h"
#include "TempoIO.h"

CPropTempo::CPropTempo()
{
	Clear();
}


CPropTempo::CPropTempo(const CTempoItem *pTempoItem)
{
	m_lMeasure = pTempoItem->m_lMeasure;
	m_lBeat = pTempoItem->m_lBeat;
	m_lOffset = pTempoItem->m_lOffset;
	m_dblTempo = pTempoItem->m_dblTempo;
	m_mtTime = pTempoItem->m_mtTime;
	m_dwBits = 0;
	m_wFlags = 0;
}

void CPropTempo::Clear()
{
	m_lMeasure = 0;
	m_lBeat = 0;
	m_lOffset = 0;
	m_dblTempo = 120;
	m_mtTime = 0;
	m_dwBits = 0;
	m_wFlags = 0;
}

void CPropTempo::ApplyToTempoItem( CTempoItem *pTempoItem ) const
{
	ASSERT( pTempoItem != NULL );
	if ( pTempoItem == NULL )
	{
		return;
	}

	//pTempoItem->m_lMeasure = m_lMeasure;
	//pTempoItem->m_lBeat = m_lBeat;
	//pTempoItem->m_dwOffset = m_dwOffset;
	pTempoItem->m_dblTempo = m_dblTempo;
	//pTempoItem->m_mtTime = m_mtTime;
}

void CPropTempo::Copy( const CPropTempo* pPropTempo )
{
	ASSERT( pPropTempo != NULL );
	if ( pPropTempo == NULL )
	{
		return;
	}

	if( pPropTempo == this )
	{
		return;
	}

	m_lMeasure = pPropTempo->m_lMeasure;
	m_lBeat = pPropTempo->m_lBeat;
	m_lOffset = pPropTempo->m_lOffset;
	m_dblTempo = pPropTempo->m_dblTempo;
	m_mtTime = pPropTempo->m_mtTime;
	m_dwBits = pPropTempo->m_dwBits;
	m_wFlags = pPropTempo->m_wFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TempoStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_TEMPO              101
#define IDR_TEMPOMGR                    102
#define IDS_DELETE                      102
#define IDS_PASTE                       103
#define IDS_INSERT                      104
#define IDD_TEMPO_PROPPAGE              105
#define IDS_TRACK_NAME                  105
#define IDS_EDITOR_NAME                 106
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDS_MULTIPLE_SELECT             108
#define IDS_STRIP_NAME                  109
#define IDS_MOVE                        110
#define IDS_UNDO_CHANGE                 111
#define IDS_UNDO_TRACK_GROUP            112
#define IDS_NONE_SELECTED               113
#define IDR_EDIT_RMENU                  201
#define IDC_EDIT_TEMPO                  223
#define IDC_EDIT_MEASURE                224
#define IDC_EDIT_BEAT                   225
#define IDC_EDIT_TIME                   228
#define IDC_SPIN_MEASURE                229
#define IDC_SPIN_BEAT                   230
#define IDC_SPIN_TEMPO                  232
#define IDC_EDIT_TICK                   233
#define IDC_SPIN_TICK                   234
#define IDM_DRAG_RMENU                  243
#define ID_VIEW_PROPERTIES              32768
#define IDM_CYCLE_TEMPOS                32769
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define ID_EDIT_PASTE_MERGE             32797
#define ID_EDIT_PASTE_OVERWRITE         32798
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        212
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         235
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\PropPageTempo.h ===
#if !defined(AFX_PROPPAGETEMPO_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGETEMPO_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "PropTempo.h"

class CTempoPropPageMgr;
class CTempoMgr;

// PropPageTempo.h : header file
//

class CMyEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CMyEdit)
public:
	CMyEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// PropPageTempo dialog
class CTempoPropPageMgr;

class PropPageTempo : public CPropertyPage
{
	friend CTempoPropPageMgr;
	DECLARE_DYNCREATE(PropPageTempo)

// Construction
public:
	PropPageTempo();
	~PropPageTempo();

// Dialog Data
	//{{AFX_DATA(PropPageTempo)
	enum { IDD = IDD_TEMPO_PROPPAGE };
	CSpinButtonCtrl	m_spinTick;
	CMyEdit	m_editTick;
	CSpinButtonCtrl	m_spinTempo;
	CEdit	m_editBeat;
	CEdit	m_editTempo;
	CEdit	m_editMeasure;
	CSpinButtonCtrl	m_spinMeasure;
	CSpinButtonCtrl	m_spinBeat;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageTempo)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(PropPageTempo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnDeltaposSpinBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposSpinMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditBeat();
	afx_msg void OnKillfocusEditTempo();
	afx_msg void OnKillfocusEditMeasure();
	afx_msg void OnDeltaposSpinTempo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditTick();
	afx_msg void OnDeltaposSpinTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateEditTempo();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void SetTempo( const CPropTempo * pTempo );

protected:
	void UpdateObject( void );
	void EnableControls( BOOL fEnable );

	BOOL					m_fValidTempo;
	BOOL					m_fMultipleSelect;
	CPropTempo				m_Tempo;
	CTempoPropPageMgr *		m_pPropPageMgr;
	BOOL					m_fNeedToDetach;
};

class CLockoutNotification
{
public:
	CLockoutNotification( HWND hWnd);
	~CLockoutNotification();

	BOOL				m_fReset;
	_AFX_THREAD_STATE*	m_pThreadState;
	HWND				m_hWndOldLockout;

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGETEMPO_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\TempoIO.cpp ===
#include "stdafx.h"
#include "TempoIO.h"



CTempoItem::CTempoItem()

{
	m_fSelected = FALSE;
	m_strText.Empty();
}

CTempoItem::CTempoItem(const CTempoItem& Tempo)
{
	m_fSelected = Tempo.m_fSelected;
	m_strText = Tempo.m_strText;
	*((CPropTempo*)this) = Tempo;
}

BOOL CTempoItem::After(const CTempoItem& Tempo)
{
	if( m_mtTime > Tempo.m_mtTime )
	{
		return TRUE;
	}
	return FALSE;
}

BOOL CTempoItem::Before(const CTempoItem& Tempo)
{
	if( m_mtTime < Tempo.m_mtTime )
	{
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\TempoIO.h ===
#ifndef __TEMPOIO_H_
#define __TEMPOIO_H_

#include "PropTempo.h"
#ifndef MUSIC_TIME
#include <dmusici.h>
#endif

typedef struct _PROD_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
	MUSIC_TIME    lOffset;
} PROD_IO_TEMPO_ITEM;

class CTempoItem : public CPropTempo
{
public:
	CTempoItem();
	CTempoItem(const CTempoItem&);

	BOOL After(const CTempoItem& Tempo);
	BOOL Before(const CTempoItem& Tempo);

//	Used to track the selection of the tempo in display.
	BOOL		m_fSelected;	// This tempo is currently selected.
	CString		m_strText;		// Textual representation of the tempo
};

#endif // __TEMPOIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\TempoMgr.cpp ===
// TempoMgr.cpp : implementation file
//

/*--------------
@doc TEMPOSAMPLE
--------------*/

#include "stdafx.h"
#include "TempoIO.h"
#include "TempoMgr.h"
#include "PropPageMgr.h"
#include <dmusicf.h>
#include <RiffStrm.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"
#include <StyleDesigner.h>
#include <Conductor.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr constructor/destructor 

CTempoMgr::CTempoMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pTempoStrip = NULL;
	m_pIDMTrack = NULL;
	m_pDMPerformance = NULL;
	m_posLastGetParam = NULL;

	// Initially the segment isn't playing
	m_pSegmentState = NULL;
	m_mtLoopEnd = 0;
	m_mtLoopStart = 0;
	m_mtStartTime = 0;
	m_mtStartPoint = 0;
	m_dwNumLoops = 0;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// By default, belong to all groups
	m_dwGroupBits = 0xFFFFFFFF;
	m_dwIndex = 0;

	// Initialize the track extras flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
	m_dwProducerOnlyFlags = 0;

	// Initially, have a tempo of 120 at time 0
	CTempoItem *pTempo = new CTempoItem();
	pTempo->m_dblTempo = 120.0;
	pTempo->m_mtTime = 0;
	pTempo->m_strText.Format("%.2f", 120.0);
	m_lstTempos.AddHead( pTempo );

	// Create a TempoStrip
	m_pTempoStrip = new CTempoStrip(this);
	ASSERT( m_pTempoStrip );
}

CTempoMgr::~CTempoMgr()
{
	// Clean up our references
	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );

	if( m_pDMPerformance )
	{
		m_pDMPerformance->Release();
		m_pDMPerformance = NULL;
	}
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}
	if( m_pTempoStrip )
	{
		m_pTempoStrip->Release();
		m_pTempoStrip = NULL;
	}
	if( m_pSegmentState )
	{
		m_pSegmentState->Release();
		m_pSegmentState = NULL;
	}

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}

	// Delete all the tempos in m_lstTempos
	EmptyTempoList();
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr ITempoMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::IsMeasureBeatOpen
/*
HRESULT STDMETHODCALLTYPE CTempoMgr::IsMeasureBeatOpen( long lMeasure, long lBeat )
{
	HRESULT hr = S_FALSE;
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if( pTempoItem->m_lMeasure > lMeasure )
		{
			pos = NULL;
		}
		else if( pTempoItem->m_lMeasure == lMeasure &&
				 pTempoItem->m_lBeat == lBeat )
		{
			hr = S_OK;
			pos = NULL;
		}
	}
	return hr;
}
*/


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr IDMUSProdStripMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetParam

HRESULT STDMETHODCALLTYPE CTempoMgr::GetParam(
		/* [in] */	REFGUID 	rguidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ::IsEqualGUID( rguidType, GUID_TempoParam ) )
	{
		if( pData == NULL )
		{
			return E_POINTER;
		}

		CTempoItem *pTempoItemNext, *pTempoItemCur;
		pTempoItemCur = GetTempoForTime( mtTime, &pTempoItemNext );

		DMUS_TEMPO_PARAM *pDMTempoItem = (DMUS_TEMPO_PARAM *)pData;
		if( pmtNext )
		{
			if( pTempoItemNext )
			{
				*pmtNext = pTempoItemNext->m_mtTime - mtTime;
			}
			else
			{
				*pmtNext = 0;
			}
		}

		if( pTempoItemCur )
		{
			pDMTempoItem->dblTempo = pTempoItemCur->m_dblTempo;
			pDMTempoItem->mtTime = pTempoItemCur->m_mtTime;
			return S_OK;
		}
		else
		{
			pDMTempoItem->dblTempo = 120.0;
			pDMTempoItem->mtTime = 0;
			return S_FALSE;
		}
	}
	else if( ::IsEqualGUID( rguidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pTempoStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SetParam

HRESULT STDMETHODCALLTYPE CTempoMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	UNREFERENCED_PARAMETER( guidType );
	UNREFERENCED_PARAMETER( mtTime );
	UNREFERENCED_PARAMETER( pData );
	return E_NOTIMPL;
	// In an implementation you would want to check guidType against the data type GUIDs
	// that you support.  If it is a known type, copy the value to local storage.  Otherwise
	// return E_INVALIDARG.
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CTempoMgr::IsParamSupported(
		/* [in] */ REFGUID		rguidType)
{
	if( ::IsEqualGUID( rguidType, GUID_TempoParam )
	||  ::IsEqualGUID( rguidType, GUID_Segment_Undo_BSTR ))
	{
		return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CTempoMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	UNREFERENCED_PARAMETER( dwGroupBits );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Update the m_mtTime value of all tempo events
		if( RecomputeTempoTimes() )
		{
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
			OnDataChanged();
		}

		// Redraw our strip
		m_pTimeline->StripInvalidateRect( m_pTempoStrip, NULL, TRUE );
		return S_OK;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Update the Measure/beat value of all tempo events
		RecomputeTempoMeasureBeats();

		// Redraw our strip
		m_pTimeline->StripInvalidateRect( m_pTempoStrip, NULL, TRUE );
		//OnDataChanged();
		return S_OK;
	}

	// New Style just added to Style strip
	if( ::IsEqualGUID( rguidType, GUID_Segment_NewStyleSelected ) )
	{
		MUSIC_TIME* pmtTime = (MUSIC_TIME *)pData;
		IDMUSProdNode* pIStyleNode;
		IDMUSProdStyleInfo* pIStyleInfo;
		double dblTempo;

		// Use dwGroupBits handed to this method
		// dwGroupBits contains GroupBits of the Style track that sent the notification
		if( SUCCEEDED ( m_pTimeline->GetParam( GUID_StyleNode, dwGroupBits, 0, 
											   *pmtTime, NULL, (void *)&pIStyleNode ) ) )
		{
			if( SUCCEEDED ( pIStyleNode->QueryInterface( IID_IDMUSProdStyleInfo, (void**)&pIStyleInfo ) ) )
			{
				if( SUCCEEDED ( pIStyleInfo->GetTempo( &dblTempo ) ) )
				{
					m_pTempoStrip->AddTempo( dblTempo, *pmtTime );
				}
				RELEASE( pIStyleInfo );
			}
			RELEASE( pIStyleNode );
		}
		OnDataChanged();

		// Redraw our strip
		m_pTimeline->StripInvalidateRect( m_pTempoStrip, NULL, TRUE );
		return S_OK;
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_CreateTrack ) )
	{
		// Notify all other StripMgrs that something changed
		// Tempos are global, so don't restrict to just our group(s)
		m_pTimeline->NotifyStripMgrs( GUID_TempoParam, 0xFFFFFFFF, NULL );

		// Notify the Segment designer that we need to be saved, since we have a default tempo
		ASSERT( m_pTempoStrip );
		if( m_pTempoStrip )
		{
			m_pTempoStrip->m_nLastEdit = IDS_INSERT;
			OnDataChanged();
			return S_OK;
		}
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_DeletedTrack ) )
	{
		if( !pData )
		{
			return E_POINTER;
		}

		IDMUSProdTimeline *pTimeline = (IDMUSProdTimeline *) pData;

		// Notify all other StripMgrs that something changed
		// Tempos are global, so don't restrict to just our group(s)
		pTimeline->NotifyStripMgrs( GUID_TempoParam, 0xFFFFFFFF, NULL );
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_Set_Tempo ) )
	{
		if( !pData )
		{
			return E_POINTER;
		}

		DMUS_TEMPO_PARAM *pTempo = (DMUS_TEMPO_PARAM *)pData;
		OnTransportChangeTempo( pTempo->dblTempo );

		return S_OK;
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_Start ) )
	{
		m_pSegmentState = (IDirectMusicSegmentState *)pData;
		if( m_pSegmentState )
		{
			m_pSegmentState->AddRef();

			// If mtLoopEnd is non zero, set m_mtLoopEnd to mtLoopEnd, otherwise use the segment length
			long m_mtLoopEnd;
			IDirectMusicSegment *pSegment;
			if( SUCCEEDED( m_pSegmentState->GetSegment( &pSegment ) ) )
			{
				pSegment->GetLoopPoints( &m_mtLoopStart, &m_mtLoopEnd );
				pSegment->GetRepeats( &m_dwNumLoops );
				if( m_dwNumLoops && (m_mtLoopEnd == 0) )
				{
					MUSIC_TIME mtLength;
					pSegment->GetLength( &mtLength );
					m_mtLoopEnd = mtLength;
				}
				pSegment->Release();
			}
			m_pSegmentState->GetStartPoint( &m_mtStartPoint );
			m_pSegmentState->GetStartTime( &m_mtStartTime );
			//TRACE("Segment Start: %d %d %d %d %d\n", m_mtLoopStart, m_mtLoopEnd, m_dwNumLoops, m_mtStartPoint, m_mtStartTime);
		}
		return S_OK;
	}

	if( ::IsEqualGUID( rguidType, GUID_Segment_Stop ) )
	{
		if( m_pSegmentState )
		{
			m_pSegmentState->Release();
			m_pSegmentState = NULL;
		}
		m_mtLoopEnd = 0;
		m_mtLoopStart = 0;
		m_mtStartTime = 0;
		m_mtStartPoint = 0;
		m_dwNumLoops = 0;
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTempoMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackHeader->guidClassID = CLSID_DirectMusicTempoTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = DMUS_FOURCC_TEMPO_TRACK;
			pioTrackHeader->fccType = NULL;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CTempoMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		// If we were previously attached to a timeline, remove our PropPageObject and strip from it
		if( m_pTimeline )
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->Release();
				m_pPropPageMgr = NULL;
			}
			if ( m_pTempoStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pTempoStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pTempoStrip );
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Set_Tempo, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_NewStyleSelected, m_dwGroupBits );
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		if( V_UNKNOWN( &variant ) )
		{
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// Add the strip to the timeline
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pTempoStrip, CLSID_DirectMusicTempoTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_NewStyleSelected, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Set_Tempo, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwGroupBits );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}

		if( m_pDMPerformance )
		{
			m_pDMPerformance->Release();
			m_pDMPerformance = NULL;
		}

		if( V_UNKNOWN( &variant )
		&&	SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework) ) )
		{
			IDMUSProdComponent* pIComponent = NULL;
			if( SUCCEEDED ( m_pDMProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				IDMUSProdConductor *pIConductor;
				if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
				{
					IUnknown* punk;
					if( SUCCEEDED( pIConductor->GetPerformanceEngine( &punk ) ) )
					{
						punk->QueryInterface( IID_IDirectMusicPerformance, (void **)&m_pDMPerformance );
						punk->Release();
					}
					pIConductor->Release();
				}
				pIComponent->Release();
			}
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			// Can't change the group bits
			//m_dwGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetClassID

HRESULT CTempoMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_TempoMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::IsDirty

HRESULT CTempoMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::Load

HRESULT CTempoMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing tempos
	EmptyTempoList();

	MMCKINFO	ck;
	DWORD		dwByteCount;
	DWORD		dwTempoSize;
	DMUS_IO_TEMPO_ITEM iTempo;
	long		lChunkSize;

	// Load the Track
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case DMUS_FOURCC_TEMPO_TRACK:
			hr = pIStream->Read( &dwTempoSize, sizeof(DWORD), &dwByteCount );
			if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwTempoSize = min( dwTempoSize, sizeof(DMUS_IO_TEMPO_ITEM) );

			lChunkSize = ck.cksize - sizeof(DWORD);

			while(lChunkSize > 0)
			{
				ZeroMemory(	&iTempo, sizeof(DMUS_IO_TEMPO_ITEM) );
				hr = pIStream->Read( &iTempo, dwTempoSize, &dwByteCount );
				if( FAILED( hr ) || dwByteCount != dwTempoSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				lChunkSize -= dwTempoSize;

				CTempoItem* pItem = new CTempoItem;
				if ( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				pItem->m_mtTime = iTempo.lTime;
				pItem->m_dblTempo = iTempo.dblTempo;
				pItem->m_strText.Format("%.2f", pItem->m_dblTempo);

				if( m_pTimeline )
				{
					SetPropTempoBarBeat( (CPropTempo*) pItem );
				}
				InsertByAscendingTime( pItem, FALSE );
			}
			break;
		}
		pIRiffStream->Ascend( &ck, 0 );
	}

	SyncWithDirectMusic();

ON_ERROR:
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::Save

HRESULT CTempoMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a design-time stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusicTempoTrack (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

    MMCKINFO ckMain;

	// Always write a tempo data chunk, even if it will be empty

	// Create the chunk to store the Tempo data
	ckMain.ckid = DMUS_FOURCC_TEMPO_TRACK;
	if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write the structure size
	DWORD dwBytesWritten;
	DWORD dwTempoSize;
	dwTempoSize = sizeof(DMUS_IO_TEMPO_ITEM);
	hr = pIStream->Write( &dwTempoSize, sizeof(DWORD), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	POSITION pos;
	pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if( pTempoItem->m_dblTempo != 0.0 )
		{
			DMUS_IO_TEMPO_ITEM oTempo;
			// Clear out the structure (clears out the padding bytes as well).
			ZeroMemory( &oTempo, sizeof(DMUS_IO_TEMPO_ITEM) );
			oTempo.lTime = pTempoItem->m_mtTime;
			oTempo.dblTempo = pTempoItem->m_dblTempo;

			hr = pIStream->Write( &oTempo, sizeof(DMUS_IO_TEMPO_ITEM), &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_TEMPO_ITEM) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

	// Ascend out of the Tempo data chunk.
	pIRiffStream->Ascend( &ckMain, 0 );

	if( fClearDirty )
	{
		m_fDirty = FALSE;
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetSizeMax

HRESULT CTempoMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	UNREFERENCED_PARAMETER( pcbSize );
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetData

// This method is called by CTempoPropPageMgr to get data to send to the
// Tempo property page.
// The CTempoStrip::GetData() method is called by CTempoStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CTempoMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	// Return a pointer to the currently selected tempo.
	BOOL fMultipleSelect = FALSE;
	CTempoItem* pFirstTempoItem = NULL;
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if ( pTempoItem->m_fSelected && (pTempoItem->m_dblTempo != 0.0) )
		{
			pFirstTempoItem = pTempoItem;
			while( pos && !fMultipleSelect )
			{
				pTempoItem = m_lstTempos.GetNext( pos );
				if ( pTempoItem->m_fSelected && (pTempoItem->m_dblTempo != 0.0) )
				{
					fMultipleSelect = TRUE;
					break;
				}
			}
			break;
		}
	}

	if( pFirstTempoItem )
	{
		m_SelectedPropTempo.Copy( (CPropTempo*)pFirstTempoItem );
		m_SelectedPropTempo.m_wFlags |= fMultipleSelect ? BF_MULTIPLE : 0;
		*ppData = &m_SelectedPropTempo;
		return S_OK;
	}

	// Nothing selected, multiple items selected, or no 'real' tempos selected
	*ppData = NULL;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SetData

// This method is called by CTempoPropPageMgr in response to user actions
// in the Tempo Property page.  It changes the currenly selected Tempo. 
HRESULT STDMETHODCALLTYPE CTempoMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Get a pointer to the currently selected tempo.
	CTempoItem* pTempoItem = FirstSelectedTempo();

	if ( pTempoItem )
	{
		CPropTempo* pTempo = (CPropTempo*)pData;

		if( (pTempo->m_lMeasure != pTempoItem->m_lMeasure) ||
			(pTempo->m_lBeat != pTempoItem->m_lBeat) ||
			(pTempo->m_lOffset != pTempoItem->m_lOffset) )
		{
			MUSIC_TIME mtOrigTime = pTempoItem->m_mtTime;
			pTempoItem->m_lMeasure = pTempo->m_lMeasure;
			pTempoItem->m_lBeat = pTempo->m_lBeat;
			pTempoItem->m_lOffset = pTempo->m_lOffset;
			SetPropTempoTime( pTempoItem );
			SetPropTempoBarBeat( pTempoItem );

			// Get maximum number of measures
			long lMaxMeasure;
			VARIANT var;
			m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
			MUSIC_TIME mtMaxTimelineLength = V_I4( &var );
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtMaxTimelineLength, &lMaxMeasure, NULL );
			lMaxMeasure--;
			// Ensure lMaxMeasure is at least 0
			lMaxMeasure = max( 0, lMaxMeasure );

			// Enforce measure boundary
			if( pTempoItem->m_lMeasure > lMaxMeasure )
			{
				pTempoItem->m_mtTime = mtMaxTimelineLength - 1;
				SetPropTempoBarBeat( pTempoItem );
			}

			if( pTempoItem->m_mtTime != mtOrigTime )
			{
				m_pTempoStrip->m_nLastEdit = IDS_MOVE;

				// Reposition item in tempo list
				POSITION pos = m_lstTempos.Find( pTempoItem );
				ASSERT( pos != NULL );
				if( pos )
				{
					m_lstTempos.RemoveAt( pos );
					if( pos == m_posLastGetParam )
					{
						m_posLastGetParam = NULL;
					}
					InsertByAscendingTime( pTempoItem, FALSE );
				}
			}

			// Refresh property page
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
		}
		else if( pTempo->m_dblTempo != pTempoItem->m_dblTempo )
		{
			pTempoItem->m_strText.Format("%.2f", pTempo->m_dblTempo);
			pTempoItem->m_dblTempo = pTempo->m_dblTempo;
			m_pTempoStrip->m_nLastEdit = IDS_UNDO_CHANGE;

			if( m_pSegmentState )
			{
				if( pTempoItem == GetTempoForTime(GetCurrentOffset(), NULL) )
				{
					// Change tempo now!!!
					DMUS_TEMPO_PMSG* pTempo;

					if( SUCCEEDED( m_pDMPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
						(DMUS_PMSG**)&pTempo ) ) )
					{
						// Queue tempo event
						ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
						pTempo->dblTempo = pTempoItem->m_dblTempo;
						pTempo->dwFlags = DMUS_PMSGF_REFTIME;
						pTempo->dwType = DMUS_PMSGT_TEMPO;
						m_pDMPerformance->SendPMsg( (DMUS_PMSG*)pTempo );
					}
				}
			}
		}
		else
		{
			return S_OK;
		}
			
		// Redraw the tempo strip
		// TODO: Should be smarter and only redraw the tempo that changed
		m_pTimeline->StripInvalidateRect( m_pTempoStrip, NULL, TRUE );

		// Let our hosting editor and the music engine know about the changes
		OnDataChanged();
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CTempoMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CTempoPropPageMgr* pPPM = new CTempoPropPageMgr;
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CTempoMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CTempoMgr::OnDataChanged( void)
{
	SyncWithDirectMusic();

	ASSERT( m_pTimeline );
	if ( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (IDMUSProdStripMgr*)this );

	// Notify all other StripMgrs that something changed
	// Tempos are global, so don't restrict to just our group(s)
	m_pTimeline->NotifyStripMgrs( GUID_TempoParam, 0xFFFFFFFF, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::DeleteSelectedTempos

HRESULT CTempoMgr::DeleteSelectedTempos()
{
	POSITION pos2, pos1 = m_lstTempos.GetHeadPosition();
	while( pos1 )
	{
		// Need to save current position, since GetNext will set pos1 to point
		// to the next tempo.
		pos2 = pos1;
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos1 );
		if ( pTempoItem->m_fSelected )
		{
			// Remove the tempo from the current position.  pos1 will
			// still be valid, and it will still point to the next tempo.
			m_lstTempos.RemoveAt( pos2 );
			if( pos2 == m_posLastGetParam )
			{
				m_posLastGetParam = NULL;
			}
			delete pTempoItem;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SaveSelectedTempos

HRESULT CTempoMgr::SaveSelectedTempos(LPSTREAM pIStream, long lOffset)
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Tempo list has anything in it, look for selected Tempos
	if ( !m_lstTempos.IsEmpty() )
	{
		POSITION pos;

		// Create the chunk to wrap our data in
		MMCKINFO ckMain;
		ckMain.ckid = DMUS_FOURCC_TEMPO_TRACK;
		if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write the structure size
		DWORD dwBytesWritten;
		DWORD dwTempoSize;
		dwTempoSize = sizeof(PROD_IO_TEMPO_ITEM);
		hr = pIStream->Write( &dwTempoSize, sizeof(DWORD), &dwBytesWritten );
		if( FAILED( hr ) || dwBytesWritten != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Now, write out each selected item
		pos = m_lstTempos.GetHeadPosition();
		while( pos )
		{
			CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
			if( pTempoItem->m_fSelected && (pTempoItem->m_dblTempo != 0.0) )
			{
				PROD_IO_TEMPO_ITEM oTempo;
				oTempo.lTime = pTempoItem->m_mtTime - lOffset;
				oTempo.dblTempo = pTempoItem->m_dblTempo;
				oTempo.lOffset = pTempoItem->m_lOffset;

				DWORD dwBytesWritten;
				hr = pIStream->Write( &oTempo, sizeof(PROD_IO_TEMPO_ITEM), &dwBytesWritten );
				if( FAILED( hr ) || dwBytesWritten != sizeof(PROD_IO_TEMPO_ITEM) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
			}
		}

		// Ascend out of the chunk our data is in
		pIRiffStream->Ascend( &ckMain, 0 );
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::MarkSelectedTempos

void CTempoMgr::MarkSelectedTempos( DWORD dwFlags )
{
	// For all selected items, OR dwFlags with the item's m_dwBits member.
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if ( pTempoItem->m_fSelected )
		{
			pTempoItem->m_dwBits |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::DeleteMarked

void CTempoMgr::DeleteMarked( DWORD dwFlags )
{
	// For all items, if the item's m_dwBits member has any of the same bits set as
	// dwFlags (m_dwBits & dwFlags is non-zero), delete it.
	POSITION pos2, pos1 = m_lstTempos.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos1 );
		if ( pTempoItem->m_dwBits & dwFlags )
		{
			m_lstTempos.RemoveAt( pos2 );
			if( pos2 == m_posLastGetParam )
			{
				m_posLastGetParam = NULL;
			}
			delete pTempoItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::UnMarkTempos

void CTempoMgr::UnMarkTempos( DWORD dwFlags )
{
	// For all items, clear the bits in the item's m_dwBits member that are also set in dwFlags.
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		m_lstTempos.GetNext( pos )->m_dwBits &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::UnselectAll

bool CTempoMgr::UnselectAll()
{
	bool fChanged = false;

	// Unselect all items in the list
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if( pTempoItem->m_fSelected )
		{
			pTempoItem->m_fSelected = FALSE;
			fChanged = true;
		}
	}

	if( m_pTempoStrip )
	{
		m_pTempoStrip->m_pCurrentlySelectedTempoItem = NULL;
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SelectAll

void CTempoMgr::SelectAll()
{
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if( (pTempoItem->m_dblTempo != 0.0) )
		{
			pTempoItem->m_fSelected = TRUE;
		}
		// Unselect all 'fake' items
		else
		{
			pTempoItem->m_fSelected = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::IsSelected

BOOL CTempoMgr::IsSelected()
{
	// If anything is selected, return TRUE.
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if ( (pTempoItem->m_dblTempo != 0.0) && pTempoItem->m_fSelected )
		{
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::FirstSelectedTempo

CTempoItem* CTempoMgr::FirstSelectedTempo()
{
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if ( pTempoItem->m_fSelected )
		{
			return pTempoItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SelectSegment

BOOL CTempoMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	long lBeginMeas, lBeginBeat, lEndMeas, lEndBeat;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBeginTime, &lBeginMeas, &lBeginBeat );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEndTime, &lEndMeas, &lEndBeat );

	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		pTempoItem->m_fSelected = FALSE;
		if( lBeginMeas < pTempoItem->m_lMeasure && pTempoItem->m_lMeasure < lEndMeas )
		{
			pTempoItem->m_fSelected = TRUE;
			result = TRUE;
		}
		else if( lBeginMeas == pTempoItem->m_lMeasure )
		{
			if( lEndMeas == pTempoItem->m_lMeasure )
			{
				if( lBeginBeat <= pTempoItem->m_lBeat && pTempoItem->m_lBeat <= lEndBeat )
				{
					pTempoItem->m_fSelected = TRUE;
					result = TRUE;
				}
			}
			else
			{
				if( lBeginBeat <= pTempoItem->m_lBeat )
				{
					pTempoItem->m_fSelected = TRUE;
					result = TRUE;
				}
			}
		}
		else if( lEndMeas == pTempoItem->m_lMeasure )
		{
			if( pTempoItem->m_lBeat <= lEndBeat )
			{
				pTempoItem->m_fSelected = TRUE;
				result = TRUE;
			}
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::EmptyTempoList

void CTempoMgr::EmptyTempoList(void)
{
	// Remove all items from the list
	if( !m_lstTempos.IsEmpty() )
	{
		m_posLastGetParam = NULL;
		CTempoItem *pTempoItem;
		while ( !m_lstTempos.IsEmpty() )
		{
			pTempoItem = m_lstTempos.RemoveHead();
			delete pTempoItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::InsertByAscendingTime

void CTempoMgr::InsertByAscendingTime( CTempoItem *pTempo, BOOL fPaste )
{
	// Insert pTempo into the list in ascending order, determined by the values of
	// the item's m_mtTime member.
	ASSERT( pTempo );
	if ( pTempo == NULL )
	{
		return;
	}

	POSITION posCurrent, posNext = m_lstTempos.GetHeadPosition();
	while( posNext )
	{
		posCurrent = posNext;
		CTempoItem* pTempoItem = m_lstTempos.GetNext( posNext );
		if ( fPaste )
		{
			if ( pTempoItem->m_mtTime == pTempo->m_mtTime )
			{
				// replace item
				m_lstTempos.InsertBefore( posCurrent, pTempo );
				m_lstTempos.RemoveAt( posCurrent );
				if( posCurrent == m_posLastGetParam )
				{
					m_posLastGetParam = NULL;
				}
				delete pTempoItem;
				return;
			}
		}
		if ( pTempoItem->m_mtTime > pTempo->m_mtTime )
		{
			// insert before posCurrent (which is current position of pTempoItem)
			m_lstTempos.InsertBefore( posCurrent, pTempo );
			return;
		}
	}
	// insert at end of list
	m_lstTempos.AddTail( pTempo );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::RemoveItem

BOOL CTempoMgr::RemoveItem( CTempoItem* pItem )
{
	// Removes the specified item from the list
	POSITION pos2;
	POSITION pos1 = m_lstTempos.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstTempos.GetNext( pos1 ) == pItem )
		{
			m_lstTempos.RemoveAt( pos2 );
			if( pos2 == m_posLastGetParam )
			{
				m_posLastGetParam = NULL;
			}
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SyncWithDirectMusic

HRESULT CTempoMgr::SyncWithDirectMusic(  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

	// 1. persist the strip as a tempo track to a stream
	IStream* pIMemStream = NULL;
	IPersistStream* pIPersistStream = NULL;
	hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_CurrentVersion, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
		hr = Save(pIMemStream, FALSE);
		if ( SUCCEEDED( hr ) )
		{
			// 2. load the stream into m_pIDMTrack
			hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
			if ( SUCCEEDED( hr ) )
			{
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load(pIMemStream);
				pIPersistStream->Release();
			}
		}
		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SetPropTempoBarBeat

void CTempoMgr::SetPropTempoBarBeat( CPropTempo *pTempo )
{
	// Fill in the item's m_lMeasure, m_lBeat, and m_lOffset members, based on
	// the timesignature(s) for the group(s) we belong to.
	ASSERT( pTempo && m_pTimeline );
	if( !pTempo || !m_pTimeline )
	{
		return;
	}

	// If our time value is negative, set the offset to our time value and everything else
	// to zero.
	if( pTempo->m_mtTime < 0 )
	{
		pTempo->m_lMeasure = 0;
		pTempo->m_lBeat = 0;
		pTempo->m_lOffset = pTempo->m_mtTime;
		return;
	}

	// Our time value is positive (or 0)

	// Let the Timeline decide which Measure and Beat we're in, and get the clock position
	// of that measure and beat.
	long lMeasure, lBeat, lClocks;
	if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, pTempo->m_mtTime, &lMeasure, &lBeat ) ) && 
		SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &lClocks )))
	{
		pTempo->m_lMeasure = lMeasure;
		pTempo->m_lBeat = lBeat;
		pTempo->m_lOffset = pTempo->m_mtTime - lClocks;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::SetPropTempoTime

BOOL CTempoMgr::SetPropTempoTime( CPropTempo *pTempo )
{
	BOOL fChanged = FALSE;

	// Fill in the item's m_mtTime member, based on the timesignature(s) for the group(s)
	// we belong to, and the item's m_lMeasure, m_lBeat, and m_lOffset members
	ASSERT( pTempo && m_pTimeline );
	if( !pTempo || !m_pTimeline )
	{
		return FALSE;
	}

	// Convert m_lMeasure and m_lBeat to a clock value
	long lClocks;
	if( SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, pTempo->m_lMeasure, pTempo->m_lBeat, &lClocks )))
	{
		lClocks += pTempo->m_lOffset;
		if( lClocks < 0 )
		{
			lClocks = 0;
		}
		if( lClocks != pTempo->m_mtTime )
		{
			pTempo->m_mtTime = lClocks;
			fChanged = TRUE;
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::RecomputeTempoMeasureBeats

void CTempoMgr::RecomputeTempoMeasureBeats()
{
	// For all items, call SetPropTempoBarBeat to update their m_lMeasure, m_lBeat,
	// and m_lOffset members
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		SetPropTempoBarBeat( static_cast<CPropTempo*>(m_lstTempos.GetNext( pos )) );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetNextGreatestUniqueTime

MUSIC_TIME CTempoMgr::GetNextGreatestUniqueTime( MUSIC_TIME mtOrigTime )
{
	DMUS_TIMESIGNATURE dmTimeSig;
	MUSIC_TIME mtTime;
	long lMeasure = 0;
	long lBeat = 0;
	long lTick = 0;

	// Calc measure, beat, tick associated with mtOrigTime
	if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, mtOrigTime, &lMeasure, &lBeat ) )
	&&	SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &lTick ) ) )
	{
		lTick = mtOrigTime - lTick;
	}

	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );

		if( pTempoItem->m_lMeasure > lMeasure )
		{
			break;
		}

		// Get the time signature for this measure
		if( SUCCEEDED ( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, pTempoItem->m_lMeasure, 0, &mtTime ) ) )
		{
			m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, 0, mtTime, NULL, &dmTimeSig );
			if( pTempoItem->m_lBeat > dmTimeSig.bBeatsPerMeasure )
			{
				break;
			}

			if( pTempoItem->m_lMeasure == lMeasure
			&&  pTempoItem->m_lBeat == lBeat )
			{
				lTick = pTempoItem->m_lOffset + 1;

				// Take care of measure/beat rollover
				if( SUCCEEDED ( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &mtTime ) ) )
				{
					mtTime += lTick;

					if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, mtTime, &lMeasure, &lBeat ) )
					&&	SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &lTick ) ) )
					{
						lTick = mtTime - lTick;
					}
				}
			}
		}
	}

	mtTime = mtOrigTime;
	if( SUCCEEDED ( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &mtTime ) ) )
	{
		mtTime += lTick;
	}

	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::RecomputeTempoTimes

BOOL CTempoMgr::RecomputeTempoTimes()
{
	MUSIC_TIME mtTime;
	long lMeasure = 0;
	long lBeat = 0;
	long lTick = 0;
	POSITION pos2;

	if( m_pTimeline == NULL )
	{
		return FALSE;
	}

	BOOL fChanged = FALSE;

	// For all items, call SetPropTempoTime to update their m_mtTime member
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );

		if( pTempoItem->m_dblTempo == 0.0 )
		{
			m_lstTempos.RemoveAt( pos2 );
			if( pos2 == m_posLastGetParam )
			{
				m_posLastGetParam = NULL;
			}
			delete pTempoItem;
		}
		else if( pTempoItem->m_mtTime > 0 )
		{
			if( SUCCEEDED ( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, pTempoItem->m_lMeasure, pTempoItem->m_lBeat, &mtTime ) ) )
			{
				mtTime += pTempoItem->m_lOffset;

				if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, mtTime, &lMeasure, &lBeat ) )
				&&	SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &lTick ) ) )
				{
					lTick = mtTime - lTick;
				}
			}

			if( pTempoItem->m_mtTime != mtTime
			||	pTempoItem->m_lMeasure != lMeasure
			||	pTempoItem->m_lBeat != lBeat
			||	pTempoItem->m_lOffset != lTick )
			{
				m_lstTempos.RemoveAt( pos2 );
				if( pos2 == m_posLastGetParam )
				{
					m_posLastGetParam = NULL;
				}

				if( pTempoItem->m_lMeasure != lMeasure )
				{
					// This would happen when moving from 7/4 to 4/4, for example
					// Tempos on beat 7 would end up on next measure's beat 3

					MUSIC_TIME mtTempTime = mtTime;
					long lTempMeasure = lMeasure;
					long lTempBeat = lBeat;
					long lTempTick = lTick;

					while( pTempoItem->m_lMeasure != lTempMeasure )
					{
						BOOL fSuccess = FALSE;

						// Keep moving back a beat until the measure does not change
						if( SUCCEEDED ( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lTempMeasure, --lTempBeat, &mtTempTime ) ) )
						{
							mtTempTime += lTempTick;
							if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, mtTempTime, &lTempMeasure, &lTempBeat ) )
							&&	SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lTempMeasure, lTempBeat, &lTempTick ) ) )
							{
								lTempTick = mtTempTime - lTempTick;

								fSuccess = TRUE;
								mtTime = mtTempTime;
								lMeasure = lTempMeasure;
								lBeat = lTempBeat;
								lTick = lTempTick;
							}
						}
						
						if( fSuccess == FALSE)
						{
							break;
						}
					}
				}

				mtTime = GetNextGreatestUniqueTime( mtTime ); 
				if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, mtTime, &lMeasure, &lBeat ) )
				&&	SUCCEEDED( m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lMeasure, lBeat, &lTick ) ) )
				{
					lTick = mtTime - lTick;

					pTempoItem->m_mtTime = mtTime;
					pTempoItem->m_lMeasure = lMeasure;
					pTempoItem->m_lBeat = (BYTE)lBeat;
					pTempoItem->m_lOffset = lTick;
					fChanged = TRUE;
				}

				InsertByAscendingTime( pTempoItem, FALSE );
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetBoundariesOfSelectedTempos

void CTempoMgr::GetBoundariesOfSelectedTempos( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	long lEnd = -1;
	BOOL fSetStart = FALSE;

	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if ( pTempoItem->m_fSelected )
		{
			if( lEnd < pTempoItem->m_mtTime )
			{
				lEnd = pTempoItem->m_mtTime;
			}
			if( !fSetStart )
			{
				fSetStart = TRUE;
				*plStart = pTempoItem->m_mtTime;
			}
		}
	}

	if( lEnd >= 0 )
	{
		*plEnd = lEnd;
	}
	else
	{
		*plStart = -1;
		*plEnd = -1;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::DeleteBetweenTimes

BOOL CTempoMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	BOOL fChanged = FALSE;

	// Iterate through the list
	POSITION pos2, pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );

		// If the tempo occurs between lStart and lEnd, delete it
		if( (pTempoItem->m_mtTime >= lStart) && (pTempoItem->m_mtTime <= lEnd) ) 
		{
			m_lstTempos.RemoveAt( pos2 );
			if( pos2 == m_posLastGetParam )
			{
				m_posLastGetParam = NULL;
			}
			delete pTempoItem;
			fChanged = TRUE;
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::ClocksToMeasureBeat

HRESULT CTempoMgr::ClocksToMeasureBeat( long lTime, long *plMeasure, long *plBeat )
{
	if( lTime < 0 )
	{
		if( plMeasure )
		{
			*plMeasure = 0;
		}
		if( plBeat )
		{
			*plBeat = 0;
		}
		return S_OK;
	}
	else if( m_pTimeline )
	{
		return m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits,
												 m_dwIndex,
												 lTime,
												 plMeasure,
												 plBeat );
	}
	else
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
}



/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::CanCycle

BOOL CTempoMgr::CanCycle( long lXPos  )
{
	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		int nCount = 0;
		long lTempoMeasure;
		long lTempoBeat;

		POSITION pos = m_lstTempos.GetHeadPosition();
		while( pos )
		{
			CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );

			ClocksToMeasureBeat( pTempoItem->m_mtTime,
								 &lTempoMeasure,
								 &lTempoBeat );
			if( lTempoMeasure == lMeasure
			&&  lTempoBeat == lBeat
			&&  pTempoItem->m_strText.IsEmpty() == FALSE )
			{
				if( ++nCount > 1 )
				{
					return TRUE;
				}
			}

			if( lTempoMeasure > lMeasure )
			{
				break;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::CycleTempos

HRESULT CTempoMgr::CycleTempos( long lXPos  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	long lMeasure;
	long lBeat;
	HRESULT hr = m_pTimeline->PositionToMeasureBeat( m_dwGroupBits, 0, lXPos, &lMeasure, &lBeat );

	if( SUCCEEDED ( hr ) ) 
	{
		CTempoItem* pFirstTempoItem = NULL;
		CTempoItem* pSecondTempoItem = NULL;
		long lTempoMeasure;
		long lTempoBeat;
		long lNextTempoMeasure;
		long lNextTempoBeat;

		hr = E_FAIL;

		POSITION pos = m_lstTempos.GetHeadPosition();
		while( pos )
		{
			CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );

			ClocksToMeasureBeat( pTempoItem->m_mtTime,
								 &lTempoMeasure,
								 &lTempoBeat );
			if( lTempoMeasure == lMeasure
			&&  lTempoBeat == lBeat
			&&  pTempoItem->m_strText.IsEmpty() == FALSE )
			{
				if( pFirstTempoItem == NULL )
				{
					pFirstTempoItem = pTempoItem;
				}
				else if( pSecondTempoItem == NULL )
				{
					pSecondTempoItem = pTempoItem;
				}

				if( pTempoItem->m_wFlags & BF_TOPTEMPO )
				{
					if( pos )
					{
						// Cycle to next Tempo if on same measure/beat
						CTempoItem* pNextTempoItem = m_lstTempos.GetNext( pos );

						ClocksToMeasureBeat( pNextTempoItem->m_mtTime,
											 &lNextTempoMeasure,
											 &lNextTempoBeat );
						if( lNextTempoMeasure == lMeasure
						&&  lNextTempoBeat == lBeat
						&&  pNextTempoItem->m_strText.IsEmpty() == FALSE )
						{
							UnselectAll();
							pTempoItem->m_wFlags &= ~BF_TOPTEMPO;
							pNextTempoItem->m_fSelected = TRUE;
							pNextTempoItem->m_wFlags |= BF_TOPTEMPO;
							hr = S_OK;
							break;
						}
					}

					// Cycle to first Tempo on same measure/beat
					UnselectAll();
					pTempoItem->m_wFlags &= ~BF_TOPTEMPO;
					pFirstTempoItem->m_fSelected = TRUE;
					pFirstTempoItem->m_wFlags |= BF_TOPTEMPO;
					hr = S_OK;
					break;
				}
			}

			if( lTempoMeasure > lMeasure
			||  pos == NULL )
			{
				UnselectAll();
				if( pSecondTempoItem )
				{
					pSecondTempoItem->m_fSelected = TRUE;
					pSecondTempoItem->m_wFlags |= BF_TOPTEMPO;
					hr = S_OK;
				}
				else if( pFirstTempoItem )
				{
					pFirstTempoItem->m_fSelected = TRUE;
					pFirstTempoItem->m_wFlags |= BF_TOPTEMPO;
					hr = S_OK;
				}
				break;
			}
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Redraw the Tempo strip
		m_pTimeline->StripInvalidateRect( m_pTempoStrip, NULL, TRUE );

		// Update the property page
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::CreateTempo

HRESULT	CTempoMgr::CreateTempo( MUSIC_TIME mtTime, CTempoItem *&rpTempo )
{
	rpTempo = NULL;

	if ( !m_pTimeline )
	{
		return E_FAIL;
	}

	rpTempo = new CTempoItem;

	if(rpTempo == NULL)
	{
		return E_OUTOFMEMORY;
	}

	long lMeasure = 0;
	long lBeat = 0;
	HRESULT hr;
	hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
	ASSERT(SUCCEEDED(hr));
	rpTempo->m_dblTempo = 0.0;
	rpTempo->m_strText.Empty();
	rpTempo->m_lMeasure = lMeasure;
	ASSERT( lBeat >= 0 && lBeat < 256 );
	if( lBeat < 0 )
	{
		lBeat = 0;
	}
	else if( lBeat > 255 )
	{
		lBeat = 255;
	}
	rpTempo->m_lBeat = lBeat;
	rpTempo->m_lOffset = 0;
	hr = m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lMeasure, lBeat, &rpTempo->m_mtTime );
	InsertByAscendingTime( rpTempo, FALSE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::FindTempo

CTempoItem* CTempoMgr::FindTempo(long lMeasure, long lBeat)
{
	POSITION pos = m_lstTempos.GetHeadPosition();
	while( pos )
	{
		CTempoItem* pTempoItem = m_lstTempos.GetNext( pos );
		if ( pTempoItem->m_lMeasure == lMeasure && pTempoItem->m_lBeat == lBeat)
		{
			return pTempoItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::OnTransportChangeTempo

void CTempoMgr::OnTransportChangeTempo( double dblTempo )
{
	// Get the tempo at the current cursor position;
	long lTimeCursor;
	if( m_pTimeline && m_pTempoStrip &&
		SUCCEEDED(m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTimeCursor) ) )
	{
		CTempoItem *pTempoKeep = NULL;
		POSITION pos = m_lstTempos.GetHeadPosition();
		while( pos )
		{
			CTempoItem *pTempoItem = m_lstTempos.GetNext( pos );
			if( lTimeCursor < pTempoItem->m_mtTime )
			{
				break;
			}

			if( pTempoItem->m_dblTempo != 0.0 )
			{
				pTempoKeep = pTempoItem;
			}
		}
		if( pTempoKeep && (pTempoKeep->m_dblTempo != dblTempo) )
		{
			if( m_pSegmentState )
			{
				if( pTempoKeep == GetTempoForTime(GetCurrentOffset(), NULL) )
				{
					// Change tempo now!!!
					DMUS_TEMPO_PMSG* pTempo;

					if( SUCCEEDED( m_pDMPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
						(DMUS_PMSG**)&pTempo ) ) )
					{
						// Queue tempo event
						ZeroMemory( pTempo, sizeof(DMUS_TEMPO_PMSG) );
						pTempo->dblTempo = pTempoKeep->m_dblTempo;
						pTempo->dwFlags = DMUS_PMSGF_REFTIME;
						pTempo->dwType = DMUS_PMSGT_TEMPO;
						m_pDMPerformance->SendPMsg( (DMUS_PMSG*)pTempo );
					}
				}
			}

			pTempoKeep->m_strText.Format("%.2f", dblTempo);
			pTempoKeep->m_dblTempo = dblTempo;
			m_pTempoStrip->m_nLastEdit = IDS_UNDO_CHANGE;

			// Refresh property page
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
			
			// Redraw the tempo strip
			// TODO: Should be smarter and only redraw the tempo that changed
			m_pTimeline->StripInvalidateRect( m_pTempoStrip, NULL, TRUE );

			// Un-Freeze undo queue
			BOOL fOrigFreezeState = FALSE;
			VARIANT var;
			if( SUCCEEDED( m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fOrigFreezeState = V_BOOL(&var);
			}

			if( fOrigFreezeState )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = FALSE;
				m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}

			// Let our hosting editor and the music engine know about the changes
			OnDataChanged();

			// Re-disable undo queue, if neccessary
			if( fOrigFreezeState )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = TRUE;
				m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetCurrentOffset

MUSIC_TIME CTempoMgr::GetCurrentOffset( void )
{
	ASSERT(m_pDMPerformance);

	MUSIC_TIME mtNow;
	if ( m_pSegmentState && m_pDMPerformance && SUCCEEDED( m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
	{
		// Convert mtNow from absolute time to an offset from when the segment started playing
		mtNow -= m_mtStartTime - m_mtStartPoint;

		if( (m_dwNumLoops != 0) && (m_mtStartPoint < m_mtLoopEnd) )
		{
			if( mtNow > (m_mtLoopStart + (m_mtLoopEnd - m_mtLoopStart) * (signed)m_dwNumLoops) )
			{
				mtNow -= (m_mtLoopEnd - m_mtLoopStart) * m_dwNumLoops;
			}
			else if( mtNow > m_mtLoopStart )
			{
				mtNow = m_mtLoopStart + (mtNow - m_mtLoopStart) % (m_mtLoopEnd - m_mtLoopStart);
			}
		}

		return mtNow;
	}
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoMgr::GetTempoForTime

CTempoItem* CTempoMgr::GetTempoForTime( MUSIC_TIME mtTime, CTempoItem** ppTempoItemNext )
{
	// Initialize data to return
	CTempoItem *pTempoToReturn = NULL;
	if( ppTempoItemNext )
	{
		*ppTempoItemNext = NULL;
	}

	// Initialize pos to NULL
	POSITION pos = NULL;

	// If we have a cached position
	if( m_posLastGetParam )
	{
		// Get the cached tempo
		CTempoItem *pItem = m_lstTempos.GetAt(m_posLastGetParam);

		// If the time is more than halfway to the cached tempo
		if( mtTime > pItem->m_mtTime / 2 )
		{
			// Start searching from m_posLastGetParam
			pos = m_posLastGetParam;

			// If mtTime is earlier than the cached tempo, search backwards
			if( mtTime < pItem->m_mtTime )
			{
				while( pos )
				{
					POSITION posNow = pos;
					// Continue until we find a tempo earlier than mtTime
					if( m_lstTempos.GetPrev( pos )->m_mtTime < mtTime )
					{
						pos = posNow;
						break;
					}
				}

				// If pos is NULL, set pos to the head position (happens below)
			}

			// Otherwise, fall through and search forwards (from m_posLastGetParam)
		}
	}

	if( pos == NULL )
	{
		pos = m_lstTempos.GetHeadPosition();
	}

	while( pos )
	{
		const POSITION posCurrent = pos;
		CTempoItem *pTempoItem = m_lstTempos.GetNext( pos );
		if( mtTime < pTempoItem->m_mtTime )
		{
			// Set next	
			if( ppTempoItemNext )
			{
				if( pTempoItem->m_dblTempo != 0.0 )
				{
					*ppTempoItemNext = pTempoItem;
				}
				else
				{
					while( pTempoItem->m_dblTempo == 0.0 )
					{
						if( pos == NULL )
						{
							break;
						}
						pTempoItem = m_lstTempos.GetNext( pos );
						if( pTempoItem->m_dblTempo != 0.0 )
						{
							*ppTempoItemNext = pTempoItem;
						}
					}
				}
			}
			break;
		}

		if( pTempoItem->m_dblTempo != 0.0 )
		{
			pTempoToReturn = pTempoItem;
			m_posLastGetParam = posCurrent;
		}
	}

	return pTempoToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\TempoMgr.h ===
// TempoMgr.h : Declaration of the CTempoMgr

#ifndef __TEMPOMGR_H_
#define __TEMPOMGR_H_

#include "resource.h"		// main symbols
#include "TempoStripMgr.h"
#include "timeline.h"
#include "PropTempo.h"
#include <DMUSProd.h>
#include <afxtempl.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CTempoStrip;
class CTempoItem;
class CDllJazzDataObject;
class PropPageTempo;
interface IDirectMusicTrack;

/////////////////////////////////////////////////////////////////////////////
// CTempoMgr
class ATL_NO_VTABLE CTempoMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTempoMgr, &CLSID_TempoMgr>,
	//public ITempoMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CTempoStrip;
friend PropPageTempo;

public:
	CTempoMgr();
	~CTempoMgr();

public:
DECLARE_REGISTRY_RESOURCEID(IDR_TEMPOMGR)

BEGIN_COM_MAP(CTempoMgr)
	//COM_INTERFACE_ENTRY(ITempoMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// ITempoMgr methods
//	HRESULT STDMETHODCALLTYPE IsMeasureBeatOpen( long lMeasure, long lBeat );

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

protected:
	HRESULT STDMETHODCALLTYPE OnDataChanged( void);
	void	EmptyTempoList(void);
	void	InsertByAscendingTime(CTempoItem *pTempo, BOOL fPaste);
	void	SetPropTempoBarBeat( CPropTempo *pTempo );
	BOOL	SetPropTempoTime( CPropTempo *pTempo );
	void	RecomputeTempoMeasureBeats();
	BOOL	RecomputeTempoTimes();
	void	GetBoundariesOfSelectedTempos( long *plStart, long *plEnd );
	HRESULT	CreateTempo( MUSIC_TIME mtTime, CTempoItem *&pTempo );
	CTempoItem* FindTempo(long lMeasure, long lBeat);
	void	OnTransportChangeTempo( double dblTempo );
	CTempoItem* GetTempoForTime( MUSIC_TIME mtTime, CTempoItem** ppTempoItemNext );

	BOOL	SelectSegment(long begintime, long endtime);
	HRESULT SyncWithDirectMusic();

protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CTempoItem*> m_lstTempos;
	POSITION					m_posLastGetParam;
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDataObject*				m_pCopyDataObject;
	DWORD						m_dwGroupBits;
	DWORD						m_dwIndex;;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	BOOL						m_fDirty;
	CPropTempo					m_SelectedPropTempo;
	IDirectMusicPerformance		*m_pDMPerformance;

	// Playback state variables
	IDirectMusicSegmentState	*m_pSegmentState;
	MUSIC_TIME					m_mtLoopEnd;
	MUSIC_TIME					m_mtLoopStart;
	MUSIC_TIME					m_mtStartTime;
	MUSIC_TIME					m_mtStartPoint;
	DWORD						m_dwNumLoops;

	CTempoStrip*				m_pTempoStrip;

protected:
//	HRESULT LoadTempoList( LPSTREAM pStream );
//	HRESULT SaveTempoList( LPSTREAM );
	HRESULT DeleteSelectedTempos();
	HRESULT SaveSelectedTempos(LPSTREAM pIStream, long lOffset);

// general helpers
	void MarkSelectedTempos(DWORD flags);
	void UnMarkTempos(DWORD flags);
	void DeleteMarked(DWORD flags);
	bool UnselectAll();
	void SelectAll();
	BOOL RemoveItem( CTempoItem* pItem );
	BOOL DeleteBetweenTimes( long lStart, long lEnd );
	BOOL CanCycle( long lXPos );
	HRESULT CycleTempos( long lXPos );
	HRESULT ClocksToMeasureBeat( long lTime, long *plMeasure, long *plBeat );
	MUSIC_TIME GetCurrentOffset( void );
	MUSIC_TIME GetNextGreatestUniqueTime( MUSIC_TIME mtOrigTime );

// Misc
	BOOL		IsSelected();	// returns if one or more tempos are selected.
	CTempoItem* FirstSelectedTempo();
};


class CTempoStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CTempoMgr;

public:
	CTempoStrip( CTempoMgr* pTempoMgr );
	~CTempoStrip();

public:
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject *pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject *pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject *pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
protected:
	CWnd*	GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL &fChanged );
	HRESULT DoDragDrop(WPARAM mousekeybutton, LONG lXPos);

// IDMUSProdPropPageObject functions
public:
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
// IDropSource helpers
	CImageList* CreateDragImage();
	HRESULT 	CreateDataObject(IDataObject**, long position);

// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	HRESULT OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos);
	void UpdateName();
	long GetBeatWidth(long measure);
	HRESULT SelectRange(CTempoItem* pTempo);

	long		m_cRef;
	LONG		m_lGutterBeginSelect;
	LONG		m_lGutterEndSelect;
	BOOL		m_bGutterSelected;	// whether the gutter select is selected
	CTempoMgr*	m_pTempoMgr;
	IDMUSProdStripMgr*	m_pStripMgr;
	BOOL		m_bSelecting;
	CString		m_strName;
	CTempoItem*	m_pCurrentlySelectedTempoItem;

private:
	HRESULT		AddTempo( double dblTempo, MUSIC_TIME mtTime );
	HRESULT		ShowPropertySheet(IDMUSProdTimeline*);
	void		UnselectGutterRange( void );
	CTempoItem* GetTopTempoFromPoint( long lPos );
	CTempoItem* GetTopTempoFromMeasureBeatAndPosition( long lMeasure, long lBeat, POSITION posStart );
	CTempoItem* GetTopTempoFromMeasureBeatAndPositionReverse( long lMeasure, long lBeat, POSITION posStart );
	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	CImageList* m_pDragImage;			// Image used for drag operation feedback
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	UINT		m_cfTempoList;			// Clipboard format
	LONG		m_lStartDragPosition;	// xpos where drag was started
	UINT		m_nLastEdit;			// resource id of last edit
	BOOL		m_fShowTempoProps;		// if TRUE, show Tempo property page, else show group property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	BOOL		m_fLButtonDown;			// TRUE if the left mouse button is down
	BOOL		m_fInDragDrop;			// TRUE if we are doing a drag'n'drop operation
	BOOL		m_fInRightClickMenu;
	BOOL		m_fSingleSelect;
	IDMUSProdPropPageManager*	m_pPropPageMgr;

};
#endif //__TEMPOMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\TempoStrip.cpp ===
// TempoStrip.cpp : Implementation of CTempoStrip
#include "stdafx.h"
#include "TempoIO.h"
#include "TempoStripMgr.h"
#include "TempoMgr.h"
#include "PropPageMgr.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include <RiffStrm.h>
#include <dmusicf.h>
#include "MusicTimeConverter.h"
#include "SegmentIO.h"
#include "GrayOutRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define STRIP_HEIGHT 20

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip constructor/destructor

CTempoStrip::CTempoStrip( CTempoMgr* pTempoMgr )
{
	ASSERT( pTempoMgr );
	if ( pTempoMgr == NULL )
	{
		return;
	}

	m_pTempoMgr = pTempoMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pTempoMgr;
	//m_pStripMgr->AddRef();

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_lXPos = -1;
	m_bGutterSelected = FALSE;
	m_bSelecting = FALSE;
	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;
	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_nLastEdit = 0;
	m_fShowTempoProps = FALSE;
	m_fPropPageActive = FALSE;
	m_pPropPageMgr = NULL;
	m_fInRightClickMenu = FALSE;
	m_fSingleSelect = FALSE;
	m_fLButtonDown = FALSE;
	m_fInDragDrop = FALSE;
	m_pCurrentlySelectedTempoItem = NULL;

	UpdateName();
}

CTempoStrip::~CTempoStrip()
{
	ASSERT( m_pStripMgr );
	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pTempoMgr = NULL;
	}
	if ( m_pISourceDataObject )
	{
		m_pISourceDataObject->Release();
	}
	if ( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
	}
	if ( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::QueryInterface

STDMETHODIMP CTempoStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::AddRef

STDMETHODIMP_(ULONG) CTempoStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Release

STDMETHODIMP_(ULONG) CTempoStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Draw

bool IsRealTempo(CTempoItem* pTempo)
{
	ASSERT(pTempo);
	if(!pTempo)
		return false;
	return (pTempo->m_strText.IsEmpty() == FALSE) ? true : false;
}

HRESULT	STDMETHODCALLTYPE CTempoStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER( sv );

	bool fUseGutterSelectRange = m_bGutterSelected && m_lGutterBeginSelect != m_lGutterEndSelect;

	// Get a pointer to the Timeline
	if( m_pTempoMgr->m_pTimeline )
	{
		IDMUSProdTimeline* pTimeline = m_pTempoMgr->m_pTimeline;

		// Draw Measure and Beat lines in our strip
		pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pTempoMgr->m_dwGroupBits, 0, lXOffset );

			// Get clip box
			RECT rectClip;
			::GetClipBox( hDC, &rectClip );
			RECT rectHighlight;
			rectHighlight.top = 0;
			rectHighlight.bottom = STRIP_HEIGHT;
			RECT rectGhost;
			rectGhost.top = rectGhost.left = rectGhost.right = 0;
			rectGhost.bottom = STRIP_HEIGHT;

			// Create Italics font
			HFONT hFontItalics = NULL;
			HFONT hFont = static_cast<HFONT>(::GetCurrentObject( hDC, OBJ_FONT ));
			if( hFont )
			{
				LOGFONT logfont;
				if( ::GetObject( hFont, sizeof(logfont), &logfont) > 0 )
				{
					logfont.lfItalic = TRUE;
					hFontItalics = ::CreateFontIndirect( &logfont );
				}
			}

			//
			// find first visible measure/beat for ghosting tempos
			//
			
			// Get the time of the first pixel
			long lClocks;
			pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);

			// Get the measure/beat of the first pixel
			long lFirstPartialVisibleMeasure, lFirstPartialVisibleBeat;
			m_pTempoMgr->ClocksToMeasureBeat( lClocks, &lFirstPartialVisibleMeasure, &lFirstPartialVisibleBeat );

			// Get the start time of the first visible measure/beat
			CMusicTimeConverter cmtNearestMeasureBeat(lFirstPartialVisibleMeasure, lFirstPartialVisibleBeat, pTimeline, m_pTempoMgr->m_dwGroupBits);

			// If the first visible measure beat starts earlier than the display
			long lFirstFullVisibleMeasure, lFirstFullVisibleBeat;
			if(cmtNearestMeasureBeat.Time() < lClocks)
			{
				// round up to the next beat
				cmtNearestMeasureBeat.AddOffset(0, 1, pTimeline, m_pTempoMgr->m_dwGroupBits);
				cmtNearestMeasureBeat.GetMeasureBeat(lFirstFullVisibleMeasure, lFirstFullVisibleBeat, pTimeline, m_pTempoMgr->m_dwGroupBits);
			}
			else
			{
				// Otherwise the first full visible beat is the current one
				lFirstFullVisibleMeasure = lFirstPartialVisibleMeasure;
				lFirstFullVisibleBeat = lFirstPartialVisibleBeat;
			}

			// Find nearest Tempo in or after first visible measure/beat
			POSITION pos = m_pTempoMgr->m_lstTempos.GetHeadPosition();
			POSITION posCurrent = pos;
			while( pos )
			{
				CTempoItem* pTempoItem = m_pTempoMgr->m_lstTempos.GetNext(pos);
				
				if(pTempoItem->m_lMeasure > lFirstFullVisibleMeasure || (pTempoItem->m_lMeasure == lFirstFullVisibleMeasure && 
				  pTempoItem->m_lBeat >= lFirstFullVisibleBeat))
				{
					break;
				}

				posCurrent = pos;
			}

			//
			// Find the first previous real tempo (the ghost tempo)
			bool bUseItalicsForGhost = false;
			bool bGhostTempoCovered = false;	// indicates real tempo covering ghost tempo
			CTempoItem* pGhostTempo = NULL;

			// Back up one in the tempo list
			if( posCurrent )
			{
				m_pTempoMgr->m_lstTempos.GetPrev( posCurrent );
			}
			else
			{
				posCurrent = m_pTempoMgr->m_lstTempos.GetTailPosition();
			}

			// While there is a tempo before the one we found
			long lCurrentMeasure = -1;
			long lCurrentBeat = -1;
			while( posCurrent )
			{
				// Get a pointer to it
				const POSITION posCurCurrent = posCurrent;
				CTempoItem *pTempoItem = m_pTempoMgr->m_lstTempos.GetPrev( posCurrent );
				if( pTempoItem->m_lMeasure != lCurrentMeasure || pTempoItem->m_lBeat != lCurrentBeat )
				{
					// Set the current measure and beat
					lCurrentMeasure = pTempoItem->m_lMeasure;
					lCurrentBeat = pTempoItem->m_lBeat;

					// Get the top tempo from that measure and beat
					CTempoItem* pTopTempoItem = GetTopTempoFromMeasureBeatAndPositionReverse( lCurrentMeasure, lCurrentBeat, posCurCurrent );
					if(pTopTempoItem)
					{
						// Check that it's a real tempo
						if(IsRealTempo(pTopTempoItem))
						{
							bUseItalicsForGhost = false;	// may be overridden later
							pGhostTempo = pTopTempoItem;
							if(	pTopTempoItem != pTempoItem
							&&	IsRealTempo(pTempoItem) )
							{
								bUseItalicsForGhost = true;
							}
							else
							{
								// either pTempoItem is the top Tempo of many or it is a singleton
								// in either case we must get to the end of list of measure/beat
								// coincident Tempos
								POSITION posPrev = posCurrent;
								while(posPrev)
								{
									// Get a pointer to the previous tempo
									CTempoItem* pPrevTempoItem = m_pTempoMgr->m_lstTempos.GetPrev(posPrev);

									// Check if its still in the same measure/beat
									if( (pPrevTempoItem->m_lMeasure != lCurrentMeasure)
									||	(pPrevTempoItem->m_lBeat != lCurrentBeat) )
									{
										//end of measure/beat coincident Tempos
										posPrev = NULL;
									}
									else
									{
										// Check if we found another real tempo on the same measure/beat
										if( (pPrevTempoItem != pTopTempoItem)
										&&	IsRealTempo(pPrevTempoItem))
										{
											// Yes - use italics
											bUseItalicsForGhost = true;
										}
									}
								}
							}

							// Break out of the loop, since we found the ghost tempo
							break;
						}
					}
				}
			}

			long lPosition;
			SIZE size;
			if(pGhostTempo)
			{
				// get rect of ghost Tempo's text, we may have to truncate it if it covers a real Tempo
				pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, 
									lFirstFullVisibleMeasure, lFirstFullVisibleBeat, &lPosition );
				lPosition++;
				::GetTextExtentPoint32( hDC, pGhostTempo->m_strText, pGhostTempo->m_strText.GetLength(), &size );
				rectGhost.left = lPosition-lXOffset;
				rectGhost.right = rectGhost.left + size.cx;
			}

			// we'll draw the ghost after checking whether or not Tempo covers it

			// Flag if any of the tempos are selected
			bool fAnyTemposSelected = false;

			// Draw all Tempos in the strip
			long lMeasure;
			long lBeat;
			lCurrentMeasure = -1;
			lCurrentBeat = -1;
			pos = m_pTempoMgr->m_lstTempos.GetHeadPosition();
			while( pos )
			{
				const POSITION posCurrent = pos;
				CTempoItem* pTempoItem = m_pTempoMgr->m_lstTempos.GetNext( pos );
				
				// Get measure/beat of this tempo
				const long lTempoMeasure = pTempoItem->m_lMeasure;
				const long lTempoBeat = pTempoItem->m_lBeat;

				// Get position to draw at
				pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, lTempoMeasure, lTempoBeat, &lPosition );
				
				lPosition++;

				// If the tempo starts after the visible region
				if( lPosition - lXOffset > rectClip.right )
				{
					// break out of the loop
					break;
				}

				// Draw the tempo
				if( lCurrentMeasure != lTempoMeasure || lCurrentBeat != lTempoBeat )
				{
					lCurrentMeasure = lTempoMeasure;
					lCurrentBeat = lTempoBeat;

					CTempoItem* pTopTempoItem = GetTopTempoFromMeasureBeatAndPosition( lTempoMeasure, lTempoBeat, posCurrent );
					ASSERT( pTopTempoItem != NULL );		// Should never be NULL!
					if( pTopTempoItem )
					{
						HFONT hFontOld = NULL;
						if( hFontItalics )
						{
							if( pTopTempoItem->m_strText.IsEmpty() == FALSE )
							{
								if( pTopTempoItem != pTempoItem	&& pTempoItem->m_strText.IsEmpty() == FALSE )
								{
									hFontOld = static_cast<HFONT>(::SelectObject( hDC, hFontItalics ));
								}
								else
								{
									POSITION posNext = pos;
									while( posNext )
									{
										CTempoItem* pNextTempoItem = m_pTempoMgr->m_lstTempos.GetNext( posNext );
										m_pTempoMgr->ClocksToMeasureBeat( pNextTempoItem->m_mtTime, &lMeasure, &lBeat );
										if( lCurrentMeasure != lMeasure	|| lCurrentBeat != lBeat )
										{
											posNext = NULL;
										}
										else
										{
											if( pNextTempoItem != pTopTempoItem	&& pNextTempoItem->m_strText.IsEmpty() == FALSE )
											{
												hFontOld = static_cast<HFONT>(::SelectObject( hDC, hFontItalics ));
												posNext = NULL;

												// If this item is selected and the one on top is not then do the needful...
												if(pTopTempoItem->m_fSelected == FALSE && pNextTempoItem->m_fSelected == TRUE)
												{
													pTopTempoItem->m_wFlags &= ~BF_TOPTEMPO;
													pTopTempoItem = pNextTempoItem;
													pTopTempoItem->m_wFlags |= BF_TOPTEMPO;
												}
											}
										}
									}
								}
							}
						}

						// Find extent of text
						::GetTextExtentPoint32( hDC, pTopTempoItem->m_strText, pTopTempoItem->m_strText.GetLength(), &size );
						long lBeatLength = GetBeatWidth(lTempoMeasure);
						if( size.cx < lBeatLength )
						{
							size.cx = lBeatLength;
						}
						long lExtent = lPosition + size.cx;

						// Check if this tempo is visible
						if( lExtent - lXOffset >= rectClip.left )
						{
							// Truncate if next Tempo covers part of text
							POSITION pos2 = pos;
							while( pos2 )
							{
								CTempoItem* pTempTempo = m_pTempoMgr->m_lstTempos.GetNext( pos2 );

								if( pTempTempo->m_strText.IsEmpty() == FALSE )
								{
									lMeasure = pTempTempo->m_lMeasure;
									lBeat = pTempTempo->m_lBeat;
									if( lCurrentMeasure != lMeasure
									||  lCurrentBeat != lBeat )
									{
										long lNextTempoStartPos;
										pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lNextTempoStartPos );
										if( lNextTempoStartPos <= lExtent )
										{
											lExtent = lNextTempoStartPos;
										}
										break;
									}
								}
							}

							rectHighlight.left = lPosition - lXOffset;
							rectHighlight.right = lExtent - lXOffset;

							// truncate ghost tempo if necessary
							if( pGhostTempo
							&&	IsRealTempo(pTopTempoItem) )
							{
								bool b1 = pTopTempoItem->m_lMeasure == lFirstFullVisibleMeasure
									&& pTopTempoItem->m_lBeat == lFirstFullVisibleBeat;
								bool b2 = pTopTempoItem->m_lMeasure == lFirstPartialVisibleMeasure
										&& rectHighlight.right > (LeftMargin(pTimeline) - lXOffset);
								if(b1 || b2)
								{
									bGhostTempoCovered = true;
								}
								else if(rectHighlight.left > rectGhost.left
											&& rectHighlight.left < rectGhost.right)
								{
									rectGhost.right = rectHighlight.left;
								}
							}

							if( !fUseGutterSelectRange
							&&	pTopTempoItem->m_fSelected )
							{
								// Don't need to draw the selected tempo item, since it's draw below
								fAnyTemposSelected = true;
							}
							else
							{
								::DrawText( hDC, pTopTempoItem->m_strText, pTopTempoItem->m_strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
							}
						}

						if( hFontOld )
						{
							::SelectObject( hDC, hFontOld );
						}
					}
				}
			}

			// finally draw ghost tempo
			if(pGhostTempo && !bGhostTempoCovered)
			{
				HFONT hOldFont = 0;
				if(bUseItalicsForGhost && hFontItalics)
				{
					hOldFont = static_cast<HFONT>(::SelectObject( hDC, hFontItalics ));
				}
				COLORREF cr = ::SetTextColor( hDC, RGB(168,168,168));
				::DrawText( hDC, pGhostTempo->m_strText, pGhostTempo->m_strText.GetLength(), &rectGhost, (DT_LEFT | DT_NOPREFIX) );

				if(hOldFont)
				{
					::SelectObject( hDC, hOldFont );
				}
				::SetTextColor( hDC, cr );
			}

			// Make sure the names of selected tempos are shown in their entirety
			long lLastMeasure = -1;
			long lLastBeat = -1;
			lCurrentMeasure = -1;
			lCurrentBeat = -1;
			pos = m_pTempoMgr->m_lstTempos.GetHeadPosition();

			// Skip this if we're using the gutter select range or if there are no selected tempos
			if( fUseGutterSelectRange
			||	!fAnyTemposSelected )
			{
				pos = NULL;
			}
			while( pos )
			{
				POSITION posCurrentTemp = pos;
				CTempoItem *pTempoItem = m_pTempoMgr->m_lstTempos.GetNext( pos );

				const long lTempoMeasure = pTempoItem->m_lMeasure;
				const long lTempoBeat = pTempoItem->m_lBeat;
				pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, lTempoMeasure, lTempoBeat, &lPosition );

				if( lPosition - lXOffset > rectClip.right )
				{
					break;
				}

				if( pTempoItem->m_fSelected )
				{
					if( lCurrentMeasure != lTempoMeasure || lCurrentBeat != lTempoBeat )
					{
						lCurrentMeasure = lTempoMeasure;
						lCurrentBeat = lTempoBeat;

						// Back up and find the first tempo on this beat
						POSITION posFirst = posCurrentTemp;
						while( posCurrentTemp )
						{
							posFirst = posCurrentTemp;
							CTempoItem *pTmpTempoItem = m_pTempoMgr->m_lstTempos.GetPrev( posCurrentTemp );
							if( lCurrentMeasure != pTmpTempoItem->m_lMeasure
							||	lCurrentBeat != pTmpTempoItem->m_lBeat )
							{
								break;
							}
						}

						CTempoItem* pTopTempoItem = GetTopTempoFromMeasureBeatAndPosition( lTempoMeasure, lTempoBeat, posFirst );
						ASSERT( pTopTempoItem != NULL );		// Should never be NULL!
						if( pTopTempoItem )
						{
							HFONT hFontOld = NULL;
							if( hFontItalics )
							{
								if( pTopTempoItem->m_strText.IsEmpty() == FALSE )
								{
									if( pTopTempoItem != pTempoItem	&&  pTempoItem->m_strText.IsEmpty() == FALSE )
									{
										hFontOld = static_cast<HFONT>(::SelectObject( hDC, hFontItalics ));
									}
									else if( lLastMeasure == lTempoMeasure &&  lLastBeat == lTempoBeat )
									{
										hFontOld = static_cast<HFONT>(::SelectObject( hDC, hFontItalics ));
									}
									else
									{
										POSITION posNext = pos;
										while( posNext )
										{
											CTempoItem* pNextTempoItem = m_pTempoMgr->m_lstTempos.GetNext( posNext );
											m_pTempoMgr->ClocksToMeasureBeat( pNextTempoItem->m_mtTime, &lMeasure, &lBeat );
											if( lCurrentMeasure != lMeasure	||  lCurrentBeat != lBeat )
											{
												posNext = NULL;
											}
											else
											{
												if( pNextTempoItem != pTopTempoItem	&&  pNextTempoItem->m_strText.IsEmpty() == FALSE )
												{
													hFontOld = static_cast<HFONT>(::SelectObject( hDC, hFontItalics ));
													posNext = NULL;
												}
											}
										}
									}
								}
							}

							// If this item is selected and the one on top is not then do the needful...
							if( pTopTempoItem != pTempoItem )
							{
								if( pTopTempoItem->m_fSelected == FALSE )
								{
									pTopTempoItem = pTempoItem;
								}

								pTempoItem->m_wFlags &= ~BF_TOPTEMPO;
								pTopTempoItem->m_wFlags |= BF_TOPTEMPO;
							}

							// find extent of text
							long lBeatLength = GetBeatWidth(lTempoMeasure);
							::GetTextExtentPoint32( hDC, pTopTempoItem->m_strText, pTopTempoItem->m_strText.GetLength(), &size );
							if( size.cx < lBeatLength )
							{
								size.cx = lBeatLength;
							}
							long lExtent = lPosition + size.cx;

							// Check if this tempo is visible
							if( lExtent - lXOffset >= rectClip.left )
							{
								// Truncate if a selected Tempo covers part of text
								POSITION pos2 = pos;
								while( pos2 )
								{
									CTempoItem* pTempTempo = m_pTempoMgr->m_lstTempos.GetNext( pos2 );

									if( pTempTempo->m_fSelected
									&&	pTempTempo->m_strText.IsEmpty() == FALSE )
									{
										lMeasure = pTempTempo->m_lMeasure;
										lBeat = pTempTempo->m_lBeat;
										if( lCurrentMeasure != lMeasure
										||	lCurrentBeat != lBeat )
										{
											long lNextTempoStartPos;
											pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lNextTempoStartPos );
											if( lNextTempoStartPos <= lExtent )
											{
												lExtent = lNextTempoStartPos;
											}
											break;
										}
									}
								}

								rectHighlight.left = lPosition - lXOffset;
								rectHighlight.right = lExtent - lXOffset;
								::DrawText( hDC, pTopTempoItem->m_strText, pTopTempoItem->m_strText.GetLength(), &rectHighlight, (DT_LEFT | DT_NOPREFIX) );
								GrayOutRect( hDC, &rectHighlight );
							}

							if( hFontOld )
							{
								::SelectObject( hDC, hFontOld );
							}
						}
					}
				}
			
				if( pTempoItem->m_strText.IsEmpty() == FALSE )
				{
					lLastMeasure = lTempoMeasure;
					lLastBeat = lTempoBeat;
				}
			}

			// Highlight the selected range if there is one.
			if( fUseGutterSelectRange )
			{
				long lBeginSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterEndSelect : m_lGutterBeginSelect;
				long lEndSelect = m_lGutterBeginSelect > m_lGutterEndSelect ? m_lGutterBeginSelect : m_lGutterEndSelect;

				long lMeasure;
				long lBeat;
				long lClocks;

				pTimeline->ClocksToMeasureBeat( m_pTempoMgr->m_dwGroupBits, 0, lBeginSelect, &lMeasure, &lBeat );
				pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, 0, lMeasure, lBeat, &lClocks );
				pTimeline->ClocksToPosition( lClocks, &(rectHighlight.left));

				pTimeline->ClocksToMeasureBeat( m_pTempoMgr->m_dwGroupBits, 0, lEndSelect, &lMeasure, &lBeat );
				pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, 0, lMeasure, (lBeat + 1), &lClocks );
				pTimeline->ClocksToPosition( (lClocks - 1), &(rectHighlight.right));

				rectHighlight.left -= lXOffset;
				rectHighlight.right -= lXOffset;

				// Invert it.
				GrayOutRect( hDC, &rectHighlight );
			}

			if( hFontItalics )
			{
				::DeleteObject( hFontItalics );
			}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CTempoStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			BSTR bstr;

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = m_strName.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pTempoMgr )
		{
			m_pTempoMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CTempoStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		if( m_bSelecting )
		{
			break;
		}

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			if( m_pTempoMgr->UnselectAll() )
			{
				m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			break;
		}
		if( m_bGutterSelected )
		{
			m_pTempoMgr->UnselectAll();
			m_pTempoMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
			m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
		}
		else
		{
			if( m_pTempoMgr->UnselectAll() )
			{
				m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
		}

		// Update the property page
		if( m_pTempoMgr->m_pPropPageMgr != NULL )
		{
			m_pTempoMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	case SP_GUTTERSELECT:
		m_bGutterSelected = V_BOOL(&var);

		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			m_pTempoMgr->UnselectAll();
			m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			break;
		}
		if( m_bGutterSelected )
		{
			m_pTempoMgr->UnselectAll();
			m_pTempoMgr->SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			m_pTempoMgr->UnselectAll();
		}
		m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

		// Update the property page
		if( m_pTempoMgr->m_pPropPageMgr != NULL )
		{
			m_pTempoMgr->m_pPropPageMgr->RefreshData();
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GetTopTempoFromMeasureBeatAndPositionReverse

CTempoItem *CTempoStrip::GetTopTempoFromMeasureBeatAndPositionReverse( long lMeasure, long lBeat, POSITION pos )
{
	// Validate our Timeline pointer
	if( m_pTempoMgr->m_pTimeline == NULL )
	{
		return NULL;
	}

	// Get the time of the start of the beat
	MUSIC_TIME mtTimeBeatStart;
	if( FAILED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits,
					m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &mtTimeBeatStart ) ) )
	{
		return NULL;
	}

	// Get the timesig of the beat
	DMUS_TIMESIGNATURE dmTimeSig;
	if( FAILED( m_pTempoMgr->m_pTimeline->GetParam( GUID_TimeSignature, 
					m_pTempoMgr->m_dwGroupBits, 0, mtTimeBeatStart, NULL, (void*) &dmTimeSig ) ) ) 
	{
		return NULL;
	}

	// Get the time of the next beat
	const MUSIC_TIME mtTimeBeatEnd = mtTimeBeatStart + ((DMUS_PPQ * 4) / dmTimeSig.bBeat);

	// If pos is NULL, set it to the first item in the list
	if( NULL == pos )
	{
		pos = m_pTempoMgr->m_lstTempos.GetTailPosition();
	}

	CTempoItem* pTheTempoItem = NULL;
	CTempoItem* pFirstTempoItem = NULL;

	// Iterate through the tempos
	while( pos )
	{
		CTempoItem* pTempoItem = m_pTempoMgr->m_lstTempos.GetPrev( pos );

		// If this tempo is earlier than the beat we're looking for
		if( pTempoItem->m_mtTime < mtTimeBeatStart )
		{
			// Break out of the loop
			break;
		}
		// If this tempo is in the beat we're looking for
		else if( pTempoItem->m_mtTime < mtTimeBeatEnd )
		{
			if( pTempoItem->m_wFlags & BF_TOPTEMPO )
			{
				return pTempoItem;
			}

			if( pFirstTempoItem == NULL )
			{
				pFirstTempoItem = pTempoItem;
			}
			else
			{
				if( pFirstTempoItem->m_strText.IsEmpty() )
				{
					pFirstTempoItem = pTempoItem;
				}
			}
		}
	}

	// If we didn't find a tempo in the beat with the BF_TOPTEMPO flag
	if( pTheTempoItem == NULL )
	{
		// Just use the first tempo we found
		pTheTempoItem = pFirstTempoItem;
	}

	return pTheTempoItem;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GetTopTempoFromMeasureBeatAndPosition

CTempoItem *CTempoStrip::GetTopTempoFromMeasureBeatAndPosition( long lMeasure, long lBeat, POSITION pos )
{
	// Validate our Timeline pointer
	if( m_pTempoMgr->m_pTimeline == NULL )
	{
		return NULL;
	}

	// Get the time of the start of the beat
	MUSIC_TIME mtTimeBeatStart;
	if( FAILED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits,
					m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &mtTimeBeatStart ) ) )
	{
		return NULL;
	}

	// Get the timesig of the beat
	DMUS_TIMESIGNATURE dmTimeSig;
	if( FAILED( m_pTempoMgr->m_pTimeline->GetParam( GUID_TimeSignature, 
					m_pTempoMgr->m_dwGroupBits, 0, mtTimeBeatStart, NULL, (void*) &dmTimeSig ) ) ) 
	{
		return NULL;
	}

	// Get the time of the next beat
	const MUSIC_TIME mtTimeBeatEnd = mtTimeBeatStart + ((DMUS_PPQ * 4) / dmTimeSig.bBeat);

	// If pos is NULL, set it to the first item in the list
	if( NULL == pos )
	{
		pos = m_pTempoMgr->m_lstTempos.GetHeadPosition();
	}

	CTempoItem* pTheTempoItem = NULL;
	CTempoItem* pFirstTempoItem = NULL;

	// Iterate through the tempos
	while( pos )
	{
		CTempoItem* pTempoItem = m_pTempoMgr->m_lstTempos.GetNext( pos );

		// If this tempo is after the beat we're looking for
		if( pTempoItem->m_mtTime >= mtTimeBeatEnd )
		{
			// Break out of the loop
			break;
		}
		// If this tempo is in the beat we're looking for
		else if( pTempoItem->m_mtTime >= mtTimeBeatStart )
		{
			if( pTempoItem->m_wFlags & BF_TOPTEMPO )
			{
				return pTempoItem;
			}

			if( pFirstTempoItem == NULL )
			{
				pFirstTempoItem = pTempoItem;
			}
			else
			{
				if( pFirstTempoItem->m_strText.IsEmpty() )
				{
					pFirstTempoItem = pTempoItem;
				}
			}
		}
	}

	// If we didn't find a tempo in the beat with the BF_TOPTEMPO flag
	if( pTheTempoItem == NULL )
	{
		// Just use the first tempo we found
		pTheTempoItem = pFirstTempoItem;
	}

	return pTheTempoItem;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GetTopTempoFromPoint

CTempoItem *CTempoStrip::GetTopTempoFromPoint( long lPos )
{
	CTempoItem* pTheTempoItem = NULL;
	
	if( m_pTempoMgr->m_pTimeline )
	{
		long lMeasure, lBeat;

		if( SUCCEEDED( m_pTempoMgr->m_pTimeline->PositionToMeasureBeat( m_pTempoMgr->m_dwGroupBits, 0, lPos, &lMeasure, &lBeat ) ) )
		{
			pTheTempoItem = GetTopTempoFromMeasureBeatAndPosition( lMeasure, lBeat, NULL );
		}
	}

	return pTheTempoItem;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CTempoStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Process the window message
	HRESULT hr = S_OK;
	if( !m_pTempoMgr->m_pTimeline )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_lXPos = lXPos;
		hr = OnLButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_LBUTTONUP:
		m_lXPos = lXPos;
		if( m_fSingleSelect )
		{
			CTempoItem* pTempo = GetTopTempoFromPoint( lXPos );
			if( pTempo
			&&  pTempo->m_dblTempo != 0.0 )
			{
				m_pTempoMgr->UnselectAll();
				pTempo->m_fSelected = TRUE;
				m_pCurrentlySelectedTempoItem = pTempo;

				// Redraw the strip and refresh the Tempo property page
				m_pTempoMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
				m_pTempoMgr->OnShowProperties();
				if( m_pTempoMgr->m_pPropPageMgr )
				{
					m_pTempoMgr->m_pPropPageMgr->RefreshData();
				}
			}
			m_fSingleSelect = FALSE;
		}
		m_fLButtonDown = FALSE;
		UnselectGutterRange();
		hr = S_OK;
		break;

	case WM_RBUTTONDOWN:
		m_lXPos = lXPos;
		hr = OnRButtonDown( wParam, lParam, lXPos, lYPos );
		break;

	case WM_RBUTTONUP:
		{
			// Display a right-click context menu.
			POINT pt;
			BOOL	bResult;

			// Get the cursor position (To put the menu there)
			bResult = GetCursorPos( &pt );
			ASSERT( bResult );
			if( !bResult )
			{
				hr = E_UNEXPECTED;
				break;
			}

			if( m_pTempoMgr->m_pTimeline )
			{
				m_fInRightClickMenu = TRUE;
				HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
				HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

				::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
						MF_GRAYED );
				::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
						MF_GRAYED );
				::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
						MF_GRAYED | MF_BYPOSITION );
				::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
						MF_GRAYED );
				::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
						MF_GRAYED );
				::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED :
						MF_GRAYED );
				::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
				::EnableMenuItem( hMenuPopup, IDM_CYCLE_TEMPOS, ( m_pTempoMgr->CanCycle(m_lXPos) == TRUE ) ? MF_ENABLED :
						MF_GRAYED );

				m_pTempoMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
				m_fInRightClickMenu = FALSE;
				::DestroyMenu( hMenu );
			}
			hr = S_OK;
		}
		break;

	case WM_MOUSEMOVE:
		if( m_fLButtonDown )
		{
			// Do Drag'n'drop
			DoDragDrop(m_dwStartDragButton, lXPos);

			// Clear button down flag so we don't do drag'n'drop again.
			m_fLButtonDown= FALSE;
		}
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet(m_pTempoMgr->m_pTimeline);
			if (m_fShowTempoProps)
			{
				// Change to the tempo property page
				m_pTempoMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut( NULL );
			break;
		case ID_EDIT_COPY:
			hr = Copy( NULL );
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			hr = Paste( NULL );
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		case IDM_CYCLE_TEMPOS:
			hr = m_pTempoMgr->CycleTempos( m_lXPos );
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		m_cfTempoList = RegisterClipboardFormat( CF_TEMPOLIST );
		UpdateName();

		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::FBDraw

HRESULT CTempoStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER( sv );
	UNREFERENCED_PARAMETER( hDC );
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::FBOnWMMessage

HRESULT CTempoStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( wParam );
	UNREFERENCED_PARAMETER( lXPos );
	UNREFERENCED_PARAMETER( lYPos );

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		m_lXPos = -1;
		m_fShowTempoProps = FALSE;
		OnShowProperties();
		break;
	case WM_LBUTTONUP:
		m_lXPos = -1;
		break;
	case WM_RBUTTONDOWN:
		m_lXPos = -1;
		break;
	case WM_RBUTTONUP:
		m_fShowTempoProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pTempoMgr->m_pTimeline )
		{
			m_fInRightClickMenu = TRUE;
			HMENU hMenu = ::LoadMenu( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_EDIT_RMENU) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, 2, ( CanPaste( NULL ) == S_OK ) ? MF_ENABLED | MF_BYPOSITION :
					MF_GRAYED | MF_BYPOSITION );
			::EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, MF_GRAYED ); // 26970: Shouldn't enable Insert
			::EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ? MF_ENABLED :
					MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_VIEW_PROPERTIES, MF_ENABLED );
			::EnableMenuItem( hMenuPopup, IDM_CYCLE_TEMPOS, ( m_pTempoMgr->CanCycle(m_lXPos) == TRUE ) ? MF_ENABLED :
						MF_GRAYED );

			m_pTempoMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
			m_fInRightClickMenu = FALSE;
			::DestroyMenu( hMenu );
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Cut

HRESULT CTempoStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy( pITimelineDataObject );
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Copy

HRESULT CTempoStrip::Copy( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfTempoList == 0 )
	{
		m_cfTempoList = RegisterClipboardFormat( CF_TEMPOLIST );
		if( m_cfTempoList == 0 )
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected commands in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Save the commands into the stream.
//	m_pTempoMgr->MarkSelectedTempos(UD_DRAGSELECT);

	MUSIC_TIME mtTime;
	if( !pITimelineDataObject )
	{
		// Get clock of first selected tempo's measure/beat
		CTempoItem* pTempoAtDragPoint = m_pTempoMgr->FirstSelectedTempo();
		long lMeasure, lBeat;
		if( FAILED( m_pTempoMgr->ClocksToMeasureBeat( pTempoAtDragPoint->m_mtTime, &lMeasure, &lBeat ) ) )
		{
			return E_UNEXPECTED;
		}
		if( FAILED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &mtTime ) ) )
		{
			return E_UNEXPECTED;
		}
	}
	else
	{
		// Get clock from pITimelineDataObject
		if( FAILED( pITimelineDataObject->GetBoundaries( &mtTime, NULL ) ) )
		{
			return E_UNEXPECTED;
		}
		
		// Adjust to measure/beat boundary
		long lMeasure, lBeat;
		m_pTempoMgr->m_pTimeline->ClocksToMeasureBeat( m_pTempoMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
		m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, 0, lMeasure, lBeat, &mtTime );
	}



	// Save the commands into the stream.
	hr = m_pTempoMgr->SaveSelectedTempos( pStreamCopy, mtTime );
	if( FAILED( hr ))
	{
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfTempoList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pTempoMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pTempoMgr->GetBoundariesOfSelectedTempos( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfTempoList, pStreamCopy );

		// Release the IStream we copied into
		pStreamCopy->Release();

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the IDMUSProdTimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(	m_pTempoMgr->m_pCopyDataObject )
		{
			m_pTempoMgr->m_pCopyDataObject->Release();
		}

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pTempoMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the ITimelienDataObject
		//m_pTempoMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::PasteAt

HRESULT CTempoStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, MUSIC_TIME mtTime, BOOL &fChanged)
{
	if( pITimelineDataObject == NULL )
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if( pITimelineDataObject->IsClipFormatAvailable( m_cfTempoList ) == S_OK )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfTempoList, &pIStream)))
		{
			// Check for RIFF format
			if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				goto Leave;
			}

			MMCKINFO ck;
			ck.ckid = DMUS_FOURCC_TEMPO_TRACK;
			if ( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
			{
				// get offset of first tempo's drag position to normalize all tempos to offset zero:
				PROD_IO_TEMPO_ITEM iTempo;
				DWORD dwByteCount;
				DWORD dwTempoSize;
				long lChunkSize;

				hr = pIStream->Read( &dwTempoSize, sizeof(dwTempoSize), &dwByteCount );
				if( FAILED( hr ) || dwByteCount != sizeof(dwTempoSize) )
				{
					hr = E_FAIL;
					goto Leave;
				}

				ASSERT( dwTempoSize == sizeof(PROD_IO_TEMPO_ITEM) );
				if( dwTempoSize != sizeof(PROD_IO_TEMPO_ITEM) )
				{
					hr = E_FAIL;
					goto Leave;
				}

				lChunkSize = ck.cksize - sizeof(dwTempoSize);

				// Save the original stream position
				DWORD dwOrigPos = StreamTell( pIStream );

				// Scan through all tempos to find the last one
				long lOrigSize = lChunkSize;
				long lLastTime = LONG_MIN;
				long lFirstTime = LONG_MAX;
				long lFirstOffset = 0;
				while( lChunkSize >= (signed) dwTempoSize )
				{
					hr = pIStream->Read( &iTempo, sizeof(PROD_IO_TEMPO_ITEM), &dwByteCount );
					if( FAILED( hr ) || dwByteCount != sizeof(PROD_IO_TEMPO_ITEM) )
					{
						hr = E_FAIL;
						goto Leave;
					}

					lChunkSize -= dwByteCount;

					if( lLastTime < iTempo.lTime )
					{
						lLastTime = iTempo.lTime;
					}
					if( lFirstTime > iTempo.lTime )
					{
						lFirstTime = iTempo.lTime;
						lFirstOffset = iTempo.lOffset;
					}
				}

				// Ensure the last tempo won't display past the end of the segment
				VARIANT var;
				if( SUCCEEDED( m_pTempoMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var ) ) )
				{
					if( lLastTime + mtTime >= V_INT(&var) )
					{
						mtTime = V_INT(&var) - lLastTime - 1;

						// Snap it to the last possible beat
						long lMeasure, lBeat;
						if( SUCCEEDED( m_pTempoMgr->m_pTimeline->ClocksToMeasureBeat( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, mtTime, &lMeasure, &lBeat ) ) )
						{
							m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &mtTime );
						}
					}
				}

				// Ensure the first tempo won't display before the start of the segment
				if( mtTime + lFirstTime < 0 )
				{
					// Make the first tempo display at time lFirstOffset
					mtTime = lFirstOffset - lFirstTime;
				}

				// Reset the stream pointer to the start position
				StreamSeek( pIStream, dwOrigPos, STREAM_SEEK_SET );

				lChunkSize = lOrigSize;

				while( lChunkSize > 0 )
				{
					hr = pIStream->Read( &iTempo, sizeof(PROD_IO_TEMPO_ITEM), &dwByteCount );
					if( FAILED( hr ) || dwByteCount != sizeof(PROD_IO_TEMPO_ITEM) )
					{
						hr = E_FAIL;
						goto Leave;
					}

					lChunkSize -= dwByteCount;

					CTempoItem* pItem = new CTempoItem;
					if ( pItem == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto Leave;
					}

					pItem->m_mtTime = iTempo.lTime + mtTime;
					pItem->m_dblTempo = iTempo.dblTempo;
					pItem->m_strText.Format("%.2f", pItem->m_dblTempo);

					pItem->m_fSelected = TRUE;

					// Compute the Measure, Beat, Grid, and Offset
					m_pTempoMgr->SetPropTempoBarBeat( (CPropTempo*) pItem );

					// If there is an empty tempo at this position, remove it
					CTempoItem* pTopItem = GetTopTempoFromMeasureBeatAndPosition( pItem->m_lMeasure, pItem->m_lBeat, NULL );
					if( pTopItem && pTopItem->m_strText.IsEmpty() )
					{
						m_pTempoMgr->RemoveItem( pTopItem );
						delete pTopItem;
					}

					fChanged = TRUE;
					m_pTempoMgr->InsertByAscendingTime( pItem, TRUE );
				}

				// Ascend out of our chunk
				pIRiffStream->Ascend( &ck, 0 );

				hr = S_OK;
			}
			else
			{
				// Nothing to paste
				hr = S_FALSE;
			}
		}
	}

Leave:
	RELEASE( pIRiffStream );
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Paste

HRESULT CTempoStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	// Make sure we can paste
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Get a Timeline pointer
	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTempoMgr->m_pTimeline != NULL );
	if( m_pTempoMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfTempoList == 0 )
	{
		m_cfTempoList = RegisterClipboardFormat( CF_TEMPOLIST );
		if( m_cfTempoList == 0 )
		{
			return E_FAIL;
		}
	}
	
	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pTempoMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		RELEASE( pIDataObject );
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pTempoMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	// Get the time to paste at
	MUSIC_TIME mtTime;
	if( FAILED( m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}
	long lMeasure, lBeat;
	if( FAILED( m_pTempoMgr->m_pTimeline->ClocksToMeasureBeat( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, mtTime, &lMeasure, &lBeat ) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}
	long lClocks;
	if( FAILED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &lClocks) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			fChanged = m_pTempoMgr->DeleteBetweenTimes( mtTime, mtTime + lEnd - lStart );
		}
	}

	// Unselect the previous tempos
	m_pTempoMgr->UnselectAll();

	// Now, do the paste operation
	hr = PasteAt(pITimelineDataObject, lClocks, fChanged);
	RELEASE( pITimelineDataObject );

	// If successful and something changed, redraw our strip
	if(SUCCEEDED(hr) && fChanged)
	{
		// Set the last edit type
		m_nLastEdit = IDS_PASTE;

		// Update our hosting editor.
		m_pTempoMgr->OnDataChanged();

		// Redraw our strip
		m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		m_pTempoMgr->OnShowProperties();
		if( m_pTempoMgr->m_pPropPageMgr )
		{
			m_pTempoMgr->m_pPropPageMgr->RefreshData();
		}

	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Insert

HRESULT CTempoStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_lXPos < 0 )
	{
		return E_FAIL;
	}

	// Unselect all items in this strip 
	m_pTempoMgr->UnselectAll();
	
	// Unselect items in other strips
	UnselectGutterRange();

	if( !m_pTempoMgr->m_pTimeline )
	{
		return E_FAIL;
	}

	// BUGBUG: Need to fix this.  Should check if m_lXPos is valid, if not, use the time cursor.
	long lMeasure, lBeat;
	if( FAILED( m_pTempoMgr->m_pTimeline->PositionToMeasureBeat( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, m_lXPos, &lMeasure, &lBeat ) ) )
	{
		return E_FAIL;
	}
	long lClocks;
	if( FAILED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &lClocks ) ) )
	{
		return E_FAIL;
	}

	HRESULT hr = S_OK;
	CTempoItem* pTempo;
	bool fNewTempo = false;
	pTempo = GetTopTempoFromPoint( m_lXPos );
	if (!pTempo || (pTempo->m_dblTempo != 0.0) )
	{
		pTempo = new CTempoItem;
		fNewTempo = true;
	}

	if(pTempo == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pTempo->m_dblTempo = 120;
		pTempo->m_strText.Format("%.2f", pTempo->m_dblTempo);
		pTempo->m_mtTime = lClocks;
		m_pTempoMgr->SetPropTempoBarBeat( (CPropTempo*)pTempo );
		pTempo->m_fSelected = TRUE;
		if( fNewTempo )
		{
			m_pTempoMgr->InsertByAscendingTime(pTempo, FALSE);
		}

		// TODO: Replace NULL by actual area invalidated (in strip coordinates)
		m_pTempoMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
		ShowPropertySheet(m_pTempoMgr->m_pTimeline);
		m_pTempoMgr->OnShowProperties();
			
		if( m_pTempoMgr->m_pPropPageMgr )
		{
			m_pTempoMgr->m_pPropPageMgr->RefreshData();
		}
		m_nLastEdit = IDS_INSERT;
		m_pTempoMgr->OnDataChanged();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Delete

HRESULT CTempoStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	if( CanDelete() != S_OK )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTempoMgr->m_pTimeline != NULL );
	if( m_pTempoMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pTempoMgr->DeleteSelectedTempos();

	m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	if( m_pTempoMgr->m_pPropPageMgr )
	{
		m_pTempoMgr->m_pPropPageMgr->RefreshData();
	}

	m_nLastEdit = IDS_DELETE;
	m_pTempoMgr->OnDataChanged();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::SelectAll

HRESULT CTempoStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pTempoMgr->m_pTimeline != NULL );
	if( m_pTempoMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	m_pTempoMgr->SelectAll();

	m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanCut

HRESULT CTempoStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pTempoMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanCopy

HRESULT CTempoStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pTempoMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pTempoMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pTempoMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanPaste

HRESULT CTempoStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	ASSERT( m_pTempoMgr != NULL );
	if( m_pTempoMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if( m_cfTempoList == 0 )
	{
		m_cfTempoList = RegisterClipboardFormat( CF_TEMPOLIST );
		if( m_cfTempoList == 0 )
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfTempoList );
	}
	// Otherwise, check the clipboard
	else
	{
		hr = E_FAIL;

		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pTempoMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfTempoList);
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanInsert

HRESULT CTempoStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_lXPos >= 0 )
	{
		//BUGBUG: This doesn't seem right.
		CPropTempo* pTempo;
		pTempo = GetTopTempoFromPoint( m_lXPos );
		if( !pTempo || pTempo->m_dblTempo == 0.0 )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanDelete

HRESULT CTempoStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return m_pTempoMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanSelectAll

HRESULT CTempoStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fInRightClickMenu == FALSE )
	{
		// Always enable when gutter is selected
		if( m_bGutterSelected )
		{
			return S_OK;
		}
	}

	CTempoItem* pTempoItem;

	POSITION pos = m_pTempoMgr->m_lstTempos.GetHeadPosition();
	while( pos )
	{
		pTempoItem = m_pTempoMgr->m_lstTempos.GetNext( pos );

		if( pTempoItem->m_dblTempo != 0.0 )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::QueryContinueDrag

HRESULT CTempoStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GiveFeedback

HRESULT CTempoStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER( dwEffect );

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CreateDragImage

CImageList* CTempoStrip::CreateDragImage()
{
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CreateDataObject

HRESULT	CTempoStrip::CreateDataObject(IDataObject** ppIDataObject, long lPosition)
{
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Convert lPosition from pixels to clocks
	long lMeasure, lBeat;
	if( FAILED( m_pTempoMgr->m_pTimeline->PositionToMeasureBeat( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lPosition, &lMeasure, &lBeat ) ) )
	{
		return E_UNEXPECTED;
	}
	long lClocks;
	if( FAILED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &lClocks ) ) )
	{
		return E_UNEXPECTED;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected Tempos into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( m_pTempoMgr->m_pDMProdFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		// mark the tempos as being dragged: this used later for deleting tempos in drag move
		m_pTempoMgr->MarkSelectedTempos(UD_DRAGSELECT);
		if( SUCCEEDED ( m_pTempoMgr->SaveSelectedTempos( pIStream, lClocks ) ) )
		{
			// Place CF_TEMPOLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfTempoList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}


	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::DragEnter

HRESULT CTempoStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Show the feedback image
			m_pDragImage->DragEnter( pWnd->GetDesktopWindow(), point );
		}
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::DragOver

HRESULT CTempoStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( (pt.x >= 0) && (CanPasteFromData( m_pITargetDataObject ) == S_OK) )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::DragLeave

HRESULT CTempoStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	if( m_pDragImage )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Hide the feedback image
			m_pDragImage->DragLeave( pWnd->GetDesktopWindow() );
		}
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::Drop

HRESULT CTempoStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER( grfKeyState );

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		CWnd *pWnd = GetTimelineCWnd();
		if( pWnd )
		{
			// Hide the feedback image
			m_pDragImage->DragLeave( pWnd->GetDesktopWindow() );
		}
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if( pWnd )
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					TranslateMessage( &msg );
					DispatchMessage( &msg );
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	// If the drop effect is not 'None' and (we are dragging from another strip,
	// or the drop point is not the start point) try and do the drop
	if( (m_dwOverDragEffect != DROPEFFECT_NONE) && (!m_fInDragDrop || (pt.x != m_lStartDragPosition) ) )
	{
		// BUGBUG: Error messages?
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pTempoMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				MUSIC_TIME mtTime;
				long lMeasure;
				long lBeat;

				if( SUCCEEDED( m_pTempoMgr->m_pTimeline->PositionToMeasureBeat( m_pTempoMgr->m_dwGroupBits, 0, pt.x, &lMeasure, &lBeat ) ) )
				{
					if( SUCCEEDED( m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( m_pTempoMgr->m_dwGroupBits, m_pTempoMgr->m_dwIndex, lMeasure, lBeat, &mtTime ) ) )
					{
						BOOL fChanged = FALSE;
						hr = PasteAt( pITimelineDataObject, mtTime, fChanged);
						if( SUCCEEDED ( hr ) )
						{
							*pdwEffect = m_dwOverDragEffect;

							// If we pasted anything
							if( fChanged )
							{
								// Set the last edit type
								m_nLastEdit = IDS_PASTE;

								// If we are pasting data that originated in another strip,
								// or if we just did a copy,
								// update our hosting editor.
								if( !m_fInDragDrop
								||	(m_dwOverDragEffect & DROPEFFECT_COPY) )
								{
									m_pTempoMgr->OnDataChanged();
								}

								// Redraw our strip
								m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

								m_fInDragDrop = FALSE;

								// BUGBUG: This is wrong! - We should use the time of the
								// tempo that the user just dropped at this time (but we don't
								// know which tempo they were dragging..)
								//m_pCurrentlySelectedTempoItem = pTempo;
							}
						}
					}
				}
			}
			RELEASE( pITimelineDataObject );
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GetTimelineCWnd

CWnd* CTempoStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pTempoMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pTempoMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::CanPasteFromData

HRESULT CTempoStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfTempoList ) ))
	{
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::GetData

HRESULT CTempoStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pTempoMgr->m_dwGroupBits;
		pPPGTrackParams->dwPropPageFlags = GROUPBITSPPG_GROUPBITS_RO;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pTempoMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pTempoMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::SetData

HRESULT CTempoStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		ASSERT(FALSE);
		/* Can't change group bits settings
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pBaseMgr->m_dwGroupBits )
		{
			m_pBaseMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			// Time signature may have changed
			m_pBaseMgr->OnUpdate( GUID_TimeSignature, m_pBaseMgr->m_dwGroupBits, NULL );

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pBaseMgr->OnDataChanged();

			// Update m_dwOldGroupBits after the call to OnDataChanged, because it is needed
			// to ensure the StripMgre removes itself correctly from the Timeline's notification
			// list.
			m_pBaseMgr->m_dwOldGroupBits = *(DWORD*)pData;
		}
		*/
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pTempoMgr->m_dwTrackExtrasFlags )
		{
			m_pTempoMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pTempoMgr->m_pTimeline->OnDataChanged( (ITempoMgr*)m_pTempoMgr );
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pTempoMgr->m_dwProducerOnlyFlags )
		{
			m_pTempoMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pTempoMgr->m_pTimeline->OnDataChanged( (ITempoMgr*)m_pTempoMgr );
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::OnShowProperties

HRESULT CTempoStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( !m_pTempoMgr->m_pTimeline )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pTempoMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	pIFramework->Release();
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Piano Roll property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pTempoMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::OnRemoveFromPageManager

HRESULT CTempoStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::AddTempo

HRESULT	CTempoStrip::AddTempo( double dblTempo, MUSIC_TIME mtTime )
{
	if( !m_pTempoMgr->m_pTimeline )
	{
		return E_FAIL;
	}

	CTempoItem* pTempo = new CTempoItem;
	if( pTempo == NULL )
	{
		return E_OUTOFMEMORY;
	}

	long lMeasure, lBeat;
	m_pTempoMgr->ClocksToMeasureBeat( mtTime, &lMeasure, &lBeat );

	pTempo->m_mtTime = mtTime; 
	pTempo->m_lMeasure = lMeasure;
	pTempo->m_lBeat = lBeat;
	pTempo->m_lOffset = 0;

	pTempo->m_dblTempo = dblTempo;
	pTempo->m_strText.Format("%.2f", pTempo->m_dblTempo);

	m_pTempoMgr->InsertByAscendingTime( pTempo, TRUE );
	m_pTempoMgr->SyncWithDirectMusic();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::ShowPropertySheet

HRESULT CTempoStrip::ShowPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
			punk->Release();
		}
	}
	m_pTempoMgr->OnShowProperties();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::OnLButtonDown

HRESULT CTempoStrip::OnLButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( lYPos );

	m_fSingleSelect = FALSE;

	// If we're already dragging, just return
	if( m_pDragImage )
	{
		return S_OK;
	}

	// Validate reference to the timeline
	if( !m_pTempoMgr->m_pTimeline )
	{
		return E_FAIL;
	}

	// Unselect items in other strips
	UnselectGutterRange();

	HRESULT hr = S_OK;

	// Capture mouse so we get the WM_LBUTTONUP message as well.
	// The timeline will release the capture when it receives the
	// WM_LBUTTONUP message.
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = TRUE;
	m_pTempoMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	// Show Tempo properties
	m_fShowTempoProps = TRUE;

	// See if there is a tempo under the cursor.
	CTempoItem* pTempo = GetTopTempoFromPoint( lXPos );
	if( pTempo && (pTempo->m_dblTempo != 0.0) )
	{
		// There is a "Real' tempo on this beat
		if( wParam & MK_CONTROL )
		{
			if( pTempo->m_fSelected )
			{
				// Do drag/drop
				hr = DoDragDrop( wParam, lXPos );

				// If we cancelled (or didn't do) a drag'n'drop operation.
				if( FAILED(hr) )
				{
					pTempo->m_fSelected = !pTempo->m_fSelected;
					m_pCurrentlySelectedTempoItem = pTempo;
				}
			}
			else
			{
				pTempo->m_fSelected = !pTempo->m_fSelected;
				if( pTempo->m_fSelected )
				{
					// Set fields to initiate drag/drop on next mousemove
					m_dwStartDragButton = (unsigned long)wParam;
					m_lStartDragPosition = lXPos;
					m_fLButtonDown = TRUE;
				}
				m_pCurrentlySelectedTempoItem = pTempo;
			}
		}
		else if( wParam & MK_SHIFT )
		{
			pTempo->m_fSelected = TRUE;
			SelectRange( pTempo );
		}
		else
		{
			if( pTempo->m_fSelected == FALSE )
			{
				m_pTempoMgr->UnselectAll();
				pTempo->m_fSelected = TRUE;
				m_pCurrentlySelectedTempoItem = pTempo;
			}
			else
			{
				m_fSingleSelect = TRUE;
			}
			
			// Set fields to initiate drag/drop on next mousemove
			m_dwStartDragButton = (unsigned long)wParam;
			m_lStartDragPosition = lXPos;
			m_fLButtonDown = TRUE;
		}
	}
	else
	{
		// There is not a "real" tempo on this measure
		hr = S_OK;
		if( pTempo == NULL )
		{
			// Create a "fake" Tempo
			MUSIC_TIME mtTime = 0;
			m_pTempoMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime );
			hr = m_pTempoMgr->CreateTempo( mtTime, pTempo );
		}

		if( SUCCEEDED( hr ) )
		{
			if(wParam & MK_CONTROL)
			{
				pTempo->m_fSelected = !pTempo->m_fSelected;
				m_pCurrentlySelectedTempoItem = pTempo;
			}
			else if( wParam & MK_SHIFT )
			{
				pTempo->m_fSelected = TRUE;
				SelectRange( pTempo );
			}
			else
			{
				// click on empty space deselects all
				m_pTempoMgr->UnselectAll();

				pTempo->m_fSelected = TRUE;
				m_pCurrentlySelectedTempoItem = pTempo;
			}
		}
	}

	// Redraw the strip and refresh the Tempo property page
	m_pTempoMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
	m_pTempoMgr->OnShowProperties();
	if( m_pTempoMgr->m_pPropPageMgr )
	{
		m_pTempoMgr->m_pPropPageMgr->RefreshData();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::UpdateName

void CTempoStrip::UpdateName()
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( m_pTempoMgr->m_dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	strTmp.LoadString( IDS_STRIP_NAME );

	m_strName = strText + CString(": ") + strTmp;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::OnRButtonDown

HRESULT CTempoStrip::OnRButtonDown( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos)
{
	UNREFERENCED_PARAMETER( lParam );
	UNREFERENCED_PARAMETER( lYPos );
	ASSERT( m_pTempoMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected first.
	UnselectGutterRange();

	// Get the item at the mouse click.
	CTempoItem* pTempo = GetTopTempoFromPoint( lXPos );

	if (!pTempo)
	{
		// no Tempo, so create a 'fake' one
		m_pTempoMgr->UnselectAll();

		// now, create the tempo item and insert it into the tempo manager's list
		HRESULT hr;
		MUSIC_TIME mtTime = 0;
		m_pTempoMgr->m_pTimeline->PositionToClocks( lXPos, &mtTime );
		hr = m_pTempoMgr->CreateTempo( mtTime, pTempo);
		if (SUCCEEDED(hr))
		{
			pTempo->m_fSelected = TRUE;
		}

		m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
	}
	else if( m_pTempoMgr->IsSelected() == FALSE )
	{
		m_pTempoMgr->UnselectAll();
		// Select the item at the mouse click (if there is one).
		// Different from commands, which select empty measures.
		pTempo->m_fSelected = TRUE;
		m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
	}
	else if( !(wParam & (MK_CONTROL | MK_SHIFT)) )
	{
		if( pTempo->m_fSelected == FALSE )
		{
			m_pTempoMgr->UnselectAll();
			pTempo->m_fSelected = TRUE;
		}
		m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*) this, NULL, TRUE );
	}

	m_fShowTempoProps = TRUE;
	m_pTempoMgr->OnShowProperties();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::UnselectGutterRange

void CTempoStrip::UnselectGutterRange( void )
{
	ASSERT( m_pTempoMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pTempoMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pTempoMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTempoStrip::DoDragDrop

HRESULT CTempoStrip::DoDragDrop(WPARAM mousekeybutton, LONG lXPos)
{
	HRESULT hr = E_FAIL;
	BOOL fDrop = TRUE;

	// drag drop will capture mouse, so release it from timeline
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pTempoMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	IDropSource*	pIDropSource;
	DWORD			dwEffect = DROPEFFECT_NONE;

	// Query ourself for our IDropSource interface
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// Create a data object from the selected tempos
		hr = CreateDataObject( &m_pISourceDataObject, lXPos );
		if(SUCCEEDED(hr))
		{
			m_fInDragDrop = TRUE;

			// Create an image to use when dragging tempos
			m_pDragImage = CreateDragImage();
			if(m_pDragImage)
			{
				m_pDragImage->BeginDrag(0, CPoint(8,12));
			}

			// We can always copy tempos.
			DWORD dwOKDragEffects = DROPEFFECT_COPY;
			if(CanCut() == S_OK)
			{
				// If we can Cut(), allow the user to move the tempos as well.
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}

			// Do the Drag/Drop.
			m_dwStartDragButton = (unsigned long)mousekeybutton;
			m_lStartDragPosition = lXPos;
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// Drag/Drop completed, clean up
			m_dwStartDragButton = 0;

			// delete thr drag image
			if(m_pDragImage)
			{
				m_pDragImage->EndDrag();
				delete m_pDragImage;
				m_pDragImage = NULL;
			}

			switch(hr)
			{
			case DRAGDROP_S_DROP:
				// If we did a move, delete the tempos that were selected (since they were
				// dropped somewhere else.
				if(dwEffect & DROPEFFECT_MOVE)
				{
					m_pTempoMgr->DeleteMarked(UD_DRAGSELECT);
					// TODO: replace NULL by actual area invalidated (in strip coordinates)
					m_pTempoMgr->m_pTimeline->StripInvalidateRect(this, NULL, TRUE);
					m_pTempoMgr->OnShowProperties();
					if( m_pTempoMgr->m_pPropPageMgr )
					{
						m_pTempoMgr->m_pPropPageMgr->RefreshData();
					}
					if( m_fInDragDrop )
					{
						m_nLastEdit = IDS_DELETE;
					}
					else
					{
						m_nLastEdit = IDS_MOVE;
					}

					// We just deleted some data from this strip, update our hosting editor.
					m_pTempoMgr->OnDataChanged();
					m_pTempoMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );
				}
				if(dwEffect == DROPEFFECT_NONE)
				{
					fDrop = FALSE;
				}
				break;
			default:
				fDrop = FALSE;
				break;
			}
			hr = S_OK;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;

			m_fInDragDrop = FALSE;
		}
		else
		{
			pIDropSource->Release();
			return E_FAIL;
		}
		pIDropSource->Release();
		m_pTempoMgr->UnMarkTempos(UD_DRAGSELECT);
	}
	else
	{
		return E_FAIL;
	}

	// The Drag and Drop methods should handle redrawing the strip and updating the
	// property pages.
	if( fDrop )
	{
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

// CTempoStrip::SelectRange()

HRESULT CTempoStrip::SelectRange(CTempoItem* pTempo)
{
	HRESULT hr = S_OK;
	// select inclusive, find tempo to start from
	CTempoItem* pCurrent = m_pCurrentlySelectedTempoItem;

	// find measure and beat for tempo to start from and tempo to end at
	long lEarlyBeat = (pCurrent) ? pCurrent->m_lBeat : 0;
	long lEarlyMeasure = (pCurrent) ? pCurrent->m_lMeasure : 0;
	long lLateBeat = pTempo->m_lBeat;
	long lLateMeasure = pTempo->m_lMeasure;

	// if the order is backwards, swap
	if ( lLateMeasure < lEarlyMeasure ||
		 (lLateMeasure == lEarlyMeasure && lLateBeat < lEarlyBeat) )
	{
		long lTemp = lEarlyBeat;
		lEarlyBeat = lLateBeat;
		lLateBeat = lTemp;

		lTemp = lEarlyMeasure;
		lEarlyMeasure = lLateMeasure;
		lLateMeasure = lTemp;
	}

	// add empty empty tempos to fill in gaps
	long lCurrentBeat = lEarlyBeat;
	long lCurrentMeasure = lEarlyMeasure;
	CTempoItem* pTempoItem = NULL;
	while( lCurrentMeasure <= lLateMeasure &&
		   ( lCurrentBeat <= lLateBeat || lCurrentMeasure < lLateMeasure ) )
	{
		if ( !m_pTempoMgr->FindTempo(lCurrentMeasure, lCurrentBeat) )
		{
			MUSIC_TIME mtPosition = 0;
			m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( 
				m_pTempoMgr->m_dwGroupBits, 
				0, 
				lCurrentMeasure, 
				lCurrentBeat, 
				&mtPosition );
			pTempoItem = NULL;
			hr = m_pTempoMgr->CreateTempo(mtPosition, pTempoItem);
		}
		lCurrentBeat++;
		DMUS_TIMESIGNATURE TS;
		long lClocks = 0;
		m_pTempoMgr->m_pTimeline->MeasureBeatToClocks( 
				m_pTempoMgr->m_dwGroupBits, 
				0, 
				lCurrentMeasure, 
				lCurrentBeat, 
				&lClocks );
		hr = m_pTempoMgr->m_pTimeline->GetParam(
			GUID_TimeSignature, 
			m_pTempoMgr->m_dwGroupBits, 
			0, 
			lClocks, 
			NULL, 
			(void*) &TS);
		ASSERT(SUCCEEDED(hr));
		BYTE bBeats = 4;  // assume 4/4 if the above call fails
		if (SUCCEEDED(hr))
		{
			bBeats = TS.bBeatsPerMeasure;
		}
		if (lCurrentBeat >= bBeats)
		{
			lCurrentBeat = 0;
			lCurrentMeasure++;
		}
	}
	m_pTempoMgr->UnselectAll();
	m_pCurrentlySelectedTempoItem = pCurrent;

	// select all tempos in the range (can't simply select tempos in the
	// above loop, because there may be multiple tempos at the same
	// measure/beat)
	POSITION pos = m_pTempoMgr->m_lstTempos.GetHeadPosition();
	pTempoItem = NULL;
	while( pos )
	{
		pTempoItem = m_pTempoMgr->m_lstTempos.GetNext( pos );
		ASSERT( pTempoItem );
		if( pTempoItem->m_lMeasure >= lEarlyMeasure &&
			pTempoItem->m_lMeasure <= lLateMeasure &&
			( pTempoItem->m_lMeasure != lEarlyMeasure || 
			  pTempoItem->m_lBeat >= lEarlyBeat) &&
			( pTempoItem->m_lMeasure != lLateMeasure || 
			  pTempoItem->m_lBeat <= lLateBeat) )
		{
			pTempoItem->m_fSelected = TRUE;
		}
	}
	return hr;
}


long CTempoStrip::GetBeatWidth(long measure)
// get positional width of beat
{
	// Determine width of a beat
	long lBeatBeginPosition = 0;
	long lBeatEndPosition = 0;
	m_pTempoMgr->m_pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, measure, 0, &lBeatBeginPosition );
	m_pTempoMgr->m_pTimeline->MeasureBeatToPosition( m_pTempoMgr->m_dwGroupBits, 0, measure, 1, &lBeatEndPosition );
	long lBeatLength = lBeatEndPosition - lBeatBeginPosition;
	return lBeatLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\TempoStripMgr\TempoStripMgr.cpp ===
// TempoStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f TempoStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "TempoStripMgr.h"
#include <AFXCTL.H>

#include <initguid.h>
#include "TempoMgr.h"
#include <dmusici.h>
#include <SegmentGuids.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TempoMgr, CTempoMgr)
END_OBJECT_MAP()

class CTempoStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CTempoStripMgrApp theApp;

BOOL CTempoStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();
	return CWinApp::InitInstance();
}

int CTempoStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_TempoMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicTempoTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicTempoTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_TEMPOSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\ContextMenuHandler.cpp ===
// ContextMenuHandler.cpp : Implementation of temporary window to handle WM_COMMAND messages 
//							from the context menu.
//

#include "stdafx.h"
#include "TimelineCtl.h"
#include "ContextMenuHandler.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler

CContextMenuHandler::CContextMenuHandler()
{
	m_pStrip = NULL;
	m_hwndDeleteTracks = NULL;
	m_pTimeline = NULL;
	m_fCustomMenu = FALSE;
}

CContextMenuHandler::~CContextMenuHandler()
{
}


BEGIN_MESSAGE_MAP(CContextMenuHandler, CWnd)
	//{{AFX_MSG_MAP(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler message handlers

BOOL CContextMenuHandler::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	if( !m_fCustomMenu )
	{
		HRESULT hr = S_FALSE;

		if( ((LOWORD( wParam ) == ID_EDIT_DELETE_TRACK) || (LOWORD( wParam ) == ID_EDIT_ADD_TRACK)) && m_hwndDeleteTracks)
		{
			::SendMessage( m_hwndDeleteTracks, WM_COMMAND, wParam, lParam );
			hr = S_OK;
		}
		else if( m_pStrip != NULL )
		{
			switch( LOWORD( wParam ) )
			{
			case ID_EDIT_PASTE_MERGE:
				m_pTimeline->SetPasteType( TL_PASTE_MERGE );
				wParam = MAKELONG( ID_EDIT_PASTE, HIWORD(wParam) );
				break;
			case ID_EDIT_PASTE_OVERWRITE:
				m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
				wParam = MAKELONG( ID_EDIT_PASTE, HIWORD(wParam) );
				break;
			}
			hr = m_pStrip->OnWMMessage( WM_COMMAND, wParam, lParam, 0, 0 );
		}
		else // m_pStrip == NULL
		{
			BOOL bReturn; // For OnZoomIn and OnZoomOut
			switch( LOWORD( wParam ) )
			{
			case ID_EDIT_PASTE_MERGE:
				m_pTimeline->SetPasteType( TL_PASTE_MERGE );
				hr = m_pTimeline->Paste( NULL );
				break;
			case ID_EDIT_PASTE_OVERWRITE:
				m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
				hr = m_pTimeline->Paste( NULL );
				break;
			case ID_VIEW_PROPERTIES:
				m_pTimeline->DisplayPropertySheet();
				hr = m_pTimeline->OnShowProperties();
				break;
			case ID_EDIT_CUT:
				hr = m_pTimeline->Cut( NULL );
				break;
			case ID_EDIT_COPY:
				hr = m_pTimeline->Copy( NULL );
				break;
			case ID_EDIT_DELETE:
				hr = m_pTimeline->Delete();
				break;
			case ID_EDIT_PASTE:
				m_pTimeline->SetPasteType( TL_PASTE_MERGE );
				hr = m_pTimeline->Paste( NULL );
				break;
			case ID_EDIT_INSERT:
				hr = m_pTimeline->Insert();
				break;
			case ID_EDIT_SELECT_ALL:
				hr = m_pTimeline->SelectAll();
				break;
			case ID_EDIT_HORIZZOOMIN:
				m_pTimeline->OnZoomIn( 0, 0, 0, bReturn );
				hr = S_OK;
				break;
			case ID_EDIT_HORIZZOOMOUT:
				m_pTimeline->OnZoomOut( 0, 0, 0, bReturn );
				hr = S_OK;
				break;
			default:
				hr = E_FAIL;
				break;
			}
		}
		
		if( hr == S_OK )
		{
			return TRUE;
		}
	}
	else if( m_pStrip )
	{
		if( m_pStrip->OnWMMessage( WM_COMMAND, wParam, lParam, 0, 0 ) == S_OK )
		{
			return TRUE;
		}
	}

	return CWnd::OnCommand( wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\PrivateTimelineCtl.cpp ===
// PrivateTimelineCtl.cpp : Implementation of CPrivateTimelineCtl
// @doc Timeline
#include "stdafx.h"
#include <math.h>
#include <SegmentGuids.h>
#include "Timeline.h"
#include "PrivateTimelineCtl.h"
#include "TimelineCtl.h"
#include "TimeStripMgr.h"
#pragma warning( push )
#pragma warning( disable : 4005 )
#include <winresrc.h>
#pragma warning( pop )
#include <Conductor.h>
#include <initguid.h>
#include <dmusici.h>
#include <dmusicf.h>
#include "TimelineDataObject.h"
#include "SegmentIO.h"
#include "windowsx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


CPrivateTimelineCtl::CPrivateTimelineCtl()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pDMUSProdFramework = NULL;
	m_pTimelineCtl = NULL;
	m_pStripMgrList = NULL;
	m_pStripList = NULL;
	m_pActiveStripList = NULL;
	m_pTempoMapMgr = NULL;
	m_dblZoom = .125; // set initial zoom factor
	m_lLength = DMUS_PPQ * 4 * 20; // start at 20 measures, four quarter notes per measure
	m_lXScrollPos = 0;
	m_lYScrollPos = 0;
	m_fFreezeUndo = FALSE;
	m_lFunctionBarWidth = LEFT_DRAW_OFFSET + 80;
	m_pTimelineCallback = NULL;
	m_fMusicTime = TRUE;
	m_ptPasteType = TL_PASTE_OVERWRITE;
	m_lstNotifyEntry.RemoveAll();
	InitializeCriticalSection( &m_csOnDataChanged );
	m_pTimeStrip = NULL;
	m_pIDMPerformance = NULL;
	m_fInSetTimelineOleCtl = false;
}

HRESULT CPrivateTimelineCtl::FinalConstruct()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// create the time display strip
	IDMUSProdStripMgr*	pSM;
	if( SUCCEEDED( CoCreateInstance( CLSID_TimeStripMgr, NULL, CLSCTX_INPROC_SERVER,
		IID_IDMUSProdStripMgr, (void**)&pSM )))
	{
		AddStripMgr( pSM, 0xffffffff );
		pSM->Release();
	}
	else
	{
		ASSERT(FALSE); // couldn't create time display mgr.
	}

	return CComObjectRootEx<CComSingleThreadModel>::FinalConstruct();
}

CPrivateTimelineCtl::~CPrivateTimelineCtl()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pTimelineCtl == NULL );

	FinalCleanUp();

	DeleteCriticalSection( &m_csOnDataChanged );
}

//  @method HRESULT | IDMUSProdTimeline | DrawMusicLines | This method draws
//		vertical bar, beat, and grid lines in the specified device context.
//
//  @parm   HDC | hdc | A handle to the device context to draw in
//  @parm   <t MUSICLINE_PROPERTY> | mlp | Which type of lines to draw.  Must be one of <t MUSICLINE_PROPERTY>
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_FAIL | Unable to attach to <p hdc>.
//	@rvalue E_INVALIDARG | <p mlp> does not contain a valid value.
//
//	@xref	<i IDMUSProdTimeline>, <t MUSICLINE_PROPERTY>
HRESULT CPrivateTimelineCtl::DrawMusicLines( HDC hdc, MUSICLINE_PROPERTY mlp, DWORD dwGroupBits, DWORD dwIndex, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	ASSERT( hdc );
	ASSERT( (mlp == ML_DRAW_MEASURE_BEAT_GRID) || (mlp == ML_DRAW_MEASURE_BEAT) );
	if ( !hdc || ((mlp != ML_DRAW_MEASURE_BEAT_GRID) && (mlp != ML_DRAW_MEASURE_BEAT)) )
	{
		return E_INVALIDARG;
	}

	// Time signature behavior:  If the time signature changes during a measure, the current time
	// signature will continute to apply for that measure.  At the end of the measure, the time
	// signature will change to the most recent one available.  Repeat this process for each
	// time signature change.

	// Create the pens
	HPEN hPenMeasureLine, hPenBeatLine, hPenSubBeatLine;
	hPenMeasureLine = ::CreatePen( MEASURE_LINE_PENSTYLE, MEASURE_LINE_WIDTH, MEASURE_LINE_COLOR );
	if( hPenMeasureLine == NULL )
	{
		return E_OUTOFMEMORY;
	}

	hPenBeatLine = ::CreatePen( BEAT_LINE_PENSTYLE, BEAT_LINE_WIDTH, BEAT_LINE_COLOR );
	if( hPenBeatLine == NULL )
	{
		::DeleteObject( hPenMeasureLine );
		return E_OUTOFMEMORY;
	}

	if ( mlp == ML_DRAW_MEASURE_BEAT_GRID )
	{
		hPenSubBeatLine = ::CreatePen( SUBBEAT_LINE_PENSTYLE, SUBBEAT_LINE_WIDTH, SUBBEAT_LINE_COLOR );
		if( hPenSubBeatLine == NULL )
		{
			::DeleteObject( hPenMeasureLine );
			::DeleteObject( hPenBeatLine );
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		hPenSubBeatLine = NULL;
	}

	// Set up our start time, end time
	RECT rectClip;
	MUSIC_TIME mtLeft, mtRight, mtTemp;
	::GetClipBox( hdc, &rectClip );
	PositionToClocks( rectClip.left + lXOffset, &mtLeft );
	// Since the bar lines are two pixels wide, we need to add 1 here
	PositionToClocks( rectClip.right + lXOffset + 1, &mtRight );

	long lPosition = 0; // integer position

	// Save the current pen and switch to the Measure Line pen
	HPEN hPenOld;
	hPenOld = static_cast<HPEN>( ::SelectObject( hdc, hPenMeasureLine ) );

	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;
	BYTE bBeat;

	// Handle drawing in negative times
	if( mtLeft < 0 )
	{
		if ( FAILED( GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, 0, NULL, &TimeSig ) ) )
		{
			::SelectObject( hdc, hPenOld );
			::DeleteObject( hPenMeasureLine );
			::DeleteObject( hPenBeatLine );
			if( hPenSubBeatLine )
			{
				::DeleteObject( hPenSubBeatLine );
			}
			return E_UNEXPECTED;
		}

		// Compute the number of clocks per measure
		const MUSIC_TIME mtClocksPerMeasure = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		mtTSCur = (mtLeft - mtClocksPerMeasure + 1) / mtClocksPerMeasure;
		mtTSCur *= mtClocksPerMeasure;
	}

	while( mtTSCur < mtRight )
	{
		if ( FAILED( GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, max( 0, mtTSCur), &mtTSNext, &TimeSig ) ) )
		{
			::SelectObject( hdc, hPenOld );
			::DeleteObject( hPenMeasureLine );
			::DeleteObject( hPenBeatLine );
			if( hPenSubBeatLine )
			{
				::DeleteObject( hPenSubBeatLine );
			}
			return E_UNEXPECTED;
		}

		MUSIC_TIME mtNext;
		if( mtTSNext == 0 )
		{
			mtTSNext = m_lLength;
			mtNext = LONG_MAX;
		}
		else
		{
			mtTSNext += max( 0, mtTSCur );
			mtNext = mtTSNext;
		}

		while( (mtTSCur < mtNext) && (mtTSCur < mtRight) )
		{
			// For this measure, compute clocks per beat and clocks per grid
			const MUSIC_TIME mtClocksPerBeat = NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// Draw this measure
			if ( mtTSCur + TimeSig.bBeatsPerMeasure * mtClocksPerBeat >= mtLeft )
			{

				// Draw measure line
				if ( mtTSCur >= mtLeft )
				{
					::SelectObject( hdc, hPenMeasureLine );
					ClocksToPosition( mtTSCur, &lPosition );
					::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
					::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );
				}

				// Draw beats
				bBeat = 1;
				::SelectObject( hdc, hPenBeatLine );
				while ( bBeat < TimeSig.bBeatsPerMeasure )
				{
					mtTSCur += mtClocksPerBeat;

					// Draw beat line
					ClocksToPosition( mtTSCur, &lPosition );
					::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
					::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );

					bBeat++;
				}

				// Draw Grids
				if ( mlp == ML_DRAW_MEASURE_BEAT_GRID )
				{
					const MUSIC_TIME mtClocksPerGrid = mtClocksPerBeat / TimeSig.wGridsPerBeat;
					bBeat = 0;
					mtTSCur = mtTSCur - mtClocksPerBeat * (TimeSig.bBeatsPerMeasure - 1);
					::SelectObject( hdc, hPenSubBeatLine );
					while ( bBeat < TimeSig.bBeatsPerMeasure )
					{
						// Draw Grids

						// Save next beat position
						mtTemp = mtTSCur + mtClocksPerBeat;

						BYTE bGrid = 1;
						mtTSCur += mtClocksPerGrid;

						// Draw grid lines
						while ( bGrid < TimeSig.wGridsPerBeat )
						{
							ClocksToPosition( mtTSCur, &lPosition );
							::MoveToEx( hdc, lPosition - lXOffset, rectClip.top, NULL );
							::LineTo( hdc, lPosition - lXOffset, rectClip.bottom );

							bGrid++;
							mtTSCur += mtClocksPerGrid;
						}
						mtTSCur = mtTemp;
						bBeat++;
					}
				}
				else
				{
					mtTSCur += mtClocksPerBeat;
				}
			}
			else
			{	// Advance time by one measure
				mtTSCur += TimeSig.bBeatsPerMeasure * mtClocksPerBeat;
			}
		}
	}

	// Restore the previous pen
	::SelectObject( hdc, hPenOld );

	::DeleteObject( hPenMeasureLine );
	::DeleteObject( hPenBeatLine );
	if( hPenSubBeatLine )
	{
		::DeleteObject( hPenSubBeatLine );
	}

	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | AddStripMgr | This method adds an <i IDMUSProdStripMgr> to the
//		list of strip managers within the Timeline.
//
//	@comm	Using the <p dwGroupBits> parameter and the Strip manager's FourCCCKIds
//		(returned by the method <om IDMUSProdStripMgr::GetFourCCCKIDs>), the Timeline determines a
//		position for the StripMgr in its internal list.<nl>
//		They are ordered first by the least track group number they belong to, then in the following order,
//		then by the order they were inserted:<nl>
//		Chord<nl>
//		Signpost<nl>
//		ChordMap Reference<nl>
//		Groove<nl>
//		Tempo<nl>
//		Style Reference<nl>
//		Sequence<nl>
//		Time Signature<nl>
//		Band<nl>
//		Mute<nl>
//		All other strips
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to add
//  @parm	DWORD | dwGroupBits | Which track group(s) this strip manager belongs to.  A value
//		of 0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. 
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p punkStripMgr>
//	@rvalue E_INVALIDARG | The strip manager was previously added to the Timeline
//	@rvalue E_OUTOFMEMORY | Unable to allocate memory while adding the strip manager
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::RemoveStripMgr>
HRESULT CPrivateTimelineCtl::AddStripMgr( IDMUSProdStripMgr* pIStripMgr, DWORD dwGroupBits)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pIStripMgr )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	StripMgrList*	pScan;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_pStripMgr == pIStripMgr )
		{
			return E_INVALIDARG;
		}
	}

	StripMgrList*	pSML = new StripMgrList( pIStripMgr, dwGroupBits );
	if( pSML )
	{
		// Empty list
		if( !m_pStripMgrList )
		{
			m_pStripMgrList = pSML;
			pSML->m_pNext = NULL;

			VARIANT varTimeline;
			varTimeline.vt = VT_UNKNOWN;
			QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
			pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
			Release();
			return S_OK;
		}

		DMUS_IO_TRACK_HEADER ioTrackHeader;
		ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
		VARIANT varTrackHeader;
		varTrackHeader.vt = VT_BYREF;
		V_BYREF(&varTrackHeader) = &ioTrackHeader;
		if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
		{
			TRACE("Timeline: Unable to get StripMgr's FourCCCKIDs\n");
		}

		int nType1, nType2;
		nType1 = StripCLSIDToInt( ioTrackHeader.guidClassID );

		StripMgrList*	pScanOld = NULL;
		for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
		{
			ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			if( FAILED( pScan->m_pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
			{
				TRACE("Timeline: Unable to get StripMgr's FourCCCKIDs\n");
			}

			// Ensure the TimeStripMgr is always the last strip
			if( pScan->m_pStripMgr->IsParamSupported( CLSID_TimeStripMgr ) == S_OK )
			{
				// if pSML should go before pScan, insert it there
				if( pScanOld )
				{
					pScanOld->m_pNext = pSML;
				}
				else
				{
					// Head of the list
					ASSERT( pScan == m_pStripMgrList );
					m_pStripMgrList = pSML;
				}
				pSML->m_pNext = pScan;

				VARIANT varTimeline;
				varTimeline.vt = VT_UNKNOWN;
				QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
				pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
				Release();
				return S_OK;
			}
			nType2 = StripCLSIDToInt( ioTrackHeader.guidClassID );

			if( CompareStrips( nType2, pScan->m_dwGroupBits, 0, NULL,
							   nType1, dwGroupBits, 0, NULL ) == 2 )
			{
				// if pSML should go before pScan, insert it there
				if( pScanOld )
				{
					pScanOld->m_pNext = pSML;
				}
				else
				{
					// Head of the list
					ASSERT( pScan == m_pStripMgrList );
					m_pStripMgrList = pSML;
				}
				pSML->m_pNext = pScan;

				VARIANT varTimeline;
				varTimeline.vt = VT_UNKNOWN;
				QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
				pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
				Release();
				return S_OK;
			}
			pScanOld = pScan;
		}
		
		// End of the list
		pScanOld->m_pNext = pSML;
		pSML->m_pNext = NULL;

		VARIANT varTimeline;
		varTimeline.vt = VT_UNKNOWN;
		QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&varTimeline)) );
		pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
		Release();
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
}

//  @method HRESULT | IDMUSProdTimeline | RemoveStripMgr | This method removes a strip manager
//		from the Timeline.
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to remove
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p punkStripMgr>
//	@rvalue E_INVALIDARG | <p pIStripMgr> was not previously added to the Timeline via
//		<om IDMUSProdTimeline::AddStripMgr>.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::AddStripMgr>
HRESULT CPrivateTimelineCtl::RemoveStripMgr(
	/* [in] */	IDMUSProdStripMgr* pIStripMgr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT			hr;

	if( NULL == pIStripMgr )
	{
		return E_POINTER;
	}
	StripMgrList	*pSML, *pSMLold;
	pSML = m_pStripMgrList;
	pSMLold = NULL;
	hr = E_INVALIDARG;
	// Remove pIStripMgr from m_pStripMgrList
	while ( pSML )
	{
		if ( pSML->m_pStripMgr == pIStripMgr )
		{
			VARIANT varTimeline;
			varTimeline.vt = VT_UNKNOWN;
			V_UNKNOWN(&varTimeline) = NULL;
			pIStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
			if ( pSMLold )
			{
				pSMLold->m_pNext = pSML->m_pNext;
			}
			else
			{
				m_pStripMgrList = pSML->m_pNext;
			}
			delete pSML;
			pSML = NULL;
			hr = S_OK;
		}
		else
		{
			pSMLold = pSML;
			pSML = pSML->m_pNext;
		}
	}

	// Remove the Stripmgr from the list of Notify Entries
	POSITION pos, pos2;
	NotifyEntry *pNotifyEntry;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		// Found guidNotify, now find pIStripMgr
		NotifyListEntry* pNotifyListEntry = NULL;
		pos2 = pNotifyEntry->m_lstNotifyListEntry.GetHeadPosition( );
		while ( pos2 != NULL )
		{
			POSITION pos3 = pos2;
			pNotifyListEntry = pNotifyEntry->m_lstNotifyListEntry.GetNext( pos2 );
			if( pNotifyListEntry->pIStripMgr == pIStripMgr )
			{
				// We've found it, now remove it from the list and delete our entry
				pNotifyEntry->m_lstNotifyListEntry.RemoveAt( pos3 );
				delete pNotifyListEntry;

				// Check if the list is empty
				if ( pNotifyEntry->m_lstNotifyListEntry.IsEmpty() )
				{
					// If the list is empty, remove it from m_lstNotifyEntry
					pos2 = m_lstNotifyEntry.Find( pNotifyEntry );
					ASSERT( pos2 );
					if ( pos2 )
					{
						m_lstNotifyEntry.RemoveAt( pos2 );
						delete pNotifyEntry;
						pos2 = NULL;
					}
				}
			}
		}
	}

	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | AddStrip | This method adds a strip at the
//		bottom of the strips displayed by the Timeline.
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to add
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p punkStrip>
//	@rvalue E_FAIL | The strip is already displayed by the Timeline
//	@rvalue E_OUTOFMEMORY | Unable to allocate memory while adding the strip
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::RemoveStrip>,
//		<om IDMUSProdTimeline::InsertStripAtDefaultPos>, <om IDMUSProdTimeline::InsertStripAtPos>.
HRESULT CPrivateTimelineCtl::AddStrip( 
    /* [in] */ IDMUSProdStrip* pIStrip)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pIStrip )
	{
		return E_POINTER;
	}

	if( m_pTimeStrip == NULL )
	{
		m_pTimeStrip = static_cast<CTimeStrip *>(pIStrip);
		ASSERT( m_pTimeStrip );
	}

	return InternalInsertStripAtPos( pIStrip, 0xffffffff, GUID_AllZeros, 1, 0 );
}

//  @method HRESULT | IDMUSProdTimeline | RemoveStrip | This method removes a strip from
//		the Timeline.
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to remove
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStrip>
//	@rvalue E_INVALIDARG | <p pIStrip> was not previously added to the Timeline via
//		<om IDMUSProdTimeline::AddStrip>.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::AddStrip>
HRESULT CPrivateTimelineCtl::RemoveStrip(
	/* [in] */	IDMUSProdStrip* pIStrip)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT			hr = S_OK;
	RECT			rect, rectWin;

	if( NULL == pIStrip )
	{
		return E_POINTER;
	}
	// if the strip is already in the list, return E_FAIL
	StripList* pSL = FindStripList(pIStrip);
	if( !pSL )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		// If this strip is active, sent it a killfocus
		if ( m_pActiveStripList == pSL )
		{
			CallStripWMMessage( pSL, WM_KILLFOCUS, 0, 0 );
			m_pActiveStripList = NULL;
		}

		// If a strip is removed after the Timeline window is destroyed,
		// don't recompute the positions of the strips and scrollbars.
		if( m_pTimelineCtl
		&&	::IsWindow( m_pTimelineCtl->m_hWnd ) )
		{
			m_pTimelineCtl->GetClientRect( &rectWin );
			m_pTimelineCtl->GetStripClientRect( pSL, &rect );
			rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
			m_pTimelineCtl->InvalidateRect( &rectWin, FALSE );
			m_pTimelineCtl->ComputeScrollBars();
		}

		// remove the strip from m_pStripList
		ASSERT(m_pStripList);
		if( m_pStripList )
		{
			StripList*	pTemp = m_pStripList;
			StripList*	pTempOld = NULL;
			while( pTemp )
			{
				if ( pTemp == pSL )
				{
					if (pTempOld)
					{
						pTempOld->m_pNext = pTemp->m_pNext;
					}
					else
					{
						m_pStripList = pTemp->m_pNext;
					}

					// Send WM_MOVE messages to all strips that were moved
					if( m_pTimelineCtl
					&&	::IsWindow(m_pTimelineCtl->m_hWnd) )
					{
						pTemp = pTemp->m_pNext;
						while( pTemp )
						{
							pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
							pTemp = pTemp->m_pNext;
						}
					}
					else
					{
						pTemp = NULL;
					}
				}
				else
				{
					pTempOld = pTemp;
					pTemp = pTemp->m_pNext;
				}
			}
		}

		if( m_pTimelineCtl )
		{
			if ( m_pTimelineCtl->m_pMouseStripList == pSL )
			{
				m_pTimelineCtl->m_pMouseStripList = NULL;
			}
			if ( m_pTimelineCtl->m_pLastDragStripList == pSL )
			{
				m_pTimelineCtl->m_pLastDragStripList = NULL;
			}
		}
		IDMUSProdTimelineEdit* pITimelineEdit;
		if ( SUCCEEDED(pIStrip->QueryInterface( IID_IDMUSProdTimelineEdit, (void**)&pITimelineEdit )))
		{
			pITimelineEdit->Release();
		}

		pIStrip->OnWMMessage( WM_DESTROY, 0, 0, 0, 0 );

		delete pSL;

		// If we need to scroll up, do so
		if( m_lYScrollPos
		&&	m_pTimelineCtl
		&&	::IsWindow( m_pTimelineCtl->m_hWnd ) )
		{
			RECT rect, rectS;
			m_pTimelineCtl->GetClientRect(&rect);
			m_pTimelineCtl->m_ScrollHorizontal.GetClientRect(&rectS);
			rect.bottom -= rectS.bottom;

			long lMaxScroll = TotalStripHeight() - rect.bottom;
			if( lMaxScroll < m_lYScrollPos )
			{
				int nPos;
				if( lMaxScroll < 1 )
				{
					nPos = 0;
				}
				else
				{
					nPos = ( lMaxScroll * m_pTimelineCtl->m_ScrollVertical.GetScrollLimit()) / lMaxScroll;
				}
				int iTemp = 0;
				m_pTimelineCtl->OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, nPos ), (LPARAM) ((HWND) m_pTimelineCtl->m_ScrollVertical), iTemp );
			}
		}
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | GetParam | This method retrieves data of the specified type
//		from a strip manager in the Timeline.
//
//  @parm   REFGUID | rguidType | Reference to the identifier of the type of data to obtain.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible data types.  Strips can also define
//		their own types for custom data.
///  @parm   DWORD | dwGroupBits | Which track group(s) to scan for the strip manager in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To scan all strip managers
//		regardless of groups, set this parameter to 0xFFFFFFFF. 
//  @parm   DWORD | dwIndex | Index of the strip manager in the group(s) from which to obtain the data. 
//  @parm   MUSIC_TIME | mtTime | Time from which to obtain the data.
//	@parm   MUSIC_TIME* | pmtNext | Address of a variable to receive the time (relative to
//		the current time) until which the data is valid. If this returns a value of 0, it means
//		either that the data will always be valid, or that it is unknown when it will become
//		invalid. If this information is not needed, <p pmtNext> may be set to NULL. 
//  @parm   void* | pData | Address of an allocated structure in which the data is to be returned. This
//		structure must be of the appropriate kind and size for the data type identified by <p rguidType>.
//
//	@comm	This method is analagous to the DirectMusic method <om IDirectMusicPerformance::GetParam>.
//
//	@comm	Strip managers are searched in the order that they are listed in the Timeline.  See
//		<om IDMUSProdTimeline::AddStripMgr> for the order they are listed.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pData>
//	@rvalue E_INVALIDARG | No strip managers support the requested <p rguidType>.
//	@rvalue E_UNEXPECTED | An internal error occurred.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::SetParam>, <om IDMUSProdStripMgr::GetParam>
HRESULT CPrivateTimelineCtl::GetParam(/* [in] */  REFGUID		guidType,
				/* [in] */  DWORD		dwGroupBits,
				/* [in] */  DWORD		dwIndex,
				/* [in] */  MUSIC_TIME	mtTime,
				/* [out] */ MUSIC_TIME*	pmtNext,
				/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	StripMgrList*	pScan;
	HRESULT hr = E_INVALIDARG;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}
			if ( pScan->m_pStripMgr->IsParamSupported( guidType ) == S_OK )
			{
				/*
				// Get the track extras flags
				VARIANT varTrackExtras;
				varTrackExtras.vt = VT_BYREF;
				DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHeader;
				if( pScan->m_pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER, &varTrackExtras ) == S_OK )
				{
					if( !(ioTrackExtrasHeader.dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED) )
					{
						continue;
					}
				}
				*/

				if ( dwIndex == 0 )
				{
					if ( pData == NULL )
					{
						return E_POINTER;
					}
					else
					{
						if( SUCCEEDED( pScan->m_pStripMgr->GetParam( guidType, mtTime, pmtNext, pData ) ) )
						{
							return S_OK;
						}
						else
						{
							hr = E_UNEXPECTED;
						}
					}
				}
				else
				{
					dwIndex--;
				}
			}
		}
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | SetParam | This method sets data on a
//		strip manager in the timeline
//
//  @parm   REFGUID | rguidType | Reference to the identifier of the type of data to set.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible data types.  Strips can also define
//		their own types for custom data.
//  @parm   DWORD | dwGroupBits | Which track group(s) to scan for the strip manager in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To scan all strip managers
//		regardless of groups, set this parameter to 0xFFFFFFFF. 
//  @parm   DWORD | dwIndex | Index of the strip manager in the group(s) identified by <p dwGroupBits> where data is to be set. 
//  @parm   MUSIC_TIME | mtTime | Time at which to set the data.
//  @parm   void* | pData | Address of structure containing the data. This structure must be of
//		the appropriate kind and size for the data type identified by rguidType.
//
//	@comm	This method is analagous to the DirectMusic method <om IDirectMusicPerformance::SetParam>.
//
//	@comm	Strip managers are searched in the order that they are listed in the Timeline.  See
//		<om IDMUSProdTimeline::AddStripMgr> for the order they are listed.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pData>
//	@rvalue E_INVALIDARG | No strip managers support the requested <p rguidType>.
//	@rvalue E_UNEXPECTED | An internal error occurred.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimeline::GetParam>, <om IDMUSProdStripMgr::SetParam>
HRESULT CPrivateTimelineCtl::SetParam(/* [in] */ REFGUID		guidType,
				/* [in] */ DWORD		dwGroupBits,
				/* [in] */ DWORD		dwIndex,
				/* [in] */ MUSIC_TIME	mtTime,
				/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Handle the timeline-specific Setparams
	if( m_pTimelineCtl )
	{
		if( SUCCEEDED( m_pTimelineCtl->SetParam( guidType, dwGroupBits, dwIndex, mtTime, pData ) ) )
		{
			return S_OK;
		}
	}

	StripMgrList*	pScan;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}
			if ( pScan->m_pStripMgr->IsParamSupported( guidType ) == S_OK )
			{
				if ( dwIndex == 0 )
				{
					if ( pData == NULL )
					{
						return E_POINTER;
					}
					else
					{
						return pScan->m_pStripMgr->SetParam( guidType, mtTime, pData );
					}
				}
				else
				{
					dwIndex--;
				}
			}
		}
	}
	return E_INVALIDARG;
}

//  @method HRESULT | IDMUSProdTimeline | GetStripMgr | This method retrieves a pointer to the specified
//		strip manager.
//
//  @parm   REFGUID | rguidType | Reference to the identifier of the type of data to search for.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible data types.  Strips can also define
//		their own types for custom data.
//  @parm   DWORD | dwGroupBits | Which track group(s) to scan for the strip manager in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To scan all tracks
//		regardless of groups, set this parameter to 0xFFFFFFFF. 
//  @parm   DWORD | dwIndex | Zero-based index into the list of tracks of type <p rguidType>
//		and in group <p dwGroupBits> to return. If multiple groups are selected in <p dwGroupBits>,
//		this index will indicate the nth track of type <p rguidType> encountered in the union of
//		the groups selected. 
//  @parm   <i IDMUSProdStripMgr>** | ppIStripMgr | Address of a variable to receive a pointer to
//		the strip manager.
//
//	@comm	This method is analagous to the DirectMusic method <om IDirectMusicPerformance::GetTrack>.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p ppIStripMgr>
//	@rvalue E_INVALIDARG | No matching strip manager was found
//	@rvalue E_UNEXPECTED | An internal error occurred.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdStripMgr::IsParamSupported>
HRESULT CPrivateTimelineCtl::GetStripMgr(/* [in] */ REFGUID				guidType,
					/* [in] */ DWORD				dwGroupBits,
					/* [in] */ DWORD				dwIndex,
					/* [out,retval] */ IDMUSProdStripMgr**	ppStripMgr)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	StripMgrList*	pScan;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}
			if ( pScan->m_pStripMgr->IsParamSupported( guidType ) == S_OK )
			{
				if ( dwIndex == 0 )
				{
					*ppStripMgr = pScan->m_pStripMgr;
					pScan->m_pStripMgr->AddRef();
					return S_OK;
				}
				else
				{
					dwIndex--;
				}
			}
		}
	}

	DMUS_IO_TRACK_HEADER ioTrackHeader;
	VARIANT varTrackHeader;
	for( pScan = m_pStripMgrList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_dwGroupBits & dwGroupBits )
		{
			ASSERT( pScan->m_pStripMgr != NULL );
			if ( pScan->m_pStripMgr == NULL )
			{
				return E_UNEXPECTED;
			}

			ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			if ( SUCCEEDED( pScan->m_pStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
			{
				if( ::IsEqualGUID( guidType, ioTrackHeader.guidClassID ) )
				{
					if ( dwIndex == 0 )
					{
						*ppStripMgr = pScan->m_pStripMgr;
						pScan->m_pStripMgr->AddRef();
						return S_OK;
					}
					else
					{
						dwIndex--;
					}
				}
			}
		}
	}

	return E_INVALIDARG;
}

//  @method HRESULT | IDMUSProdTimeline | InsertStripAtDefaultPos | This method inserts a strip into
//		timeline, ordering them by using <p rclsidType>, <p dwGroupBits> and <p dwIndex>.
//
//	@comm	Using the <p dwGroupBits> parameter and the <p rclsidType> parameter, the Timeline determines a
//		position for <p pIStrip> in its display list.<nl>
//		They are ordered first by the least track group number they belong to, then in the following order,
//		then by the value of <p dwIndex>, then by the order they were inserted:<nl>
//		Chord<nl>
//		Signpost<nl>
//		ChordMap Reference<nl>
//		Groove<nl>
//		Tempo<nl>
//		Style Reference<nl>
//		Sequence<nl>
//		Time Signature<nl>
//		Band<nl>
//		Mute<nl>
//		All other strips
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to add.
//  @parm	REFCLSID | rclsidType | The CLSID of the strip to add.
//  @parm   DWORD | dwGroupBits | Which track group(s) to add the strip in.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group.
//  @parm   DWORD | dwIndex | Where in the list of matching strips to add the strip..
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStrip>
//	@rvalue E_FAIL | <p pIStrip> was previously added.
//	@rvalue E_INVALIDARG | 0 was passed as <p dwGroupBits>.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::RemoveStrip>,
//		<om IDMUSProdTimeline::InsertStripAtPos>, <om IDMUSProdTimeline::AddStrip>
HRESULT CPrivateTimelineCtl::InsertStripAtDefaultPos(
		/* [in] */ IDMUSProdStrip* pStrip,
		/* [in] */ REFCLSID		clsidType,
		/* [in] */ DWORD		dwGroupBits,
		/* [in] */ DWORD		dwIndex)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	DWORD		dwPosition = 0;

	if( NULL == pStrip )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// if the strip is already in the list, return E_FAIL
	StripList*	pScan;
	for( pScan = m_pStripList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_pStrip == pStrip )
		{
			pStrip->Release();
			return E_FAIL;
		}
	}

	// determine the default position
	dwPosition = 1;
	if( m_pStripList )
	{
		if( m_pStripList->m_pNext != NULL )
		{
			// Remember to skip over the first strip.
			StripList*	pTemp = m_pStripList->m_pNext;
			int nMyId = StripCLSIDToInt( clsidType );
			BSTR bstrMyName = NULL;
			VARIANT var;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_NAME, &var ) ) && (var.vt == VT_BSTR) )
			{
				bstrMyName = V_BSTR(&var);
			}
			IUnknown *punkMyStripMgr = NULL;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &var ) ) && (var.vt == VT_UNKNOWN) )
			{
				punkMyStripMgr = V_UNKNOWN(&var);
			}

			IUnknown *punkLastStripMgr = NULL;
			IUnknown *punkTempStripMgr = NULL;
			while( pTemp )
			{
				BSTR bstrTempName = NULL;
				if( SUCCEEDED( pTemp->m_pStrip->GetStripProperty( SP_NAME, &var ) ) && (var.vt == VT_BSTR) )
				{
					bstrTempName = V_BSTR(&var);
				}
				if( SUCCEEDED( pTemp->m_pStrip->GetStripProperty( SP_STRIPMGR, &var ) ) && (var.vt == VT_UNKNOWN) )
				{
					punkTempStripMgr = V_UNKNOWN(&var);
				}
				// (If the last StripMgr and the temp StripMgr are different and the last StripMgr and my
				// StripMgr are the same)
				// OR
				// (If the last StripMgr and the temp StripMgr are different, or if the last, temp, and my
				// StripMgr are all the same, check if the strip being inserted should go BEFORE pTemp.)
				// If so, break.
				if( ((punkLastStripMgr != punkTempStripMgr) && (punkLastStripMgr == punkMyStripMgr))
				||	(((punkLastStripMgr != punkTempStripMgr) || (punkMyStripMgr == punkTempStripMgr))
					 && CompareStrips( StripCLSIDToInt(pTemp->m_clsidType), pTemp->m_dwGroupBits, pTemp->m_dwIndex, bstrTempName,
								   nMyId, dwGroupBits, dwIndex, bstrMyName ) == 2) )
				{
					if( bstrTempName )
					{
						::SysFreeString( bstrTempName );
					}
					if( punkLastStripMgr )
					{
						punkLastStripMgr->Release();
					}
					break;
				}
				if( bstrTempName )
				{
					::SysFreeString( bstrTempName );
				}
				if( punkLastStripMgr )
				{
					punkLastStripMgr->Release();
				}
				punkLastStripMgr = punkTempStripMgr;
				dwPosition++;
				pTemp = pTemp->m_pNext;
			}

			if( punkTempStripMgr )
			{
				punkTempStripMgr->Release();
			}
			if( punkMyStripMgr )
			{
				punkMyStripMgr->Release();
			}

			if( bstrMyName )
			{
				::SysFreeString( bstrMyName );
			}
		}
	}

	return InternalInsertStripAtPos( pStrip, dwPosition, clsidType, dwGroupBits, dwIndex );
}

int StripCLSIDToInt( REFCLSID clsidType )
{
	if( memcmp( &clsidType, &CLSID_DirectMusicTempoTrack, sizeof(GUID) ) == 0 )
	{
		return 0;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicTimeSigTrack, sizeof(GUID) ) == 0 )
	{
		return 10;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicChordMapTrack, sizeof(GUID) ) == 0 )
	{
		return 20;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicSignPostTrack, sizeof(GUID) ) == 0 )
	{
		return 30;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicChordTrack, sizeof(GUID) ) == 0 )
	{
		return 40;
	}
	else if( (memcmp( &clsidType, &CLSID_DirectMusicMotifTrack, sizeof(GUID) ) == 0)
		 ||	 (memcmp( &clsidType, &CLSID_DirectMusicSegmentTriggerTrack, sizeof(GUID) ) == 0) )
	{
		return 50;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicCommandTrack, sizeof(GUID) ) == 0 )
	{
		return 60;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicStyleTrack, sizeof(GUID) ) == 0 )
	{
		return 70;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicMelodyFormulationTrack, sizeof(GUID) ) == 0 )
	{
		return 80;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicPatternTrack, sizeof(GUID) ) == 0 )
	{
		return 90;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicSeqTrack, sizeof(GUID) ) == 0 )
	{
		return 100;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicWaveTrack, sizeof(GUID) ) == 0 )
	{
		return 110;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicBandTrack, sizeof(GUID) ) == 0 )
	{
		return 120;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicParamControlTrack, sizeof(GUID) ) == 0 )
	{
		return 130;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicMuteTrack, sizeof(GUID) ) == 0 )
	{
		return 140;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicScriptTrack, sizeof(GUID) ) == 0 )
	{
		return 150;
	}
	else if( memcmp( &clsidType, &CLSID_DirectMusicLyricsTrack, sizeof(GUID) ) == 0 )
	{
		return 160;
	}
	else
	{
		return 170;
	}
}

int CompareStrips( int nType1, DWORD dwGroups1, DWORD dwIndex1, BSTR bstrName1, int nType2, DWORD dwGroups2, DWORD dwIndex2, BSTR bstrName2 )
{
	// If the group bits are equal, check the types
	if( dwGroups1 == dwGroups2 )
	{
		if( nType1 == nType2 )
		{
			if( dwIndex1 == dwIndex2 )
			{
				if( bstrName1 && bstrName2 )
				{
					CString strName1 = bstrName1;
					CString strName2 = bstrName2;
					return strName1.CompareNoCase( strName2 ) < 0 ? 1 : 2;
				}
			}
			return long(dwIndex1) <= long(dwIndex2) ? 1 : 2;
		}
		return nType1 < nType2 ? 1 : 2;
	}

	// Continue while both group bits have at least one bit still set
	while( dwGroups1 && dwGroups2 )
	{
		if( (dwGroups1 & dwGroups2 & 1) == 0 )
		{
			// One of the first bits of dwGroups1 or dwGroups2 is zero
			if( dwGroups1 & 1 )
			{
				// The first bit of dwGroups1 is one and at least one bit in dwGroups2 is set -
				// #1 should go first
				return 1;
			}
			else if( dwGroups2 & 1 )
			{
				// The first bit of dwGroups2 is one and at least one bit in dwGroups1 is set -
				// #2 should go first
				return 2;
			}
			// else both of the first bits are zero - try the next bit
		}
		else
		{
			// Both of the first bits of dwGroups1 and dwGroups2 are one
			if( nType1 < nType2 )
			{
				return 1; // #1 should go first
			}
			else if ( nType1 > nType2 )
			{
				return 2; // #2 should go first
			}
			// else both are the same type - check the next bit
		}
		dwGroups1 = dwGroups1 >> 1;
		dwGroups2 = dwGroups2 >> 1;
	}

	if( dwGroups1 )
	{
		// Some of the bits in dwGroups1 are set - #2 should go first
		return 2;
	}
	else if( dwGroups2 )
	{
		// Some of the bits in dwGroups2 are set - #1 should go first
		return 1;
	}
	// dwGroups1 == dwGroups2 == 0 (Shouldn't happen!)
	ASSERT( FALSE );
	return 1;
}

HRESULT CPrivateTimelineCtl::InternalInsertStripAtPos( IDMUSProdStrip* pStrip, DWORD dwPosition, REFCLSID clsidType, DWORD dwGroupBits, DWORD dwIndex )
{
	HRESULT			hr = S_OK;
	StripList*		pSL;

	if( pStrip == NULL )
	{
		return E_POINTER;
	}

	if( dwPosition == 0 )
	{
		return E_INVALIDARG;
	}
	dwPosition--;

	// if the strip is already in the list, return E_FAIL
	StripList*	pScan;
	for( pScan = m_pStripList; pScan; pScan = pScan->m_pNext )
	{
		if( pScan->m_pStrip == pStrip )
		{
			pStrip->Release();
			return E_FAIL;
		}
	}
	// add the strip to the list of strips
	pSL = new StripList( pStrip, clsidType );
	if( pSL == NULL )
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pSL->m_dwGroupBits = dwGroupBits;
		pSL->m_dwIndex = dwIndex;

		// ask the Strip how tall it wants to be
		VARIANT var;
		if( SUCCEEDED( pStrip->GetStripProperty( SP_DEFAULTHEIGHT, &var )))
		{
			pSL->m_lHeight = V_INT(&var);
		}
		else if( SUCCEEDED( pStrip->GetStripProperty( SP_MAXHEIGHT, &var )))
		{
			pSL->m_lHeight = V_INT(&var);
		}
		else if( SUCCEEDED( pStrip->GetStripProperty( SP_MINHEIGHT, &var )))
		{
			pSL->m_lHeight = V_INT(&var);
		}

		// add the strip to the specified position
		if( m_pStripList )
		{
			StripList* pTemp = m_pStripList;
			while( pTemp->m_pNext && dwPosition > 0 )
			{
				pTemp = pTemp->m_pNext;
				dwPosition--;
			}
			pSL->m_pNext = pTemp->m_pNext;
			pTemp->m_pNext = pSL;

			// Send WM_CREATE to the strip that was added
			// Send WM_MOVE messages to all strips that were moved
			if( m_pTimelineCtl
			&&	::IsWindow(m_pTimelineCtl->m_hWnd) )
			{
				pStrip->OnWMMessage( WM_CREATE, 0, 0, 0, 0 );
				pTemp = pSL->m_pNext;
				while( pTemp )
				{
					pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
					pTemp = pTemp->m_pNext;
				}
			}
		}
		else
		{
			m_pStripList = pSL;

			// call the strip's callback that it has been added, but only if the
			// Timeline window exists
			if( m_pTimelineCtl
			&&	::IsWindow(m_pTimelineCtl->m_hWnd) )
			{
				pStrip->OnWMMessage( WM_CREATE, 0, 0, 0, 0 );
			}
		}

		if( m_pTimelineCtl )
		{
			// Compute what the scroll bars look like
			m_pTimelineCtl->ComputeScrollBars();

			// Refresh the display
			RECT rectWin, rect;
			m_pTimelineCtl->GetClientRect( &rectWin );
			m_pTimelineCtl->GetStripClientRect( pSL, &rect );
			rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
			m_pTimelineCtl->InvalidateRect( &rectWin, FALSE );
		}
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | EnumStrip | This method enumerates through all strips
//		displayed within the Timeline.
//
//  @parm   DWORD | dwEnum | Zero-based index into the Timeline's strip list. 
//  @parm   <i IDMUSProdStrip>** | ppIStrip | Address of a variable to receive a pointer to the strip.
//		The caller is responsible for Release()ing the pointer when it is done with it.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p ppIStrip>
//	@rvalue E_FAIL | There is no strip at the given index.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CPrivateTimelineCtl::EnumStrip(
		/* [in] */  DWORD			 dwEnum,
		/* [in] */  IDMUSProdStrip** ppStrip)
{
	if( ppStrip == NULL )
	{
		return E_POINTER;
	}
	StripList	*pSL;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( dwEnum == 0 )
		{
			*ppStrip = pSL->m_pStrip;
			if( pSL->m_pStrip )
			{
				pSL->m_pStrip->AddRef();
			}
			return S_OK;
		}
		dwEnum--;
	}
	*ppStrip = NULL;
	return E_FAIL;
}


//  @method HRESULT | IDMUSProdTimeline | InsertStripAtPos | This method inserts a strip at the
//		specified position.
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip to add to the Timeline.  The strip must not
//		have been previously added to the Timeline.
//  @parm   DWORD | dwPosition | The 0-based position to add the strip at.
//
//	@comm	No strip may be inserted before the Time Strip, the first strip in the Timeline.
//		Consequently, 0 is an invalid value for <p dwPosition>.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStrip>
//	@rvalue E_FAIL | The operation failed.
//	@rvalue E_OUTOFMEMORY | There was not enough available memory to complete the operation.
//	@rvalue E_INVALIDARG | dwPosition is 0.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::RemoveStrip>,
//		<om IDMUSProdTimeline::InsertStripAtDefaultPos>, <om IDMUSProdTimeline::AddStrip>
HRESULT CPrivateTimelineCtl::InsertStripAtPos(
		/* [in] */  IDMUSProdStrip*	pStrip,
		/* [in] */  DWORD		    dwPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pStrip != NULL );
	if( pStrip == NULL )
	{
		return E_POINTER;
	}

	DMUS_IO_TRACK_HEADER ioTrackHeader;
	ZeroMemory( &ioTrackHeader, sizeof(DMUS_IO_TRACK_HEADER) );

	VARIANT varStripMgr;
	if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
	&&	(varStripMgr.vt == VT_UNKNOWN) && (V_UNKNOWN(&varStripMgr) != NULL) )
	{
		IDMUSProdStripMgr* pIStripMgr;
		if( SUCCEEDED( V_UNKNOWN(&varStripMgr)->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
		{
			VARIANT varTrackHeader;
			varTrackHeader.vt = VT_BYREF;
			V_BYREF(&varTrackHeader) = &ioTrackHeader;
			if( FAILED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKHEADER, &varTrackHeader ) ) )
			{
				TRACE("Timeline: Unable to get StripMgr's TrackHeader\n");
			}

			pIStripMgr->Release();
		}
		V_UNKNOWN(&varStripMgr)->Release();
	}

	return InternalInsertStripAtPos( pStrip, dwPosition, ioTrackHeader.guidClassID, ioTrackHeader.dwGroup, ioTrackHeader.dwPosition );
}


//  @method HRESULT | IDMUSProdTimeline | StripToWindowPos | This method converts a point from strip
//		coordinates to Timeline Window coordinates
//
//  @parm   <i IDMUSProdStrip>* | pIStrip | The strip from whose coordinates to convert from.
//  @parm   POINT* | pPoint | Address of the point to convert.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pPoint> or <p pIStrip>
//	@rvalue E_INVALIDARG | <p pIStrip> was not previously added to the Timeline
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CPrivateTimelineCtl::StripToWindowPos(
		/* [in] */		IDMUSProdStrip*	pIStrip,
		/* [in,out] */	POINT*			pPoint)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if( NULL == pIStrip || NULL == pPoint )
	{
		return E_POINTER;
	}

	if (m_pStripList == NULL)
	{
		return E_INVALIDARG;
	}

	StripList* pTempSL;
	// subtract the heights of any strips above this one
	for( pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		if( pIStrip == pTempSL->m_pStrip )
		{
			return StripPointToClient( pTempSL, pPoint );
		}
	}
	return E_INVALIDARG;
}


//  @method HRESULT | IDMUSProdTimeline | AddToNotifyList | This method enables a StripMgr to receive
//		notifications of type <p rguidType> send to at least one group of <p dwGroupBits>
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to add.
//  @parm   REFGUID | rguidType | Reference to the identifier of the notification type to start
//		receiving notifications for.  See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible notifications.  Strips can also define
//		their own types for custom notifications.
//  @parm   DWORD | dwGroupBits | Which track group(s) to receive notifications for.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To receive all notifications
//		of the type specified by <p rguidType> regardless of groups, set this parameter to 0xFFFFFFFF. 
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStripMgr>
//	@rvalue E_OUTOFMEMORY | Not enough memory available
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdStripMgr::OnUpdate>, <om IDMUSProdTimeline::RemoveFromNotifyList>,
//		<om IDMUSProdTimeline::NotifyStripMgrs>
HRESULT CPrivateTimelineCtl::AddToNotifyList(
		/* [in] */	IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */	REFGUID				rguidType,
		/* [in] */	DWORD				dwGroupBits)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pIStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	NotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;
	NotifyListEntry* pNotifyListEntry = NULL;

	try
	{
		// Look through m_lstNotifyEntry for guidNotify
		POSITION pos;
		pos = m_lstNotifyEntry.GetHeadPosition();
		while ( pos != NULL && !fFound )
		{
			pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
			if ( InlineIsEqualGUID( pNotifyEntry->m_guid, rguidType ) )
			{
				// Found guidNotify, add pNotifyListEntry to the end of the list
				fFound = TRUE;

				pNotifyListEntry = new NotifyListEntry( pIStripMgr, dwGroupBits );
				pNotifyEntry->m_lstNotifyListEntry.AddTail( pNotifyListEntry );
			}
		}

		// Didn't find guidNotify, add a new NotifyEntry to the end of m_lstNotifyEntry
		if ( !fFound )
		{
			pNotifyEntry = new NotifyEntry( pIStripMgr, rguidType, dwGroupBits );
			m_lstNotifyEntry.AddTail( pNotifyEntry );
		}
	}
	catch( CMemoryException *pMemoryException )
	{
		if( pNotifyListEntry )
		{
			delete pNotifyListEntry;
		}
		if( pNotifyEntry )
		{
			delete pNotifyEntry;
		}
		pMemoryException->Delete();
		return E_OUTOFMEMORY;
	}
		
	return S_OK;
}


//  @method HRESULT | IDMUSProdTimeline | RemoveFromNotifyList | This method stops a StripMgr from
//		receiving notifications of type <p rguidType> for groups in <p dwGroupBits>
//
//  @parm   <i IDMUSProdStripMgr>* | pIStripMgr | The strip manager to remove.
//  @parm   REFGUID | rguidType |  Reference to the identifier of the notification type to stop
//		receiving notifications for.  See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible notifications.  Strips can also define
//		their own types for custom notifications.
//  @parm   DWORD | dwGroupBits | Which track group(s) to stop receiving notifications for.  A value of
//		0 is invalid. Each bit in <p dwGroupBits> corresponds to a track group. To stop receiving all notifications
//		of the type specified by <p rguidType> regardless of groups, set this parameter to 0xFFFFFFFF. 
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStripMgr>
//	@rvalue E_INVALIDARG | The specified <p pIStripMgr> can not be found
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdStripMgr::OnUpdate>, <om IDMUSProdTimeline::AddToNotifyList>,
//		<om IDMUSProdTimeline::NotifyStripMgrs>
HRESULT CPrivateTimelineCtl::RemoveFromNotifyList(
		/* [in] */	IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */	REFGUID				rguidType,
		/* [in] */	DWORD				dwGroupBits)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( pIStripMgr == NULL )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	NotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;

	// Look through m_lstNotifyEntry for guidNotify
	POSITION pos;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL && !fFound )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		if ( InlineIsEqualGUID( pNotifyEntry->m_guid, rguidType ) )
		{
			// Found guidNotify, now find pIStripMgr
			NotifyListEntry* pNotifyListEntry = NULL;
			POSITION pos2;
			pos2 = pNotifyEntry->m_lstNotifyListEntry.GetHeadPosition( );
			while ( pos2 != NULL && !fFound )
			{
				POSITION pos3 = pos2;
				pNotifyListEntry = pNotifyEntry->m_lstNotifyListEntry.GetNext( pos2 );
				if( pNotifyListEntry->pIStripMgr == pIStripMgr &&
					pNotifyListEntry->dwGroupBits == dwGroupBits )
				{
					// We've found it, now remove it from the list and delete our entry
					fFound = TRUE;
					pNotifyEntry->m_lstNotifyListEntry.RemoveAt( pos3 );
					delete pNotifyListEntry;

					// Check if the list is empty
					if ( pNotifyEntry->m_lstNotifyListEntry.IsEmpty() )
					{
						// If the list is empty, remove it from m_lstNotifyEntry
						pos2 = m_lstNotifyEntry.Find( pNotifyEntry );
						ASSERT( pos2 );
						if ( pos2 )
						{
							m_lstNotifyEntry.RemoveAt( pos2 );
							delete pNotifyEntry;
						}
					}
				}
			}
		}
	}

	// Didn't find guidNotify, add a new NotifyEntry to the end of m_lstNotifyEntry
	if ( !fFound )
	{
		return E_INVALIDARG;
	}
	return S_OK;
}


//  @method HRESULT | IDMUSProdTimeline | NotifyStripMgrs | This method broadcasts the specified
//		notification to all registered strip managers that belong to at least one of <p dwGroupBits>
//
//  @parm   REFGUID | rguidType |  Reference to the identifier of the notification type to send.
//		See <t SegmentGUIDs> and the list of track parameter types
//		in the DirectX documentation for a list of possible notifications.  Strips can also define
//		their own types for custom notifications.
///  @parm   DWORD | dwGroupBits | Which track group(s) to notify.  A value of 0 is invalid. Each bit in
//		<p dwGroupBits> corresponds to a track group.  To notify all strip managers that asked to hear
//		notifications of the type specified by <p rguidType> regardless of groups, set this parameter to 0xFFFFFFFF. 
//
//  @rvalue S_OK | The operation was successful
//	@rvalue E_FAIL | No matching strip managers were found, so no notifications were sent
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdStripMgr::OnUpdate>, <om IDMUSProdTimeline::AddToNotifyList>,
//		<om IDMUSProdTimeline::RemoveFromNotifyList>
HRESULT CPrivateTimelineCtl::NotifyStripMgrs(
		/* [in] */	REFGUID		rguidType,
		/* [in] */	DWORD		dwGroupBits,
		/* [in] */  void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Handle the timeline-specific notifications
	if( m_pTimelineCtl )
	{
		m_pTimelineCtl->NotifyStripMgrs( rguidType, dwGroupBits, pData );
	}

	// Find the NotifyEntry corresponding to rguidType
	NotifyEntry* pNotifyEntry = NULL;
	BOOL fFound = FALSE;
	POSITION pos;
	pos = m_lstNotifyEntry.GetHeadPosition();
	while ( pos != NULL && !fFound )
	{
		pNotifyEntry = m_lstNotifyEntry.GetNext( pos );
		if ( InlineIsEqualGUID( pNotifyEntry->m_guid, rguidType ) )
		{
			VARIANT var;

			BOOL fOrigFreezeUndo = FALSE;
			if( SUCCEEDED( GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fOrigFreezeUndo = V_BOOL(&var);
			}

			// Freeze undo queue
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			SetTimelineProperty( TP_FREEZE_UNDO, var );

			// Found the NotifyEntry corresponding to rguidType
			// Now, call OnUpdate for all matching StripMgrs
			HRESULT hr = E_FAIL;
			POSITION pos2;
			NotifyListEntry *pNotifyListEntry;
			pos2 = pNotifyEntry->m_lstNotifyListEntry.GetHeadPosition();
			while ( pos2 != NULL )
			{
				pNotifyListEntry = pNotifyEntry->m_lstNotifyListEntry.GetNext( pos2 );
				ASSERT( pNotifyListEntry );
				if ( pNotifyListEntry && (pNotifyListEntry->dwGroupBits & dwGroupBits) )
				{
					ASSERT( pNotifyListEntry->pIStripMgr );
					if( pNotifyListEntry->pIStripMgr )
					{
						fFound = TRUE;
						HRESULT hr2;
						hr2 = pNotifyListEntry->pIStripMgr->OnUpdate( rguidType, pNotifyListEntry->dwGroupBits & dwGroupBits, pData );
						if( (hr != S_OK) && (FAILED( hr ) || SUCCEEDED( hr2 )) )
						{
							hr = hr2;
						}
					}
				}
			}

			// Restore undo queue
			var.vt = VT_BOOL;
			V_BOOL(&var) = (short)fOrigFreezeUndo;
			SetTimelineProperty( TP_FREEZE_UNDO, var );

			return hr;
		}
	}
	return E_FAIL;
}


//  @method HRESULT | IDMUSProdTimeline | AllocTimelineDataObject | This method allocates an object that
//		implements the <i IDMUSProdTimelineDataObject> interface.
//
//  @parm	<i IDMUSProdTimelineDataObject> | ppITimelineDataObject | Address of a variable to receive a pointer
//		to the TimelineDataObject.
//
//	@comm	A Timeline DataObject simplifies dealing with the clipboard, and allows the Timeline to manage
//		multiple-strip copy and paste operations.
//
//  @rvalue S_OK | The operation was successful
//	@rvalue E_OUTOFMEMORY | Not enough memory available to allocate a TimelineDataObject
//	@rvalue E_POINTER | <p ppITimelineDataObject> is NULL
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdTimelineDataObject>
HRESULT CPrivateTimelineCtl::AllocTimelineDataObject(
		/* [out,retval] */ IDMUSProdTimelineDataObject**	ppITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate ppITimelineDataObject
	if( ppITimelineDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize variables
	HRESULT hr = S_OK;
	CTimelineDataObject *pTimelineDataObject = NULL;

	// Try and allocate a CTimelineDataObject object
	try
	{
		pTimelineDataObject = new CTimelineDataObject;
	}
	// Catch out of memory exception
	catch( CMemoryException *pMemException )
	{
		hr = E_OUTOFMEMORY;
		pMemException->Delete();
	}

	// If successful, QI for an IDMUSProdTimelineDataObject to store in ppITimelineDataObject
	if( SUCCEEDED(hr) && pTimelineDataObject )
	{
		hr = pTimelineDataObject->QueryInterface( IID_IDMUSProdTimelineDataObject, (void**)ppITimelineDataObject );
		pTimelineDataObject->Release();
	}
	
	return hr;
}


//  @method HRESULT | IDMUSProdTimeline | GetPasteType | This method returns the type of Paste operation
//		to perform.
//
//  @parm   <t TIMELINE_PASTE_TYPE>* | ptlptPasteType | Address of a variable to store the
//		<t TIMELINE_PASTE_TYPE> in.
//
//  @rvalue S_OK | The operation was successful
//	@rvalue E_POINTER | <p ptlptPasteType> is NULL
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::SetPasteType>
HRESULT CPrivateTimelineCtl::GetPasteType(
		/* [out,retval] */ TIMELINE_PASTE_TYPE*	ptlptPasteType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate ptlptPasteType
	if( ptlptPasteType == NULL )
	{
		return E_POINTER;
	}

	*ptlptPasteType = m_ptPasteType;

	return S_OK;
}


//  @method HRESULT | IDMUSProdTimeline | SetPasteType | This method sets the type of Paste operation
//		to perform.
//
//  @parm   <t TIMELINE_PASTE_TYPE> | tlptPasteType | The type of <t TIMELINE_PASTE_TYPE> to set
//
//  @rvalue S_OK | The operation was successful
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::GetPasteType>
HRESULT CPrivateTimelineCtl::SetPasteType(
		/* [in] */ TIMELINE_PASTE_TYPE tlptPasteType )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_ptPasteType = tlptPasteType;

	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | SetMarkerTime | This method sets the location of
//		one of the markers in the time strip.
//
//  @parm   <t MARKERID> | idMarkerType | Which marker to get the location of.  Must be
//		one of <t MARKERID>.  MARKER_LEFTDISPLAY and MARKER_RIGHTDISPLAY are not supported.
//  @parm   <t TIMETYPE> | ttType | Which units to use when computing <p plTime>.  Must be
//		one of <t TIMETYPE>.
//  @parm   long | lTime | The time the marker should be set to.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p ttType> or <p idMarkerType> do not contain valid values, or
//		lTime is less than zero.
//
//	@xref	<i IDMUSProdTimeline>, <t TIMETYPE>, <t MARKERID>, <om IDMUSProdTimeline::GetMarkerTime>
HRESULT CPrivateTimelineCtl::SetMarkerTime( 
    /* [in] */ MARKERID idMarkerType,
	/* [in] */ TIMETYPE	ttType,
    /* [in] */ long lTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimelineCtl )
	{
		return m_pTimelineCtl->SetMarkerTime( idMarkerType, ttType, lTime );
	}

	return E_FAIL;
}

//  @method HRESULT | IDMUSProdTimeline | GetMarkerTime | This method gets the location of
//		one of the markers in the time strip.
//
//  @parm   <t MARKERID> | idMarkerType | Which marker to get the location of.  Must be
//		one of <t MARKERID>
//  @parm   <t TIMETYPE> | ttType | Which units to use when computing <p plTime>.  Must be
//		one of <t TIMETYPE>.
//  @parm   long* | plTime | Address of a variable to receive the location of <p idMarkerType>.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p plTime> is NULL.
//	@rvalue E_INVALIDARG | <p ttType> or <p idMarkerType> do not contain valid values.
//
//	@xref	<i IDMUSProdTimeline>, <t TIMETYPE>, <t MARKERID>, <om IDMUSProdTimeline::SetMarkerTime>
HRESULT CPrivateTimelineCtl::GetMarkerTime( 
    /* [in] */ MARKERID idMarkerType,
	/* [in] */ TIMETYPE	ttType,
    /* [out] */ long *plTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimelineCtl )
	{
		return m_pTimelineCtl->GetMarkerTime( idMarkerType, ttType, plTime );
	}

	return E_FAIL;
}

//  @method HRESULT | IDMUSProdTimeline | ClocksToPosition | This method converts
//		from a time in clocks to a horizontal pixel position
//
//	@comm	Negative values for <p lTime> are valid.
//
//	@comm	Due to rounding errors, converting from a time to a pixel position and back
//		will usually return a value different from the original one.
//
//  @parm   long | lTime | The time in clocks
//  @parm   long* | plPosition | Address of a variable to receive the pixel position this
//		time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plPosition>
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::PositionToClocks>
HRESULT CPrivateTimelineCtl::ClocksToPosition( 
    /* [in] */ long   lTime,
    /* [out] */ long *plPosition)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == plPosition )
	{
		return E_POINTER;
	}
	if (m_fMusicTime == TRUE) 
	{
		*plPosition = (long)floor( double(lTime) * m_dblZoom + 0.5 );
		return S_OK;
	}
	else
	{
		REFERENCE_TIME rTime;
		HRESULT hr = ClocksToRefTime( lTime, &rTime);
		if (SUCCEEDED(hr))
		{
			return RefTimeToPosition( rTime, plPosition);
		}
		return hr;
	}
}

//  @method HRESULT | IDMUSProdTimeline | PositionToClocks | This method converts
//		from a horizontal pixel position to a time in clocks.
//
//	@comm	Negative values for <p lPosition> are valid.
//
//	@comm	Due to rounding errors, converting from a pixel position to a time and back
//		may return a value different from the original one.
//
//  @parm   long | lPosition | The horizontal position, in pixels.
//  @parm   long* | plTime | Address of a variable to receive the time in clocks this
//		position resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plTime>
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::ClocksToPosition>
HRESULT CPrivateTimelineCtl::PositionToClocks( 
    /* [in] */ long position,
    /* [out] */ long *plTime)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == plTime )
	{
		return E_POINTER;
	}
	if (m_fMusicTime == TRUE)
	{
		double dblPosition;
		double dblTime;
		dblPosition = position;
		dblTime = dblPosition / m_dblZoom;
		*plTime = (long)floor(dblTime + 0.5);
		return S_OK;
	}
	else
	{
		REFERENCE_TIME rTime;
		HRESULT hr = PositionToRefTime( position, &rTime);
		if (SUCCEEDED(hr))
		{
			return RefTimeToClocks( rTime, plTime);
		}
		return hr;
	}
}

static HRESULT GetVT_I4( VARIANT var, long* plVal )
{
	if( var.vt != VT_I4 )
		return E_FAIL;
	*plVal = V_I4(&var);
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | SetTimelineProperty | This method sets a property of
//		the Timeline.
//
//	@comm	The TP_SNAPAMOUNT property is not supported.
//
//  @parm   <t TIMELINE_PROPERTY> | tp | Which property to get.  Must be one of <t TIMELINE_PROPERTY>.
//  @parm   VARIANT | var | The data to set the property with.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p tp> does not contain a valid property type.
//	@rvalue E_FAIL | <p var> contained an invalid value for the specified property type.
//
//	@xref	<i IDMUSProdTimeline>, <t TIMELINE_PROPERTY>, <om IDMUSProdTimeline::GetTimelineProperty>
HRESULT CPrivateTimelineCtl::SetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [in] */ VARIANT				var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Handle the timeline-specific properties
	if( m_pTimelineCtl
	&&	SUCCEEDED( m_pTimelineCtl->SetTimelineProperty( tp, var ) ) )
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;
	long	lVal;

	switch(tp)
	{
	case TP_CLOCKLENGTH:
		if( SUCCEEDED( hr = GetVT_I4( var, &lVal )))
		{
			if( (lVal >= 0) && (m_lLength != lVal) )
			{
				m_lLength = lVal;
				if( m_pTimelineCtl )
				{
					m_pTimelineCtl->OptimizeZoomFactor();
					m_pTimelineCtl->ComputeScrollBars();
				}

				// send WM_SIZE to all strips, letting them know they have changed size
				StripList* pSL = m_pStripList;
				while (pSL)
				{
					// BUGBUG: Should have meaningful values for lParam.
					CallStripWMMessage( pSL, WM_SIZE, SIZE_RESTORED, MAKELONG(0, pSL->m_lHeight) );
					pSL = pSL->m_pNext;
				}

				hr = S_OK;
			}
		}
		break;

	case TP_ACTIVESTRIP:
		{
			hr = E_INVALIDARG;
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					IDMUSProdStrip* pIStrip;
					if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdStrip, (void**)&pIStrip ) ) )
					{
						StripList* pSL = FindStripList( pIStrip );
						if( pSL )
						{
							ActivateStripList( pSL );
							hr = S_OK;
						}
						pIStrip->Release();
					}
					punk->Release();
				}
				else
				{
					DeactivateStripList();
					hr = S_OK;
				}
			}
		}
		break;

	case TP_DMUSPRODFRAMEWORK:
		{
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				if( m_pDMUSProdFramework )
				{
					m_pDMUSProdFramework->Release();
					m_pDMUSProdFramework = NULL;
				}
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					if( SUCCEEDED( punk->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMUSProdFramework ) ) )
					{
						IDMUSProdComponent* pIComponent = NULL;
						if( SUCCEEDED ( m_pDMUSProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
						{
							IDMUSProdConductor *pIConductor;
							if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIConductor ) ) )
							{
								if( m_pIDMPerformance )
								{
									m_pIDMPerformance->Release();
									m_pIDMPerformance = NULL;
								}
								IUnknown* punkPerformance;
								if( SUCCEEDED( pIConductor->GetPerformanceEngine( &punkPerformance ) ) )
								{
									punkPerformance->QueryInterface( IID_IDirectMusicPerformance, (void **)&m_pIDMPerformance ) ;
									punkPerformance->Release();
								}
								pIConductor->Release();
							}
							pIComponent->Release();
						}
					}
				}
				hr = S_OK;
			}
		}
		break;

	case TP_TIMELINECALLBACK:
		{
			IUnknown* punk;
			if( var.vt == VT_UNKNOWN )
			{
				if( m_pTimelineCallback )
				{
					m_pTimelineCallback->Release();
					m_pTimelineCallback = NULL;
				}
				punk = V_UNKNOWN(&var);
				if( punk )
				{
					punk->QueryInterface( IID_IDMUSProdTimelineCallback, (void**)&m_pTimelineCallback );
				}
				hr = S_OK;
			}
		}
		break;

	case TP_ZOOM:
		if( var.vt == VT_R8 )
		{
			if ( V_R8(&var) > 0 )
			{
				m_dblZoom = V_R8(&var);
				hr = S_OK;
			}
		}
		break;

	case TP_FREEZE_UNDO:
		if( var.vt == VT_BOOL )
		{
			m_fFreezeUndo = V_BOOL(&var);
			hr = S_OK;
		}
		break;

	case TP_SNAP_TO:
		if( var.vt == VT_I4 )
		{
			m_pTimeStrip->SetSnapTo( (DMUSPROD_TIMELINE_SNAP_TO) V_I4(&var) );
			hr = S_OK;
		}
		break;

	case TP_HORIZONTAL_SCROLL:
		if( var.vt == VT_I4 )
		{
			hr = S_OK;
			if( m_lXScrollPos != V_I4(&var) )
			{
				if( m_pTimelineCtl )
				{
					m_pTimelineCtl->ScrollToPosition( V_I4(&var) );
				}
				else
				{
					m_lXScrollPos = V_I4(&var);
				}
			}
		}
		break;

	case TP_VERTICAL_SCROLL:
		if( var.vt == VT_I4 )
		{
			hr = S_OK;
			if( m_lYScrollPos != V_I4(&var) )
			{
				if( m_pTimelineCtl )
				{
					// Get the height of all strips
					long lMaxStripScroll = TotalStripHeight();

					RECT rect;
					m_pTimelineCtl->GetClientRect( &rect );

					RECT rectTmp;
					m_pTimelineCtl->m_ScrollHorizontal.GetClientRect( &rectTmp );
					rect.bottom -= rectTmp.bottom;

					if( m_pStripList )
					{
						// don't scroll top strip (usually the time strip)
						rect.top += m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH*2;

						// subtract off the top strip
						lMaxStripScroll -= m_pStripList->m_lHeight + BORDER_HORIZ_WIDTH;
					}

					// subtract the height of the viewing region
					lMaxStripScroll -= rect.bottom - rect.top;

					int nPos;
					if (lMaxStripScroll < 1)
					{
						nPos = 0;
					}
					else
					{
						nPos = (V_I4(&var) * m_pTimelineCtl->m_ScrollVertical.GetScrollLimit()) / lMaxStripScroll;
					}

					int iTemp = 0;
					m_pTimelineCtl->OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, nPos ), (LPARAM) ((HWND) m_pTimelineCtl->m_ScrollVertical), iTemp );
				}
				else
				{
					m_lYScrollPos = V_I4(&var);
				}
			}
		}
		break;

	case TP_FUNCTIONBAR_WIDTH:
		if( var.vt == VT_I4 )
		{
			if(( V_I4(&var) >= MIN_FNBAR_WIDTH ) && ( V_I4(&var) <= MAX_FNBAR_WIDTH))
			{
				m_lFunctionBarWidth = V_I4(&var);
				hr = S_OK;

				// Probably should calculate the area that will be affected
				// and only invalidate it.
				// Perhaps we could just 'scroll' the affected area to the
				// right and invalidate the small new area to be displayed

				// send WM_SIZE to all strips, letting them know something has changed size
				StripList* pSL = m_pStripList;
				while (pSL)
				{
					// BUGBUG: Should have meaningful values for lParam.
					CallStripWMMessage( pSL, WM_SIZE, SIZE_RESTORED, MAKELONG(0, pSL->m_lHeight) );
					pSL = pSL->m_pNext;
				}

				if( m_pTimelineCtl )
				{
					m_pTimelineCtl->ComputeScrollBars();
					RECT rect;
					m_pTimelineCtl->GetClientRect( &rect );
					m_pTimelineCtl->InvalidateRect( &rect, FALSE );
				}
			}
		}
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | GetTimelineProperty | This method gets a property of
//		the Timeline.
//
//  @parm   <t TIMELINE_PROPERTY> | tp | Which property to get.  Must be one of <t TIMELINE_PROPERTY>.
//  @parm   VARIANT* | pVar | Address of the variant to return the property's data in.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p pVar> is NULL.
//	@rvalue E_INVALIDARG | <p tp> does not contain a valid property type.
//
//	@xref	<i DMUSProdTimeline>, <t TIMELINE_PROPERTY>, <om IDMUSProdTimeline::SetTimelineProperty>
HRESULT CPrivateTimelineCtl::GetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [out] */ VARIANT*			pVar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pVar == NULL )
	{
		return E_POINTER;
	}

	// Handle the timeline-specific properties
	if( m_pTimelineCtl
	&&	SUCCEEDED( m_pTimelineCtl->GetTimelineProperty( tp, pVar ) ) )
	{
		return S_OK;
	}

	HRESULT hr = S_OK;

	switch(tp)
	{
	case TP_CLOCKLENGTH:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lLength;
		break;

	case TP_TIMELINECALLBACK:
		pVar->vt = VT_UNKNOWN;
		V_UNKNOWN(pVar) = m_pTimelineCallback;
		if( m_pTimelineCallback )
		{
			m_pTimelineCallback->AddRef();
		}
		else
		{
			return E_FAIL;
		}
		break;

	case TP_DMUSPRODFRAMEWORK:
		pVar->vt = VT_UNKNOWN;
		V_UNKNOWN(pVar) = m_pDMUSProdFramework;
		if( m_pDMUSProdFramework )
		{
			m_pDMUSProdFramework->AddRef();
		}
		else
		{
			return E_FAIL;
		}
		break;

	case TP_ACTIVESTRIP:
		pVar->vt = VT_UNKNOWN;
		if( m_pActiveStripList && m_pActiveStripList->m_pStrip )
		{
			V_UNKNOWN(pVar) = m_pActiveStripList->m_pStrip;
			m_pActiveStripList->m_pStrip->AddRef();
		}
		else
		{
			V_UNKNOWN(pVar) = NULL;
			return E_FAIL;
		}
		break;
	
	case TP_FUNCTIONBAR_WIDTH:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lFunctionBarWidth;
		break;

	case TP_HORIZONTAL_SCROLL:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lXScrollPos;
		break;

	case TP_VERTICAL_SCROLL:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_lYScrollPos;
		break;

	case TP_ZOOM:
		pVar->vt = VT_R8;
		V_R8(pVar) = m_dblZoom;
		break;

	case TP_SNAPAMOUNT:
		if( m_pTimeStrip )
		{
			V_I4(pVar) = m_pTimeStrip->SnapAmount( V_I4(pVar) );
			pVar->vt = VT_I4;
		}
		else
		{
			return E_FAIL;
		}
		break;

	case TP_FREEZE_UNDO:
		pVar->vt = VT_BOOL;
		V_BOOL(pVar) = (short)m_fFreezeUndo;
		break;

	case TP_SNAP_TO:
		pVar->vt = VT_I4;
		V_I4(pVar) = m_pTimeStrip->m_stSetting;
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | Refresh | This method causes a redraw of the
//		entire Timeline.
//
//	@comm	This method should be used sparingly.  If at all possible,
//		<om IDMUSProdTimeline::StripInvalidateRect> and <om IDMUSProdTimeline::NotifyStripMgrs>
//		should be used instead.
//
//  @rvalue S_OK | The operation was successful
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::StripInvalidateRect>, <om IDMUSProdTimeline::NotifyStripMgrs>
HRESULT CPrivateTimelineCtl::Refresh(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimelineCtl == NULL
	||	!::IsWindow(m_pTimelineCtl->m_hWnd) )
	{
		// Our window has been destroyed - fail.
		return E_FAIL;
	}

	return m_pTimelineCtl->Refresh();
}

//  @method HRESULT | IDMUSProdTimeline | ClocksToMeasureBeat | This method converts
//		from a time in clocks to a time in measures and beats
//
//	@comm	If <p lTime> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plMeasure> and <p plBeat>.  <p plMeasure> will
//			contain the negative measure number, and <p plBeat> will contain
//			the beat in the measure that <p lTime> falls in.
//
//	@comm	Either <p plMeasure> or <p lBeat> may be NULL, but not both.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   long | lTime | The time in clocks
//  @parm   long* | plMeasure | Address of a variable to recieve the measure number, with
//		measure 0 as the first measure.
//  @parm   long* | plBeat | Address of a variable to receive the beat number, with beat
//		0 as the first beat in each measure.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p plMeasure> and <p plBeat>
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::MeasureBeatToClocks>
HRESULT CPrivateTimelineCtl::ClocksToMeasureBeat( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long	  lTime,
    /* [out] */ long *plMeasure,
    /* [out] */ long *plBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( (NULL == plMeasure) && (NULL == plBeat) )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext;
	long lBeat = 0, lMeasure = 0;

	do
	{
		// Try and get the current time signature
		if ( FAILED( GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig ) ) )
		{
			return E_UNEXPECTED;
		}

		// If lTime is less than 0, only use the first TimeSig
		if( lTime < 0 )
		{
			lMeasure += lTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));
			lTime = -(abs(lTime) % (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ )));
			break;
		}
		// If there is no next time signature, do the math to find how many more measures to add
		else if( mtTSNext == 0 )
		{
			lMeasure += lTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));
			lTime %= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// If the next time signature is after the time we're looking for
			if( lTime < mtTSNext )
			{
				// Add the number of complete measures between here and there
				lMeasure += lTime / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));

				// lTime now stores an offset from the beginning of the measure
				lTime %= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ));

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

				// Subtract from the time left (lTime) and add to the current time (mtTSCur)
				lTime -= lMeasureDiff;
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the time left is greater than 0
	while ( lTime > 0 );

	if ( lTime < 0 )
	{
		lTime += TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		lMeasure--;
	}

	if ( lTime != 0 && plBeat != NULL )
	{
		lBeat = lTime / NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
	}
	else
	{
		lBeat = 0;
	}

	if( plMeasure != NULL )
	{
		*plMeasure = lMeasure;
	}
	if( plBeat != NULL )
	{
		*plBeat = lBeat;
	}

	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | PositionToMeasureBeat | This method converts
//		from a horizontal pixel position to a measure and beat value.
//
//	@comm	If <p lPosition> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plMeasure> and <p plBeat>.  <p plMeasure> will
//			contain the negative measure number, and <p plBeat> will contain
//			the beat in the measure that <p lTime> falls in.
//
//	@comm	Either <p plMeasure> or <p lBeat> may be NULL, but not both.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   long | lPosition | The horizontal pixel position.
//  @parm   long* | plMeasure | Address of a variable to receive the measure number, with
//		measure 0 as the first measure.
//  @parm   long* | plBeat | Address of a variable to receive the beat number, with beat
//		0 as the first beat in each measure.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plMeasure> and <p plBeat>
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::MeasureBeatToPosition>
HRESULT CPrivateTimelineCtl::PositionToMeasureBeat( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long   position,
    /* [out] */ long *plMeasure,
    /* [out] */ long *plBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long lTime;
	HRESULT hr;

	// Since this uses PositionToClocks, we don't care if we're in music time
	// or real time.  PositionToClocks will deal with it appropriately.
	if( SUCCEEDED( hr = PositionToClocks( position, &lTime ) ))
	{
		hr = ClocksToMeasureBeat( dwGroupBits, dwIndex, lTime, plMeasure, plBeat );
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | MeasureBeatToClocks | This method converts
//		from a measure and beat to a time in clocks.
//
//	@comm	If <p lMeasure> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plTime>.  If <p lBeat> is less than 0, the
//			Time Signature in measure <p lMeasure> will be used to compute the offset
//			from the start of measure <p lMeasure>.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm	long | lMeasure | The measure number, with measure 0 as the first measure.
//  @parm	long | lBeat | The beat number, with beat 0 as the first beat in each measure.
//  @parm	long* | plTime | Address of a variable to receive the converted time in clocks.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | NULL was passed as <p plTime>.
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::ClocksToMeasureBeat>
HRESULT CPrivateTimelineCtl::MeasureBeatToClocks( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long lMeasure,
    /* [in] */ long lBeat,
    /* [out] */ long *plTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == plTime )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	HRESULT hr;
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;
	do
	{
		hr = GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig );
		if ( FAILED( hr ) )
		{
			return E_UNEXPECTED;
		}

		long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );
		if( mtTSNext == 0 )
		{
			mtTSCur += lMeasureClocks * lMeasure;
			break;
		}
		else
		{
			long lTmpMeasures = mtTSNext / lMeasureClocks;
			if( lMeasure <= lTmpMeasures )
			{
				mtTSCur += lMeasureClocks * lMeasure;
				break;
			}
			else
			{
				mtTSCur += lMeasureClocks * lTmpMeasures;
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	if( lBeat >= 0 )
	{
		hr = GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, max(mtTSCur, 0), NULL, &TimeSig );
	}
	else
	{
		hr = GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, max(mtTSCur - TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ), 0), NULL, &TimeSig );
	}
	if ( FAILED( hr ) )
	{
		return E_UNEXPECTED;
	}

	mtTSCur += NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ ) * lBeat;
	*plTime = mtTSCur;
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | MeasureBeatToPosition | This method converts
//		from a measure and beat to a pixel position.
//
//	@comm	If <p lMeasure> is less than 0, the Time Signature at time 0 will
//			be used to compute <p plPosition>.  If <p lBeat> is less than 0, the
//			Time Signature in measure <p lMeasure> will be used to compute the offset
//			from the start of measure <p lMeasure>.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm	long | lMeasure | The measure number, with measure 0 as the first measure.
//  @parm	long | lBeat | The beat number, with beat 0 as the first beat in each measure.
//  @parm	long* | plPosition | Address of a variable to receive the pixel position.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | NULL was passed as <p plPosition>.
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::PositionToMeasureBeat>
HRESULT CPrivateTimelineCtl::MeasureBeatToPosition( 
	/* [in] */ DWORD  dwGroupBits,
	/* [in] */ DWORD  dwIndex,
    /* [in] */ long   lMeasure,
    /* [in] */ long   lBeat,
    /* [out] */ long *pPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	long lTime;
	HRESULT hr;
	// Since this uses ClocksToPosition, we don't care if we're in music time
	// or real time.  ClocksToPosition will deal with it appropriately.
	if( SUCCEEDED( hr = MeasureBeatToClocks( dwGroupBits, dwIndex, lMeasure, lBeat, &lTime ) ))
	{
		hr = ClocksToPosition( lTime, pPosition );
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | StripInvalidateRect | This method invalidates the
//		specified rectangle in a strip, causing the area to be redrawn.
//
//	@parm	<i IDMUSProdStrip>* | pStrip | Which strip to invalidate the rectangle in.
//  @parm   RECT* | pRect | The rectangle to invalidate.  If NULL, invalidate the entire strip.
//  @parm   BOOL | fErase | If TRUE, erase the background of the rectangle first.
//
//	@comm	The parameter <p fErase> is ignore, as the background of the strip is always filled
//		before <om IDMUSProdStrip::Draw> is called.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p pStrip> was not added to the timeline by calling one of
//		<om IDMUSProdTimeline::AddStrip>, <om IDMUSProdTimeline::InsertStripAtDefaultPos>, or
//		<om IDMUSProdTimeline::InsertStripAtPos>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::Refresh>, <i IDMUSProdStrip>
HRESULT CPrivateTimelineCtl::StripInvalidateRect(
	/* [in] */ IDMUSProdStrip*	pStrip,
	/* [in] */ RECT*			pRect,
	/* [in] */ BOOL				fErase)
{
	UNREFERENCED_PARAMETER( fErase );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pTimelineCtl == NULL
	||	!::IsWindow(m_pTimelineCtl->m_hWnd) )
	{
		// Our window has been destroyed - fail.
		return E_FAIL;
	}

	return m_pTimelineCtl->StripInvalidateRect( pStrip, pRect, fErase );
}

//  @method HRESULT | IDMUSProdTimeline | RemovePropertyPageObject | This method removes
//		a property page object previously set by <om IDMUSProdTimeline::SetPropertyPage>
//
//	@comm <t TP_DMUSPRODFRAMEWORK> must be set to the DirectMusic Producer framework
//		object (via a call to <om IDMUSProdTimeline::SetTimelineProperty> prior to calling
//		this method.
//
//  @parm   IUnknown* | punkPropPageObj | Reference to the <i IDMUSProdPropPageObject>
//		to remove from the current property sheet.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p punkPropPageObj>
//	@rvalue E_FAIL | <t TP_DMUSPRODFRAMEWORK> was not set previous to calling this method.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdPropPageObject>,	<om IDMUSProdTimeline::SetPropertyPage>
HRESULT CPrivateTimelineCtl::RemovePropertyPageObject(	/* [in] */ IUnknown* punkPropPageObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( punkPropPageObj == NULL )
	{
		return E_POINTER;
	}

	if ( m_pDMUSProdFramework == NULL )
	{
		return E_FAIL;
	}

	IDMUSProdPropPageObject* pPPO;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED(hr = punkPropPageObj->QueryInterface( IID_IDMUSProdPropPageObject,
		(void**)&pPPO )))
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pDMUSProdFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			pJPS->RemovePageManagerByObject( pPPO );
			pJPS->Release();
		}
		pPPO->Release();
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | SetPropertyPage | This method changes the
//		currently displayed <i IDMUSProdPropSheet> to refer to <p punkPropPageMgr>
//		and <p punkPropPageObj>.
//
//	@comm <t TP_DMUSPRODFRAMEWORK> must be set to the DirectMusic Producer framework
//		object (via a call to <om IDMUSProdTimeline::SetTimelineProperty> prior to calling
//		this method.
//
//  @parm   IUnknown* | punkPropPageMgr | Reference to the <i IDMUSProdPropPageManager>
//		to set for the currently displayed property sheet.
//  @parm   IUnknown* | punkPropPageObj | Reference to the <i IDMUSProdPropPageObject>
//		to set for the currently displayed property sheet.
//
//	@rdesc	If the property sheet is hidden, this method returns S_FALSE and does not
//		set either <p punkPropPageMgr> or <p punkPropPageObj>.
//
//  @rvalue S_OK | The operation was successful
//	@rvalue S_FALSE | The current property sheet is hidden.
//  @rvalue E_POINTER | NULL was passed as  <p punkPropPageObj> or <p punkPropPageMgr>
//	@rvalue E_FAIL | <t TP_DMUSPRODFRAMEWORK> was not set previous to calling this method.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdPropPageManager>, <i IDMUSProdPropPageObject>,
//		<i IDMUSProdPropSheet>, <om IDMUSProdTimeline::RemovePropertyPageObject>
HRESULT CPrivateTimelineCtl::SetPropertyPage(
		/* [in] */ IUnknown* punkPropPageMgr,
		/* [in] */ IUnknown* punkPropPageObj)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !punkPropPageMgr || !punkPropPageObj )
	{
		return E_POINTER;
	}

	IDMUSProdPropPageManager* pPPM;
	IDMUSProdPropPageObject* pPPO;
	HRESULT hr = E_FAIL;

	if( m_pDMUSProdFramework )
	{
		IDMUSProdPropSheet* pJPS;
		if( SUCCEEDED(hr = m_pDMUSProdFramework->QueryInterface( IID_IDMUSProdPropSheet,
			(void**)&pJPS )))
		{
			//  If the property sheet is hidden, exit
			if( pJPS->IsShowing() != S_OK )
			{
				pJPS->Release();
				return S_FALSE;
			}
			if( SUCCEEDED(hr = punkPropPageMgr->QueryInterface( IID_IDMUSProdPropPageManager, 
				(void**)&pPPM )))
			{
				if( SUCCEEDED(hr = punkPropPageObj->QueryInterface( IID_IDMUSProdPropPageObject,
					(void**)&pPPO )))
				{
					HWND hwnd = ::GetFocus();	// save window to setfocus to afterwards if necessary
					if( SUCCEEDED(pJPS->SetPageManager( pPPM )))
					{
						pPPM->SetObject(pPPO);
// don't open property page automatically	pJPS->Show(TRUE);
					}
					HWND hwnd2 = ::GetFocus();
					if(hwnd != hwnd2)
					{
						::SetFocus(hwnd);
					}
					pPPO->Release();
				}
				pPPM->Release();
			}
			pJPS->Release();
		}
	}
	return hr;
}

StripList* CPrivateTimelineCtl::FindStripList(IDMUSProdStrip* pStrip) const
{
	StripList* pSL;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		if( pSL->m_pStrip == pStrip )
		{
			return pSL;
		}
	}
	return NULL;
}

//  @method HRESULT | IDMUSProdTimeline | StripSetTimelineProperty | This method sets a strip property
//		that is controlled by the Timeline.
//
//	@parm	<i IDMUSProdStrip>* | pIStrip | Which strip to set the property for.
//  @parm   <t STRIP_TIMELINE_PROPERTY> | stp | Which property to set.  Must be one of <t STRIP_TIMELINE_PROPERTY>.
//  @parm   VARIANT | variant | The data to set the property with.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p pIStrip> is NULL.
//	@rvalue E_INVALIDARG | <p stp> does not contain a valid property type, <p variant>
//		contains invalid data for the specified property type, or <p pIStrip> was not previously
//		added to the Timeline.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <t STRIP_TIMELINE_PROPERTY>,
//		<om IDMUSProdTimeline::StripGetTimelineProperty>
HRESULT CPrivateTimelineCtl::StripSetTimelineProperty( 
    /* [in] */ IDMUSProdStrip* pIStrip,
    /* [in] */ STRIP_TIMELINE_PROPERTY stp,
    /* [in] */ VARIANT variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_INVALIDARG;

	if( NULL == pIStrip )
	{
		return E_POINTER;
	}

	StripList* pSL = FindStripList(pIStrip);
	if( NULL == pSL )
	{
		return E_INVALIDARG;
	}

	switch( stp )
	{
	case STP_VERTICAL_SCROLL:
		{
				long lScrollAmount = pSL->m_lVScroll - V_I4(&variant);
				RECT rect;

				m_pTimelineCtl->GetStripClientRect(pSL, &rect);
				if (( lScrollAmount >= rect.bottom - rect.top ) || ( -lScrollAmount >= rect.bottom - rect.top ))
				{
					pSL->m_lVScroll = V_I4(&variant);
					StripInvalidateRect( pIStrip, NULL, TRUE );
				}
				else
				{
					// Scroll strip
					pSL->m_lVScroll = V_I4(&variant);

					if( m_pTimelineCtl )
					{
						m_pTimelineCtl->ScrollWindow( 0, lScrollAmount, &rect, &rect );
						if (lScrollAmount < 0) // scroll up
						{
							// bottom is invalidated automatically by ScrollWindow()
							RECT oldRect = rect;

							// invalidate region displaying the track's title
							rect.bottom = rect.top + FUNCTION_NAME_HEIGHT;
							rect.right = rect.left + m_lFunctionBarWidth;
							// Don't need to erase, since the title will overwrite it anyways
							m_pTimelineCtl->InvalidateRect( &rect, FALSE);

							// invalidate region displaying the track's minize icon
							VARIANT var;
							if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
							{
								if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
								{
									if ((pSL->m_sv == SV_NORMAL) || (pSL->m_sv == SV_MINIMIZED))
									{
										rect.bottom += m_pTimelineCtl->m_sizeMinMaxButton.cy - FUNCTION_NAME_HEIGHT;
										rect.right = oldRect.right;
										long posLength;
										ClocksToPosition( m_lLength, &posLength );
										posLength++;
										if( posLength < rect.right - m_lFunctionBarWidth)
										{
											rect.right = posLength + m_lFunctionBarWidth;
										}
										rect.left = rect.right - m_pTimelineCtl->m_sizeMinMaxButton.cx;
										// Don't need to erase, since the button will overwrite it anyways
										m_pTimelineCtl->InvalidateRect( &rect, FALSE);
									}
								}
							}
						}
						else // scroll down
						{
							RECT oldRect = rect;
							// top is invalidated automatically by ScrollWindow()

							// invalidate region displaying the track's title
							rect.top += lScrollAmount;
							rect.bottom = rect.top + FUNCTION_NAME_HEIGHT;
							rect.right = rect.left + m_lFunctionBarWidth;
							m_pTimelineCtl->InvalidateRect( &rect, FALSE);

							// invalidate region displaying the track's minize icon
							VARIANT var;
							if( SUCCEEDED( pSL->m_pStrip->GetStripProperty( SP_MINMAXABLE, &var )))
							{
								if( ( var.vt == VT_BOOL ) && ( V_BOOL(&var) == TRUE ))
								{
									if ((pSL->m_sv == SV_NORMAL) || (pSL->m_sv == SV_MINIMIZED))
									{
										rect.bottom += m_pTimelineCtl->m_sizeMinMaxButton.cy - FUNCTION_NAME_HEIGHT;
										rect.right = oldRect.right;
										long posLength;
										ClocksToPosition( m_lLength, &posLength );
										posLength++;
										if( posLength < rect.right - m_lFunctionBarWidth)
										{
											rect.right = posLength + m_lFunctionBarWidth;
										}
										rect.left = rect.right - m_pTimelineCtl->m_sizeMinMaxButton.cx;
										m_pTimelineCtl->InvalidateRect( &rect, FALSE);
									}
								}
							}
						}
					}
				}
		}
		break;

	case STP_HEIGHT:
		if (variant.vt != VT_I4)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			hr = S_OK;
			if ( pSL->m_sv == SV_NORMAL )
			{
				if( pSL->m_lHeight != V_I4(&variant) )
				{
					pSL->m_lHeight = V_I4(&variant);

					// Send WM_MOVE messages to all strips (below this one) that were moved
					if( m_pTimelineCtl
					&&	::IsWindow(m_pTimelineCtl->m_hWnd) )
					{
						StripList* pTemp = pSL->m_pNext;
						while( pTemp )
						{
							pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
							pTemp = pTemp->m_pNext;
						}
					}

					if( m_pTimelineCtl )
					{
						RECT rectWin, rect;
						m_pTimelineCtl->GetClientRect( &rectWin );
						m_pTimelineCtl->GetStripClientRect( pSL, &rect );
						rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
						m_pTimelineCtl->InvalidateRect( &rectWin, FALSE );
						m_pTimelineCtl->ComputeScrollBars();
						// If, as a result of the strip resize, the total height of the strips is less than the
						// height of the window, scroll back to the top.
						if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
						{
							int iTemp = 0;
							m_pTimelineCtl->OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_pTimelineCtl->m_ScrollVertical), iTemp );
						}
					}
				}
			}
			else if ( pSL->m_sv == SV_MINIMIZED )
			{
				pSL->m_lRestoreHeight = V_I4(&variant);
			}
			else
			{
				hr = E_UNEXPECTED;
			}
		}
		break;

	case STP_STRIPVIEW:
		if (variant.vt != VT_I4)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			if( (V_I4(&variant) <= (int) SV_FUNCTIONBAR_MINIMIZED))
			{
				if ( pSL->m_sv != (STRIPVIEW) V_I4(&variant) )
				{
					if ( (STRIPVIEW) V_I4(&variant) == SV_MINIMIZED)
					{
						pSL->m_lRestoreHeight = pSL->m_lHeight;
						pSL->m_sv = SV_MINIMIZED;
						VARIANT var;
						if (SUCCEEDED (pIStrip->GetStripProperty( SP_MINIMIZE_HEIGHT, &var)))
						{
							pSL->m_lHeight = V_INT(&var);
						}
						else
						{
							pSL->m_lHeight = MIN_STRIP_HEIGHT;
						}
					}
					else if ( (STRIPVIEW) V_I4(&variant) == SV_NORMAL)
					{
						pSL->m_lHeight = pSL->m_lRestoreHeight;
						pSL->m_sv = SV_NORMAL;
					}

					// Send WM_MOVE messages to all strips (below this one) that were moved
					if( m_pTimelineCtl
					&&	::IsWindow(m_pTimelineCtl->m_hWnd) )
					{
						StripList* pTemp = pSL->m_pNext;
						while( pTemp )
						{
							pTemp->m_pStrip->OnWMMessage( WM_MOVE, 0, 0, 0, 0 );
							pTemp = pTemp->m_pNext;
						}
					}
	
					if( m_pTimelineCtl )
					{
						RECT rectWin, rect;
						m_pTimelineCtl->GetClientRect( &rectWin );
						m_pTimelineCtl->GetStripClientRect( pSL, &rect );
						rectWin.top = rect.top - BORDER_HORIZ_WIDTH;
						m_pTimelineCtl->InvalidateRect( &rectWin, FALSE );
						m_pTimelineCtl->ComputeScrollBars();
						// If, as a result of the strip resize, the total height of the strips is less than the
						// height of the window, scroll back to the top.
						if ( (TotalStripHeight() < rectWin.bottom - rectWin.top) && (m_lYScrollPos != 0) )
						{
							int iTemp = 0;
							m_pTimelineCtl->OnVScroll( 0, MAKELONG( SB_THUMBPOSITION, 0 ), (LPARAM) ((HWND) m_pTimelineCtl->m_ScrollVertical), iTemp );
						}
					}
				}
			}
			else
			{
				hr = E_INVALIDARG;
			}
		}
		break;

	case STP_GUTTER_SELECTED:
		if (variant.vt != VT_BOOL)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			if( (V_BOOL(&variant) != pSL->m_fSelected) )
			{
				// This code is duplicated in SetStripGutter
				// Change its selection
				pSL->m_fSelected = V_BOOL(&variant);

				if( m_pTimelineCtl )
				{
					// Update the gutter display
					RECT rect;
					m_pTimelineCtl->GetStripClientRect( pSL, &rect );
					rect.left = 0;
					rect.right = rect.left + GUTTER_WIDTH;
					m_pTimelineCtl->InvalidateRect( &rect, FALSE );
				}

				// Notify the strip
				/*
				var.vt = VT_BOOL;
				V_BOOL(&var) = (short)m_pMouseStripList->m_fSelected;
				m_pMouseStripList->m_pStrip->SetStripProperty( SP_GUTTERSELECT, var );
				*/
				hr = S_OK;
			}
		}
		break;

	case STP_STRIP_INFO:
		if (variant.vt != VT_BYREF)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			DMUSPROD_TIMELINE_STRIP_INFO *pDMUSPROD_TIMELINE_STRIP_INFO = (DMUSPROD_TIMELINE_STRIP_INFO *)V_BYREF( &variant );
			if( NULL == pDMUSPROD_TIMELINE_STRIP_INFO )
			{
				hr = E_POINTER;
			}
			else
			{
				pSL->m_clsidType = pDMUSPROD_TIMELINE_STRIP_INFO->clsidType;
				pSL->m_dwGroupBits = pDMUSPROD_TIMELINE_STRIP_INFO->dwGroupBits;
				pSL->m_dwIndex = pDMUSPROD_TIMELINE_STRIP_INFO->dwIndex;
			}
		}
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | OnDataChanged | This method calls the registered
//		<om IDMUSProdTimelineCallback::OnDataChanged> method with <p punk> as a
//		parameter.
//
//	@comm	When used in the Segment Designer, an <i IDMUSProdStripMgr> interface must be passed
//		in <p punk>.  The Segment Designer will then call the strip manager's <om IStream::Save>
//		method to retrieve the new data.
//
//  @parm   IUnknown* | punk | The interface to pass.
//
//	@rdesc	If there is an <om IDMUSProdTimelineCallback::OnDataChanged> method registered, 
//		the return value is the value returned by <om IDMUSProdTimelineCallback::OnDataChanged>.
//		Otherwise, the return value is E_FAIL.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStripMgr>, <om IDMUSProdTimelineCallback::OnDataChanged>
HRESULT CPrivateTimelineCtl::OnDataChanged( IUnknown* punk )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_FAIL;

	if( m_pTimelineCallback )
	{
		EnterCriticalSection( &m_csOnDataChanged );
		hr = m_pTimelineCallback->OnDataChanged( punk );
		LeaveCriticalSection( &m_csOnDataChanged );
	}
	else
	{
		return E_FAIL;
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | TrackPopupMenu | This method displays a
//		context menu at the specified position.
//
//  @parm   HMENU | hMenu | The handle of the menu to add to the default menu.  If NULL, don't add
//		any custom items.
//  @parm   long | lXPos | The horizontal coordinate to display the menu at, in screen coordinates.
//  @parm   long | lYPos | The vertical coordinate to display the menu at, in screen coordinates.
//	@parm	<i DMUSProdStrip>* | pIStrip | Which strip to display the popup menu for.  If NULL, display the default
//		edit menu and send the results to the Timeline.
//  @parm   BOOL | fEditMenu | If TRUE, display the default edit menu.
//
//	@comm	If a custom menu is specified in <p hMenu> and <p fEditMenu> is TRUE, the items in <p hMenu>
//		will be added immediately before the "Properties" item in the edit menu.
//
//	@comm	If a valid <p pIStrip> is given, a WM_COMMAND message will be sent to <om IDMUSProdStrip::OnWMMessage>
//		if the user chooses a menu item.  No message is sent if the user cancels the context menu.
//
//	@comm	If <p hMenu> is non-NULL, <p pIStrip> should also be non-NULL to ensure the custom menu items
//		are properly handled.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_INVALIDARG | <p hMenu> is NULL and fEditMenu is FALSE.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CPrivateTimelineCtl::TrackPopupMenu(HMENU hMenu, long x, long y, IDMUSProdStrip *pIStrip, BOOL fEditMenu)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_pTimelineCtl )
	{
		return m_pTimelineCtl->TrackPopupMenu( hMenu, x,y, pIStrip, fEditMenu );
	}
	return E_FAIL;
}

//  @method HRESULT | IDMUSProdTimeline | ClocksToRefTime | This method converts
//		from a time in clocks to a time in REFERENCE_TIME units
//
//	@comm	Negative values for <p lTime> are valid.  The tempo at time 0 will be used
//		to compute the value to return in <p pRefTime>.
//
//  @parm   long | lTime | The time in clocks
//  @parm   REFERENCE_TIME* | pRefTime | Address of a variable to receive the time in
//		REFERENCE_TIME units this time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p pRefTime>
//	@rvalue E_UNEXPECTED | The tempo is zero at some point.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::RefTimeToClocks>
HRESULT CPrivateTimelineCtl::ClocksToRefTime(
		/* [in] */  long		lTime,
		/* [out] */ REFERENCE_TIME		*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	if (NULL == pRefTime)
	{
		return E_POINTER;
	}

	if (NULL != m_pTempoMapMgr)
	{
		return m_pTempoMapMgr->ClocksToRefTime( lTime, pRefTime);
	}

	REFERENCE_TIME rtTime = 0;

	MUSIC_TIME mtNext, mtCur = 0;
	do
	{
		mtNext = 0;

		BOOL fHaveTempoTrack = FALSE;
		double dblTempo = 120.0;
		MUSIC_TIME mtLatestTempoTime = LONG_MIN;
		DWORD dwIndex = 0;
		while( TRUE )
		{
			IDMUSProdStripMgr *pTempoStripMgr = NULL;
			if( SUCCEEDED( GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
			{
				if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
				{
					DMUS_TEMPO_PARAM tempo;
					MUSIC_TIME mtNextTemp;
					HRESULT hr = pTempoStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNextTemp, &tempo );

					if( SUCCEEDED( hr ) )
					{
						fHaveTempoTrack = TRUE;
						// If we found a real tempo and it's later than all other tempos,
						// save it to use for this time span
						if( (hr == S_OK) && (tempo.mtTime > mtLatestTempoTime) )
						{
							dblTempo = tempo.dblTempo;
							mtLatestTempoTime = tempo.mtTime;
						}
						else if( mtLatestTempoTime == LONG_MIN )
						{
							dblTempo = tempo.dblTempo;
						}

						// Look for the earliest next tempo (mtNextTempo==0 means no more tempo changes)
						if( mtNextTemp && (!mtNext || (mtNextTemp < mtNext)) )
						{
							mtNext = mtNextTemp;
						}
					}
				}

				pTempoStripMgr->Release();
			}
			else
			{
				// No more strips to check - exit
				break;
			}
			dwIndex++;
		}

		if( !fHaveTempoTrack )
		{
			DMUS_TEMPO_PARAM tempo;
			if( SUCCEEDED( m_pTimeStrip->m_pTimeStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNext, &tempo ) ) )
			{
				dblTempo = tempo.dblTempo;
			}
		}

		ASSERT(dblTempo > 0.0);
		if( dblTempo <= 0.0 )
		{
			return E_UNEXPECTED;
		}

		long double ldRes;
		if( !mtNext || mtNext + mtCur > lTime )
		{
			ldRes = (long double(lTime - mtCur) * long double(REFCLOCKS_PER_MINUTE) + ((dblTempo * (long double)DMUS_PPQ) / 2.0)) /
					(dblTempo * (long double)DMUS_PPQ);
		}
		else
		{
			ldRes = ((long double)mtNext * (long double)REFCLOCKS_PER_MINUTE) / (dblTempo * (long double)DMUS_PPQ);
		}
		rtTime += (REFERENCE_TIME) ldRes;
		mtCur += mtNext;
	}
	while( mtNext && mtCur < lTime );

	*pRefTime = rtTime;
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | RefTimeToClocks | This method converts
//		from a time in REFERENCE_TIME units to a time in clocks.
//
//	@comm	Negative values for <p RefTime> are valid, in which case the tempo at time 0 will
//		be used to compute the value of <p plTime>.
//
//  @parm   REFERENCE_TIME | RefTime | The time in REFERENCE_TIME units.
//  @parm   long* | plTime | Address of a variable to receive the time in clocks.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p plTime>
//	@rvalue E_UNEXPECTED | The tempo is zero at some point.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::ClocksToRefTime>
HRESULT CPrivateTimelineCtl::RefTimeToClocks(
		/* [in] */  REFERENCE_TIME		RefTime,
		/* [out] */ long		*plTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == plTime)
	{
		return E_POINTER;
	}

	if (NULL != m_pTempoMapMgr)
	{
		return m_pTempoMapMgr->RefTimeToClocks( RefTime, plTime );
	}

	MUSIC_TIME mtNext, mtCur = 0;
	do
	{
		mtNext = 0;

		BOOL fHaveTempoTrack = FALSE;
		double dblTempo = 120.0;
		MUSIC_TIME mtLatestTempoTime = LONG_MIN;
		DWORD dwIndex = 0;
		while( TRUE )
		{
			IDMUSProdStripMgr *pTempoStripMgr = NULL;
			if( SUCCEEDED( GetStripMgr( GUID_TempoParam, 0xFFFFFFFF, dwIndex, &pTempoStripMgr ) ) )
			{
				if( S_OK != pTempoStripMgr->IsParamSupported( GUID_TimeSignature ) )
				{
					DMUS_TEMPO_PARAM tempo;
					MUSIC_TIME mtNextTemp;
					HRESULT hr = pTempoStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNextTemp, &tempo );

					if( SUCCEEDED( hr ) )
					{
						fHaveTempoTrack = TRUE;
						// If we found a real tempo and it's later than all other tempos,
						// save it to use for this time span
						if( (hr == S_OK) && (tempo.mtTime > mtLatestTempoTime) )
						{
							dblTempo = tempo.dblTempo;
							mtLatestTempoTime = tempo.mtTime;
						}
						else if( mtLatestTempoTime == LONG_MIN )
						{
							dblTempo = tempo.dblTempo;
						}

						// Look for the earliest next tempo (mtNextTempo==0 means no more tempo changes)
						if( mtNextTemp && (!mtNext || (mtNextTemp < mtNext)) )
						{
							mtNext = mtNextTemp;
						}
					}
				}

				pTempoStripMgr->Release();
			}
			else
			{
				// No more strips to check - exit
				break;
			}
			dwIndex++;
		}

		if( !fHaveTempoTrack )
		{
			DMUS_TEMPO_PARAM tempo;
			if( SUCCEEDED( m_pTimeStrip->m_pTimeStripMgr->GetParam( GUID_TempoParam, mtCur, &mtNext, &tempo ) ) )
			{
				dblTempo = tempo.dblTempo;
			}
		}

		ASSERT(dblTempo > 0.0);
		if( dblTempo <= 0.0 )
		{
			return E_UNEXPECTED;
		}

		// Convert mtNext to ldRes
		long double ldRes = ((REFERENCE_TIME)mtNext * REFCLOCKS_PER_MINUTE) / (dblTempo * DMUS_PPQ);
		if( !mtNext || RefTime <= ldRes )
		{
			// Convert RefTime to ldblTmp
			long double ldblTmp = ((long double)RefTime * dblTempo * (long double)DMUS_PPQ + long double(REFCLOCKS_PER_MINUTE / 2)) /
								  (long double)REFCLOCKS_PER_MINUTE;
			*plTime = mtCur + (MUSIC_TIME)ldblTmp;
		}
		else
		{
			mtCur += mtNext;
		}
		RefTime -= (REFERENCE_TIME)ldRes;
	}
	while( mtNext && RefTime > 0 );
	return S_OK;
}

//  @method HRESULT | IDMUSProdTimeline | PositionToRefTime | This method converts
//		from a horizontal pixel position to a time in REFERENCE_TIME units.
//
//	@comm	Negative values for <p lPosition> are valid, in which case the tempo at time 0 will be used
//		to compute the value to return in <p pRefTime>.
//
//  @parm   long | lPosition | The horizontal pixel position.
//  @parm   REFERENCE_TIME* | pRefTime | Address of a variable to receive the time
//		in REFERENCE_TIME units this position resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as  <p pRefTime>
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::RefTimeToClocks>
HRESULT CPrivateTimelineCtl::PositionToRefTime(
		/* [in] */  long		position,
		/* [out] */ REFERENCE_TIME		*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == pRefTime)
	{
		return E_POINTER;
	}

	if (m_fMusicTime == TRUE)
	{
		long lClocks;
		HRESULT hr;
		if (SUCCEEDED(hr = PositionToClocks( position, &lClocks)))
		{
			if (NULL != m_pTempoMapMgr)
			{
				hr = m_pTempoMapMgr->ClocksToRefTime( lClocks, pRefTime);
			}
			else
			{
				hr = ClocksToRefTime( lClocks, pRefTime);
			}
		}
		return hr;
	}
	else
	{
		DMUS_TEMPO_PARAM dmTempo;
		if( FAILED( GetParam( GUID_TempoParam, 0xffffffff, 0, 0, NULL, &dmTempo ) ) )
		{
			return E_FAIL;
		}
		double dblTmp = position;
		dblTmp /= m_dblZoom * (double)DMUS_PPQ * dmTempo.dblTempo / (double)REFCLOCKS_PER_MINUTE;
		*pRefTime = (REFERENCE_TIME) dblTmp;
		return S_OK;
	}
}

//  @method HRESULT | IDMUSProdTimeline | RefTimeToPosition | This method converts
//		from a time in REFERENCE_TIME units to a horizontal pixel position
//
//	@comm	Negative values for <p RefTime> are valid, in which case the tempo at time 0 will
//		be used to compute the value of <p plPosition>.
//
//  @parm   REFERENCE_TIME | RefTime | The time in REFERENCE_TIME units.
//  @parm   long* | plPosition | Address of a variable to receive the pixel position this
//		time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p plPosition>
//	@rvalue E_UNEXPECTED | The tempo is zero at some point.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::PositionToRefTime>
HRESULT CPrivateTimelineCtl::RefTimeToPosition(
		/* [in] */  REFERENCE_TIME		RefTime,
		/* [out] */ long		*pPosition)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == pPosition)
	{
		return E_POINTER;
	}

	if (m_fMusicTime == TRUE)
	{
		long lClocks;
		// RefTimeToClocks will map this fn to m_pTempoMapMgr if necessary
		HRESULT hr;
		if (SUCCEEDED(hr = RefTimeToClocks( RefTime, &lClocks)))
		{
			hr = ClocksToPosition( lClocks, pPosition);
		}
		return hr;
	}
	else
	{
		DMUS_TEMPO_PARAM dmTempo;
		if( FAILED( GetParam( GUID_TempoParam, 0xffffffff, 0, 0, NULL, &dmTempo ) ) )
		{
			return E_FAIL;
		}
		double dblTmp = (double)RefTime * m_dblZoom * (double)DMUS_PPQ * dmTempo.dblTempo /
						(double)REFCLOCKS_PER_MINUTE;;
		*pPosition = (long) dblTmp;
		return S_OK;
	}
}

//  @method HRESULT | IDMUSProdTimeline | MeasureBeatToRefTime | This method converts
//		from a measure and beat to a time in REFERENCE_TIME units.
//
//	@comm	If <p lMeasure> is less than 0, the Time Signature at time 0 will
//			be used to compute <p pRefTime>.  If <p lBeat> is less than 0, the
//			Time Signature in measure <p lMeasure> will be used to compute the offset
//			from the start of measure <p lMeasure>.
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   long | lMeasure | The measure.
//  @parm   long | lBeat | The beat.
//  @parm   REFERENCE_TIME* | pRefTime | Address of a variable to receive the
//		reference time.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | NULL was passed as <p pRefTime>.
//	@rvalue E_UNEXPECTED | The Time Signature was unable to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::RefTimeToMeasureBeat>
HRESULT CPrivateTimelineCtl::MeasureBeatToRefTime(
		/* [in] */ DWORD		dwGroupBits,
		/* [in] */ DWORD		dwIndex,
		/* [in] */  long		lMeasure,
		/* [in] */  long		lBeat,
		/* [out] */ REFERENCE_TIME		*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (NULL == pRefTime)
	{
		return E_POINTER;
	}

	long lClocks;
	HRESULT hr;
	if (SUCCEEDED( hr = MeasureBeatToClocks( dwGroupBits, dwIndex, lMeasure, lBeat, &lClocks)))
	{
		if (NULL != m_pTempoMapMgr)
		{
			return m_pTempoMapMgr->ClocksToRefTime( lClocks, pRefTime);
		}
		hr = ClocksToRefTime( lClocks, pRefTime);
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | RefTimeToMeasureBeat | This method converts
//		from a time in REFERENCE_CLOCK units to a time in measures and beats
//
//	@parm   DWORD | dwGroupBits | Which track group(s) to look for a time signature in.  A value of
//		0 is invalid.  Each bit in <p dwGroupBits> corresponds to a track group.  To look for a time
//		signature in any strip manager regardless of groups, set this parameter to 0xFFFFFFFF. 
//	@parm   DWORD | dwIndex | Zero-based index of the specified time signature to use.  This index
//		will indicate to use the nth strip manager that provides time signature information.
//  @parm   REFERENCE_TIME | RefTime | The time in REFERENCE_CLOCK units
//  @parm   long* | plMeasure | Address of a variable to receive the measure this
//							   time resolves to.
//  @parm   long* | plBeat | Address of a variable to receive the beat this
//							time resolves to.
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p plMeasure> or <p plBeat>
//	@rvalue E_INVALIDARG | <p RefTime> is less than 0.  <p plMeasure> and <p plBeat> are
//						   set to -1.
//	@rvalue E_UNEXPECTED | The tempo is zero at some point or the Time Signature was unable
//		to be read by a call to <om IDMUSProdTimeline::GetParam>.
//
//	@xref	<i IDMUSProdTimeline>, <om IDMUSProdTimeline::MeasureBeatToRefTime>
HRESULT CPrivateTimelineCtl::RefTimeToMeasureBeat(
		/* [in] */  DWORD		 dwGroupBits,
		/* [in] */  DWORD		 dwIndex,
		/* [in] */  REFERENCE_TIME		RefTime,
		/* [out] */ long		*plMeasure,
		/* [out] */ long		*plBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	long lClocks;
	HRESULT hr;
	if (NULL != m_pTempoMapMgr)
	{
		hr = m_pTempoMapMgr->RefTimeToClocks( RefTime, &lClocks );
	}
	else
	{
		hr = RefTimeToClocks( RefTime, &lClocks);
	}
	if ( SUCCEEDED(hr) )
	{
		hr = ClocksToMeasureBeat( dwGroupBits, dwIndex, lClocks, plMeasure, plBeat);
	}
	return hr;
}

//  @method HRESULT | IDMUSProdTimeline | ScreenToStripPosition | This method converts from a
//		<t POINT> in screen coordinates to a <t POINT> in strip coordinates.
//
//	@parm	<i IDMUSProdStrip>* | pIStrip | Which strip to get the new coordinates from.
//  @parm   <t POINT>* | pPoint | The screen point to convert.
//
//  @rvalue S_OK | The operation was successful.
//	@rvalue E_POINTER | <p pIStrip> or <p pPoint> are NULL.
//	@rvalue E_INVALIDARG | <p pIStrip> was not previously added to the Timeline.
//
//	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>
HRESULT CPrivateTimelineCtl::ScreenToStripPosition(
		/* [in] */		 IDMUSProdStrip		*pIStrip,
		/* [in] [out] */ POINT				*pPoint)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameters
	if( NULL == pIStrip || NULL == pPoint )
	{
		return E_POINTER;
	}

	if( m_pTimelineCtl )
	{
		return m_pTimelineCtl->ScreenToStripPosition( pIStrip, pPoint );
	}
	return E_FAIL;
}

//  @method HRESULT | IDMUSProdTimeline | StripGetTimelineProperty | This method gets a strip property
//		that is controlled by the Timeline.
//
//	@parm	<i IDMUSProdStrip>* | pIStrip | Which strip to get the property of.
//  @parm   <t STRIP_TIMELINE_PROPERTY> | stp | Which property to get.  Must be one of <t STRIP_TIMELINE_PROPERTY>.
//  @parm   VARIANT* | pVariant | The address to return to property's data in.
//
//  @rvalue S_OK | The operation was successful.
//  @rvalue E_POINTER | <p pVariant> or <p pIStrip> are NULL.
//	@rvalue E_INVALIDARG | <p stp> does not contain a valid property type, <p pIStrip> was not previously
//		added to the Timeline,	or <p pVariant> contained an invalid value for the specified property type.
//
//	@xref	<i IDMUSProdTimeline>, <t STRIP_TIMELINE_PROPERTY>,
//		<om IDMUSProdTimeline::StripSetTimelineProperty>, <i IDMUSProdStrip>
HRESULT CPrivateTimelineCtl::StripGetTimelineProperty(
		/* [in] */	IDMUSProdStrip*	pIStrip,
		/* [in] */	STRIP_TIMELINE_PROPERTY stp,
		/* [out] */	VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr = E_INVALIDARG;

	if( NULL == pIStrip || NULL == pVariant )
	{
		return E_POINTER;
	}

	if (m_pStripList == NULL)
	{
		return E_INVALIDARG;
	}

	StripList* pSL = FindStripList( pIStrip );
	if( pSL == NULL )
	{
		return E_INVALIDARG;
	}

	switch( stp )
	{
	case STP_VERTICAL_SCROLL:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = pSL->m_lVScroll;
		hr = S_OK;
		break;

	case STP_ENTIRE_STRIP_RECT:
		if( m_pTimelineCtl && (pVariant->vt == VT_BYREF) && (V_BYREF(pVariant) != NULL) )
		{
			RECT *pRect = (RECT *)V_BYREF(pVariant);
			m_pTimelineCtl->GetEntireStripClientRect( pSL, pRect );
			hr = S_OK;
		}
		break;
	case STP_STRIP_RECT:
	case STP_FBAR_RECT:
	case STP_FBAR_CLIENT_RECT:
		if( m_pTimelineCtl && (pVariant->vt == VT_BYREF) && (V_BYREF(pVariant) != NULL) )
		{
			RECT *pRect = (RECT *)V_BYREF(pVariant);
			m_pTimelineCtl->GetStripClientRect( pSL, pRect );
			if( stp == STP_STRIP_RECT )
			{
				pRect->left += m_lFunctionBarWidth;
			}
			else if( stp == STP_FBAR_RECT )
			{
				pRect->right = m_lFunctionBarWidth;
			}
			else // STP_FBAR_CLIENT_RECT
			{
				pRect->bottom = pRect->bottom - pRect->top;
				pRect->top = 0;
				pRect->right = m_lFunctionBarWidth - GUTTER_WIDTH - BORDER_VERT_WIDTH;
			}
			if( pRect->left > pRect->right )
			{
				// there is no client area to draw in, so fail
				pRect->left = 0;
				pRect->right = 0;
				pRect->bottom = 0;
				pRect->top = 0;
				hr = E_FAIL;
			}
			else
			{
				hr = S_OK;
			}
		}
		break;

	case STP_GET_HDC:
		// Only succeed if m_hWnd is actually a real window
		if( m_pTimelineCtl
		&&	::IsWindow( m_pTimelineCtl->m_hWnd ) )
		{
			HDC hdc;
			hdc = ::GetDC( m_pTimelineCtl->m_hWnd );

			if( hdc )
			{
				CDC dc;
				if( dc.Attach( hdc ) )
				{
					RECT rect;

					m_pTimelineCtl->GetStripClientRect( pSL, &rect );
					rect.top += BORDER_HORIZ_WIDTH;
					rect.left += m_lFunctionBarWidth;
					hr = S_OK;
					if( rect.left > rect.right )
					{
						// there is no client area to draw in, so return
						// a null hdc
						ReleaseDC(m_pTimelineCtl->m_hWnd, hdc);
						hdc = NULL;
						hr = E_FAIL;
					}
					else
					{
						CRgn rgn;
						// set window org so m_lXScrollPos,0 is top left of strip
						dc.SetWindowOrg( -rect.left, -rect.top );
						// set clip region so we can't plot outside of strip
						rgn.CreateRectRgn( rect.left, rect.top, rect.right, rect.bottom );
						dc.SelectClipRgn( &rgn );
						rgn.DeleteObject();
					}
					dc.Detach();
				}
				else
				{
					ReleaseDC(m_pTimelineCtl->m_hWnd,hdc);
					hdc = NULL;
					hr = E_FAIL;
				}
			}
			else
			{
				hr = E_FAIL;
			}
			pVariant->vt = VT_I4;
			V_I4(pVariant) = (long)hdc;
		}
		else
		{
			hr = E_FAIL;
		}
		break;

	case STP_HEIGHT:
		pVariant->vt = VT_I4;
		hr = S_OK;
		if ( pSL->m_sv == SV_NORMAL )
		{
			V_I4(pVariant) = pSL->m_lHeight;
		}
		else if ( pSL->m_sv == SV_MINIMIZED )
		{
			V_I4(pVariant) = pSL->m_lRestoreHeight;
		}
		else
		{
			V_I4(pVariant) = -1;
			hr = E_UNEXPECTED;
		}
		break;

	case STP_STRIPVIEW:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = (int) pSL->m_sv;
		hr = S_OK;
		break;

	case STP_POSITION:
		{
			pVariant->vt = VT_I4;
			StripList*	pScan;
			long lResult = -1, lPosition = 0;
			for( pScan = m_pStripList; pScan; pScan = pScan->m_pNext )
			{
				if( pScan->m_pStrip == pIStrip )
				{
					lResult = lPosition;
					break;
				}
				lPosition++;
			}
			if( lResult == -1 )
			{
				hr = E_INVALIDARG;
				V_I4(pVariant) = lResult;
			}
			else
			{
				hr = S_OK;
				V_I4(pVariant) = lResult;
			}
		}
		break;

	case STP_GUTTER_SELECTED:
		pVariant->vt = VT_BOOL;
		V_BOOL(pVariant) = (short)pSL->m_fSelected;
		hr = S_OK;
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}
	return hr;
}

const StripList *GetStripList( const CPrivateTimelineCtl *pCPrivateTimelineCtl )
{
	ASSERT( pCPrivateTimelineCtl );
	if( pCPrivateTimelineCtl )
	{
		ASSERT( pCPrivateTimelineCtl->m_pStripList );
		return pCPrivateTimelineCtl->m_pStripList;
	}
	return NULL;
}

long CPrivateTimelineCtl::TotalStripHeight(void) const
{
	const StripList* pSL;
	long lReturn = 0;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		lReturn += pSL->m_lHeight + ( 2 * BORDER_HORIZ_DRAWWIDTH );
	}
	return lReturn;
}

void CPrivateTimelineCtl::CallStripWMMessage( const StripList* pSL, UINT nMsg, WPARAM wParam,
	LPARAM lParam )
{
	BOOL fFunctionBar = FALSE; // true if mouse is in function bar area

	if (pSL == NULL)
	{
		return;
	}

	const StripList* pMainStripList = GetStripList( this );

	long xPos, yPos;
	xPos = GET_X_LPARAM(lParam);
	yPos = GET_Y_LPARAM(lParam);

	switch(nMsg)
	{
	case WM_MOUSEMOVE:
	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_SETCURSOR:
	case WM_CONTEXTMENU:
		{
		// adjust lParam so the cursor position is relative to 0,0 of the strip

			if( xPos < m_lFunctionBarWidth )
			{
				fFunctionBar = TRUE;
			}

			// add horizontal scroll and subtract the function bar and any extras time at the start
			xPos = xPos + m_lXScrollPos - m_lFunctionBarWidth;

			// subtract away the border
			yPos -= BORDER_HORIZ_WIDTH;
			// if not minized, add any strip vertical scrolling
			if (pSL->m_sv != SV_MINIMIZED)
			{
				yPos += pSL->m_lVScroll;
			}

			// add timeline scroll for all except top strip, which doesn't scroll
			if( pSL != pMainStripList )
			{
				yPos += m_lYScrollPos;
			}

			// subtract the heights of any strips above this one
			for( const StripList* pTempSL = pMainStripList; pTempSL; pTempSL = pTempSL->m_pNext )
			{
				if( pTempSL == pSL )
				{
					break;
				}
				yPos -= ( pTempSL->m_lHeight + BORDER_HORIZ_DRAWWIDTH );
			}
			lParam = MAKELONG( xPos, yPos );
		}
		break;
	default:
		break;
	}
	if( fFunctionBar )
	{
		if( nMsg == WM_LBUTTONDOWN || nMsg == WM_RBUTTONDOWN )
		{
			// Unselect everything
			SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
			SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
		}

		// we're in the function bar area
		IDMUSProdStripFunctionBar* pSFB;
		if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdStripFunctionBar, (void**)&pSFB)))
		{
			pSFB->FBOnWMMessage( nMsg, wParam, lParam, xPos, yPos );
			pSFB->Release();
		}
	}
	else
	{
		if( m_pTimelineCtl
		&&	(nMsg == WM_LBUTTONDOWN || nMsg == WM_RBUTTONDOWN) )
		{
			// Set the time cursor to where the user clicked
			long lTime;
			PositionToClocks( xPos, &lTime );
			m_pTimelineCtl->SetTimeCursor( lTime, false, true );
		}
		pSL->m_pStrip->OnWMMessage( nMsg, wParam, lParam, xPos, yPos );
	}
}

void CPrivateTimelineCtl::DeactivateStripList(void)
{
	RECT rect;

	if( m_pActiveStripList )
	{
		if( m_pTimelineCtl )
		{
			m_pTimelineCtl->GetStripClientRect( m_pActiveStripList, &rect );
			//rect.left = 0;
			//rect.right = rect.left + GUTTER_WIDTH;
			m_pTimelineCtl->InvalidateRect( &rect, FALSE );
		}
		const StripList* pTempSL = m_pActiveStripList;
		m_pActiveStripList = NULL;
		CallStripWMMessage( pTempSL, WM_KILLFOCUS, 0, 0 );
	}
}

void CPrivateTimelineCtl::ActivateStripList( const StripList* pSL )
{
	if( pSL != m_pActiveStripList )
	{
		if( m_pActiveStripList )
		{
			DeactivateStripList();
		}
		m_pActiveStripList = pSL;

		if( m_pTimelineCtl )
		{
			RECT rect;
			m_pTimelineCtl->GetStripClientRect( pSL, &rect );
			//rect.left = 0;
			//rect.right = rect.left + GUTTER_WIDTH;
			m_pTimelineCtl->InvalidateRect( &rect, FALSE );
		}
		CallStripWMMessage( m_pActiveStripList, WM_SETFOCUS, 0, 0 );
	}
}

HRESULT CPrivateTimelineCtl::StripPointToClient( const StripList* pSL, POINT *pPoint) const
{
	// Validate parameters
	ASSERT( pSL && pPoint );
	if ((NULL == pSL)||(NULL == pPoint))
	{
		return E_INVALIDARG;
	}

	// Store the point's y coordinate in a working variable
	long yPos;
	yPos = pPoint->y;

	// subtract horizontal scroll and add the function bar and early time
	pPoint->x -= m_lXScrollPos - m_lFunctionBarWidth;

	// add any borders
	yPos += BORDER_HORIZ_WIDTH;

	const StripList *pMainStripList = GetStripList( this );
	// Check if we're looking in the first strip
	if (pSL == pMainStripList)
	{
		if (pSL->m_sv != SV_MINIMIZED)
		{
			// subtract any strip vertical scrolling, if not minized
			yPos -= pSL->m_lVScroll;
		}
		pPoint->y = yPos;
		return S_OK;
	}

	// subtract timeline scroll for all except top strip, which doesn't scroll
	yPos -= m_lYScrollPos;

	// add the heights of any strips above this one
	for( const StripList* pTempSL = pMainStripList; pTempSL; pTempSL = pTempSL->m_pNext )
	{
		if( pSL == pTempSL )
		{
			break;
		}
		yPos += ( pTempSL->m_lHeight + BORDER_HORIZ_DRAWWIDTH );
	}

	if ( pTempSL == NULL )
	{
		// Strip not in our list.
		return E_INVALIDARG;
	}

	if (pSL->m_sv != SV_MINIMIZED)
	{
		// subtract any strip vertical scrolling, if not minized
		yPos -= pSL->m_lVScroll;
	}

	pPoint->y = yPos;
	return S_OK;
}

HRESULT CPrivateTimelineCtl::StripRectToClient( const StripList* pSL, LPRECT pRect) const
{
	POINT point;
	point.x = 0;
	point.y = 0;

	HRESULT hr;
	hr = StripPointToClient( pSL, &point );
	if ( SUCCEEDED(hr) )
	{
		pRect->top += point.y;
		pRect->bottom += point.y;
		pRect->left += point.x;
		pRect->right += point.x;
	}
	return hr;
}

bool CPrivateTimelineCtl::AnyGutterSelectedStrips( void ) const
{
	const StripList* pSL;
	for( pSL = GetStripList( this ); pSL; pSL = pSL->m_pNext )
	{
		if( (pSL->m_pStrip != NULL) && pSL->m_fSelected )
		{
			return true;
		}
	}

	return false;
}

bool CPrivateTimelineCtl::ComputeEarlyAndLateTime( long &lEarlyTime, long &lLateTime ) const
{
	// Initialize the times to 0.
	lEarlyTime = 0;
	lLateTime = 0;

	VARIANT varTime;
	for( const StripList* pList = GetStripList( this ); pList; pList = pList->m_pNext )
	{
		if( SUCCEEDED( pList->m_pStrip->GetStripProperty( SP_EARLY_TIME, &varTime ) ) )
		{
			lEarlyTime = max( lEarlyTime, V_I4(&varTime) );
		}

		if( SUCCEEDED( pList->m_pStrip->GetStripProperty( SP_LATE_TIME, &varTime ) ) )
		{
			lLateTime = max( lLateTime, V_I4(&varTime) );
		}
	}

	return (lEarlyTime != 0) || (lLateTime != 0);
}

HRESULT CPrivateTimelineCtl::SetTimelineOleCtl( IUnknown *punkTimelineOleCtl )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CTimelineCtl *pNewTimelineCtl = NULL;
	if( punkTimelineOleCtl
	&&	FAILED( punkTimelineOleCtl->QueryInterface( IID_ICTimelineCtl, (void **)&pNewTimelineCtl ) ) )
	{
		return E_INVALIDARG;
	}

	if( m_pTimelineCtl == pNewTimelineCtl
	||	m_fInSetTimelineOleCtl )
	{
		if( pNewTimelineCtl )
		{
			pNewTimelineCtl->Release();
		}
		return S_FALSE;
	}

	m_fInSetTimelineOleCtl = true;

	if( m_pTimelineCtl )
	{
		if( ::IsWindow(m_pTimelineCtl->m_hWnd)
		&&	m_pStripList )
		{
			StripList *pTemp = m_pStripList;
			while( pTemp )
			{
				pTemp->m_pStrip->OnWMMessage( WM_DESTROY, 0, 0, 0, 0 );
				pTemp = pTemp->m_pNext;
			}
		}

		m_pTimelineCtl->SetPrivateTimelineCtl( NULL );
		m_pTimelineCtl->Release();
	}

	// Set the new timeline pointer
	m_pTimelineCtl = pNewTimelineCtl;

	if( m_pTimelineCtl)
	{
		m_pTimelineCtl->AddRef();
		m_pTimelineCtl->SetPrivateTimelineCtl( this );

		if( ::IsWindow(m_pTimelineCtl->m_hWnd)
		&&	m_pStripList )
		{
			StripList *pTemp = m_pStripList;
			while( pTemp )
			{
				pTemp->m_pStrip->OnWMMessage( WM_CREATE, 0, 0, 0, 0 );
				pTemp = pTemp->m_pNext;
			}
		}
	}

	if( pNewTimelineCtl )
	{
		pNewTimelineCtl->Release();
	}
	m_fInSetTimelineOleCtl = false;
	return S_OK;
}

HRESULT CPrivateTimelineCtl::FinalCleanUp()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release our reference to the Timeline OLE control
	SetTimelineOleCtl( NULL );

	// This should be NULL
	ASSERT( m_pTimelineCtl == NULL );

	IDMUSProdPropPageObject* pPPO;

	// Clean up the strip manager list
	while( m_pStripMgrList )
	{
		if( m_pStripMgrList->m_pStripMgr )
		{
			// make sure that there's no chance an object is left over
			if( SUCCEEDED( m_pStripMgrList->m_pStripMgr->QueryInterface( 
				IID_IDMUSProdPropPageObject, (void**)&pPPO )))
			{
				RemovePropertyPageObject(pPPO);
				pPPO->Release();
			}

			// Now, set the StripMgr's timeline pointer to NULL
			VARIANT varTimeline;
			varTimeline.vt = VT_UNKNOWN;
			V_UNKNOWN(&varTimeline) = NULL;
			m_pStripMgrList->m_pStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
		}

		// Now, delete the StripMgr list item (which will release the
		// strip manager interface)
		StripMgrList* pSML = m_pStripMgrList->m_pNext;
		delete m_pStripMgrList;
		m_pStripMgrList = pSML;
	}

	// Clean up the strip list
	while( m_pStripList )
	{
		if( m_pStripList->m_pStrip )
		{
			// make sure that there's no chance an object is left over
			if( SUCCEEDED( m_pStripList->m_pStrip->QueryInterface( 
				IID_IDMUSProdPropPageObject, (void**)&pPPO )))
			{
				RemovePropertyPageObject(pPPO);
				pPPO->Release();
			}
		}

		// Now, delete the Strip list item (which will release the
		// strip interface)
		StripList* pSL = m_pStripList->m_pNext;
		delete m_pStripList;
		m_pStripList = pSL;
	}

	// Clean up the notification lists
	NotifyEntry* pNotifyEntry = NULL;
	while( !m_lstNotifyEntry.IsEmpty() )
	{
		pNotifyEntry = m_lstNotifyEntry.RemoveHead();
		if ( pNotifyEntry != NULL )
		{
			delete pNotifyEntry;
		}
	}

	// Clean up our pointers
	if( m_pDMUSProdFramework )
	{
		m_pDMUSProdFramework->Release();
		m_pDMUSProdFramework = NULL;
	}
	if( m_pIDMPerformance )
	{
		m_pIDMPerformance->Release();
		m_pIDMPerformance = NULL;
	}
	if( m_pTimelineCallback )
	{
		m_pTimelineCallback->Release();
		m_pTimelineCallback = NULL;
	}

	return S_OK;
}

HRESULT WINAPI CPrivateTimelineCtlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD dw)
{
	UNREFERENCED_PARAMETER( dw );
	CPrivateTimelineCtl *pCPrivateTimelineCtl = (CPrivateTimelineCtl *)pv;
	ASSERT( pCPrivateTimelineCtl );
	if( pCPrivateTimelineCtl->m_pTimelineCtl )
	{
		return pCPrivateTimelineCtl->m_pTimelineCtl->QueryInterface( riid, ppv );
	}
	else
	{
		return E_NOINTERFACE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\PrivateTimelineCtl.h ===
#ifndef __PRIVATETIMELINECTL_H_
#define __PRIVATETIMELINECTL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// PrivateTimelineCtl.h : Declaration of the CPrivateTimelineCtl

#include "resource.h"       // main symbols
#include "stripmgr.h"
#include "TimelineDraw.h"
#include <DMUSProd.h>
#include "ContextMenuHandler.h"
#include <afxext.h>
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )

#ifndef REFCLOCKS_PER_MINUTE
#define REFCLOCKS_PER_MINUTE 600000000
#endif

interface IDirectMusicPerformance;
class CContextMenuHandler;
class CTimeStrip;

struct StripMgrList
{
	struct StripMgrList*	m_pNext;
	IDMUSProdStripMgr*		m_pStripMgr;
	DWORD					m_dwGroupBits;

	StripMgrList(IDMUSProdStripMgr* pStripMgr, DWORD dwGroupBits)
	{
		ASSERT( pStripMgr );
		m_pStripMgr = pStripMgr;
		pStripMgr->AddRef();
		m_pNext = NULL;
		m_dwGroupBits = dwGroupBits;
	};

	~StripMgrList()
	{
		ASSERT( m_pStripMgr );
		m_pStripMgr->Release();
	};
};

struct StripList
{
	struct StripList*	m_pNext;
	IDMUSProdStrip*		m_pStrip;
	long				m_lHeight;	// height of strip
	long				m_lVScroll; // amount of vertical scroll
	long				m_lRestoreHeight;	// height of strip to retore to when maximizing it
	STRIPVIEW			m_sv;
	BOOL				m_fSelected;
	DWORD				m_dwGroupBits;
	DWORD				m_dwIndex;
	CLSID				m_clsidType;

	StripList(IDMUSProdStrip* pStrip, REFCLSID clsidype)
	{
		ASSERT( pStrip );
		m_pStrip = pStrip;
		pStrip->AddRef();
		m_pNext = NULL;
		m_lHeight = MIN_STRIP_HEIGHT;
		m_lVScroll = 0;
		m_lRestoreHeight = MIN_STRIP_HEIGHT;
		m_sv = SV_NORMAL;
		m_fSelected = FALSE;
		m_dwGroupBits = 1;
		m_dwIndex = 0;
		memcpy( &m_clsidType, &clsidype, sizeof(GUID) );
	};

	~StripList()
	{
		ASSERT( m_pStrip );
		m_pStrip->Release();
	}
};

struct NotifyListEntry
{
	IDMUSProdStripMgr*	pIStripMgr;
	DWORD				dwGroupBits;

	NotifyListEntry(IDMUSProdStripMgr* pINewStripMgr, DWORD dwNewGroupBits)
	{
		pIStripMgr = pINewStripMgr;
		dwGroupBits = dwNewGroupBits;
	}
};

struct NotifyEntry
{
	NotifyEntry( IDMUSProdStripMgr* pIStripMgr, REFGUID guid, DWORD dwGroupBits )
	{
		memcpy( &m_guid, &guid, sizeof(GUID) );

		NotifyListEntry* pNotifyListEntry = new NotifyListEntry( pIStripMgr, dwGroupBits);
		m_lstNotifyListEntry.AddHead( pNotifyListEntry );
	}

	~NotifyEntry()
	{
		while ( !m_lstNotifyListEntry.IsEmpty() )
		{
			NotifyListEntry* pNotifyListEntry = m_lstNotifyListEntry.RemoveHead();
			delete pNotifyListEntry;
		};
	}

	GUID		m_guid;
    CTypedPtrList<CPtrList, NotifyListEntry*> m_lstNotifyListEntry;
};

int CompareStrips( int nType1, DWORD dwGroups1, DWORD dwIndex1, BSTR bstrName1, int nType2, DWORD dwGroups2, DWORD dwIndex2, BSTR bstrName2 );
int StripCLSIDToInt( REFCLSID clsidType );
int StripCKIDsToInt( FOURCC ckid, FOURCC fccType );
void InsertMenuInMenu( CMenu* pMenu1, UINT nPos, CMenu* pMenu2);
const StripList *GetStripList( const class CPrivateTimelineCtl *pCPrivateTimelineCtl );
HRESULT WINAPI CPrivateTimelineCtlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);


/////////////////////////////////////////////////////////////////////////////
// CPrivateTimelineCtl
class ATL_NO_VTABLE CPrivateTimelineCtl : 
	public IDMUSProdTimeline,
	public IDMUSProdPrivateTimelineCtl,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPrivateTimelineCtl, &CLSID_PrivateTimelineCtl>
{
	friend CContextMenuHandler;
	friend CTimelineCtl;
	friend CTimeStrip;
	friend const StripList *GetStripList( const CPrivateTimelineCtl *pCPrivateTimelineCtl );
	friend HRESULT WINAPI CPrivateTimelineCtlQI(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);

public:
	CPrivateTimelineCtl();
	~CPrivateTimelineCtl();

DECLARE_NO_REGISTRY()
	HRESULT FinalConstruct();

BEGIN_COM_MAP(CPrivateTimelineCtl)
	COM_INTERFACE_ENTRY(IDMUSProdTimeline)
	COM_INTERFACE_ENTRY_IID(IID_ICPrivateTimelineCtl, CPrivateTimelineCtl)
	COM_INTERFACE_ENTRY_IID(IID_IDMUSProdPrivateTimelineCtl, IDMUSProdPrivateTimelineCtl)
	COM_INTERFACE_ENTRY_FUNC_BLIND(0, CPrivateTimelineCtlQI)
END_COM_MAP()

// don't forget to add any new messages that might go to strips
// to the CallStripWMMessage function.
BEGIN_MSG_MAP(CPrivateTimelineCtl)
END_MSG_MAP()


// IDMUSProdTimeline
public:
    STDMETHODIMP AddStripMgr( 
        /* [in] */ IDMUSProdStripMgr* pIStripMgr,
		/* [in] */ DWORD			  dwGroupBits);
    
    STDMETHODIMP AddStrip( 
        /* [in] */ IDMUSProdStrip* pIStrip);
    
    STDMETHODIMP SetMarkerTime( 
        /* [in] */ MARKERID idMarkerType,
		/* [in] */ TIMETYPE	ttType,
        /* [in] */ long lTime);
    
    STDMETHODIMP GetMarkerTime( 
        /* [in] */ MARKERID idMarkerType,
		/* [in] */ TIMETYPE	type,
        /* [out] */ long *plTime);
    
    STDMETHODIMP ClocksToPosition( 
        /* [in] */ long lTime,
        /* [out] */ long *plPosition);
    
    STDMETHODIMP PositionToClocks( 
        /* [in] */ long lPosition,
        /* [out] */ long *plTime);

	STDMETHODIMP DrawMusicLines(
		/* [in] */ HDC					hdc,
		/* [in] */ MUSICLINE_PROPERTY	mlp,
		/* [in] */ DWORD				dwGroupBits,
		/* [in] */ DWORD				dwIndex,
		/* [in] */ LONG					lXOffset);

	STDMETHODIMP SetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [in] */ VARIANT			var
		);

	STDMETHODIMP Refresh(
			void
		);

	STDMETHODIMP GetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [out] */ VARIANT*			pvar
		);

    STDMETHODIMP ClocksToMeasureBeat( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lTime,
        /* [out] */ long*	plMeasure,
        /* [out] */ long*	plBeat);
    
    STDMETHODIMP PositionToMeasureBeat( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lPosition,
        /* [out] */ long*	plMeasure,
        /* [out] */ long*	plBeat);
    
    STDMETHODIMP MeasureBeatToClocks( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lMeasure,
        /* [in] */  long	lBeat,
        /* [out] */ long*	plTime);
    
    STDMETHODIMP MeasureBeatToPosition( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lMeasure,
        /* [in] */  long	lBeat,
        /* [out] */ long*	plPosition);

	STDMETHODIMP StripInvalidateRect(
		/* [in] */ IDMUSProdStrip*	pIStrip,
		/* [in] */ RECT*			pRect,
		/* [in] */ BOOL				fErase);

	STDMETHODIMP SetPropertyPage(
		/* [in] */ IUnknown* punkPropPageMgr,
		/* [in] */ IUnknown* punkPropPageObj);

	STDMETHODIMP RemovePropertyPageObject(
		/* [in] */ IUnknown* punkPropPageObj );

    STDMETHODIMP StripSetTimelineProperty( 
        /* [in] */ IDMUSProdStrip* punkStrip,
        /* [in] */ STRIP_TIMELINE_PROPERTY stp,
        /* [in] */ VARIANT variant);

	STDMETHODIMP OnDataChanged(
		/* [in] */ IUnknown* punk);

	STDMETHODIMP TrackPopupMenu(
		/* [in] */ HMENU			hMenu,
		/* [in] */ long				lXpos,
		/* [in] */ long				lYpos,
		/* [in] */ IDMUSProdStrip*	pIstrip,
		/* [in] */ BOOL				bEditMenu);
		
	STDMETHODIMP ClocksToRefTime(
		/* [in] */  long			lTime,
		/* [out] */ REFERENCE_TIME*	pRefTime);
	
	STDMETHODIMP PositionToRefTime(
		/* [in] */  long			lPosition,
		/* [out] */ REFERENCE_TIME*	pRefTime);
	
	STDMETHODIMP MeasureBeatToRefTime(
		/* [in] */  DWORD			dwGroupBits,
		/* [in] */  DWORD			dwIndex,
		/* [in] */  long			lMeasure,
		/* [in] */  long			lBeat,
		/* [out] */ REFERENCE_TIME*	pRefTime);
	
	STDMETHODIMP RefTimeToClocks(
		/* [in] */  REFERENCE_TIME	RefTime,
		/* [out] */ long*			plTime);
	
	STDMETHODIMP RefTimeToPosition(
		/* [in] */  REFERENCE_TIME	RefTime,
		/* [out] */ long*			plPosition);
	
	STDMETHODIMP RefTimeToMeasureBeat(
		/* [in] */  DWORD			dwGroupBits,
		/* [in] */  DWORD			dwIndex,
		/* [in] */  REFERENCE_TIME	RefTime,
		/* [out] */ long*			plMeasure,
		/* [out] */ long*			plBeat);

	STDMETHODIMP ScreenToStripPosition(
		/* [in] */  IDMUSProdStrip*	pIStrip,
		/* [in] [out] */ POINT*	pPoint);

	STDMETHODIMP StripGetTimelineProperty(
		/* [in] */	IDMUSProdStrip*	pIStrip,
		/* [in] */	STRIP_TIMELINE_PROPERTY stp,
		/* [out] */	VARIANT*	pvar);

	STDMETHODIMP RemoveStripMgr(
		/* [in] */	IDMUSProdStripMgr* pIStripMgr);

	STDMETHODIMP RemoveStrip(
		/* [in] */	IDMUSProdStrip* pIStrip);

	STDMETHODIMP GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */  DWORD		dwIndex,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);

	STDMETHODIMP SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ DWORD		dwGroupBits,
		/* [in] */ DWORD		dwIndex,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);

	STDMETHODIMP GetStripMgr(
		/* [in] */ REFGUID				guidType,
		/* [in] */ DWORD				dwGroupBits,
		/* [in] */ DWORD				dwIndex,
		/* [out,retval] */ IDMUSProdStripMgr**	ppStripMgr);

	STDMETHODIMP InsertStripAtDefaultPos(
		/* [in] */  IDMUSProdStrip*	pStrip,
		/* [in] */  REFCLSID		clsidType,
		/* [in] */  DWORD			dwGroupBits,
		/* [in] */  DWORD			dwIndex);

	STDMETHODIMP EnumStrip(
		/* [in] */  DWORD				dwEnum,
		/* [in] */  IDMUSProdStrip**	ppStrip);

	STDMETHODIMP InsertStripAtPos(
		/* [in] */  IDMUSProdStrip*		pStrip,
		/* [in] */  DWORD				dwPosition);

	STDMETHODIMP StripToWindowPos(
		/* [in] */  IDMUSProdStrip*		pStrip,
		/* [in,out] */ POINT*			pPoint);

	STDMETHODIMP AddToNotifyList(
		/* [in] */  IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */  REFGUID				rguidType,
		/* [in] */  DWORD				dwGroupBits);

	STDMETHODIMP RemoveFromNotifyList(
		/* [in] */  IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */  REFGUID				rguidType,
		/* [in] */  DWORD				dwGroupBits);

	STDMETHODIMP NotifyStripMgrs(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */  void*		pData);

	STDMETHODIMP AllocTimelineDataObject(
		/* [out,retval] */ IDMUSProdTimelineDataObject**	ppITimelineDataObject );

	STDMETHODIMP GetPasteType(
		/* [out,retval] */ TIMELINE_PASTE_TYPE*	ptlptPasteType );

	STDMETHODIMP SetPasteType(
		/* [in] */ TIMELINE_PASTE_TYPE tlptPasteType );

// IDMUSProdPrivateTimelineCtl functions
public:
	STDMETHODIMP SetTimelineOleCtl( IUnknown *punkTimelineOleCtl );
    STDMETHODIMP FinalCleanUp();

// private member variables
private:
	IDMUSProdFramework* m_pDMUSProdFramework;	// framework pointer set by SetTimelineProperty
	IDMUSProdTimelineCallback*	m_pTimelineCallback; // set by the component, this is an interface on the component
	StripMgrList*	m_pStripMgrList; // list of strip managers
	StripList*		m_pStripList;	// list of strips
	long			m_lLength;  // length of piece (zero is infinite length). In clocks for now.
	long			m_lXScrollPos;
	long			m_lYScrollPos;
	long			m_lFunctionBarWidth; // includes borders
	double			m_dblZoom; // zoom factor
	const StripList*m_pActiveStripList; // the currently active strip
	BOOL			m_fFreezeUndo; // true when a strip wants to prevent undo entries from being created
	BOOL			m_fMusicTime; // true when we're displaying in Music time.
	IDMUSProdTempoMapMgr* m_pTempoMapMgr;	// Pointer to the tempo-map manager, if there is one
	double			m_dblRefTimeConv; // number used to convert from RefTime to position
    CTypedPtrList<CPtrList, NotifyEntry*> m_lstNotifyEntry;
	TIMELINE_PASTE_TYPE m_ptPasteType;
	CRITICAL_SECTION m_csOnDataChanged;
	CTimeStrip*		m_pTimeStrip;
	CTimelineCtl	*m_pTimelineCtl;
	IDirectMusicPerformance* m_pIDMPerformance;
	bool			m_fInSetTimelineOleCtl;

// protected member methods
protected:
	long TotalStripHeight(void) const;
	void ActivateStripList( const StripList* pSL );
	void DeactivateStripList( void );
	void CallStripWMMessage( const StripList* pSL, UINT nMsg, WPARAM wParam, LPARAM lParam );
	StripList* FindStripList(IDMUSProdStrip*) const;
	HRESULT StripPointToClient( const StripList* pSL, POINT *pPoint) const;
	HRESULT StripRectToClient( const StripList* pSL, LPRECT pRect) const;
	HRESULT InternalInsertStripAtPos( IDMUSProdStrip* pStrip, DWORD dwPosition, REFCLSID clsidType, DWORD dwGroupBits, DWORD dwIndex );
	bool AnyGutterSelectedStrips( void ) const;
	bool ComputeEarlyAndLateTime( long &lEarlyTime, long &lLateTime ) const;
};

#endif //__PRIVATETIMELINECTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\ContextMenuHandler.h ===
#if !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
#define AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ContextMenuHandler.h : header file
//

#include "timeline.h"

class CTimelineCtl;

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler window

class CContextMenuHandler : public CWnd
{
// Construction
public:
	CContextMenuHandler();

// Attributes
public:

	IDMUSProdStrip	*m_pStrip;
	HWND			 m_hwndDeleteTracks;
	CTimelineCtl	*m_pTimeline;
	BOOL			 m_fCustomMenu;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContextMenuHandler)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CContextMenuHandler();

	// Generated message map functions
protected:
	//{{AFX_MSG(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Timeline.rc
//
#define IDS_PROJNAME                    100
#define IDS_DRAGBAR_FONTNAME            101
#define IDR_TIMELINECTL                 102
#define IDS_TOOLBAR_HELP                102
#define SB_HORIZONTAL                   103
#define IDR_TIMESTRIPMGR                104
#define BTN_ZOOMIN                      106
#define BTN_ZOOMOUT                     107
#define SB_VERTICAL                     108
#define BTN_REALTIME                    109
#define BTN_MUSICTIME                   110
#define IDC_RIGHTARROW                  201
#define IDR_EDIT_RMENU                  201
#define IDB_ZOOMIN                      207
#define IDB_ZOOMINDOWN                  208
#define IDB_ZOOMOUT                     209
#define IDB_ZOOMOUTDOWN                 210
#define IDB_REALTIME                    213
#define IDB_MUSICTIME                   214
#define IDB_MUSICTIMEDOWN               216
#define IDB_REALTIMEDOWN                217
#define IDR_REALTIME_MENU               219
#define IDB_MINIMIZE                    220
#define IDB_MINIMIZEDOWN                221
#define IDC_TIMELINE_CUT                32768
#define ID_VIEW_PROPERTIES              32768
#define IDC_TIMELINE_COPY               32769
#define IDC_TIMELINE_PASTE              32770
#define IDC_TIMELINE_SELECTALL          32771
#define ID_EDIT_DELETE                  32771
#define IDC_TIMELINE_INSERT             32772
#define ID_EDIT_INSERT                  32772
#define IDC_TIMELINE_DELETE             32773
#define IDC_TIMELINE_PROPERTIES         32774
#define ID_RT_SECONDS                   32782
#define ID_RT_MEASURES                  32783
#define ID_RT_BEATS                     32784
#define ID_REALTIME_CONST               32785
#define ID_CONST_MUSICTIME              32786
#define IDS_ELAPSED_TIME                32787
#define IDS_OFFSET_TIME                 32788
#define ID_CONST_REALTIME               32789
#define IDS_UNDO_DELETE_DATA            32789
#define ID_SNAP_NONE                    32790
#define IDS_UNDO_CUT_DATA               32790
#define ID_SNAP_GRID                    32791
#define IDS_UNDO_PASTE_DATA             32791
#define ID_SNAP_BEAT                    32792
#define IDS_ZOOM_IN_KEYS                32792
#define ID_SNAP_BAR                     32793
#define IDS_ZOOM_OUT_KEYS               32793
#define IDS_ELAPSED_NEG_TIME            32794
#define IDS_OFFSET_NEG_TIME             32795
#define ID_EDIT_PASTE_INSERT            32796
#define ID_EDIT_PASTE_MERGE             32797
#define ID_EDIT_PASTE_OVERWRITE         32798
#define ID_EDIT_HORIZZOOMIN             32800
#define ID_EDIT_HORIZZOOMOUT            32801
#define ID_EDIT_DELETE_TRACK            32900
#define ID_EDIT_ADD_TRACK               32901

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        222
#define _APS_NEXT_COMMAND_VALUE         32802
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           113
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TempoMapMgr.cpp ===
// TempoMapMgr.cpp : Implementation of CTempoMapMgr
#include "stdafx.h"
#include "Timeline.h"
#include "TempoMapMgr.h"
#include <dmusici.h>

/////////////////////////////////////////////////////////////////////////////
// CTempoMapMgr

HRESULT CTempoMapMgr::ClocksToRefTime(
				/*[in]*/  long		time,
				/*[out]*/ REFERENCE_TIME	*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (NULL == pRefTime)
	{
		return E_POINTER;
	}
	*pRefTime = time * REFCLOCKS_PER_MINUTE;
	*pRefTime /= m_lTempo * DMUS_PPQ;
	return S_OK;
}

HRESULT CTempoMapMgr::MeasureBeatToRefTime(
				/*[in]*/  DWORD		dwGroupBits,
				/*[in]*/  DWORD		dwIndex,
				/*[in]*/  long		iMeasure,
				/*[in]*/  long		iBeat,
				/*[out]*/ REFERENCE_TIME	*pRefTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (NULL == pRefTime)
	{
		return E_POINTER;
	}
	if (NULL == m_pTimelineCtl)
	{
		return E_FAIL;
	}

	long lClocks;
	m_pTimelineCtl->MeasureBeatToClocks( dwGroupBits, dwIndex, iMeasure, iBeat, &lClocks );
	ClocksToRefTime( lClocks, pRefTime);
	return S_OK;
}

HRESULT CTempoMapMgr::RefTimeToClocks(
				/*[in]*/  REFERENCE_TIME	RefTime,
				/*[out]*/ long		*pTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (NULL == pTime)
	{
		return E_POINTER;
	}
	REFERENCE_TIME rTmp = RefTime * m_lTempo * DMUS_PPQ;
	rTmp /= REFCLOCKS_PER_MINUTE;
	*pTime = (long) rTmp;
	return S_OK;
}							 

HRESULT CTempoMapMgr::RefTimeToMeasureBeat(
				/*[in]*/  DWORD		dwGroupBits,
				/*[in]*/  DWORD		dwIndex,
				/*[in]*/  REFERENCE_TIME	RefTime,
				/*[out]*/ long		*piMeasure,
				/*[out]*/ long		*piBeat)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if ((NULL == piMeasure)||(NULL == piBeat))
	{
		return E_POINTER;
	}
	if (NULL == m_pTimelineCtl)
	{
		return E_FAIL;
	}

	long lClocks;
	RefTimeToClocks( RefTime, &lClocks);
	m_pTimelineCtl->ClocksToMeasureBeat( dwGroupBits, dwIndex, lClocks, piMeasure, piBeat);
	return S_OK;
}

HRESULT CTempoMapMgr::RefTimeToTempo(
				/*[in]*/  REFERENCE_TIME	RefTime,
				/*[out]*/ long		*plTempo)
{
	UNREFERENCED_PARAMETER( RefTime );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (NULL == plTempo)
	{
		return E_POINTER;
	}
	*plTempo = m_lTempo;
	return S_OK;
}

HRESULT CTempoMapMgr::ClocksToTempo(
				/*[in]*/  long		time,
				/*[out]*/ long		*plTempo)
{
	UNREFERENCED_PARAMETER( time );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (NULL == plTempo)
	{
		return E_POINTER;
	}
	*plTempo = m_lTempo;
	return S_OK;
}

HRESULT CTempoMapMgr::MeasureBeatToTempo(
				/*[in]*/  DWORD		dwGroupBits,
				/*[in]*/  DWORD		dwIndex,
				/*[in]*/  long		iMeasure,
				/*[in]*/  long		iBeat,
				/*[out]*/ long		*plTempo)
{
	UNREFERENCED_PARAMETER( dwGroupBits );
	UNREFERENCED_PARAMETER( dwIndex );
	UNREFERENCED_PARAMETER( iMeasure );
	UNREFERENCED_PARAMETER( iBeat );
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (NULL == plTempo)
	{
		return E_POINTER;
	}
	*plTempo = m_lTempo;
	return S_OK;
}

HRESULT CTempoMapMgr::SetTempo(
				/*[in]*/  long		lTempo)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_lTempo = lTempo;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TempoMapMgr.h ===
// TempoMapMgr.h : Declaration of the CTempoMapMgr

#ifndef __TEMPOMAPMGR_H_
#define __TEMPOMAPMGR_H_

#ifndef REFCLOCKS_PER_MINUTE
#define REFCLOCKS_PER_MINUTE 600000000
#endif

/////////////////////////////////////////////////////////////////////////////
// CTempoMapMgr
class ATL_NO_VTABLE CTempoMapMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTempoMapMgr, &CLSID_TempoMapMgr>,
	public IDMUSProdTempoMapMgr
{
public:
	CTempoMapMgr()
	{
		m_lTempo = 120;
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_TIMESTRIPMGR)

BEGIN_COM_MAP(CTempoMapMgr)
	COM_INTERFACE_ENTRY(IDMUSProdTempoMapMgr)
END_COM_MAP()


	STDMETHODIMP ClocksToRefTime(
		/*[in]*/  long		time,
		/*[out]*/ REFERENCE_TIME		*pRefTime
		);

	STDMETHODIMP MeasureBeatToRefTime(
		/*[in]*/  DWORD		dwGroupBits,
		/*[in]*/  DWORD		dwIndex,
		/*[in]*/  long		iMeasure,
		/*[in]*/  long		iBeat,
		/*[out]*/ REFERENCE_TIME	*pRefTime
		);

	STDMETHODIMP RefTimeToClocks(
		/*[in]*/  REFERENCE_TIME	RefTime,
		/*[out]*/ long		*pTime
		);
	
	STDMETHODIMP RefTimeToMeasureBeat(
		/*[in]*/  DWORD		dwGroupBits,
		/*[in]*/  DWORD		dwIndex,
		/*[in]*/  REFERENCE_TIME	RefTime,
		/*[out]*/ long		*piMeasure,
		/*[out]*/ long		*piBeat
		);
	
	STDMETHODIMP RefTimeToTempo(
		/*[in]*/  REFERENCE_TIME	RefTime,
		/*[out]*/ long		*piTempo
		);
	
	STDMETHODIMP ClocksToTempo(
		/*[in]*/  long		time,
		/*[out]*/ long		*piTempo
		);
	
	STDMETHODIMP MeasureBeatToTempo(
		/*[in]*/  DWORD		dwGroupBits,
		/*[in]*/  DWORD		dwIndex,
		/*[in]*/  long		iMeasure,
		/*[in]*/  long		iBeat,
		/*[out]*/ long		*piTempo
		);
	
	STDMETHODIMP SetTempo(
		/*[in]*/  long		iTempo
		);

private:
	long				m_lTempo;	// Tempo in Beats per Minute
	IDMUSProdTimeline*	m_pTimelineCtl;
};

#endif //__TEMPOMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__934F7274_B521_11D0_A980_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__934F7274_B521_11D0_A980_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__934F7274_B521_11D0_A980_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\Timeline.cpp ===
// Timeline.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Timelineps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Timeline.h"

#include "TimelineCtl.h"
#include "TimeStripMgr.h"
#include "AFXCTL.H"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TimelineCtl, CTimelineCtl)
	OBJECT_ENTRY(CLSID_TimeStripMgr, CTimeStripMgr)
END_OBJECT_MAP()

class CTimelineApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CTimelineApp theApp;

BOOL CTimelineApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CTimelineApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	AfxOleUnregisterTypeLib( LIBID_TIMELINELib );
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimelineDataObject.h ===
#if !defined(AFX_TIMELINEDATAOBJECT_H__6442911A_2AFC_11D2_88F9_00C04FBF8D15__INCLUDED_)
#define AFX_TIMELINEDATAOBJECT_H__6442911A_2AFC_11D2_88F9_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TimelineDataObject.h : header file
//

#include "timeline.h"
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )

interface IStream;
interface IDMUSProdRIFFStream;

/////////////////////////////////////////////////////////////////////////////
// CClipboardStorage class

class CClipboardStorage
{
public:
	CClipboardStorage( UINT cfClipboardFormat, IStream* pStream )
	{
		ASSERT( pStream );
		m_pIStream = pStream;
		m_pIStream->AddRef();
		m_cfClipboardFormat = cfClipboardFormat;
	};

	virtual ~CClipboardStorage()
	{
		if( m_pIStream )
		{
			m_pIStream->Release();
		}
	}

	UINT		m_cfClipboardFormat;
	IStream*	m_pIStream;
};

/////////////////////////////////////////////////////////////////////////////
// CTimelineDataObject class

class CTimelineDataObject : public IDMUSProdTimelineDataObject
{
public:
	CTimelineDataObject();
	virtual ~CTimelineDataObject();

// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDMUSProdTimelineDataObject implementation
	STDMETHODIMP AddInternalClipFormat(
		/* [in] */ UINT				uClipFormat,
		/* [in] */ IStream*			pIStream );

	STDMETHODIMP AddExternalClipFormat(
		/* [in] */ UINT				uClipFormat,
		/* [in] */ IStream*			pIStream );

	STDMETHODIMP	IsClipFormatAvailable(
		/* [in] */ UINT				uClipFormat );

	STDMETHODIMP	AttemptRead(
		/* [in] */ UINT				uClipFormat,
		/* [out,retval] */ IStream**ppIStream );

	STDMETHODIMP GetBoundaries(
		/* [out] */ long*			plStartTime,
		/* [out] */ long*			plEndTime );

	STDMETHODIMP SetBoundaries(
		/* [in] */ long				lStartTime,
		/* [in] */ long				lEndTime );

	STDMETHODIMP Import(
		/* [in] */ IDataObject*		pIDataObject );

	STDMETHODIMP Export(
		/* [out,retval] */ IDataObject**ppIDataObject );

// Attributes
public:

// Protected operations
protected:
	CClipboardStorage*	FindClipboardStorage( UINT uClipFormat );
	HRESULT GetInternalListAsStream( IStream** ppIStream );
	HRESULT SaveBoundaries( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveInternalList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT LoadInternalListFromStream( IStream* pIStream );
	HRESULT BuildInternalList( IStream* pStream, IDMUSProdRIFFStream *pIRiffStream, MMCKINFO& ckParent );
	HRESULT ExtractItem( IStream* pStream, IDMUSProdRIFFStream *pIRiffStream, MMCKINFO& ckParent );


// Data
protected:
	long			m_cRef;

	CTypedPtrList<CPtrList, CClipboardStorage*> m_lstInternalClipboard;
	CTypedPtrList<CPtrList, CClipboardStorage*> m_lstExternalClipboard;

	CTypedPtrList<CPtrList, CClipboardStorage*> m_lstUsedInternalClipboard;
	CTypedPtrList<CPtrList, CClipboardStorage*> m_lstUsedExternalClipboard;

	long			m_lEnd;
	long			m_lStart;

	UINT			m_cfTimeline;
};

#endif // !defined(AFX_TIMELINEDATAOBJECT_H__6442911A_2AFC_11D2_88F9_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimelineDataObject.cpp ===
// TimelineDataObject.cpp : implementation file
//
// @doc Timeline

#include "stdafx.h"
#include "timeline.h"
#include "TimelineDataObject.h"
#include "DllJazzDataObject.h"
#include <RiffStrm.h>

/*  --------------------------------------------------------------------------
	@interface IDMUSProdTimelineDataObject | Wrapper interface for data stored on the clipboard.

	@meth HRESULT | AddInternalClipFormat | Adds a stream to the clipboard for use by other DirectMusic Producer components.

	@meth HRESULT | AddExternalClipFormat | Adds a stream to the clipboard for use by other applications.

	@meth HRESULT | IsClipFormatAvailable | Checks for data in a specified clipboard format in this object.

	@meth HRESULT | AttemptRead | Tries to read a stream for a specified clipboard format.

	@meth HRESULT | GetBoundaries | Get the boundaries of the data in this object.

	@meth HRESULT | SetBoundaries | Set the boundaries of the data in this object.

	@meth HRESULT | Import | Import the data from an <i IDataObject> into this object.

	@meth HRESULT | Export | Export the data from this object into an <i IDataObject>.

	@base public | IUnknown

	@xref	<i IDMUSProdTimeline>
	--------------------------------------------------------------------------*/

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTimelineDataObject

CTimelineDataObject::CTimelineDataObject()
{
	_Module.Lock();
	m_cRef = 0;
	AddRef();
	m_lStart = -1;
	m_lEnd = -1;
	m_cfTimeline = 0;
}

CTimelineDataObject::~CTimelineDataObject()
{
	CClipboardStorage *pStorage;

	while( !m_lstInternalClipboard.IsEmpty() )
	{
		pStorage = m_lstInternalClipboard.RemoveHead();
		delete pStorage;
	}

	while( !m_lstExternalClipboard.IsEmpty() )
	{
		pStorage = m_lstExternalClipboard.RemoveHead();
		delete pStorage;
	}

	while( !m_lstUsedInternalClipboard.IsEmpty() )
	{
		pStorage = m_lstUsedInternalClipboard.RemoveHead();
		delete pStorage;
	}

	while( !m_lstUsedExternalClipboard.IsEmpty() )
	{
		pStorage = m_lstUsedExternalClipboard.RemoveHead();
		delete pStorage;
	}
	_Module.Unlock();
}


/////////////////////////////////////////////////////////////////////////////
// CTimelineDataObject

/////////////////////////////////////////////////////////////////////////////
// CTimelineDataObject IUnknown
STDMETHODIMP CTimelineDataObject::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppvObj == NULL )
	{
		return E_POINTER;
	}

    if( ::IsEqualIID(riid, IID_IDMUSProdTimelineDataObject)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdTimelineDataObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTimelineDataObject::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CTimelineDataObject::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


//  @method HRESULT | IDMUSProdTimelineDataObject | AddInternalClipFormat | This method adds the specified
//		<p pIStream> with the format <p uClipFormat> to the internal list of streams stored
//		in this TimelineDataObject.  The stream will be unavailable to other applications.
//
//  @parm	UINT | uClipFormat | The clipboard format of the stream
//  @parm   IStream* | pIStream | The stream containing data
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStream>
//	@rvalue E_OUTOFMEMORY | Unable to allocate memory while adding the stream
//
//	@xref	<om IDMUSProdTimelineDataObject::AddExternalClipFormat> <i IDMUSProdTimelineDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject>
HRESULT CTimelineDataObject::AddInternalClipFormat( UINT uClipFormat, IStream* pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate pIStream
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	CClipboardStorage* pStorage = NULL;
	try
	{
		// Create an object to store the stream and clipboard format
		pStorage = new CClipboardStorage( uClipFormat, pIStream );
		
		// Add it to our internal list
		m_lstInternalClipboard.AddTail( pStorage );
	}
	catch ( CMemoryException* pMemoryException )
	{
		// Catch out of memory errors
		pMemoryException->Delete();

		// This will be true if AddTail ran out of memory
		if( pStorage )
		{
			delete pStorage;
		}

		return E_OUTOFMEMORY;
	}

	// Succeeded
	return S_OK;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | AddExternalClipFormat | This method adds the specified
//		<p pIStream> with the format <p uClipFormat> to the list of streams stored in this
//		TimelineDataObject.  The stream will be available to other applications that support
//		<p uClipFormat>.
//
//  @parm	UINT | uClipFormat | The clipboard format of the stream
//  @parm   IStream* | pIStream | The stream containing data
//
//  @rvalue S_OK | The operation was successful
//  @rvalue E_POINTER | NULL was passed as <p pIStream>
//	@rvalue E_UNEXPECTED | An unexpected error occurred
//	@rvalue E_OUTOFMEMORY | Unable to allocate memory while adding the stream
//
//	@xref	<om IDMUSProdTimelineDataObject::AddInternalClipFormat> <i IDMUSProdTimelineDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject>
HRESULT CTimelineDataObject::AddExternalClipFormat( UINT uClipFormat, IStream* pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate pIStream
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	CClipboardStorage* pStorage = NULL;
	try
	{
		// Create an object to store the stream and clipboard format
		pStorage = new CClipboardStorage( uClipFormat, pIStream );
		
		// Add it to our external list
		m_lstExternalClipboard.AddTail( pStorage );
	}
	catch ( CMemoryException* pMemoryException )
	{
		// Catch out of memory errors
		pMemoryException->Delete();

		// This will be true if AddTail ran out of memory
		if( pStorage )
		{
			delete pStorage;
		}

		return E_OUTOFMEMORY;
	}

	// Succeeded
	return S_OK;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | IsClipFormatAvailable | This method searches the list
//		of internal and external clipboard formats available, and returns S_OK if it finds
//		<p uClipFormat>.  S_FALSE is returned if <p uClipFormat> is not found.
//
//  @parm	UINT | uClipFormat | The clipboard format to search for
//
//  @rvalue S_OK | The clipboard format is available.
//	@rvalue S_FALSE | The clipboard format is not available
//
//	@xref	<om IDMUSProdTimelineDataObject::AttemptRead> <i IDMUSProdTimelineDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject>
HRESULT CTimelineDataObject::IsClipFormatAvailable( UINT uClipFormat )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( FindClipboardStorage( uClipFormat ) != NULL )
	{
		return S_OK;
	}

	return S_FALSE;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | AttemptRead | This method searches the list
//		of internal and external clipboard formats available, and if a match is found it fills
//		<p ppIStream> with a pointer to the stream containing the data.
//
//  @parm	UINT | uClipFormat | The clipboard format to search for
//  @parm	IStream | ppIStream | A pointer to the location to store a pointer to the stream
//		containing the data.
//
//	@comm	A subsequence call to this method with the same <p uClipFormat> will return a different
//		stream pointer, if one is availabe.  This allows multiple strips of the same type to be copied
//		and pasted without losing data.
//
//  @rvalue S_OK | The clipboard format is available. <p ppIStream> contains a pointer to the
//		stream containing the data.
//	@rvalue E_INVALIDARG | The clipboard format was not found.
//	@rvalue E_POINTER | <p ppIStream> is NULL.
//
//	@xref	<om IDMUSProdTimelineDataObject::IsClipFormatAvailable> <i IDMUSProdTimelineDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject>
HRESULT CTimelineDataObject::AttemptRead( UINT uClipFormat, IStream** ppIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIStream == NULL )
	{
		return E_POINTER;
	}


	// Search our internal list
	CClipboardStorage *pClipboardStorage;
	pClipboardStorage = FindClipboardStorage( uClipFormat );

	// If found, set ppIStream to the stream
	if( pClipboardStorage )
	{
		pClipboardStorage->m_pIStream->Clone( ppIStream );
		// Reset the stream pointer to the beginning
		LARGE_INTEGER li;
		li.QuadPart = 0;
		(*ppIStream)->Seek( li, STREAM_SEEK_SET, NULL );

		// Now, remove this item from the main lists and add it to
		// the Used list
		POSITION pos;
		pos = m_lstInternalClipboard.Find( pClipboardStorage );
		if( pos )
		{
			m_lstInternalClipboard.RemoveAt( pos );
			m_lstUsedInternalClipboard.AddTail( pClipboardStorage );
		}
		else
		{
			pos = m_lstExternalClipboard.Find( pClipboardStorage );
			ASSERT( pos );
			m_lstExternalClipboard.RemoveAt( pos );
			m_lstUsedExternalClipboard.AddTail( pClipboardStorage );
		}
		return S_OK;
	}

	return E_INVALIDARG;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | GetBoundaries | This method returns the
//		start and edit times of the selection that was pasted to the clipboard.
//
//	@comm	These boundaries are only available if a <i IDMUSProdTimelineDataObject> was
//		pasted to the clipboard with valid boundaries.  Either <p plStartTime> or <p plEndTime>
//		may be NULL, but not both.
//
//  @parm	long | plStartTime | A pointer to the location to store the start time in.
//  @parm	long | plEndTime | A pointer to the location to store the end time in.
//
//  @rvalue S_OK | <p plStartTime> and/or <p plEndTime> were successfully set.
//	@rvalue E_PENDING | The start and end boundaries are not available (they are both internally set to -1).
//	@rvalue E_POINTER | Both <p plStartTime> and <p plEndTime> are NULL.
//
//	@xref	<i IDMUSProdTimelineDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject> <om IDMUSProdTimelineDataObject::SetBoundaries>
HRESULT CTimelineDataObject::GetBoundaries( long* plStartTime, long* plEndTime )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate plStartTime and plEndTime
	if( (plStartTime == NULL) && (plEndTime == NULL) )
	{
		return E_POINTER;
	}

	// Ensure the start and edit times were set
	if( (m_lEnd == -1)
	&&	(m_lStart == -1) )
	{
		return E_PENDING;
	}

	// Set plStartTime
	if( plStartTime )
	{
		*plStartTime = m_lStart;
	}

	// Set plEndTime
	if( plEndTime )
	{
		*plEndTime = m_lEnd;
	}

	return S_OK;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | SetBoundaries | This method sets the
//		boundaries to save to the clipboard and return with <om IDMUSProdTimelineDataObject::GetBoundaries>
//
//  @parm	long | lStartTime | The start time.
//  @parm	long | lEndTime | The end time.
//
//	@comm	If <p lStartTime> and <p lEndTime> are both -1, the TimelineDataObject will not persist
//		them to the clipboard, and <om IDMUSProdTimelineDataObject::GetBoundaries> will return
//		E_PENDING.
//
//  @rvalue S_OK | The start and end time were successfully set.
//
//	@xref	<i IDMUSProdTimelineDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject> <om IDMUSProdTimelineDataObject::GetBoundaries>
HRESULT CTimelineDataObject::SetBoundaries( long lStartTime, long lEndTime )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_lStart = lStartTime;
	m_lEnd = lEndTime;

	return S_OK;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | Import | This method imports the clipboard
//		data formats from an IDataObject and makes them accessable from the methods of
//		<i IDMUSProdTimelineDataObject>
//
//  @parm	IDataObject | pIDataObject | A pointer to <i IDataObject> to import.
//
//  @rvalue S_OK | <p pIDataObject> was successfully imported.
//	@rvalue E_FAIL | An error occurred.
//	@rvalue E_POINTER | <p pIDataObject> is NULL.
//
//	@xref	<i IDMUSProdTimelineDataObject> <i IDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject> <om IDMUSProdTimelineDataObject::Import>
HRESULT CTimelineDataObject::Import( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Register our clipboard format if we haven't done so already
	if( m_cfTimeline == 0 )
	{
		m_cfTimeline = RegisterClipboardFormat( CF_TIMELINE );
		if( m_cfTimeline == 0 )
		{
			return E_FAIL;
		}
	}

	// Initialize variables
	IEnumFORMATETC *pIEnumFORMATETC;
	FORMATETC formatEtc;
	ULONG ulElem;
	HRESULT hr;
	CDllJazzDataObject *pDllJazzDataObject = new CDllJazzDataObject;

	// Get IEnumFORMATETC interface
	hr = pIDataObject->EnumFormatEtc( DATADIR_GET, &pIEnumFORMATETC );
	ASSERT( hr == S_OK );
	if ( hr != S_OK )
	{
		pDllJazzDataObject->Release();
		return E_FAIL;
	}

	// Reset the enumeration counter
	pIEnumFORMATETC->Reset();

	// Iterate through all formats
	while ( pIEnumFORMATETC->Next( 1, &formatEtc, &ulElem ) == S_OK)
	{
		// Get the IStream
		IStream	*pIStream;
		hr = pDllJazzDataObject->AttemptRead( pIDataObject, formatEtc.cfFormat, &pIStream);
		if ( SUCCEEDED( hr ) )
		{
			// Seek to the beginning of the stream
			LARGE_INTEGER liStreamPos;
			liStreamPos.QuadPart = 0;
			hr = pIStream->Seek( liStreamPos, STREAM_SEEK_SET, NULL );
			ASSERT( SUCCEEDED( hr ));

			// Check for timeline format
			if( formatEtc.cfFormat == m_cfTimeline )
			{
				LoadInternalListFromStream( pIStream );
			}
			// Add it to our external list
			else
			{
				CClipboardStorage *pStorage;
				pStorage = new CClipboardStorage( formatEtc.cfFormat, pIStream ); 
				m_lstExternalClipboard.AddTail( pStorage );
			}
			pIStream->Release();
		}
	}

	// Clean up
	pIEnumFORMATETC->Release();
	pDllJazzDataObject->Release();

	return S_OK;
}


//  @method HRESULT | IDMUSProdTimelineDataObject | Export | This method exports the clipboard
//		data formats stored in this <i ITimleineDataObject> and creates an IDataObject
//		that can be subsequently added to the clipboard.
//
//  @parm	IDataObject | ppIDataObject | A pointer location to store the pointer to the new <i IDataObject>.
//
//  @rvalue S_OK | <p ppIDataObject> was successfully exported.
//	@rvalue E_UNEXPECTED | We failed to register the Timeline's clipboard format.
//	@rvalue E_POINTER | <p ppIDataObject> is NULL.
//
//	@xref	<i IDMUSProdTimelineDataObject> <i IDataObject> <om IDMUSProdTimeline::AllocTimelineDataObject> <om IDMUSProdTimelineDataObject::Import>
HRESULT CTimelineDataObject::Export( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	// Initialize variables
	HRESULT hr = S_OK;
	*ppIDataObject = NULL;

	// Create a DllJazzDataObject
	CDllJazzDataObject*	pDllJazzDataObject = NULL;
	pDllJazzDataObject = new CDllJazzDataObject;

	// Need to keep Timeline.DLL around forever, so that OLE can use this clipboard object
	// BUGBUG: Need to fix this in DX8.1
	_Module.Lock();

	// If boundaries are set, or if there are any internal clipboard items,
	// add a CF_TIMELINE object to the clipboard
	if( (m_lEnd != -1) || (m_lStart != -1) || !m_lstInternalClipboard.IsEmpty() )
	{
		// Register our clipboard format if we haven't done so already
		if( m_cfTimeline == 0 )
		{
			m_cfTimeline = RegisterClipboardFormat( CF_TIMELINE );
			if( m_cfTimeline == 0 )
			{
				hr = E_UNEXPECTED;
				goto ON_ERROR;
			}
		}

		// Get our stream and add it to the clipboard
		IStream *pIStream;
		if( SUCCEEDED( GetInternalListAsStream( &pIStream ) ) )
		{
			pDllJazzDataObject->AddClipFormat( m_cfTimeline, pIStream );
			pIStream->Release();
		}
	}

	// Add all the external clipboard streams
	if( !m_lstExternalClipboard.IsEmpty() )
	{
		CClipboardStorage *pStorage;
		POSITION pos;
		pos = m_lstExternalClipboard.GetHeadPosition();
		while( pos )
		{
			pStorage = m_lstExternalClipboard.GetNext( pos );
			pDllJazzDataObject->AddClipFormat( pStorage->m_cfClipboardFormat, pStorage->m_pIStream );
		}
	}

	// QI for an IDataObject interface to return
	hr = pDllJazzDataObject->QueryInterface(IID_IDataObject, (void**) ppIDataObject);

ON_ERROR:
	// Clean up and return
	pDllJazzDataObject->Release();
	return hr;
}

CClipboardStorage* CTimelineDataObject::FindClipboardStorage( UINT uClipFormat )
{
	POSITION pos;
	CClipboardStorage *pClipboardStorage;

	// Search our internal list
	pos = m_lstInternalClipboard.GetHeadPosition();
	while ( pos != NULL )
	{
		pClipboardStorage = m_lstInternalClipboard.GetNext( pos );
		if( pClipboardStorage->m_cfClipboardFormat == uClipFormat )
		{
			return pClipboardStorage;
		}
	}

	// Search our external list
	pos = m_lstExternalClipboard.GetHeadPosition();
	while ( pos != NULL )
	{
		pClipboardStorage = m_lstExternalClipboard.GetNext( pos );
		if( pClipboardStorage->m_cfClipboardFormat == uClipFormat )
		{
			return pClipboardStorage;
		}
	}

	return NULL;
}

HRESULT CTimelineDataObject::GetInternalListAsStream( IStream** ppIStream )
{
	// Validate and initialize ppIStream
	ASSERT( ppIStream );
	*ppIStream = NULL;

	// Create a new stream
	IStream* pIStream;
	if( FAILED( CreateStreamOnHGlobal( NULL, TRUE, &pIStream ) ) )
	{
		return E_UNEXPECTED;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		pIStream->Release();
		return hr;
	}

	// If the start and end times are set, save them
	if ( (m_lStart != -1)
	||	 (m_lEnd != -1) )
	{
		if( FAILED( SaveBoundaries( pIRiffStream ) ) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// If the internal list is non-empty, save it
	if ( !m_lstInternalClipboard.IsEmpty() )
	{
		if( FAILED( SaveInternalList( pIRiffStream ) ) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Successful, set ppIStream
	*ppIStream = pIStream;
	(*ppIStream)->AddRef();

ON_ERROR:
	pIRiffStream->Release();
	pIStream->Release();

	return hr;
}

HRESULT CTimelineDataObject::SaveBoundaries( IDMUSProdRIFFStream* pIRiffStream )
{
	ASSERT( pIRiffStream );

	// Get the stream
	IStream* pIStream;
	pIStream = pIRiffStream->GetStream();

	// initialize variables
	HRESULT hr = S_OK;
	MMCKINFO ckMain;
	DWORD dwBytesWritten;

	// Create the chunk to store the Start and End data
	ckMain.ckid = FOURCC_TIMELINE_BOUNDARY;
	if( pIRiffStream->CreateChunk( &ckMain, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write the start time
	hr = pIStream->Write( &m_lStart, sizeof(long), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(long) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write the end time
	hr = pIStream->Write( &m_lEnd, sizeof(long), &dwBytesWritten );
	if( FAILED( hr ) || dwBytesWritten != sizeof(long) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Ascend out of the boundary chunk.
	pIRiffStream->Ascend( &ckMain, 0 );

ON_ERROR:
	pIStream->Release();

	return hr;
}

HRESULT CTimelineDataObject::SaveInternalList( IDMUSProdRIFFStream* pIRiffStream )
{
	ASSERT( pIRiffStream );

	// Get the stream
	IStream* pIStream;
	pIStream = pIRiffStream->GetStream();

	// initialize variables
	HRESULT hr = S_OK;
	MMCKINFO ckMain, ckList, ckSubChunk;
	DWORD dwBytesWritten;

	// Create the list to store the clipboard data
	ckMain.fccType = FOURCC_TIMELINE_LIST;
	if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Iterate through the list of CClipboardStorage objects
	CClipboardStorage *pStorage;
	POSITION pos;
	pos = m_lstInternalClipboard.GetHeadPosition();
	while( pos )
	{
		pStorage = m_lstInternalClipboard.GetNext( pos );

		TCHAR tcstr[MAX_PATH];
		long lCharCount;
		lCharCount = GetClipboardFormatName( pStorage->m_cfClipboardFormat, tcstr, MAX_PATH );
		if( lCharCount > 0 )
		{
			// Create the list to store this clipboard data
			ckList.fccType = FOURCC_TIMELINE_CLIPBOARD;
			if( pIRiffStream->CreateChunk( &ckList, MMIO_CREATELIST ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Create the chunk to store the clipboard format name
			ckSubChunk.ckid = FOURCC_TIMELINE_CLIP_NAME;
			if( pIRiffStream->CreateChunk( &ckSubChunk, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write the format's name
			hr = pIStream->Write( tcstr, sizeof(TCHAR) * lCharCount, &dwBytesWritten );
			if( FAILED( hr ) || dwBytesWritten != sizeof(TCHAR) * lCharCount )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Ascend out of the clipboard format name chunk.
			pIRiffStream->Ascend( &ckSubChunk, 0 );

			// Create the chunk to store the clipboard data
			ckSubChunk.ckid = FOURCC_TIMELINE_CLIP_DATA;
			if( pIRiffStream->CreateChunk( &ckSubChunk, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Get the size of the stream
			STATSTG stats;
			pStorage->m_pIStream->Stat( &stats, STATFLAG_NONAME );

			// Reset the stream pointer to the beginning
			LARGE_INTEGER li;
			li.QuadPart = 0;
			pStorage->m_pIStream->Seek( li, STREAM_SEEK_SET, NULL );

			// Copy the stream to the clipboard
			hr = pStorage->m_pIStream->CopyTo( pIStream, stats.cbSize, NULL, NULL );
			if( FAILED( hr ) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Ascend out of the clipboard data chunk.
			pIRiffStream->Ascend( &ckSubChunk, 0 );

			// Ascend out of the clipboard data list chunk.
			pIRiffStream->Ascend( &ckList, 0 );
		}
	}

	// Ascend out of the cipboard data list.
	pIRiffStream->Ascend( &ckMain, 0 );

ON_ERROR:
	pIStream->Release();

	return hr;
}


HRESULT CTimelineDataObject::LoadInternalListFromStream( IStream* pIStream )
{
	// Initialize variables
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = S_OK;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	DWORD cbRead;
	
	MMCKINFO ckMain;
	
	ckMain.ckid = 0;
	ckMain.fccType = 0;
		
	while( SUCCEEDED(hr) && (pIRiffStream->Descend(&ckMain, NULL, 0) == 0) )
	{
		switch(ckMain.ckid)
		{
			case FOURCC_TIMELINE_BOUNDARY:
				// Read the start time
				hr = pIStream->Read( &m_lStart, sizeof(long), &cbRead );
				if( SUCCEEDED( hr ) && (cbRead == sizeof(long)) )
				{
					// Read the end time
					hr = pIStream->Read( &m_lEnd, sizeof(long), &cbRead );
					if( FAILED( hr ) || (cbRead != sizeof(long)) )
					{
						hr = E_FAIL;
					}
				}
				break;
			case FOURCC_LIST:
				switch(ckMain.fccType)
				{
					case  FOURCC_TIMELINE_LIST:
						hr = BuildInternalList(pIStream, pIRiffStream, ckMain);
						break;

					default:
						break;
				}
			default:
				hr = E_UNEXPECTED;
				break;
		}

		if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckMain, 0) == 0)
		{
			ckMain.ckid = 0;
			ckMain.fccType = 0;
		}
	}

	pIRiffStream->Release();

	return hr;
}

HRESULT CTimelineDataObject::BuildInternalList(	IStream* pStream,
												IDMUSProdRIFFStream *pIRiffStream,
												MMCKINFO& ckParent )
{
	ASSERT(pIRiffStream);
	ASSERT(pStream);
	HRESULT hr = S_OK;

	MMCKINFO ckNext;
	ckNext.ckid = 0;
	ckNext.fccType = 0;

	while( SUCCEEDED(hr) && (pIRiffStream->Descend(&ckNext, &ckParent, 0) == 0) )
	{
		switch(ckNext.ckid)
		{
			case FOURCC_LIST :
				switch(ckNext.fccType)
				{
					case FOURCC_TIMELINE_CLIPBOARD:
						hr = ExtractItem(pStream, pIRiffStream, ckNext);
						break;
					
					default:
						break;

				}
				break;

			default:
				break;

		}
    
		if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
		{
			ckNext.ckid = 0;
			ckNext.fccType = 0;
		}
	}

	return hr;
}

HRESULT CTimelineDataObject::ExtractItem( IStream* pIStream, 
										  IDMUSProdRIFFStream *pIRiffStream, 
										  MMCKINFO& ckParent )
{
	ASSERT(pIRiffStream);
	ASSERT(pIStream);
	
	MMCKINFO ckNext;
	ckNext.ckid = 0;
	ckNext.fccType = 0;
	
	DWORD cbRead;    
	DWORD cbSize;
	TCHAR tcstr[MAX_PATH];
	HRESULT hr = S_OK;

	IStream *pIDataStream = NULL;
	UINT cfClipboardFormat = 0;

	while( SUCCEEDED(hr) && (pIRiffStream->Descend(&ckNext, &ckParent, 0) == 0) )
	{
		switch(ckNext.ckid)
		{
			case FOURCC_TIMELINE_CLIP_NAME:
				// Read the format's name
				cbSize = min( ckNext.cksize, MAX_PATH );
				memset( tcstr, 0, min( cbSize + 2, MAX_PATH * sizeof( TCHAR ) ) );
				hr = pIStream->Read( tcstr, cbSize, &cbRead );
				if( SUCCEEDED( hr ) && cbRead == cbSize )
				{
					cfClipboardFormat = RegisterClipboardFormat( tcstr );
				}
				else 
				{
					hr = E_FAIL;
				}
				break;

			case FOURCC_TIMELINE_CLIP_DATA:
				// Copy the stream to the local data stream
				hr = CreateStreamOnHGlobal( NULL, TRUE, &pIDataStream );
				if( SUCCEEDED( hr ) )
				{
					ULARGE_INTEGER ui;
					ui.QuadPart = ckNext.cksize;

					hr = pIStream->CopyTo( pIDataStream, ui, NULL, NULL );
				}
				break;

			default:
				break;
		}
		if( SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0 )
		{
			ckNext.ckid = 0;
			ckNext.fccType = 0;
		}
	}

	if( SUCCEEDED(hr) && cfClipboardFormat && pIDataStream )
	{
		CClipboardStorage *pStorage;
		pStorage = new CClipboardStorage( cfClipboardFormat, pIDataStream ); 
		m_lstInternalClipboard.AddTail( pStorage );
	}

	if( pIDataStream )
	{
		pIDataStream->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimelineCtl.h ===
#ifndef __TIMELINECTL_H_
#define __TIMELINECTL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TimelineCtl.h : Declaration of the CTimelineCtl

#include "resource.h"       // main symbols
#include "stripmgr.h"
#include "TimelineDraw.h"
#include <DMUSProd.h>
#include "ContextMenuHandler.h"
#include <afxext.h>
#include <afxtempl.h>
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )
#include "dmusici.h"
#include "dmusicf.h"

#ifndef REFCLOCKS_PER_MINUTE
#define REFCLOCKS_PER_MINUTE 600000000
#endif

interface IDirectMusicPerformance;

struct StripMgrList
{
	struct StripMgrList*	m_pNext;
	IDMUSProdStripMgr*		m_pStripMgr;
	DWORD					m_dwGroupBits;

	StripMgrList(IDMUSProdStripMgr* pStripMgr, DWORD dwGroupBits)
	{
		ASSERT( pStripMgr );
		m_pStripMgr = pStripMgr;
		pStripMgr->AddRef();
		m_pNext = NULL;
		m_dwGroupBits = dwGroupBits;
	};

	~StripMgrList()
	{
		ASSERT( m_pStripMgr );
		m_pStripMgr->Release();
	};
};
struct StripList
{
	struct StripList*	m_pNext;
	IDMUSProdStrip*		m_pStrip;
	long				m_lHeight;	// height of strip
	long				m_lVScroll; // amount of vertical scroll
	long				m_lRestoreHeight;	// height of strip to retore to when maximizing it
	STRIPVIEW			m_sv;
	BOOL				m_fSelected;
	DWORD				m_dwGroupBits;
	DWORD				m_dwIndex;
	CLSID				m_clsidType;

	StripList(IDMUSProdStrip* pStrip, REFCLSID clsidype)
	{
		ASSERT( pStrip );
		m_pStrip = pStrip;
		pStrip->AddRef();
		m_pNext = NULL;
		m_lHeight = 100;
		m_lVScroll = 0;
		m_lRestoreHeight = 100;
		m_sv = SV_NORMAL;
		m_fSelected = FALSE;
		m_dwGroupBits = 1;
		m_dwIndex = 0;
		memcpy( &m_clsidType, &clsidype, sizeof(GUID) );
	};

	~StripList()
	{
		ASSERT( m_pStrip );
		m_pStrip->Release();
	}
};

struct NotifyListEntry
{
	IDMUSProdStripMgr*	pIStripMgr;
	DWORD				dwGroupBits;
};

struct NotifyEntry
{
	NotifyEntry( IDMUSProdStripMgr* pIStripMgr, REFGUID guid, DWORD dwGroupBits )
	{
		memcpy( &m_guid, &guid, sizeof(GUID) );
		m_lstNotifyListEntry.RemoveAll();

		NotifyListEntry* pNotifyListEntry;
		pNotifyListEntry = new NotifyListEntry;
		pNotifyListEntry->pIStripMgr = pIStripMgr;
		//pIStripMgr->AddRef();
		pNotifyListEntry->dwGroupBits = dwGroupBits;

		m_lstNotifyListEntry.AddHead( pNotifyListEntry );
	}

	~NotifyEntry()
	{
		NotifyListEntry* pNotifyListEntry = NULL;
		while ( !m_lstNotifyListEntry.IsEmpty() )
		{
			pNotifyListEntry = m_lstNotifyListEntry.RemoveHead();
			if ( pNotifyListEntry != NULL )
			{
				delete pNotifyListEntry;
			}
		};
	}

	GUID		m_guid;
    CTypedPtrList<CPtrList, NotifyListEntry*> m_lstNotifyListEntry;
};

int CompareStrips( int nType1, DWORD dwGroups1, DWORD dwIndex1, BSTR bstrName1, int nType2, DWORD dwGroups2, DWORD dwIndex2, BSTR bstrName2 );
int StripCLSIDToInt( REFCLSID clsidType );
int StripCKIDsToInt( FOURCC ckid, FOURCC fccType );
void InsertMenuInMenu( CMenu* pMenu1, UINT nPos, CMenu* pMenu2);

class CContextMenuHandler;
class CTimeStrip;

/////////////////////////////////////////////////////////////////////////////
// CTimelineCtl
class ATL_NO_VTABLE CTimelineCtl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimelineCtl, &CLSID_TimelineCtl>,
	public CComControl<CTimelineCtl>,
	public IDMUSProdTimeline,
	public IDMUSProdTimelineEdit,
	public IDropTarget,
	public IProvideClassInfo2Impl<&CLSID_TimelineCtl, NULL, &LIBID_TIMELINELib>,
	public IPersistStreamInitImpl<CTimelineCtl>,
	public IPersistStorageImpl<CTimelineCtl>,
	public IQuickActivateImpl<CTimelineCtl>,
	public IOleControlImpl<CTimelineCtl>,
	public IOleObjectImpl<CTimelineCtl>,
	public IOleInPlaceActiveObjectImpl<CTimelineCtl>,
	public IViewObjectExImpl<CTimelineCtl>,
	public IOleInPlaceObjectWindowlessImpl<CTimelineCtl>,
	public IDataObjectImpl<CTimelineCtl>,
	public ISpecifyPropertyPagesImpl<CTimelineCtl>,
	public IDMUSProdPropPageObject
{
	friend CContextMenuHandler;

public:
	CTimelineCtl();
	~CTimelineCtl();

static CWndClassInfo& GetWndClassInfo();


DECLARE_REGISTRY_RESOURCEID(IDR_TIMELINECTL)

BEGIN_COM_MAP(CTimelineCtl)
	COM_INTERFACE_ENTRY(IDMUSProdTimeline)
	COM_INTERFACE_ENTRY(IDMUSProdTimelineEdit)
	COM_INTERFACE_ENTRY(IDropTarget)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
	COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
	COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY_IMPL(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTimelineCtl)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
END_PROPERTY_MAP()


// don't forget to add any new messages that might go to strips
// to the CallStripWMMessage function.
BEGIN_MSG_MAP(CTimelineCtl)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
	MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
	MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
	MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRButtonDown)
	MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
	MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblclk)
	MESSAGE_HANDLER(WM_HSCROLL, OnHScroll)
	MESSAGE_HANDLER(WM_VSCROLL, OnVScroll)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
	MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
	MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
	MESSAGE_HANDLER(WM_CHAR, OnChar)
	MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	MESSAGE_HANDLER(WM_TIMER, OnTimer)
	COMMAND_HANDLER(BTN_ZOOMIN, BN_CLICKED, OnZoomIn)
	COMMAND_HANDLER(BTN_ZOOMOUT, BN_CLICKED, OnZoomOut)
	COMMAND_HANDLER(BTN_REALTIME, BN_CLICKED, OnRealTime)
	COMMAND_HANDLER(BTN_MUSICTIME, BN_CLICKED, OnMusicTime)
	//COMMAND_ID_HANDLER(ID_EDIT_COPY, OnEditCopy)
	//COMMAND_ID_HANDLER(ID_EDIT_CUT, OnEditCut)
	//COMMAND_ID_HANDLER(ID_EDIT_PASTE, OnEditPaste)
	//COMMAND_ID_HANDLER(ID_EDIT_INSERT, OnEditInsert)
	//COMMAND_ID_HANDLER(ID_EDIT_DELETE, OnEditDelete)
	//COMMAND_ID_HANDLER(ID_EDIT_REDO, OnEditRedo)
	//COMMAND_ID_HANDLER(ID_EDIT_UNDO, OnEditUndo)
	//COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, OnEditSelectall)
END_MSG_MAP()

// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IDMUSProdTimeline
public:
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		ATLTRACE(_T("IOleObjectImpl::SetClientSite\n"));
		if( pClientSite == NULL )
		{
			StripMgrList* pList;
			for( pList = m_pStripMgrList; pList; pList = pList->m_pNext )
			{
				VARIANT varTimeline;
				varTimeline.vt = VT_UNKNOWN;
				V_UNKNOWN(&varTimeline) = NULL;
				pList->m_pStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
			}
		}
		return IOleObject_SetClientSite(pClientSite);
	}

	LRESULT OnCreate(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnDestroy(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnDrawItem(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnSize(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnHScroll(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnVScroll(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnMouseWheel(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);
	
	LRESULT OnMouseMove(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnKeyDown(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnChar(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnSetCursor(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);
	
	LRESULT OnLButtonDown(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnLButtonUp(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnRButtonDown(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnRButtonUp(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnLButtonDblclk(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnZoomIn(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/);

	LRESULT OnZoomOut(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/);

	LRESULT OnRealTime(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/);

	LRESULT OnMusicTime(WORD /*wNotifyCode*/, WORD /*wID*/, 
		HWND /*hWndCtl*/, BOOL& /*bHandled*/);

	LRESULT OnEraseBkgnd(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnContextMenu(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);

	LRESULT OnTimer(UINT /* nMsg */, WPARAM /* wParam */,
		LPARAM /* lParam */, BOOL& /* lResult */);


//	LRESULT OnEditCopy(WORD /* nMsg */, WORD /* wParam */,
//		HWND /* lParam */, BOOL& /* lResult */);

//	LRESULT OnEditCut(WORD /* nMsg */, WORD /* wParam */,
//		HWND /* lParam */, BOOL& /* lResult */);

//	LRESULT OnEditPaste(WORD /* nMsg */, WORD /* wParam */,
//		HWND /* lParam */, BOOL& /* lResult */);

//	LRESULT OnEditInsert(WORD /* nMsg */, WORD /* wParam */,
//		HWND /* lParam */, BOOL& /* lResult */);

//	LRESULT OnEditDelete(WORD /* nMsg */, WORD /* wParam */,
//		HWND /* lParam */, BOOL& /* lResult */);

//	LRESULT OnEditSelectall(WORD /* nMsg */, WORD /* wParam */,
//		HWND /* lParam */, BOOL& /* lResult */);

	HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);

    STDMETHODIMP AddStripMgr( 
        /* [in] */ IDMUSProdStripMgr* pIStripMgr,
		/* [in] */ DWORD			  dwGroupBits);
    
    STDMETHODIMP AddStrip( 
        /* [in] */ IDMUSProdStrip* pIStrip);
    
    STDMETHODIMP SetMarkerTime( 
        /* [in] */ MARKERID idMarkerType,
		/* [in] */ TIMETYPE	ttType,
        /* [in] */ long lTime);
    
    STDMETHODIMP GetMarkerTime( 
        /* [in] */ MARKERID idMarkerType,
		/* [in] */ TIMETYPE	type,
        /* [out] */ long *plTime);
    
    STDMETHODIMP ClocksToPosition( 
        /* [in] */ long lTime,
        /* [out] */ long *plPosition);
    
    STDMETHODIMP PositionToClocks( 
        /* [in] */ long lPosition,
        /* [out] */ long *plTime);

	STDMETHODIMP DrawMusicLines(
		/* [in] */ HDC					hdc,
		/* [in] */ MUSICLINE_PROPERTY	mlp,
		/* [in] */ DWORD				dwGroupBits,
		/* [in] */ DWORD				dwIndex,
		/* [in] */ LONG					lXOffset);

	STDMETHODIMP SetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [in] */ VARIANT			var
		);

	STDMETHODIMP Refresh(
			void
		);

	STDMETHODIMP GetTimelineProperty(
		/* [in] */ TIMELINE_PROPERTY	tp,
		/* [out] */ VARIANT*			pvar
		);

    STDMETHODIMP ClocksToMeasureBeat( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lTime,
        /* [out] */ long*	plMeasure,
        /* [out] */ long*	plBeat);
    
    STDMETHODIMP PositionToMeasureBeat( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lPosition,
        /* [out] */ long*	plMeasure,
        /* [out] */ long*	plBeat);
    
    STDMETHODIMP MeasureBeatToClocks( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lMeasure,
        /* [in] */  long	lBeat,
        /* [out] */ long*	plTime);
    
    STDMETHODIMP MeasureBeatToPosition( 
		/* [in] */  DWORD	dwGroupBits,
		/* [in] */  DWORD	dwIndex,
        /* [in] */  long	lMeasure,
        /* [in] */  long	lBeat,
        /* [out] */ long*	plPosition);

	STDMETHODIMP StripInvalidateRect(
		/* [in] */ IDMUSProdStrip*	pIStrip,
		/* [in] */ RECT*			pRect,
		/* [in] */ BOOL				fErase);

	STDMETHODIMP SetPropertyPage(
		/* [in] */ IUnknown* punkPropPageMgr,
		/* [in] */ IUnknown* punkPropPageObj);

	STDMETHODIMP RemovePropertyPageObject(
		/* [in] */ IUnknown* punkPropPageObj );

    STDMETHODIMP StripSetTimelineProperty( 
        /* [in] */ IDMUSProdStrip* punkStrip,
        /* [in] */ STRIP_TIMELINE_PROPERTY stp,
        /* [in] */ VARIANT variant);

	STDMETHODIMP OnDataChanged(
		/* [in] */ IUnknown* punk);

	STDMETHODIMP TrackPopupMenu(
		/* [in] */ HMENU			hMenu,
		/* [in] */ long				lXpos,
		/* [in] */ long				lYpos,
		/* [in] */ IDMUSProdStrip*	pIstrip,
		/* [in] */ BOOL				bEditMenu);
		
	STDMETHODIMP ClocksToRefTime(
		/* [in] */  long			lTime,
		/* [out] */ REFERENCE_TIME*	pRefTime);
	
	STDMETHODIMP PositionToRefTime(
		/* [in] */  long			lPosition,
		/* [out] */ REFERENCE_TIME*	pRefTime);
	
	STDMETHODIMP MeasureBeatToRefTime(
		/* [in] */  DWORD			dwGroupBits,
		/* [in] */  DWORD			dwIndex,
		/* [in] */  long			lMeasure,
		/* [in] */  long			lBeat,
		/* [out] */ REFERENCE_TIME*	pRefTime);
	
	STDMETHODIMP RefTimeToClocks(
		/* [in] */  REFERENCE_TIME	RefTime,
		/* [out] */ long*			plTime);
	
	STDMETHODIMP RefTimeToPosition(
		/* [in] */  REFERENCE_TIME	RefTime,
		/* [out] */ long*			plPosition);
	
	STDMETHODIMP RefTimeToMeasureBeat(
		/* [in] */  DWORD			dwGroupBits,
		/* [in] */  DWORD			dwIndex,
		/* [in] */  REFERENCE_TIME	RefTime,
		/* [out] */ long*			plMeasure,
		/* [out] */ long*			plBeat);

	STDMETHODIMP ScreenToStripPosition(
		/* [in] */  IDMUSProdStrip*	pIStrip,
		/* [in] [out] */ POINT*	pPoint);

	STDMETHODIMP StripGetTimelineProperty(
		/* [in] */	IDMUSProdStrip*	pIStrip,
		/* [in] */	STRIP_TIMELINE_PROPERTY stp,
		/* [out] */	VARIANT*	pvar);

	STDMETHODIMP RemoveStripMgr(
		/* [in] */	IDMUSProdStripMgr* pIStripMgr);

	STDMETHODIMP RemoveStrip(
		/* [in] */	IDMUSProdStrip* pIStrip);

	STDMETHODIMP GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */  DWORD		dwIndex,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);

	STDMETHODIMP SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ DWORD		dwGroupBits,
		/* [in] */ DWORD		dwIndex,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);

	STDMETHODIMP GetStripMgr(
		/* [in] */ REFGUID				guidType,
		/* [in] */ DWORD				dwGroupBits,
		/* [in] */ DWORD				dwIndex,
		/* [out,retval] */ IDMUSProdStripMgr**	ppStripMgr);

	STDMETHODIMP InsertStripAtDefaultPos(
		/* [in] */  IDMUSProdStrip*	pStrip,
		/* [in] */  REFCLSID		clsidType,
		/* [in] */  DWORD			dwGroupBits,
		/* [in] */  DWORD			dwIndex);

	STDMETHODIMP EnumStrip(
		/* [in] */  DWORD				dwEnum,
		/* [in] */  IDMUSProdStrip**	ppStrip);

	STDMETHODIMP InsertStripAtPos(
		/* [in] */  IDMUSProdStrip*		pStrip,
		/* [in] */  DWORD				dwPosition);

	STDMETHODIMP StripToWindowPos(
		/* [in] */  IDMUSProdStrip*		pStrip,
		/* [in,out] */ POINT*			pPoint);

	STDMETHODIMP AddToNotifyList(
		/* [in] */  IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */  REFGUID				rguidType,
		/* [in] */  DWORD				dwGroupBits);

	STDMETHODIMP RemoveFromNotifyList(
		/* [in] */  IDMUSProdStripMgr*	pIStripMgr,
		/* [in] */  REFGUID				rguidType,
		/* [in] */  DWORD				dwGroupBits);

	STDMETHODIMP NotifyStripMgrs(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */  void*		pData);

	STDMETHODIMP AllocTimelineDataObject(
		/* [out,retval] */ IDMUSProdTimelineDataObject**	ppITimelineDataObject );

	STDMETHODIMP GetPasteType(
		/* [out,retval] */ TIMELINE_PASTE_TYPE*	ptlptPasteType );

	STDMETHODIMP SetPasteType(
		/* [in] */ TIMELINE_PASTE_TYPE tlptPasteType );

// IDropTarget
public:
	HRESULT STDMETHODCALLTYPE DragEnter( 
        /* [in] */ IDataObject __RPC_FAR *pDataObj,
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
    
	HRESULT STDMETHODCALLTYPE DragOver( 
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD __RPC_FAR *pdwEffect);
    
	HRESULT STDMETHODCALLTYPE DragLeave(void);
    
	HRESULT STDMETHODCALLTYPE Drop( 
        /* [in] */ IDataObject __RPC_FAR *pDataObj,
        /* [in] */ DWORD grfKeyState,
        /* [in] */ POINTL pt,
        /* [out][in] */ DWORD __RPC_FAR *pdwEffect);

// IDMUSProdTimelineEdit
public:
	HRESULT STDMETHODCALLTYPE Cut( /* out */ IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE Copy( /* out */ IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( /* in */ IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
public:
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

// private member variables
private:
	IDMUSProdFramework* m_pDMUSProdFramework;	// framework pointer set by SetTimelineProperty
	IDMUSProdTimelineCallback*	m_pTimelineCallback; // set by the component, this is an interface on the component
	StripMgrList*	m_pStripMgrList; // list of strip managers
	StripList*		m_pStripList;	// list of strips
	CWnd			m_wnd;				// the timeline window
	CScrollBar		m_ScrollHorizontal; // bottom scroll bar
	CScrollBar		m_ScrollVertical; // right scroll bar
	CButton			m_BtnZoomIn; // zoom in button
	CButton			m_BtnZoomOut; // zoom out button
	long			m_lLength;  // length of piece (zero is infinite length). In clocks for now.
	long			m_lBeginSelect; // clock-time of begin of selection (inclusive)
	long			m_lEndSelect; // clock-time of end of selection (not inclusive)
	long			m_lCursor; // clock-time of the cursor
	long			m_lXScrollPos;
	long			m_lYScrollPos;
	long			m_lFunctionBarWidth; // includes borders
	double			m_dblZoom; // zoom factor
	MOUSEMODE		m_MouseMode; // current Mouse Mode
	long			m_lResizeYPos; // current position of resize xor line
	long			m_lResizeOriginalYPos; // same as m_lResizeYPos when we first click with the mouse
	StripList*		m_pMouseStripList; // the strip getting resized or whatever
	StripList*		m_pActiveStripList; // the currently active strip
	StripList*		m_pLastDragStripList; // the strip which the cursor is currently over during a drag operation
	BOOL			m_fStripMouseCapture; // true when a strip wants all mouse events
	BOOL			m_fFreezeUndo; // true when a strip wants to prevent undo entries from being created
	BOOL			m_bPasting;	// true when pasting so the selection range doesn't change.
	BOOL			m_fMusicTime; // true when we're displaying in Music time.
	BOOL			m_fHScrollTracking; // true when we're dragging the HScroll thumb
	BOOL			m_fActiveGutterState; // true if gutters should be selected during MM_ACTIVEGUTTER movement
	COLORREF		m_colorMeasureLine;
	COLORREF		m_colorBeatLine;
	COLORREF		m_colorSubBeatLine;
	IDataObject*	m_pCurrentDataObject; // Pointer to the data object being dragged over the control
	IDataObject*	m_pCopyDataObject; // Pointer to the data object last copied.
	DWORD			m_dwDragScrollTick;		// Used to scroll timeline during OLE drag
	CContextMenuHandler	  m_MenuHandler;	// menu handler for the pop-up menus
	IDMUSProdTempoMapMgr* m_pTempoMapMgr;	// Pointer to the tempo-map manager, if there is one
	double			m_dblRefTimeConv; // number used to convert from RefTime to position
	static long		m_lBitmapRefCount;
	static CBitmap	m_BitmapZoomIn;
	static CBitmap	m_BitmapZoomOut;
	static CBitmap	m_BitmapMinimize;
	static CBitmap	m_BitmapMinimized;
	static CBitmap	m_BitmapMaximize;
	static CBitmap	m_BitmapMaximized;
	static CString	m_strZoomInChars;
	static CString	m_strZoomOutChars;
	SIZE			m_sizeMinMaxButton;
    CTypedPtrList<CPtrList, NotifyEntry*> m_lstNotifyEntry;
	TIMELINE_PASTE_TYPE m_ptPasteType;
	CRITICAL_SECTION m_csOnDataChanged;
	REFERENCE_TIME	m_rtSegmentStart;
	REFERENCE_TIME	m_rtLastElapsedTime;
	IDirectMusicPerformance* m_pIDMPerformance;
	HANDLE			m_hKeyRealTimeStatusBar;
	CTimeStrip*		m_pTimeStrip;
	long			m_lLastEarlyPosition;
	long			m_lLastLatePosition;
	long			m_lLastLateTime;
	static bool		m_fFilledColorArrays;
	static DWORD	m_adwNormalColor[256];
	static DWORD	m_adwActiveColor[256];
	/*
	static DWORD	m_adwSelectedColor[256];
	static DWORD	m_adwActiveSelectedColor[256];
	*/

// public helper methods
public:
	bool ShouldEnableDeleteTrack( void );

// protected member methods
protected:
	long ComputeXScrollPos(void); // returns, in screen coordinates, the horizontal scroll factor
	void ComputeDrawingArea( LPRECT pRect ) const;
	long PositionToXScroll(long); // converts from position to scroll bar
	void ScrollToTimeCursor( long lTime, long lLeftSide, long lRightSide );
	void SetTimeCursor( long lTime, BOOL fScroll, bool fUserSetCursor );
	void SetStripGutter( StripList* pSL, BOOL fSelect );
	void GetStripClientRect( StripList* pSL, LPRECT pRect );
	void GetEntireStripClientRect( StripList* pSL, LPRECT pRect );
	void InvalidateSelectedStrips(BOOL fErase);
	void ComputeScrollBars(void);
	long TotalStripHeight(void) const;
	void ActivateStripList( StripList* pSL );
	void DeactivateStripList( void );
	void SetTopStripList( StripList* pSL );
	StripList *GetTopStripList( void );
	void OptimizeZoomFactor(void);
	StripList* FindStripList(IDMUSProdStrip*) const;
	void CallStripWMMessage( StripList* pSL, UINT nMsg, WPARAM wParam, LPARAM lParam );
	void GetStripAndCoordinates( POINTL ptTimeline, POINTL *ptStrip, StripList **ppSL );
	void ScrollToPosition( long lPos );
	HRESULT CutCopy( BOOL bCut, IDMUSProdTimelineDataObject* pIDataObject );
	HRESULT CanEdit( long lCommand );
	void SetMouseMode( long xPos, long yPos);
	POINT GetMousePoint() const;
	HRESULT StripPointToClient( StripList* pSL, POINT *pPoint) const;
	HRESULT StripRectToClient( StripList* pSL, LPRECT pRect) const;
	HRESULT InternalInsertStripAtPos( IDMUSProdStrip* pStrip, DWORD dwPosition, REFCLSID clsidType, DWORD dwGroupBits, DWORD dwIndex );
	bool AnyGutterSelectedStrips( void ) const;
	HRESULT CanStripEdit( IDMUSProdTimelineEdit* pITimelineEdit, long lCommand );
	void DisplayPropertySheet( void );
	void ScrollTimeline( POINTL point );
	bool ComputeEarlyAndLateTime( long &lEarlyTime, long &lLateTime );
	bool BumpTimeCursor( bool fMoveRight, DMUSPROD_TIMELINE_SNAP_TO stAmount );
	void GetTempoList( CList<DMUS_TEMPO_PARAM,DMUS_TEMPO_PARAM&> &lstTempos, long lTime );
	void GetTempoList( CList<DMUS_TEMPO_PARAM,DMUS_TEMPO_PARAM&> &lstTempos, REFERENCE_TIME rtTime );
};

#endif //__TIMELINECTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Timeline\TimelineCtl.cpp ===
// TimelineCtl.cpp : Implementation of CTimelineCtl
// @doc Timeline
#include "stdafx.h"
#include <math.h>
#include <SegmentGuids.h>
#include "Timeline.h"
#include "TimelineCtl.h"
#include "TimeStripMgr.h"
#pragma warning( push )
#pragma warning( disable : 4005 )
#include <winresrc.h>
#pragma warning( pop )
#include <Conductor.h>
#include <initguid.h>
#include <dmusici.h>
#include <dmusicf.h>
#include "TimelineDataObject.h"
#include "SegmentIO.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define SHADING_BLOCK_WIDTH 16

#define TRACKCONFIG_PLAY_FLAGS (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)

long	CTimelineCtl::m_lBitmapRefCount = 0;
CBitmap	CTimelineCtl::m_BitmapZoomIn;
CBitmap	CTimelineCtl::m_BitmapZoomOut;
CBitmap	CTimelineCtl::m_BitmapMinimize;
CBitmap	CTimelineCtl::m_BitmapMinimized;
CBitmap	CTimelineCtl::m_BitmapMaximize;
CBitmap	CTimelineCtl::m_BitmapMaximized;
CString	CTimelineCtl::m_strZoomInChars;
CString	CTimelineCtl::m_strZoomOutChars;
bool	CTimelineCtl::m_fFilledColorArrays = false;
DWORD	CTimelineCtl::m_adwNormalColor[256];
DWORD	CTimelineCtl::m_adwActiveColor[256];
/*
DWORD	CTimelineCtl::m_adwSelectedColor[256];
DWORD	CTimelineCtl::m_adwActiveSelectedColor[256];
*/

// Helper function for RealTime display

void RefTimeToString( REFERENCE_TIME rtTime, int nResourceID, int nNegativeResourceID, CString &cstrTime )
{
	bool fNegative = false;
	if( rtTime < 0 )
	{
		fNegative = true;
		rtTime = -rtTime;
	}

	int iMillisecond, iSecond, iMinute, iHour;
	// Convert to milliseconds
	iMillisecond = int(rtTime / 10000);
	iSecond = iMillisecond / 1000;
	iMillisecond %= 1000;
	iMinute = iSecond / 60;
	iSecond %= 60;
	iHour = iMinute / 60;
	iMinute %= 60;

	CString strFormat;
	if( strFormat.LoadString( fNegative ? nNegativeResourceID : nResourceID ) )
	{
		cstrTime.Format(strFormat, iHour, iMinute, iSecond, iMillisecond);
	}
	else
	{
		cstrTime.Format(fNegative ? "-%02d:%02d:%02d.%03d" : "%02d:%02d:%02d.%03d", iHour, iMinute, iSecond, iMillisecond);
	}
}

BOOL StripSupportTimeSigs( IDMUSProdStrip *pStrip )
{
	if( !pStrip )
	{
		return FALSE;
	}

	VARIANT var;
	BOOL fSupportsTimeSigs = FALSE;
	if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &var ) ) 
	&&	V_UNKNOWN(&var) )
	{
		IDMUSProdStripMgr *pStripMgr;
		if( SUCCEEDED( V_UNKNOWN(&var)->QueryInterface( IID_IDMUSProdStripMgr, (void**)&pStripMgr ) ) )
		{
			if( pStripMgr->IsParamSupported( GUID_TimeSignature ) == S_OK )
			{
				fSupportsTimeSigs = TRUE;
			}
			pStripMgr->Release();
		}
		V_UNKNOWN(&var)->Release();
	}

	return fSupportsTimeSigs;
}


/*  --------------------------------------------------------------------------
	@interface IDMUSProdTimelineCallback | The Timeline uses this interface to complete its
		<om IDMUSProdTimeline::OnDataChanged> method.

	@meth HRESULT | OnDataChanged | Called when data in one of the strips changes.

	@base public | IUnknown

	@xref	<i IDMUSProdTimeline>, <i IDMUSProdStrip>, <om IDMUSProdTimeline::OnDataChanged>
	--------------------------------------------------------------------------*/

/*  --------------------------------------------------------------------------
	@method HRESULT | IDMUSProdTimelineCallback | OnDataChanged | This method is
		called in response to a call to <om IDMUSProdTimeline::OnDataChanged>.

	@comm	Typically an <i IDMUSProdStripMgr> interface is passed in <p punk> and this method
		is used to notify the component that created it that data in the strip has changed.
		The component should then get the new data from the <p punk>, either by calling
		<om IStream::Save> or another method.

	@parm   IUnknown* | punk | The interface to pass.

	@xref	<om IDMUSProdTimeline::OnDataChanged> <i IDMUSProdStripMgr>
	--------------------------------------------------------------------------*/

/*  --------------------------------------------------------------------------
	@interface IDMUSProdTimeline | Coordinates the display of strips in a Timeline format.

	@meth HRESULT | AddStripMgr | Add a strip manager to the Timeline.

	@meth HRESULT | AddStrip | Add a strip to the Timeline.

	@meth HRESULT | SetMarkerTime | Set the location of one of the selection markers.

	@meth HRESULT | GetMarkerTime | Get the location of one of the selection markers.

 	@meth HRESULT | ClocksToPosition | Convert from a time in clocks to a horizontal pixel position.

	@meth HRESULT | PositionToClocks | Convert from a horizontal pixel position to a time in clocks.

	@meth HRESULT | DrawMusicLines | Draw vertical bar, beat, and grid lines in the specified device context.

	@meth HRESULT | SetTimelineProperty | Set a property of the Timeline.

	@meth HRESULT | GetTimelineProperty | Get a property of the Timeline.

	@meth HRESULT | Refresh | Redraw the entire Timeline window.

	@meth HRESULT | ClocksToMeasureBeat | Convert from a time in clocks to a measure and beat value.

	@meth HRESULT | PositionToMeasureBeat | Convert from a pixel position to a measure and beat value.

 	@meth HRESULT | MeasureBeatToClocks | Convert from a measure and beat to a time in clocks.

	@meth HRESULT | MeasureBeatToPosition | Convert from a measure and beat to a pixel position.

	@meth HRESULT | StripInvalidateRect | Invalidate the specified rectangle in a strip, causing the area to be redrawn.

	@meth HRESULT | SetPropertyPage | Change the currently display property page.

	@meth HRESULT | RemovePropertyPageObject | Remove a property page object from the currently displayed property sheet.

	@meth HRESULT | StripSetTimelineProperty | Set a strip property that is controlled by the Timeline.

	@meth HRESULT | OnDataChanged | Notify the main editor that data has changed.

	@meth HRESULT | TrackPopupMenu | Display a context menu at the specified position.

	@meth HRESULT | ClocksToRefTime | Convert from a time in clocks to a time in REFERENCE_TIME units.

	@meth HRESULT | PositionToRefTime | Convert from a pixel position to a time in REFERENCE_TIME units.

	@meth HRESULT | MeasureBeatToRefTime | Convert from a measure and beat to a time in REFERENCE_TIME units.

	@meth HRESULT | RefTimeToClocks | Convert from a time in REFERENCE_TIME units to a time in clocks.

	@meth HRESULT | RefTimeToPosition | Convert from a time in REFERENCE_TIME units to a pixel position.

	@meth HRESULT | RefTimeToMeasureBeat | Convert from a time in REFERENCE_TIME units to a measure and beat value.

	@meth HRESULT | ScreenToStripPosition | Convert a point from screen coordinates to strip coordinates.

	@meth HRESULT | StripGetTimelineProperty | Get a strip property that is controlled by the Timeline.

	@meth HRESULT | RemoveStripMgr | Remove a strip manager from the Timeline.

	@meth HRESULT | RemoveStrip | Remove a strip from the Timeline.

	@meth HRESULT | GetParam | Retrieve data from a strip manager in the Timeline.

	@meth HRESULT | SetParam | Set data on a strip manager in the Timeline

	@meth HRESULT | GetStripMgr | Retrieve a specified strip manager.

	@meth HRESULT | InsertStripAtDefaultPos | Insert a strip into the Timeline, using the default sorting order.

	@meth HRESULT | EnumStrip | Enumerate through all strips displayed within the Timeline.

	@meth HRESULT | InsertStripAtPos | Insert a strip into the Timeline at a specified position.

	@meth HRESULT | StripToWindowPos | Convert a point from strip coordinates to Timeline Window coordinates.

	@meth HRESULT | AddToNotifyList | Register a StripMgr to receive notifications of a specified type.

	@meth HRESULT | RemoveFromNotifyList | Unregister a StripMgr from receiving notifications of a specified type.

	@meth HRESULT | NotifyStripMgrs | Broadcast the specified notification to all registered strip managers.

	@meth HRESULT | AllocTimelineDataObject | Allocate an object that implements the <i IDMUSProdTimelineDataObject> interface.

	@meth HRESULT | GetPasteType | Returns the type of Paste operation to perform.

	@meth HRESULT | SetPasteType | Sets the type of Paste operation to perform.

	@base public | IUnknown

	@xref	<i IDMUSProdStrip>, <i IDMUSProdStripMgr>, <i IDMUSProdStripFunctionBar>,
		<i IDMUSProdTimelineEdit>, <i IDMUSProdTimelineCallback>, <i IDMUSProdTimelineDataObject>
	--------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
//
//	@enum TIMETYPE | Time unit types
//		@emem TIMETYPE_CLOCKS | Use clocks units.
//		@emem TIMETYPE_MS | Use millisecond units.  This is converted to and from clocks internally.
//
//	@enum TIMELINE_PROPERTY | Timeline properties
//		@emem TP_CLOCKLENGTH | The length of the Timeline, in ticks.
//		@emem TP_STRIPMOUSECAPTURE | Allows a strip to capture the mouse cursor.  This should be
//					set to true when a strip receives a WM_LBUTTONDOWN, WM_RBUTTONDOWN, or
//					WM_LBUTTONDBLCLK message.  Getting this parameter is unsupported.
//		@emem TP_DMUSPRODFRAMEWORK | Sets or gets a pointer to the DirectMusic Producer Framework.
//		@emem TP_TIMELINECALLBACK | Sets or gets a pointer to the object which receives notification
//					when data changes in any of the strips.  The object must implement the
//					<i IDMUSProdTimelineCallback> interface.
//		@emem TP_ACTIVESTRIP | Sets or gets a pointer to the active strip.  NULL is a valid parameter
//					for setting this property, but it will never be successfully returned when
//					retrieving this property.
//		@emem TP_FUNCTIONBAR_WIDTH | The width of the function bar as a number of pixels as a VT_I4.
//		@emem TP_MAXIMUM_HEIGHT | The maximum height of a strip, if the entire strip is to be shown
//					at once.  Setting this parameter is unsupported.
//		@emem TP_ZOOM | The horizontal zoom faction, as a VT_R8 parameter.
//		@emem TP_HORIZONTAL_SCROLL | The horizontal scroll amount.
//		@emem TP_VERTICAL_SCROLL | The vertical scroll amount.
//		@emem TP_SNAPAMOUNT | Returns the snap granularity for the given VT_I4 parameter.  Setting
//					this parameter is unsupported.
//		@emem TP_FREEZE_UNDO | Segment specific: When set to TRUE, any calls to OnDataChanged will
//					not create undo states, but the changes will still be taken.
//		@emem TP_SNAP_TO | (<t DMUSPROD_TIMELINE_SNAP_TO>) as a VT_I4.  Gets or sets the snap-to boundary.
//		@emem TP_GUTTER_WIDTH | The width of the gutter as a number of pixels as a VT_I4.  Setting
//					this parameter is unsupported.
//
//	@enum DMUSPROD_TIMELINE_SNAP_TO | Snap-to settings
//		@emem DMUSPROD_TIMELINE_SNAP_NONE | No snap setting.
//		@emem DMUSPROD_TIMELINE_SNAP_GRID | Snap to nearest grid.
//		@emem DMUSPROD_TIMELINE_SNAP_BEAT | Snap to nearest beat.
//		@emem DMUSPROD_TIMELINE_SNAP_BAR | Snap to nearest bar.
//
//	@enum STRIP_TIMELINE_PROPERTY | Timeline strip properties
//		@emem STP_VERTICAL_SCROLL | VT_I4.  The current vertical scroll position of the strip (in pixels).
//		@emem STP_GET_HDC | VT_I4.  Gets a handle to the device context (a HDC stored as a VT_I4) that
//					is used to draw the strip.  Setting this parameter is unsupported.
//		@emem STP_HEIGHT | VT_I4.  The current height of the strip.
//		@emem STP_STRIPVIEW | VT_I4.  The current <t STRIPVIEW> of the strip.
//		@emem STP_STRIP_RECT | VT_BYREF.  Allows a strip to get its clipped boundaries in Timeline
//					window coordinates.  The caller must pass a VARIANT of type VT_BYREF that contains
//					a non-NULL pointer to a RECT structure.  Setting this parameter is unsupported.
//		@emem STP_FBAR_RECT | VT_BYREF.  Allows a strip to get the boundaries of its function bar
//					(including the gutter and line diving the function bar from the rest of the strip)
//					in Timeline window coordinates.  The caller must pass a VARIANT of type
//					VT_BYREF that contains a non-NULL pointer to a RECT structure.  Setting this
//					parameter is unsupported.
//		@emem STP_FBAR_CLIENT_RECT | VT_BYREF.  Allows a strip to get the boundaries of the drawable
//					area of its function bar in the window coordinates used in the <om IStrip::FBDraw>
//					method.  The caller must pass a VARIANT of type	VT_BYREF that contains a non-NULL
//					pointer to a RECT structure.  Setting this parameter is unsupported.
//		@emem STP_POSITION | VT_I4.  Returns the position of the strip, with the top strip having the
//					value of 0.  Setting this parameter is unsupported.
//		@emem STP_GUTTER_SELECTED | VT_BOOL.  Allows a strip to get or set its gutter selection state.
//					When the strip is selectd, its gutter will display either as red or orange.  When
//					the strip is unselected, its gutter will display as either grey or yellow.
//		@emem STP_ENTIRE_STRIP_RECT | VT_BYREF.  Allows a strip to get its unclipped boundaries in Timeline
//					window coordinates.  The caller must pass a VARIANT of type VT_BYREF that contains
//					a non-NULL pointer to a RECT structure.  Setting this parameter is unsupported.
//		@emem STP_STRIP_INFO | VT_BYREF.  Allows a strip to set its position properties, if the strip was
//					not added by <om IDMUSProdTimeline::InsertStripAtDefaultPos>.  The caller must pass a
//					VARIANT of type VT_BYREF that contains a non-NULL pointer to a <t DMUSPROD_TIMELINE_STRIP_INFO>
//					structure.  Getting this parameter is unsupported.
//
//	@enum MARKERID | Marker types in the time strip
//		@emem MARKER_CURRENTTIME | The current time position, displayed as a infinitely tall
//			line.
//		@emem MARKER_BEGINSELECT | The start of the edit selection.
//		@emem MARKER_ENDSELECT | The end of the edit selection.
//		@emem MARKER_LEFTDISPLAY | The left edge of the strip display window.  Setting this
//			parameter is unsupported.
//		@emem MARKER_RIGHTDISPLAY | The right edge of the strip display window.  Setting this
//			parameter is unsupported.
//
//	@enum MUSICLINE_PROPERTY | Type of bar lines to draw
//		@emem ML_DRAW_MEASURE_BEAT_GRID | Draw bar, beat, and grid lines.
//		@emem ML_DRAW_MEASURE_BEAT | Draw bar and beat lines.
//
//	@enum TIMELINE_PASTE_TYPE | Type of paste operation to do
//		@emem TL_PASTE_MERGE | Merge pasted data with existing data.
//		@emem TL_PASTE_OVERWRITE | Overwrite existing data with pasted data.
//

CTimelineCtl::CTimelineCtl()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pDMUSProdFramework = NULL;
	m_bWindowOnly = TRUE; 
	m_pStripMgrList = NULL;
	m_pStripList = NULL;
	m_pActiveStripList = NULL;
	m_pTempoMapMgr = NULL;
	m_dblZoom = .125; // set initial zoom factor
	m_MouseMode = MM_NORMAL;
	m_pMouseStripList = NULL;
	m_lLength = DMUS_PPQ * 4 * 20; // start at 20 measures, four quarter notes per measure
	m_lBeginSelect = 0;
	m_lEndSelect = 0;
	m_lCursor = 0;
	m_lXScrollPos = 0;
	m_lYScrollPos = 0;
	m_fStripMouseCapture = FALSE;
	m_fFreezeUndo = FALSE;
	m_bPasting = FALSE;
	m_lFunctionBarWidth = LEFT_DRAW_OFFSET + 80;
	m_colorMeasureLine = MEASURE_LINE_COLOR;
	m_colorBeatLine = BEAT_LINE_COLOR;
	m_colorSubBeatLine = SUBBEAT_LINE_COLOR;
	m_pLastDragStripList = NULL;
	m_pCurrentDataObject = NULL;
	m_pCopyDataObject = NULL;
	m_dwDragScrollTick = 0;
	m_pTimelineCallback = NULL;
	m_fMusicTime = TRUE;
	m_fHScrollTracking = FALSE;
	m_fActiveGutterState = FALSE;
	m_ptPasteType = TL_PASTE_OVERWRITE;
	// Default values - real values are set in OnCreate()
	m_sizeMinMaxButton.cx = 16;
	m_sizeMinMaxButton.cy = 16;
	m_lstNotifyEntry.RemoveAll();
	InitializeCriticalSection( &m_csOnDataChanged );
	m_pIDMPerformance = NULL;
	m_rtSegmentStart = 0;
	m_rtLastElapsedTime = 0;
	m_hKeyRealTimeStatusBar = NULL;
	m_pTimeStrip = NULL;
	m_lLastEarlyPosition = 0;
	m_lLastLatePosition = 0;
	m_lLastLateTime = 0;
	if( m_strZoomInChars.IsEmpty() )
	{
		if( !m_strZoomInChars.LoadString( IDS_ZOOM_IN_KEYS ) )
		{
			m_strZoomInChars = _T("iI");
		}
	}
	if( m_strZoomOutChars.IsEmpty() )
	{
		if( !m_strZoomOutChars.LoadString( IDS_ZOOM_OUT_KEYS ) )
		{
			m_strZoomOutChars = _T("oO");
		}
	}

	if( !m_fFilledColorArrays )
	{
		// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
		DWORD dwColorBase = RGB( SHADING_DARK_COLOR, SHADING_DARK_COLOR, SHADING_DARK_COLOR );
		int iBScale = 255 - SHADING_DARK_COLOR;
		int iGScale = 255 - SHADING_DARK_COLOR;
		int iRScale = 255 - SHADING_DARK_COLOR;
		for( long lIndex = 0; lIndex < 256; lIndex++ )
		{
			// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
			const DWORD dwColor = dwColorBase + RGB( (iBScale * lIndex) / 255, (iGScale * lIndex) / 255, (iRScale * lIndex) / 255 );
			m_adwNormalColor[lIndex] = dwColor;
		}

		// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
		dwColorBase = RGB( 192, 255, 255 ); // Yellow (COLOR_GUTTER_ACTIVE)
		iBScale = 255 - 192;
		iGScale = 255 - 255;
		iRScale = 255 - 255;
		for( lIndex = 0; lIndex < 256; lIndex++ )
		{
			// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
			const DWORD dwColor = dwColorBase + RGB( (iBScale * lIndex) / 255, (iGScale * lIndex) / 255, (iRScale * lIndex) / 255 );
			m_adwActiveColor[lIndex] = dwColor;
		}

		/*
		// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
		dwColorBase = RGB( 128, 128, 255 ); // Red (COLOR_GUTTER_SELECTED)
		iBScale = 0; iGScale = 0; iRScale = 7;
		for( lIndex = 0; lIndex < 256; lIndex++ )
		{
			const BYTE bHeightVal = BYTE(lIndex >> 1);

			// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
			const DWORD dwColor = dwColorBase + RGB( bHeightVal >> iBScale, bHeightVal >> iGScale, bHeightVal >> iRScale );
			m_adwSelectedColor[lIndex] = dwColor;
		}

		// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
		dwColorBase = RGB( 128, 192, 255 ); // Orange (COLOR_GUTTER_ACTIVESELECTED)
		iBScale = 0; iGScale = 1; iRScale = 7;
		for( lIndex = 0; lIndex < 256; lIndex++ )
		{
			const BYTE bHeightVal = BYTE(lIndex >> 1);

			// For DIBs, RGB() is actually BGR(), so we need to switch the order of the values
			const DWORD dwColor = dwColorBase + RGB( bHeightVal >> iBScale, bHeightVal >> iGScale, bHeightVal >> iRScale );
			m_adwActiveSelectedColor[lIndex] = dwColor;
		}
		*/

		m_fFilledColorArrays = true;
	}
}

CTimelineCtl::~CTimelineCtl()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	StripMgrList*	pSML;
	StripList*		pSL;
	IDMUSProdPropPageObject* pPPO;

	if( m_pCopyDataObject )
	{
		if(S_OK == OleIsCurrentClipboard(m_pCopyDataObject))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}

	DeleteCriticalSection( &m_csOnDataChanged );

	if( ::InterlockedDecrement( &m_lBitmapRefCount ) == 0 )
	{
		if ( m_BitmapZoomIn.GetSafeHandle() != NULL )
		{
			m_BitmapZoomIn.DeleteObject();
		}
		if ( m_BitmapZoomOut.GetSafeHandle() != NULL )
		{
			m_BitmapZoomOut.DeleteObject();
		}

		if ( m_BitmapMinimize.GetSafeHandle() != NULL )
		{
			m_BitmapMinimize.DeleteObject();
		}
		if ( m_BitmapMinimized.GetSafeHandle() != NULL )
		{
			m_BitmapMinimized.DeleteObject();
		}

		if ( m_BitmapMaximize.GetSafeHandle() != NULL )
		{
			m_BitmapMaximize.DeleteObject();
		}
		if ( m_BitmapMaximized.GetSafeHandle() != NULL )
		{
			m_BitmapMaximized.DeleteObject();
		}
	}

	while( m_pStripMgrList )
	{
		if( m_pStripMgrList->m_pStripMgr )
		{
			// make sure that there's no chance an object is left over
			if( SUCCEEDED( m_pStripMgrList->m_pStripMgr->QueryInterface( 
				IID_IDMUSProdPropPageObject, (void**)&pPPO )))
			{
				RemovePropertyPageObject(pPPO);
				pPPO->Release();
			}
			VARIANT varTimeline;
			varTimeline.vt = VT_UNKNOWN;
			V_UNKNOWN(&varTimeline) = NULL;
			m_pStripMgrList->m_pStripMgr->SetStripMgrProperty(SMP_ITIMELINECTL, varTimeline);
		}
		pSML = m_pStripMgrList->m_pNext;
		delete m_pStripMgrList;
		m_pStripMgrList = pSML;
	}
	while( m_pStripList )
	{
		if( m_pStripList->m_pStrip )
		{
			// make sure that there's no chance an object is left over
			if( SUCCEEDED( m_pStripList->m_pStrip->QueryInterface( 
				IID_IDMUSProdPropPageObject, (void**)&pPPO )))
			{
				RemovePropertyPageObject(pPPO);
				pPPO->Release();
			}
		}
		pSL = m_pStripList->m_pNext;
		delete m_pStripList;
		m_pStripList = pSL;
	}
	NotifyEntry* pNotifyEntry = NULL;
	while( !m_lstNotifyEntry.IsEmpty() )
	{
		pNotifyEntry = m_lstNotifyEntry.RemoveHead();
		if ( pNotifyEntry != NULL )
		{
			delete pNotifyEntry;
		}
	};
	if( m_pDMUSProdFramework )
	{
		m_pDMUSProdFramework->Release();
	}
	if( m_pIDMPerformance )
	{
		m_pIDMPerformance->Release();
	}
	if( m_pTimelineCallback )
	{
		m_pTimelineCallback->Release();
	}

	m_wnd.Detach();
}

void CTimelineCtl::CallStripWMMessage( StripList* pSL, UINT nMsg, WPARAM wParam,
	LPARAM lParam )
{
	BOOL fFunctionBar = FALSE; // true if mouse is in function bar area

	ASSERT(pSL != NULL);
	if (pSL == NULL)
	{
		return;
	}
	ASSERT(m_pStripList != NULL);
	if (m_pStripList == NULL)
	{
		return;
	}

	long xPos, yPos;
	xPos = LOWORD(lParam);
	yPos = HIWORD(lParam);

	// if X position is negative, make xPos negative
	if( lParam & 0x8000 )
	{
		xPos = xPos | 0xFFFF0000;
	}

	// if Y position is negative, make yPos negative
	if( lParam & 0x80000000 )
	{
		yPos = yPos | 0xFFFF0000;
	}

	switch(nMsg)
	{
	case WM_MOUSEMOVE:
	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_SETCURSOR:
	case WM_CONTEXTMENU:
		{
		// adjust lParam so the cursor position is relative to 0,0 of the strip

			if( xPos < m_lFunctionBarWidth )
			{
				fFunctionBar = TRUE;
			}

			// add horizontal scroll and subtract the function bar and any extras time at the start
			xPos = xPos + m_lXScrollPos - m_lLastEarlyPosition - m_lFunctionBarWidth;

			// subtract away the border
			yPos -= BORDER_HORIZ_WIDTH;
			// if not minized, add any strip vertical scrolling
			if (pSL->m_sv != SV_MINIMIZED)
			{
				yPos += pSL->m_lVScroll;
			}

			// add timeline scroll for all except top strip, which doesn't scroll
			if( pSL != m_pStripList )
			{
				yPos += m_lYScrollPos;
			}

			// subtract the heights of any strips above this one
			for( StripList* pTempSL = m_pStripList; pTempSL; pTempSL = pTempSL->m_pNext )
			{
				if( pTempSL == pSL )
				{
					break;
				}
				yPos -= ( pTempSL->m_lHeight + BORDER_HORIZ_DRAWWIDTH );
			}
			lParam = MAKELONG( xPos, yPos );
		}
		break;
	default:
		break;
	}
	if( fFunctionBar )
	{
		if( nMsg == WM_LBUTTONDOWN || nMsg == WM_RBUTTONDOWN )
		{
			// Unselect everything
			SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
			SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
		}

		// we're in the function bar area
		IDMUSProdStripFunctionBar* pSFB;
		if( SUCCEEDED( pSL->m_pStrip->QueryInterface( IID_IDMUSProdStripFunctionBar, (void**)&pSFB)))
		{
			pSFB->FBOnWMMessage( nMsg, wParam, lParam, xPos, yPos );
			pSFB->Release();
		}
	}
	else
	{
		if( nMsg == WM_LBUTTONDOWN || nMsg == WM_RBUTTONDOWN )
		{
			// Set the time cursor to where the user clicked
			long lTime;
			PositionToClocks( xPos, &lTime );
			SetTimeCursor( lTime, false, true );
		}
		pSL->m_pStrip->OnWMMessage( nMsg, wParam, lParam, xPos, yPos );
	}
}


long CTimelineCtl::TotalStripHeight(void) const
{
	StripList* pSL;
	long lReturn = 0;

	for( pSL = m_pStripList; pSL; pSL = pSL->m_pNext )
	{
		lReturn += pSL->m_lHeight + ( 2 * BORDER_HORIZ_DRAWWIDTH );
	}
	return lReturn;
}

void CTimelineCtl::ComputeScrollBars(void)
{
	RECT rect, rectS;
	long lTemp;
	SCROLLINFO	siH, siV, si;

	// Get the current information for each scrollbar
	m_ScrollVertical.GetScrollInfo( &siV, SIF_ALL );
	m_ScrollHorizontal.GetScrollInfo( &siH, SIF_ALL );

	// compute the number of pixels that show in one window
	m_ScrollVertical.GetClientRect(&rectS);
	GetClientRect(&rect);
	rect.right -= ( rectS.right + m_lFunctionBarWidth + BORDER_VERT_WIDTH );

	// compute the length, in # of pixels
	ClocksToPosition( m_lLength, &lTemp );

	// Check if the pixel length is greater than 0
	if( lTemp > 0 )
	{
		// Determine how much of the window is visible, horizontally
		double dbl = (double)max( rect.right, 0 ) / double(lTemp + m_l