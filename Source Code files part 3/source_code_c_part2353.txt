dPropertySheets(HANDLE hProps, int flags);
INT_PTR  WINAPI EnumPropertySheets(HANDLE hProps, int iType, INT_PTR iSheet, LPPROPSHEETPAGE lppsi);
HANDLE  WINAPI FreePropertySheets(HANDLE hProps, int flags);
#endif  /* PIF_PROPERTY_SHEETS */

#endif  /* WINAPI */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

/* XLATON */

#endif // _INC_PIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\krnlcmn.h ===
//---------------------------------------------------------------------------
//
//  KrnlCmn.h
//
//  Include file for common private krnl386/kernel32 APIs.
//
//---------------------------------------------------------------------------

//
//  idProcess can be one of:
//      0L                      --  for current process
//      MAKELONG(hTask, 0)      --  for process with task handle hTask
//      idProcess               --  for real PID
//
//  iIndex is:
//      extra DWORD if >= 0
//      kernel thing if negative
//

#define GPD_PPI                 0       // Going away
#define GPD_FLAGS               -4
#define GPD_PARENT              -8
#define GPD_STARTF_FLAGS        -12     // Can be changed
#define GPD_STARTF_POS          -16
#define GPD_STARTF_SIZE         -20
#define GPD_STARTF_SHOWCMD      -24
#define GPD_STARTF_HOTKEY       -28
#define GPD_STARTF_SHELLDATA    -32
#define	GPD_CURR_PROCESS_ID     -36
#define	GPD_CURR_THREAD_ID      -40
#define	GPD_EXP_WINVER          -44
#define GPD_HINST               -48
#define GPD_HUTSTATE		-52
#define GPD_COMPATFLAGS         -56

#define CW_USEDEFAULT_32    0x80000000
#define CW_USEDEFAULT_16    0x00008000

#ifdef WIN32
#define INDEX   LONG
#define OURAPI  APIENTRY
#else
#define INDEX   int
#define OURAPI  API

#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USEHOTKEY        0x00000200  // ;4.0
#define STARTF_HASSHELLDATA     0x00000400  // ;Internal
#endif

DWORD OURAPI GetProcessDword(DWORD idProcess, INDEX iIndex);
BOOL  OURAPI SetProcessDword(DWORD idProcess, INDEX iIndex, DWORD dwValue);

// 
// For GPD_FLAGS
//
#define GPF_DEBUG_PROCESS   0x00000001
#define GPF_WIN16_PROCESS   0x00000008
#define GPF_DOS_PROCESS     0x00000010
#define GPF_CONSOLE_PROCESS 0x00000020
#define GPF_SERVICE_PROCESS 0x00000100


#undef OURAPI
#undef INDEX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\platform.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       platform.h
//
//  Contents:   Macros for portable access to platform dependent values.
//
//
// This file contains macros for easy cross platform developing.
// There are macros for compiler differences and platform/layer differences.
//
//----------------------------------------------------------------------------


#ifndef __PLATFORM_H_
#define __PLATFORM_H_

#ifdef __cplusplus
   // +++ Unaligned memory access templates/macros
#  include <unaligned.hpp>
#endif

////////////////////////////////////////////////////////////////////
//
// Global defines (should be moved to NT public headers)
//

#define VER_PLATFORM_WIN32_UNIX 9

////////////////////////////////////////////////////////////////////
//
// Compiler differences
//

#if !defined(_MSC_VER) && !defined(__APOGEE__)
    // For compilers lacking VC++ extensions

#   define __cdecl
#   define INLINEOP      /* Inline operators not available IEUNIX */

#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX

#else // !_MSC_VER

    // VC++ compilers

#   define INLINEOP inline
#   define UNSIZED_ARRAY

#endif

#define EMPTY_SIZE UNSIZED_ARRAY

////////////////////////////////////////////////////////////////////
//
// Platform / Layer dependent sections.
//
// NOTE! #ifdefing based on WIN32 is invalid as some layers define
//       WIN32 for compatability.
//

#define ENDEXCEPT  __endexcept
#define ENDFINALLY __endfinally

#if !defined( UNIX )
#define __endexcept
#define __endfinally
#endif // UNIX

// +++ File Separators

#if defined( UNIX )
// UNIX

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '/'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'/'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "/"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"/"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ':'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L':'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ":"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L":"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\n"
#  endif

#else // UNIX

// Windows / MAC

#  ifndef FILENAME_SEPARATOR
#  define FILENAME_SEPARATOR       '\\'
#  endif

#  ifndef FILENAME_SEPARATOR_W
#  define FILENAME_SEPARATOR_W     L'\\'
#  endif

#  ifndef FILENAME_SEPARATOR_STR
#  define FILENAME_SEPARATOR_STR   "\\"
#  endif

#  ifndef FILENAME_SEPARATOR_STR_W
#  define FILENAME_SEPARATOR_STR_W L"\\"
#  endif

#  ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR           ';'
#  endif

#  ifndef PATH_SEPARATOR_W
#  define PATH_SEPARATOR_W         L';'
#  endif

#  ifndef PATH_SEPARATOR_STR
#  define PATH_SEPARATOR_STR       ";"
#  endif

#  ifndef PATH_SEPARATOR_STR_W
#  define PATH_SEPARATOR_STR_W     L";"
#  endif

#  ifndef LINE_SEPARATOR_STR
#  define LINE_SEPARATOR_STR       "\r\n"
#  endif

#  ifndef LINE_SEPARATOR_STR_W
#  define LINE_SEPARATOR_STR_W     L"\r\n"
#  endif

#endif // Windows / MAC



#ifdef UNIX


#  define PLATFORM_ACCEL_KEY ALT
#  define PLATFORM_ACCEL_STR "Alt"  // --  Look in rc.sed files
#  define FACCELKEY FALT

#define VK_OEM_SLASH 0xBF

#else   /* UNIX  */

#define INTERFACE_PROLOGUE(a)
#define INTERFACE_EPILOGUE(a)
#define INTERFACE_PROLOGUE_(a,b)
#define INTERFACE_EPILOGUE_(a,b)


#  define PLATFORM_ACCEL_KEY CONTROL
#  define PLATFORM_ACCEL_STR "Ctrl"  // --  Look in rc.sed files
#  define FACCELKEY FCONTROL

#define VK_OEM_SLASH '/'

#endif  /* UNIX */

#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))

#ifdef BIG_ENDIAN
#define MAKE_LI(low,high) { high, low }
#define PALETTE_ENTRY( r, g, b, f )  { f, b, g, r }
#else
#define MAKE_LI(low,high) { low, high }
#define PALETTE_ENTRY( r, g, b, f )  { r, g, b, f }
#endif

#endif // __PLATFORM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((WPARAM)(x))
#define OFFSETOF(x)     ((WPARAM)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) BOOLFROMPTR(hinst)

// HIWORD is typically used to detect whether a pointer parameter
// is a real pointer or is a MAKEINTATOM.  HIWORD64 is the Win64-compatible
// version of this usage.  It does *NOT* return the top word of a 64-bit value.
// Rather, it returns the top 48 bits of the 64-bit value.
//
// Yes, the name sucks.  Any better ideas?
//
// BOOLFROMPTR is used when you have a pointer or a ULONG_PTR
// and you want to turn it into a BOOL.  In Win32,
// sizeof(BOOL) == sizeof(LPVOID) so a straight cast works.
// In Win64, you have to do it the slow way because pointers are 64-bit.
//
#ifdef _WIN64
#define HIWORD64(p)     ((ULONG_PTR)(p) >> 16)
#define BOOLFROMPTR(p)  ((p) != 0)
#define SPRINTF_PTR		"%016I64x"
#else
#define HIWORD64        HIWORD
#define BOOLFROMPTR(p)  ((BOOL)(p))
#define SPRINTF_PTR		"%08x"
#endif

#define DATASEG_READONLY    ".text"	        // don't use this, compiler does this for you
#define DATASEG_PERINSTANCE "INSTDATA"      // per instance data (per process)
#ifdef WINNT
#define DATASEG_SHARED
#else
#define DATASEG_SHARED      "SHARED"        // global global data (shared across process)
#endif
#define CODESEG_INIT        ".text"

#define GetWindowInt        GetWindowLongPtr
#define SetWindowInt        SetWindowLongPtr
#define SetWindowID(hwnd,id)    SetWindowLongPtr(hwnd, GWLP_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLongPtr(hwnd, GCLP_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLongPtr(hwnd, GCLP_HICON))
#define BOOL_PTR                INT_PTR

#ifdef WINNT

#else

typedef TBYTE TUCHAR;

#endif


#else  // !WIN32

typedef LPCSTR LPCTSTR;
typedef LPSTR  LPTSTR;
typedef const short far *LPCWSTR;
#define TEXT(x) (x)

#define ISLPTR(pv)      	(SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT 	    "_INIT"

#define GetWindowInt    	GetWindowWord
#define SetWindowInt    	SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\propset.h ===
#ifndef _PROPSET_H_
#define _PROPSET_H_

// BUGBUG (scotth): this is a placeholder header so we can
//  use this according to the spec \\ole\specs\release\properties.doc

// Don't define if OLE definitions are in place!
#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

#include <ole2.h>


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

typedef struct tagPROPVARIANT PROPVARIANT;

#define TYPEDEF_CA(type, name) \
	typedef struct tag ## name {\
		ULONG cElems;\
		type *pElems;\
		} name
TYPEDEF_CA(unsigned char,		CAUI1);
TYPEDEF_CA(short,			CAI2);
TYPEDEF_CA(USHORT,		CAUI2);
TYPEDEF_CA(long,				CAI4);
TYPEDEF_CA(ULONG,			CAUI4);
TYPEDEF_CA(LARGE_INTEGER,	CAI8);
TYPEDEF_CA(ULARGE_INTEGER,CAUI8);
TYPEDEF_CA(float,				CAR4);
TYPEDEF_CA(double,			CAR8);
TYPEDEF_CA(CURRENCY,		CACY);
TYPEDEF_CA(DATE,			CADATE);
TYPEDEF_CA(BSTR,			CABSTR);
TYPEDEF_CA(VARIANT_BOOL,	CABOOL);
TYPEDEF_CA(SCODE,			CASCODE);
TYPEDEF_CA(FILETIME,		CAFILETIME);
TYPEDEF_CA(LPSTR,			CALPSTR);
TYPEDEF_CA(LPWSTR,		CALPWSTR);
TYPEDEF_CA(CLSID,			CACLSID);
TYPEDEF_CA(CLIPDATA,		CACLIPDATA);
TYPEDEF_CA(PROPVARIANT,	CAPROPVARIANT);

typedef struct tagPROPVARIANT{
	VARTYPE	vt;				// value type tag
	WORD 		wReserved1;		// padding to achieve 4-byte alignment
	WORD 		wReserved2;
	WORD 		wReserved3;
    union {							
	// none						// VT_EMPTY, VT_NULL, VT_ILLEGAL
	unsigned char 		bVal;		// VT_UI1
	short         		iVal;           	// VT_I2
	USHORT			uiVal;		// VT_UI2
	long          		lVal;			// VT_I4
	ULONG			ulVal;		// VT_UI4
	LARGE_INTEGER	hVal;		// VT_I8
	ULARGE_INTEGER  uhVal;		// VT_UI8
	float				fltVal;		// VT_R4
	double			dblVal;		// VT_R8
	CY				cyVal;		// VT_CY
	DATE			date;			// VT_DATE
	BSTR			bstrVal;		// VT_BSTR			// string in the current Ansi code page
	VARIANT_BOOL	bool;			// VT_BOOL
	SCODE         		scode;          	// VT_ERROR
	FILETIME			filetime;	// VT_FILETIME
	LPSTR			pszVal;		// VT_LPSTR			// string in the current Ansi code page
	LPWSTR        		pwszVal;		// VT_LPWSTR		// string in Unicode
	CLSID*			puuid;		// VT_CLSID
	CLIPDATA*		pclipdata;		// VT_CF

	BLOB			blob;			// VT_BLOB, VT_BLOBOBJECT
	IStream*		pStream;		// VT_STREAM, VT_STREAMED_OBJECT
	IStorage*		pStorage;		// VT_STORAGE, VT_STORED_OBJECT

	CAUI1			cab;		// VT_VECTOR | VT_UI1
	CAI2           		cai;            	// VT_VECTOR | VT_I2
	CAUI2			caui;			// VT_VECTOR | VT_UI2
	CAI4           		cal;            	// VT_VECTOR | VT_I4
	CAUI4			caul;			// VT_VECTOR | VT_UI4
	CAI8				cah;			// VT_VECTOR | VT_I8
	CAUI8			cauh;		// VT_VECTOR | VT_UI8
	CAR4         		caflt;			// VT_VECTOR | VT_R4
	CAR8         		cadbl;		// VT_VECTOR | VT_R8
	CACY          		cacy;           	// VT_VECTOR | VT_CY
	CADATE        		cadate;         	// VT_VECTOR | VT_DATE
	CABSTR        		cabstr;         	// VT_VECTOR | VT_BSTR
	CABOOL			cabool;		// VT_VECTOR | VT_BOOL
	CASCODE		cascode;		// VT_VECTOR | VT_ERROR
	CALPSTR       		calpstr;        	// VT_VECTOR | VT_LPSTR
	CALPWSTR      	calpwstr;       	// VT_VECTOR | VT_LPWSTR
	CAFILETIME    	cafiletime;     	// VT_VECTOR | VT_FILETIME
	CACLSID       		cauuid;         	// VT_VECTOR | VT_CLSID
	CACLIPDATA		caclipdata;	// VT_VECTOR | VT_CF
	CAPROPVARIANT 	capropvar;	     	// VT_VECTOR | VT_VARIANT
	}DUMMYUNIONNAME;
} PROPVARIANT;

#if 0
typedef enum {
	VT_EMPTY=0,		VT_NULL=1,		VT_I2=2,			VT_I4=3,			VT_R4=4
	VT_R8=5,		VT_CY=6,		VT_DATE=7,		VT_BSTR=8,		VT_ERROR=10,	VT_BOOL=11,
	VT_VARIANT=12,	VT_UI1=17, 		VT_UI2=18,		VT_UI4=19,
	VT_I8=20,		VT_UI8=21,		VT_LPSTR=30,	VT_LPWSTR=31,
	VT_FILETIME=64,	VT_BLOB=65,		VT_STREAM=66,	VT_STORAGE=67,	VT_STREAMED_OBJECT=68
	VT_STORED_OBJECT=69,			VT_BLOB_OBJECT=70,				VT_CF=71
	VT_CLSID=72,		VT_VECTOR=0x1000,
	VT_ILLEGAL=0xFFFFFFFF,
	VT_TYPEMASK=0xFFF,		// a mask for masking VT_VECTOR and other modifiers to get the raw VT_ value.
	} PROPVARENUM;
#endif // VT_EMPTY

#define	VT_ILLEGAL 0xFFFF

typedef enum
    {
    PRSPEC_LPWSTR   = 0,
    PRSPEC_PROPID   = 1,
    } PRSPEC;

// typedef LONG	PROPID;

typedef struct tagPROPSPEC {
	ULONG ulKind;		// PRSPEC_LPWSTR or PRSPEC_PROPID
	union {
		LPWSTR	lpwstr;
        		PROPID	propid;
	}DUMMYUNIONNAME;
} PROPSPEC;

typedef GUID		FMTID;

typedef struct tagSTATPROPSETSTG {	// used in IPropertySetStorage::Enum and IPropertyStorage::Stat
	FMTID		fmtid;		// The fmtid name of this property set.
	CLSID		clsid;		// The class id of this property set.
	DWORD		grfFlags;		// The flag values of this property set as specified in IPropertySetStorage::Create.
	FILETIME		mtime;		// The time in UTC at which this property set was last modified
	FILETIME		ctime;		// The time in UTC at which this property set was created.
	FILETIME		atime;		// The time in UTC at which this property set was last accessed.
	} STATPROPSETSTG;

typedef struct  tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    }	STATPROPSTG;

#undef  INTERFACE
#define INTERFACE   IEnumSTATPROPSTG

DECLARE_INTERFACE_(IEnumSTATPROPSTG, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Next) (THIS_ ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATPROPSTG **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IEnumSTATPROPSETSTG

DECLARE_INTERFACE_(IEnumSTATPROPSETSTG, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Next) (THIS_ ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATPROPSTG **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IPropertyStorage

DECLARE_INTERFACE_(IPropertyStorage, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(ReadMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]) PURE;
    STDMETHOD(WriteMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst) PURE;
    STDMETHOD(DeleteMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[]) PURE;
    STDMETHOD(ReadPropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]) PURE;
    STDMETHOD(WritePropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]) PURE;
    STDMETHOD(DeletePropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[]) PURE;
    STDMETHOD(SetClass)(THIS_ REFCLSID clsid) PURE;
    STDMETHOD(Commit)(THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert)(THIS) PURE;
    STDMETHOD(Enum)(THIS_ IEnumSTATPROPSTG** ppenm) PURE;
    STDMETHOD(Stat)(THIS_ STATPROPSETSTG* pstatpsstg) PURE;
    STDMETHOD(SetTimes)(THIS_ const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime) PURE;
};

typedef REFGUID	REFFMTID;

#undef  INTERFACE
#define INTERFACE   IPropertySetStorage

DECLARE_INTERFACE_(IPropertySetStorage, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Create)(THIS_ REFFMTID fmtid, const CLSID* pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg)PURE;
    STDMETHOD(Open)(THIS_ REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg) PURE;
    STDMETHOD(Delete)(THIS_ REFFMTID fmtid) PURE;
    STDMETHOD(Enum)(THIS_ IEnumSTATPROPSETSTG** ppenum) PURE;
};

typedef enum PROPSETFLAG {
    PROPSETFLAG_NONSIMPLE	= 1,
    PROPSETFLAG_ANSI			= 2,
    } PROPSETFLAG;

extern  const IID IID_IPropertyStorage;
extern  const IID IID_IEnumSTATPROPSTG;
extern  const IID IID_IPropertySetStorage;
extern  const IID IID_IEnumSTATPROPSETSTG;


#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // __IPropertyStorage_INTERFACE_DEFINED__

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\sfview.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */



#ifdef __cplusplus
}       /* End of extern "C" { */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shalias.h ===
#ifndef _SHALIAS_H_
#define _SHALIAS_H_

// Editing modes
#define ADD_ALIAS   0x01
#define EDIT_ALIAS  0x02

#define LocalRealloc(a, b) LocalReAlloc(a, b, LMEM_MOVEABLE)

class CAlias;

typedef struct tagALIASINFO
{
    HWND hDlg;
    int  mode;
    HDPA aliasList;
    HDPA aliasDelList;
    BOOL fInternalChange;
    BOOL fChanged;
} ALIASINFO, * LPALIASINFO;

#define ALIASLIST_COLUMNS 2  

typedef struct tagALIASITEM 
{ 
	LPSTR aCols[ALIASLIST_COLUMNS]; 
} ALIASITEM; 

typedef struct tagALIASEDITINFO
{
    HDPA aliasList;
    CAlias * alias;
    HWND   hWnd;
    DWORD  dwFlags;
} ALIASEDITINFO, *LPALIASEDITINFO;

#define ALIASINFO_FROM_HDLG( hDlg ) \
    ((LPALIASINFO)GetWindowLong(hDlg, DWL_USER)) \

TCHAR *  EatSpaces( TCHAR * str );
TCHAR *  ChopSpaces( TCHAR * str );
TCHAR *  DuplicateString( TCHAR * str );

// CAlias - object representing one alias.
class CAlias
{
public:
    LPTSTR  m_alias;
    LPTSTR  m_szurl;
    BOOL    m_fDirty;
    CAlias( LPTSTR name );
   ~CAlias();
    
    // Operations defined for Asscociation

    Load();
    Save(); 
    Delete();

#ifdef DEBUG
    Print();
#endif
};

// Some Helper Function Prototypes
BOOL     FAR PASCAL InitAliasDialog(HWND hDlg, CAlias * current, BOOL fFullInit );
CAlias * GetCurrentAlias( HWND hDlg );

#define MAX_ALIAS_LENGTH 256

STDAPI_(BOOL) LoadAliases( HDPA aliasListIn );
STDAPI_(BOOL) SaveAliases( HDPA aliasListIn );
STDAPI_(BOOL) FreeAliases( HDPA aliasListIn );

STDAPI_(LPCTSTR) GetAliasName( CAlias * ptr );
STDAPI_(LPCTSTR) GetAliasUrl( CAlias * ptr );
STDAPI_(LPVOID)  CreateAlias( LPTSTR str );
STDAPI_(VOID)    DestroyAlias( CAlias * ptr );
STDAPI_(BOOL)    SetAliasInfo( CAlias * ptr, TCHAR * alias, TCHAR * url );

#ifdef UNICODE
// TODO :
#define FindAliasIndex FindAliasIndexW
#define FindAliasByURL FindAliasByURLW
#define AddAliasToList AddAliasToListW
#define GetURLForAlias GetURLForAliasW
#else
#define FindAliasIndex FindAliasIndexA
#define FindAliasByURL FindAliasByURLA
#define AddAliasToList AddAliasToListA
#define GetURLForAlias GetURLForAliasA
#endif

STDAPI_(BOOL)  GetURLForAliasW(HDPA  aliasListIn, LPWSTR alias, LPWSTR szurl, int cchUrl );
STDAPI_(BOOL)  AddAliasToListW(HDPA  aliasListIn, LPWSTR alias, LPWSTR szurl, HWND hwnd);
STDAPI_(BOOL)  FindAliasByURLW(HDPA  aliasListIn, LPWSTR szurl, LPWSTR alias, INT cchAlias);
STDAPI_(INT)   FindAliasIndexW(HDPA  aliasListIn, LPWSTR alias);

STDAPI_(BOOL)  GetURLForAliasA(HDPA  aliasListIn, LPSTR alias, LPSTR szurl, int cchUrl );
STDAPI_(BOOL)  AddAliasToListA(HDPA  aliasListIn, LPSTR alias, LPSTR szurl, HWND hwnd);
STDAPI_(BOOL)  FindAliasByURLA(HDPA  aliasListIn, LPSTR szurl, LPSTR alias, INT cchAlias);
STDAPI_(INT)   FindAliasIndexA(HDPA  aliasListIn, LPSTR alias);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\regitemp.h ===
//
//  RegItemP.h  - header for regitem IDLists
//  
//  NOTE - these structures cannot be changed for any reason.
//

#ifndef _REGITEMP_H_
#define _REGITEMP_H_

#ifndef NOPRAGMAS
#pragma pack(1)
#endif

typedef struct _IDREGITEM
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    CLSID   clsid;
} IDREGITEM;
typedef UNALIGNED IDREGITEM *LPIDREGITEM;
typedef const UNALIGNED IDREGITEM *LPCIDREGITEM;


typedef struct
{
    IDREGITEM       idri;
    USHORT          cbNext;
} IDLREGITEM;           // "RegItem" IDList
typedef const UNALIGNED IDLREGITEM *LPCIDLREGITEM;

#ifndef NOPRAGMAS
#pragma pack()
#endif


// stolen from shell32\shitemid.h
#ifndef SHID_ROOTEDREGITEM
#define SHID_ROOTEDREGITEM       0x1e    //
#endif //SHID_ROOTEDREGITEM

// stolen from shell32\shitemid.h
#ifndef SHID_ROOT_REGITEM
#define SHID_ROOT_REGITEM        0x1f    //
#endif //SHID_ROOT_REGITEM

#endif // _REGITEMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\runtask.h ===
#ifndef _RUNTASK_H_
#define _RUNTASK_H_

class CRunnableTask : public IRunnableTask
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IRunnableTask ***
    virtual STDMETHODIMP Run(void);
    virtual STDMETHODIMP Kill(BOOL bWait);
    virtual STDMETHODIMP Suspend(void);
    virtual STDMETHODIMP Resume(void);
    virtual STDMETHODIMP_(ULONG) IsRunning(void);

    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void) PURE;
    virtual STDMETHODIMP KillRT(BOOL bWait)     { return S_OK; };
    virtual STDMETHODIMP SuspendRT(void)        { return S_OK; };
    virtual STDMETHODIMP ResumeRT(void)         { return InternalResumeRT(); };
    virtual STDMETHODIMP InternalResumeRT(void) { _lState = IRTIR_TASK_FINISHED; return S_OK; };
    
protected:
    CRunnableTask(DWORD dwFlags);
    virtual ~CRunnableTask();
    
    LONG            _cRef;
    LONG            _lState;
    DWORD           _dwFlags;       // RTF_*
    HANDLE          _hDone;

#ifdef DEBUG
    DWORD           _dwTaskID;
#endif
};

// CRunnableTask flags
#define RTF_DEFAULT             0x00000000
#define RTF_SUPPORTKILLSUSPEND  0x00000001

#endif  // _RUNTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shdload.h ===
// Override the linkers default behaviour to DELAYLOAD failures.  Instead of throwing an exception
// try and return a function that simulates a failure in that API, therefore allowing the caller
// to correctly handle it.
//
// To use this functionality exactly one source must include this with COMPILE_DELAYLOAD_STUBS defined,
// and link to shlwapi.

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

#ifdef COMPILE_DELAYLOAD_STUBS

#include "delayimp.h"

// NOTE: The names __pfnDliNotifyHook / __pfnDliFailureHook must not be changed,
// NOTE: as they are referenced by the linker's DELAYLOAD handler so we can hook
// NOTE: and process failures during symbol import.  

FARPROC WINAPI ShellDelayLoadHelper(UINT unReason, PDelayLoadInfo pInfo);

PfnDliHook  __pfnDliNotifyHook = ShellDelayLoadHelper;
PfnDliHook  __pfnDliFailureHook = ShellDelayLoadHelper;

#endif

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shdguid.h ===
#ifndef __shdguid_h__
#define __shdguid_h__

// GUIDs for COM objects that live in SHDOCVW.DLL. currently this is shared with SHELL32.DLL only

// 3DC7A020-0ACD-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CURLFolder,       0x3DC7A020L, 0x0ACD, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// this is the IE30 WebBrowser's CLSID
DEFINE_GUID(CLSID_WebBrowser_V1,0xEAB22AC3L,0x30C1,0x11CF,0xA7,0xEB,0x00,0x00,0xC0,0x5B,0xAE,0x0B);

// 5E6AB780-7743-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_InternetToolbar, 0x5E6AB780L, 0x7743, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 7BA4C740-9E81-11CF-99D3-00AA004AE837
DEFINE_GUID(CLSID_SendToMenu, 0x7BA4C740L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {C2FBB630-2971-11d1-A18C-00C04FD75D13}
DEFINE_GUID(CLSID_CopyToMenu, 0xc2fbb630, 0x2971, 0x11d1, 0xa1, 0x8c, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {C2FBB631-2971-11d1-A18C-00C04FD75D13}
DEFINE_GUID(CLSID_MoveToMenu, 0xc2fbb631, 0x2971, 0x11d1, 0xa1, 0x8c, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {D969A300-E7FF-11d0-A93B-00A0C90F2719}
DEFINE_GUID(CLSID_NewMenu,0xd969a300, 0xe7ff, 0x11d0, 0xa9, 0x3b, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {0E5CBF21-D15F-11d0-8301-00AA005B4383}
DEFINE_GUID(CLSID_QuickLinks, 0xe5cbf21, 0xd15f, 0x11d0, 0x83, 0x1, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
// Remove this after Beta 2.
DEFINE_GUID(CLSID_QuickLinksOld, 0x7BA4C741L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

DEFINE_GUID(CLSID_BrowserBand, 0x7BA4C742L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {4D5C8C2A-D075-11d0-B416-00C04FB90376}
DEFINE_GUID(CLSID_CommBand, 0x4d5c8c2a, 0xd075, 0x11d0, 0xb4, 0x16, 0x0, 0xc0, 0x4f, 0xb9, 0x3, 0x76);

// {30D02401-6A81-11d0-8274-00C04FD5AE38}
DEFINE_GUID(CLSID_SearchBand, 0x30d02401, 0x6a81, 0x11d0, 0x82, 0x74, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);
#define CGID_SearchBand CLSID_SearchBand

// 01E04581-4EEE-11d0-BFE9-00AA005B4383
DEFINE_GUID(CLSID_AddressBand, 0x1e04581, 0x4eee, 0x11d0, 0xbf, 0xe9, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// 59FEBFE0-2ED3-11D1-83E5-00A0C90DC849
DEFINE_GUID(CLSID_NavigationBand, 0x59FEBFE0, 0x2ED3, 0x11D1, 0x83, 0xE5, 0x0, 0xA0, 0xC9, 0x0D, 0xC8, 0x49);

// {353ECE21-74CB-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_SNSList, 0x353ece21, 0x74cb, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {2466C261-78ED-11d0-80FB-00AA005B4383}
DEFINE_GUID(CLSID_ACPList, 0x2466c261, 0x78ed, 0x11d0, 0x80, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {35C042C1-75BE-11d0-80D2-00AA005B4383}
DEFINE_GUID(CLSID_MRUList, 0x35c042c1, 0x75be, 0x11d0, 0x80, 0xd2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {F61FFEC1-754F-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_BandProxy, 0xf61ffec1, 0x754f, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// 22BF0C20-6DA7-11D0-B373-00A0C9034938
DEFINE_GUID(CLSID_BrandBand, 0x22BF0C20, 0x6DA7, 0x11D0, 0xB3, 0x73, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x38);

// 90A756E0-AFCF-11CE-927B-0800095AE340
DEFINE_GUID(CLSID_TargetMenu, 0x90A756E0L, 0xAFCF, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40);

// 57D5ECC0-A23F-11CE-AE65-08002B2E1262
DEFINE_GUID(CLSID_ContentsMenu, 0x57D5ECC0L, 0xA23F, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

// 26027EA0-3992-11D0-A271-00A0C90A90CE
DEFINE_GUID(CLSID_NewFileMenu, 0x26027EA0, 0x3992, 0x11D0, 0xA2, 0x71, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE);

// *** Really private (never move to even to semi-public header) ***

// C2EA74E0-0ED2-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjectView,   0xC2EA74E0L, 0x0ED2, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
// 6667E240-0F9D-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjMenuExt,   0x6667E240L, 0x0F9D, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
//131A6952-7F78-11D0-A979-00C04FD705A2
DEFINE_GUID(IID_IBrowserService, 0x02ba3b52, 0x0547, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// (old: E4A141D2-70C7-11D1-8DD7-00C04FC99D61 until 980512)
// (old: C3F16B61-E91A-11d1-BCD9-00A0C92DBFE8 until 980903)
// {68BD21CC-438B-11d2-A560-00A0C92DBFE8}
DEFINE_GUID(IID_IBrowserService2, 0x68bd21cc, 0x438b, 0x11d2, 0xa5, 0x60, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// 02BA3B52-0547-11D1-B833-00C04FC9B31F

DEFINE_GUID(IID_IShellService, 0x5836FB00L, 0x8187, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 062E1261-A60E-11d0-82C2-00C04FD5AE38
DEFINE_GUID(IID_IHistSFPrivate, 0x62e1261, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);

// {49422C1E-1C03-11d2-8DAB-0000F87A556C}
DEFINE_GUID(IID_IShellFolderViewType, 0x49422c1e, 0x1c03, 0x11d2, 0x8d, 0xab, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {F98D8294-2BBC-11d2-8DBD-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchableCallback, 0xf98d8294, 0x2bbc, 0x11d2, 0x8d, 0xbd, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {4E1AE66C-204B-11d2-8DB3-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchable, 0x4e1ae66c, 0x204b, 0x11d2, 0x8d, 0xb3, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {D1F15BC1-D650-11d1-9839-006097DF5BD4}
DEFINE_GUID(IID_IFtpLegacySupport, 0xd1f15bc1, 0xd650, 0x11d1, 0x98, 0x39, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(CLSID_CFtpLegacySupport, 0xd1f15bc1, 0xd650, 0x11d1, 0x98, 0x39, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// 2D8ECD81-4A7B-11CF-A0B9-00AA002F954E
DEFINE_GUID(IID_INavigationStack,          0x2D8ECD81L, 0x4A7B, 0x11CF, 0xA0, 0xB9, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E);
DEFINE_GUID(IID_INavigationStackItem,      0x2D8ECD82L, 0x4A7B, 0x11CF, 0xA0, 0xB9, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E);
DEFINE_GUID(CLSID_CShellDataSource,        0xD4903360L, 0x44da, 0x11d0, 0x89, 0xe2, 0x00, 0xa0, 0xc9, 0x0a, 0x90, 0xac);

//CLSID_CDeskHtmlProp  3FC0B520-68A9-11D0-8D77-00C04FD70822

// This is the property sheet extension for the desk.cpl
// 3FC0B520-68A9-11D0-8D77-00C04FD70822
DEFINE_GUID(CLSID_CDeskHtmlProp, 0x3FC0B520L, 0x68A9, 0x11D0, 0x8D, 0x77, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x22);


// {F46EDB3B-BC2F-11d0-9412-00AA00A3EBD3}
DEFINE_GUID(IID_ITravelEntry,  0xf46edb3b, 0xbc2f, 0x11d0, 0x94, 0x12, 0x0, 0xaa, 0x0, 0xa3, 0xeb, 0xd3);

// (old: F46EDB3C-BC2F-11d0-9412-00AA00A3EBD3 until 980909)
// {66A9CB08-4802-11d2-A561-00A0C92DBFE8}
DEFINE_GUID(IID_ITravelLog, 0x66a9cb08, 0x4802, 0x11d2, 0xa5, 0x61, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);


// {91EA3F8B-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(CLSID_AugmentedShellFolder,     0x91ea3f8b, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
// {6413BA2C-B461-11d1-A18A-080036B11A03}
DEFINE_GUID(CLSID_AugmentedShellFolder2,    0x6413ba2c, 0xb461, 0x11d1, 0xa1, 0x8a, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);
// {91EA3F8C-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(IID_IAugmentedShellFolder,      0x91ea3f8c, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
// {8DB3B3F4-6CFE-11d1-8AE9-00C04FD918D0}
DEFINE_GUID(IID_IAugmentedShellFolder2,     0x8db3b3f4, 0x6cfe, 0x11d1, 0x8a, 0xe9, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {568804CE-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(CLSID_FavoriteMenu,             0x568804ce, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {568804CF-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_FavoriteMenu,               0x568804cf, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {C501AE8A-5A64-11d1-9838-00C04FD91972}
DEFINE_GUID(IID_IProxyShellFolder,          0xc501ae8a, 0x5a64, 0x11d1, 0x98, 0x38, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {E13EF4E4-D2F2-11d0-9816-00C04FD91972}
DEFINE_GUID(CLSID_MenuBandSite,             0xe13ef4e4, 0xd2f2, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {70A77D84-D78C-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_ISetWinHandler,             0x70a77d84, 0xd78c, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A82A3FDE-ECE6-11d0-981C-00C04FD91972}
DEFINE_GUID(IID_IDropTargetBackground,      0xa82a3fde, 0xece6, 0x11d0, 0x98, 0x1c, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {B8A9C381-19DF-11d1-9193-006097DF5BD4}
DEFINE_GUID(IID_IIsWebBrowserSB, 0xb8a9c381, 0x19df, 0x11d1, 0x91, 0x93, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {e17d4fc0-5564-11d1-83f2-00a0c90dc849}
DEFINE_GUID(CLSID_DocFindFolder, 0xe17d4fc0, 0x5564, 0x11d1, 0x83, 0xf2, 0x0, 0xa0, 0xc9, 0x0d, 0xc8, 0x49);

// {1f4de370-d627-11d1-ba4f-00a0c91eedba}
DEFINE_GUID(CLSID_ComputerFindFolder, 0x1f4de370, 0xd627, 0x11d1, 0xba, 0x4f, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba);

// {B005E690-678D-11d1-B758-00A0C90564FE}
DEFINE_GUID(CLSID_DocFindCommand, 0xb005e690, 0x678d, 0x11d1, 0xb7, 0x58, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

// {3409E930-5A39-11d1-83FA-00A0C90DC849}
DEFINE_GUID(IID_IContextMenuCB, 0x3409e930, 0x5a39, 0x11d1, 0x83, 0xfa, 0x0, 0xa0, 0xc9, 0xd, 0xc8, 0x49);

// {A85C4BB0-5AEE-11d1-83FA-00A0C90DC849}
DEFINE_GUID(IID_IDocFindBrowser, 0xa85c4bb0, 0x5aee, 0x11d1, 0x83, 0xfa, 0x0, 0xa0, 0xc9, 0xd, 0xc8, 0x49);

// {DBEC1000-6AB8-11d1-B758-00A0C90564FE}
DEFINE_GUID(IID_IDocFindFileFilter, 0xdbec1000, 0x6ab8, 0x11d1, 0xb7, 0x58, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

// {50a7e9b0-70ef-11d1-b75a-00a0c90564fe}
DEFINE_GUID(LIBID_Shell32, 0x50a7e9b0, 0x70ef, 0x11d1, 0xb7, 0x5a, 0x0,
 0xa0, 0xc9, 0x5, 0x64, 0xfe);

// {1BEEAD20-70D3-11d1-8CAD-00609797EA4F}
DEFINE_GUID(IID_IContextMenuSite, 0x1beead20, 0x70d3, 0x11d1, 0x8c, 0xad, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);

// {0x87D605E0L, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29};
DEFINE_GUID(IID_IDocViewSite,     0x87D605E0, 0xC511, 0x11CF, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);

//A5E46E3A-8849-11D1-9D8C-00C04FC99D61
DEFINE_GUID(CLSID_CBaseBrowser, 0xA5E46E3AL, 0x8849, 0x11D1, 0x9D, 0x8C, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);
// {AFA7AD8A-51A7-11d2-83A1-00C04FD918D0}
DEFINE_GUID(IID_IOrderList2,    0xafa7ad8a, 0x51a7, 0x11d2, 0x83, 0xa1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);


// {80F30233-B7DF-11d2-A33B-006097DF5BD4}
DEFINE_GUID(SID_SCommDlgBrowser, 0x80f30233, 0xb7df, 0x11d2, 0xa3, 0x3b, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

#endif // __shdguid_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shconv.h ===
//
//  Wrapper for <atlconv.h> that redirects it to our C-callable
//  helper functions, and also creates the appropriate definitions
//  for C callers so everybody can use the A2W/W2A macros.
//

#ifndef _SHCONV_H
#define _SHCONV_H
//
//  Force these to EXTERN_C so we can use them from C code, too.
//
STDAPI_(LPWSTR) SHA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
STDAPI_(LPSTR)  SHW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);
#define ATLA2WHELPER SHA2WHelper
#define ATLW2AHELPER SHW2AHelper

#ifdef __cplusplus
#include <atlconv.h>
#else

#define USES_CONVERSION int _convert = 0

//
//  This macro assumes that lstrlenW(UNICODE) <= lstrlenA(ANSI)
//
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
            _convert = (lstrlenA(lpa)+1),\
            ATLA2WHELPER((LPWSTR) alloca(_convert*2), (LPCSTR)lpa, _convert)))

//
//  This macro assumes that lstrlenA(ANSI) <= lstrlenW(UNICODE) * 2
//

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
            _convert = (lstrlenW(lpw)+1)*2,\
            ATLW2AHELPER((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#ifdef UNICODE
        #define T2A W2A
        #define A2T A2W
        __inline LPWSTR T2W(LPTSTR lp) { return lp; }
        __inline LPTSTR W2T(LPWSTR lp) { return lp; }
        #define T2CA W2CA
        #define A2CT A2CW
        __inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
        __inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
        #define T2W A2W
        #define W2T W2A
        __inline LPSTR T2A(LPTSTR lp) { return lp; }
        __inline LPTSTR A2T(LPSTR lp) { return lp; }
        #define T2CW A2CW
        #define W2CT W2CA
        __inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
        __inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif

#include <crt/malloc.h>         // Get definition for alloca()

#endif // !C++

#endif // _SHCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shcompui.h ===
#ifndef __SHCOMPUI_H
#define __SHCOMPUI_H
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: SHCOMPUI.H
//
//  DESCRIPTION:
//
//    Header for users of SHCOMPUI.DLL.
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//    09/21/95   Changes per first code review.                      brianau
//    09/28/95   Added SCCA_CONTEXT structure.                       brianau
//
///////////////////////////////////////////////////////////////////////////////
#ifdef WINNT

#include <windows.h>

//
// Define a context structure for keeping track of what's going on during the
// compression/uncompression operations.
//
typedef struct {
   BOOL bIgnoreAllErrors;       // User wants to ignore all errors.
   DWORD uCompletionReason;     // Reason operation completed.
   DWORD cErrors;               // Number of errors on last call.
   DWORD cCummErrors;           // Cummulative error count.
} SCCA_CONTEXT, *LPSCCA_CONTEXT;


//
// Values for uCompletionReason member of SCCA_CONTEXT.
//
#define SCCA_REASON_NORMAL         0  // No problems.
#define SCCA_REASON_USERCANCEL     1  // User cancel in confirm dlg.
#define SCCA_REASON_USERABORT      2  // User abort in error dlg.
#define SCCA_REASON_IOERROR        3  // Device IO error.
#define SCCA_REASON_DISKFULL       4  // Disk full on uncompression.

//
// Initialize a new context structure.
// Use address of structure as argument.
//
#define SCCA_CONTEXT_INIT(c)  { memset((LPVOID)c, 0, sizeof(SCCA_CONTEXT)); }

//
// To call this function, create a SCCA_CONTEXT variable, initialize
// it with SCCA_CONTEXT_INIT( ) and pass it's address in the "context"
// argument.  The context structure maintains information that must
// persist between successive calls while processing an Explorer
// selection set.  The structure is also used to collect performance
// data such as error counts and completion status that may be queried
// once the function returns.
//
BOOL ShellChangeCompressionAttribute(HWND hActiveWnd, LPTSTR szNameSpec,
                      LPSCCA_CONTEXT context, BOOL bCompress, BOOL bShowUI);

#define SZ_SHCOMPUI_DLLNAME    __TEXT("SHCOMPUI.DLL")

//
// Note:  This must be an ANSI string for GetProcAddress( ).
//
#define SZ_COMPRESS_PROCNAME   "ShellChangeCompressionAttribute"


#endif  // ifdef WINNT

#endif  // ifdef __SHCOMPUI_H


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shellp.h ===
#ifndef _SHELLP_H_
#define _SHELLP_H_

//
// shell private header
//


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)


#ifdef __cplusplus
}
#endif // __cplusplus


#endif // _SHELLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\sherror.h ===
#ifndef _SHERROR_H_
#define _SHERROR_H_



#endif // _SHERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shdocvw.h ===
#ifndef _SHDOCVW_H_
#define _SHDOCVW_H_

//
// Define used for unicode shodcvw.  When shdocvw is fully unicode and no longer
// builds an ansi version this should be removed.

#include <iethread.h>

//
// SHDOCVW private header
//

// #include <shlobj.h> or <shellapi.h> before this to get the right
// SHDOCAPI macro definitions.
//

// value under HKLM\software\microsoft\internet explorer where we cache the platform
#define REGVAL_INTEGRATEDBROWSER    TEXT("IntegratedBrowser")

SHDOCAPI_(int) IEWinMain(LPSTR pszCmdLine, int nCmdShow);

//
// Automation support.
//
SHDOCAPI CDDEAuto_Navigate(BSTR str, HWND *phwnd, long);

SHDOCAPI SHGetIDispatchForFolder(LPCITEMIDLIST pidl, IWebBrowserApp **ppauto);


SHDOCAPI URLQualifyA(LPCSTR pszURL, DWORD dwFlags, LPSTR * ppszOut);
SHDOCAPI URLQualifyW(LPCWSTR pszURL, DWORD dwFlags, LPWSTR * ppszOut);

#ifdef UNICODE
#define URLQualify      URLQualifyW
#else
#define URLQualify      URLQualifyA
#endif

// Flags for URLQualify
#define UQF_GUESS_PROTOCOL          0x00000001  // Try to guess based upon given path ("www.msn.com")
#define UQF_USE_DEFAULT_PROTOCOL    0x00000002  // Resort to default protocol if guess fails
#define UQF_IGNORE_FILEPATHS        0x00000004  // Don't special case file paths
#define UQF_CANONICALIZE            0x00000008  // Canonicalize if a valid URL
#define UQF_AUTOCORRECT             0x00000010  // Try to correct typo's
#define UQF_DEFAULT                 (UQF_GUESS_PROTOCOL | UQF_USE_DEFAULT_PROTOCOL)

// Quick pass to show Splash screens for IE components
SHDOCAPI_(HWND) SHShowSplashScreen(DWORD dwMember); // Which member of family...
SHDOCAPI        SHDismissSplashScreen(HWND hwnd);

SHDOCAPI_(BOOL) GenerateHTMLForDesktop();

#define COMP_TYPE_MASK          0x0000000F  // apply to COMP_TYPE to get the type
#define COMP_UNCHECKED          0x00001000
#define COMP_CHECKED            0x00002000
#define COMP_SELECTED           0x00002000
#define COMP_NOSCROLL           0x00004000


// shared icons. 
// instead of duplicating the icons in a bunch of dll's, we have a few that are shared
#define IDI_HOMEPAGE                    100   // Index:   0

SHDOCAPI_(BOOL) IsFileUrl(LPCSTR psz);
SHDOCAPI_(BOOL) IsFileUrlW(LPCWSTR pcwzUrl);
SHDOCAPI_(BOOL) PathIsFilePath(LPCWSTR lpszPath);

SHDOCAPI_(BOOL) IsErrorUrl(LPCWSTR pwszDisplayName);


// For dwSubstitutions parameter in URLSubstitution() and RegURLSubstitution().
#define URLSUB_CLSID        0x00000001
#define URLSUB_PRD          0x00000002   // Product IE (Example: "ie")
#define URLSUB_PVER         0x00000004   // Product Version (Example: "4.0")
#define URLSUB_OS           0x00000008   // System OS, same as header
#define URLSUB_RFC1766      0x00000010   // Human readable LCID (Example: "en-us")
#define URLSUB_ALL          0xFFFFFFFF

SHDOCAPI  URLSubLoadString(HINSTANCE hInst, UINT idRes, LPWSTR pszUrlOut, 
                                DWORD cchSizeOut, DWORD dwSubstitutions);

SHDOCAPI_(void) SHInitRoot(IETHREADPARAM* piei);

SHDOCAPI URLSubstitution(LPCWSTR pszUrlIn, LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);

SHDOCAPI_(IStream *) OpenPidlOrderStream(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidl, LPCSTR pszKey, DWORD grfMode);
SHDOCAPI DragDrop(HWND hwnd, IShellFolder * psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD *pdwEffect) ;
SHDOCAPI_(int) IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int *piSelectedImage);
SHDOCAPI_(void) IEInvalidateImageList(void);
SHDOCAPI_(BOOL) ILIsWeb(LPCITEMIDLIST pidl);
SHDOCAPI_(BOOL) IsURLChild(LPCITEMIDLIST pidl, BOOL fIncludeHome);
SHDOCAPI IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut);
SHDOCAPI IEParseDisplayName(UINT uiCP, LPCTSTR pszPath, LPITEMIDLIST * ppidlOut);
SHDOCAPI IEBindToObjectEx(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
SHDOCAPI IEBindToObject(LPCITEMIDLIST pidl, IShellFolder **ppsfOut);
SHDOCAPI IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs);
SHDOCAPI IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pszName, UINT uFlags);
SHDOCAPI IEGetNameAndFlags(LPCITEMIDLIST pidl, UINT uFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs);
SHDOCAPI_(BOOL) IEILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fIgnoreHidden);
SHDOCAPI IECreateFromPathCPWithBCA(UINT uiCP, LPCSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut);
SHDOCAPI IECreateFromPathCPWithBCW(UINT uiCP, LPCWSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut);

#define IEParseDisplayNameW(uiCP, pwszPath, ppidlOut)       IEParseDisplayNameWithBCW(uiCP, pwszPath, NULL, ppidlOut)
#define IECreateFromPathA(pszPath, ppidlOut) IECreateFromPathCPWithBCA(CP_ACP, pszPath, NULL, ppidlOut)
#define IECreateFromPathW(pszPath, ppidlOut) IECreateFromPathCPWithBCW(CP_ACP, pszPath, NULL, ppidlOut)

#ifdef UNICODE
#define IECreateFromPathCPWithBC            IECreateFromPathCPWithBCW
#define IECreateFromPath(pszPath, ppidlOut) IECreateFromPathCPWithBC(CP_ACP, pszPath, NULL, ppidlOut)
#else // UNICODE 
#define IECreateFromPathCPWithBC            IECreateFromPathCPWithBCA
#define IECreateFromPath(pszPath, ppidlOut) IECreateFromPathCPWithBC(CP_ACP, pszPath, NULL, ppidlOut)
#endif // UNICODE



SHDOCAPI CreateShortcutInDirA(IN LPCITEMIDLIST pidlTarget, IN LPSTR pszTitle, IN LPCSTR pszDir, 
                    OUT LPSTR pszOut, IN BOOL bUpdateProperties);
SHDOCAPI CreateShortcutInDirW(IN LPCITEMIDLIST pidlTarget, IN LPWSTR pwzTitle, IN LPCWSTR pwzDir, 
                    OUT LPWSTR pwzOut, IN BOOL bUpdateProperties);

#ifndef UNICODE
#define CreateShortcutInDir         CreateShortcutInDirA
#else
#define CreateShortcutInDir         CreateShortcutInDirW
#endif

SHDOCAPI_(void) IECleanUpAutomationObject();
SHDOCAPI_(void) IEOnFirstBrowserCreation(IUnknown* punkAuto);
SHDOCAPI_(BOOL) IEDDE_WindowDestroyed(HWND hwnd);
SHDOCAPI_(BOOL) IEDDE_NewWindow(HWND hwnd);

SHDOCAPI _GetStdLocation(LPWSTR pszPath, DWORD cchPathSize, UINT id);

SHDOCAPI SHCreateStreamWrapperCP(IStream *aStreams[], UINT cStreams, DWORD grfMode, UINT uiCodePage, IStream **ppstm);

#define DVIDM_GOHOME         (FCIDM_SHVIEWFIRST + 0x10E)

/// Browser command ids
//---------------------------------------------------------------------------


/// pre-merged browser menu command ids
///--------------------------------------------------------------------------
#define DVIDM_FIRST          (FCIDM_SHVIEWFIRST + 0x100)
#define DVIDM_OPEN           (FCIDM_SHVIEWFIRST + 0x100)
#define DVIDM_SAVE           (FCIDM_SHVIEWFIRST + 0x101)
#define DVIDM_SAVEASFILE     (FCIDM_SHVIEWFIRST + 0x102)
#define DVIDM_PAGESETUP      (FCIDM_SHVIEWFIRST + 0x103)
#define DVIDM_PRINT          (FCIDM_SHVIEWFIRST + 0x104)
#define DVIDM_PROPERTIES     (FCIDM_SHVIEWFIRST + 0x106)
#define DVIDM_CUT            (FCIDM_SHVIEWFIRST + 0x107)
#define DVIDM_COPY           (FCIDM_SHVIEWFIRST + 0x108)
#define DVIDM_PASTE          (FCIDM_SHVIEWFIRST + 0x109)
#define DVIDM_REFRESH        (FCIDM_SHVIEWFIRST + 0x10A)
#define DVIDM_STOPDOWNLOAD   (FCIDM_SHVIEWFIRST + 0x10B)
#define DVIDM_ZOOMIN         (FCIDM_SHVIEWFIRST + 0x10C)
#define DVIDM_ZOOMOUT        (FCIDM_SHVIEWFIRST + 0x10D)
#define DVIDM_GOSEARCH       (FCIDM_SHVIEWFIRST + 0x10F)
#define DVIDM_GOFIRSTHOME    (FCIDM_SHVIEWFIRST + 0x110)
#define DVIDM_GOFIRSTHOMERO  (FCIDM_SHVIEWFIRST + 0x111)
#define DVIDM_GOLOCALPAGE    (FCIDM_SHVIEWFIRST + 0x112)
#define DVIDM_NEWWINDOW      (FCIDM_SHVIEWFIRST + 0x113)
#define DVIDM_DHFAVORITES    (FCIDM_SHVIEWFIRST + 0x114)
#define DVIDM_PRINTPREVIEW   (FCIDM_SHVIEWFIRST + 0x115)
#define DVIDM_PRINTFRAME     (FCIDM_SHVIEWFIRST + 0x116)
#define DVIDM_NEWMESSAGE     (FCIDM_SHVIEWFIRST + 0x117)
#define DVIDM_SEARCHBAR      (FCIDM_SHVIEWFIRST + 0x118)
#define DVIDM_SEND           (FCIDM_SHVIEWFIRST + 0x119)
#define DVIDM_SENDPAGE       (FCIDM_SHVIEWFIRST + 0x11A)
#define DVIDM_SENDSHORTCUT   (FCIDM_SHVIEWFIRST + 0x11B)
#define DVIDM_DESKTOPSHORTCUT (FCIDM_SHVIEWFIRST + 0x11C)
#define DVIDM_SENDTO         (FCIDM_SHVIEWFIRST + 0x140)
#define DVIDM_SENDTOFIRST    (FCIDM_SHVIEWFIRST + 0x141)
#define DVIDM_SENDTOLAST     (FCIDM_SHVIEWFIRST + 0x14f)
#define DVIDM_HELPABOUT      (FCIDM_SHVIEWFIRST + 0x150)
#define DVIDM_HELPSEARCH     (FCIDM_SHVIEWFIRST + 0x151)
#define DVIDM_HELPTUTORIAL   (FCIDM_SHVIEWFIRST + 0x152)
#define DVIDM_HELPREPAIR     (FCIDM_SHVIEWFIRST + 0x153)
#define DVIDM_HELPMSWEB      (FCIDM_SHVIEWFIRST + 0x154)
#define DVIDM_HELPMSWEBLAST  (FCIDM_SHVIEWFIRST + 0x16f)

#define DVIDM_SHOWTOOLS      (FCIDM_SHVIEWFIRST + 0x170)
#define DVIDM_MAILNEWS       (FCIDM_SHVIEWFIRST + 0x171)
#define DVIDM_FONTS          (FCIDM_SHVIEWFIRST + 0x172)
#define DVIDM_EDITPAGE       (FCIDM_SHVIEWFIRST + 0x173)
#define DVIDM_DISCUSSIONS    (FCIDM_SHVIEWFIRST + 0x174)
#define DVIDM_ENCODING       (FCIDM_SHVIEWFIRST + 0x175)

#define DVIDM_IMPORTEXPORT   (FCIDM_SHVIEWFIRST + 0x176)

#define DVIDM_SUITE_APP_FIRST  (FCIDM_SHVIEWFIRST + 0x180)
#define DVIDM_NEW            (DVIDM_SUITE_APP_FIRST + 0x002)
#define DVIDM_NEWPOST        (DVIDM_SUITE_APP_FIRST + 0x003)
#define DVIDM_NEWAPPOINTMENT (DVIDM_SUITE_APP_FIRST + 0x004)
#define DVIDM_NEWMEETING     (DVIDM_SUITE_APP_FIRST + 0x005)
#define DVIDM_NEWCONTACT     (DVIDM_SUITE_APP_FIRST + 0x006)
#define DVIDM_NEWTASK        (DVIDM_SUITE_APP_FIRST + 0x007)
#define DVIDM_NEWTASKREQUEST (DVIDM_SUITE_APP_FIRST + 0x008)
#define DVIDM_NEWJOURNAL     (DVIDM_SUITE_APP_FIRST + 0x009)
#define DVIDM_NEWNOTE        (DVIDM_SUITE_APP_FIRST + 0x00a)
#define DVIDM_CALL           (DVIDM_SUITE_APP_FIRST + 0x00b)
#define DVIDM_SUITE_APP_LAST (DVIDM_SUITE_APP_FIRST + 0x020)

#define DVIDM_NONSUITE_APP_FIRST (FCIDM_SHVIEWFIRST + 0x1B0)
#define DVIDM_NONSUITE_APP_LAST (DVIDM_NONSUITE_APP_FIRST + 0x20)

// large block must be reserved for pre-merged menu
#define DVIDM_MSHTML_FIRST   (FCIDM_SHVIEWFIRST + 0x0400)
#define DVIDM_MSHTML_LAST    (FCIDM_SHVIEWFIRST + 0x1fff)

// Reserve a Block for Tools Menu Extensions
#define DVIDM_MENUEXT_FIRST     (DVIDM_MSHTML_LAST + 1)
#define DVIDM_MENUEXT_LAST      (DVIDM_MENUEXT_FIRST + 0x200)

#define IDS_HELP_FIRST          0x4000
#define IDS_HELP_OF(id)         ((id - DVIDM_FIRST)+IDS_HELP_FIRST)
#define IDS_HELP_OPEN           IDS_HELP_OF(DVIDM_OPEN           )
#define IDS_HELP_SAVE           IDS_HELP_OF(DVIDM_SAVE           )
#define IDS_HELP_SAVEASFILE     IDS_HELP_OF(DVIDM_SAVEASFILE     )
#define IDS_HELP_PAGESETUP      IDS_HELP_OF(DVIDM_PAGESETUP      )
#define IDS_HELP_PRINT          IDS_HELP_OF(DVIDM_PRINT          )
#define IDS_HELP_PROPERTIES     IDS_HELP_OF(DVIDM_PROPERTIES     )
#define IDS_HELP_CUT            IDS_HELP_OF(DVIDM_CUT            )
#define IDS_HELP_COPY           IDS_HELP_OF(DVIDM_COPY           )
#define IDS_HELP_PASTE          IDS_HELP_OF(DVIDM_PASTE          )
#define IDS_HELP_STOPDOWNLOAD   IDS_HELP_OF(DVIDM_STOPDOWNLOAD   )
#define IDS_HELP_REFRESH        IDS_HELP_OF(DVIDM_REFRESH        )
#define IDS_HELP_GOHOME         IDS_HELP_OF(DVIDM_GOHOME         )
#define IDS_HELP_GOSEARCH       IDS_HELP_OF(DVIDM_GOSEARCH       )
#define IDS_HELP_NEWWINDOW      IDS_HELP_OF(DVIDM_NEWWINDOW      )
#define IDS_HELP_PRINTPREVIEW   IDS_HELP_OF(DVIDM_PRINTPREVIEW   )
#define IDS_HELP_PRINTFRAME     IDS_HELP_OF(DVIDM_PRINTFRAME     )
#define IDS_HELP_NEWMESSAGE     IDS_HELP_OF(DVIDM_NEWMESSAGE     )
#define IDS_HELP_DHFAVORITES    IDS_HELP_OF(DVIDM_DHFAVORITES    )
#define IDS_HELP_HELPABOUT      IDS_HELP_OF(DVIDM_HELPABOUT      )
#define IDS_HELP_HELPSEARCH     IDS_HELP_OF(DVIDM_HELPSEARCH     )
#define IDS_HELP_HELPTUTORIAL   IDS_HELP_OF(DVIDM_HELPTUTORIAL   )
#define IDS_HELP_HELPMSWEB      IDS_HELP_OF(DVIDM_HELPMSWEB      )
#ifndef POSTPOSTSPLIT
#define IDS_HELP_COPYTO         IDS_HELP_OF(DVIDM_COPYTO         )
#define IDS_HELP_MOVETO         IDS_HELP_OF(DVIDM_MOVETO         )
#endif

#define IDS_HELP_NEW            IDS_HELP_OF(DVIDM_NEW            )
#define IDS_HELP_NEWPOST        IDS_HELP_OF(DVIDM_NEWPOST        )
#define IDS_HELP_NEWAPPOINTMENT IDS_HELP_OF(DVIDM_NEWAPPOINTMENT )
#define IDS_HELP_NEWMEETING     IDS_HELP_OF(DVIDM_NEWMEETING     )
#define IDS_HELP_NEWCONTACT     IDS_HELP_OF(DVIDM_NEWCONTACT     )
#define IDS_HELP_NEWTASK        IDS_HELP_OF(DVIDM_NEWTASK        )
#define IDS_HELP_NEWTASKREQUEST IDS_HELP_OF(DVIDM_NEWTASKREQUEST )
#define IDS_HELP_NEWJOURNAL     IDS_HELP_OF(DVIDM_NEWJOURNAL     )
#define IDS_HELP_NEWNOTE        IDS_HELP_OF(DVIDM_NEWNOTE        )
#define IDS_HELP_CALL           IDS_HELP_OF(DVIDM_CALL           )

#define IDS_HELP_SENDTO         IDS_HELP_OF(DVIDM_SENDTO         )
#define IDS_HELP_SENDTOFIRST    IDS_HELP_OF(DVIDM_SENDTOFIRST    )


SHDOCAPI CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                      IUnknown *pSite, IDispatch *pExternalDisp);
SHDOCAPI_(IStream*) SHGetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pszName, LPCWSTR pszStreamMRU, LPCWSTR pszStreams);


// these two MUST be in order because we peek them together
#define WMC_PRIVATE_BASE        (WM_USER + 0x0300)
#define WMC_RESERVED_FIRST      (WMC_PRIVATE_BASE + 0x0000)
#define WMC_RESERVED_LAST       (WMC_PRIVATE_BASE + 0x0002)
#define WMC_FAV_CHANGE          (WMC_PRIVATE_BASE + 0x0003)
#define WMC_REMOTENAV           (WMC_PRIVATE_BASE + 0x0004)
#define WMC_DISPATCH            (WMC_PRIVATE_BASE + 0x0005)
#ifndef POSTPOSTSPLIT
#define WMC_GETTHISPTR          (WMC_PRIVATE_BASE + 0x0006)
#endif
#define WMC_ACTIVATE            (WMC_PRIVATE_BASE + 0x0007)
#define WMC_MARSHALIDISPATCH    (WMC_PRIVATE_BASE + 0x0008)
#define WMC_MARSHALIDISPATCHSLOW (WMC_PRIVATE_BASE + 0x0009)
#define WMC_ONREFRESHTIMER       (WMC_PRIVATE_BASE + 0x000A)

// WMC_DISPATCH #defines
#define DSID_NAVIGATEIEBROWSER  1
#define DSID_GETLOCATIONURL     2
#define DSID_GETLOCATIONTITLE   3
#define DSID_GETHWND            4
#define DSID_CANCEL             5
#define DSID_EXIT               6
#define DSID_NOACTION           7

//Functions exported by shdocvw and used by browseui
SHDOCAPI_(BOOL) IsIEDefaultBrowser(void);
SHDOCAPI_(void) _DeletePidlDPA(HDPA hdpa);
SHDOCAPI IURLQualify(LPCWSTR pcszURL, DWORD  dwFlags,LPWSTR  pszTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);

SHDOCAPI_(BOOL) ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
#ifdef UNICODE
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceW 
#else
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceA 
#endif


//
// Packages both the url and transaction id into one parameter
// to pass as a message.
//
typedef struct tagDDENAVIGATESTRUCT
{
    LPWSTR wszUrl;
    long transID;
} DDENAVIGATESTRUCT;

SHDOCAPI WinList_NotifyNewLocation(IShellWindows* psw, long dwRegister, LPCITEMIDLIST pidl);
SHDOCAPI WinList_FindFolderWindow(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, HWND *phwnd, IWebBrowserApp** ppauto);
SHDOCAPI_(IShellWindows*) WinList_GetShellWindows(BOOL fForceNew);
SHDOCAPI WinList_RegisterPending(DWORD dwThread, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, long *pdwRegister);
SHDOCAPI WinList_Revoke(long dwRegister);
SHDOCAPI WinList_OnActivate(IShellWindows* psw, long dwRegister, BOOL fActivate, LPCITEMIDLIST pidl);

SHDOCAPI SHMapNbspToSp(LPCWSTR lpwszIn, LPSTR lpszOut, int cbszOut);

SHDOCAPI_(BOOL) SHIsGlobalOffline(void);
SHDOCAPI_(DWORD) SHRestricted2A(BROWSER_RESTRICTIONS rest, LPCSTR pszUrl, DWORD dwReserved);
SHDOCAPI_(DWORD) SHRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);
SHDOCAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest);
SHDOCAPI_(BOOL) SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);
SHDOCAPI_(void)    DetectAndFixAssociations();
SHDOCAPI_(void)    EnsureWebViewRegSettings();

#ifdef UNICODE
#define UrlHitsNet UrlHitsNetW
#endif

SHDOCAPI_(BOOL) UrlHitsNetW(LPCWSTR pszURL);
#ifdef UNICODE
#define SHRestricted2     SHRestricted2W
#else // UNICODE
#define SHRestricted2     SHRestricted2A
#endif // UNICODE


/// event firing helper functions
//
// FireEvent_XXX functions do a bunch of the work of firing an event.
// punk points to the object that contains the connection point
// that you want to fire the event from. The hwnd parameter is for DDE.
//


SHDOCAPI_(void) FireEvent_BeforeNavigate(IUnknown* punk, HWND hwnd, IWebBrowser2* pwb2,
        LPCITEMIDLIST pidl,LPWSTR pwzLocation,
        DWORD dwFlags,LPWSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPWSTR pszHeaders,BOOL * pfCancel);

SHDOCAPI_(void) FireEvent_NewWindow(IUnknown* punk, HWND hwnd,
        LPCITEMIDLIST pidl,LPWSTR pwzLocation,
        DWORD dwFlags,LPWSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPWSTR pszHeaders,BOOL * pfProcessed);

SHDOCAPI_(void) FireEvent_NewWindow2(IUnknown* punk, IUnknown ** ppunkNewWindow, BOOL* pfCancel);
SHDOCAPI_(void) FireEvent_NavigateComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl, HWND hwnd);
SHDOCAPI_(void) FireEvent_DocumentComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl);
SHDOCAPI_(void) FireEvent_DoInvokeString(IExpDispSupport* peds, DISPID dispid, LPSTR psz);
SHDOCAPI_(void) FireEvent_DoInvokeStringW(IExpDispSupport* peds, DISPID dispid, LPWSTR psz);
SHDOCAPI_(void) FireEvent_DoInvokeDispid(IUnknown* punk, DISPID dispid);
SHDOCAPI_(void) FireEvent_DoInvokeDwords(IExpDispSupport* peds, DISPID dispid,DWORD dw1,DWORD dw2);
SHDOCAPI_(void) FireEvent_DoInvokeBstr(IUnknown* punk, DISPID dispid, BSTR bstr);
SHDOCAPI_(void) FireEvent_Quit(IExpDispSupport* peds);
SHDOCAPI_(void) FireEvent_OnAdornment(IUnknown* punk, DISPID dispid, VARIANT_BOOL f);


#define IDP_START       0
#define IDP_SEARCH      1
#define IDP_UPDATE      2
#define IDP_CHANNELGUIDE  3
SHDOCAPI SHDGetPageLocation(HWND hwndOwner, UINT idp, LPWSTR pszPath, UINT cchMax, LPITEMIDLIST *ppidlOut);

SHDOCAPI SHGetHistoryPIDL(LPITEMIDLIST *ppidlHistory);
SHDOCAPI_(UINT) SHIEErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCWSTR pszURLparam,
                    UINT idResource, UINT wFlags);

// pszClient values:
#define MAIL_DEF_KEY            L"Mail"
#define NEWS_DEF_KEY            L"News"
#define CONTACTS_DEF_KEY        L"Contacts"
#define CALENDAR_DEF_KEY        L"Calendar"
#define TASKS_DEF_KEY           L"Task"
#define JOURNAL_DEF_KEY         L"Journal"
#define NOTES_DEF_KEY           L"Note"
#define CALL_DEF_KEY            L"Internet Call"

SHDOCAPI_(BOOL) SHIsRegisteredClient(LPCWSTR pszClient);

// stopgap export for shell32\unicpp\dcomp.cpp
SHDOCAPI NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow);
SHDOCAPI NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow);
#ifdef UNICODE
#define NavToUrlUsingIE     NavToUrlUsingIEW
#else // UNICODE
#define NavToUrlUsingIE     NavToUrlUsingIEA
#endif // UNICODE

/// shared icons that browseUI grabs from shdocvw.
// we leave them in shdocvw instead of moving them for back compat.
// folks may have relied upon the icons in the dll for their shortcuts.
// (do we care?)
#define IDI_OFFLINE                     105   //          5
#define IDI_STATE_NORMAL                110
#define ICO_TREEUP                      204
#define ICO_GLEAM                       205



// stopgap export for shell32\unicpp\dcomp.cpp
SHDOCAPI UseDefaultAutoComplete(HWND hwndEdit,
                               IBrowserService * pbs,          IN  OPTIONAL
                               IAutoComplete ** ppac,          OUT OPTIONAL
                               IShellService ** ppssACLISF,    OUT OPTIONAL
                               BOOL fUseCMDMRU);

// stopgap export for shell32\unicpp\dcomp.cpp, deskstat.cpp


#define JITCOCREATEINSTANCE_ORD 209
SHDOCAPI JITCoCreateInstance(
    REFCLSID rclsid, 
    IUnknown *pUnkOuter,
    DWORD dwClsContext, 
    REFIID riid, 
    LPVOID FAR* ppv,
    HWND hwndParent,
    DWORD dwJitFlags
);


SHDOCAPI_(void) TLTransferToThreadMemlist(struct ITravelLog *, DWORD);

SHDOCAPI_(BOOL) DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir);
SHDOCAPI_(BOOL) DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir);

#define NAVCANCELLED_URL                 TEXT("about:NavigationCanceled")
#define OFFLINEINFO_URL                  TEXT("about:OfflineInformation")
#define FOLDERBROWSINGINFO_URL           TEXT("about:FolderBrowsing")

#define SEARCH_SETTINGS_CHANGEDW         L"SearchSettingsChanged"
#define SEARCH_SETTINGS_CHANGEDA         "SearchSettingsChanged"

#ifdef UNICODE
#define SEARCH_SETTINGS_CHANGED          SEARCH_SETTINGS_CHANGEDW
#else
#define SEARCH_SETTINGS_CHANGED          SEARCH_SETTINGS_CHANGEDA
#endif

SHDOCAPI_(VARIANT_BOOL) UseCustomInternetSearch();
SHDOCAPI_(BOOL) GetSearchAssistantUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize);
SHDOCAPI_(BOOL) GetDefaultInternetSearchUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute);
SHDOCAPI_(BOOL) GetSearchAssistantUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize);
SHDOCAPI_(BOOL) GetDefaultInternetSearchUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute);

#ifdef UNICODE
#define GetSearchAssistantUrl GetSearchAssistantUrlW
#define GetDefaultInternetSearchUrl GetDefaultInternetSearchUrlW
#else
#define GetSearchAssistantUrl GetSearchAssistantUrlA
#define GetDefaultInternetSearchUrl GetDefaultInternetSearchUrlA
#endif

typedef enum
{
    ILS_ADDTOFAV = 0,
    ILS_LINK     = 1,
    ILS_HOME     = 2,
    ILS_NAVIGATE = 3,
}ILS_ACTION;

SHDOCAPI_(BOOL) IEIsLinkSafe(HWND hwnd, LPCITEMIDLIST pidl, ILS_ACTION ilsFlag);

#endif // _SHDOCVW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shguidp.h ===
//
// CLSIDs of shell object classes. They don't have to be in a public header
// unless we decided to let ISVs to create shell objects directly by calling
// OleCreateInstance with one of class IDs.
//
// NOTE: those that are commented out are ready to be used again...
//

DEFINE_GUID(CLSID_NetworkRoot,          0x953d732d, 0xab45, 0x11d2, 0x84, 0xe0, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);// {953D732D-AB45-11d2-84E0-00C04FA31A86}

DEFINE_GUID(GUID_SystemPidlChange,      0x210A4BA0, 0x3AEA, 0x1069, 0xA2,0xD9,0x08,0x00,0x2B,0x30,0x30,0x9D);//210A4BA0-3AEA-1069-A2D9-08002B30309D

// DEFINE_GUID(CLSID_,                  0x21444760, 0x3AEA, 0x1069, 0xA2,0xDA,0x08,0x00,0x2B,0x30,0x30,0x9D);//21444760-3AEA-1069-A2DA-08002B30309D
DEFINE_GUID(CLSID_ShellCopyHook,        0x217FC9C0, 0x3AEA, 0x1069, 0xA2,0xDB,0x08,0x00,0x2B,0x30,0x30,0x9D);//217FC9C0-3AEA-1069-A2DB-08002B30309D
DEFINE_GUID(CLSID_ShellFileDefExt,      0x21B22460, 0x3AEA, 0x1069, 0xA2,0xDC,0x08,0x00,0x2B,0x30,0x30,0x9D);//21B22460-3AEA-1069-A2DC-08002B30309D
DEFINE_GUID(CLSID_ShellDrvDefExt,       0x5F5295E0, 0x429F, 0x1069, 0xA2,0xE2,0x08,0x00,0x2B,0x30,0x30,0x9D);//5F5295E0-429F-1069-A2E2-08002B30309D
DEFINE_GUID(CLSID_ShellNetDefExt,       0x86422020, 0x42A0, 0x1069, 0xA2,0xE5,0x08,0x00,0x2B,0x30,0x30,0x9D);//86422020-42A0-1069-A2E5-08002B30309D
DEFINE_GUID(CLSID_CCommonShellExtInit,  0xA2AD3100, 0x3B84, 0x1069, 0xA2,0xDF,0x08,0x00,0x2B,0x30,0x30,0x9D);//A2AD3100-3B84-1069-A2DF-08002B30309D
DEFINE_GUID(CLSID_Briefcase,            0x85BBD920, 0x42A0, 0x1069, 0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);//85BBD920-42A0-1069-A2E4-08002B30309D
DEFINE_GUID(CLSID_BriefcaseFolder,      0x86747AC0, 0x42A0, 0x1069, 0xA2,0xE6,0x08,0x00,0x2B,0x30,0x30,0x9D);//86747AC0-42A0-1069-A2E6-08002B30309D
DEFINE_GUID(CLSID_Clouds,               0x869DADA0, 0x42A0, 0x1069, 0xA2,0xE7,0x08,0x00,0x2B,0x30,0x30,0x9D);//869DADA0-42A0-1069-A2E7-08002B30309D   // secret credits object
DEFINE_GUID(CLSID_ExeDropTarget,        0x86C86720, 0x42A0, 0x1069, 0xA2,0xE8,0x08,0x00,0x2B,0x30,0x30,0x9D);//86C86720-42A0-1069-A2E8-08002B30309D
DEFINE_GUID(CLSID_PifProperties,        0x86F19A00, 0x42A0, 0x1069, 0xA2,0xE9,0x08,0x00,0x2B,0x30,0x30,0x9D);//86F19A00-42A0-1069-A2E9-08002B30309D   // pifprops


DEFINE_GUID(CLSID_Remote,               0x992CFFA0, 0xF557, 0x101A, 0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);
DEFINE_GUID(CLSID_ShellFindExt,         0x61E218E0, 0x65D3, 0x101B, 0x9F,0x08,0x06,0x1C,0xEA,0xC3,0xD5,0x0D);//61E218E0-65D3-101B-9F08-061CEAC3D50D
// {169A0691-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(CLSID_ShellSearchExt,       0x169a0691, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);
// {07798131-AF23-11d1-9111-00A0C98BA67D}
DEFINE_GUID(CLSID_WebSearchExt,         0x7798131, 0xaf23, 0x11d1, 0x91, 0x11, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

DEFINE_GUID(CLSID_CFonts,               0xBD84B380, 0x8CA2, 0x1069, 0xAB,0x1D,0x08,0x00,0x09,0x48,0xF5,0x34);//bd84b380-8ca2-1069-ab1d-08000948f534
DEFINE_GUID(CLSID_CmdFileIcon,          0x57651662, 0xCE3E, 0x11D0, 0x8D,0x77,0x00,0xC0,0x4F,0xC9,0x9D,0x61);//57651662-CE3E-11D0-8D77-00C04FC99D61

DEFINE_GUID(CLSID_CDocObjectFolder,     0xE7E4BC40, 0xE76A, 0x11CE, 0xA9,0xBB,0x00,0xAA,0x00,0x4A,0xE8,0x37);//E7E4BC40-E76A-11CE-A9BB-00AA004AE837

DEFINE_GUID(CLSID_CSiteMapEmbedding,    0x438C0EA0, 0x5731, 0x11CF, 0x9A,0xF8,0x00,0x20,0xAF,0x73,0xAD,0x51);
DEFINE_GUID(CLSID_CSiteMapNode,         0xA61D5780, 0xBA29, 0x11CF, 0x95,0x2E,0x00,0xC0,0x4F,0xD7,0x05,0xB4);// A61D5780-BA29-11CF-952E-00C04FD705B4

DEFINE_GUID(IID_IDefViewBrowser,        0x9692C5C0, 0x7C21, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);

DEFINE_GUID(CLSID_CShellHlinkFrame,     0x2C5A8FC0, 0x8401, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);// 2C5A8FC0-8401-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellFrameAuto,      0x20C46560, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);// 20C46560-8491-11CF-960C-0080C7F4EE85

DEFINE_GUID(CLSID_CStubBindStatusCallback, 
                                        0x2B4F54B1, 0x3D6D, 0x11d0, 0x82, 0x58, 0x00, 0xC0, 0x4F, 0xD5, 0xAE, 0x38);// 2B4F54B1-3D6D-11d0-8258-00C04FD5AE38

// This is a hack to allow the explorer to use more of the same implemention of the
// frame automation from SHDocvw (what was used for IExplorer

DEFINE_GUID(IID_IExpDispSupport,        0x0D7D1D00, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D00-6FC0-11D0-A974-00C04FD705A2
DEFINE_GUID(IID_IExpDispSupportOC,      0x0D7D1D01, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D01-6FC0-11D0-A974-00C04FD705A2

// {E770AD23-7346-11d1-8AEE-00C04FC9E26E}
DEFINE_GUID(IID_IWebViewOCWinMan, 0xe770ad23, 0x7346, 0x11d1, 0x8a, 0xee, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {BB90CD8B-4F08-11d0-B497-00C04FD90119}
DEFINE_GUID(IID_IShellHTMLWindowSupport,0xbb90cd8bL, 0x4f08, 0x11d0, 0xb4, 0x97, 0x00, 0xc0, 0x4f, 0xd9, 0x01, 0x19);

/// IAddressList
// {D7E67AA1-AA76-11d0-8282-00AA005B4383}
DEFINE_GUID(IID_IAddressList,           0xd7e67aa1, 0xaa76, 0x11d0, 0x82, 0x82, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

#if 0
// The old IMRU interface used by IE4.  This interface was not accessible
// to outside components, so I'm #if'ing it out completely, but I left it
// in the header so at least we'll recognize it if we see it again.
// {D095EB91-A7B2-11d0-8274-00AA005B4383}
DEFINE_GUID(IID_IMRU_IE4,               0xd095eb91, 0xa7b2, 0x11d0, 0x82, 0x74, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
#endif

// {1011fa30-69da-11d2-8599-006097df8c11}
DEFINE_GUID(IID_IMRU,                   0x1011fa30, 0x69da, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

/// IBandProxy
// {208CE801-754B-11d0-80CA-00AA005B4383}
DEFINE_GUID(IID_IBandProxy,             0x208ce801, 0x754b, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
DEFINE_GUID(SID_IBandProxy,             0x80243ac1, 0x569, 0x11d1, 0xa7, 0xae, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

/// INSCTree
// {43A8F463-4222-11d2-B641-006097DF5BD4}
DEFINE_GUID(CLSID_NSCTree,              0x43a8f463, 0x4222, 0x11d2, 0xb6, 0x41, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(IID_INSCTree,               0x43a8f463, 0x4222, 0x11d2, 0xb6, 0x41, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// { 0x4434FF80L, 0xEF4C, 0x11CE, { 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62 } };
DEFINE_GUID(IID_CDefView,               0x4434FF80, 0xEF4C, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62 );


// This is Semi-gross, but if the IShellFolder can be agregated, there are times we need to get
// back to the real inner class.  So we create an internal GUID which we use to QueryInterface for
// which hopefully the outer object will allow through...
// ABCB3A00-1B2B-11CF-A49F-444553540000
DEFINE_GUID(IID_INeedRealCFSFolder,     0xABCB3A00, 0x1B2B, 0x11CF, 0xA4, 0x9F, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

// New MSIE FTP UI from msieftp.dll
DEFINE_GUID(CLSID_FtpFolder,            0x63da6ec0, 0x2e98, 0x11cf, 0x8d,0x82,0x44,0x45,0x53,0x54,0,0);

// Xbox Remote UI from xbnmspc.dll
DEFINE_GUID(CLSID_XboxFolder,           0x9FA6C2C0, 0x852C, 0x4aed, 0x8C, 0xeb, 0xc8,0xff,0xea, 0xbf,0x79, 0x21);

//
// this interface is used by DefView when it wants to run a script in one
// of its extended views.  the actual script triggers currently live in shdisp
//
// 4706B500-09EF-11D0-99CB-00C04FD64497
DEFINE_GUID(IID_IDefViewScript,         0x4706B500L, 0x09EF, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


DEFINE_GUID(IID_IObjectCache,           0xEA5F2D60L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);   // ;internal

DEFINE_GUID(SID_SDesktopExtMenu,        0x6F272F90L, 0x2380, 0x11D0, 0x89, 0xB9, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);

// 20C46561-8491-11CF-960C-0080C7F4EE85 
// this is who should navigate instead
DEFINE_GUID(SID_SProxyBrowser,          0x20C46561L, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);

//***   SID_STopFrameBrowser -- like SID_STopLevelBrowser, but blocked by BrowserBand
// currently used to make BrowserBand get its own global history, but could
// be more generally useful than that, hence the more generic name.
// {A9227C3C-7F8E-11d0-8CB0-00A0C92DBFE8}
DEFINE_GUID(SID_STopFrameBrowser,       0xa9227c3c, 0x7f8e, 0x11d0, 0x8c, 0xb0, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

DEFINE_GUID(SID_PendingBindStatusCallback, 0xfe390c68, 0xe2bc, 0x11d0, 0x88, 0x8c, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);

// this is used in shdocvw's CConnectionPoint implementation
// to let CShellOcx type OCs get advised of Advise/Unadvise
// calls to the connection point. CShellFolderViewOC uses it.
//
DEFINE_GUID(IID_IConnectionPointCB,     0xAAAC9640L, 0x1252, 0x11D0, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);
DEFINE_GUID(IID_IDelegateDropTargetCB,  0xbefd347e, 0xc7ec, 0x11d0, 0xb9, 0x3b, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);


// this defines the deskbar and also id's for each of the toolbands that we implement
//ECD4FC4C-521C-11D0-B792-00A0C90312E1
DEFINE_GUID(CLSID_DeskBar,              0xECD4FC4CL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_RebarBandSite,        0xECD4FC4DL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_BandSiteMenu,         0xECD4FC4EL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_MenuDeskBar,          0xECD4FC4FL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {40B96610-B522-11d1-B3B4-00AA006EFDE7}
DEFINE_GUID(CLSID_MenuToolbarBase,      0x40b96610, 0xb522, 0x11d1, 0xb3, 0xb4, 0x0, 0xaa, 0x0, 0x6e, 0xfd, 0xe7);

// {D1E7AFEA-6A2E-11d0-8C78-00C04FD918B4}
DEFINE_GUID(IID_IBandSiteHelper,        0xd1e7afea, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);
DEFINE_GUID(IID_IMenuPopup,             0xd1e7afeb, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);
#define SID_SMenuPopup IID_IMenuPopup

DEFINE_GUID(SID_SMenuBandTop,           0x9493a810, 0xec38, 0x11d0, 0xbc, 0x46, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);
DEFINE_GUID(SID_SMenuBandBottom,        0x743ca664, 0xdeb, 0x11d1, 0x98, 0x25, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
DEFINE_GUID(SID_SMenuBandChild,         0xed9cc020, 0x8b9, 0x11d1, 0x98, 0x23, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
DEFINE_GUID(SID_SMenuBandParent,         0x8c278eec, 0x3eab, 0x11d1, 0x8c, 0xb0, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
// {165EBAF4-6D51-11d2-83AD-00C04FD918D0}
DEFINE_GUID(SID_SMenuBandBottomSelected, 0x165ebaf4, 0x6d51, 0x11d2, 0x83, 0xad, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// NOTE!  Different from the IID_ITranslateShellChangeNotify in IE4x and IE5.0
// {B4DF2675-BA23-11d2-B5EE-006097C686F6}
DEFINE_GUID(IID_ITranslateShellChangeNotify, 0xb4df2675, 0xba23, 0x11d2, 0xb5, 0xee, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

DEFINE_GUID(SID_ITopViewHost,           0xd1e7afec, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

// {3CCF8A41-5C85-11d0-9796-00AA00B90ADF}
DEFINE_GUID(CLSID_DeskBarApp,           0x3ccf8a41, 0x5c85, 0x11d0, 0x97, 0x96, 0x0, 0xaa, 0x0, 0xb9, 0xa, 0xdf);

// {9581015C-D08E-11d0-8D36-00A0C92DBFE8}
DEFINE_GUID(CLSID_BrowserBar,           0x9581015c, 0xd08e, 0x11d0, 0x8d, 0x36, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// The IShellFolder band pointing to c:\band
// D82BE2B0-5764-11D0-A96E-00C04FD705A2
DEFINE_GUID(CLSID_ISFBand,              0xD82BE2B0L, 0x5764, 0x11D0, 0xA9, 0x6E, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// explorer band
// {EFA24E64-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ExplorerBand,         0xefa24e64, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// The thumbnail view extension
// {8BEBB290-52D0-11d0-B7F4-00C04FD706EC}
DEFINE_GUID(CLSID_ThumbnailViewExt,     0x8bebb290, 0x52d0, 0x11d0, 0xb7, 0xf4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// The Favorites Shell extension
// for 1A9BA3A0-143A-11CF-8350-444553540000
DEFINE_GUID(CLSID_FavoritesFolder,      0x1A9BA3A0, 0x143A, 0x11CF, 0x83, 0x50, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 );

// the Task band (for the tray).
// n.b. while we have a CLSID, we can't actually CoCreateInst it
// we fake it in tray's IBandSiteHelper implementation.
// {68284FAA-6A48-11d0-8C78-00C04FD918B4}
DEFINE_GUID(CLSID_TaskBand,             0x68284faa, 0x6a48, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

// URL Shell Execute Hook for IE4
// {AEB6717E-7E19-11d0-97EE-00C04FD91972}
DEFINE_GUID(CLSID_URLExecHook,          0xaeb6717e, 0x7e19, 0x11d0, 0x97, 0xee, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// MIME-enabled File Types Hook for browser-only installs
DEFINE_GUID(CLSID_MIMEFileTypesHook,    0xFBF23B41L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

// Cache Shell Folder
DEFINE_GUID(CLSID_CacheFolder,          0x7BD29E00L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);

// History Shell Folder
DEFINE_GUID(CLSID_HistFolder,           0xFF393560L, 0xC2A7, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

//  Cache Shellfolder Item private interface
DEFINE_GUID (IID_IHistCache,            0xF7FE8CA0L, 0xEC5A, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID (IID_IHist,                 0x06faeb04L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
DEFINE_GUID (IID_ICache,                0x06faeb05L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
// {C7A30296-907E-11d2-B02F-00C04FA35D89}
DEFINE_GUID(IID_IUrlHistoryPriv,        0xc7a30296, 0x907e, 0x11d2, 0xb0, 0x2f, 0x0, 0xc0, 0x4f, 0xa3, 0x5d, 0x89);


DEFINE_GUID(IID_IDocNavigate,           0x131A6950L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// navigate band UI from pidl
DEFINE_GUID(IID_IBandNavigate,          0x3697c30b, 0xcd88, 0x11d0, 0x8a, 0x3e, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

DEFINE_GUID(CLSID_ChannelOC,            0x131A6951L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);
DEFINE_GUID(CLSID_OrderListExport,      0xf3368374, 0xcf19, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
DEFINE_GUID(IID_IOrderList,             0x8bfcb27d, 0xcf1a, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

DEFINE_GUID(IID_IEFrameAuto,            0x131A6953L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

//Command Group ID for MenuDeskBar
// {5C9F0A12-959E-11d0-A3A4-00A0C9082636}
DEFINE_GUID(CGID_MENUDESKBAR,0x5c9f0a12, 0x959e, 0x11d0, 0xa3, 0xa4, 0x0, 0xa0, 0xc9, 0x8, 0x26, 0x36);
//3531F060-22B3-11D0-969E-00AA00B60104
// used when communicating with the Internet Toolbar. 
DEFINE_GUID(CGID_ShellBrowser, 0x3531F060L, 0x22B3, 0x11D0, 0x96, 0x9E, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 );

// {FFB4B000-9FAB-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(VID_DefaultCustomWebView, 0xffb4b000, 0x9fab, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

//0F12079C-C193-11D0-8D49-00C04FC99D61
DEFINE_GUID(CGID_Theater, 0x0F12079CL, 0xC193, 0x11D0, 0x8D, 0x49, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

//FB4A79C0-C808-11D0-8D57-00C04FC99D61
DEFINE_GUID(CGID_MenuISF, 0xFB4A79C0L, 0xC808, 0x11D0, 0x8D, 0x57, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// {AFD971E0-C870-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IPrivateOleObject, 0xafd971e0, 0xc870, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {89820200-ECBD-11cf-8B85-00AA005B4383}
DEFINE_GUID(COMPID_IE4, 0x89820200, 0xecbd, 0x11cf, 0x8B, 0x85, 0x00, 0xAA, 0x00, 0x5B, 0x43, 0x83 );

//ffdc1a80-d527-11d0-a32c-34af06c10000
DEFINE_GUID (CLSID_WinListShellProc, 0xffdc1a80, 0xd527, 0x11d0, 0xa3, 0x2c, 0x34, 0xaf, 0x06, 0xc1, 0x00, 0x00);

// {67EA19A0-CCEF-11d0-8024-00C04FD75D13}
DEFINE_GUID(CLSID_CDFCopyHook, 0x67ea19a0, 0xccef, 0x11d0, 0x80, 0x24, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {AF4F6510-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(CLSID_CRegTreeOptions, 0xaf4f6510, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {AF4F6511-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(IID_IRegTreeOptions, 0xaf4f6511, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// Internet Cache Cleaner
// {9B0EFD60-F7B0-11D0-BAEF-00C04FC308C9}
DEFINE_GUID(CLSID_InternetCacheCleaner,     0x9b0efd60, 0xf7b0, 0x11d0, 0xba, 0xef, 0x0, 0xc0, 0x4f, 0xc3, 0x08, 0xc9);

// {8E6E6079-0CB7-11d2-8F10-0000F87ABD16}
DEFINE_GUID(CLSID_OfflinePagesCacheCleaner, 0x8e6e6079, 0xcb7, 0x11d2, 0x8f, 0x10, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {4622AD10-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_ITrayPriv,0x4622ad10, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {4622AD11-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(CLSID_StartMenu,0x4622ad11, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);
#define CLSID_StartMenuBar CLSID_StartMenu 

// {4622AD16-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_IInitializeObject,0x4622ad16, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {596A9A94-013E-11d1-8D34-00A0C90F2719}
DEFINE_GUID(IID_IBanneredBar,0x596a9a94, 0x13e, 0x11d1, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// Interface used to keep channel cache in sync.
DEFINE_GUID(IID_IChannelMgrPriv, 0xc9ace0f0, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);
DEFINE_GUID(IID_IChannelMgrPriv2, 0xc9ace0f1, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);

// {733AC4CB-F1A4-11d0-B951-00A0C90312E1}
DEFINE_GUID(CLSID_CWebViewMimeFilter, 0x733ac4cb, 0xf1a4, 0x11d0, 0xb9, 0x51, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// Disk cleaner for the recycle bin
/* 5ef4af3a-f726-11d0-b8a2-00c04fc309a4 */
DEFINE_GUID(CLSID_RecycleBinCleaner,  0x5ef4af3a, 0xf726, 0x11d0, 0xb8, 0xa2, 0x00, 0xc0, 0x4f, 0xc3, 0x09, 0xa4 );

// {1820FED0-473E-11D0-A96C-00C04FD705A2}
// WARNING: CLSID_CDefViewOC is also stored in shell\shdocvw\selfreg.inx and shell\ext\shwizard\finisha.cpp
//          and D:\nt\private\shell\ext\html\construc\*.htt
DEFINE_GUID(CLSID_CDefViewOC, 0x1820FED0, 0x473E, 0x11D0, 0xA9, 0x6C, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// {B1E437E0-047A-11D1-B833-00C04FC9B31F}
DEFINE_GUID(IID_IDwnCodePage, 0xb1e437e0, 0x047a, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

//Pidl Filtering for Menu Bands.
// {B16C55D1-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(CGID_FilterObject,0xb16c55d1, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {B16C55D3-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(SID_SHostProxyFilter,0xb16c55d3, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {2D3DDFC0-09E1-11d1-BC59-00AA006CE2F5}
DEFINE_GUID(CGID_MenuBandHandler, 0x2d3ddfc0, 0x9e1, 0x11d1, 0xbc, 0x59, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);
// {7376D660-C583-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ImgCtxThumbnailExtractor, 0x7376d660, 0xc583, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {1430A130-103F-11d1-8D45-00A0C90F2719}
DEFINE_GUID(SID_SBandHandler, 0x1430a130, 0x103f, 0x11d1, 0x8d, 0x45, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {21090CB1-103F-11d1-8D45-00A0C90F2719}
DEFINE_GUID(CGID_BandHandler, 0x21090cb1, 0x103f, 0x11d1, 0x8d, 0x45, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {2E420C00-1361-11d1-8D49-00A0C90F2719}
DEFINE_GUID(CGID_Persist, 0x2e420c00, 0x1361, 0x11d1, 0x8d, 0x49, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {DDB008FE-048D-11d1-B9CD-00C04FC2C1D2}
DEFINE_GUID(CLSID_StartMenuTask,    0xddb008fe, 0x48d, 0x11d1, 0xb9, 0xcd, 0x0, 0xc0, 0x4f, 0xc2, 0xc1, 0xd2);

// {E7D3DB4E-199C-11d1-9828-00C04FD91972}
DEFINE_GUID(CLSID_DesktopTask,      0xe7d3db4e, 0x199c, 0x11d1, 0x98, 0x28, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {80D4A420-3167-11d2-BE3C-3078302C2030}
DEFINE_GUID(IID_IShellFolderTask,   0x80d4a420, 0x3167, 0x11d2, 0xbe, 0x3c, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {80D4A41F-3167-11d2-BE3C-3078302C2030}
DEFINE_GUID(IID_IStartMenuTask,     0x80d4a41f, 0x3167, 0x11d2, 0xbe, 0x3c, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {5EA35BC9-19B1-11d1-9828-00C04FD91972}
DEFINE_GUID(IID_IShellHotKey,       0x5ea35bc9, 0x19b1, 0x11d1, 0x98, 0x28, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {8C7461EF-2B13-11d2-BE35-3078302C2030}
DEFINE_GUID(CLSID_ComCatCacheTask,  0x8c7461ef, 0x2b13, 0x11d2, 0xbe, 0x35, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {E56829C9-2D59-11d2-BE38-3078302C2030}
DEFINE_GUID(CLSID_ComCatConditionalCacheTask, 0xe56829c9, 0x2d59, 0x11d2, 0xbe, 0x38, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {83799FE0-1F5A-11d1-95C7-00609797EA4F}
DEFINE_GUID(CLSID_DocFileInfoTip,   0x83799fe0, 0x1f5a, 0x11d1, 0x95, 0xc7, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);

// {5c191fec-2d33-11d1-bd7e-0000f8753a75}
DEFINE_GUID(CGID_MenuBandItem,      0x5c191fec, 0x2d33, 0x11d1, 0xbd, 0x7e, 0x0, 0x00, 0xf8, 0x75, 0x3a, 0x75);

// {0563BC42-4418-11d1-8CB4-00C04FD918D0}
DEFINE_GUID(CGID_MenuBandRestriction, 0x563bc42, 0x4418, 0x11d1, 0x8c, 0xb4, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
#define SID_SMenuBandRestriction CGID_MenuBandRestriction

// {A6C17EB4-2D65-11d2-838F-00C04FD918D0}
DEFINE_GUID(SID_MenuShellFolder,   0xa6c17eb4, 0x2d65, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {B49C1CD0-5256-11d1-8CBB-00C04FD918D0}
DEFINE_GUID(NSID_Menu,             0xb49c1cd0, 0x5256, 0x11d1, 0x8c, 0xbb, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {CE422100-6CE1-11d1-838D-0000F80461CF}
DEFINE_GUID(CLSID_ShellMallocSpy,   0xce422100, 0x6ce1, 0x11d1, 0x83, 0x8d, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// {CE422101-6CE1-11d1-838D-0000F80461CF}
DEFINE_GUID(IID_IShellMallocSpy,    0xce422101, 0x6ce1, 0x11d1, 0x83, 0x8d, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// Defview background task IDs
// {956B35B8-6DCB-11d1-AD2F-00C04FB687DA}
DEFINE_GUID(TOID_DVIconExtract,    0x956b35b8, 0x6dcb, 0x11d1, 0xad, 0x2f, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {76119F10-B9E3-11D1-A7F4-006008059382}
DEFINE_GUID(TOID_DVIconOverlay, 0x76119F10L, 0xB9E3, 0x11D1, 0xA7, 0xF4, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {956B35B9-6DCB-11d1-AD2F-00C04FB687DA}
DEFINE_GUID(TOID_DVBackgroundEnum, 0x956b35b9, 0x6dcb, 0x11d1, 0xad, 0x2f, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// Start Menu.Settings.Folder Options property sheet extension
// {6D5313C0-8C62-11D1-B2CD-006097DF8C11}
DEFINE_GUID(CLSID_ShellFldSetExt,       0x6D5313C0, 0x8C62, 0x11D1, 0xB2,0xCD,0x00,0x60,0x97,0xDF,0x8C,0x11);

// Also used by SHCreateGlobalCounter to count changes to global folder settings
#define GUID_FolderSettingsChange       CLSID_ShellFldSetExt

// Offline Files property sheet extension.  Implemented in cscui.dll.
// {10CFC467-4392-11d2-8DB4-00C04FA31A66}
DEFINE_GUID(CLSID_OfflineFilesOptions, 0x10cfc467, 0x4392, 0x11d2, 0x8d, 0xb4, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x66);

//AF604EFE-8897-11D1-B944-00A0C90312E1
DEFINE_GUID(CLSID_CCommonBrowser, 0xAF604EFEL, 0x8897, 0x11D1, 0xB9, 0x44, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// Currently not used -- will be used when dbapp moves to shell32
// 4AF4A5FC-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(CLSID_CDockingBarPropertyBag, 0x4AF4A5FCL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// 4AF4A5FA-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(IID_IDockingBarPropertyBagInit, 0x4AF4A5FAL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// 438755C2-A8BA-11D1-B96B-00A0C90312E1
DEFINE_GUID(CLSID_BrowseuiPreloader, 0x438755C2L, 0xA8BA, 0x11D1, 0xB9, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {169A0694-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(IID_ISearchProvider,   0x169a0694, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {94FD6891-92CD-11d1-A1C6-00C04FD75D13}
DEFINE_GUID(SRCID_SWebSearch,      0x94fd6891, 0x92cd, 0x11d1, 0xa1, 0xc6, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

#define SRCID_SFileSearch          CLSID_ShellSearchExt

// {996E1EB1-B524-11d1-9120-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindComputer,   0x996e1eb1, 0xb524, 0x11d1, 0x91, 0x20, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {D515F311-B78B-11d1-9123-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindPrinter,    0xd515f311, 0xb78b, 0x11d1, 0x91, 0x23, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

//1E79697E-9CC5-11D1-A83F-00C04FC99D61
DEFINE_GUID(CLSID_CommonButtons, 0x1E79697EL, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

//A48F1A32-A340-11D1-BC6B-00A0C90312E1
DEFINE_GUID(GUID_Restrictions, 0xA48F1A32L, 0xA340, 0x11D1, 0xBC, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// 96a23e16-a1bc-11d1-b084-00c04fc33aa5
DEFINE_GUID(IID_ILVRange,          0x96a23e16L, 0xa1bc, 0x11d1, 0xb0, 0x84, 0x00, 0xc0, 0x4f, 0xc3, 0x3a, 0xa5);

// CLSID whose sole purpose is to let us locate BROWSEUI, wherever it happens to be installed
// ef8ad2d0-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_BROWSEUI,        0xef8ad2d0L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// ef8ad2d1-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_GlobalFolderSettings, 0xef8ad2d1L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// ef8ad2d3-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(IID_IGlobalFolderSettings, 0xef8ad2d3L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// 830abff0-afd9-11d1-b9f1-00a0c98bc547
DEFINE_GUID(IID_ISearchItems,      0x830abff0L, 0xafd9, 0x11d1, 0xb9, 0xf1, 0x00, 0xa0, 0xc9, 0x8b, 0xc5, 0x47);

// {59CA3D02-446B-11d2-85DE-00C04FA35C89}
DEFINE_GUID(IID_ISearchBandTBHelper, 0x59ca3d02, 0x446b, 0x11d2, 0x85, 0xde, 0x0, 0xc0, 0x4f, 0xa3, 0x5c, 0x89);

// {09799AFB-AD67-11d1-ABCD-00C04FC30936}
DEFINE_GUID(CLSID_OpenWithMenu, 0x9799afb, 0xad67, 0x11d1, 0xab, 0xcd, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

// {5B8DCBF0-B096-11d1-9217-00403393B8F0}
DEFINE_GUID(IID_IDocFindControllerNotify, 0x5b8dcbf0, 0xb096, 0x11d1, 0x92, 0x17, 0x0, 0x40, 0x33, 0x93, 0xb8, 0xf0);

// {7febaf7c-18cf-11d2-993f-00a0c91f3880}
DEFINE_GUID(CLSID_DefViewPersistHistory, 0x7febaf7c, 0x18cf, 0x11d2, 0x99, 0x3f, 0x00, 0xa0, 0xc9, 0x1f, 0x38, 0x80);

// {bab33640-1280-11d2-aa30-00a0c91eedba}
DEFINE_GUID(CLSID_DocFindPersistHistory, 0xbab33640, 0x1280, 0x11d2, 0xaa, 0x30, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba);

// {DD313E04-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(CLSID_UserAssist, 0xdd313e04, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// {DD313E05-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(IID_IUserAssist, 0xdd313e05, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// {1ABCFC13-2340-11d2-B601-006097DF5BD4}
DEFINE_GUID(CLSID_FtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(IID_IFtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {5CFCC662-1767-11d2-A222-0000F81FEDEE}
DEFINE_GUID(IID_IFolderShortcutConvert, 0x5cfcc662, 0x1767, 0x11d2, 0xa2, 0x22, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee);

// {E0DD6CAB-2D10-11d2-8F1A-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtBand, 0xe0dd6cab, 0x2d10, 0x11d2, 0x8f, 0x1a, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {37e856d7-3dfd-11d2-bf8b-00c04fb93661}
DEFINE_GUID(IID_IEnumUrlSearch,   0x37e856d7, 0x3dfd, 0x11d2, 0xbf, 0x8b, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

// {23d9b0f1-40fc-11d2-bf8c-00c04fb93661}
DEFINE_GUID(IID_IFolderSearches, 0x23d9b0f1, 0x40fc, 0x11d2, 0xbf, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

// {1FBA04EE-3024-11d2-8F1F-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtExec, 0x1fba04ee, 0x3024, 0x11d2, 0x8f, 0x1f, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {32bb8320-b41b-11cf-a6bb-0080c7b2d682}
DEFINE_GUID(IID_IBrowserExtension, 0x32bb8320, 0xb41b, 0x11cf, 0xa6, 0xbb, 0x0, 0x80, 0xc7, 0xb2, 0xd6, 0x82);

// {3CD141F4-3C6A-11d2-BCAA-00C04FD929DB}
DEFINE_GUID(IID_IAutoCompleteDropDown, 0x3cd141f4, 0x3c6a, 0x11d2, 0xbc, 0xaa, 0x0, 0xc0, 0x4f, 0xd9, 0x29, 0xdb);

// {48123bc4-99d9-11d1-a6b3-00c04fd91555}
DEFINE_GUID(CLSID_XMLViewerDocObj, 0x48123bc4, 0x99d9, 0x11d1, 0xa6, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x55);

// {C0C66348-C440-11d2-9F03-006097C686F6}
DEFINE_GUID(CLSID_FolderShortcutToShortcut, 0xc0c66348, 0xc440, 0x11d2, 0x9f, 0x3, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

// {C8B35474-C440-11d2-9F03-006097C686F6}
DEFINE_GUID(CLSID_ShortcutToFolderShortcut, 0xc8b35474, 0xc440, 0x11d2, 0x9f, 0x3, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

// {BDEADF00-C265-11d0-BCED-00A0C90AB50F}	IID_WebFolders
DEFINE_GUID(CLSID_WebFolders, 0xBDEADF00, 0xC265, 0x11d0, 0xbc, 0xed, 0x0, 0xa0, 0xc9, 0xa, 0xb5, 0x0f);

// map old names to nice names
#define CLSID_CControls         CLSID_ControlPanel
#define CLSID_ShellBitBucket    CLSID_RecycleBin
#define CLSID_ShellDrives       CLSID_MyComputer
#define CLSID_CPrinters         CLSID_Printers
#define CLSID_ShellNetwork      CLSID_NetworkPlaces
#define CLSID_ShellInetRoot     CLSID_Internet

#define CLSID_ShellNetworkDomain    CLSID_NetworkDomain
#define CLSID_ShellNetworkServer    CLSID_NetworkServer
#define CLSID_ShellNetworkShare     CLSID_NetworkShare
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shsemip.h ===
#ifndef _SHSEMIP_H_
#define _SHSEMIP_H_

#ifndef LPNTSTR_DEFINED
#define LPNTSTR_DEFINED

typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;

#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif

#endif // LPNTSTR_DEFINED

#ifndef DONT_WANT_SHELLDEBUG

#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */
#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */
                                                                                /* ;Internal */
#endif



//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef NOPRAGMAS
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//====== Ranges for WM_NOTIFY codes ==================================
// If a new set of codes is defined, make sure the range goes   /* ;Internal */
// here so that we can keep them distinct                       /* ;Internal */
// Note that these are defined to be unsigned to avoid compiler warnings
// since NMHDR.code is declared as UINT.
//
// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)
//
// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)
//
// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)
//
// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)
//
// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define SEN_FIRST       (0U-550U)       // ;Internal
#define SEN_LAST        (0U-559U)       // ;Internal


#ifndef UNIX
#define MAXPATHLEN      MAX_PATH        // ;Internal
#endif

#ifdef UNICODE
#define OTHER_TCHAR_NAME(sz)      sz##A
#else // !UNICODE
#define OTHER_TCHAR_NAME(sz)      sz##W
#endif

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)


//===================================================================
// Smart tiling API's
WINSHELLAPI WORD WINAPI ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND FAR *ahwnd);


/* Avoid multiple typedefs C warnings. Defined in shlapip.h as well. */
#ifndef RUNDLLPROC

typedef void (WINAPI FAR* RUNDLLPROCA)(HWND hwndStub,
        HINSTANCE hAppInstance,
        LPSTR lpszCmdLine, int nCmdShow);

typedef void (WINAPI FAR* RUNDLLPROCW)(HWND hwndStub,
        HINSTANCE hAppInstance,
        LPWSTR lpszCmdLine, int nCmdShow);

#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif
#endif

// Maximum length of a path string
#define CCHPATHMAX      MAX_PATH
#define MAXSPECLEN      MAX_PATH
#define MAX_PATH_URL    INTERNET_MAX_URL_LENGTH
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifndef SIZEOF
#define SIZEOF(a)       sizeof(a)
#endif

#define PathRemoveBlanksORD     33
#define PathFindFileNameORD     34
#define PathFindExtensionORD    31

#ifdef OVERRIDE_SHLWAPI_PATH_FUNCTIONS
// SHLWAPI provides the majority of the Path functions.  There are
// some cases where the shell code (shell32 and explorer) need to
// call a different variation of these calls.  Because of this, we
// have OVERRIDE_SHLWAPI_PATH_FUNCTIONS.  Components such as shdocvw
// should strive to *not* have this defined.
//
// Some reasons why something like shell32 would need this:
//   1)  Shell32 calls some WNet APIs due to the NT merge.  Shlwapi
//       cannot take these.
//   2)  Shell32 needs the unaligned version PathBuildRoot,
//       PathCombine, etc.
//

#undef PathIsDirectory
#undef PathMakePretty

WINSHELLAPI BOOL  WINAPI PathIsDirectory(LPCTSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathMakePretty(LPTSTR lpszPath);

#endif // OVERRIDE_SHLWAPI_PATH_FUNCTIONS


WINSHELLAPI void  WINAPI ExitWindowsDialog(HWND hwnd);
WINSHELLAPI void  WINAPI LogoffWindowsDialog(HWND hwnd);
WINSHELLAPI BOOL  WINAPI IsSuspendAllowed(void);

WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cbIconPath, int FAR *piIconIndex);

WINSHELLAPI void WINAPI SHRefreshSettings(void);
WINSHELLAPI LRESULT WINAPI SHRenameFile(HWND hwndParent, LPCTSTR pszDir, LPCTSTR pszOldName, LPCTSTR pszNewName, BOOL bRetainExtension);


WINSHELLAPI BOOL    WINAPI SHRunControlPanel(LPCTSTR lpcszCmdLine, HWND hwndMsgParent);

EXTERN_C WINSHELLAPI HRESULT STDAPICALLTYPE SHCLSIDFromString(LPCTSTR lpsz, LPCLSID lpclsid);

EXTERN_C WINSHELLAPI HRESULT STDAPICALLTYPE SHCopyMonikerToTemp(IMoniker *pmk, LPCWSTR pszIn, LPWSTR pszOut, int cchOut);

WINSHELLAPI BOOL WINAPI IsVolumeNTFS(LPCTSTR pszRootPath);

#ifdef WINNT
WINSHELLAPI LPWSTR WINAPI GetDownlevelCopyDataLossText(LPCWSTR pszSrcFile, LPCWSTR pszDestDir, BOOL bIsADir, BOOL * pbLossPossibleThisDir);
#endif

//-------- file engine stuff ----------

// "current directory" management routines.  used to set parameters
// that paths are qualfied against in MoveCopyDeleteRename()

WINSHELLAPI int  WINAPI GetDefaultDrive();
WINSHELLAPI int  WINAPI SetDefaultDrive(int iDrive);
WINSHELLAPI int  WINAPI SetDefaultDirectory(LPCTSTR lpPath);
WINSHELLAPI void WINAPI GetDefaultDirectory(int iDrive, LPSTR lpPath);
//
// NOTES: No reason to have this one here, but I don't want to break the build.
//
#ifndef WINCOMMCTRLAPI
int WINAPI StrToInt(LPCTSTR lpSrc);  // atoi()
#endif

#define POSINVALID  32767       // values for invalid position

#define IDCMD_SYSTEMFIRST       0x8000
#define IDCMD_SYSTEMLAST        0xbfff
#define IDCMD_CANCELED          0xbfff
#define IDCMD_PROCESSED         0xbffe
#define IDCMD_DEFAULT           0xbffe

/* timedate.c */

// **********************************************************************
//  DATE is a structure with a date packed into a WORD size value. It
//  is compatible with a file date in a directory entry structure.
// **********************************************************************

#ifndef DATE_DEFINED
typedef struct
{
    WORD    Day     :5; // Day number 1 - 31
    WORD    Month   :4; // Month number 1 - 12
    WORD    Year    :7; // Year subtracted from 1980, 0-127
} WORD_DATE;

typedef union
{
    WORD            wDate;
    WORD_DATE       sDate;
} WDATE;

#define DATE_DEFINED
#endif

// **********************************************************************
//  TIME is a structure with a 24 hour time packed into a WORD size value.
//  It is compatible with a file time in a directory entry structure.
// **********************************************************************

#ifndef TIME_DEFINED

typedef struct
{
        WORD    Sec     :5;     // Seconds divided by 2 (0 - 29).
        WORD    Min     :6;     // Minutes 0 - 59
        WORD    Hour    :5;     // Hours 0 - 24
} WORD_TIME;

typedef union
{
        WORD        wTime;
        WORD_TIME   sTime;
} WTIME;

#define TIME_DEFINED
#endif

WINSHELLAPI WORD WINAPI Shell_GetCurrentDate(void);
WINSHELLAPI WORD WINAPI Shell_GetCurrentTime(void);

//====== SEMI-PRIVATE API ===============================
#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif // HPSXA_DEFINED

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHObjectPropertiesORD                   178
#define SHCreateDefClassObjectORD                70
#define SHGetNetResourceORD                      69

#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)
#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#ifndef NOPRAGMAS
#pragma pack()
#endif /* NOPRAGMAS */
#endif  /* !RC_INVOKED */

#endif // _SHSEMIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\stubres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inststub.rc
//
/* IDD_InstallStubProgress and IDS_UNINSTALL should be defined by the including
 * component to not conflict with other resources.
 *
 * Control IDs can live here since they don't need to be unique across dialogs.
 */

#define IDC_RUNNING_INSTALL_STUB        1000
#define IDC_RUNNING_UNINSTALL_STUB      1001
#define IDC_INSTALL_STUB_NAME           1002
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\startids.h ===
#ifndef _STARTIDS_H
#define _STARTIDS_H

#define IDM_FILERUN                 401
#define IDM_LOGOFF                  402
#define IDM_EJECTPC                 410
#define IDM_SETTINGSASSIST          411
#define IDM_TRAYPROPERTIES          413
#define IDM_UPDATEWIZARD            414
#define IDM_UPDATE_SEP              415

#ifdef WINNT // hydra specific ids
#define IDM_MU_DISCONNECT           5000
#define IDM_MU_SECURITY             5001
#endif

#define IDM_RECENT              501
#define IDM_FIND                502
#define IDM_HELPSEARCH          503
#define IDM_PROGRAMS            504
#define IDM_CONTROLS            505
#define IDM_EXITWIN             506
#define IDM_SETTINGS            508
#define IDM_PRINTERS            510
#define IDM_STARTMENU           511
#define IDM_MYCOMPUTER          512
#define IDM_PROGRAMSINIT        513
#define IDM_RECENTINIT          514
#define IDM_MYDOCUMENTS         516
#define IDM_MENU_FIND           520
#define TRAY_IDM_FINDFIRST      521  // this range
#define TRAY_IDM_FINDLAST       550  // is reserved for find command
#define IDM_NETCONNECT          557


// Orphans from IE401....
#ifdef FEATURE_BROWSEWEB
#define IDM_MENU_WEB            551
#endif

#define IDM_DESKTOPHTML_CUSTOMIZE   552
#define IDM_DESKTOPHTML_UPDATE      553
#define IDM_DESKTOPHTML_ONOFF       554
#define IDM_FOLDERPROPERTIES        555
#define IDM_ACTIVEDESKTOP_PROP      556
#define IDM_FAVORITES               507
#define IDM_SUSPEND                 409

#define IDM_CSC                 553

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shui.h ===
#ifndef _SHUI_H_
#define _SHUI_H_

/* Declaration needed for shdocvw and browseui to work together and 
for whatever reason they cannot go into shdocvw.h or browseui.h
*/
#include <mshtml.h>

STDAPI SearchForElementInHead
(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface

);


typedef HRESULT (*PFNSEARCHFORELEMENTINHEAD)(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface
    );


#define SEARCHFORELEMENTINHEAD_ORD 208

typedef struct _internet_shortcut_params
{
    LPCITEMIDLIST pidlTarget;
    LPCTSTR  pszTitle;           // BUGBUG -- all of these can be made TCHAR 
                              // when shdocvw is made unicode - then the use of this struct in browseui
                              // will have to be changed to reflect that these are TCHAR
    LPCTSTR pszDir;
    LPTSTR  pszOut;
    int     cchOut;
    BOOL    bUpdateProperties;
    BOOL    bUniqueName;
    BOOL    bUpdateIcon;
    IOleCommandTarget *pCommand;
    IHTMLDocument2 *pDoc;
} ISHCUT_PARAMS;


STDAPI
CreateShortcutInDirEx(ISHCUT_PARAMS *pIShCutParams);


typedef HRESULT (*PFNDOWNLOADICONFORSHORTCUT)(WCHAR *pwszFileName, WCHAR *pwszShortcutUrl, WCHAR *pwszIconUrl);
#define DOWNLOADICONFORSHORTCUT_ORD 207   
STDAPI
DownloadIconForShortcut(
    WCHAR *pwszFileName,            // [in] Optional, File name of shortcut - full path
    WCHAR *pwszShortcutUrl,         // [in] Url of Shortcut
    IHTMLDocument2* pHTMLDocument  // [in] document to search for icon URL 
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\shstr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class

    shstr.h

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


Abstract:

    this allows automatic resizing and stuff

    NOTE: this class is specifically designed to be used as a stack variable


--*/

#ifndef _SHSTR_H_

//  default shstr to MAX_PATH so that we can use them anywhere 
//  we currently assume a MAX_PATH buffer.
#define DEFAULT_SHSTR_LENGTH    MAX_PATH


#ifdef UNICODE
#define ShStr ShStrW
#define UrlStr UrlStrW
#else
#define ShStr ShStrA
#define UrlStr UrlStrA
#endif //UNICODE

class ShStrA
{
public:

    //
    //  Constructors
    //
    ShStrA();

    //
    //  Destructor
    //
    ~ShStrA()
        {Reset();}

    //
    // the first are the only ones that count
    //
    HRESULT SetStr(LPCSTR pszStr, DWORD cchStr);
    HRESULT SetStr(LPCSTR pszStr);
    HRESULT SetStr(LPCWSTR pwszStr, DWORD cchStr);

    // the rest just call into the first three
    HRESULT SetStr(LPCWSTR pwszStr)
        {return SetStr(pwszStr, (DWORD) -1);}
    HRESULT SetStr(ShStrA &shstr)
        {return SetStr(shstr._pszStr);}


    ShStrA& operator=(LPCSTR pszStr)
        {SetStr(pszStr); return *this;}
    ShStrA& operator=(LPCWSTR pwszStr)
        {SetStr(pwszStr); return *this;}
    ShStrA& operator=(ShStrA &shstr)
        {SetStr(shstr._pszStr); return *this;}


    LPSTR GetStr()
        {return _pszStr;}
    operator LPSTR()
        {return _pszStr;}

    HRESULT Append(LPCSTR pszStr, DWORD cchStr);
    HRESULT Append(LPCSTR pszStr)
        {return Append(pszStr, (DWORD) -1);}
    HRESULT Append(CHAR ch)
        {return Append(&ch, 1);}

    //
    //  the Clone methods return memory that must be freed
    //
    ShStrA *Clone();
    LPSTR CloneStrA();
    LPWSTR CloneStrW();
    LPSTR CloneStr()
        {return CloneStrA();}

    
    VOID Reset();
    VOID Trim();

#ifdef DEBUG
    BOOL IsValid();
#else
    inline BOOL IsValid()
    {return _pszStr != NULL;}
#endif //DEBUG

    DWORD GetSize()
        {ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH)); return (_pszStr ? _cchSize : 0);}

    HRESULT SetSize(DWORD cchSize);
    DWORD GetLen()
        {return lstrlenA(_pszStr);}



protected:
//    friend UrlStr;
/*
    TCHAR GetAt(DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] : TEXT('\0');}
    TCHAR SetAt(TCHAR ch, DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] = ch : TEXT('\0');}
*/
private:

    HRESULT _SetStr(LPCSTR psz);
    HRESULT _SetStr(LPCSTR psz, DWORD cb);
    HRESULT _SetStr(LPCWSTR pwszStr, DWORD cchStr);

    CHAR _szDefaultBuffer[DEFAULT_SHSTR_LENGTH];
    LPSTR _pszStr;
    DWORD _cchSize;


}; //ShStrA


class ShStrW
{
public:

    //
    //  Constructors
    //
    ShStrW();

    //
    //  Destructor
    //
    ~ShStrW()
        {Reset();}

    //
    // the first are the only ones that count
    //
    HRESULT SetStr(LPCSTR pszStr, DWORD cchStr);
    HRESULT SetStr(LPCSTR pszStr);
    HRESULT SetStr(LPCWSTR pwszStr, DWORD cchStr);

    // the rest just call into the first three
    HRESULT SetStr(LPCWSTR pwszStr)
        {return SetStr(pwszStr, (DWORD) -1);}
    HRESULT SetStr(ShStrW &shstr)
        {return SetStr(shstr._pszStr);}


    ShStrW& operator=(LPCSTR pszStr)
        {SetStr(pszStr); return *this;}
    ShStrW& operator=(LPCWSTR pwszStr)
        {SetStr(pwszStr); return *this;}
    ShStrW& operator=(ShStrW &shstr)
        {SetStr(shstr._pszStr); return *this;}


    LPWSTR GetStr()
        {return _pszStr;}
    operator LPWSTR()
        {return _pszStr;}

    HRESULT Append(LPCWSTR pszStr, DWORD cchStr);
    HRESULT Append(LPCWSTR pszStr)
        {return Append(pszStr, (DWORD) -1);}
    HRESULT Append(WCHAR ch)
        {return Append(&ch, 1);}

    //
    //  the Clone methods return memory that must be freed
    //
    ShStrW *Clone();
    LPSTR CloneStrA();
    LPWSTR CloneStrW();
    LPWSTR CloneStr()
        {return CloneStrW();}

    
    VOID Reset();
    VOID Trim();

#ifdef DEBUG
    BOOL IsValid();
#else
    BOOL IsValid() 
    {return (BOOL) (_pszStr ? TRUE : FALSE);}
#endif //DEBUG

    DWORD GetSize()
        {ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH)); return (_pszStr ? _cchSize : 0);}

    HRESULT SetSize(DWORD cchSize);
    DWORD GetLen()
        {return lstrlenW(_pszStr);}



protected:
//    friend UrlStr;
/*
    TCHAR GetAt(DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] : TEXT('\0');}
    TCHAR SetAt(TCHAR ch, DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] = ch : TEXT('\0');}
*/
private:

    HRESULT _SetStr(LPCSTR psz);
    HRESULT _SetStr(LPCSTR psz, DWORD cb);
    HRESULT _SetStr(LPCWSTR pwszStr, DWORD cchStr);

    WCHAR _szDefaultBuffer[DEFAULT_SHSTR_LENGTH];
    LPWSTR _pszStr;
    DWORD _cchSize;


}; //ShStrW

#ifdef UNICODE
typedef ShStrW  SHSTR;
typedef ShStrW  *PSHSTR;
#else
typedef ShStrA  SHSTR;
typedef ShStrA  *PSHSTR;
#endif //UNICODE

typedef ShStrW  SHSTRW;
typedef ShStrW  *PSHSTRW;

typedef ShStrA  SHSTRA;
typedef ShStrA  *PSHSTRA;



#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96

class UrlStr 
{
public:
    UrlStr()
        {return;}

    operator LPCTSTR();
    operator SHSTR();

    UrlStr &SetUrl(LPCSTR pszUrl);
    UrlStr &SetUrl(LPCWSTR pwszUrl);
    UrlStr &SetUrl(LPCSTR pszUrl, DWORD cchUrl);
    UrlStr &SetUrl(LPCWSTR pwszUrl, DWORD cchUrl);

    DWORD GetScheme();
    VOID GetSchemeStr(PSHSTR pstrScheme);

    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
*/
protected:
    SHSTR  _strUrl;
};
#endif //DISABLED


#endif // _SHSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\trayp.h ===
#ifndef _TRAYP_INC
#define _TRAYP_INC


#define TBC_SETACTIVEALT            (WM_USER + 50)      //  50=0x32
#define TBC_VERIFYBUTTONHEIGHT      (WM_USER + 51)

#define WMTRAY_PROGCHANGE           (WM_USER + 200)     // 200=0xc8
#define WMTRAY_RECCHANGE            (WM_USER + 201)
#define WMTRAY_FASTCHANGE           (WM_USER + 202)
#define WMTRAY_PRINTCHANGE          (WM_USER + 203)
#define WMTRAY_DESKTOPCHANGE        (WM_USER + 204)

#define WMTRAY_COMMONPROGCHANGE     (WM_USER + 205)
#define WMTRAY_COMMONFASTCHANGE     (WM_USER + 206)

#define WMTRAY_FAVORITESCHANGE      (WM_USER + 207)

#define WMTRAY_PRINTICONNOTIFY      (WM_USER + 220)

#define WMTRAY_REGISTERHOTKEY       (WM_USER + 230)
#define WMTRAY_UNREGISTERHOTKEY     (WM_USER + 231)
#define WMTRAY_SETHOTKEYENABLE      (WM_USER + 232)
#define WMTRAY_SCREGISTERHOTKEY     (WM_USER + 233)
#define WMTRAY_SCUNREGISTERHOTKEY   (WM_USER + 234)
#define WMTRAY_QUERY_MENU           (WM_USER + 235)
#define WMTRAY_QUERY_VIEW           (WM_USER + 236)     // 236=0xec

#define TM_WINDOWDESTROYED          (WM_USER+0x100)
#define TM_POSTEDRCLICK             (WM_USER+0x101)
#define TM_CONTEXTMENU              (WM_USER+0x102)
#define TM_ACTASTASKSW              (WM_USER+0x104)
#define TM_SYSMENUCOUNT             (WM_USER+0x105)
#define TM_TASKTAB                  (WM_USER+0x106)

#define TM_RELAYPOSCHANGED          (WM_USER + 0x150)
// #define TM_INVALIDATEREBUILDMENU    (WM_USER + 0x151)
#define TM_BRINGTOTOP               (WM_USER + 0x152)
#define TM_WARNNOAUTOHIDE           (WM_USER + 0x153)
#define TM_WARNNODROP               (WM_USER + 0x154)
// #define TM_NEXTCTL                  (WM_USER + 0x155)
#define TM_DOEXITWINDOWS            (WM_USER + 0x156)
#define TM_SHELLSERVICEOBJECTS      (WM_USER + 0x157)
#define TM_DESKTOPSTATE             (WM_USER + 0x158)
#define TM_HANDLEDELAYBOOTSTUFF     (WM_USER + 0x159)
#define TM_GETHMONITOR              (WM_USER + 0x15a)

#ifdef DEBUG
#define TM_NEXTCTL                  (WM_USER + 0x15b)
#endif
#define TM_UIACTIVATEIO             (WM_USER + 0x15c)
#define TM_ONFOCUSCHANGEIS          (WM_USER + 0x15d)

#define TM_MARSHALBS                (WM_USER + 0x15e)
// was TM_THEATERMODE, do not reuse (WM_USER + 0x15f)
#define TM_KILLTIMER                (WM_USER + 0x160)
#define TM_REFRESH                  (WM_USER + 0x161)
#define TM_SETTIMER                 (WM_USER + 0x162)

#define TM_PRIVATECOMMAND           (WM_USER + 0x175)


#define Tray_GetHMonitor(hwndTray, phMon) \
        (DWORD)SendMessage((hwndTray), TM_GETHMONITOR, 0, (LPARAM)(HMONITOR *)phMon)


#ifdef ABM_NEW

typedef struct _TRAYAPPBARDATA
{
    APPBARDATA abd;
    DWORD dwMessage;
    HANDLE hSharedABD;
    DWORD dwProcId;
} TRAYAPPBARDATA, *PTRAYAPPBARDATA;

#endif

#define RRA_DEFAULT               0x0000
#define RRA_DELETE                0x0001        // delete each reg value when we're done with it
#define RRA_WAIT                  0x0002        // Wait for current item to finish before launching next item
#define RRA_SHELLSERVICEOBJECTS   0x0004        // treat as a shell service object instead of a command sting
#define RRA_NOUI                  0x0008        // prevents ShellExecuteEx from displaying error dialogs
#define RRA_RUNSUBKEYS            0x0010        // Run items in sub keys in alphabetical order
#define RRA_USEJOBOBJECTS         0x0020        // wait on job objects instead of process handles

typedef UINT RRA_FLAGS;

#endif // _TRAYP_INC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\stubsup.h ===
/* Header file for install stub code, to be included in components which
 * don't link to shlwapi.dll (such as loadwc.exe, which may remain on disk
 * after IE4 and shlwapi have been uninstalled).
 */

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// "foo.exe bar.txt"    -> "bar.txt"
// "foo.exe"            -> ""
//
// Spaces in filenames must be quoted.
// " "A long name.txt" bar.txt " -> "bar.txt"

STDAPI_(LPTSTR)
PathGetArgs(
    LPCTSTR pszPath)
{
    BOOL fInQuotes = FALSE;

    if (!pszPath)
            return NULL;

    while (*pszPath)
    {
        if (*pszPath == TEXT('"'))
            fInQuotes = !fInQuotes;
        else if (!fInQuotes && *pszPath == TEXT(' '))
            return (LPTSTR)pszPath+1;
        pszPath = CharNext(pszPath);
    }

    return (LPTSTR)pszPath;
}


/*----------------------------------------------------------
Purpose: Behaves just like RegQueryValueEx, except if the
         data type is REG_EXPAND_SZ, then this goes ahead
         and expands out the string.  *pdwType will always
         be massaged to REG_SZ if this happens.

Returns: 
Cond:    --
*/
STDAPI_(DWORD)
SHQueryValueEx(
    IN     HKEY    hkey,
    IN     LPCSTR  pszValue,
    IN     LPDWORD lpReserved,
    OUT    LPDWORD pdwType,
    OUT    LPVOID  pvData,
    IN OUT LPDWORD pcbData)
{
    DWORD dwRet;
    DWORD cbSize;
    DWORD dwType;
    LPSTR lpsz;

    if (pvData) 
    {
        // Trying to get back data

        cbSize = *pcbData;     // Size of output buffer
        dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                                 (LPBYTE)pvData, &cbSize);

        // Normally, we'd be done with this.  But do some extra work
        // if this is an expandable string (something that has system
        // variables in it), or if we need to pad the buffer.

        if (NO_ERROR == dwRet)
        {
            // Note: on Win95, RegSetValueEx will always write the 
            // full string out, including the null terminator.  On NT,
            // it won't unless the write length was specified.  
            // Hence, we have the following check.

            // Pad the buffer, in case the string didn't have a null
            // terminator when it was stored?
            if (REG_SZ == dwType)
            {
                // Yes
                if (cbSize < *pcbData) 
                {
                    LPSTR lpszData = (LPSTR)pvData;
                    lpszData[cbSize] = '\0';
                }
            }
            // Expand the string?
            else if (REG_EXPAND_SZ == dwType)
            {
                // Yes

                // Use a temporary buffer to expand
                lpsz = (LPSTR)LocalAlloc(LPTR, *pcbData);    
                if ( !lpsz )
                    return ERROR_OUTOFMEMORY;

                cbSize = ExpandEnvironmentStringsA((LPCTSTR)pvData, lpsz, *pcbData);

                // BUGBUG:: NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlen(lpsz) + 1;
                if (cbSize > 0 && cbSize <= *pcbData) 
                    lstrcpynA((LPTSTR)pvData, lpsz, *pcbData);
                else
                    dwRet = GetLastError();

                LocalFree(lpsz);

                // Massage dwType so that callers always see REG_SZ
                dwType = REG_SZ;
            }
        }
    } 
    else 
    {
        // Trying to find out how big of a buffer to use

        cbSize = 0;
        dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, &dwType,
                                 NULL, &cbSize);
        if (REG_EXPAND_SZ == dwType && NO_ERROR == dwRet)
        {
            CHAR szBuff[1];

            // Find out the length of the expanded string
            //
            lpsz = (LPSTR)LocalAlloc(LPTR, cbSize);
            if (!lpsz)
                return ERROR_OUTOFMEMORY;

            dwRet = RegQueryValueExA(hkey, pszValue, lpReserved, NULL,
                                     (LPBYTE)lpsz, &cbSize);

            if (NO_ERROR == dwRet)
            {
                cbSize = ExpandEnvironmentStringsA(lpsz, szBuff, ARRAYSIZE(szBuff));

                // BUGBUG:: NT screws up the cbSize returned...
                if (cbSize > 0)
                    cbSize = lstrlen(lpsz) + 1;
            }

            LocalFree(lpsz);

            // Massage dwType so that callers always see REG_SZ
            dwType = REG_SZ;
        }
    }

    if (pdwType)
        *pdwType = dwType;

    if (pcbData)
        *pcbData = cbSize;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\uemedat.h ===
//***   uemedat.h -- generator file for UEME_*
// NOTES
//  this file is included in numerous contexts w/ TABDAT #defined
//  to give the desired behavior.   see the individ files for details.
//
//  BUGBUG many of these are NYI.
//
//  e<n>    encode up to step <= n
//  f       fire event
//  l       log event
//  @       escape to custom code
//  !       ASSERT
//  x       NYI
//

// UI (menu, shortcut, etc.)
TABDAT(UEME_UIMENU     , "e2fl@" , 0, 0, 0, 0)
TABDAT(UEME_UIHOTKEY   , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UISCUT     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UIQCUT     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UITOOLBAR  , "e2fl"  , 0, 0, 0, 0)
#if 0 // 980825 uncomment in uemevt.h, uemedat.h if build breaks (tmp hack)
TABDAT(UEME_UIASSOC    , "e1fl"  , 0, 0, 0, 0)
#endif

// run (spawn, invoke, etc.)
TABDAT(UEME_RUNWMCMD   , "e2fl"  , 0, 0, 0, 0)
TABDAT(_UEME_RUNPIDL1  , "e2fl"  , 0, 0, 0, 0)  // obsolete, remove
TABDAT(UEME_RUNPIDL    , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNINVOKE  , "xe1fl" , 0, 0, 0, 0)
TABDAT(UEME_RUNOLECMD  , "xe1fl" , 0, 0, 0, 0)
TABDAT(UEME_RUNPATHA   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNPATHW   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNCPLA    , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNCPLW    , "e2fl"  , 0, 0, 0, 0)

// exit status
TABDAT(UEME_DONECANCEL , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_DONEOK     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_DONEFAIL   , "e1fl"  , 0, 0, 0, 0)

// error
// NOTES
//  for now lParam=szMsg, that's just temporary but not sure what we need yet
TABDAT(UEME_ERRORA     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_ERRORW     , "e1fl"  , 0, 0, 0, 0)

#ifdef UNICODE
TABDAT(UEME_ERROR      , "e1fl"  , 0, 0, 0, 0)
#else
TABDAT(UEME_ERROR      , "e1fl"  , 0, 0, 0, 0)
#endif

// control
TABDAT(UEME_CTLSESSION , "@"     , 0, 0, 0, 0)

// debug
TABDAT(UEME_DBTRACEA   , "@"     , 0, 0, 0, 0)
TABDAT(UEME_DBTRACEW   , "@"     , 0, 0, 0, 0)

#ifdef UNICODE
TABDAT(UEME_DBTRACE    , "@"     , 0, 0, 0, 0)
#else
TABDAT(UEME_DBTRACE    , "@"     , 0, 0, 0, 0)
#endif
TABDAT(UEME_DBSLEEP    , "@"     , 0, 0, 0, 0)

// Instrumented Browser
TABDAT(UEME_INSTRBROWSER, "e2fl" , 0, 0, 0, 0)

// all events below here (msg < UEME_USER) are reserved
// private messages start here (at UEME_USER + 0)
// BUGBUG NYI we don't support private messages for now
TABDAT(UEME_USER       , "x"     , 0, 0, 0, 0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\uemevt.h ===
// {
//***   UEME_* -- events
// DESCRIPTION
//  UEME_UI*
//  UEME_RUN*
//  UEME_DONE*
//  UEME_ERROR*
//  UEME_DB*
// NOTES
//  since rulc.exe must process this, it can *only* contain #defines.

// UI (menu, shortcut, etc.)
#define UEME_UIMENU     1   // did a UI menu, wP=grp lParam=IDM_*
#define UEME_UIHOTKEY   2   // did a UI hotkey, lParam=GHID_*
#define UEME_UISCUT     3   // did a UI shortcut, lParam=???
#define UEME_UIQCUT     4   // did a UI qlink/isfband, lParam=???
#define UEME_UITOOLBAR  5   // did a UI toolbar button, wP=lParam=???
#if 0 // 980825 uncomment in uemevt.h, uemedat.h if build breaks (tmp hack)
#define UEME_UIASSOC    6   // did a semi-UI association, wP=-1 lP=-1
#endif

// run (spawn, invoke, etc.)
#define UEME_RUNWMCMD   12  // ran a WM_COMMAND, lParam=UEMC_*
#define _UEME_RUNPIDL1  10  // (obsolete) ran a pidl, wP=csidl, lParam=pidl
#define UEME_RUNPIDL    18  // ran a pidl, wP=isf lP=pidlItem
#define UEME_RUNINVOKE  11  // ran an Ixxx::Invoke, lParam=???
#define UEME_RUNOLECMD  13  // ran an IOleCT::Exec wP=nCmdID lP=pguidCmdGrp
#define UEME_RUNPATHA   14  // ran a path, lParam=path
#define UEME_RUNPATHW   15  // ran a path, lParam=path
#define UEME_RUNCPLA    16  // ran a cpl path, wP=index lP=path
#define UEME_RUNCPLW    17  // ran a cpl path, wP=index lP=path

#ifdef UNICODE
#define UEME_RUNPATH    UEME_RUNPATHW
#define UEME_RUNCPL     UEME_RUNCPLW
#else
#define UEME_RUNPATH    UEME_RUNPATHA
#define UEME_RUNCPL     UEME_RUNCPLA
#endif

// exit status
#define UEME_DONECANCEL 32  // cancel
#define UEME_DONEOK     30  // (NYI) ok (==0)
#define UEME_DONEFAIL   31  // (NYI) fail (!=0)

// error
// NOTES
//  for now lParam=szMsg, that's just temporary but not sure what we need yet
#define UEME_ERRORA     20  // error (generic), lParam=szMsg
#define UEME_ERRORW     21  // error (generic), lParam=szMsg

#ifdef UNICODE
#define UEME_ERROR      UEME_ERRORW
#else
#define UEME_ERROR      UEME_ERRORA
#endif

// control
#define UEME_CTLSESSION 40  // do UASetSession

// instrumented browser
#define UEME_INSTRBROWSER 50

// debug
#define UEME_DBTRACEA   90  // just a midpoint trace..., lParam=szMsg
#define UEME_DBTRACEW   91  // just a midpoint trace..., lParam=szMsg

#ifdef UNICODE
#define UEME_DBTRACE    UEME_DBTRACEW
#else
#define UEME_DBTRACE    UEME_DBTRACEA
#endif

#define UEME_DBSLEEP    92  // sleep, lParam=mSec (per Sleep API)

// all events below here (msg < UEME_USER) are reserved
// private messages start here (at UEME_USER + 0)
// BUGBUG NYI we don't support private messages for now
#define UEME_USER       256

// }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\unimp.h ===
#ifdef DEBUG
#ifdef K32
const char UnimpMessage[] = "Unimplemented API %s";
const char AttentionMessage[] = "ATTENTION !!! API stub might corrupt the stack";

enum {DEB_FATAL, DEB_ERR, DEB_WARN, DEB_TRACE };
int apiLevel = DEB_WARN;
VOID    KERNENTRY   vDebugOut(int level, const char *pfmt, ...);

#define DebugOut(args) vDebugOut args
#define UNIMP_MESSAGE DebugOut((apiLevel, UnimpMessage, api_string));
#define DEBUG_OOPS    DebugOut((DEB_ERR, UnimpMessage, api_string)); \

#else

const char UnimpMessage[] = "Unimplemented API %s\r\n";
const char AttentionMessage[] = "ATTENTION !!! API stub might corrupt the stack\r\n";
#define UNIMP_MESSAGE DebugPrintf(UnimpMessage, api_string);
#define DEBUG_OOPS    DebugPrintf(UnimpMessage, api_string); _asm { int 3 };
#endif
#endif
/*
 * Macros for unimplemented APIs stubs.
 *
 */



#define API_name(api_name) api_name

#define API_decl(api_name) long APIENTRY API_name(api_name)

#ifdef DEBUG
#define API_body(api_name, return_value) \
    const char api_string[] = #api_name; \
    UNIMP_MESSAGE \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value);
#else
#define API_body(api_name, return_value) \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value);
#endif

#ifdef DEBUG
#define APISTUB_(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
    const char api_string[] = #api_name; \
    DebugPrintf(AttentionMessage); \
    DEBUG_OOPS \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value); \
}
#else
#define APISTUB_(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value); \
}
#endif

#define APISTUB_0(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
API_body(api_name, return_value) \
}

#define APISTUB_1(api_name, return_value) \
API_decl(api_name) ( \
    int p1 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
}

#define APISTUB_2(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
}

#define APISTUB_3(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
}

#define APISTUB_4(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
}

#define APISTUB_5(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
}

#define APISTUB_6(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
}

#define APISTUB_7(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
}

#define APISTUB_8(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
}

#define APISTUB_9(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
}

#define APISTUB_10(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
}

#define APISTUB_11(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
}

#define APISTUB_12(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
}

#define APISTUB_13(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12, \
    int p13 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
    p13; \
}

#define APISTUB_14(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12, \
    int p13, \
    int p14 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
    p13; \
    p14; \
}

/*
 * Miscelaneous declarations needed for the APIs
 */
extern void _cdecl DebugPrintf();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT_PTR)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT_PTR)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// The next few functions must declare the structure types explicitly
// so we don't need to worry about whether <shlobj.h> and/or <comctrlp.h>
// was included before or after us.

BOOL
IsValidPIDL(
    const UNALIGNED struct _ITEMIDLIST *pidl);

BOOL
IsValidHDPA(
    struct _DPA *hdpa);

BOOL
IsValidHDSA(
    struct _DSA *hdsa);

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\uemapp.h ===
#ifndef _UEMAPP_H_ // {
#define _UEMAPP_H_

//***   uemapp.h -- application (client) side of event monitor
//

#ifdef __cplusplus
extern "C" {
#endif

// {
//***   UEME_* -- events
#include "uemevt.h"         // separate #include so rulc.exe can use it

#define UEME_FBROWSER   0x80000000  // 0:shell 1:browser

//***   UEMF_* -- Flags used when calling FireEvent
#define UEMF_EVENTMON   0x00000001       // Traditional Event Monitor use of FireEvent
#define UEMF_INSTRUMENT 0x00000002       // These events are being instrumented
#define UEMF_MASK       (UEMF_EVENTMON | UEMF_INSTRUMENT)

//****  UEMF_ Meta Categories
#define UEMF_XEVENT     (UEMF_EVENTMON | UEMF_INSTRUMENT)

//***   UIG_* -- UI 'groups'
// NOTES
//  BUGBUG not sure if this is the right partitioning
#define UIG_NIL         (-1)
#define UIG_COMMON      1       // common UI elements (e.g. back/stop/refresh)
#define UIG_INET        2       // inet (html) elements (e.g. search/favs)
#define UIG_FILE        3       // file (defview) elements (e.g. up)
#define UIG_OTHER       4       // custom (isf, isv, docobj) elements

//***   UIM_* -- modules
// NOTES
//  used to separate namespaces.  e.g. IDMs for UEME_RUNWMCMD.
#define UIM_NIL         (-1)    // none (global)
#define UIM_EXPLORER    1       // explorer.exe
#define UIM_BROWSEUI    2       // browseui.dll
#define UIM_SHDOCVW     3       // shdocvw.dll
#define UIM_SHELL32     4       // shell32.dll

// Instrumented Browser wparams 
#define UIBW_ADDTOFAV   1
#define UIBW_404ERROR   2
#define UIBW_NAVIGATE   3       // navigation lP=how
    #define UIBL_NAVOTHER   0   // via other
    #define UIBL_NAVADDRESS 1   // via address bar
    #define UIBL_NAVGO      2   // (NYI) via 'go' button on address bar
    #define UIBL_NAVHIST    3   // via history pane
    #define UIBL_NAVFAVS    4   // via favorites pane
    #define UIBL_NAVFOLDERS 5   // (NYI) via all-folders pane
    #define UIBL_NAVSEARCH  6   // (NYI) via search pane
#define UIBW_RUNASSOC   4       // run lP=assoc
    #define UIBL_DOTOTHER   0   // other
    #define UIBL_DOTEXE     1   // .exe
    #define UIBL_DOTASSOC   2   // associated w/ some .exe
    #define UIBL_DOTNOASSOC 3   // not associated w/ some .exe (OpenWith)
    #define UIBL_DOTFOLDER  4   // folder
    #define UIBL_DOTLNK     5   // .lnk
#define UIBW_UICONTEXT  5       // context menu lP=where
    #define UIBL_CTXTOTHER      0   // (NYI) other
    #define UIBL_CTXTDEFBKGND   1   // defview background
    #define UIBL_CTXTDEFITEM    2   // defview item
    #define UIBL_CTXTDESKBKGND  3   // desktop background
    #define UIBL_CTXTDESKITEM   4   // desktop item
//  #define UIBL_CTXTQCUTBKGND  5   // (n/a) qlaunch background
    #define UIBL_CTXTQCUTITEM   6   // qlaunch/qlinks item
//  #define UIBL_CTXTISFBKGND   7   // (n/a) arb. isf background
    #define UIBL_CTXTISFITEM    8   // arb. isf item
    #define UIBL_CTXTITBBKGND   9   // (n/a) itbar background
    #define UIBL_CTXTITBITEM    10  // itbar item
// for input, however the menu is *1st* invoked is assumed to be representative
// of the *entire* menu action
#define UIBW_UIINPUT    6       // input method lP=source
    // n.b. no desktop/browser distinction
    #define UIBL_INPOTHER   0       // (NYI) other
    #define UIBL_INPMOUSE   1       // mouse
    #define UIBL_INPMENU    2       // menu key (alt or alt+letter)
    #define UIBL_INPACCEL   3       // (NYI) accelerator
    #define UIBL_INPWIN     4       // (NYI) 'windows' key

// Instrumented Browser lparams
#define UIBL_KEYBOARD   1
#define UIBL_MENU       2
#define UIBL_PANE       3


//***   UEM*_* -- app 'groups'
//
#define UEMIID_NIL      CLSID_NULL              // nil (office uses 0...)
#define UEMIID_SHELL    CLSID_ActiveDesktop     // BUGBUG need better one
#define UEMIID_BROWSER  CLSID_InternetToolbar   // BUGBUG need better one

#define UEMIND_NIL      (-1)
#define UEMIND_SHELL    0
#define UEMIND_BROWSER  1

#define UEMIND_NSTANDARD    2   // cardinality(UEMIND_*)

//***   UEM*Event -- helpers from ../lib/uassist.cpp
// NOTES
//  BUGBUG rename to UA* (from UEM*)
BOOL UEMIsLoaded();
HRESULT UEMFireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam);
HRESULT UEMQueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
HRESULT UEMSetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);


#if 1 // {
//***   obsolete -- old exports, nuke after all callers fixed
//

STDAPI_(void) UEMEvalMsg(const GUID *pguidGrp, int uemCmd, WPARAM wParam, LPARAM lParam);

// obsolete! use UEMEvalMsg
//STDAPI_(void) UEMTrace(int uemCmd, LPARAM lParam);
#define UEMTrace(uemCmd, lParam)    UEMEvalMsg(&UEMIID_NIL, uemCmd, -1, lParam)

#define UEIA_RARE       0x01    // rare (demotion candidate)

STDAPI_(BOOL) UEMGetInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
#endif // }

// }

// {
//***   UEMC_* -- commands
//
#define TABDAT(uemc)   uemc,
enum {
    #include "uemcdat.h"
};
#undef  TABDAT
// }


// {
//***   misc helpers
//

//***   XMB_ICONERROR -- guys that look like an error (vs. idle chit-chat)
// error stop (question) exclamation hand (info) (aster) (warn)
// BUGBUG is this the right set?
#define XMB_ICONERROR   (MB_ICONERROR|MB_ICONSTOP|MB_ICONEXCLAMATION|MB_ICONHAND)
// }

#ifdef __cplusplus
}
#endif

#endif // } _UEMAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\vdate.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: vdate.h - Debug argument validation helpers
//
// History:
//  06-16-94    Davepl  Created
//
//---------------------------------------------------------------------------

#ifdef DEBUG

__inline void FUNC_VDATEINPUTBUF(void * pBuffer,
                                 size_t cElementSize,
                                 size_t cCount,
                                 int    iLine,
                                 char * pszFile)
{
    if (IsBadWritePtr(pBuffer, cElementSize * cCount))
    {
        char sazOutput[MAX_PATH * 2];
        wnsprintfA(sazOutput, SIZECHARS(sazOutput), "Buffer failed validation at line %d in %s\n", iLine, pszFile);
        OutputDebugStringA(sazOutput);
        RIP(FALSE);
    }
}

#define VDATEINPUTBUF(ptr, type, count) FUNC_VDATEINPUTBUF(ptr,                 \
                                                           sizeof(type),        \
                                                           count,               \
                                                           __LINE__,            \
                                                           __FILE__)

#else

#define VDATEINPUTBUF(ptr, type, const)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\uemcdat.h ===
//***   uemcmddat.h -- generator file for UEMC_*
// NOTES
//  this file is included in numerous contexts w/ TABDAT #defined
//  to give the desired behavior.   see the individ files for details.
//
//  BUGBUG many of these are NYI.
//

TABDAT(UEMC_NIL)
TABDAT(UEMC_FIRST)

TABDAT(UEMC_STARTMENU)      // (pseudo) start menu

//
TABDAT(UEMC_PROGS)          // (NYI) (pseudo) catchall for FS programs
TABDAT(UEMC_FAVS)           // (NYI) (pseudo) catchall for FS favorites
TABDAT(UEMC_DOCS)           // (NYI) (pseudo) catchall for FS documents

// settings...
TABDAT(UEMC_CONTROLS)
TABDAT(UEMC_PRINTERS)
TABDAT(UEMC_TASKBAR)
TABDAT(UEMC_FOLDERS)
TABDAT(UEMC_ACTDESK)

// find...
TABDAT(UEMC_FINDFILES)
TABDAT(UEMC_FINDCOMP)
TABDAT(UEMC_FINDINTER)      // (NYI?)
TABDAT(UEMC_FINDOTHERS)     // (NYI) (pseudo) catchall for installed extensions

TABDAT(UEMC_HELPSEARCH)
TABDAT(UEMC_FILERUN)
TABDAT(UEMC_LOGOFF)         // unused?
TABDAT(UEMC_SHUTDOWN)       // unused?

TABDAT(UEMC_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\w95wraps.h ===
/*****************************************************************************\
*                                                                             *
* w95wraps.h - Unicode wrappers for ANSI functions on Win95                   *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

//
//  This file is for internal use only.  Do not put it in the SDK.
//

#ifndef _INC_W95WRAPS
#define _INC_W95WRAPS

#if defined(UNIX)
#define NO_W95WRAPS_UNITHUNK
#define GetSaveFileNameW GetSaveFileNameWrapW
#define GetOpenFileNameW GetOpenFileNameWrapW
#define PrintDlgW PrintDlgWrapW
#define PageSetupDlgW PageSetupDlgWrapW
#define GetMenuItemInfoW GetMenuItemInfoWrapW
#endif
//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_W95WRAPS_UNITHUNK  Unicode wrapper functions
//    NO_W95WRAPS_TPS       Thread Pool Services
//    NO_W95WRAPS_MLUI      MLUI wrapper functions
//
//  You are expected to have done a #include <shlwapi.h> before including
//  this file.
//
// BUGBUG: you can't include shlwapi.h before this, as ATL templates
// require things like TranlsateAccelerator which, due to munging, get
// turned into TranslateAcceleratorWrapW at compile time.  So w95wraps.h
// pretty much needs to be included FIRST so all the interface definitions
// get munged too.
//#ifndef _INC_SHLWAPI
//#error "You must include shlwapi.h *before* w95wraps.h
//#endif

//=============== Unicode Wrapper Routines ===================================

#ifndef NO_W95WRAPS_UNITHUNK

//
//  If you #include this file, then calls to many UNICODE functions
//  are re-routed through wrapper functions in SHLWAPI which will
//  either call the UNICODE version (on NT) or thunk the parameters
//  to ANSI and call the ANSI version (on 9x).
//
//  Note that these wrapper functions must be used with care, because
//
//  *   They do not account for subtle differences between UNICODE and
//      ANSI versions of the same API.  Examples:
//
//      -   RegisterClassW register a UNICODE window class, whereas
//          RegisterClassA registers an ANSI window class.  Consequently,
//          if you use RegisterClassWrapW, your WNDPROC will receive
//          *ANSI* WM_SETTEXT messages on Windows 9x.
//
//      -   SetWindowLongW(GWL_WNDPROC) and CallWindowProcW behave
//          very differently from their ANSI counterparts.
//
//      -   DialogBoxW will send your dialog procedure UNICODE window
//          messages, whereas DialogBoxA will send ANSI window messages.
//
//      -   Anything that manipulates window messages or MSG structures
//          will be subtly affected by character set discrepancies.
//
//  *   Not all features of the underlying API are always supported,
//      or are supported with restrictions.  Examples:
//
//      -   DialogBoxWrapW does not support named dialog resources.
//
//      -   AppendMenuWrapW does not support bitmap or owner-draw
//          menu items.
//
//      -   FormatMessageWrapW does not support insertions.
//
//      -   If you use RegQueryValueExWrapW with a NULL output buffer to
//          query the size of a buffer, you must also pass *lpcbData = 0.
//
//      -   SendMessageWrapW requires that the window message not conflict
//          with messages used by any of the Windows common controls.
//

#define IsCharAlphaW                IsCharAlphaWrapW
#define IsCharUpperW                IsCharUpperWrapW
#define IsCharLowerW                IsCharLowerWrapW
#define IsCharAlphaNumericW         IsCharAlphaNumericWrapW

#define AppendMenuW                 AppendMenuWrapW
#define CallMsgFilterW              CallMsgFilterWrapW
#define CallWindowProcW             CallWindowProcWrapW
#define CharLowerW                  CharLowerWrapW
#define CharLowerBuffW              CharLowerBuffWrapW
#define CharNextW                   CharNextWrapW
#define CharPrevW                   CharPrevWrapW
#define CharToOemW                  CharToOemWrapW
#define CharUpperW                  CharUpperWrapW
#define CharUpperBuffW              CharUpperBuffWrapW
#define CompareStringW              CompareStringWrapW
#define CopyAcceleratorTableW       CopyAcceleratorTableWrapW
#define CreateAcceleratorTableW     CreateAcceleratorTableWrapW
#define CreateDCW                   CreateDCWrapW
#define CreateDirectoryW            CreateDirectoryWrapW
#define CreateEventW                CreateEventWrapW
#define CreateFileW                 CreateFileWrapW
#define CreateFontW                 CreateFontWrapW
#define CreateFontIndirectW         CreateFontIndirectWrapW
#define CreateMetaFileW             CreateMetaFileWrapW
#define CreateMutexW                CreateMutexWrapW
#define CreateICW                   CreateICWrapW
#define CreateSemaphoreW            CreateSemaphoreWrapW
#define CreateWindowExW             CreateWindowExWrapW
#define GetFileVersionInfoSizeW     GetFileVersionInfoSizeWrapW
#define GetFileVersionInfoW         GetFileVersionInfoWrapW
#define VerQueryValueW              VerQueryValueWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define DefWindowProcW              DefWindowProcWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define DeleteFileW                 DeleteFileWrapW
#define DispatchMessageW            DispatchMessageWrapW
#define DragQueryFileW              DragQueryFileWrapW
#define DrawTextExW                 DrawTextExWrapW
#define DrawTextW                   DrawTextWrapW
#define EnumFontFamiliesW           EnumFontFamiliesWrapW
#define EnumFontFamiliesExW         EnumFontFamiliesExWrapW
#define EnumResourceNamesW          EnumResourceNamesWrapW
#define ExpandEnvironmentStringsW   ExpandEnvironmentStringsWrapW
#define ExtractIconExW              ExtractIconExWrapW
#define ExtTextOutW                 ExtTextOutWrapW
#define FindFirstFileW              FindFirstFileWrapW
#define FindResourceW               FindResourceWrapW
#define FindNextFileW               FindNextFileWrapW
#define FindWindowW                 FindWindowWrapW
#define FindWindowExW               FindWindowExWrapW
#define FormatMessageW              FormatMessageWrapW
#ifndef NO_W95_GETCLASSINFO_WRAPS
// #define NO_W95_GETCLASSINFO_WRAPS if one of the objects uses IProvideClassInfo which has a GetClassInfo method.
#define GetClassInfoW               GetClassInfoWrapW
#define GetClassInfoExW             GetClassInfoExWrapW
#endif  // NO_W95_GETCLASSINFO_WRAPS
#define GetClassLongW               GetClassLongWrapW
#define GetClassNameW               GetClassNameWrapW
#define GetClipboardFormatNameW     GetClipboardFormatNameWrapW
#define GetCurrentDirectoryW        GetCurrentDirectoryWrapW
#define GetDlgItemTextW             GetDlgItemTextWrapW
#define GetFileAttributesW          GetFileAttributesWrapW
#define GetFullPathNameW            GetFullPathNameWrapW
#define GetLocaleInfoW              GetLocaleInfoWrapW
#define GetMenuItemInfoW            GetMenuItemInfoWrapW
#define GetMenuStringW              GetMenuStringWrapW
#define GetMessageW                 GetMessageWrapW
#define GetModuleFileNameW          GetModuleFileNameWrapW
#define GetNumberFormatW            GetNumberFormatWrapW
#define GetSystemDirectoryW         GetSystemDirectoryWrapW
#define GetModuleHandleW            GetModuleHandleWrapW
#define GetObjectW                  GetObjectWrapW
#define GetPrivateProfileIntW       GetPrivateProfileIntWrapW
#define GetPrivateProfileStringW    GetPrivateProfileStringWrapW
#define GetProfileStringW           GetProfileStringWrapW
#define GetPropW                    GetPropWrapW
#define GetShortPathNameW           GetShortPathNameWrapW
#define GetLongPathNameW            GetLongPathNameWrapW
#define GetLongPathNameA            GetLongPathNameWrapA
#define GetStringTypeExW            GetStringTypeExWrapW
#define GetTempFileNameW            GetTempFileNameWrapW
#define GetTempPathW                GetTempPathWrapW
#define GetTextExtentPoint32W       GetTextExtentPoint32WrapW
#define GetTextFaceW                GetTextFaceWrapW
#define GetTextMetricsW             GetTextMetricsWrapW
#define GetTimeFormatW              GetTimeFormatWrapW
#define GetDateFormatW              GetDateFormatWrapW
#define GetUserNameW                GetUserNameWrapW
#define GetWindowLongW              GetWindowLongWrapW
#define GetEnvironmentVariableW     GetEnvironmentVariableWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define GetWindowTextW              GetWindowTextWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define GetWindowTextLengthW        GetWindowTextLengthWrapW
#define GetWindowsDirectoryW        GetWindowsDirectoryWrapW
#define InsertMenuW                 InsertMenuWrapW
#define InsertMenuItemW             InsertMenuItemWrapW
#define IsBadStringPtrW             IsBadStringPtrWrapW
#define IsDialogMessageW            IsDialogMessageWrapW
#define LoadAcceleratorsW           LoadAcceleratorsWrapW
#define LoadBitmapW                 LoadBitmapWrapW
#define LoadCursorW                 LoadCursorWrapW
#define LoadIconW                   LoadIconWrapW
#define LoadImageW                  LoadImageWrapW
#define LoadLibraryW                LoadLibraryWrapW
#define LoadLibraryExW              LoadLibraryExWrapW
#define LoadMenuW                   LoadMenuWrapW
#define LoadStringW                 LoadStringWrapW
#define MessageBoxIndirectW         MessageBoxIndirectWrapW
#define MessageBoxW                 MessageBoxWrapW
#define ModifyMenuW                 ModifyMenuWrapW
#define GetCharWidth32W             GetCharWidth32WrapW
#define GetCharacterPlacementW      GetCharacterPlacementWrapW
#define CopyFileW                   CopyFileWrapW
#define MoveFileW                   MoveFileWrapW
#define OemToCharW                  OemToCharWrapW
#define OpenEventW                  OpenEventWrapW
#define OutputDebugStringW          OutputDebugStringWrapW
#define PeekMessageW                PeekMessageWrapW
#define PostMessageW                PostMessageWrapW
#define PostThreadMessageW          PostThreadMessageWrapW
#define RegCreateKeyW               RegCreateKeyWrapW
#define RegCreateKeyExW             RegCreateKeyExWrapW
#define RegDeleteKeyW               RegDeleteKeyWrapW
#define RegDeleteValueW             RegDeleteValueWrapW
#define RegEnumKeyW                 RegEnumKeyWrapW
#define RegEnumKeyExW               RegEnumKeyExWrapW
#define RegOpenKeyW                 RegOpenKeyWrapW
#define RegOpenKeyExW               RegOpenKeyExWrapW
#define RegQueryInfoKeyW            RegQueryInfoKeyWrapW
#define RegQueryValueW              RegQueryValueWrapW
#define RegQueryValueExW            RegQueryValueExWrapW
#define RegSetValueW                RegSetValueWrapW
#define RegSetValueExW              RegSetValueExWrapW
#define RegisterClassW              RegisterClassWrapW
#define RegisterClassExW            RegisterClassExWrapW
#define RegisterClipboardFormatW    RegisterClipboardFormatWrapW
#define RegisterWindowMessageW      RegisterWindowMessageWrapW
#define RemoveDirectoryW            RemoveDirectoryWrapW
#define RemovePropW                 RemovePropWrapW
#define SearchPathW                 SearchPathWrapW
#define SendDlgItemMessageW         SendDlgItemMessageWrapW
#define SendMessageW                SendMessageWrapW
#define SendMessageTimeoutW         SendMessageTimeoutWrapW
#define SetCurrentDirectoryW        SetCurrentDirectoryWrapW
#define SetDlgItemTextW             SetDlgItemTextWrapW
#define SetMenuItemInfoW            SetMenuItemInfoWrapW
#define SetPropW                    SetPropWrapW
#define SetFileAttributesW          SetFileAttributesWrapW
#define SetWindowLongW              SetWindowLongWrapW
#define SHGetFileInfoW              SHGetFileInfoWrapW
#define SHBrowseForFolderW          SHBrowseForFolderWrapW
#define ShellExecuteExW             ShellExecuteExWrapW
#define SHFileOperationW            SHFileOperationWrapW
#define SHGetNewLinkInfoW           SHGetNewLinkInfoWrapW
#define SHDefExtractIconW           SHDefExtractIconWrapW
#define GetUserNameW                GetUserNameWrapW
#define RegEnumValueW               RegEnumValueWrapW
#define WritePrivateProfileStructW  WritePrivateProfileStructWrapW
#define GetPrivateProfileStructW    GetPrivateProfileStructWrapW
#define CreateProcessW              CreateProcessWrapW
#define ExtractIconW                ExtractIconWrapW
#define DdeInitializeW              DdeInitializeWrapW
#define DdeCreateStringHandleW      DdeCreateStringHandleWrapW
#define DdeQueryStringW             DdeQueryStringWrapW
#define GetSaveFileNameW            GetSaveFileNameWrapW
#define GetOpenFileNameW            GetOpenFileNameWrapW
#define SHChangeNotify              SHChangeNotifyWrap
#define SHFlushSFCache              SHFlushSFCacheWrap
#define PageSetupDlgW               PageSetupDlgWrapW
#define PrintDlgW                   PrintDlgWrapW
#define SHGetPathFromIDListW        SHGetPathFromIDListWrapW
#define SetWindowsHookExW           SetWindowsHookExWrapW
#define SetWindowTextW              SetWindowTextWrapW
#define StartDocW                   StartDocWrapW
#define SystemParametersInfoW       SystemParametersInfoWrapW

#define TrackPopupMenu              TrackPopupMenuWrap
#define TrackPopupMenuEx            TrackPopupMenuExWrap

#ifndef NO_W95_TRANSACCEL_WRAPS_TBS
// #define NO_W95_TRANSACCEL_WRAPS_TBS if one of the objects uses IOleInPlaceActiveObject which has a TranslateAccelerator method.
#define TranslateAcceleratorW       TranslateAcceleratorWrapW
#endif // NO_W95_TRANSACCEL_WRAPS_TBS

#define UnregisterClassW            UnregisterClassWrapW
#define VkKeyScanW                  VkKeyScanWrapW
#define WinHelpW                    WinHelpWrapW
#define WritePrivateProfileStringW  WritePrivateProfileStringWrapW
#define wvsprintfW                  wvsprintfWrapW
#define WNetRestoreConnectionW      WNetRestoreConnectionWrapW
#define WNetGetLastErrorW           WNetGetLastErrorWrapW

#endif // NO_W95WRAPS_UNITHUNK

#if !defined(NO_W95WRAPS_UNITHUNK) || !defined(NO_W95WRAPS_MLUI)

#define CreateDialogIndirectParamW  CreateDialogIndirectParamWrapW
#define CreateDialogParamW          CreateDialogParamWrapW
#define DialogBoxIndirectParamW     DialogBoxIndirectParamWrapW                 // UNICODE, ML
//#ifdef DialogBoxIndirectW
//#undef DialogBoxIndirectW
//#endif
//#define DialogBoxIndirectW(i,h,w,f) DialogBoxIndirectParamWrapW(i,h,w,f,d,0)    // UNICODE, ML
#define DialogBoxParamW             DialogBoxParamWrapW                         // UNICODE, ML
//#ifdef DialogBoxW
//#undef DialogBoxW
//#endif
//#define DialogBoxW(i,t,w,f)         DialogBoxParamWrapW(i,t,w,f,0)              // UNICODE, ML
#define ShellMessageBoxW            ShellMessageBoxWrapW

#define DeleteMenu                  DeleteMenuWrap
#define DestroyMenu                 DestroyMenuWrap

#endif // !defined(NO_W95WRAPS_UNITHUNK) || !defined(NO_W95WRAPS_MLUI)


#if !defined(NO_OLE32_WRAPS)
#define CLSIDFromString             CLSIDFromStringWrap
#define CLSIDFromProgID             CLSIDFromProgIDWrap
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\wutilsp.h ===
#define MAX_PRN_PAGES 10

//
// This data structure is privately shared with 
// prtprop.c in SHELLDLL
// prt16.c in LIBRARY
//
typedef struct // apg
{
    DWORD cpages;
    HPROPSHEETPAGE ahpage[MAX_PRN_PAGES];
} PAGEARRAY, FAR * LPPAGEARRAY;

// thunk from shell232.dll -> shell.dll
VOID WINAPI CallAddPropSheetPages16(LPFNADDPROPSHEETPAGES lpfn16, LPVOID hdrop, LPPAGEARRAY papg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\help.h ===
// This file contains help context id's in the master windows.h file.

// Id's over 61440 are reserved and will ALWAYS use windows.hlp when
// used for context-sensitive help.

// Id's from 1-999 are reserved for Object help

// REVIEW: has to be 28440 until new help compiler is available

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_BACK 	0x3023
#define IDH_NEXT 	0x3024
#define IDH_FINISH 	0x3025

#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_COMM_APPLYNOW               28447
#define IDH_FONT_STYLE                  28448
#define IDH_FONT_SIZE                   28449
#define IDH_FONT_SAMPLE                 28450
#define IDH_FONT_EFFECTS                28451
#define IDH_FONT_FONT                   28452
#define IDH_PRINT_SETUP_AVAIL           28453
#define IDH_PRINT_SETUP_OPTIONS         28454
#define IDH_PRINT_SETUP_DETAILS         28455
#define IDH_OPEN_LOCATION               28456
#define IDH_OPEN_FILES                  28457
#define IDH_OPEN_READONLY               28459
#define IDH_OPEN_FILETYPE               28460
#define IDH_OPEN_PATH                   28461
#define IDH_OPEN_FILENAME               28462
#define IDH_FIND_SEARCHTEXT             28463
#define IDH_FIND_NEXT_BUTTON            28464
#define IDH_FIND_WHOLE                  28467
#define IDH_FIND_CASE                   28468
#define IDH_REPLACE_REPLACE             28469
#define IDH_REPLACE_REPLACE_ALL         28470
#define IDH_REPLACE_REPLACEWITH         28471
#define IDH_PRINT_PRINTER               28472
#define IDH_PRINT_PRINTER_SETUP         28473
#define IDH_PRINT_COPIES                28474
#define IDH_PRINT_COLLATE               28475
#define IDH_PRINT_TO_FILE               28476
#define IDH_PRINT_QUALITY               28477
#define IDH_PRINT_RANGE                 28478
#define IDH_PAGE_SAMPLE                 28485
#define IDH_PAGE_ORIENTATION            28486
#define IDH_PAGE_PAPER_SIZE             28487
#define IDH_PAGE_PAPER_SOURCE           28488
#define IDH_PAGE_MARGINS                28489
#define IDH_OPEN_DRIVES                 28490
#define IDH_COMM_DRIVE                  28491
#define IDH_COMM_PASSWDBUTT             28492
#define IDH_COMM_OLDPASSWD              28493
#define IDH_BROWSE                      28496
#define IDH_COLOR_CUSTOM                28497
#define IDH_COLOR_SAMPLE_COLOR          28498
#define IDH_COLOR_HUE                   28500
#define IDH_COLOR_SAT                   28501
#define IDH_COLOR_RED                   28502
#define IDH_COLOR_GREEN                 28503
#define IDH_COLOR_BLUE                  28504
#define IDH_COLOR_LUM                   28505
#define IDH_COLOR_ADD                   28506
#define IDH_COLOR_COLOR_SOLID           28507
#define IDH_COLOR_DEFINE                28508
#define IDH_QUICKINFO                   28509
#define IDH_NO_CROSSREF                 28510
#define IDH_CHARMAP_INSERT              28511
#define IDH_COMM_USER_NAME              28512
#define IDH_COMM_USER_SERVERNAME        28513
#define IDH_COMM_USER_SELECT_FROM       28514
#define IDH_COMM_USER_SELECTED          28515
#define IDH_PRINT32_RANGE               28516
#define IDH_PRINT_PROPERTIES            28517
#define IDH_PRINT_FILENAME              28518
#define IDH_PRINT_CHOOSE_PRINTER        28519
#define IDH_FIND_DIRECTION              28520
#define IDH_FONT_COLOR                  28521
#define IDH_PRINT_SETUP_PAPER           28522
#define IDH_PRINT_SETUP_ORIENT          28523
#define IDH_OPEN_BUTTON                 28529
#define IDH_SAVE_BUTTON                 28531
#define IDH_COLOR_BASIC                 28532
#define IDH_COLOR_CUSTOM_CUSTOM         28533
#define IDH_COLOR_SAMPLE_SCROLL         28534
#define IDH_FONT_SCRIPT                 28535
#define IDH_KERNEL_TASK_LIST            28536
#define IDH_KERNEL_END_TASK             28537
#define IDH_KERNEL_SHUTDOWN             28538
#define IDH_QVIEW_DISPLAY               28539
#define IDH_CHARMAP_COPY                28540
#define IDH_CHARMAP_FONT                28541
#define IDH_CHARMAP_CHARACTERS          28542
#define IDH_CHARMAP_SELECTED_CHARS      28543
#define IDH_CHARMAP_SELECT_BUTTON       28544
#define IDH_CHARMAP_HELP_BUTTON         28545
#define IDH_BOLD                        28546
#define IDH_ITALIC                      28547
#define IDH_COMM_GROUPBOX               28548
#define IDH_OPEN_FILES32                28549
#define IDH_SAVE_FILETYPE               28550
#define IDH_SYSTEM_CFG_OLDNAME          28551
#define IDH_DIAL_WHAT_WRONG             28552
#define IDH_COMCTL_RESET                28553
#define IDH_COMCTL_MOVEUP               28554
#define IDH_COMCTL_MOVEDOWN             28555
#define IDH_COMCTL_BUTTON_LIST          28556
#define IDH_COMCTL_ADD                  28557
#define IDH_COMCTL_REMOVE               28558
#define IDH_COMCTL_AVAIL_BUTTONS        28559
#define IDH_COMCTL_CLOSE                28560
#define IDH_PAGE_PRINTER                28561
#define IDH_DCC_WHAT_WRONG              28562
#define IDH_FILEVIEWER_PREVIEW          28563
#define IDH_PRINT_NETWORK               28564
#define IDH_PRINT_SETUP_DUPLEX          28565

#define IDH_OLEPROP_SUMMARY             28569
#define IDH_OLEPROP_STATISTICS          28570
#define IDH_CONFIGURE_LPT_PORT          28571
#define IDH_ADD_LOCAL_PORT              28572
#define IDH_PRINT_PORT_NAME             28573
#define IDH_PRINT_OUTPUT_FILE           28574
#define IDH_DISKCOPY_START              28575
#define IDH_DISKCOPY_FROM               28576
#define IDH_DISKCOPY_TO                 28577

#define IDH_PRINT_FIND_PRINTER          29010
#define IDH_PRINT_PRINTER_FOLDER        29015

#define IDH_OPEN_SHORTCUT_BAR           29500
#define IDH_OPEN_BACK_BUTTON            29501
#define IDH_PRINT_BTN                   29510

// ID value for Win 3.1 user transition piece: jump from First experience screen
#define WIN31_TRANSITION_PIECE          30000

// ID values 2100-2199 are reserved for Disk Compression.
// See dos\dos86\dblspace\utility\comphelp.h

// ID values 2200-2299 are reserved for Find File. See findhlp.h.

// ID values 2400-2499 are reserved for MultiMedia control panel. See medhelp.h

// ID values 2500-2699 are reserved for Print Trouble Shooter

// ID values 2700-2799 are reserved for Network control panel. See nethelp.h

// ID values 2800-2899 are reserved for Online Registration.

// ID values 2900-2999 are reserved for Clipbook and Chat.

#define IDH_COMM_NEWPASSWD              3018    // See pwdids.h
#define IDH_COMM_NEWPASSCONF            3019    // See pwdids.h

// Briefcase ids

#define IDH_BFC_UPDATE_SCREEN           3100
#define IDH_BFC_UPDATE_BUTTON           3101
#define IDH_BFC_PROP_FILEICON           3102
#define IDH_BFC_PROP_SPLIT_BUTTON       3103
#define IDH_BFC_PROP_FINDORIG_BUTTON    3104
#define IDH_BFC_FILTER_TYPE             3105
#define IDH_BFC_FILTER_INCLUDE          3106

// ID values 3300-3499 are reserved for international. See intlhlp.h

// ID values for the Keyboard property sheet

#define IDH_DLGKEY_REPDEL               4000
#define IDH_DLGKEY_REPSPEED             4001
#define IDH_DLGKEY_REPTEST              4002
#define IDH_DLGKEY_TYPE                 4008
#define IDH_DLGKEY_CHANGE               4010
#define IDH_DLGKEY_CURSBLNK             4011
#define IDH_DLGKEY_CURSOR_GRAPHIC       4012

#define IDH_KEYB_INPUT_LIST             4028
#define IDH_KEYB_INPUT_ADD              4029
#define IDH_KEYB_INPUT_PROP             4030
#define IDH_KEYB_INPUT_DEL              4031
#define IDH_KEYB_INPUT_DEFAULT          4032
#define IDH_KEYB_CAPSLOCK_LAYOUT        4033
#define IDH_KEYB_INPUT_LANG             4034
#define IDH_KEYB_INPUT_INDICATOR        4035
#define IDH_KEYB_INPUT_ONSCRN_KEYB      4036
#define IDH_KEYB_INPUT_PROP_LANG        4039
#define IDH_KEYB_INPUT_PROP_KEYLAY      4042
#define IDH_KEYB_INPUT_DEF_LANG         4043
#define IDH_KEYB_INPUT_SHORTCUT         4044
#define IDH_KEYB_INDICATOR_ON_TASKBAR   4045
#define IDH_KEYB_IME_SETTINGS           4046
#define IDH_KEYB_HOTKEY_LIST            4047
#define IDH_KEYB_CHANGE_HOTKEY          4048
#define IDH_KEYB_CHANGE_KEY             4049

// ID values for Desktop Property sheet

// Settings Page
#define IDH_SETTINGS_DISPLAYDESK		4064	//Monitor icon display area
#define IDH_SETTINGS_DISPLAYLIST		4065	//Monitor dropdown
#define IDH_SETTINGS_COLORBOX		    4066	//Colors dropdown	
#define IDH_SETTINGS_SCREENSIZE		    4067	//Screen Area dropdown		
#define IDH_SETTINGS_DISPLAYUSEME	    4068	//Use this monitor chkbx
#define IDH_SETTINGS_DISPLAYPROPERTIES	4069	//Advanced button

// General Page
#define IDH_GENERAL_FONTSIZEGRP	        4080	//Font size dropdown
#define IDH_GENERAL_DYNA			    4081	//Compatibility option group
#define IDH_GENERAL_NODYNA	            4082	//Restart the computer option
#define IDH_GENERAL_YESDYNA             4083	//Apply the changes option	
#define IDH_GENERAL_SHUTUP              4084	//Always prompt before option

// Background Page

#define IDH_DSKTPBACKGROUND_MONITOR     4100
#define IDH_DSKTPBACKGROUND_PATTLIST    4102
#define IDH_DSKTPBACKGROUND_WALLLIST    4104
#define IDH_DSKTPBACKGROUND_BROWSE      4105
#define IDH_DSKTPBACKGROUND_TILE        4106
#define IDH_DSKTPBACKGROUND_CENTER      4107
#define IDH_DSKTPBACKGROUND_DISPLAY     4108
#define IDH_DSKTPBACKGROUND_EDITPAT     4109

// Screen Saver Page

#define IDH_DSKTPSCRSAVER_LISTBX        4111
#define IDH_DSKTPSCRSAVER_WAIT          4112
#define IDH_DSKTPSCRSAVER_TEST          4113
#define IDH_DSKTPSCRSAVER_SETTINGS      4114
#define IDH_DSKTPSCRSAVER_MONITOR       4115
#define IDH_SCRSAVER_GRAPHIC            4116
#define IDH_SCRSAVER_LOWPOWSTANDBY      4117
#define IDH_SCRSAVER_SHUTOFFPOW         4118

// Appearance Page

#define IDH_APPEAR_SCHEME               4120
#define IDH_APPEAR_SAVEAS               4121
#define IDH_APPEAR_DELETE               4122
#define IDH_APPEAR_GRAPHIC              4123
#define IDH_APPEAR_ITEMSIZE             4124
#define IDH_APPEAR_FONTBOLD             4125
#define IDH_APPEAR_FONTSIZE             4126
#define IDH_APPEAR_FONTCOLOR            4127
#define IDH_APPEAR_FONTITALIC           4128
#define IDH_APPEAR_BACKGRNDCOLOR        4129
#define IDH_APPEAR_ITEM                 4130
#define IDH_APPEAR_FONT                 4131

// Monitor Settings Page




#define IDH_DSKTPMONITOR_CHANGE_DISPLAY 4134
#define IDH_DSKTPMONITOR_COLOR          4135
#define IDH_DSKTPMONITOR_AREA           4136
#define IDH_DSKTPMONITOR_REFRESH        4137
#define IDH_DSKTPMONITOR_LIST_MODES     4138
#define IDH_DSKTPMONITOR_ENERGY         4139
#define IDH_DSKTPMONITOR_MONITOR        4140
#define IDH_DSKTPMONITOR_TEST           4141
#define IDH_DSKTPMONITOR_ADTYPE         4143
#define IDH_DSKTPMONITOR_CHANGE1        4144
#define IDH_DSKTPMONITOR_CHANGE2        4145
#define IDH_DSKTPMONITOR_MONTYPE        4146
#define IDH_DSKTPMONITOR_CUSTOM         4148
#define IDH_DSKTPMONITOR_FONTSIZE       4149
#define IDH_DSKTPMONITOR_AD_FACTS       4150
#define IDH_DSKTPMONITOR_DRIVER         4151
#define IDH_DSKTPMONITOR_DETECT         4152


#define IDH_SAVESCHEME_EDITFIELD        4170
#define IDH_CUSTOMFONTS_FONTSCALE       4171
#define IDH_CUSTOMFONTS_RULER           4172
#define IDH_CUSTOMFONTS_SAMPLE          4173

#define IDH_PATTERN_EDIT_NAME           4174
#define IDH_PATTERN_EDIT_SAMPLE         4175
#define IDH_PATTERN_EDIT_PIXEL_SCREEN   4176
#define IDH_PATTERN_EDIT_EXIT           4177
#define IDH_PATTERN_EDIT_ADD            4178
#define IDH_PATTERN_EDIT_CHANGE         4179
#define IDH_PATTERN_EDIT_REMOVE         4180

// ID values for Defrag

#define IDH_DEFRAG_START                        4200
#define IDH_DEFRAG_STOP                         4201
#define IDH_DEFRAG_PAUSE                        4202
#define IDH_DEFRAG_SHOWDETAILS                  4203
#define IDH_DEFRAG_HIDEDETAILS                  4204
#define IDH_DEFRAG_LEGEND                       4205
#define IDH_DEFRAG_SPARKLESCRN                  4206
#define IDH_DEFRAG_DEFRAGNOW_ANYWY              4207
#define IDH_DEFRAG_SELECTDRIVE                  4208
#define IDH_DEFRAG_ADVANCED                     4209
#define IDH_DEFRAG_EXIT                         4210
#define IDH_DEFRAG_DRIVELIST                    4211
#define IDH_DEFRAG_RESUME                       4212
#define IDH_DEFRAG_FULL                         4213
#define IDH_DEFRAG_FILESONLY                    4214
#define IDH_DEFRAG_FRSPCONLY                    4215
#define IDH_DEFRAG_USEONCE                      4218
#define IDH_DEFRAG_USEALWAYS                    4219
#define IDH_DEFRAG_GASGAUGE                     4220
#define IDH_DEFRAG_CHECK_DRIVE_FOR_ERRORS       4221

// RNA id values

#define IDH_RNA_CONNECT_NAME            4250
#define IDH_RNA_CONNECT_USER            4251
#define IDH_RNA_CONNECT_PASSWORD        4252
#define IDH_RNA_CONNECT_SAVEPW          4253
#define IDH_RNA_CONNECT_FROM            4254
#define IDH_RNA_OUT_PHONE_NUMBER        4255
#define IDH_RNA_OUT_DIALASST            4256
#define IDH_RNA_OUT_COMPLETE_PHONE      4257
#define IDH_RNA_OUT_CONNECT_BUTTON      4258
#define IDH_RNA_CHOOSE_MODEM            4273
#define IDH_RNA_CONFIG_MODEM            4274
#define IDH_RNA_MODEM_SERVER            4275
#define IDH_RNA_SERVERS                 4276
#define IDH_RNA_CONNECTION_LIST         4277
#define IDH_RNA_SERVER_COMPRESS         4278
#define IDH_RNA_SERVER_ENCRYPT          4279
#define IDH_RNA_SERVER_NETLOGON         4280
#define IDH_RNA_SERVER_PROTOCOL         4281
#define IDH_RNA_SERVER_TCPIPSET         4282
#define IDH_RNA_TCPIP_ASSIGNED_IP       4283
#define IDH_RNA_TCPIP_SPECIFY_IP        4284
#define IDH_RNA_TCPIP_ASSIGNED_DNS      4285
#define IDH_RNA_TCPIP_SPECIFY_DNS       4286
#define IDH_RNA_TCPIP_COMPRESS          4287
#define IDH_RNA_TCPIP_GATEWAY           4288
#define IDH_RNA_SETTINGS_REDIAL         4290
#define IDH_RNA_SETTINGS_TIMES          4291
#define IDH_RNA_SETTINGS_MINSEC         4292
#define IDH_RNA_SETTINGS_PROMPT         4293

// ID values for printing property sheets

#define IDH_PRTPROPS_TYPE_LOCATION              4501
#define IDH_PRTPROPS_COMMENT                    4502
#define IDH_PRTPROPS_NAME_STATIC                4505
#define IDH_PRTPROPS_PORT                       4506
#define IDH_PRTPROPS_DRIVER                     4507
#define IDH_PRTPROPS_NEW_PORT                   4508
#define IDH_PRTPROPS_NEW_DRIVER                 4509
#define IDH_PRTPROPS_SEPARATOR                  4510
#define IDH_PRTPROPS_ICON                       4512
#define IDH_PRTPROPS_SPOOL_SETTINGS             4513
#define IDH_PRTPROPS_PORT_SETTINGS              4514
#define IDH_PRTPROPS_SETUP                      4515
#define IDH_PRTPROPS_SEPARATOR_BROWSE           4516
#define IDH_PRTPROPS_TIMEOUT_NOTSELECTED        4517
#define IDH_PRTPROPS_TIMEOUT_TRANSRETRY         4518
#define IDH_PRTPROPS_TEST_PAGE                  4519
#define IDH_SPOOLSETTINGS_SPOOL                 4520
#define IDH_SPOOLSETTINGS_NOSPOOL               4521
#define IDH_SPOOLSETTINGS_PRINT_FASTER          4522
#define IDH_SPOOLSETTINGS_LESS_SPACE            4523
#define IDH_SPOOLSETTINGS_DATA_FORMAT           4524
#define IDH_SPOOLSETTINGS_RESTORE               4525
#define IDH_PRTPROPS_DEL_PORT                   4528
#define IDH_ADDPORT_NETWORK                     4529
#define IDH_ADDPORT_PORTMON                     4530
#define IDH_ADDPORT_NETPATH                     4531
#define IDH_ADDPORT_BROWSE                      4532
#define IDH_ADDPORT_LB                          4533
#define IDH_DELPORT_LB                          4534
#define IDH_PRTPROPS_MAP_PRN_PORT               4535
#define IDH_PRTPROPS_UNMAP_PRN_PORT             4536
#define IDH_SPOOLSETTINGS_ENABLE_BIDI           4537
#define IDH_SPOOLSETTINGS_DISABLE_BIDI          4538

// ID values for System property sheets

#define IDH_SYSTEM_SYSTEM               4600
#define IDH_SYSTEM_RESOURCES            4602
#define IDH_SYSTEM_OWNER                4603
#define IDH_SYSTEM_PRO_COPY             4624
#define IDH_SYSTEM_PRO_RENAME           4625
#define IDH_SYSTEM_PRO_DELETE           4626
#define IDH_SYSTEM_PRO_LIST             4627
#define IDH_SYSTEM_LOGO                 4628
#define IDH_SYSTEM_CFG_EDIT             4629
#define IDH_SYSTEM_PROCESSOR            4630
#define IDH_SYSTEM_VIEW_RESOURCETYPE    4631
#define IDH_SYSTEM_PAGING               4632
#define IDH_SYSTEM_ADVANCED             4633
#define IDH_SYSTEM_VIRTMEM_ADJUST       4634
#define IDH_SYSTEM_VIRTMEM_DISABLE      4635

#define IDH_SYSTEM_RESERVE_PICKONE      4636

#define IDH_SYSTEM_RESERVE_MODIFY       4639
#define IDH_SYSTEM_RESERVE_ADD          4640
#define IDH_SYSTEM_RESERVE_REMOVE       4641
#define IDH_SYSTEM_CLASSLIST            4642
#define IDH_SYS_PERF_GRAPHICS           4643
#define IDH_SYS_PERF_GRAPHICS_SLIDER    4644

#define IDH_SYSTEM_FILESYSTEM           4661
#define IDH_SYSTEM_DISK                 4662
#define IDH_SYSTEM_CDROM                4663
#define IDH_SYSTEM_CACHE                4664
#define IDH_SYSTEM_BALANCE              4665
#define IDH_SYSTEM_TROUBLESHOOT         4666
#define IDH_SYSTEM_FSCHANGE             4667
#define IDH_DEVMGR_REMOVEONE            4671
#define IDH_DEVMGR_REMOVEALL            4672
#define IDH_SYSTEM_VIEW_RESRES          4673
#define IDH_DEVMGR_CLASS                4674
#define IDH_DEVMGR_ENABLE_HEAD          4675
#define IDH_DEVMGR_PRINT_SELECT         4676
#define IDH_DEVMGR_PRINT_FILE           4677
#define IDH_DEVMGR_SCSI_INFO            4678
#define IDH_DEVMGR_DISKOPTIONS          4679
#define IDH_DEVMGR_DISCONNECT           4680
#define IDH_DEVMGR_SYNC                 4681
#define IDH_DEVMGR_AUTOINSERT           4682
#define IDH_DEVMGR_REMOVABLE            4683
#define IDH_DEVMGR_INT13                4684
#define IDH_DEVMGR_DRIVE_LETTER         4685
#define IDH_DEVMGR_DRIVE_RESERVED       4686
#define IDH_NHF_HELP                4687
#define IDH_NHF_WINDOWS             4688
#define IDH_NHF_DISK                4689
#define IDH_NHF_NODRIVER            4690
#define IDH_NHF_SIMILAR             4691
#define IDH_DMA_MEMORY              4692
#define IDH_DMA_ADDRESS             4693
#define IDH_DMA_DEFAULT             4694
#define IDH_SCSIPROP_SETTINGS       4695
#define IDH_PCI_ENUMTYPE            4697
#define IDH_PCI_IRQ_STEERING        4698
#define IDH_PCI_SETDEFAULTS         4699

// ID's for File properties

#define IDH_FPROP_VER_INFO                      4700
#define IDH_FPROP_GEN_COMPRESSED                4701
#define IDH_FPROP_GEN_COMPRESSED_SIZE           4702
#define IDH_FPROP_SECURITY_PERMISSIONS          4703
#define IDH_FPROP_SECURITY_AUDITING             4704
#define IDH_FPROP_SECURITY_OWNERSHIP            4705
#define IDH_FPROP_GEN_NAME                      4708
#define IDH_FPROP_GEN_TYPE                      4709
#define IDH_FPROP_GEN_SIZE                      4710
#define IDH_FPROP_GEN_LOCATION                  4711
#define IDH_FPROP_GEN_DOSNAME                   4712
#define IDH_FPROP_GEN_LASTCHANGE                4713
#define IDH_FPROP_GEN_LASTACCESS                4714
#define IDH_FPROP_GEN_READONLY                  4715
#define IDH_FPROP_GEN_ARCHIVE                   4716
#define IDH_FPROP_GEN_HIDDEN                    4717
#define IDH_FPROP_GEN_SYSTEM                    4718
#define IDH_FPROP_GEN_PATH                      4719
#define IDH_FPROP_VER_ABOUT                     4720
#define IDH_FCAB_LINK_NAME                      4721
#define IDH_FCAB_DRV_CLEANUP                    4722
#define IDH_FCAB_LINK_LOCATION                  4723
#define IDH_FCAB_LINK_LINKTO                    4724
#define IDH_FCAB_LINK_LINKTYPE                  4725
#define IDH_FCAB_LINK_SIZE                      4726
#define IDH_FCAB_LINK_WORKING                   4727
#define IDH_FCAB_LINK_HOTKEY                    4728
#define IDH_FCAB_LINK_RUN                       4729
#define IDH_FCAB_LINK_CHANGEICON                4730
#define IDH_FCAB_LINK_FIND                      4731
#define IDH_FCAB_LINK_ICONNAME                  4732
#define IDH_FCAB_LINK_CURRENT_ICON              4733
#define IDH_FCAB_DRV_ICON                       4734
#define IDH_FCAB_DRV_LABEL                      4735
#define IDH_FCAB_DRV_TYPE                       4736
#define IDH_FCAB_DRV_USEDCOLORS                 4737
#define IDH_FCAB_DRV_TOTSEP                     4738
#define IDH_FCAB_DRV_PIE                        4739
#define IDH_FCAB_DRV_LETTER                     4740
#define IDH_FCAB_DRV_FS                         4741
#define IDH_FCAB_DISKTOOLS_CHKNOW               4742
#define IDH_FCAB_DISKTOOLS_BKPNOW               4743
#define IDH_FCAB_DISKTOOLS_OPTNOW               4744
#define IDH_FCAB_DELFILEPROP_DELETED            4745
#define IDH_FCAB_DRV_COMPRESS                   4746
#define IDH_FPROP_GEN_DATE_CREATED              4747
#define IDH_FCAB_FOLDEROPTIONS_ALWAYS           4748
#define IDH_FCAB_FOLDEROPTIONS_NEVER            4749
#define IDH_FCAB_VIEWOPTIONS_SHOWALL            4750
#define IDH_FCAB_VIEWOPTIONS_HIDDENEXTS         4751
#define IDH_FCAB_VIEWOPTIONS_SHOWFULLPATH       4752
#define IDH_FCAB_VIEWOPTIONS_HIDEEXTS           4753
#define IDH_FCAB_VIEWOPTIONS_SHOWDESCBAR        4754
#define IDH_FCAB_FT_PROP_LV_FILETYPES           4755
#define IDH_FCAB_FT_PROP_NEW                    4756
#define IDH_FCAB_FT_PROP_REMOVE                 4757
#define IDH_FCAB_FT_PROP_FINDEXT                4758
#define IDH_FCAB_FT_PROP_EDIT                   4759
#define IDH_FCAB_FT_PROP_DETAILS                4760
#define IDH_FCAB_FT_CMD_ACTION                  4761
#define IDH_FCAB_FT_CMD_EXE                     4762
#define IDH_FCAB_FT_CMD_BROWSE                  4763
#define IDH_FCAB_FT_CMD_USEDDE                  4764
#define IDH_FCAB_FT_CMD_DDEMSG                  4765
#define IDH_FCAB_FT_CMD_DDEAPP                  4766
#define IDH_FCAB_FT_CMD_DDEAPPNOT               4767
#define IDH_FCAB_FT_CMD_DDETOPIC                4768
#define IDH_FCAB_FT_EDIT_DOCICON                4769
#define IDH_FCAB_FT_EDIT_CHANGEICON             4770
#define IDH_FCAB_FT_EDIT_DESC                   4771
#define IDH_FCAB_FT_EDIT_EXT                    4772
#define IDH_FCAB_FT_EDIT_LV_CMDS                4773
#define IDH_FCAB_FT_EDIT_DEFAULT                4774
#define IDH_FCAB_FT_EDIT_NEW                    4775
#define IDH_FCAB_FT_EDIT_EDIT                   4776
#define IDH_FCAB_FT_EDIT_REMOVE                 4777
#define IDH_FCAB_DELFILEPROP_COMPRESSED         4778
#define IDH_FPROP_GEN_ICON                      4779
#define IDH_MULTPROP_NAME                       4780
#define IDH_FPROP_FOLDER_CONTAINS               4781
#define IDH_FCAB_LINK_ICON                      4782
#define IDH_FCAB_DELFILEPROP_LOCATION           4783
#define IDH_FCAB_DELFILEPROP_READONLY           4784
#define IDH_FCAB_DELFILEPROP_HIDDEN             4785
#define IDH_FCAB_DELFILEPROP_ARCHIVE            4786
#define IDH_FCAB_DELFILEPROP_SYSTEM             4787
#define IDH_FCAB_OPENAS_DESCRIPTION             4788
#define IDH_FCAB_OPENAS_APPLIST                 4789
#define IDH_FCAB_OPENAS_OTHER                   4790
#define IDH_FCAB_FT_EDIT_QUICKVIEW              4791
#define IDH_GENDRV_CHKWARN                      4792
#define IDH_GENDRV_MBFREE                       4793
#define IDH_FCAB_OPENAS_MAKEASSOC               4794
#define IDH_FCAB_FT_EDIT_SHOWEXT                4795
#define IDH_FCAB_FT_PROP_CONTTYPERO             4796    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_CONTTYPE               4797    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_DEFEXT                 4798    // T.B.D. IExplorer merge
#define IDH_FCAB_VIEWOPTIONS_SHOWCOMPCOLOR      4799


// Screen saver ids

#define IDH_BEZIER_SPEED                4800
#define IDH_BEZIER_LINES                4801
#define IDH_BEZIER_CURVES               4802
#define IDH_BEZIER_DENSITY              4803
#define IDH_BEZIER_ONECOLOR             4804
#define IDH_BEZIER_CHOOSECLR            4805
#define IDH_BEZIER_MULTCOLOR            4806
#define IDH_BEZIER_CLRSCRN              4807
#define IDH_FLYINGWIN_WARP              4808
#define IDH_FLYINGWIN_DENSTY            4809
#define IDH_COMM_PASSWDCHKBOX           4810
#define IDH_MARQUEE_CENTER              4811
#define IDH_MARQUEE_RANDOM              4812
#define IDH_MARQUEE_SPEED               4813
#define IDH_MARQUEE_COLOR               4814
#define IDH_MARQUEE_TEXT                4815
#define IDH_MARQUEE_FORMAT              4817
#define IDH_MYST_SHAPE                  4818
#define IDH_MYST_ACTVBOX                4819
#define IDH_MYST_LINES                  4820
#define IDH_MYST_TWOCOLORS              4821
#define IDH_MYST_MULTIPLE               4822
#define IDH_MYST_CLEARSCRN              4823
#define IDH_STARS_WARP                  4824
#define IDH_STARS_DENSTY                4825
#define IDH_HOP_DELAY                   4826
#define IDH_HOP_SCALE                   4827

// More ids for file properties (first range wasn't big enough)
#define IDH_FCAB_VIEWOPTIONS_WEBVIEW                    4850
#define IDH_FCAB_VIEWOPTIONS_WIN95VIEW                  4851
#define IDH_FCAB_VIEWOPTIONS_DOUBLECLICKINWEBVIEW       4852
#define IDH_FCAB_VIEWOPTIONS_SINGLECLICKINWEBVIEW       4853
#define IDH_FCAB_LINK_DESCRIPTION                       4854

// New filetype's dialog help ID's
#define IDH_FCAB_FT_NE_ADV_BUT                          4855
#define IDH_FCAB_FT_NE_FILETYPE                         4856
#define IDH_FPROP_GEN_OPENSWITH                         4857
#define IDH_FPROP_GEN_ADVANCED                          4858
#define IDH_FPROP_GEN_INDEX                             4859
#define IDH_FPROP_GEN_ENCRYPT                           4860
#define IDH_FCAB_LINK_RUNASUSER                         4861
#define IDH_FCAB_DRV_INDEX                              4862

#define IDH_FCAB_FT_NE_FILEEXT                          4863
#define IDH_FCAB_FT_PROP_EDIT_RESTORE                   4864

#define IDH_FPROP_GEN_MOUNTEDPROP                       4865
#define IDH_FPROP_GEN_MOUNTEDTARGET                     4866

// id's for date-time property sheet

#define IDH_DATETIME_MONTH              4901
#define IDH_DATETIME_YEAR               4902
#define IDH_DATETIME_DATE               4903
#define IDH_DATETIME_TIME               4904
#define IDH_DATETIME_TIMEZONE           4907
#define IDH_DATETIME_BITMAP             4908
#define IDH_DATETIME_DAYLIGHT_SAVE      4909
#define IDH_DATETIME_CURRENT_TIME_ZONE  4910
#define IDH_DATETIME_DATE_GROUP         4911

// id's for Modem Setup

#define IDH_MODEM_SELECT                5000
#define IDH_MODEM_DETECT                5001
#define IDH_MODEM_PORT                  5002
#define IDH_MODEM_NAME                  5003
#define IDH_MODEM_INSTALLED             5004
#define IDH_MODEM_PROP                  5005
#define IDH_MODEM_NEW                   5006
#define IDH_MODEM_DELETE                5007

// id's for Unimodem property pages

#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056
//#define IDH_UNI_CON_TONE                5057      Deleted
#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060
#define IDH_UNI_CON_PORT                5061
#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072
//#define IDH_UNI_OPT_CONNECTION          5073      Deleted
#define IDH_UNI_OPT_PRE_DIAL            5074
#define IDH_UNI_OPT_POST_DIAL           5075
#define IDH_UNI_OPT_MANUAL              5076
#define IDH_UNI_OPT_STATUS              5077
#define IDH_UNI_TERMINAL                5078
#define IDH_UNI_STATUS_TALK             5079
#define IDH_UNI_STATUS_HANGUP           5080
#define IDH_UNI_GEN_PORT_INT            5081
#define IDH_UNI_OPT_WAIT                5082

#define IDH_LIGHTS                      5099

// id's for TAPI Dial Helper (5100-5199)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// id's 5200 - 5500 are reserved for DOS

//  Add/Remove Program IDs reserved 5600-5699

// Miscellaneous ids

#define IDH_TRAY_RUN_COMMAND            6002
#define IDH_TRAY_RUN_SEPMEM             6003
#define IDH_TRAY_TASKBAR_ONTOP          6004
#define IDH_TRAY_TASKBAR_AUTOHIDE       6005
#define IDH_TRAY_SHUTDOWN_SHUTDOWN      6007
#define IDH_TRAY_SHUTDOWN_RESTART       6008
#define IDH_TRAY_SHUTDOWN_LOGOFF        6009
#define IDH_STARTMENU_SMALLICONS        6010
#define IDH_MENUCONFIG_CLEAR            6011
#define IDH_TRAY_ADD_PROGRAM            6012
#define IDH_TRAY_REMOVE_PROGRAM         6013
#define IDH_TRAY_ADVANCED               6014
#define IDH_TRAY_SHUTDOWN_HELP          6015
#define IDH_TRAY_SHOW_CLOCK             6016
#define IDH_TRAY_REMOVEDLG_LIST         6017
#define IDH_TRAY_REMOVEDLG_DEL          6018
#define IDH_TASKBAR_OPTIONS_BITMAP      6019
#define IDH_TRAY_USE_ADAPTIVE_MENUS     6020
#define IDH_TRAY_RESORT_BUTTON          6021
#define IDH_TRAY_RUN_OK                 6022
#define IDH_TRAY_RUN_CANCEL             6023

// ID values for Virtual Memory Property sheet

#define IDH_DEVMGR_VIEW_BY              6204
#define IDH_SYSTEM_DM_PRINT             6205
#define IDH_DEVMGR_PATH                 6206

#define IDH_DEVMGR_CONFLICT_TRB         6260
#define IDH_DEVMGR_DRIVERINFO           6261
#define IDH_DEVMGR_CHANGEDRIVER         6262
#define IDH_DEVMGR_DRIVERS              6264
#define IDH_DEVMGR_PRINTER              6265
#define IDH_DEVMGR_PRINTOVERVIEW        6266
#define IDH_DEVMGR_PRINT_SYS            6267
#define IDH_DEVMGR_PRINT_CLASS          6268
#define IDH_DEVMGR_SHOW                 6271
#define IDH_DEVMGR_HAVEDISK             6272
#define IDH_DEVMGR_CHOOSE_DEVICE        6273

//  Ids for the performance page
#define IDH_PERFLOWRES                  6301
#define IDH_PERFLOWMEM                  6302
#define IDH_4MBHELP                     6303
#define IDH_PERFCOMPATVIRTMEM           6304
#define IDH_PERFVIRTMEMOFF              6305
#define IDH_PERFPCMCIAOFF               6306
#define IDH_PERFRMCOMPRESS              6307
#define IDH_PERFNOPMODEDRIVES           6308
#define IDH_PERFMBRHOOK                 6309
#define IDH_PERFREALMODEDRIVE           6310
#define IDH_PERFNOPMODETSR              6311

#define IDH_SYS_PERF_MEMORY             6320
#define IDH_SYS_PERF_SR                 6321
#define IDH_SYS_PERF_FS                 6322
#define IDH_SYS_PERF_VMEM               6323
#define IDH_SYS_PERF_COMPRESS           6324
#define IDH_SYS_PERF_PCMCIA             6325
#define IDH_SYS_PERF_PROBLEM            6326
#define IDH_SYS_PERF_DETAILS            6327


//  sysclass.dll
#define IDH_FPU_DIAGTEXT                6350
#define IDH_FPU_SETTING                 6351
#define IDH_POWERCFG_ENABLE_PM          6352
#define IDH_POWERCFG_FORCE_APM          6353
#define IDH_POWERCFG_DISABLE_INTEL      6354
#define IDH_POWERCFG_POLLING            6355


// More ids for system cpl (ran out of #'s above)
#define IDH_SYSTEM_DMCONFIG_RETRY               6400
#define IDH_SYSTEM_DMCONFIG_IGNORE              6401

#define IDH_SYSTEM_OEMSUPPORT           6407
#define IDH_SYSTEM_DEVGEN_STATUS                6408
#define IDH_SYSTEM_DEGEN_SPECIALMF      6409
#define IDH_SYSTEM_DEVRES_SETTINGS              6410
#define IDH_SYSTEM_USESYSSETTINGS               6411
#define IDH_SYSTEM_DEVRES_CHANGE                6412
#define IDH_SYSTEM_LOGCONFIGLIST                6413
#define IDH_SYSTEM_REGRSTR_RESTORE              6417
#define IDH_SYSTEM_TREE                         6418
#define IDH_SYSTEM_PROPERTIES                   6419
#define IDH_SYSTEM_DM_REFRESH                   6420

#define IDH_SYSTEM_VIRTMEM_ON                   6421
#define IDH_SYSTEM_VIRTMEM_DEFAULT              6422
#define IDH_SYSTEM_VIRTMEM_SWAPDRIVE            6424
#define IDH_SYSTEM_VIRTMEM_MINSIZE              6427
#define IDH_SYSTEM_VIRTMEM_MAXSIZE              6428

#define IDH_SYSTEM_DEVRES_DESC                  6442
#define IDH_SYSTEM_CONFLICT_IO                  6443
#define IDH_SYSTEM_EDITRANGE_STARTVAL           6444
#define IDH_SYSTEM_CONFLICT_USED                6445
#define IDH_SYSTEM_DM_REMOVE                    6446

#define IDH_POWERCFG_ENABLEMETER                        6452
#define IDH_POWERCFG_POWERSTATUSBAR                     6453
#define IDH_POWERCFG_PMLEVELLIST                        6454
#define IDH_POWERCFG_OPTIONS                            6455

#define IDH_PCMCIA_SELECT                               6458
#define IDH_PCMCIA_MEMORY                               6459
#define IDH_PCMCIA_SOUND                                6460
#define IDH_PCMCIA_CARDSERV                             6461

#define IDH_SYSTEM_DEVGEN_DEVDESC                       6462
#define IDH_SYSTEM_DEVRES_MAKEFC                        6463

#define IDH_SYSTEM_DEVRES_LISTCONFLICT                  6474

#define IDH_SYSTEM_VIEW_LIST                            6483
#define IDH_SYSTEM_RCW_LIST                             6485
#define IDH_SYSTEM_RCW_DETAILS                          6488

#define IDH_POWERCFG_STARTMENU          6491
#define IDH_BATMETER_LOWBATWARN         6492

#define IDH_PCMCIA_TRAY                                 6493
#define IDH_PCMCIA_EJECT                                6494
#define IDH_PCMCIA_WARN                                 6495
#define IDH_PCMCIA_LIST                                 6496

// browseui.dll
#define IDH_BROWSEUI_TB_TEXTOPTIONS                             6800
#define IDH_BROWSEUI_TB_ICONOPTIONS                             6801

// More WinDisk IDs

#define IDH_WINDISK_DDEMDBPB_IGNORE                             7000
#define IDH_WINDISK_DDEMDBPB_REPAIR                             7005
#define IDH_WINDISK_DDERRBOOT_IGNORE                            7010
#define IDH_WINDISK_DDERRBOOT_REPAIR                            7015
#define IDH_WINDISK_DDERRCVFNM_IGNORE                           7020
#define IDH_WINDISK_DDERRCVFNM_REPAIR                           7025
#define IDH_WINDISK_DDERRLSTSQZ_DISCARD                         7030
#define IDH_WINDISK_DDERRLSTSQZ_IGNORE                          7035
#define IDH_WINDISK_DDERRLSTSQZ_KEEP                            7040
#define IDH_WINDISK_DDERRMDFAT_IGNORE                           7045
#define IDH_WINDISK_DDERRMDFAT_REPAIR                           7050
#define IDH_WINDISK_DDERRSIG_IGNORE                             7055
#define IDH_WINDISK_DDERRSIG_REPAIR                             7060
#define IDH_WINDISK_DDERRXLSQZ_COPY                             7065
#define IDH_WINDISK_DDERRXLSQZ_DELETE                           7070
#define IDH_WINDISK_DDERRXLSQZ_IGNORE                           7075
#define IDH_WINDISK_DDESIZE2_IGNORE                             7080
#define IDH_WINDISK_DDESIZE2_REPAIR                             7085
#define IDH_WINDISK_FATERRCDLIMIT_DELETE                        7090
#define IDH_WINDISK_FATERRCDLIMIT_IGNORE                        7095
#define IDH_WINDISK_FATERRCDLIMIT_REPAIR                        7100
#define IDH_WINDISK_FATERRFILE_DELETE_FILE                      7105
#define IDH_WINDISK_FATERRFILE_DELETE_FOLDER                    7107
#define IDH_WINDISK_FATERRFILE_IGNORE                           7110
#define IDH_WINDISK_FATERRFILE_REPAIR                           7115
#define IDH_WINDISK_FATERRLSTCLUS_CONVERT                       7120
#define IDH_WINDISK_FATERRLSTCLUS_DISCARD                       7125
#define IDH_WINDISK_FATERRLSTCLUS_IGNORE                        7130
#define IDH_WINDISK_FATERRMISMAT_DONT_REPAIR                    7135
#define IDH_WINDISK_FATERRMISMAT_REPAIR                         7140
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FILE                    7145
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FOLDER                  7150
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FILE                    7155
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FOLDER                  7160
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FILE                    7165
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FOLDER                  7170
#define IDH_WINDISK_FATERRRESVAL_DONT_REPAIR                    7175
#define IDH_WINDISK_FATERRRESVAL_REPAIR                         7180
#define IDH_WINDISK_FATERRXLNK_COPY                             7185
#define IDH_WINDISK_FATERRXLNK_DELETE                           7190
#define IDH_WINDISK_FATERRXLNK_IGNORE                           7195
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_DEL_OTH                 7200
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_TRUNC_OTH               7205
#define IDH_WINDISK_FATERRXLNK_TRUNCATE_ALL                     7210
#define IDH_WINDISK_ISBAD_COMP_HOST_DONE_REPAIR                 7215
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_REPAIR              7220
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_RESTART             7225
#define IDH_WINDISK_ISBAD_COMP_RETRY                            7230
#define IDH_WINDISK_ISBAD_IGNORE                                7235
#define IDH_WINDISK_ISBAD_SYSTEM_IGNORE                         7240
#define IDH_WINDISK_ISBAD_SYSTEM_RETRY                          7245
#define IDH_WINDISK_ISBAD_UNCOMP_DATA_REPAIR                    7250
#define IDH_WINDISK_ISBAD_UNCOMP_RETRY                          7255
#define IDH_WINDISK_ISNTBAD_RETRY                               7260
#define IDH_WINDISK_ISNTBAD_CLEAR                               7265
#define IDH_WINDISK_ISNTBAD_LEAVE                               7270
#define IDH_WINDISK_ISTR_FATERRCIRCC_DELETE                     7275
#define IDH_WINDISK_ISTR_FATERRCIRCC_IGNORE                     7280
#define IDH_WINDISK_ISTR_FATERRCIRCC_TRUNCATE                   7285
#define IDH_WINDISK_ISTR_FATERRDIR_DELETE                       7290
#define IDH_WINDISK_ISTR_FATERRDIR_IGNORE                       7295
#define IDH_WINDISK_ISTR_FATERRDIR_REPAIR                       7300
#define IDH_WINDISK_ISTR_FATERRINVCLUS_DELETE                   7305
#define IDH_WINDISK_ISTR_FATERRINVCLUS_IGNORE                   7310
#define IDH_WINDISK_ISTR_FATERRINVCLUS_TRUNCATE                 7315
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_NOTSET      7320
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_SET         7330
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_NOTSET      7340
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_SET         7350
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_NOTSET      7360
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_SET         7370
#define IDH_WINDISK_MEMORYERROR_IGNORE                          7380
#define IDH_WINDISK_MEMORYERROR_RETRY                           7385
#define IDH_WINDISK_READERROR_RETRY                             7390
#define IDH_WINDISK_READWRITEERROR_COMP_SYSTEM_IGNORE           7395
#define IDH_WINDISK_READWRITEERROR_COMP_THOROUGH                7400
#define IDH_WINDISK_READWRITEERROR_DATA_IGNORE                  7405
#define IDH_WINDISK_READWRITEERROR_UNCOMP_SYSTEM_IGNORE         7410
#define IDH_WINDISK_READWRITEERROR_UNCOMP_THOROUGH              7415
#define IDH_WINDISK_WRITEERROR_RETRY                            7420
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FILE              7425
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FOLDER            7430
#define IDH_SCANDISK                                            7431
#define IDH_SCANDISK_FINISH                                     7432
#define IDH_SCANDISK_FINISH_SURF_HOST                           7433
#define IDH_SCANDISK_FINISH_SURF                                7434
#define IDH_COMPRESS_CORRECT_SIZE                               7435
#define IDH_COMPRESS_CORRECT_RATIO                              7436
#define IDH_UTILITIES_DEFRAG_DISK_ERROR                         7437
#define IDH_CVF_TOO_SMALL_CHECK_HOST                            7438
#define IDH_THOROUGH_TEST_CHECK_HOST                            7439
#define IDH_DISK_LOGICAL                                        7440
#define IDH_DISK_PHYSICAL                                       7441
#define IDH_WINDISK_DDERRMDFAT_LOST_REPAIR                      7442
#define IDH_WINDISK_DDERRMDFAT_LOST_IGNORE                      7443
#define IDH_WINDISK_ISBAD_NO_FREE_CLUSTER                       7444
#define IDH_WINDISK_MAIN_LIST                                   7445
#define IDH_WINDISK_MAIN_STANDARD                               7446
#define IDH_WINDISK_MAIN_OPTIONS                                7447
#define IDH_WINDISK_MAIN_THOROUGH                               7448
#define IDH_WINDISK_MAIN_AUTOFIX                                7449
#define IDH_WINDISK_MAIN_ADVANCED                               7450
#define IDH_WINDISK_ADV_ALWAYS                                  7451
#define IDH_WINDISK_ADV_NEVER                                   7452
#define IDH_WINDISK_ADV_ONLY_IF_FOUND                           7453
#define IDH_WINDISK_ADV_DELETE                                  7454
#define IDH_WINDISK_ADV_MAKE_COPIES                             7455
#define IDH_WINDISK_ADV_IGNORE                                  7456
#define IDH_WINDISK_ADV_FILENAME                                7457
#define IDH_WINDISK_ADV_DATE_TIME                               7458
#define IDH_WINDISK_ADV_CHECK_HOST                              7459
#define IDH_WINDISK_ADV_FREE                                    7460
#define IDH_WINDISK_ADV_CONVERT                                 7461
#define IDH_WINDISK_OPTIONS_SYS_AND_DATA                        7462
#define IDH_WINDISK_OPTIONS_SYS_ONLY                            7463
#define IDH_WINDISK_OPTIONS_DATA_ONLY                           7464
#define IDH_WINDISK_OPTIONS_NO_WRITE_TEST                       7465
#define IDH_WINDISK_OPTIONS_NO_HID_SYS                          7466
#define IDH_FORMATDLG_CAPACITY                                  7467
#define IDH_FORMATDLG_QUICK                                     7468
#define IDH_FORMATDLG_FULL                                      7469
#define IDH_FORMATDLG_DOSYS                                     7470
#define IDH_FORMATDLG_LABEL                                     7471
#define IDH_FORMATDLG_NOLAB                                     7472
#define IDH_FORMATDLG_REPORT                                    7473
#define IDH_FORMATDLG_MKSYS                                     7474
#define IDH_WINDISK_MAIN_START                                  7475
#define IDH_WINDISK_MAIN_CLOSE                                  7476
#define IDH_WINDISK_OK_FOR_ERRORS                               7477
#define IDH_WINDISK_CANCEL_FOR_ERRORS                           7478
#define IDH_WINDISK_MORE_INFO                                   7479
#define IDH_FORMATDLG_START                                     7480
#define IDH_WINDISK_REPLACE_LOG                                 7481
#define IDH_WINDISK_APPEND_LOG                                  7482
#define IDH_WINDISK_NO_LOG                                      7483
#define IDH_FORMATDLG_FILESYS                                   7484
#define IDH_FORMATDLG_ALLOCSIZE                                 7485
#define IDH_FORMATDLG_QUICKFULL                                 7486
#define IDH_FORMATDLG_COMPRESS                                  7487

#define IDH_CHKDSKDLG_START                                     7488
#define IDH_CHKDSKDLG_FIXERRORS                                 7489
#define IDH_CHKDSKDLG_SCAN                                      7490
#define IDH_CHKDSKDLG_CANCEL                                    7491
#define IDH_CHKDSKDLG_PROGRESS                                  7492
#define IDH_FORMATDLG_PROGRESS                                  7493

// IDs for Port Settings

#define IDH_PORT_BAUD                                           7900
#define IDH_PORT_DATA                                           7901
#define IDH_PORT_PARITY                                         7902
#define IDH_PORT_STOPBITS                                       7903
#define IDH_PORT_FLOW                                           7904
#define IDH_PORT_RESTORE                                        7905

// IDs for Modem Diagnostics

#define IDH_MODEM_DIAG_INSTALLED                                7950
#define IDH_MODEM_DIAG_HELP                                     7951
#define IDH_MODEM_DIAG_MOREINFO                                 7952
#define IDH_MODEM_DIAG_DRIVER                                   7953

// IDs for Wastebasket/Recycle

#define IDH_WASTE_FREEING_DISK_SPACE                            8000
#define IDH_RECYCLE_CONFIG_INDEP                                8001
#define IDH_RECYCLE_CONFIG_ALL                                  8002
#define IDH_RECYCLE_PURGE_ON_DEL                                8003
#define IDH_RECYCLE_MAX_SIZE                                    8004
#define IDH_RECYCLE_DRIVE_SIZE                                  8005
#define IDH_RECYCLE_BIN_SIZE                                    8006
#define IDH_DELETE_CONFIRM_DLG                                  8007

#define IDH_FPROP_GEN_CHANGE                                    475102
#define IDH_CONFIRM_OPEN                                        51065
#define IDH_SAME_WINDOW                                         51066

// ID values 8100-8199 are reserved for Font dialog.

#define IDH_TRAY_START_MENU_SETTINGS	                        51132
#define IDH_TRAY_DISPLAY_LOGOFF	                                51133
#define IDH_TRAY_DISPLAY_FAVORITES	                        51134
#define IDH_TRAY_EXPAND_CPANEL	                                51135
#define IDH_TRAY_EXPAND_MYDOCS	                                51136
#define IDH_TRAY_EXPAND_PRINTERS	                        51137
#define IDH_TRAY_SCROLL_PROGRAMS	                        51138
#define IDH_TRAY_PERSONALIZED_MENUS	                        51139
#define IDH_TRAY_DISPLAY_ADMIN_TOOLS	                        51140
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\adodef.h ===
//--------------------------------------------------------------------
// Microsoft ADO
//
// (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module	adodef.h | ADO Version definitions
//
// @devnote None
//--------------------------------------------------------------------

#ifndef _ADODEF_H_
#define _ADODEF_H_

// TYPELIB MAJOR VERSIONS
#define ADO_MAJOR			2
#define ADOR_MAJOR			2
#define ADOX_MAJOR			2
#define ADOMD_MAJOR			2
#define JRO_MAJOR			2

// TYPELIB MINOR VERSION
#define ADO_MINOR			5
#define ADOR_MINOR			5
#define ADOX_MINOR			5
#define ADOMD_MINOR			5
#define JRO_MINOR			5

#define ADO_VERSION			2.5		
#define ADOR_VERSION		2.5
#define ADOX_VERSION		2.5
#define ADOMD_VERSION		2.5
#define JRO_VERSION			2.5

#define ADO_HELPFILE		"ado210.chm"
#define ADOX_HELPFILE		"ado210.chm"
#define ADOMD_HELPFILE		"ado210.chm"
#define JRO_HELPFILE		"ado210.chm"

#define ADO_LIBRARYNAME		"Microsoft ActiveX Data Objects 2.5 Library"
#define ADOR_LIBRARYNAME	"Microsoft ActiveX Data Objects Recordset 2.5 Library"
#define ADOX_LIBRARYNAME	"Microsoft ADO Ext. 2.5 for DDL and Security"
#define ADOMD_LIBRARYNAME	"Microsoft ActiveX Data Objects (Multi-dimensional) 2.5 Library"
#define JRO_LIBRARYNAME		"Microsoft Jet and Replication Objects 2.5 Library"

#define ADOMD_TYPELIB_UUID	uuid(22813728-8BD3-11D0-B4EF-00A0C9138CA4)
#define JRO_TYPELIB_UUID	uuid(AC3B8B4C-B6CA-11d1-9F31-00C04FC29D52)

#endif // _ADODEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\htiframe.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Jan 24 20:14:48 2001
 */
/* Compiler settings for htiframe.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __htiframe_h__
#define __htiframe_h__

/* Forward Declarations */ 

#ifndef __ITargetNotify_FWD_DEFINED__
#define __ITargetNotify_FWD_DEFINED__
typedef interface ITargetNotify ITargetNotify;
#endif 	/* __ITargetNotify_FWD_DEFINED__ */


#ifndef __ITargetFrame2_FWD_DEFINED__
#define __ITargetFrame2_FWD_DEFINED__
typedef interface ITargetFrame2 ITargetFrame2;
#endif 	/* __ITargetFrame2_FWD_DEFINED__ */


#ifndef __ITargetContainer_FWD_DEFINED__
#define __ITargetContainer_FWD_DEFINED__
typedef interface ITargetContainer ITargetContainer;
#endif 	/* __ITargetContainer_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_htiframe_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// HTIframe.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Hyperlinking ITargetFrame2 Interfaces.



EXTERN_C const IID IID_ITargetFrame2;
EXTERN_C const IID IID_ITargetContainer;
#ifndef _LPTARGETFRAME2_DEFINED
#define _LPTARGETFRAME2_DEFINED
#define TF_NAVIGATE 0x7FAEABAC
#define TARGET_NOTIFY_OBJECT_NAME L"863a99a0-21bc-11d0-82b4-00a0c90c29c5"


extern RPC_IF_HANDLE __MIDL_itf_htiframe_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiframe_0000_v0_0_s_ifspec;

#ifndef __ITargetNotify_INTERFACE_DEFINED__
#define __ITargetNotify_INTERFACE_DEFINED__

/* interface ITargetNotify */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITargetNotify __RPC_FAR *LPTARGETNOTIFY;


EXTERN_C const IID IID_ITargetNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("863a99a0-21bc-11d0-82b4-00a0c90c29c5")
    ITargetNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCreate( 
            /* [in] */ IUnknown __RPC_FAR *pUnkDestination,
            /* [in] */ ULONG cbCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnReuse( 
            /* [in] */ IUnknown __RPC_FAR *pUnkDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITargetNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITargetNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITargetNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCreate )( 
            ITargetNotify __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkDestination,
            /* [in] */ ULONG cbCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnReuse )( 
            ITargetNotify __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkDestination);
        
        END_INTERFACE
    } ITargetNotifyVtbl;

    interface ITargetNotify
    {
        CONST_VTBL struct ITargetNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITargetNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITargetNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITargetNotify_OnCreate(This,pUnkDestination,cbCookie)	\
    (This)->lpVtbl -> OnCreate(This,pUnkDestination,cbCookie)

#define ITargetNotify_OnReuse(This,pUnkDestination)	\
    (This)->lpVtbl -> OnReuse(This,pUnkDestination)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITargetNotify_OnCreate_Proxy( 
    ITargetNotify __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkDestination,
    /* [in] */ ULONG cbCookie);


void __RPC_STUB ITargetNotify_OnCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetNotify_OnReuse_Proxy( 
    ITargetNotify __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkDestination);


void __RPC_STUB ITargetNotify_OnReuse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITargetNotify_INTERFACE_DEFINED__ */


#ifndef __ITargetFrame2_INTERFACE_DEFINED__
#define __ITargetFrame2_INTERFACE_DEFINED__

/* interface ITargetFrame2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITargetFrame2 __RPC_FAR *LPTARGETFRAME2;

typedef /* [public] */ 
enum __MIDL_ITargetFrame2_0001
    {	FINDFRAME_NONE	= 0,
	FINDFRAME_JUSTTESTEXISTENCE	= 1,
	FINDFRAME_INTERNAL	= 0x80000000
    }	FINDFRAME_FLAGS;

typedef /* [public] */ 
enum __MIDL_ITargetFrame2_0002
    {	FRAMEOPTIONS_SCROLL_YES	= 0x1,
	FRAMEOPTIONS_SCROLL_NO	= 0x2,
	FRAMEOPTIONS_SCROLL_AUTO	= 0x4,
	FRAMEOPTIONS_NORESIZE	= 0x8,
	FRAMEOPTIONS_NO3DBORDER	= 0x10,
	FRAMEOPTIONS_DESKTOP	= 0x20,
	FRAMEOPTIONS_BROWSERBAND	= 0x40
    }	FRAMEOPTIONS_FLAGS;


EXTERN_C const IID IID_ITargetFrame2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86D52E11-94A8-11d0-82AF-00C04FD5AE38")
    ITargetFrame2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFrameName( 
            /* [in] */ LPCWSTR pszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameName( 
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentFrame( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameSrc( 
            /* [in] */ LPCWSTR pszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameSrc( 
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFramesContainer( 
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameOptions( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameMargins( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameMargins( 
            /* [out] */ DWORD __RPC_FAR *pdwWidth,
            /* [out] */ DWORD __RPC_FAR *pdwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFrame( 
            /* [unique][in] */ LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetAlias( 
            /* [unique][in] */ LPCWSTR pszTargetName,
            /* [out] */ LPWSTR __RPC_FAR *ppszTargetAlias) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFrame2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITargetFrame2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITargetFrame2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameName )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameName )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentFrame )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameSrc )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameSrc )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFramesContainer )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameOptions )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameOptions )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameMargins )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameMargins )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwWidth,
            /* [out] */ DWORD __RPC_FAR *pdwHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFrame )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [unique][in] */ LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetAlias )( 
            ITargetFrame2 __RPC_FAR * This,
            /* [unique][in] */ LPCWSTR pszTargetName,
            /* [out] */ LPWSTR __RPC_FAR *ppszTargetAlias);
        
        END_INTERFACE
    } ITargetFrame2Vtbl;

    interface ITargetFrame2
    {
        CONST_VTBL struct ITargetFrame2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFrame2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITargetFrame2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITargetFrame2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITargetFrame2_SetFrameName(This,pszFrameName)	\
    (This)->lpVtbl -> SetFrameName(This,pszFrameName)

#define ITargetFrame2_GetFrameName(This,ppszFrameName)	\
    (This)->lpVtbl -> GetFrameName(This,ppszFrameName)

#define ITargetFrame2_GetParentFrame(This,ppunkParent)	\
    (This)->lpVtbl -> GetParentFrame(This,ppunkParent)

#define ITargetFrame2_SetFrameSrc(This,pszFrameSrc)	\
    (This)->lpVtbl -> SetFrameSrc(This,pszFrameSrc)

#define ITargetFrame2_GetFrameSrc(This,ppszFrameSrc)	\
    (This)->lpVtbl -> GetFrameSrc(This,ppszFrameSrc)

#define ITargetFrame2_GetFramesContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetFramesContainer(This,ppContainer)

#define ITargetFrame2_SetFrameOptions(This,dwFlags)	\
    (This)->lpVtbl -> SetFrameOptions(This,dwFlags)

#define ITargetFrame2_GetFrameOptions(This,pdwFlags)	\
    (This)->lpVtbl -> GetFrameOptions(This,pdwFlags)

#define ITargetFrame2_SetFrameMargins(This,dwWidth,dwHeight)	\
    (This)->lpVtbl -> SetFrameMargins(This,dwWidth,dwHeight)

#define ITargetFrame2_GetFrameMargins(This,pdwWidth,pdwHeight)	\
    (This)->lpVtbl -> GetFrameMargins(This,pdwWidth,pdwHeight)

#define ITargetFrame2_FindFrame(This,pszTargetName,dwFlags,ppunkTargetFrame)	\
    (This)->lpVtbl -> FindFrame(This,pszTargetName,dwFlags,ppunkTargetFrame)

#define ITargetFrame2_GetTargetAlias(This,pszTargetName,ppszTargetAlias)	\
    (This)->lpVtbl -> GetTargetAlias(This,pszTargetName,ppszTargetAlias)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITargetFrame2_SetFrameName_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [in] */ LPCWSTR pszFrameName);


void __RPC_STUB ITargetFrame2_SetFrameName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetFrameName_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszFrameName);


void __RPC_STUB ITargetFrame2_GetFrameName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetParentFrame_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkParent);


void __RPC_STUB ITargetFrame2_GetParentFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_SetFrameSrc_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [in] */ LPCWSTR pszFrameSrc);


void __RPC_STUB ITargetFrame2_SetFrameSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetFrameSrc_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc);


void __RPC_STUB ITargetFrame2_GetFrameSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetFramesContainer_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);


void __RPC_STUB ITargetFrame2_GetFramesContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_SetFrameOptions_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITargetFrame2_SetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetFrameOptions_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB ITargetFrame2_GetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_SetFrameMargins_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [in] */ DWORD dwWidth,
    /* [in] */ DWORD dwHeight);


void __RPC_STUB ITargetFrame2_SetFrameMargins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetFrameMargins_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwWidth,
    /* [out] */ DWORD __RPC_FAR *pdwHeight);


void __RPC_STUB ITargetFrame2_GetFrameMargins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_FindFrame_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [unique][in] */ LPCWSTR pszTargetName,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);


void __RPC_STUB ITargetFrame2_FindFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame2_GetTargetAlias_Proxy( 
    ITargetFrame2 __RPC_FAR * This,
    /* [unique][in] */ LPCWSTR pszTargetName,
    /* [out] */ LPWSTR __RPC_FAR *ppszTargetAlias);


void __RPC_STUB ITargetFrame2_GetTargetAlias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITargetFrame2_INTERFACE_DEFINED__ */


#ifndef __ITargetContainer_INTERFACE_DEFINED__
#define __ITargetContainer_INTERFACE_DEFINED__

/* interface ITargetContainer */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITargetContainer __RPC_FAR *LPTARGETCONTAINER;


EXTERN_C const IID IID_ITargetContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7847EC01-2BEC-11d0-82B4-00A0C90C29C5")
    ITargetContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameUrl( 
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFramesContainer( 
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITargetContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITargetContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITargetContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameUrl )( 
            ITargetContainer __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFramesContainer )( 
            ITargetContainer __RPC_FAR * This,
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);
        
        END_INTERFACE
    } ITargetContainerVtbl;

    interface ITargetContainer
    {
        CONST_VTBL struct ITargetContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITargetContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITargetContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITargetContainer_GetFrameUrl(This,ppszFrameSrc)	\
    (This)->lpVtbl -> GetFrameUrl(This,ppszFrameSrc)

#define ITargetContainer_GetFramesContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetFramesContainer(This,ppContainer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITargetContainer_GetFrameUrl_Proxy( 
    ITargetContainer __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc);


void __RPC_STUB ITargetContainer_GetFrameUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetContainer_GetFramesContainer_Proxy( 
    ITargetContainer __RPC_FAR * This,
    /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);


void __RPC_STUB ITargetContainer_GetFramesContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITargetContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_htiframe_0110 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_htiframe_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiframe_0110_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\comctrlp.h ===
/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMCTRLP
#define _INC_COMCTRLP
#ifndef NOUSER

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NOBTNLIST    A control which is a list of bitmap buttons.
//
//=============================================================================

#if defined (WINNT) || defined (WINNT_ENV)
#include <prshtp.h>
#endif
// BUGBUG: we want to remove this to force new apps to use the Ex version
#if (_WIN32_IE >= 0x0501)
#define ICC_WINLOGON_REINIT  0x80000000
#endif

#define ICC_ALL_CLASSES      0x00007FFF //
#define ICC_ALL_VALID        0x80007FFF //
// BUGBUG: should be in windows.h?
#define CCM_TRANSLATEACCELERATOR (CCM_FIRST + 0xa)  // lParam == lpMsg
WINCOMMCTRLAPI LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr);
WINCOMMCTRLAPI LRESULT WINAPI SendNotifyEx(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr, BOOL bUnicode);
#define NM_STARTWAIT            (NM_FIRST-9)
#define NM_ENDWAIT              (NM_FIRST-10)
#define NM_BTNCLK               (NM_FIRST-11)
// Rundll reserved              (0U-500U) -  (0U-509U)

// Run file dialog reserved     (0U-510U) -  (0U-519U)

// Message Filter Proc codes - These are defined above MSGF_USER
/////                           0x00000001  // don't use because some apps return 1 for all notifies
#define CDRF_NOTIFYITEMERASE    0x00000080   //

#define CDRF_VALIDFLAGS         0xFFFF00F6   //

#define SSI_DEFAULT ((UINT)-1)


#define SSIF_SCROLLPROC    0x0001
#define SSIF_MAXSCROLLTIME 0x0002
#define SSIF_MINSCROLL     0x0004

typedef int (CALLBACK *PFNSMOOTHSCROLLPROC)(    HWND hWnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);


typedef struct tagSSWInfo{
    UINT cbSize;
    DWORD fMask;
    HWND hwnd;
    int dx;
    int dy;
    LPCRECT lprcSrc;
    LPCRECT lprcClip;
    HRGN hrgnUpdate;
    LPRECT lprcUpdate;
    UINT fuScroll;

    UINT uMaxScrollTime;
    UINT cxMinScroll;
    UINT cyMinScroll;

    PFNSMOOTHSCROLLPROC pfnScrollProc;  // we'll call this back instead
} SMOOTHSCROLLINFO, *PSMOOTHSCROLLINFO;

WINCOMMCTRLAPI INT  WINAPI SmoothScrollWindow(PSMOOTHSCROLLINFO pssi);

#define SSW_EX_NOTIMELIMIT      0x00010000
#define SSW_EX_IMMEDIATE        0x00020000
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll



// ================ READER MODE ================
struct tagReaderModeInfo;
typedef BOOL (CALLBACK *PFNREADERSCROLL)(struct tagReaderModeInfo*, int, int);
typedef BOOL (CALLBACK *PFNREADERTRANSLATEDISPATCH)(LPMSG);
typedef struct tagReaderModeInfo
{
    UINT cbSize;
    HWND hwnd;
    DWORD fFlags;
    LPRECT prc;
    PFNREADERSCROLL pfnScroll;
    PFNREADERTRANSLATEDISPATCH pfnTranslateDispatch;

    LPARAM lParam;
} READERMODEINFO, *PREADERMODEINFO;

#define RMF_ZEROCURSOR          0x00000001
#define RMF_VERTICALONLY        0x00000002
#define RMF_HORIZONTALONLY      0x00000004

#define RM_SCROLLUNIT 20

WINCOMMCTRLAPI void WINAPI DoReaderMode(PREADERMODEINFO prmi);

// Cursors and Bitmaps used by ReaderMode
#ifdef RC_INVOKED
#define IDC_HAND_INTERNAL       108
#define IDC_VERTICALONLY        109
#define IDC_HORIZONTALONLY      110
#define IDC_MOVE2D              111
#define IDC_NORTH               112
#define IDC_SOUTH               113
#define IDC_EAST                114
#define IDC_WEST                115
#define IDC_NORTHEAST           116
#define IDC_NORTHWEST           117
#define IDC_SOUTHEAST           118
#define IDC_SOUTHWEST           119

#define IDB_2DSCROLL    132
#define IDB_VSCROLL     133
#define IDB_HSCROLL     134
#else
#define IDC_HAND_INTERNAL       MAKEINTRESOURCE(108)
#define IDC_VERTICALONLY        MAKEINTRESOURCE(109)
#define IDC_HORIZONTALONLY      MAKEINTRESOURCE(110)
#define IDC_MOVE2D              MAKEINTRESOURCE(111)
#define IDC_NORTH               MAKEINTRESOURCE(112)
#define IDC_SOUTH               MAKEINTRESOURCE(113)
#define IDC_EAST                MAKEINTRESOURCE(114)
#define IDC_WEST                MAKEINTRESOURCE(115)
#define IDC_NORTHEAST           MAKEINTRESOURCE(116)
#define IDC_NORTHWEST           MAKEINTRESOURCE(117)
#define IDC_SOUTHEAST           MAKEINTRESOURCE(118)
#define IDC_SOUTHWEST           MAKEINTRESOURCE(119)

#define IDB_2DSCROLL    MAKEINTRESOURCE(132)
#define IDB_VSCROLL     MAKEINTRESOURCE(133)
#define IDB_HSCROLL     MAKEINTRESOURCE(134)
#endif
#define NUM_OVERLAY_IMAGES_0     4
#define NUM_OVERLAY_IMAGES      15
#define ILC_COLORMASK           0x00FE
#define ILC_SHARED              0x0100      // this is a shareable image list
#define ILC_LARGESMALL          0x0200      // (not implenented) contains both large and small images
#define ILC_UNIQUE              0x0400      // (not implenented) makes sure no dup. image exists in list
#define ILC_MOREOVERLAY         0x1000      // contains more overlay in the structure
#define ILC_MIRROR              0x2000      // Mirror the icons contained, if the process is mirrored
#define ILC_VIRTUAL             0x8000      // enables ImageList_SetFilter

#define ILC_VALID   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE | ILC_MIRROR | ILC_VIRTUAL)   // legal implemented flags
#define ILD_BLENDMASK           0x000E
#define ILD_BLEND75             0x0008   // not implemented
#define ILD_MIRROR              0x0080
#define OVERLAYMASKTOINDEX(i)   ((((i) >> 8) & (ILD_OVERLAYMASK >> 8))-1)
#define OVERLAYMASKTO1BASEDINDEX(i)   (((i) >> 8) & (ILD_OVERLAYMASK >> 8))
// BUGBUG remove these!
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int FAR *cx, int FAR *cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT FAR* prcImage);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i);
#define ILCF_VALID  (ILCF_SWAP)
#if (_WIN32_IE >= 0x0500)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetFlags(HIMAGELIST himl, UINT flags);
#endif

typedef BOOL (CALLBACK *PFNIMLFILTER)(HIMAGELIST *, int *, LPARAM, BOOL);
WINCOMMCTRLAPI BOOL WINAPI ImageList_SetFilter(HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter);
WINCOMMCTRLAPI int ImageList_SetColorTable(HIMAGELIST piml, int start, int len, RGBQUAD *prgb);

WINCOMMCTRLAPI BOOL WINAPI MirrorIcon(HICON* phiconSmall, HICON* phiconLarge);
WINCOMMCTRLAPI UINT WINAPI ImageList_GetFlags(HIMAGELIST himl);
#define HDS_VERT                0x0001  // BUGBUG: not implemente
#define HDS_SHAREDIMAGELISTS    0x0000
#define HDS_PRIVATEIMAGELISTS   0x0010

#define HDS_OWNERDATA           0x0020
#define HDFT_ISMASK         0x000f
#define HDI_ALL                 0x01ff
/* REVIEW: index, command, flag words, resource ids should be UINT */
/* REVIEW: is this internal? if not, call it TBCOLORMAP, prefix tbc */
#define CMB_DISCARDABLE         0x01    /* BUGBUG: remove this */
#define CMB_DIBSECTION          0x04

/*REVIEW: TBSTATE_* should be TBF_* (for Flags) */
#if (_WIN32_IE >= 0x0501)
#else
#define BTNS_SHOWTEXT   0x0040
#endif  // 0x0501
#if (_WIN32_IE >= 0x0501)
#elif (_WIN32_IE >= 0x0500)
#define TBSTYLE_EX_MIXEDBUTTONS     0x00000008
#define TBSTYLE_EX_HIDECLIPPEDBUTTONS   0x00000010
#endif  // 0x0501
#if (_WIN32_IE >= 0x0500)
#define TBSTYLE_EX_MULTICOLUMN      0x00000002 // conflicts w/ TBSTYLE_WRAPABLE
#define TBSTYLE_EX_VERTICAL         0x00000004
#define TBSTYLE_EX_INVERTIBLEIMAGELIST  0x00000020  // Image list may contain inverted 
#endif
/* Messages up to WM_USER+8 are reserved until we define more state bits */
/* Messages up to WM_USER+16 are reserved until we define more state bits */
#define IDB_STD_SMALL_MONO      2       /*  not supported yet */
#define IDB_STD_LARGE_MONO      3       /*  not supported yet */
#define IDB_VIEW_SMALL_MONO     6       /*  not supported yet */
#define IDB_VIEW_LARGE_MONO     7       /*  not supported yet */
#define STD_LAST                (STD_PRINT)     //
#define STD_MAX                 (STD_LAST + 1)  //
#define VIEW_LAST               (VIEW_VIEWMENU) //
#define VIEW_MAX                (VIEW_LAST + 1) //
#define HIST_LAST               (HIST_VIEWTREE) //
#define HIST_MAX                (HIST_LAST + 1) //
#define TB_SETBUTTONTYPE        (WM_USER + 34)
#ifdef _WIN32
#define TB_ADDBITMAP32          (WM_USER + 38)
#endif
#define TBBF_MONO               0x0002  /* not supported yet */
// since we don't have these for all the toolbar api's, we shouldn't expose any

#define ToolBar_ButtonCount(hwnd)  \
    (BOOL)SNDMSG((hwnd), TB_BUTTONCOUNT, 0, 0)

#define ToolBar_EnableButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_ENABLEBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_CheckButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_CHECKBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_PressButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_PRESSBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_HideButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_HIDEBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_MarkButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_MARKBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_CommandToIndex(hwnd, idBtn)  \
    (BOOL)SNDMSG((hwnd), TB_COMMANDTOINDEX, (WPARAM)(idBtn), 0)

#define ToolBar_SetState(hwnd, idBtn, dwState)  \
    (BOOL)SNDMSG((hwnd), TB_SETSTATE, (WPARAM)(idBtn), (LPARAM)(dwState))

#define ToolBar_GetState(hwnd, idBtn)  \
    (DWORD)SNDMSG((hwnd), TB_GETSTATE, (WPARAM)(idBtn), 0L)

#define ToolBar_GetRect(hwnd, idBtn, prect)  \
    (DWORD)SNDMSG((hwnd), TB_GETRECT, (WPARAM)(idBtn), (LPARAM)(prect))

#define ToolBar_SetButtonInfo(hwnd, idBtn, lptbbi)  \
    (BOOL)SNDMSG((hwnd), TB_SETBUTTONINFO, (WPARAM)(idBtn), (LPARAM)(lptbbi))

// returns -1 on failure, button index on success
#define ToolBar_GetButtonInfo(hwnd, idBtn, lptbbi)  \
    (int)(SNDMSG((hwnd), TB_GETBUTTONINFO, (WPARAM)(idBtn), (LPARAM)(lptbbi)))

#define ToolBar_GetButton(hwnd, iIndex, ptbb)  \
    (BOOL)SNDMSG((hwnd), TB_GETBUTTON, (WPARAM)(iIndex), (LPARAM)(ptbb))

#define ToolBar_SetStyle(hwnd, dwStyle)  \
    SNDMSG((hwnd), TB_SETSTYLE, 0, (LPARAM)(dwStyle))

#define ToolBar_GetStyle(hwnd)  \
    (DWORD)SNDMSG((hwnd), TB_GETSTYLE, 0, 0L)

#define ToolBar_GetHotItem(hwnd)  \
    (int)SNDMSG((hwnd), TB_GETHOTITEM, 0, 0L)

#define ToolBar_SetHotItem(hwnd, iPosHot)  \
    (int)SNDMSG((hwnd), TB_SETHOTITEM, (WPARAM)(iPosHot), 0L)

#define ToolBar_GetAnchorHighlight(hwnd)  \
    (BOOL)SNDMSG((hwnd), TB_GETANCHORHIGHLIGHT, 0, 0L)

#define ToolBar_SetAnchorHighlight(hwnd, bSet)  \
    SNDMSG((hwnd), TB_SETANCHORHIGHLIGHT, (WPARAM)(bSet), 0L)

#define ToolBar_MapAccelerator(hwnd, ch, pidBtn)  \
    (BOOL)SNDMSG((hwnd), TB_MAPACCELERATOR, (WPARAM)(ch), (LPARAM)(pidBtn))

#define ToolBar_GetInsertMark(hwnd, ptbim) \
    (void)SNDMSG((hwnd), TB_GETINSERTMARK, 0, (LPARAM)(ptbim))
#define ToolBar_SetInsertMark(hwnd, ptbim) \
    (void)SNDMSG((hwnd), TB_SETINSERTMARK, 0, (LPARAM)(ptbim))

#if (_WIN32_IE >= 0x0400)
#define ToolBar_GetInsertMarkColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), TB_GETINSERTMARKCOLOR, 0, 0)
#define ToolBar_SetInsertMarkColor(hwnd, clr) \
    (COLORREF)SNDMSG((hwnd), TB_SETINSERTMARKCOLOR, 0, (LPARAM)(clr))

#define ToolBar_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), TB_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define ToolBar_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), TB_GETUNICODEFORMAT, 0, 0)

#endif

// ToolBar_InsertMarkHitTest always fills in *ptbim with best hit information
//   returns TRUE if point is within the insert region (edge of buttons)
//   returns FALSE if point is outside the insert region (middle of button or background)
#define ToolBar_InsertMarkHitTest(hwnd, ppt, ptbim) \
    (BOOL)SNDMSG((hwnd), TB_INSERTMARKHITTEST, (WPARAM)(ppt), (LPARAM)(ptbim))

// ToolBar_MoveButton moves the button from position iOld to position iNew,
//   returns TRUE iff a button actually moved.
#define ToolBar_MoveButton(hwnd, iOld, iNew) \
    (BOOL)SNDMSG((hwnd), TB_MOVEBUTTON, (WPARAM)(iOld), (LPARAM)(iNew))

#define ToolBar_SetState(hwnd, idBtn, dwState)  \
    (BOOL)SNDMSG((hwnd), TB_SETSTATE, (WPARAM)(idBtn), (LPARAM)(dwState))

#define ToolBar_HitTest(hwnd, lppoint)  \
    (int)SNDMSG((hwnd), TB_HITTEST, 0, (LPARAM)(lppoint))

#define ToolBar_GetMaxSize(hwnd, lpsize) \
    (BOOL)SNDMSG((hwnd), TB_GETMAXSIZE, 0, (LPARAM) (lpsize))

#define ToolBar_GetPadding(hwnd) \
    (LONG)SNDMSG((hwnd), TB_GETPADDING, 0, 0)

#define ToolBar_SetPadding(hwnd, x, y) \
    (LONG)SNDMSG((hwnd), TB_SETPADDING, 0, MAKELONG(x, y))

#if (_WIN32_IE >= 0x0500)
#define ToolBar_SetExtendedStyle(hwnd, dw, dwMask)\
        (DWORD)SNDMSG((hwnd), TB_SETEXTENDEDSTYLE, dwMask, dw)

#define ToolBar_GetExtendedStyle(hwnd)\
        (DWORD)SNDMSG((hwnd), TB_GETEXTENDEDSTYLE, 0, 0)

#define ToolBar_SetBoundingSize(hwnd, lpSize)\
        (DWORD)SNDMSG((hwnd), TB_SETBOUNDINGSIZE, 0, (LPARAM)(lpSize))

#define ToolBar_SetHotItem2(hwnd, iPosHot, dwFlags)  \
    (int)SNDMSG((hwnd), TB_SETHOTITEM2, (WPARAM)(iPosHot), (LPARAM)(dwFlags))

#define ToolBar_HasAccelerator(hwnd, ch, piNum)  \
    (BOOL)SNDMSG((hwnd), TB_HASACCELERATOR, (WPARAM)(ch), (LPARAM)(piNum))

#define ToolBar_SetListGap(hwnd, iGap) \
    (BOOL)SNDMSG((hwnd), TB_SETLISTGAP, (WPARAM)(iGap), 0)
#define ToolBar_SetButtonHeight(hwnd, iMinHeight, iMaxHeight) \
    (BOOL)SNDMSG((hwnd), TB_SETBUTTONHEIGHT, 0, (LPARAM)(MAKELONG((iMinHeight),(iMaxHeight))))
#define ToolBar_SetButtonWidth(hwnd, iMinWidth, iMaxWidth) \
    (BOOL)SNDMSG((hwnd), TB_SETBUTTONWIDTH, 0, (LPARAM)(MAKELONG((iMinWidth),(iMaxWidth))))


#endif
#define TB_SETBOUNDINGSIZE      (WM_USER + 93)
#define TB_SETHOTITEM2          (WM_USER + 94)  // wParam == iHotItem,  lParam = dwFlags
#define TB_HASACCELERATOR       (WM_USER + 95)  // wParem == char, lParam = &iCount
#define TB_SETLISTGAP           (WM_USER + 96)
// empty space -- use me
#define TB_GETIMAGELISTCOUNT    (WM_USER + 98)
#define TB_GETIDEALSIZE         (WM_USER + 99)  // wParam == fHeight, lParam = psize
#define TB_SETDROPDOWNGAP       (WM_USER + 100)
// before using WM_USER + 101, recycle old space above (WM_USER + 97)
#define TB_TRANSLATEACCELERATOR     CCM_TRANSLATEACCELERATOR
#if (_WIN32_IE >= 0x0300)
#define TBN_CLOSEUP             (TBN_FIRST - 11)  //
#endif
#define TBN_WRAPHOTITEM         (TBN_FIRST - 24)
#define TBN_DUPACCELERATOR      (TBN_FIRST - 25)
#define TBN_WRAPACCELERATOR     (TBN_FIRST - 26)
#define TBN_DRAGOVER            (TBN_FIRST - 27)
#define TBN_MAPACCELERATOR      (TBN_FIRST - 28)
typedef struct tagNMTBDUPACCELERATOR
{
    NMHDR hdr;
    UINT ch;
    BOOL fDup;
} NMTBDUPACCELERATOR, *LPNMTBDUPACCELERATOR;

typedef struct tagNMTBWRAPACCELERATOR
{
    NMHDR hdr;
    UINT ch;
    int iButton;
} NMTBWRAPACCELERATOR, *LPNMTBWRAPACCELERATOR;

typedef struct tagNMTBWRAPHOTITEM
{
    NMHDR hdr;
    int iStart;
    int iDir;
    UINT nReason;       // HICF_* flags
} NMTBWRAPHOTITEM, *LPNMTBWRAPHOTITEM;
#ifndef _WIN32
// for compatibility with the old 16 bit WM_COMMAND hacks
typedef struct _ADJUSTINFO {
    TBBUTTON tbButton;
    char szDescription[1];
} ADJUSTINFO, NEAR* PADJUSTINFO, FAR* LPADJUSTINFO;
#define TBN_BEGINDRAG           0x0201
#define TBN_ENDDRAG             0x0203
#define TBN_BEGINADJUST         0x0204
#define TBN_ADJUSTINFO          0x0205
#define TBN_ENDADJUST           0x0206
#define TBN_RESET               0x0207
#define TBN_QUERYINSERT         0x0208
#define TBN_QUERYDELETE         0x0209
#define TBN_TOOLBARCHANGE       0x020a
#define TBN_CUSTHELP            0x020b
#endif

#if (_WIN32_IE >= 0x0500)
typedef struct tagNMTBCUSTOMIZEDLG {
    NMHDR   hdr;
    HWND    hDlg;
} NMTBCUSTOMIZEDLG, FAR* LPNMTBCUSTOMIZEDLG;
#endif


#define RBS_VALID       (RBS_AUTOSIZE | RBS_TOOLTIPS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_REGISTERDROP)
#if (_WIN32_IE >= 0x0400)               //
#if (_WIN32_IE >= 0x0500)               //
#if (_WIN32_IE >= 0x0501)               //
#endif // 0x0501                        //
#endif // 0x0500                        //
#define RBBS_FIXEDHEADERSIZE 0x40000000 //
#endif // 0x0400                        //
#define RBBS_DRAGBREAK      0x80000000  //
#define RB_GETBANDINFOOLD (WM_USER +  5)  //
#define RB_GETOBJECT    (WM_USER +  15) //
#define RB_PRIV_RESIZE   (WM_USER + 33)   //
#define RB_PRIV_DODELAYEDSTUFF (WM_USER+36)  // Private to delay doing toolbar stuff
// unused, reclaim      (WM_USER + 40)
// unused, reclaim      (WM_USER + 41)
// unused, reclaim      (WM_USER + 42)
// unused, reclaim          (RBN_FIRST - 9)
#define RBN_BANDHEIGHTCHANGE (RBN_FIRST - 20) // send when the rebar auto changes the height of a variableheight band
#if (_WIN32_IE >= 0x0400)                               //
//The following Style bit was 0x04. Now its set to zero
#define TTS_TOPMOST             0x00                    //
#endif                                                  //
// 0x04 used to be TTS_TOPMOST
// ie4 gold shell32 defview sets the flag (using SetWindowBits)
// so upgrade to ie5 will cause the new style to be used
// on tooltips in defview (not something we want)
#define TTF_STRIPACCELS         0x0008       // (this is implicit now)
#define TTF_UNICODE             0x0040       // Unicode Notify's
#define TTF_MEMALLOCED          0x0200
#if (_WIN32_IE >= 0x0400)
#define TTF_USEHITTEST          0x0400
#define TTF_RIGHT               0x0800       // right-aligned tooltips text (multi-line tooltips)
#endif
#if (_WIN32_IE >= 0x0500)
typedef struct tagNMTTSHOWINFO {
    NMHDR hdr;
    DWORD dwStyle;
} NMTTSHOWINFO, FAR *LPNMTTSHOWINFO;
#endif
// SBS_* styles need to not overlap with CCS_* values

#define SB_SETBORDERS           (WM_USER+5)
// Warning +11-+13 are used in the unicode stuff above!
/*REVIEW: is this internal? */
/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOBTNLIST

/*REVIEW: should be BUTTONLIST_CLASS */
#define BUTTONLISTBOX           "ButtonListBox"

/* Button List Box Styles */
#define BLS_NUMBUTTONS          0x00FF
#define BLS_VERTICAL            0x0100
#define BLS_NOSCROLL            0x0200

/* Button List Box Messages */
#define BL_ADDBUTTON            (WM_USER+1)
#define BL_DELETEBUTTON         (WM_USER+2)
#define BL_GETCARETINDEX        (WM_USER+3)
#define BL_GETCOUNT             (WM_USER+4)
#define BL_GETCURSEL            (WM_USER+5)
#define BL_GETITEMDATA          (WM_USER+6)
#define BL_GETITEMRECT          (WM_USER+7)
#define BL_GETTEXT              (WM_USER+8)
#define BL_GETTEXTLEN           (WM_USER+9)
#define BL_GETTOPINDEX          (WM_USER+10)
#define BL_INSERTBUTTON         (WM_USER+11)
#define BL_RESETCONTENT         (WM_USER+12)
#define BL_SETCARETINDEX        (WM_USER+13)
#define BL_SETCURSEL            (WM_USER+14)
#define BL_SETITEMDATA          (WM_USER+15)
#define BL_SETTOPINDEX          (WM_USER+16)
#define BL_MSGMAX               (WM_USER+17)

/* Button listbox notification codes send in WM_COMMAND */
#define BLN_ERRSPACE            (-2)
#define BLN_SELCHANGE           1
#define BLN_CLICKED             2
#define BLN_SELCANCEL           3
#define BLN_SETFOCUS            4
#define BLN_KILLFOCUS           5

/* Message return values */
#define BL_OKAY                 0
#define BL_ERR                  (-1)
#define BL_ERRSPACE             (-2)

/* Create structure for                    */
/* BL_ADDBUTTON and                        */
/* BL_INSERTBUTTON                         */
/*   lpCLB = (LPCREATELISTBUTTON)lParam    */
typedef struct tagCREATELISTBUTTON {
    UINT        cbSize;     /* size of structure */
    DWORD_PTR    dwItemData; /* user defined item data */
                            /* for LB_GETITEMDATA and LB_SETITEMDATA */
    HBITMAP     hBitmap;    /* button bitmap */
    LPCSTR      lpszText;   /* button text */

} CREATELISTBUTTON, FAR* LPCREATELISTBUTTON;

#endif /* NOBTNLIST */
//=============================================================================
#if (_WIN32_IE >= 0x0501)
#define TBS_DOWNISLEFT          0x0400  // Down=Left and Up=Right (default is Down=Right and Up=Left)
#endif
/*REVIEW: these match the SB_ (scroll bar messages); define them that way? */

//
// Unnecessary to create a A and W version
// of this string since it is only passed
// to RegisterWindowMessage.
//
// BUGBUG -- there's a message to do this now -- just macro-ize this one
#if (_WIN32_IE >= 0x0501)
#define UDS_UNSIGNED            0x0200
#endif
#define PBS_SHOWPERCENT         0x01
#define PBS_SHOWPOS             0x02


#define CCS_NOHILITE            0x00000010L
#define LVS_PRIVATEIMAGELISTS   0x0000
#define LVS_ALIGNBOTTOM         0x0400
#define LVS_ALIGNRIGHT          0x0c00
#define LVIF_ALL                0x001f
#define LVIF_VALID              0x081f
#define LVIF_RESERVED           0xf000  // all bits in high nibble is for notify specific stuff
#define LVIS_DISABLED           0x0010   // GOING AWAY
#define LVIS_LINK               0x0040
#define LVIS_USERMASK           LVIS_STATEIMAGEMASK  // BUGBUG: remove me.
#define LVIS_ALL                0xFFFF
#define STATEIMAGEMASKTOINDEX(i) ((i & LVIS_STATEIMAGEMASK) >> 12)
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define I_IMAGENONE             (-2)
#define LVNI_PREVIOUS           0x0020
#define LVFI_SUBSTRING          0x0004
#define LVFI_NOCASE             0x0010
// the following #define's must be packed sequentially.
#define LVIR_MAX                4
#define LVA_ALIGNRIGHT          0x0003
#define LVA_ALIGNBOTTOM         0x0004
#define LVA_ALIGNMASK           0x0007

#define LVA_SORTASCENDING       0x0100
#define LVA_SORTDESCENDING      0x0200
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define LVCF_ALL                0x003f
#define LVCFMT_LEFT_TO_RIGHT    0x0010
#define LVCFMT_RIGHT_TO_LEFT    0x0020
#define LVCFMT_DIRECTION_MASK   (LVCFMT_LEFT_TO_RIGHT | LVCFMT_RIGHT_TO_LEFT)
#if (_WIN32_IE >= 0x0500)
#define LVS_EX_BORDERSELECT     0x00008000  // border selection style instead of highlight
#endif  // End (_WIN32_IE >= 0x0500)
#define LVM_GETHOTLIGHTCOLOR    (LVM_FIRST + 79)
#define ListView_GetHotlightColor(hwndLV)\
        (COLORREF)SNDMSG((hwndLV), LVM_GETHOTLIGHTCOLOR, 0, 0)

#define LVM_SETHOTLIGHTCOLOR    (LVM_FIRST + 80)
#define ListView_SetHotlightColor(hwndLV, clrHotlight)\
        (BOOL)SNDMSG((hwndLV), LVM_SETHOTLIGHTCOLOR, 0,  (LPARAM)(clrHotlight))

#ifndef UNIX
#define  INTERFACE_PROLOGUE(a)
#define  INTERFACE_EPILOGUE(a)
#endif

#ifdef __IUnknown_INTERFACE_DEFINED__        // Don't assume they've #included objbase
#undef  INTERFACE
#define INTERFACE       ILVRange

DECLARE_INTERFACE_(ILVRange, IUnknown)
{
    INTERFACE_PROLOGUE(ILVRange)

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISelRange methods ***
    STDMETHOD(IncludeRange)(THIS_ LONG iBegin, LONG iEnd) PURE;
    STDMETHOD(ExcludeRange)(THIS_ LONG iBegin, LONG iEnd) PURE;
    STDMETHOD(InvertRange)(THIS_ LONG iBegin, LONG iEnd) PURE;
    STDMETHOD(InsertItem)(THIS_ LONG iItem) PURE;
    STDMETHOD(RemoveItem)(THIS_ LONG iItem) PURE;

    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(IsSelected)(THIS_ LONG iItem) PURE;
    STDMETHOD(IsEmpty)(THIS) PURE;
    STDMETHOD(NextSelected)(THIS_ LONG iItem, LONG *piItem) PURE;
    STDMETHOD(NextUnSelected)(THIS_ LONG iItem, LONG *piItem) PURE;
    STDMETHOD(CountIncluded)(THIS_ LONG *pcIncluded) PURE;

    INTERFACE_EPILOGUE(ILVRange)
};
#endif // __IUnknown_INTERFACE_DEFINED__

#define LVSR_SELECTION          0x00000000              // Set the Selection range object
#define LVSR_CUT                0x00000001              // Set the Cut range object

#define LVM_SETLVRANGEOBJECT    (LVM_FIRST + 82)
#define ListView_SetLVRangeObject(hwndLV, iWhich, pilvRange)\
        (BOOL)SNDMSG((hwndLV), LVM_SETLVRANGEOBJECT, (WPARAM)(iWhich),  (LPARAM)(pilvRange))

#define LVM_RESETEMPTYTEXT      (LVM_FIRST + 84)
#define ListView_ResetEmptyText(hwndLV)\
        (BOOL)SNDMSG((hwndLV), LVM_RESETEMPTYTEXT, 0, 0)

#define LVN_ENDDRAG             (LVN_FIRST-10)
#define LVN_ENDRDRAG            (LVN_FIRST-12)
#ifdef PW2
#define LVN_PEN                 (LVN_FIRST-20)
#endif
#define LVN_GETEMPTYTEXTA          (LVN_FIRST-60)
#define LVN_GETEMPTYTEXTW          (LVN_FIRST-61)

#ifdef UNICODE
#define LVN_GETEMPTYTEXT           LVN_GETEMPTYTEXTW
#else
#define LVN_GETEMPTYTEXT           LVN_GETEMPTYTEXTA
#endif
#if (_WIN32_IE >= 0x0500)
#define LVN_INCREMENTALSEARCHA   (LVN_FIRST-62)
#define LVN_INCREMENTALSEARCHW   (LVN_FIRST-63)

#ifdef UNICODE
#define LVN_INCREMENTALSEARCH    LVN_INCREMENTALSEARCHW
#else
#define LVN_INCREMENTALSEARCH    LVN_INCREMENTALSEARCHA
#endif

#endif      // _WIN32_IE >= 0x0500
#define TVS_SHAREDIMAGELISTS    0x0000  //
#define TVS_PRIVATEIMAGELISTS   0x0400  //
#define TVIF_WIN95              0x007F
#define TVIF_ALL                0x00FF
#define TVIF_RESERVED           0xf000  // all bits in high nibble is for notify specific stuff

#define TVIS_FOCUSED            0x0001  // Never implemented
#define TVIS_DISABLED           0        // GOING AWAY
#define TVIS_ALL                0xFF7E
    // all items above this line were for win95.  don't touch them.
    //  unfortunately, this structure was used inline in tv's notify structures
    //  which means that the size must be fixed for compat reasond
    // all items above this line were for win95.  don't touch them.
    //  unfortunately, this structure was used inline in tv's notify structures
    //  which means that the size must be fixed for compat reasond
    // all items above this line were for win95.  don't touch them.
#define TVE_ACTIONMASK          0x0003      //  (TVE_COLLAPSE | TVE_EXPAND | TVE_TOGGLE)
#define TV_FINDITEM             (TV_FIRST + 3)  // BUGBUG: Not implemented
#define TVM_SETBORDER         (TV_FIRST + 35)
#define TreeView_SetBorder(hwnd,  dwFlags, xBorder, yBorder) \
    (int)SNDMSG((hwnd), TVM_SETBORDER, (WPARAM)(dwFlags), MAKELPARAM(xBorder, yBorder))

#define TVM_GETBORDER         (TV_FIRST + 36)
#define TreeView_GetBorder(hwnd) \
    (int)SNDMSG((hwnd), TVM_GETBORDER, 0, 0)


#define TVSBF_XBORDER   0x00000001
#define TVSBF_YBORDER   0x00000002
#define TVM_TRANSLATEACCELERATOR    CCM_TRANSLATEACCELERATOR
#define CBEN_ITEMCHANGED         (CBEN_FIRST - 3)  //
#define TCS_SHAREIMAGELISTS     0x0000
#define TCS_PRIVATEIMAGELISTS   0x0000
#define TCM_GETBKCOLOR          (TCM_FIRST + 0)
#define TabCtrl_GetBkColor(hwnd)  (COLORREF)SNDMSG((hwnd), TCM_GETBKCOLOR, 0, 0L)

#define TCM_SETBKCOLOR          (TCM_FIRST + 1)
#define TabCtrl_SetBkColor(hwnd, clrBk)  (BOOL)SNDMSG((hwnd), TCM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))
#define TCIF_ALL                0x001f
#define TCIS_HIDDEN             0x0004
// BUGBUG: we need to pull the state code stuff out
    // This block must be identical to TC_TEIMHEADER
    // This block must be identical to TC_TEIMHEADER
// internal because it is not implemented yet
#define TCM_GETOBJECT           (TCM_FIRST + 54)
#define TabCtrl_GetObject(hwnd, piid, ppv) \
        (DWORD)SNDMSG((hwnd), TCM_GETOBJECT, (WPARAM)(piid), (LPARAM)(ppv))
#define MCSC_COLORCOUNT   6   //
// NOTE: this was MCN_FIRST + 2 but I changed it when I changed the structre //
#define MCS_VALIDBITS       0x001F          //
#define MCS_INVALIDBITS     ((~MCS_VALIDBITS) & 0x0000FFFF) //
#define DTS_FORMATMASK      0x000C
#define DTS_VALIDBITS       0x003F //
#define DTS_INVALIDBITS     ((~DTS_VALIDBITS) & 0x0000FFFF) //
#define PGM_SETSCROLLINFO      (PGM_FIRST + 13)
#define Pager_SetScrollInfo(hwnd, cTimeOut, cLinesPer, cPixelsPerLine) \
        (void) SNDMSG((hwnd), PGM_SETSCROLLINFO, cTimeOut, MAKELONG(cLinesPer, cPixelsPerLine))

#ifndef NO_COMMCTRL_DA
#define __COMMCTRL_DA_DEFINED__
//====== Dynamic Array routines ==========================================
#define DA_LAST         (0x7FFFFFFF)
#define DPA_APPEND      (0x7fffffff)
#define DPA_ERR         (-1)

#define DSA_APPEND      (0x7fffffff)
#define DSA_ERR         (-1)



// Dynamic structure array
typedef struct _DSA FAR* HDSA;

typedef int (CALLBACK *PFNDPAENUMCALLBACK)(LPVOID p, LPVOID pData);
typedef int (CALLBACK *PFNDSAENUMCALLBACK)(LPVOID p, LPVOID pData);

WINCOMMCTRLAPI HDSA   WINAPI DSA_Create(int cbItem, int cItemGrow);
WINCOMMCTRLAPI BOOL   WINAPI DSA_Destroy(HDSA hdsa);
WINCOMMCTRLAPI BOOL   WINAPI DSA_GetItem(HDSA hdsa, int i, void FAR* pitem);
WINCOMMCTRLAPI LPVOID WINAPI DSA_GetItemPtr(HDSA hdsa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_SetItem(HDSA hdsa, int i, void FAR* pitem);
WINCOMMCTRLAPI int    WINAPI DSA_InsertItem(HDSA hdsa, int i, void FAR* pitem);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteItem(HDSA hdsa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteAllItems(HDSA hdsa);
WINCOMMCTRLAPI void   WINAPI DSA_EnumCallback(HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData);
WINCOMMCTRLAPI void   WINAPI DSA_DestroyCallback(HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData);
#define     DSA_GetItemCount(hdsa)      (*(int FAR*)(hdsa))
#define     DSA_AppendItem(hdsa, pitem) DSA_InsertItem(hdsa, DA_LAST, pitem)

// Dynamic pointer array
typedef struct _DPA FAR* HDPA;

WINCOMMCTRLAPI HDPA   WINAPI DPA_Create(int cItemGrow);
WINCOMMCTRLAPI HDPA   WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap);
WINCOMMCTRLAPI BOOL   WINAPI DPA_Destroy(HDPA hdpa);
WINCOMMCTRLAPI HDPA   WINAPI DPA_Clone(HDPA hdpa, HDPA hdpaNew);
WINCOMMCTRLAPI LPVOID WINAPI DPA_GetPtr(HDPA hdpa, INT_PTR i);
WINCOMMCTRLAPI int    WINAPI DPA_GetPtrIndex(HDPA hdpa, LPVOID p);
WINCOMMCTRLAPI BOOL   WINAPI DPA_Grow(HDPA pdpa, int cp);
WINCOMMCTRLAPI BOOL   WINAPI DPA_SetPtr(HDPA hdpa, int i, LPVOID p);
WINCOMMCTRLAPI int    WINAPI DPA_InsertPtr(HDPA hdpa, int i, LPVOID p);
WINCOMMCTRLAPI LPVOID WINAPI DPA_DeletePtr(HDPA hdpa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DPA_DeleteAllPtrs(HDPA hdpa);
WINCOMMCTRLAPI void   WINAPI DPA_EnumCallback(HDPA hdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData);
WINCOMMCTRLAPI void   WINAPI DPA_DestroyCallback(HDPA hdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData);
#define     DPA_GetPtrCount(hdpa)       (*(int FAR*)(hdpa))
#define     DPA_FastDeleteLastPtr(hdpa) (--*(int FAR*)(hdpa))
#define     DPA_GetPtrPtr(hdpa)         (*((LPVOID FAR* FAR*)((BYTE FAR*)(hdpa) + sizeof(void *))))
#define     DPA_FastGetPtr(hdpa, i)     (DPA_GetPtrPtr(hdpa)[i])
#define     DPA_AppendPtr(hdpa, pitem)  DPA_InsertPtr(hdpa, DA_LAST, pitem)

#ifdef __IStream_INTERFACE_DEFINED__
// Save to and load from a stream.  The stream callback gets a pointer to
// a DPASTREAMINFO structure.
//
// For DPA_SaveStream, the callback is responsible for writing the pvItem
// info to the stream.  (It's not necessary to write the iPos to the
// stream.)  Return S_OK if the element was saved, S_FALSE if it wasn't
// but continue anyway, or some failure.
//
// For DPA_LoadStream, the callback is responsible for allocating an
// item and setting the pvItem field to the new pointer.  Return S_OK
// if the element was loaded, S_FALSE it it wasn't but continue anyway,
// or some failure.
//

typedef struct _DPASTREAMINFO
{
    int    iPos;        // Index of item
    LPVOID pvItem;
} DPASTREAMINFO;

typedef HRESULT (CALLBACK *PFNDPASTREAM)(DPASTREAMINFO * pinfo, IStream * pstream, LPVOID pvInstData);

WINCOMMCTRLAPI HRESULT WINAPI DPA_LoadStream(HDPA * phdpa, PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData);
WINCOMMCTRLAPI HRESULT WINAPI DPA_SaveStream(HDPA hdpa, PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData);
#endif

typedef int (CALLBACK *PFNDPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);

WINCOMMCTRLAPI BOOL   WINAPI DPA_Sort(HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam);

// Merge two DPAs.  This takes two (optionally) presorted arrays and merges
// the source array into the dest.  DPA_Merge uses the provided callbacks
// to perform comparison and merge operations.  The merge callback is
// called when two elements (one in each list) match according to the
// compare function.  This allows portions of an element in one list to
// be merged with the respective element in the second list.
//
// The first DPA (hdpaDest) is the output array.
//
// Merge options:
//
//    DPAM_SORTED       The arrays are already sorted; don't sort
//    DPAM_UNION        The resulting array is the union of all elements
//                      in both arrays (DPAMM_INSERT may be sent for
//                      this merge option.)
//    DPAM_INTERSECT    Only elements in the source array that intersect
//                      with the dest array are merged.  (DPAMM_DELETE
//                      may be sent for this merge option.)
//    DPAM_NORMAL       Like DPAM_INTERSECT except the dest array
//                      also maintains its original, additional elements.
//
#define DPAM_SORTED             0x00000001
#define DPAM_NORMAL             0x00000002
#define DPAM_UNION              0x00000004
#define DPAM_INTERSECT          0x00000008

// The merge callback should merge contents of the two items and return
// the pointer of the merged item.  It's okay to simply use pvDest
// as the returned pointer.
//
typedef LPVOID (CALLBACK *PFNDPAMERGE)(UINT uMsg, LPVOID pvDest, LPVOID pvSrc, LPARAM lParam);

// Messages for merge callback
#define DPAMM_MERGE     1
#define DPAMM_DELETE    2
#define DPAMM_INSERT    3

WINCOMMCTRLAPI BOOL WINAPI DPA_Merge(HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDPACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam);


// Search array.  If DPAS_SORTED, then array is assumed to be sorted
// according to pfnCompare, and binary search algorithm is used.
// Otherwise, linear search is used.
//
// Searching starts at iStart (0 to start search at beginning).
//
// DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not
// found.  If neither are specified, this function returns -1 if no exact
// match is found.  Otherwise, the index of the item before or after the
// closest (including exact) match is returned.
//
// Search option flags
//
#define DPAS_SORTED             0x0001
#define DPAS_INSERTBEFORE       0x0002
#define DPAS_INSERTAFTER        0x0004

WINCOMMCTRLAPI int WINAPI DPA_Search(HDPA hdpa, LPVOID pFind, int iStart,
                      PFNDPACOMPARE pfnCompare,
                      LPARAM lParam, UINT options);
#define     DPA_SortedInsertPtr(hdpa, pFind, iStart, pfnCompare, lParam, options, pitem)  \
                    DPA_InsertPtr(hdpa, DPA_Search(hdpa, pFind, iStart, pfnCompare, lParam, (DPAS_SORTED | (options))), (pitem))

//======================================================================
// String management helper routines

WINCOMMCTRLAPI int  WINAPI Str_GetPtrA(LPCSTR psz, LPSTR pszBuf, int cchBuf);
WINCOMMCTRLAPI int  WINAPI Str_GetPtrW(LPCWSTR psz, LPWSTR pszBuf, int cchBuf);
WINCOMMCTRLAPI BOOL WINAPI Str_SetPtrA(LPSTR * ppsz, LPCSTR psz);
WINCOMMCTRLAPI BOOL WINAPI Str_SetPtrW(LPWSTR * ppsz, LPCWSTR psz);

#ifdef UNICODE
#define Str_GetPtr              Str_GetPtrW
#define Str_SetPtr              Str_SetPtrW
#else
#define Str_GetPtr              Str_GetPtrA
#define Str_SetPtr              Str_SetPtrA
#endif

#endif // NO_COMMCTRL_DA

#ifndef NO_COMMCTRL_ALLOCFCNS
//====== Memory allocation functions ===================

#ifdef _WIN32
#define _huge
#endif

WINCOMMCTRLAPI void _huge* WINAPI Alloc(long cb);
WINCOMMCTRLAPI void _huge* WINAPI ReAlloc(void _huge* pb, long cb);
WINCOMMCTRLAPI BOOL        WINAPI Free(void _huge* pb);
WINCOMMCTRLAPI DWORD_PTR   WINAPI GetSize(void _huge* pb);

#endif


#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif

#ifdef _WIN32
// BUGBUG: move some place else
//===================================================================
typedef int (CALLBACK *MRUCMPPROCA)(LPCSTR, LPCSTR);
typedef int (CALLBACK *MRUCMPPROCW)(LPCWSTR, LPCWSTR);

#ifdef UNICODE
#define MRUCMPPROC              MRUCMPPROCW
#else
#define MRUCMPPROC              MRUCMPPROCA
#endif

// NB This is cdecl - to be compatible with the crts.
typedef int (cdecl FAR *MRUCMPDATAPROC)(const void FAR *, const void FAR *,
                                        size_t);



typedef struct _MRUINFOA {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCSTR lpszSubKey;
    MRUCMPPROCA lpfnCompare;
} MRUINFOA, FAR *LPMRUINFOA;

typedef struct _MRUINFOW {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCWSTR lpszSubKey;
    MRUCMPPROCW lpfnCompare;
} MRUINFOW, FAR *LPMRUINFOW;

typedef struct _MRUDATAINFOA {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCSTR lpszSubKey;
    MRUCMPDATAPROC lpfnCompare;
} MRUDATAINFOA, FAR *LPMRUDATAINFOA;

typedef struct _MRUDATAINFOW {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCWSTR lpszSubKey;
    MRUCMPDATAPROC lpfnCompare;
} MRUDATAINFOW, FAR *LPMRUDATAINFOW;


#ifdef UNICODE
#define MRUINFO                 MRUINFOW
#define LPMRUINFO               LPMRUINFOW
#define MRUDATAINFO             MRUDATAINFOW
#define LPMRUDATAINFO           LPMRUDATAINFOW
#else
#define MRUINFO                 MRUINFOA
#define LPMRUINFO               LPMRUINFOA
#define MRUDATAINFO             MRUDATAINFOA
#define LPMRUDATAINFO           LPMRUDATAINFOA
#endif

#define MRU_BINARY              0x0001
#define MRU_CACHEWRITE          0x0002
#define MRU_ANSI                0x0004
#define MRU_LAZY                0x8000

WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListA(LPMRUINFOA lpmi);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListW(LPMRUINFOW lpmi);
WINCOMMCTRLAPI void   WINAPI FreeMRUList(HANDLE hMRU);
WINCOMMCTRLAPI int    WINAPI AddMRUStringA(HANDLE hMRU, LPCSTR szString);
WINCOMMCTRLAPI int    WINAPI AddMRUStringW(HANDLE hMRU, LPCWSTR szString);
WINCOMMCTRLAPI int    WINAPI DelMRUString(HANDLE hMRU, int nItem);
WINCOMMCTRLAPI int    WINAPI FindMRUStringA(HANDLE hMRU, LPCSTR szString, LPINT lpiSlot);
WINCOMMCTRLAPI int    WINAPI FindMRUStringW(HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot);
WINCOMMCTRLAPI int    WINAPI EnumMRUListA(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen);
WINCOMMCTRLAPI int    WINAPI EnumMRUListW(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen);

WINCOMMCTRLAPI int    WINAPI AddMRUData(HANDLE hMRU, const void FAR *lpData, UINT cbData);
WINCOMMCTRLAPI int    WINAPI FindMRUData(HANDLE hMRU, const void FAR *lpData, UINT cbData,
                          LPINT lpiSlot);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListLazyA(LPMRUINFOA lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListLazyW(LPMRUINFOW lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot);

#ifdef UNICODE
#define CreateMRUList           CreateMRUListW
#define AddMRUString            AddMRUStringW
#define FindMRUString           FindMRUStringW
#define EnumMRUList             EnumMRUListW
#define CreateMRUListLazy       CreateMRUListLazyW
#else
#define CreateMRUList           CreateMRUListA
#define AddMRUString            AddMRUStringA
#define FindMRUString           FindMRUStringA
#define EnumMRUList             EnumMRUListA
#define CreateMRUListLazy       CreateMRUListLazyA
#endif

#endif

//=========================================================================
// for people that just gotta use GetProcAddress()

#ifdef _WIN32
#define DPA_CreateORD           328
#define DPA_DestroyORD          329
#define DPA_GrowORD             330
#define DPA_CloneORD            331
#define DPA_GetPtrORD           332
#define DPA_GetPtrIndexORD      333
#define DPA_InsertPtrORD        334
#define DPA_SetPtrORD           335
#define DPA_DeletePtrORD        336
#define DPA_DeleteAllPtrsORD    337
#define DPA_SortORD             338
#define DPA_SearchORD           339
#define DPA_CreateExORD         340
#define SendNotifyORD           341
#define CreatePageORD           163
#define CreateProxyPageORD      164
#endif
#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#ifndef TME_VALID
#if (WINVER >= 0x0500)
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL)
#else
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL)
#endif // WINVER >= 0x0500
#endif // !TME_VALID
// These definitions are never used as a bitmask; I don't know why
// they are all powers of two.
#if (_WIN32_IE >= 0x0500)
#define WSB_PROP_GUTTER     0x00001000L
#endif // (_WIN32_IE >= 0x0500)
// WSP_PROP_MASK is completely unused, but it was public in IE4
//====== SetPathWordBreakProc  ======================================
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet);
//
// subclassing stuff
//
typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

EXTERN_C
BOOL SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData);
EXTERN_C
BOOL GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData);
EXTERN_C
BOOL RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass);
EXTERN_C
LRESULT DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#ifdef __cplusplus
}
#endif

#endif

#endif  // _INC_COMMCTRLP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\adoid.h ===
//--------------------------------------------------------------------
// Microsoft ADO
//
// (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module	adoid.h | ADO Guids
//
// @devnote None
//--------------------------------------------------------------------

//
//
//
//
//
//
// Warning!!
//
// check MAXAVAILABLEGUID and MAXAVAILABLEGUIDALL to find the next available guid
//
//
//
//
//
//

#ifndef _ADOID_H_
#define _ADOID_H_

#include "adodef.h"

#define DEFINE_ADOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

// Type library
DEFINE_ADOGUID(LIBID_ADO20,				0x00000200);
DEFINE_ADOGUID(LIBID_ADOR20,			0x00000300);
DEFINE_ADOGUID(LIBID_ADO25,				0x00000205);
DEFINE_ADOGUID(LIBID_ADOR25,			0x00000305);

#define LIBID_ADO		LIBID_ADO25
#define LIBID_ADOR		LIBID_ADOR20

// defined for backwards compatibility
#define LIBID_CADO10	LIBID_ADO20
#define LIBID_CADOR10	LIBID_ADOR20

// Error
DEFINE_ADOGUID(IID_IADOError,            0x00000500);
DEFINE_ADOGUID(IID_IADOErrors,           0x00000501);

// Property
DEFINE_ADOGUID(IID_IADOProperty,         0x00000503);
DEFINE_ADOGUID(IID_IADOProperties,       0x00000504);

// Field
DEFINE_ADOGUID(CLSID_CADOField,			 0x0000053A);
DEFINE_ADOGUID(IID_IADOField15,            0x00000505);
DEFINE_ADOGUID(IID_IADOField20,            0x0000054C);
DEFINE_ADOGUID(IID_IADOField,            0x00000569);

DEFINE_ADOGUID(IID_IADOFields15,           0x00000506);
DEFINE_ADOGUID(IID_IADOFields20,           0x0000054D);
DEFINE_ADOGUID(IID_IADOFields,           0x00000564);

// Command
DEFINE_ADOGUID(CLSID_CADOCommand,		0x00000507);
DEFINE_ADOGUID(IID_IADOCommand15,			0x00000508);
DEFINE_ADOGUID(IID_IADOCommand,			0x0000054E);
DEFINE_ADOGUID(IID_IADOCommands,        0x00000509);
DEFINE_ADOGUID(IID_IADOCommandConstruction,	   0x00000517);

// Parameter
DEFINE_ADOGUID(CLSID_CADOParameter,		0x0000050B);
DEFINE_ADOGUID(IID_IADOParameter,        0x0000050C);
DEFINE_ADOGUID(IID_IADOParameters,       0x0000050D);

//Recordset
DEFINE_ADOGUID(CLSID_CADORecordset, 	 0x00000535);
DEFINE_ADOGUID(IID_IADORecordset15,		 0x0000050E);
DEFINE_ADOGUID(IID_IADORecordset20,		 0x0000054F);
DEFINE_ADOGUID(IID_IADORecordset21,		 0x00000555);
DEFINE_ADOGUID(IID_IADORecordset,		 0x00000556);

DEFINE_ADOGUID(IID_IADORecordsets,		 0x0000050F);
DEFINE_ADOGUID(IID_IADORecordsetConstruction,     0x00000283);

// Collections
DEFINE_ADOGUID(IID_IADOCollection,       0x00000512);
DEFINE_ADOGUID(IID_IADODynaCollection,   0x00000513);

// Connection
DEFINE_ADOGUID(CLSID_CADOConnection,	   0x00000514);
DEFINE_ADOGUID(IID_IADOConnection15,	   0x00000515);
DEFINE_ADOGUID(IID_IADOConnection,	   0x00000550);
DEFINE_ADOGUID(IID_IADOConnectionConstruction15,	0x00000516);
DEFINE_ADOGUID(IID_IADOConnectionConstruction,		0x00000551);
DEFINE_ADOGUID(IID_IADOConnections,		   0x00000518);

// events
// dispatch interfaces
DEFINE_ADOGUID(IID_IADORecordsetEvents,	   0x00000266);
DEFINE_ADOGUID(IID_IADOConnectionEvents,   0x00000400);
// vtable interfaces
DEFINE_ADOGUID(IID_IADORecordsetEventsVt,   0x00000403);
DEFINE_ADOGUID(IID_IADOConnectionEventsVt,  0x00000402);

DEFINE_ADOGUID(CLSID_CADORecord,			0x00000560);
DEFINE_ADOGUID(CLSID_CADORecField,			0x00000561);
DEFINE_ADOGUID(IID_IADORecord,				0x00000562);
DEFINE_ADOGUID(IID_IADORecFields,			0x00000563);
DEFINE_ADOGUID(IID_IADOStream,				0x00000565);
DEFINE_ADOGUID(CLSID_CADOStream,			0x00000566);
DEFINE_ADOGUID(IID_IADORecordConstruction,	0x00000567);
DEFINE_ADOGUID(IID_IADOStreamConstruction,	0x00000568);

#define MAXAVAILABLEGUID 0x00000570
#define MAXAVAILABLEGUIDALL 0x0000057F
#endif // _ADOID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\intshctp.h ===
/*
 * intshcut.h - Internet Shortcut interface definitions.
 *
 * Copyright (c) 1995-1998, Microsoft Corporation.  All rights reserved.
 */

#ifndef __INTSHCTP_H__
#define __INTSHCTP_H__

#define IURL_SETURL_FL_CANONICALIZE       0x0004
#define ALL_IURL_SETURL_FLAGS             0x0007


#define ALL_IURL_INVOKECOMMAND_FLAGS    (IURL_INVOKECOMMAND_FL_ALLOW_UI | IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB |IURL_INVOKECOMMAND_FL_DDEWAIT)


#define TRANSLATEURL_FL_CANONICALIZE        0x0004      // Canonicalize URL
#define ALL_TRANSLATEURL_FLAGS              0x0007


#define ALL_URLASSOCDLG_FLAGS   (URLASSOCDLG_FL_USE_DEFAULT_NAME | URLASSOCDLG_FL_REGISTER_ASSOC)


#define ALL_MIMEASSOCDLG_FLAGS          MIMEASSOCDLG_FL_REGISTER_ASSOC

#endif   // __INTSHCTP_H__

/*
 * intshcut.h - Internet Shortcut interface definitions.
 *
 * Copyright (c) 1995-1998, Microsoft Corporation.  All rights reserved.
 */

#ifndef __INTSHCTP_H__
#define __INTSHCTP_H__

#define IURL_SETURL_FL_CANONICALIZE       0x0004
#define ALL_IURL_SETURL_FLAGS             0x0007


#define ALL_IURL_INVOKECOMMAND_FLAGS    (IURL_INVOKECOMMAND_FL_ALLOW_UI | IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB |IURL_INVOKECOMMAND_FL_DDEWAIT)


#define TRANSLATEURL_FL_CANONICALIZE        0x0004      // Canonicalize URL
#define ALL_TRANSLATEURL_FLAGS              0x0007


#define ALL_URLASSOCDLG_FLAGS   (URLASSOCDLG_FL_USE_DEFAULT_NAME | URLASSOCDLG_FL_REGISTER_ASSOC)


#define ALL_MIMEASSOCDLG_FLAGS          MIMEASSOCDLG_FL_REGISTER_ASSOC

#endif   // __INTSHCTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\htiface.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Jan 24 20:14:46 2001
 */
/* Compiler settings for htiface.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __htiface_h__
#define __htiface_h__

/* Forward Declarations */ 

#ifndef __ITargetFrame_FWD_DEFINED__
#define __ITargetFrame_FWD_DEFINED__
typedef interface ITargetFrame ITargetFrame;
#endif 	/* __ITargetFrame_FWD_DEFINED__ */


#ifndef __ITargetEmbedding_FWD_DEFINED__
#define __ITargetEmbedding_FWD_DEFINED__
typedef interface ITargetEmbedding ITargetEmbedding;
#endif 	/* __ITargetEmbedding_FWD_DEFINED__ */


#ifndef __ITargetFramePriv_FWD_DEFINED__
#define __ITargetFramePriv_FWD_DEFINED__
typedef interface ITargetFramePriv ITargetFramePriv;
#endif 	/* __ITargetFramePriv_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_htiface_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// HTIface.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Hyperlinking ITargetFrame Interfaces.

#ifndef _LPTARGETFRAME2_DEFINED														
#include "htiframe.h"														
#endif // _LPTARGETFRAME2_DEFINED														


EXTERN_C const IID IID_ITargetFrame;
EXTERN_C const IID IID_ITargetEmbedding;
EXTERN_C const IID IID_ITargetFramePriv;
#ifndef _LPTARGETFRAME_DEFINED
#define _LPTARGETFRAME_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_htiface_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiface_0000_v0_0_s_ifspec;

#ifndef __ITargetFrame_INTERFACE_DEFINED__
#define __ITargetFrame_INTERFACE_DEFINED__

/* interface ITargetFrame */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITargetFrame __RPC_FAR *LPTARGETFRAME;

typedef /* [public] */ 
enum __MIDL_ITargetFrame_0001
    {	NAVIGATEFRAME_FL_RECORD	= 0x1,
	NAVIGATEFRAME_FL_POST	= 0x2,
	NAVIGATEFRAME_FL_NO_DOC_CACHE	= 0x4,
	NAVIGATEFRAME_FL_NO_IMAGE_CACHE	= 0x8,
	NAVIGATEFRAME_FL_AUTH_FAIL_CACHE_OK	= 0x10,
	NAVIGATEFRAME_FL_SENDING_FROM_FORM	= 0x20,
	NAVIGATEFRAME_FL_REALLY_SENDING_FROM_FORM	= 0x40
    }	NAVIGATEFRAME_FLAGS;

typedef struct tagNavigateData
    {
    ULONG ulTarget;
    ULONG ulURL;
    ULONG ulRefURL;
    ULONG ulPostData;
    DWORD dwFlags;
    }	NAVIGATEDATA;


EXTERN_C const IID IID_ITargetFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5f78c80-5252-11cf-90fa-00AA0042106e")
    ITargetFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFrameName( 
            /* [in] */ LPCWSTR pszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameName( 
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentFrame( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFrame( 
            /* [in] */ LPCWSTR pszTargetName,
            /* [in] */ IUnknown __RPC_FAR *ppunkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameSrc( 
            /* [in] */ LPCWSTR pszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameSrc( 
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFramesContainer( 
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameOptions( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameMargins( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameMargins( 
            /* [out] */ DWORD __RPC_FAR *pdwWidth,
            /* [out] */ DWORD __RPC_FAR *pdwHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoteNavigate( 
            /* [in] */ ULONG cLength,
            /* [size_is][in] */ ULONG __RPC_FAR *pulData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameActivate( 
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameDeactivate( 
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITargetFrame __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITargetFrame __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameName )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ LPCWSTR pszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameName )( 
            ITargetFrame __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentFrame )( 
            ITargetFrame __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFrame )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ LPCWSTR pszTargetName,
            /* [in] */ IUnknown __RPC_FAR *ppunkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameSrc )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ LPCWSTR pszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameSrc )( 
            ITargetFrame __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFramesContainer )( 
            ITargetFrame __RPC_FAR * This,
            /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameOptions )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameOptions )( 
            ITargetFrame __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFrameMargins )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameMargins )( 
            ITargetFrame __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwWidth,
            /* [out] */ DWORD __RPC_FAR *pdwHeight);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteNavigate )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ ULONG cLength,
            /* [size_is][in] */ ULONG __RPC_FAR *pulData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnChildFrameActivate )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnChildFrameDeactivate )( 
            ITargetFrame __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);
        
        END_INTERFACE
    } ITargetFrameVtbl;

    interface ITargetFrame
    {
        CONST_VTBL struct ITargetFrameVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITargetFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITargetFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITargetFrame_SetFrameName(This,pszFrameName)	\
    (This)->lpVtbl -> SetFrameName(This,pszFrameName)

#define ITargetFrame_GetFrameName(This,ppszFrameName)	\
    (This)->lpVtbl -> GetFrameName(This,ppszFrameName)

#define ITargetFrame_GetParentFrame(This,ppunkParent)	\
    (This)->lpVtbl -> GetParentFrame(This,ppunkParent)

#define ITargetFrame_FindFrame(This,pszTargetName,ppunkContextFrame,dwFlags,ppunkTargetFrame)	\
    (This)->lpVtbl -> FindFrame(This,pszTargetName,ppunkContextFrame,dwFlags,ppunkTargetFrame)

#define ITargetFrame_SetFrameSrc(This,pszFrameSrc)	\
    (This)->lpVtbl -> SetFrameSrc(This,pszFrameSrc)

#define ITargetFrame_GetFrameSrc(This,ppszFrameSrc)	\
    (This)->lpVtbl -> GetFrameSrc(This,ppszFrameSrc)

#define ITargetFrame_GetFramesContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetFramesContainer(This,ppContainer)

#define ITargetFrame_SetFrameOptions(This,dwFlags)	\
    (This)->lpVtbl -> SetFrameOptions(This,dwFlags)

#define ITargetFrame_GetFrameOptions(This,pdwFlags)	\
    (This)->lpVtbl -> GetFrameOptions(This,pdwFlags)

#define ITargetFrame_SetFrameMargins(This,dwWidth,dwHeight)	\
    (This)->lpVtbl -> SetFrameMargins(This,dwWidth,dwHeight)

#define ITargetFrame_GetFrameMargins(This,pdwWidth,pdwHeight)	\
    (This)->lpVtbl -> GetFrameMargins(This,pdwWidth,pdwHeight)

#define ITargetFrame_RemoteNavigate(This,cLength,pulData)	\
    (This)->lpVtbl -> RemoteNavigate(This,cLength,pulData)

#define ITargetFrame_OnChildFrameActivate(This,pUnkChildFrame)	\
    (This)->lpVtbl -> OnChildFrameActivate(This,pUnkChildFrame)

#define ITargetFrame_OnChildFrameDeactivate(This,pUnkChildFrame)	\
    (This)->lpVtbl -> OnChildFrameDeactivate(This,pUnkChildFrame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITargetFrame_SetFrameName_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ LPCWSTR pszFrameName);


void __RPC_STUB ITargetFrame_SetFrameName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_GetFrameName_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszFrameName);


void __RPC_STUB ITargetFrame_GetFrameName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_GetParentFrame_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkParent);


void __RPC_STUB ITargetFrame_GetParentFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_FindFrame_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ LPCWSTR pszTargetName,
    /* [in] */ IUnknown __RPC_FAR *ppunkContextFrame,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);


void __RPC_STUB ITargetFrame_FindFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_SetFrameSrc_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ LPCWSTR pszFrameSrc);


void __RPC_STUB ITargetFrame_SetFrameSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_GetFrameSrc_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppszFrameSrc);


void __RPC_STUB ITargetFrame_GetFrameSrc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_GetFramesContainer_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [out] */ IOleContainer __RPC_FAR *__RPC_FAR *ppContainer);


void __RPC_STUB ITargetFrame_GetFramesContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_SetFrameOptions_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITargetFrame_SetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_GetFrameOptions_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB ITargetFrame_GetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_SetFrameMargins_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ DWORD dwWidth,
    /* [in] */ DWORD dwHeight);


void __RPC_STUB ITargetFrame_SetFrameMargins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_GetFrameMargins_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwWidth,
    /* [out] */ DWORD __RPC_FAR *pdwHeight);


void __RPC_STUB ITargetFrame_GetFrameMargins_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_RemoteNavigate_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ ULONG cLength,
    /* [size_is][in] */ ULONG __RPC_FAR *pulData);


void __RPC_STUB ITargetFrame_RemoteNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_OnChildFrameActivate_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);


void __RPC_STUB ITargetFrame_OnChildFrameActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFrame_OnChildFrameDeactivate_Proxy( 
    ITargetFrame __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);


void __RPC_STUB ITargetFrame_OnChildFrameDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITargetFrame_INTERFACE_DEFINED__ */


#ifndef __ITargetEmbedding_INTERFACE_DEFINED__
#define __ITargetEmbedding_INTERFACE_DEFINED__

/* interface ITargetEmbedding */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITargetEmbedding __RPC_FAR *LPTARGETEMBEDDING;


EXTERN_C const IID IID_ITargetEmbedding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("548793C0-9E74-11cf-9655-00A0C9034923")
    ITargetEmbedding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetFrame( 
            /* [out] */ ITargetFrame __RPC_FAR *__RPC_FAR *ppTargetFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetEmbeddingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITargetEmbedding __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITargetEmbedding __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITargetEmbedding __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetFrame )( 
            ITargetEmbedding __RPC_FAR * This,
            /* [out] */ ITargetFrame __RPC_FAR *__RPC_FAR *ppTargetFrame);
        
        END_INTERFACE
    } ITargetEmbeddingVtbl;

    interface ITargetEmbedding
    {
        CONST_VTBL struct ITargetEmbeddingVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetEmbedding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITargetEmbedding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITargetEmbedding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITargetEmbedding_GetTargetFrame(This,ppTargetFrame)	\
    (This)->lpVtbl -> GetTargetFrame(This,ppTargetFrame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITargetEmbedding_GetTargetFrame_Proxy( 
    ITargetEmbedding __RPC_FAR * This,
    /* [out] */ ITargetFrame __RPC_FAR *__RPC_FAR *ppTargetFrame);


void __RPC_STUB ITargetEmbedding_GetTargetFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITargetEmbedding_INTERFACE_DEFINED__ */


#ifndef __ITargetFramePriv_INTERFACE_DEFINED__
#define __ITargetFramePriv_INTERFACE_DEFINED__

/* interface ITargetFramePriv */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITargetFramePriv __RPC_FAR *LPTARGETFRAMEPRIV;


EXTERN_C const IID IID_ITargetFramePriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9216E421-2BF5-11d0-82B4-00A0C90C29C5")
    ITargetFramePriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindFrameDownwards( 
            /* [in] */ LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFrameInContext( 
            /* [in] */ LPCWSTR pszTargetName,
            /* [in] */ IUnknown __RPC_FAR *punkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameActivate( 
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnChildFrameDeactivate( 
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateHack( 
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ LPBC pbc,
            /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
            /* [unique][in] */ LPCWSTR pszTargetName,
            /* [in] */ LPCWSTR pszUrl,
            /* [unique][in] */ LPCWSTR pszLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindBrowserByIndex( 
            /* [in] */ DWORD dwID,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkBrowser) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITargetFramePrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITargetFramePriv __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITargetFramePriv __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFrameDownwards )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ LPCWSTR pszTargetName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFrameInContext )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ LPCWSTR pszTargetName,
            /* [in] */ IUnknown __RPC_FAR *punkContextFrame,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnChildFrameActivate )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnChildFrameDeactivate )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateHack )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ DWORD grfHLNF,
            /* [unique][in] */ LPBC pbc,
            /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
            /* [unique][in] */ LPCWSTR pszTargetName,
            /* [in] */ LPCWSTR pszUrl,
            /* [unique][in] */ LPCWSTR pszLocation);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindBrowserByIndex )( 
            ITargetFramePriv __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkBrowser);
        
        END_INTERFACE
    } ITargetFramePrivVtbl;

    interface ITargetFramePriv
    {
        CONST_VTBL struct ITargetFramePrivVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITargetFramePriv_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITargetFramePriv_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITargetFramePriv_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITargetFramePriv_FindFrameDownwards(This,pszTargetName,dwFlags,ppunkTargetFrame)	\
    (This)->lpVtbl -> FindFrameDownwards(This,pszTargetName,dwFlags,ppunkTargetFrame)

#define ITargetFramePriv_FindFrameInContext(This,pszTargetName,punkContextFrame,dwFlags,ppunkTargetFrame)	\
    (This)->lpVtbl -> FindFrameInContext(This,pszTargetName,punkContextFrame,dwFlags,ppunkTargetFrame)

#define ITargetFramePriv_OnChildFrameActivate(This,pUnkChildFrame)	\
    (This)->lpVtbl -> OnChildFrameActivate(This,pUnkChildFrame)

#define ITargetFramePriv_OnChildFrameDeactivate(This,pUnkChildFrame)	\
    (This)->lpVtbl -> OnChildFrameDeactivate(This,pUnkChildFrame)

#define ITargetFramePriv_NavigateHack(This,grfHLNF,pbc,pibsc,pszTargetName,pszUrl,pszLocation)	\
    (This)->lpVtbl -> NavigateHack(This,grfHLNF,pbc,pibsc,pszTargetName,pszUrl,pszLocation)

#define ITargetFramePriv_FindBrowserByIndex(This,dwID,ppunkBrowser)	\
    (This)->lpVtbl -> FindBrowserByIndex(This,dwID,ppunkBrowser)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITargetFramePriv_FindFrameDownwards_Proxy( 
    ITargetFramePriv __RPC_FAR * This,
    /* [in] */ LPCWSTR pszTargetName,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);


void __RPC_STUB ITargetFramePriv_FindFrameDownwards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFramePriv_FindFrameInContext_Proxy( 
    ITargetFramePriv __RPC_FAR * This,
    /* [in] */ LPCWSTR pszTargetName,
    /* [in] */ IUnknown __RPC_FAR *punkContextFrame,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkTargetFrame);


void __RPC_STUB ITargetFramePriv_FindFrameInContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFramePriv_OnChildFrameActivate_Proxy( 
    ITargetFramePriv __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);


void __RPC_STUB ITargetFramePriv_OnChildFrameActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFramePriv_OnChildFrameDeactivate_Proxy( 
    ITargetFramePriv __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkChildFrame);


void __RPC_STUB ITargetFramePriv_OnChildFrameDeactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFramePriv_NavigateHack_Proxy( 
    ITargetFramePriv __RPC_FAR * This,
    /* [in] */ DWORD grfHLNF,
    /* [unique][in] */ LPBC pbc,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pibsc,
    /* [unique][in] */ LPCWSTR pszTargetName,
    /* [in] */ LPCWSTR pszUrl,
    /* [unique][in] */ LPCWSTR pszLocation);


void __RPC_STUB ITargetFramePriv_NavigateHack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITargetFramePriv_FindBrowserByIndex_Proxy( 
    ITargetFramePriv __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkBrowser);


void __RPC_STUB ITargetFramePriv_FindBrowserByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITargetFramePriv_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_htiface_0203 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_htiface_0203_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htiface_0203_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\isguids.h ===
/*
 * isguids.h - Internet Shortcut GUID definitions.
 *
 * Copyright (c) 1995-1998, Microsoft Corporation.  All rights reserved.
 */


/* GUIDs
 ********/

#ifndef _ISGUIDS_H_
#define _ISGUIDS_H_

DEFINE_GUID(CLSID_InternetShortcut,       0xFBF23B40L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

DEFINE_GUID(IID_IUniformResourceLocatorA, 0xFBF23B80L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
DEFINE_GUID(IID_IUniformResourceLocatorW, 0xCABB0DA0L, 0xDA57, 0x11CF, 0x99, 0x74, 0x00, 0x20, 0xAF, 0xD7, 0x97, 0x62);

#ifdef UNICODE
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorW
#else
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\msluguid.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*            Copyright(c) Microsoft Corp., 1996-1998               **
//*********************************************************************

#ifndef _MSLUGUID_H_
#define _MSLUGUID_H_

// 95D0F020-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(CLSID_LocalUsers, 0x95D0F020L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F023-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUser,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F022-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserDatabase,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F024-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserProfileInit,0x95D0F024L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

#ifdef USER_SETTINGS_IMPLEMENTED
// EA7364C0-0730-11D0-83B1-00C04FD705B2
DEFINE_GUID(IID_IUserSettings,0xEA7364C0L, 0x0730, 0x11D0, 0x83, 0xB1, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xB2);
#endif

#endif  // _MSLUGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\mlang.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Jan 24 20:15:18 2001
 */
/* Compiler settings for mlang.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __mlang_h__
#define __mlang_h__

/* Forward Declarations */ 

#ifndef __IMLangStringBufW_FWD_DEFINED__
#define __IMLangStringBufW_FWD_DEFINED__
typedef interface IMLangStringBufW IMLangStringBufW;
#endif 	/* __IMLangStringBufW_FWD_DEFINED__ */


#ifndef __IMLangStringBufA_FWD_DEFINED__
#define __IMLangStringBufA_FWD_DEFINED__
typedef interface IMLangStringBufA IMLangStringBufA;
#endif 	/* __IMLangStringBufA_FWD_DEFINED__ */


#ifndef __IMLangString_FWD_DEFINED__
#define __IMLangString_FWD_DEFINED__
typedef interface IMLangString IMLangString;
#endif 	/* __IMLangString_FWD_DEFINED__ */


#ifndef __IMLangStringWStr_FWD_DEFINED__
#define __IMLangStringWStr_FWD_DEFINED__
typedef interface IMLangStringWStr IMLangStringWStr;
#endif 	/* __IMLangStringWStr_FWD_DEFINED__ */


#ifndef __IMLangStringAStr_FWD_DEFINED__
#define __IMLangStringAStr_FWD_DEFINED__
typedef interface IMLangStringAStr IMLangStringAStr;
#endif 	/* __IMLangStringAStr_FWD_DEFINED__ */


#ifndef __CMLangString_FWD_DEFINED__
#define __CMLangString_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMLangString CMLangString;
#else
typedef struct CMLangString CMLangString;
#endif /* __cplusplus */

#endif 	/* __CMLangString_FWD_DEFINED__ */


#ifndef __IMLangLineBreakConsole_FWD_DEFINED__
#define __IMLangLineBreakConsole_FWD_DEFINED__
typedef interface IMLangLineBreakConsole IMLangLineBreakConsole;
#endif 	/* __IMLangLineBreakConsole_FWD_DEFINED__ */


#ifndef __IEnumCodePage_FWD_DEFINED__
#define __IEnumCodePage_FWD_DEFINED__
typedef interface IEnumCodePage IEnumCodePage;
#endif 	/* __IEnumCodePage_FWD_DEFINED__ */


#ifndef __IEnumRfc1766_FWD_DEFINED__
#define __IEnumRfc1766_FWD_DEFINED__
typedef interface IEnumRfc1766 IEnumRfc1766;
#endif 	/* __IEnumRfc1766_FWD_DEFINED__ */


#ifndef __IEnumScript_FWD_DEFINED__
#define __IEnumScript_FWD_DEFINED__
typedef interface IEnumScript IEnumScript;
#endif 	/* __IEnumScript_FWD_DEFINED__ */


#ifndef __IMLangConvertCharset_FWD_DEFINED__
#define __IMLangConvertCharset_FWD_DEFINED__
typedef interface IMLangConvertCharset IMLangConvertCharset;
#endif 	/* __IMLangConvertCharset_FWD_DEFINED__ */


#ifndef __CMLangConvertCharset_FWD_DEFINED__
#define __CMLangConvertCharset_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMLangConvertCharset CMLangConvertCharset;
#else
typedef struct CMLangConvertCharset CMLangConvertCharset;
#endif /* __cplusplus */

#endif 	/* __CMLangConvertCharset_FWD_DEFINED__ */


#ifndef __IMultiLanguage_FWD_DEFINED__
#define __IMultiLanguage_FWD_DEFINED__
typedef interface IMultiLanguage IMultiLanguage;
#endif 	/* __IMultiLanguage_FWD_DEFINED__ */


#ifndef __IMultiLanguage2_FWD_DEFINED__
#define __IMultiLanguage2_FWD_DEFINED__
typedef interface IMultiLanguage2 IMultiLanguage2;
#endif 	/* __IMultiLanguage2_FWD_DEFINED__ */


#ifndef __IMLangCodePages_FWD_DEFINED__
#define __IMLangCodePages_FWD_DEFINED__
typedef interface IMLangCodePages IMLangCodePages;
#endif 	/* __IMLangCodePages_FWD_DEFINED__ */


#ifndef __IMLangFontLink_FWD_DEFINED__
#define __IMLangFontLink_FWD_DEFINED__
typedef interface IMLangFontLink IMLangFontLink;
#endif 	/* __IMLangFontLink_FWD_DEFINED__ */


#ifndef __IMLangFontLink2_FWD_DEFINED__
#define __IMLangFontLink2_FWD_DEFINED__
typedef interface IMLangFontLink2 IMLangFontLink2;
#endif 	/* __IMLangFontLink2_FWD_DEFINED__ */


#ifndef __CMultiLanguage_FWD_DEFINED__
#define __CMultiLanguage_FWD_DEFINED__

#ifdef __cplusplus
typedef class CMultiLanguage CMultiLanguage;
#else
typedef struct CMultiLanguage CMultiLanguage;
#endif /* __cplusplus */

#endif 	/* __CMultiLanguage_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mlang_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// MLang.h                                                                    
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.       
//                                                                            
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF        
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO        
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A             
// PARTICULAR PURPOSE.                                                        
//=--------------------------------------------------------------------------=
                                                                              
#pragma comment(lib,"uuid.lib")                                             
                                                                              
//----------------------------------------------------------------------------
// IMultiLanguage Interfaces.                                                 
                                                                              


extern RPC_IF_HANDLE __MIDL_itf_mlang_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mlang_0000_v0_0_s_ifspec;


#ifndef __MultiLanguage_LIBRARY_DEFINED__
#define __MultiLanguage_LIBRARY_DEFINED__

/* library MultiLanguage */
/* [version][lcid][helpstring][uuid] */ 

typedef WORD LANGID;

typedef 
enum tagMLSTR_FLAGS
    {	MLSTR_READ	= 1,
	MLSTR_WRITE	= 2
    }	MLSTR_FLAGS;

// dwfIODControl definitions for ValidateCodePageEx()
#define CPIOD_PEEK          0x40000000L
#define CPIOD_FORCE_PROMPT  0x80000000L

EXTERN_C const IID LIBID_MultiLanguage;

#ifndef __IMLangStringBufW_INTERFACE_DEFINED__
#define __IMLangStringBufW_INTERFACE_DEFINED__

/* interface IMLangStringBufW */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMLangStringBufW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D24ACD21-BA72-11D0-B188-00AA0038C969")
    IMLangStringBufW : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ long __RPC_FAR *plFlags,
            /* [out] */ long __RPC_FAR *pcchBuf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LockBuf( 
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxLock,
            /* [size_is][size_is][out] */ WCHAR __RPC_FAR *__RPC_FAR *ppszBuf,
            /* [out] */ long __RPC_FAR *pcchBuf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnlockBuf( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszBuf,
            /* [in] */ long cchOffset,
            /* [in] */ long cchWrite) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Insert( 
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxInsert,
            /* [out] */ long __RPC_FAR *pcchActual) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long cchOffset,
            /* [in] */ long cchDelete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangStringBufWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangStringBufW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangStringBufW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangStringBufW __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMLangStringBufW __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *plFlags,
            /* [out] */ long __RPC_FAR *pcchBuf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBuf )( 
            IMLangStringBufW __RPC_FAR * This,
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxLock,
            /* [size_is][size_is][out] */ WCHAR __RPC_FAR *__RPC_FAR *ppszBuf,
            /* [out] */ long __RPC_FAR *pcchBuf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBuf )( 
            IMLangStringBufW __RPC_FAR * This,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszBuf,
            /* [in] */ long cchOffset,
            /* [in] */ long cchWrite);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert )( 
            IMLangStringBufW __RPC_FAR * This,
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxInsert,
            /* [out] */ long __RPC_FAR *pcchActual);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IMLangStringBufW __RPC_FAR * This,
            /* [in] */ long cchOffset,
            /* [in] */ long cchDelete);
        
        END_INTERFACE
    } IMLangStringBufWVtbl;

    interface IMLangStringBufW
    {
        CONST_VTBL struct IMLangStringBufWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangStringBufW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangStringBufW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangStringBufW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangStringBufW_GetStatus(This,plFlags,pcchBuf)	\
    (This)->lpVtbl -> GetStatus(This,plFlags,pcchBuf)

#define IMLangStringBufW_LockBuf(This,cchOffset,cchMaxLock,ppszBuf,pcchBuf)	\
    (This)->lpVtbl -> LockBuf(This,cchOffset,cchMaxLock,ppszBuf,pcchBuf)

#define IMLangStringBufW_UnlockBuf(This,pszBuf,cchOffset,cchWrite)	\
    (This)->lpVtbl -> UnlockBuf(This,pszBuf,cchOffset,cchWrite)

#define IMLangStringBufW_Insert(This,cchOffset,cchMaxInsert,pcchActual)	\
    (This)->lpVtbl -> Insert(This,cchOffset,cchMaxInsert,pcchActual)

#define IMLangStringBufW_Delete(This,cchOffset,cchDelete)	\
    (This)->lpVtbl -> Delete(This,cchOffset,cchDelete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufW_GetStatus_Proxy( 
    IMLangStringBufW __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *plFlags,
    /* [out] */ long __RPC_FAR *pcchBuf);


void __RPC_STUB IMLangStringBufW_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufW_LockBuf_Proxy( 
    IMLangStringBufW __RPC_FAR * This,
    /* [in] */ long cchOffset,
    /* [in] */ long cchMaxLock,
    /* [size_is][size_is][out] */ WCHAR __RPC_FAR *__RPC_FAR *ppszBuf,
    /* [out] */ long __RPC_FAR *pcchBuf);


void __RPC_STUB IMLangStringBufW_LockBuf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufW_UnlockBuf_Proxy( 
    IMLangStringBufW __RPC_FAR * This,
    /* [size_is][in] */ const WCHAR __RPC_FAR *pszBuf,
    /* [in] */ long cchOffset,
    /* [in] */ long cchWrite);


void __RPC_STUB IMLangStringBufW_UnlockBuf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufW_Insert_Proxy( 
    IMLangStringBufW __RPC_FAR * This,
    /* [in] */ long cchOffset,
    /* [in] */ long cchMaxInsert,
    /* [out] */ long __RPC_FAR *pcchActual);


void __RPC_STUB IMLangStringBufW_Insert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufW_Delete_Proxy( 
    IMLangStringBufW __RPC_FAR * This,
    /* [in] */ long cchOffset,
    /* [in] */ long cchDelete);


void __RPC_STUB IMLangStringBufW_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangStringBufW_INTERFACE_DEFINED__ */


#ifndef __IMLangStringBufA_INTERFACE_DEFINED__
#define __IMLangStringBufA_INTERFACE_DEFINED__

/* interface IMLangStringBufA */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMLangStringBufA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D24ACD23-BA72-11D0-B188-00AA0038C969")
    IMLangStringBufA : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ long __RPC_FAR *plFlags,
            /* [out] */ long __RPC_FAR *pcchBuf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LockBuf( 
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxLock,
            /* [size_is][size_is][out] */ CHAR __RPC_FAR *__RPC_FAR *ppszBuf,
            /* [out] */ long __RPC_FAR *pcchBuf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnlockBuf( 
            /* [size_is][in] */ const CHAR __RPC_FAR *pszBuf,
            /* [in] */ long cchOffset,
            /* [in] */ long cchWrite) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Insert( 
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxInsert,
            /* [out] */ long __RPC_FAR *pcchActual) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ long cchOffset,
            /* [in] */ long cchDelete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangStringBufAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangStringBufA __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangStringBufA __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangStringBufA __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            IMLangStringBufA __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *plFlags,
            /* [out] */ long __RPC_FAR *pcchBuf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBuf )( 
            IMLangStringBufA __RPC_FAR * This,
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxLock,
            /* [size_is][size_is][out] */ CHAR __RPC_FAR *__RPC_FAR *ppszBuf,
            /* [out] */ long __RPC_FAR *pcchBuf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBuf )( 
            IMLangStringBufA __RPC_FAR * This,
            /* [size_is][in] */ const CHAR __RPC_FAR *pszBuf,
            /* [in] */ long cchOffset,
            /* [in] */ long cchWrite);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Insert )( 
            IMLangStringBufA __RPC_FAR * This,
            /* [in] */ long cchOffset,
            /* [in] */ long cchMaxInsert,
            /* [out] */ long __RPC_FAR *pcchActual);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IMLangStringBufA __RPC_FAR * This,
            /* [in] */ long cchOffset,
            /* [in] */ long cchDelete);
        
        END_INTERFACE
    } IMLangStringBufAVtbl;

    interface IMLangStringBufA
    {
        CONST_VTBL struct IMLangStringBufAVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangStringBufA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangStringBufA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangStringBufA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangStringBufA_GetStatus(This,plFlags,pcchBuf)	\
    (This)->lpVtbl -> GetStatus(This,plFlags,pcchBuf)

#define IMLangStringBufA_LockBuf(This,cchOffset,cchMaxLock,ppszBuf,pcchBuf)	\
    (This)->lpVtbl -> LockBuf(This,cchOffset,cchMaxLock,ppszBuf,pcchBuf)

#define IMLangStringBufA_UnlockBuf(This,pszBuf,cchOffset,cchWrite)	\
    (This)->lpVtbl -> UnlockBuf(This,pszBuf,cchOffset,cchWrite)

#define IMLangStringBufA_Insert(This,cchOffset,cchMaxInsert,pcchActual)	\
    (This)->lpVtbl -> Insert(This,cchOffset,cchMaxInsert,pcchActual)

#define IMLangStringBufA_Delete(This,cchOffset,cchDelete)	\
    (This)->lpVtbl -> Delete(This,cchOffset,cchDelete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufA_GetStatus_Proxy( 
    IMLangStringBufA __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *plFlags,
    /* [out] */ long __RPC_FAR *pcchBuf);


void __RPC_STUB IMLangStringBufA_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufA_LockBuf_Proxy( 
    IMLangStringBufA __RPC_FAR * This,
    /* [in] */ long cchOffset,
    /* [in] */ long cchMaxLock,
    /* [size_is][size_is][out] */ CHAR __RPC_FAR *__RPC_FAR *ppszBuf,
    /* [out] */ long __RPC_FAR *pcchBuf);


void __RPC_STUB IMLangStringBufA_LockBuf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufA_UnlockBuf_Proxy( 
    IMLangStringBufA __RPC_FAR * This,
    /* [size_is][in] */ const CHAR __RPC_FAR *pszBuf,
    /* [in] */ long cchOffset,
    /* [in] */ long cchWrite);


void __RPC_STUB IMLangStringBufA_UnlockBuf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufA_Insert_Proxy( 
    IMLangStringBufA __RPC_FAR * This,
    /* [in] */ long cchOffset,
    /* [in] */ long cchMaxInsert,
    /* [out] */ long __RPC_FAR *pcchActual);


void __RPC_STUB IMLangStringBufA_Insert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringBufA_Delete_Proxy( 
    IMLangStringBufA __RPC_FAR * This,
    /* [in] */ long cchOffset,
    /* [in] */ long cchDelete);


void __RPC_STUB IMLangStringBufA_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangStringBufA_INTERFACE_DEFINED__ */


#ifndef __IMLangString_INTERFACE_DEFINED__
#define __IMLangString_INTERFACE_DEFINED__

/* interface IMLangString */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMLangString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C04D65CE-B70D-11D0-B188-00AA0038C969")
    IMLangString : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sync( 
            /* [in] */ BOOL fNoAccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLength( 
            /* [retval][out] */ long __RPC_FAR *plLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMLStr( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ IUnknown __RPC_FAR *pSrcMLStr,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMLStr( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ const IID __RPC_FAR *piid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDestMLStr,
            /* [out] */ long __RPC_FAR *plDestPos,
            /* [out] */ long __RPC_FAR *plDestLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangString __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangString __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sync )( 
            IMLangString __RPC_FAR * This,
            /* [in] */ BOOL fNoAccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IMLangString __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMLStr )( 
            IMLangString __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ IUnknown __RPC_FAR *pSrcMLStr,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMLStr )( 
            IMLangString __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ const IID __RPC_FAR *piid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDestMLStr,
            /* [out] */ long __RPC_FAR *plDestPos,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        END_INTERFACE
    } IMLangStringVtbl;

    interface IMLangString
    {
        CONST_VTBL struct IMLangStringVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangString_Sync(This,fNoAccess)	\
    (This)->lpVtbl -> Sync(This,fNoAccess)

#define IMLangString_GetLength(This,plLen)	\
    (This)->lpVtbl -> GetLength(This,plLen)

#define IMLangString_SetMLStr(This,lDestPos,lDestLen,pSrcMLStr,lSrcPos,lSrcLen)	\
    (This)->lpVtbl -> SetMLStr(This,lDestPos,lDestLen,pSrcMLStr,lSrcPos,lSrcLen)

#define IMLangString_GetMLStr(This,lSrcPos,lSrcLen,pUnkOuter,dwClsContext,piid,ppDestMLStr,plDestPos,plDestLen)	\
    (This)->lpVtbl -> GetMLStr(This,lSrcPos,lSrcLen,pUnkOuter,dwClsContext,piid,ppDestMLStr,plDestPos,plDestLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangString_Sync_Proxy( 
    IMLangString __RPC_FAR * This,
    /* [in] */ BOOL fNoAccess);


void __RPC_STUB IMLangString_Sync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangString_GetLength_Proxy( 
    IMLangString __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plLen);


void __RPC_STUB IMLangString_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangString_SetMLStr_Proxy( 
    IMLangString __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [in] */ IUnknown __RPC_FAR *pSrcMLStr,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen);


void __RPC_STUB IMLangString_SetMLStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangString_GetMLStr_Proxy( 
    IMLangString __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ const IID __RPC_FAR *piid,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDestMLStr,
    /* [out] */ long __RPC_FAR *plDestPos,
    /* [out] */ long __RPC_FAR *plDestLen);


void __RPC_STUB IMLangString_GetMLStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangString_INTERFACE_DEFINED__ */


#ifndef __IMLangStringWStr_INTERFACE_DEFINED__
#define __IMLangStringWStr_INTERFACE_DEFINED__

/* interface IMLangStringWStr */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMLangStringWStr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C04D65D0-B70D-11D0-B188-00AA0038C969")
    IMLangStringWStr : public IMLangString
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetWStr( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStrBufW( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ IMLangStringBufW __RPC_FAR *pSrcBuf,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWStr( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [size_is][out] */ WCHAR __RPC_FAR *pszDest,
            /* [in] */ long cchDest,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStrBufW( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ IMLangStringBufW __RPC_FAR *__RPC_FAR *ppDestBuf,
            /* [out] */ long __RPC_FAR *plDestLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LockWStr( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ long lFlags,
            /* [in] */ long cchRequest,
            /* [size_is][size_is][out] */ WCHAR __RPC_FAR *__RPC_FAR *ppszDest,
            /* [out] */ long __RPC_FAR *pcchDest,
            /* [out] */ long __RPC_FAR *plDestLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnlockWStr( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ LCID locale) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLocale( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ LCID __RPC_FAR *plocale,
            /* [out] */ long __RPC_FAR *plLocalePos,
            /* [out] */ long __RPC_FAR *plLocaleLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangStringWStrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangStringWStr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangStringWStr __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sync )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ BOOL fNoAccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMLStr )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ IUnknown __RPC_FAR *pSrcMLStr,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMLStr )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ const IID __RPC_FAR *piid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDestMLStr,
            /* [out] */ long __RPC_FAR *plDestPos,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWStr )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStrBufW )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ IMLangStringBufW __RPC_FAR *pSrcBuf,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWStr )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [size_is][out] */ WCHAR __RPC_FAR *pszDest,
            /* [in] */ long cchDest,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrBufW )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ IMLangStringBufW __RPC_FAR *__RPC_FAR *ppDestBuf,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockWStr )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ long lFlags,
            /* [in] */ long cchRequest,
            /* [size_is][size_is][out] */ WCHAR __RPC_FAR *__RPC_FAR *ppszDest,
            /* [out] */ long __RPC_FAR *pcchDest,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockWStr )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocale )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ LCID locale);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocale )( 
            IMLangStringWStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ LCID __RPC_FAR *plocale,
            /* [out] */ long __RPC_FAR *plLocalePos,
            /* [out] */ long __RPC_FAR *plLocaleLen);
        
        END_INTERFACE
    } IMLangStringWStrVtbl;

    interface IMLangStringWStr
    {
        CONST_VTBL struct IMLangStringWStrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangStringWStr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangStringWStr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangStringWStr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangStringWStr_Sync(This,fNoAccess)	\
    (This)->lpVtbl -> Sync(This,fNoAccess)

#define IMLangStringWStr_GetLength(This,plLen)	\
    (This)->lpVtbl -> GetLength(This,plLen)

#define IMLangStringWStr_SetMLStr(This,lDestPos,lDestLen,pSrcMLStr,lSrcPos,lSrcLen)	\
    (This)->lpVtbl -> SetMLStr(This,lDestPos,lDestLen,pSrcMLStr,lSrcPos,lSrcLen)

#define IMLangStringWStr_GetMLStr(This,lSrcPos,lSrcLen,pUnkOuter,dwClsContext,piid,ppDestMLStr,plDestPos,plDestLen)	\
    (This)->lpVtbl -> GetMLStr(This,lSrcPos,lSrcLen,pUnkOuter,dwClsContext,piid,ppDestMLStr,plDestPos,plDestLen)


#define IMLangStringWStr_SetWStr(This,lDestPos,lDestLen,pszSrc,cchSrc,pcchActual,plActualLen)	\
    (This)->lpVtbl -> SetWStr(This,lDestPos,lDestLen,pszSrc,cchSrc,pcchActual,plActualLen)

#define IMLangStringWStr_SetStrBufW(This,lDestPos,lDestLen,pSrcBuf,pcchActual,plActualLen)	\
    (This)->lpVtbl -> SetStrBufW(This,lDestPos,lDestLen,pSrcBuf,pcchActual,plActualLen)

#define IMLangStringWStr_GetWStr(This,lSrcPos,lSrcLen,pszDest,cchDest,pcchActual,plActualLen)	\
    (This)->lpVtbl -> GetWStr(This,lSrcPos,lSrcLen,pszDest,cchDest,pcchActual,plActualLen)

#define IMLangStringWStr_GetStrBufW(This,lSrcPos,lSrcMaxLen,ppDestBuf,plDestLen)	\
    (This)->lpVtbl -> GetStrBufW(This,lSrcPos,lSrcMaxLen,ppDestBuf,plDestLen)

#define IMLangStringWStr_LockWStr(This,lSrcPos,lSrcLen,lFlags,cchRequest,ppszDest,pcchDest,plDestLen)	\
    (This)->lpVtbl -> LockWStr(This,lSrcPos,lSrcLen,lFlags,cchRequest,ppszDest,pcchDest,plDestLen)

#define IMLangStringWStr_UnlockWStr(This,pszSrc,cchSrc,pcchActual,plActualLen)	\
    (This)->lpVtbl -> UnlockWStr(This,pszSrc,cchSrc,pcchActual,plActualLen)

#define IMLangStringWStr_SetLocale(This,lDestPos,lDestLen,locale)	\
    (This)->lpVtbl -> SetLocale(This,lDestPos,lDestLen,locale)

#define IMLangStringWStr_GetLocale(This,lSrcPos,lSrcMaxLen,plocale,plLocalePos,plLocaleLen)	\
    (This)->lpVtbl -> GetLocale(This,lSrcPos,lSrcMaxLen,plocale,plLocalePos,plLocaleLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_SetWStr_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringWStr_SetWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_SetStrBufW_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [in] */ IMLangStringBufW __RPC_FAR *pSrcBuf,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringWStr_SetStrBufW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_GetWStr_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen,
    /* [size_is][out] */ WCHAR __RPC_FAR *pszDest,
    /* [in] */ long cchDest,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringWStr_GetWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_GetStrBufW_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcMaxLen,
    /* [out] */ IMLangStringBufW __RPC_FAR *__RPC_FAR *ppDestBuf,
    /* [out] */ long __RPC_FAR *plDestLen);


void __RPC_STUB IMLangStringWStr_GetStrBufW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_LockWStr_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen,
    /* [in] */ long lFlags,
    /* [in] */ long cchRequest,
    /* [size_is][size_is][out] */ WCHAR __RPC_FAR *__RPC_FAR *ppszDest,
    /* [out] */ long __RPC_FAR *pcchDest,
    /* [out] */ long __RPC_FAR *plDestLen);


void __RPC_STUB IMLangStringWStr_LockWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_UnlockWStr_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringWStr_UnlockWStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_SetLocale_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [in] */ LCID locale);


void __RPC_STUB IMLangStringWStr_SetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringWStr_GetLocale_Proxy( 
    IMLangStringWStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcMaxLen,
    /* [out] */ LCID __RPC_FAR *plocale,
    /* [out] */ long __RPC_FAR *plLocalePos,
    /* [out] */ long __RPC_FAR *plLocaleLen);


void __RPC_STUB IMLangStringWStr_GetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangStringWStr_INTERFACE_DEFINED__ */


#ifndef __IMLangStringAStr_INTERFACE_DEFINED__
#define __IMLangStringAStr_INTERFACE_DEFINED__

/* interface IMLangStringAStr */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMLangStringAStr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C04D65D2-B70D-11D0-B188-00AA0038C969")
    IMLangStringAStr : public IMLangString
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAStr( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ UINT uCodePage,
            /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStrBufA( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ UINT uCodePage,
            /* [in] */ IMLangStringBufA __RPC_FAR *pSrcBuf,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAStr( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ UINT uCodePageIn,
            /* [out] */ UINT __RPC_FAR *puCodePageOut,
            /* [size_is][out] */ CHAR __RPC_FAR *pszDest,
            /* [in] */ long cchDest,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStrBufA( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ UINT __RPC_FAR *puDestCodePage,
            /* [out] */ IMLangStringBufA __RPC_FAR *__RPC_FAR *ppDestBuf,
            /* [out] */ long __RPC_FAR *plDestLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LockAStr( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ long lFlags,
            /* [in] */ UINT uCodePageIn,
            /* [in] */ long cchRequest,
            /* [out] */ UINT __RPC_FAR *puCodePageOut,
            /* [size_is][size_is][out] */ CHAR __RPC_FAR *__RPC_FAR *ppszDest,
            /* [out] */ long __RPC_FAR *pcchDest,
            /* [out] */ long __RPC_FAR *plDestLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnlockAStr( 
            /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ LCID locale) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLocale( 
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ LCID __RPC_FAR *plocale,
            /* [out] */ long __RPC_FAR *plLocalePos,
            /* [out] */ long __RPC_FAR *plLocaleLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangStringAStrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangStringAStr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangStringAStr __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sync )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ BOOL fNoAccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMLStr )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ IUnknown __RPC_FAR *pSrcMLStr,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMLStr )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ const IID __RPC_FAR *piid,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDestMLStr,
            /* [out] */ long __RPC_FAR *plDestPos,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAStr )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ UINT uCodePage,
            /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStrBufA )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ UINT uCodePage,
            /* [in] */ IMLangStringBufA __RPC_FAR *pSrcBuf,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAStr )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ UINT uCodePageIn,
            /* [out] */ UINT __RPC_FAR *puCodePageOut,
            /* [size_is][out] */ CHAR __RPC_FAR *pszDest,
            /* [in] */ long cchDest,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrBufA )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ UINT __RPC_FAR *puDestCodePage,
            /* [out] */ IMLangStringBufA __RPC_FAR *__RPC_FAR *ppDestBuf,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockAStr )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ long lFlags,
            /* [in] */ UINT uCodePageIn,
            /* [in] */ long cchRequest,
            /* [out] */ UINT __RPC_FAR *puCodePageOut,
            /* [size_is][size_is][out] */ CHAR __RPC_FAR *__RPC_FAR *ppszDest,
            /* [out] */ long __RPC_FAR *pcchDest,
            /* [out] */ long __RPC_FAR *plDestLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockAStr )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [out] */ long __RPC_FAR *pcchActual,
            /* [out] */ long __RPC_FAR *plActualLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocale )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lDestPos,
            /* [in] */ long lDestLen,
            /* [in] */ LCID locale);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocale )( 
            IMLangStringAStr __RPC_FAR * This,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcMaxLen,
            /* [out] */ LCID __RPC_FAR *plocale,
            /* [out] */ long __RPC_FAR *plLocalePos,
            /* [out] */ long __RPC_FAR *plLocaleLen);
        
        END_INTERFACE
    } IMLangStringAStrVtbl;

    interface IMLangStringAStr
    {
        CONST_VTBL struct IMLangStringAStrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangStringAStr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangStringAStr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangStringAStr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangStringAStr_Sync(This,fNoAccess)	\
    (This)->lpVtbl -> Sync(This,fNoAccess)

#define IMLangStringAStr_GetLength(This,plLen)	\
    (This)->lpVtbl -> GetLength(This,plLen)

#define IMLangStringAStr_SetMLStr(This,lDestPos,lDestLen,pSrcMLStr,lSrcPos,lSrcLen)	\
    (This)->lpVtbl -> SetMLStr(This,lDestPos,lDestLen,pSrcMLStr,lSrcPos,lSrcLen)

#define IMLangStringAStr_GetMLStr(This,lSrcPos,lSrcLen,pUnkOuter,dwClsContext,piid,ppDestMLStr,plDestPos,plDestLen)	\
    (This)->lpVtbl -> GetMLStr(This,lSrcPos,lSrcLen,pUnkOuter,dwClsContext,piid,ppDestMLStr,plDestPos,plDestLen)


#define IMLangStringAStr_SetAStr(This,lDestPos,lDestLen,uCodePage,pszSrc,cchSrc,pcchActual,plActualLen)	\
    (This)->lpVtbl -> SetAStr(This,lDestPos,lDestLen,uCodePage,pszSrc,cchSrc,pcchActual,plActualLen)

#define IMLangStringAStr_SetStrBufA(This,lDestPos,lDestLen,uCodePage,pSrcBuf,pcchActual,plActualLen)	\
    (This)->lpVtbl -> SetStrBufA(This,lDestPos,lDestLen,uCodePage,pSrcBuf,pcchActual,plActualLen)

#define IMLangStringAStr_GetAStr(This,lSrcPos,lSrcLen,uCodePageIn,puCodePageOut,pszDest,cchDest,pcchActual,plActualLen)	\
    (This)->lpVtbl -> GetAStr(This,lSrcPos,lSrcLen,uCodePageIn,puCodePageOut,pszDest,cchDest,pcchActual,plActualLen)

#define IMLangStringAStr_GetStrBufA(This,lSrcPos,lSrcMaxLen,puDestCodePage,ppDestBuf,plDestLen)	\
    (This)->lpVtbl -> GetStrBufA(This,lSrcPos,lSrcMaxLen,puDestCodePage,ppDestBuf,plDestLen)

#define IMLangStringAStr_LockAStr(This,lSrcPos,lSrcLen,lFlags,uCodePageIn,cchRequest,puCodePageOut,ppszDest,pcchDest,plDestLen)	\
    (This)->lpVtbl -> LockAStr(This,lSrcPos,lSrcLen,lFlags,uCodePageIn,cchRequest,puCodePageOut,ppszDest,pcchDest,plDestLen)

#define IMLangStringAStr_UnlockAStr(This,pszSrc,cchSrc,pcchActual,plActualLen)	\
    (This)->lpVtbl -> UnlockAStr(This,pszSrc,cchSrc,pcchActual,plActualLen)

#define IMLangStringAStr_SetLocale(This,lDestPos,lDestLen,locale)	\
    (This)->lpVtbl -> SetLocale(This,lDestPos,lDestLen,locale)

#define IMLangStringAStr_GetLocale(This,lSrcPos,lSrcMaxLen,plocale,plLocalePos,plLocaleLen)	\
    (This)->lpVtbl -> GetLocale(This,lSrcPos,lSrcMaxLen,plocale,plLocalePos,plLocaleLen)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_SetAStr_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [in] */ UINT uCodePage,
    /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringAStr_SetAStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_SetStrBufA_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [in] */ UINT uCodePage,
    /* [in] */ IMLangStringBufA __RPC_FAR *pSrcBuf,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringAStr_SetStrBufA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_GetAStr_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen,
    /* [in] */ UINT uCodePageIn,
    /* [out] */ UINT __RPC_FAR *puCodePageOut,
    /* [size_is][out] */ CHAR __RPC_FAR *pszDest,
    /* [in] */ long cchDest,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringAStr_GetAStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_GetStrBufA_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcMaxLen,
    /* [out] */ UINT __RPC_FAR *puDestCodePage,
    /* [out] */ IMLangStringBufA __RPC_FAR *__RPC_FAR *ppDestBuf,
    /* [out] */ long __RPC_FAR *plDestLen);


void __RPC_STUB IMLangStringAStr_GetStrBufA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_LockAStr_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen,
    /* [in] */ long lFlags,
    /* [in] */ UINT uCodePageIn,
    /* [in] */ long cchRequest,
    /* [out] */ UINT __RPC_FAR *puCodePageOut,
    /* [size_is][size_is][out] */ CHAR __RPC_FAR *__RPC_FAR *ppszDest,
    /* [out] */ long __RPC_FAR *pcchDest,
    /* [out] */ long __RPC_FAR *plDestLen);


void __RPC_STUB IMLangStringAStr_LockAStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_UnlockAStr_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [out] */ long __RPC_FAR *pcchActual,
    /* [out] */ long __RPC_FAR *plActualLen);


void __RPC_STUB IMLangStringAStr_UnlockAStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_SetLocale_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lDestPos,
    /* [in] */ long lDestLen,
    /* [in] */ LCID locale);


void __RPC_STUB IMLangStringAStr_SetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangStringAStr_GetLocale_Proxy( 
    IMLangStringAStr __RPC_FAR * This,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcMaxLen,
    /* [out] */ LCID __RPC_FAR *plocale,
    /* [out] */ long __RPC_FAR *plLocalePos,
    /* [out] */ long __RPC_FAR *plLocaleLen);


void __RPC_STUB IMLangStringAStr_GetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangStringAStr_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CMLangString;

#ifdef __cplusplus

class DECLSPEC_UUID("C04D65CF-B70D-11D0-B188-00AA0038C969")
CMLangString;
#endif

#ifndef __IMLangLineBreakConsole_INTERFACE_DEFINED__
#define __IMLangLineBreakConsole_INTERFACE_DEFINED__

/* interface IMLangLineBreakConsole */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMLangLineBreakConsole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5BE2EE1-BFD7-11D0-B188-00AA0038C969")
    IMLangLineBreakConsole : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakLineML( 
            /* [in] */ IMLangString __RPC_FAR *pSrcMLStr,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ long cMinColumns,
            /* [in] */ long cMaxColumns,
            /* [out] */ long __RPC_FAR *plLineLen,
            /* [out] */ long __RPC_FAR *plSkipLen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakLineW( 
            /* [in] */ LCID locale,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ long cMaxColumns,
            /* [out] */ long __RPC_FAR *pcchLine,
            /* [out] */ long __RPC_FAR *pcchSkip) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakLineA( 
            /* [in] */ LCID locale,
            /* [in] */ UINT uCodePage,
            /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ long cMaxColumns,
            /* [out] */ long __RPC_FAR *pcchLine,
            /* [out] */ long __RPC_FAR *pcchSkip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangLineBreakConsoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangLineBreakConsole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangLineBreakConsole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangLineBreakConsole __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BreakLineML )( 
            IMLangLineBreakConsole __RPC_FAR * This,
            /* [in] */ IMLangString __RPC_FAR *pSrcMLStr,
            /* [in] */ long lSrcPos,
            /* [in] */ long lSrcLen,
            /* [in] */ long cMinColumns,
            /* [in] */ long cMaxColumns,
            /* [out] */ long __RPC_FAR *plLineLen,
            /* [out] */ long __RPC_FAR *plSkipLen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BreakLineW )( 
            IMLangLineBreakConsole __RPC_FAR * This,
            /* [in] */ LCID locale,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ long cMaxColumns,
            /* [out] */ long __RPC_FAR *pcchLine,
            /* [out] */ long __RPC_FAR *pcchSkip);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BreakLineA )( 
            IMLangLineBreakConsole __RPC_FAR * This,
            /* [in] */ LCID locale,
            /* [in] */ UINT uCodePage,
            /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ long cMaxColumns,
            /* [out] */ long __RPC_FAR *pcchLine,
            /* [out] */ long __RPC_FAR *pcchSkip);
        
        END_INTERFACE
    } IMLangLineBreakConsoleVtbl;

    interface IMLangLineBreakConsole
    {
        CONST_VTBL struct IMLangLineBreakConsoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangLineBreakConsole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangLineBreakConsole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangLineBreakConsole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangLineBreakConsole_BreakLineML(This,pSrcMLStr,lSrcPos,lSrcLen,cMinColumns,cMaxColumns,plLineLen,plSkipLen)	\
    (This)->lpVtbl -> BreakLineML(This,pSrcMLStr,lSrcPos,lSrcLen,cMinColumns,cMaxColumns,plLineLen,plSkipLen)

#define IMLangLineBreakConsole_BreakLineW(This,locale,pszSrc,cchSrc,cMaxColumns,pcchLine,pcchSkip)	\
    (This)->lpVtbl -> BreakLineW(This,locale,pszSrc,cchSrc,cMaxColumns,pcchLine,pcchSkip)

#define IMLangLineBreakConsole_BreakLineA(This,locale,uCodePage,pszSrc,cchSrc,cMaxColumns,pcchLine,pcchSkip)	\
    (This)->lpVtbl -> BreakLineA(This,locale,uCodePage,pszSrc,cchSrc,cMaxColumns,pcchLine,pcchSkip)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangLineBreakConsole_BreakLineML_Proxy( 
    IMLangLineBreakConsole __RPC_FAR * This,
    /* [in] */ IMLangString __RPC_FAR *pSrcMLStr,
    /* [in] */ long lSrcPos,
    /* [in] */ long lSrcLen,
    /* [in] */ long cMinColumns,
    /* [in] */ long cMaxColumns,
    /* [out] */ long __RPC_FAR *plLineLen,
    /* [out] */ long __RPC_FAR *plSkipLen);


void __RPC_STUB IMLangLineBreakConsole_BreakLineML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangLineBreakConsole_BreakLineW_Proxy( 
    IMLangLineBreakConsole __RPC_FAR * This,
    /* [in] */ LCID locale,
    /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [in] */ long cMaxColumns,
    /* [out] */ long __RPC_FAR *pcchLine,
    /* [out] */ long __RPC_FAR *pcchSkip);


void __RPC_STUB IMLangLineBreakConsole_BreakLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangLineBreakConsole_BreakLineA_Proxy( 
    IMLangLineBreakConsole __RPC_FAR * This,
    /* [in] */ LCID locale,
    /* [in] */ UINT uCodePage,
    /* [size_is][in] */ const CHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [in] */ long cMaxColumns,
    /* [out] */ long __RPC_FAR *pcchLine,
    /* [out] */ long __RPC_FAR *pcchSkip);


void __RPC_STUB IMLangLineBreakConsole_BreakLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangLineBreakConsole_INTERFACE_DEFINED__ */


#ifndef __IEnumCodePage_INTERFACE_DEFINED__
#define __IEnumCodePage_INTERFACE_DEFINED__

/* interface IEnumCodePage */
/* [unique][uuid][object] */ 

#define	MAX_MIMECP_NAME	( 64 )

#define	MAX_MIMECSET_NAME	( 50 )

#define	MAX_MIMEFACE_NAME	( 32 )

typedef 
enum tagMIMECONTF
    {	MIMECONTF_MAILNEWS	= 0x1,
	MIMECONTF_BROWSER	= 0x2,
	MIMECONTF_MINIMAL	= 0x4,
	MIMECONTF_IMPORT	= 0x8,
	MIMECONTF_SAVABLE_MAILNEWS	= 0x100,
	MIMECONTF_SAVABLE_BROWSER	= 0x200,
	MIMECONTF_EXPORT	= 0x400,
	MIMECONTF_PRIVCONVERTER	= 0x10000,
	MIMECONTF_VALID	= 0x20000,
	MIMECONTF_VALID_NLS	= 0x40000,
	MIMECONTF_MIME_IE4	= 0x10000000,
	MIMECONTF_MIME_LATEST	= 0x20000000,
	MIMECONTF_MIME_REGISTRY	= 0x40000000
    }	MIMECONTF;

typedef struct tagMIMECPINFO
    {
    DWORD dwFlags;
    UINT uiCodePage;
    UINT uiFamilyCodePage;
    WCHAR wszDescription[ 64 ];
    WCHAR wszWebCharset[ 50 ];
    WCHAR wszHeaderCharset[ 50 ];
    WCHAR wszBodyCharset[ 50 ];
    WCHAR wszFixedWidthFont[ 32 ];
    WCHAR wszProportionalFont[ 32 ];
    BYTE bGDICharset;
    }	MIMECPINFO;

typedef struct tagMIMECPINFO __RPC_FAR *PMIMECPINFO;

typedef struct tagMIMECSETINFO
    {
    UINT uiCodePage;
    UINT uiInternetEncoding;
    WCHAR wszCharset[ 50 ];
    }	MIMECSETINFO;

typedef struct tagMIMECSETINFO __RPC_FAR *PMIMECSETINFO;

typedef /* [unique] */ IEnumCodePage __RPC_FAR *LPENUMCODEPAGE;


EXTERN_C const IID IID_IEnumCodePage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("275c23e3-3747-11d0-9fea-00aa003f8646")
    IEnumCodePage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ PMIMECPINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCodePageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCodePage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCodePage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCodePage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCodePage __RPC_FAR * This,
            /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCodePage __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ PMIMECPINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCodePage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCodePage __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        END_INTERFACE
    } IEnumCodePageVtbl;

    interface IEnumCodePage
    {
        CONST_VTBL struct IEnumCodePageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCodePage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCodePage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCodePage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCodePage_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumCodePage_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCodePage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCodePage_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCodePage_Clone_Proxy( 
    IEnumCodePage __RPC_FAR * This,
    /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumCodePage_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePage_Next_Proxy( 
    IEnumCodePage __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ PMIMECPINFO rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCodePage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePage_Reset_Proxy( 
    IEnumCodePage __RPC_FAR * This);


void __RPC_STUB IEnumCodePage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCodePage_Skip_Proxy( 
    IEnumCodePage __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCodePage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCodePage_INTERFACE_DEFINED__ */


#ifndef __IEnumRfc1766_INTERFACE_DEFINED__
#define __IEnumRfc1766_INTERFACE_DEFINED__

/* interface IEnumRfc1766 */
/* [unique][uuid][object] */ 

#define	MAX_RFC1766_NAME	( 6 )

#define	MAX_LOCALE_NAME	( 32 )

typedef struct tagRFC1766INFO
    {
    LCID lcid;
    WCHAR wszRfc1766[ 6 ];
    WCHAR wszLocaleName[ 32 ];
    }	RFC1766INFO;

typedef struct tagRFC1766INFO __RPC_FAR *PRFC1766INFO;

typedef /* [unique] */ IEnumRfc1766 __RPC_FAR *LPENUMRFC1766;


EXTERN_C const IID IID_IEnumRfc1766;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3dc39d1d-c030-11d0-b81b-00c04fc9b31f")
    IEnumRfc1766 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ PRFC1766INFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRfc1766Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRfc1766 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRfc1766 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRfc1766 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRfc1766 __RPC_FAR * This,
            /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRfc1766 __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ PRFC1766INFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRfc1766 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRfc1766 __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        END_INTERFACE
    } IEnumRfc1766Vtbl;

    interface IEnumRfc1766
    {
        CONST_VTBL struct IEnumRfc1766Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRfc1766_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRfc1766_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRfc1766_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRfc1766_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRfc1766_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRfc1766_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRfc1766_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRfc1766_Clone_Proxy( 
    IEnumRfc1766 __RPC_FAR * This,
    /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRfc1766_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRfc1766_Next_Proxy( 
    IEnumRfc1766 __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ PRFC1766INFO rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRfc1766_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRfc1766_Reset_Proxy( 
    IEnumRfc1766 __RPC_FAR * This);


void __RPC_STUB IEnumRfc1766_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRfc1766_Skip_Proxy( 
    IEnumRfc1766 __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRfc1766_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRfc1766_INTERFACE_DEFINED__ */


#ifndef __IEnumScript_INTERFACE_DEFINED__
#define __IEnumScript_INTERFACE_DEFINED__

/* interface IEnumScript */
/* [unique][uuid][object] */ 

#define	MAX_SCRIPT_NAME	( 48 )

typedef BYTE SCRIPT_ID;

typedef __int64 SCRIPT_IDS;

typedef 
enum tagSCRIPTCONTF
    {	sidDefault	= 0,
	sidMerge	= sidDefault + 1,
	sidAsciiSym	= sidMerge + 1,
	sidAsciiLatin	= sidAsciiSym + 1,
	sidLatin	= sidAsciiLatin + 1,
	sidGreek	= sidLatin + 1,
	sidCyrillic	= sidGreek + 1,
	sidArmenian	= sidCyrillic + 1,
	sidHebrew	= sidArmenian + 1,
	sidArabic	= sidHebrew + 1,
	sidDevanagari	= sidArabic + 1,
	sidBengali	= sidDevanagari + 1,
	sidGurmukhi	= sidBengali + 1,
	sidGujarati	= sidGurmukhi + 1,
	sidOriya	= sidGujarati + 1,
	sidTamil	= sidOriya + 1,
	sidTelugu	= sidTamil + 1,
	sidKannada	= sidTelugu + 1,
	sidMalayalam	= sidKannada + 1,
	sidThai	= sidMalayalam + 1,
	sidLao	= sidThai + 1,
	sidTibetan	= sidLao + 1,
	sidGeorgian	= sidTibetan + 1,
	sidHangul	= sidGeorgian + 1,
	sidKana	= sidHangul + 1,
	sidBopomofo	= sidKana + 1,
	sidHan	= sidBopomofo + 1,
	sidEthiopic	= sidHan + 1,
	sidCanSyllabic	= sidEthiopic + 1,
	sidCherokee	= sidCanSyllabic + 1,
	sidYi	= sidCherokee + 1,
	sidBraille	= sidYi + 1,
	sidRunic	= sidBraille + 1,
	sidOgham	= sidRunic + 1,
	sidSinhala	= sidOgham + 1,
	sidSyriac	= sidSinhala + 1,
	sidBurmese	= sidSyriac + 1,
	sidKhmer	= sidBurmese + 1,
	sidThaana	= sidKhmer + 1,
	sidMongolian	= sidThaana + 1,
	sidUserDefined	= sidMongolian + 1,
	sidLim	= sidUserDefined + 1,
	sidFEFirst	= sidHangul,
	sidFELast	= sidHan
    }	SCRIPTCONTF;

typedef struct tagSCRIPTINFO
    {
    SCRIPT_ID ScriptId;
    UINT uiCodePage;
    WCHAR wszDescription[ 48 ];
    WCHAR wszFixedWidthFont[ 32 ];
    WCHAR wszProportionalFont[ 32 ];
    }	SCRIPTINFO;

typedef struct tagSCRIPTINFO __RPC_FAR *PSCRIPTINFO;

typedef /* [unique] */ IEnumScript __RPC_FAR *LPENUMScript;


EXTERN_C const IID IID_IEnumScript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE5F1430-388B-11d2-8380-00C04F8F5DA1")
    IEnumScript : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumScript __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ PSCRIPTINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumScriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumScript __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumScript __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumScript __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumScript __RPC_FAR * This,
            /* [out] */ IEnumScript __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumScript __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ PSCRIPTINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumScript __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumScript __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        END_INTERFACE
    } IEnumScriptVtbl;

    interface IEnumScript
    {
        CONST_VTBL struct IEnumScriptVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumScript_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumScript_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumScript_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumScript_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumScript_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumScript_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumScript_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumScript_Clone_Proxy( 
    IEnumScript __RPC_FAR * This,
    /* [out] */ IEnumScript __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumScript_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumScript_Next_Proxy( 
    IEnumScript __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ PSCRIPTINFO rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumScript_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumScript_Reset_Proxy( 
    IEnumScript __RPC_FAR * This);


void __RPC_STUB IEnumScript_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumScript_Skip_Proxy( 
    IEnumScript __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumScript_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumScript_INTERFACE_DEFINED__ */


#ifndef __IMLangConvertCharset_INTERFACE_DEFINED__
#define __IMLangConvertCharset_INTERFACE_DEFINED__

/* interface IMLangConvertCharset */
/* [unique][uuid][object] */ 

typedef 
enum tagMLCONVCHARF
    {	MLCONVCHARF_AUTODETECT	= 1,
	MLCONVCHARF_ENTITIZE	= 2,
	MLCONVCHARF_NCR_ENTITIZE	= 2,
	MLCONVCHARF_NAME_ENTITIZE	= 4,
	MLCONVCHARF_USEDEFCHAR	= 8,
	MLCONVCHARF_NOBESTFITCHARS	= 16
    }	MLCONVCHAR;

typedef /* [unique] */ IMLangConvertCharset __RPC_FAR *LPMLANGCONVERTCHARSET;


EXTERN_C const IID IID_IMLangConvertCharset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d66d6f98-cdaa-11d0-b822-00c04fc9b31f")
    IMLangConvertCharset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ UINT uiSrcCodePage,
            /* [in] */ UINT uiDstCodePage,
            /* [in] */ DWORD dwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceCodePage( 
            /* [out] */ UINT __RPC_FAR *puiSrcCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationCodePage( 
            /* [out] */ UINT __RPC_FAR *puiDstCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoConversion( 
            /* [in] */ BYTE __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ BYTE __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoConversionToUnicode( 
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoConversionFromUnicode( 
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangConvertCharsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangConvertCharset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangConvertCharset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [in] */ UINT uiSrcCodePage,
            /* [in] */ UINT uiDstCodePage,
            /* [in] */ DWORD dwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceCodePage )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *puiSrcCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDestinationCodePage )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *puiDstCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoConversion )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ BYTE __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoConversionToUnicode )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoConversionFromUnicode )( 
            IMLangConvertCharset __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        END_INTERFACE
    } IMLangConvertCharsetVtbl;

    interface IMLangConvertCharset
    {
        CONST_VTBL struct IMLangConvertCharsetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangConvertCharset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangConvertCharset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangConvertCharset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangConvertCharset_Initialize(This,uiSrcCodePage,uiDstCodePage,dwProperty)	\
    (This)->lpVtbl -> Initialize(This,uiSrcCodePage,uiDstCodePage,dwProperty)

#define IMLangConvertCharset_GetSourceCodePage(This,puiSrcCodePage)	\
    (This)->lpVtbl -> GetSourceCodePage(This,puiSrcCodePage)

#define IMLangConvertCharset_GetDestinationCodePage(This,puiDstCodePage)	\
    (This)->lpVtbl -> GetDestinationCodePage(This,puiDstCodePage)

#define IMLangConvertCharset_GetProperty(This,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,pdwProperty)

#define IMLangConvertCharset_DoConversion(This,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> DoConversion(This,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMLangConvertCharset_DoConversionToUnicode(This,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> DoConversionToUnicode(This,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMLangConvertCharset_DoConversionFromUnicode(This,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> DoConversionFromUnicode(This,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMLangConvertCharset_Initialize_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [in] */ UINT uiSrcCodePage,
    /* [in] */ UINT uiDstCodePage,
    /* [in] */ DWORD dwProperty);


void __RPC_STUB IMLangConvertCharset_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMLangConvertCharset_GetSourceCodePage_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *puiSrcCodePage);


void __RPC_STUB IMLangConvertCharset_GetSourceCodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMLangConvertCharset_GetDestinationCodePage_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *puiDstCodePage);


void __RPC_STUB IMLangConvertCharset_GetDestinationCodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMLangConvertCharset_GetProperty_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IMLangConvertCharset_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMLangConvertCharset_DoConversion_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ BYTE __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMLangConvertCharset_DoConversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMLangConvertCharset_DoConversionToUnicode_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [in] */ CHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ WCHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMLangConvertCharset_DoConversionToUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMLangConvertCharset_DoConversionFromUnicode_Proxy( 
    IMLangConvertCharset __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ CHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMLangConvertCharset_DoConversionFromUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangConvertCharset_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CMLangConvertCharset;

#ifdef __cplusplus

class DECLSPEC_UUID("d66d6f99-cdaa-11d0-b822-00c04fc9b31f")
CMLangConvertCharset;
#endif

#ifndef __IMultiLanguage_INTERFACE_DEFINED__
#define __IMultiLanguage_INTERFACE_DEFINED__

/* interface IMultiLanguage */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IMultiLanguage __RPC_FAR *LPMULTILANGUAGE;


EXTERN_C const IID IID_IMultiLanguage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("275c23e1-3747-11d0-9fea-00aa003f8646")
    IMultiLanguage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfCodePageInfo( 
            /* [out] */ UINT __RPC_FAR *pcCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageInfo( 
            /* [in] */ UINT uiCodePage,
            /* [out] */ PMIMECPINFO pCodePageInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFamilyCodePage( 
            /* [in] */ UINT uiCodePage,
            /* [out] */ UINT __RPC_FAR *puiFamilyCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodePages( 
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnumCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCharsetInfo( 
            /* [in] */ BSTR Charset,
            /* [out] */ PMIMECSETINFO pCharsetInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsConvertible( 
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertString( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding,
            /* [in] */ BYTE __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ BYTE __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringToUnicode( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringFromUnicode( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringReset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRfc1766FromLcid( 
            /* [in] */ LCID Locale,
            /* [out] */ BSTR __RPC_FAR *pbstrRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLcidFromRfc1766( 
            /* [out] */ LCID __RPC_FAR *pLocale,
            /* [in] */ BSTR bstrRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRfc1766( 
            /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnumRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRfc1766Info( 
            /* [in] */ LCID Locale,
            /* [out] */ PRFC1766INFO pRfc1766Info) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateConvertCharset( 
            /* [in] */ UINT uiSrcCodePage,
            /* [in] */ UINT uiDstCodePage,
            /* [in] */ DWORD dwProperty,
            /* [out] */ IMLangConvertCharset __RPC_FAR *__RPC_FAR *ppMLangConvertCharset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultiLanguageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMultiLanguage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMultiLanguage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfCodePageInfo )( 
            IMultiLanguage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pcCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageInfo )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [out] */ PMIMECPINFO pCodePageInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFamilyCodePage )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [out] */ UINT __RPC_FAR *puiFamilyCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCodePages )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnumCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharsetInfo )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ BSTR Charset,
            /* [out] */ PMIMECSETINFO pCharsetInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsConvertible )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertString )( 
            IMultiLanguage __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding,
            /* [in] */ BYTE __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ BYTE __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringToUnicode )( 
            IMultiLanguage __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringFromUnicode )( 
            IMultiLanguage __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringReset )( 
            IMultiLanguage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRfc1766FromLcid )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ LCID Locale,
            /* [out] */ BSTR __RPC_FAR *pbstrRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLcidFromRfc1766 )( 
            IMultiLanguage __RPC_FAR * This,
            /* [out] */ LCID __RPC_FAR *pLocale,
            /* [in] */ BSTR bstrRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRfc1766 )( 
            IMultiLanguage __RPC_FAR * This,
            /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnumRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRfc1766Info )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ LCID Locale,
            /* [out] */ PRFC1766INFO pRfc1766Info);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateConvertCharset )( 
            IMultiLanguage __RPC_FAR * This,
            /* [in] */ UINT uiSrcCodePage,
            /* [in] */ UINT uiDstCodePage,
            /* [in] */ DWORD dwProperty,
            /* [out] */ IMLangConvertCharset __RPC_FAR *__RPC_FAR *ppMLangConvertCharset);
        
        END_INTERFACE
    } IMultiLanguageVtbl;

    interface IMultiLanguage
    {
        CONST_VTBL struct IMultiLanguageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultiLanguage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultiLanguage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultiLanguage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultiLanguage_GetNumberOfCodePageInfo(This,pcCodePage)	\
    (This)->lpVtbl -> GetNumberOfCodePageInfo(This,pcCodePage)

#define IMultiLanguage_GetCodePageInfo(This,uiCodePage,pCodePageInfo)	\
    (This)->lpVtbl -> GetCodePageInfo(This,uiCodePage,pCodePageInfo)

#define IMultiLanguage_GetFamilyCodePage(This,uiCodePage,puiFamilyCodePage)	\
    (This)->lpVtbl -> GetFamilyCodePage(This,uiCodePage,puiFamilyCodePage)

#define IMultiLanguage_EnumCodePages(This,grfFlags,ppEnumCodePage)	\
    (This)->lpVtbl -> EnumCodePages(This,grfFlags,ppEnumCodePage)

#define IMultiLanguage_GetCharsetInfo(This,Charset,pCharsetInfo)	\
    (This)->lpVtbl -> GetCharsetInfo(This,Charset,pCharsetInfo)

#define IMultiLanguage_IsConvertible(This,dwSrcEncoding,dwDstEncoding)	\
    (This)->lpVtbl -> IsConvertible(This,dwSrcEncoding,dwDstEncoding)

#define IMultiLanguage_ConvertString(This,pdwMode,dwSrcEncoding,dwDstEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> ConvertString(This,pdwMode,dwSrcEncoding,dwDstEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMultiLanguage_ConvertStringToUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> ConvertStringToUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMultiLanguage_ConvertStringFromUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> ConvertStringFromUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMultiLanguage_ConvertStringReset(This)	\
    (This)->lpVtbl -> ConvertStringReset(This)

#define IMultiLanguage_GetRfc1766FromLcid(This,Locale,pbstrRfc1766)	\
    (This)->lpVtbl -> GetRfc1766FromLcid(This,Locale,pbstrRfc1766)

#define IMultiLanguage_GetLcidFromRfc1766(This,pLocale,bstrRfc1766)	\
    (This)->lpVtbl -> GetLcidFromRfc1766(This,pLocale,bstrRfc1766)

#define IMultiLanguage_EnumRfc1766(This,ppEnumRfc1766)	\
    (This)->lpVtbl -> EnumRfc1766(This,ppEnumRfc1766)

#define IMultiLanguage_GetRfc1766Info(This,Locale,pRfc1766Info)	\
    (This)->lpVtbl -> GetRfc1766Info(This,Locale,pRfc1766Info)

#define IMultiLanguage_CreateConvertCharset(This,uiSrcCodePage,uiDstCodePage,dwProperty,ppMLangConvertCharset)	\
    (This)->lpVtbl -> CreateConvertCharset(This,uiSrcCodePage,uiDstCodePage,dwProperty,ppMLangConvertCharset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMultiLanguage_GetNumberOfCodePageInfo_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pcCodePage);


void __RPC_STUB IMultiLanguage_GetNumberOfCodePageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_GetCodePageInfo_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [out] */ PMIMECPINFO pCodePageInfo);


void __RPC_STUB IMultiLanguage_GetCodePageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_GetFamilyCodePage_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [out] */ UINT __RPC_FAR *puiFamilyCodePage);


void __RPC_STUB IMultiLanguage_GetFamilyCodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_EnumCodePages_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnumCodePage);


void __RPC_STUB IMultiLanguage_EnumCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_GetCharsetInfo_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ BSTR Charset,
    /* [out] */ PMIMECSETINFO pCharsetInfo);


void __RPC_STUB IMultiLanguage_GetCharsetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_IsConvertible_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ DWORD dwSrcEncoding,
    /* [in] */ DWORD dwDstEncoding);


void __RPC_STUB IMultiLanguage_IsConvertible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_ConvertString_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwSrcEncoding,
    /* [in] */ DWORD dwDstEncoding,
    /* [in] */ BYTE __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ BYTE __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMultiLanguage_ConvertString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_ConvertStringToUnicode_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwEncoding,
    /* [in] */ CHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ WCHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMultiLanguage_ConvertStringToUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_ConvertStringFromUnicode_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwEncoding,
    /* [in] */ WCHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ CHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMultiLanguage_ConvertStringFromUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_ConvertStringReset_Proxy( 
    IMultiLanguage __RPC_FAR * This);


void __RPC_STUB IMultiLanguage_ConvertStringReset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_GetRfc1766FromLcid_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ LCID Locale,
    /* [out] */ BSTR __RPC_FAR *pbstrRfc1766);


void __RPC_STUB IMultiLanguage_GetRfc1766FromLcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_GetLcidFromRfc1766_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [out] */ LCID __RPC_FAR *pLocale,
    /* [in] */ BSTR bstrRfc1766);


void __RPC_STUB IMultiLanguage_GetLcidFromRfc1766_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_EnumRfc1766_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnumRfc1766);


void __RPC_STUB IMultiLanguage_EnumRfc1766_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_GetRfc1766Info_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ LCID Locale,
    /* [out] */ PRFC1766INFO pRfc1766Info);


void __RPC_STUB IMultiLanguage_GetRfc1766Info_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage_CreateConvertCharset_Proxy( 
    IMultiLanguage __RPC_FAR * This,
    /* [in] */ UINT uiSrcCodePage,
    /* [in] */ UINT uiDstCodePage,
    /* [in] */ DWORD dwProperty,
    /* [out] */ IMLangConvertCharset __RPC_FAR *__RPC_FAR *ppMLangConvertCharset);


void __RPC_STUB IMultiLanguage_CreateConvertCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMultiLanguage_INTERFACE_DEFINED__ */


#ifndef __IMultiLanguage2_INTERFACE_DEFINED__
#define __IMultiLanguage2_INTERFACE_DEFINED__

/* interface IMultiLanguage2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IMultiLanguage2 __RPC_FAR *LPMULTILANGUAGE2;

typedef 
enum tagMLDETECTCP
    {	MLDETECTCP_NONE	= 0,
	MLDETECTCP_7BIT	= 1,
	MLDETECTCP_8BIT	= 2,
	MLDETECTCP_DBCS	= 4,
	MLDETECTCP_HTML	= 8,
	MLDETECTCP_NUMBER	= 16
    }	MLDETECTCP;

typedef struct tagDetectEncodingInfo
    {
    UINT nLangID;
    UINT nCodePage;
    INT nDocPercent;
    INT nConfidence;
    }	DetectEncodingInfo;

typedef struct tagDetectEncodingInfo __RPC_FAR *pDetectEncodingInfo;

typedef 
enum tagSCRIPTFONTCONTF
    {	SCRIPTCONTF_FIXED_FONT	= 0x1,
	SCRIPTCONTF_PROPORTIONAL_FONT	= 0x2,
	SCRIPTCONTF_SCRIPT_USER	= 0x10000,
	SCRIPTCONTF_SCRIPT_HIDE	= 0x20000,
	SCRIPTCONTF_SCRIPT_SYSTEM	= 0x40000
    }	SCRIPTFONTCONTF;

typedef struct tagSCRIPFONTINFO
    {
    SCRIPT_IDS scripts;
    WCHAR wszFont[ 32 ];
    }	SCRIPTFONTINFO;

typedef struct tagSCRIPFONTINFO __RPC_FAR *PSCRIPTFONTINFO;


EXTERN_C const IID IID_IMultiLanguage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCCFC164-2B38-11d2-B7EC-00C04F8F5D9A")
    IMultiLanguage2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfCodePageInfo( 
            /* [out] */ UINT __RPC_FAR *pcCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageInfo( 
            /* [in] */ UINT uiCodePage,
            /* [in] */ LANGID LangId,
            /* [out] */ PMIMECPINFO pCodePageInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFamilyCodePage( 
            /* [in] */ UINT uiCodePage,
            /* [out] */ UINT __RPC_FAR *puiFamilyCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodePages( 
            /* [in] */ DWORD grfFlags,
            /* [in] */ LANGID LangId,
            /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnumCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCharsetInfo( 
            /* [in] */ BSTR Charset,
            /* [out] */ PMIMECSETINFO pCharsetInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsConvertible( 
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertString( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding,
            /* [in] */ BYTE __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ BYTE __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringToUnicode( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringFromUnicode( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringReset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRfc1766FromLcid( 
            /* [in] */ LCID Locale,
            /* [out] */ BSTR __RPC_FAR *pbstrRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLcidFromRfc1766( 
            /* [out] */ LCID __RPC_FAR *pLocale,
            /* [in] */ BSTR bstrRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRfc1766( 
            /* [in] */ LANGID LangId,
            /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnumRfc1766) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRfc1766Info( 
            /* [in] */ LCID Locale,
            /* [in] */ LANGID LangId,
            /* [out] */ PRFC1766INFO pRfc1766Info) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateConvertCharset( 
            /* [in] */ UINT uiSrcCodePage,
            /* [in] */ UINT uiDstCodePage,
            /* [in] */ DWORD dwProperty,
            /* [out] */ IMLangConvertCharset __RPC_FAR *__RPC_FAR *ppMLangConvertCharset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringInIStream( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwFlag,
            /* [in] */ WCHAR __RPC_FAR *lpFallBack,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding,
            /* [in] */ IStream __RPC_FAR *pstmIn,
            /* [in] */ IStream __RPC_FAR *pstmOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringToUnicodeEx( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize,
            /* [in] */ DWORD dwFlag,
            /* [in] */ WCHAR __RPC_FAR *lpFallBack) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertStringFromUnicodeEx( 
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize,
            /* [in] */ DWORD dwFlag,
            /* [in] */ WCHAR __RPC_FAR *lpFallBack) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetectCodepageInIStream( 
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwPrefWinCodePage,
            /* [in] */ IStream __RPC_FAR *pstmIn,
            /* [out][in] */ DetectEncodingInfo __RPC_FAR *lpEncoding,
            /* [out][in] */ INT __RPC_FAR *pnScores) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetectInputCodepage( 
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwPrefWinCodePage,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ INT __RPC_FAR *pcSrcSize,
            /* [out][in] */ DetectEncodingInfo __RPC_FAR *lpEncoding,
            /* [out][in] */ INT __RPC_FAR *pnScores) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateCodePage( 
            /* [in] */ UINT uiCodePage,
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageDescription( 
            /* [in] */ UINT uiCodePage,
            /* [in] */ LCID lcid,
            /* [out][in] */ LPWSTR lpWideCharStr,
            /* [in] */ int cchWideChar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCodePageInstallable( 
            /* [in] */ UINT uiCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMimeDBSource( 
            /* [in] */ MIMECONTF dwSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfScripts( 
            /* [out] */ UINT __RPC_FAR *pnScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumScripts( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LANGID LangId,
            /* [out] */ IEnumScript __RPC_FAR *__RPC_FAR *ppEnumScript) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateCodePageEx( 
            /* [in] */ UINT uiCodePage,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwfIODControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultiLanguage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMultiLanguage2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMultiLanguage2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfCodePageInfo )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pcCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageInfo )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [in] */ LANGID LangId,
            /* [out] */ PMIMECPINFO pCodePageInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFamilyCodePage )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [out] */ UINT __RPC_FAR *puiFamilyCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCodePages )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [in] */ LANGID LangId,
            /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnumCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharsetInfo )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ BSTR Charset,
            /* [out] */ PMIMECSETINFO pCharsetInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsConvertible )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertString )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding,
            /* [in] */ BYTE __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ BYTE __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringToUnicode )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringFromUnicode )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringReset )( 
            IMultiLanguage2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRfc1766FromLcid )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ LCID Locale,
            /* [out] */ BSTR __RPC_FAR *pbstrRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLcidFromRfc1766 )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out] */ LCID __RPC_FAR *pLocale,
            /* [in] */ BSTR bstrRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRfc1766 )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ LANGID LangId,
            /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnumRfc1766);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRfc1766Info )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ LCID Locale,
            /* [in] */ LANGID LangId,
            /* [out] */ PRFC1766INFO pRfc1766Info);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateConvertCharset )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiSrcCodePage,
            /* [in] */ UINT uiDstCodePage,
            /* [in] */ DWORD dwProperty,
            /* [out] */ IMLangConvertCharset __RPC_FAR *__RPC_FAR *ppMLangConvertCharset);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringInIStream )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwFlag,
            /* [in] */ WCHAR __RPC_FAR *lpFallBack,
            /* [in] */ DWORD dwSrcEncoding,
            /* [in] */ DWORD dwDstEncoding,
            /* [in] */ IStream __RPC_FAR *pstmIn,
            /* [in] */ IStream __RPC_FAR *pstmOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringToUnicodeEx )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ WCHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize,
            /* [in] */ DWORD dwFlag,
            /* [in] */ WCHAR __RPC_FAR *lpFallBack);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertStringFromUnicodeEx )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwMode,
            /* [in] */ DWORD dwEncoding,
            /* [in] */ WCHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
            /* [in] */ CHAR __RPC_FAR *pDstStr,
            /* [out][in] */ UINT __RPC_FAR *pcDstSize,
            /* [in] */ DWORD dwFlag,
            /* [in] */ WCHAR __RPC_FAR *lpFallBack);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetectCodepageInIStream )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwPrefWinCodePage,
            /* [in] */ IStream __RPC_FAR *pstmIn,
            /* [out][in] */ DetectEncodingInfo __RPC_FAR *lpEncoding,
            /* [out][in] */ INT __RPC_FAR *pnScores);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetectInputCodepage )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwPrefWinCodePage,
            /* [in] */ CHAR __RPC_FAR *pSrcStr,
            /* [out][in] */ INT __RPC_FAR *pcSrcSize,
            /* [out][in] */ DetectEncodingInfo __RPC_FAR *lpEncoding,
            /* [out][in] */ INT __RPC_FAR *pnScores);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateCodePage )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageDescription )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [in] */ LCID lcid,
            /* [out][in] */ LPWSTR lpWideCharStr,
            /* [in] */ int cchWideChar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsCodePageInstallable )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMimeDBSource )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ MIMECONTF dwSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfScripts )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pnScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumScripts )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LANGID LangId,
            /* [out] */ IEnumScript __RPC_FAR *__RPC_FAR *ppEnumScript);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateCodePageEx )( 
            IMultiLanguage2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwfIODControl);
        
        END_INTERFACE
    } IMultiLanguage2Vtbl;

    interface IMultiLanguage2
    {
        CONST_VTBL struct IMultiLanguage2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultiLanguage2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultiLanguage2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultiLanguage2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultiLanguage2_GetNumberOfCodePageInfo(This,pcCodePage)	\
    (This)->lpVtbl -> GetNumberOfCodePageInfo(This,pcCodePage)

#define IMultiLanguage2_GetCodePageInfo(This,uiCodePage,LangId,pCodePageInfo)	\
    (This)->lpVtbl -> GetCodePageInfo(This,uiCodePage,LangId,pCodePageInfo)

#define IMultiLanguage2_GetFamilyCodePage(This,uiCodePage,puiFamilyCodePage)	\
    (This)->lpVtbl -> GetFamilyCodePage(This,uiCodePage,puiFamilyCodePage)

#define IMultiLanguage2_EnumCodePages(This,grfFlags,LangId,ppEnumCodePage)	\
    (This)->lpVtbl -> EnumCodePages(This,grfFlags,LangId,ppEnumCodePage)

#define IMultiLanguage2_GetCharsetInfo(This,Charset,pCharsetInfo)	\
    (This)->lpVtbl -> GetCharsetInfo(This,Charset,pCharsetInfo)

#define IMultiLanguage2_IsConvertible(This,dwSrcEncoding,dwDstEncoding)	\
    (This)->lpVtbl -> IsConvertible(This,dwSrcEncoding,dwDstEncoding)

#define IMultiLanguage2_ConvertString(This,pdwMode,dwSrcEncoding,dwDstEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> ConvertString(This,pdwMode,dwSrcEncoding,dwDstEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMultiLanguage2_ConvertStringToUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> ConvertStringToUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMultiLanguage2_ConvertStringFromUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)	\
    (This)->lpVtbl -> ConvertStringFromUnicode(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize)

#define IMultiLanguage2_ConvertStringReset(This)	\
    (This)->lpVtbl -> ConvertStringReset(This)

#define IMultiLanguage2_GetRfc1766FromLcid(This,Locale,pbstrRfc1766)	\
    (This)->lpVtbl -> GetRfc1766FromLcid(This,Locale,pbstrRfc1766)

#define IMultiLanguage2_GetLcidFromRfc1766(This,pLocale,bstrRfc1766)	\
    (This)->lpVtbl -> GetLcidFromRfc1766(This,pLocale,bstrRfc1766)

#define IMultiLanguage2_EnumRfc1766(This,LangId,ppEnumRfc1766)	\
    (This)->lpVtbl -> EnumRfc1766(This,LangId,ppEnumRfc1766)

#define IMultiLanguage2_GetRfc1766Info(This,Locale,LangId,pRfc1766Info)	\
    (This)->lpVtbl -> GetRfc1766Info(This,Locale,LangId,pRfc1766Info)

#define IMultiLanguage2_CreateConvertCharset(This,uiSrcCodePage,uiDstCodePage,dwProperty,ppMLangConvertCharset)	\
    (This)->lpVtbl -> CreateConvertCharset(This,uiSrcCodePage,uiDstCodePage,dwProperty,ppMLangConvertCharset)

#define IMultiLanguage2_ConvertStringInIStream(This,pdwMode,dwFlag,lpFallBack,dwSrcEncoding,dwDstEncoding,pstmIn,pstmOut)	\
    (This)->lpVtbl -> ConvertStringInIStream(This,pdwMode,dwFlag,lpFallBack,dwSrcEncoding,dwDstEncoding,pstmIn,pstmOut)

#define IMultiLanguage2_ConvertStringToUnicodeEx(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize,dwFlag,lpFallBack)	\
    (This)->lpVtbl -> ConvertStringToUnicodeEx(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize,dwFlag,lpFallBack)

#define IMultiLanguage2_ConvertStringFromUnicodeEx(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize,dwFlag,lpFallBack)	\
    (This)->lpVtbl -> ConvertStringFromUnicodeEx(This,pdwMode,dwEncoding,pSrcStr,pcSrcSize,pDstStr,pcDstSize,dwFlag,lpFallBack)

#define IMultiLanguage2_DetectCodepageInIStream(This,dwFlag,dwPrefWinCodePage,pstmIn,lpEncoding,pnScores)	\
    (This)->lpVtbl -> DetectCodepageInIStream(This,dwFlag,dwPrefWinCodePage,pstmIn,lpEncoding,pnScores)

#define IMultiLanguage2_DetectInputCodepage(This,dwFlag,dwPrefWinCodePage,pSrcStr,pcSrcSize,lpEncoding,pnScores)	\
    (This)->lpVtbl -> DetectInputCodepage(This,dwFlag,dwPrefWinCodePage,pSrcStr,pcSrcSize,lpEncoding,pnScores)

#define IMultiLanguage2_ValidateCodePage(This,uiCodePage,hwnd)	\
    (This)->lpVtbl -> ValidateCodePage(This,uiCodePage,hwnd)

#define IMultiLanguage2_GetCodePageDescription(This,uiCodePage,lcid,lpWideCharStr,cchWideChar)	\
    (This)->lpVtbl -> GetCodePageDescription(This,uiCodePage,lcid,lpWideCharStr,cchWideChar)

#define IMultiLanguage2_IsCodePageInstallable(This,uiCodePage)	\
    (This)->lpVtbl -> IsCodePageInstallable(This,uiCodePage)

#define IMultiLanguage2_SetMimeDBSource(This,dwSource)	\
    (This)->lpVtbl -> SetMimeDBSource(This,dwSource)

#define IMultiLanguage2_GetNumberOfScripts(This,pnScripts)	\
    (This)->lpVtbl -> GetNumberOfScripts(This,pnScripts)

#define IMultiLanguage2_EnumScripts(This,dwFlags,LangId,ppEnumScript)	\
    (This)->lpVtbl -> EnumScripts(This,dwFlags,LangId,ppEnumScript)

#define IMultiLanguage2_ValidateCodePageEx(This,uiCodePage,hwnd,dwfIODControl)	\
    (This)->lpVtbl -> ValidateCodePageEx(This,uiCodePage,hwnd,dwfIODControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetNumberOfCodePageInfo_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pcCodePage);


void __RPC_STUB IMultiLanguage2_GetNumberOfCodePageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetCodePageInfo_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [in] */ LANGID LangId,
    /* [out] */ PMIMECPINFO pCodePageInfo);


void __RPC_STUB IMultiLanguage2_GetCodePageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetFamilyCodePage_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [out] */ UINT __RPC_FAR *puiFamilyCodePage);


void __RPC_STUB IMultiLanguage2_GetFamilyCodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_EnumCodePages_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [in] */ LANGID LangId,
    /* [out] */ IEnumCodePage __RPC_FAR *__RPC_FAR *ppEnumCodePage);


void __RPC_STUB IMultiLanguage2_EnumCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetCharsetInfo_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ BSTR Charset,
    /* [out] */ PMIMECSETINFO pCharsetInfo);


void __RPC_STUB IMultiLanguage2_GetCharsetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_IsConvertible_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ DWORD dwSrcEncoding,
    /* [in] */ DWORD dwDstEncoding);


void __RPC_STUB IMultiLanguage2_IsConvertible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertString_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwSrcEncoding,
    /* [in] */ DWORD dwDstEncoding,
    /* [in] */ BYTE __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ BYTE __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMultiLanguage2_ConvertString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertStringToUnicode_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwEncoding,
    /* [in] */ CHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ WCHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMultiLanguage2_ConvertStringToUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertStringFromUnicode_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwEncoding,
    /* [in] */ WCHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ CHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize);


void __RPC_STUB IMultiLanguage2_ConvertStringFromUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertStringReset_Proxy( 
    IMultiLanguage2 __RPC_FAR * This);


void __RPC_STUB IMultiLanguage2_ConvertStringReset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetRfc1766FromLcid_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ LCID Locale,
    /* [out] */ BSTR __RPC_FAR *pbstrRfc1766);


void __RPC_STUB IMultiLanguage2_GetRfc1766FromLcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetLcidFromRfc1766_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out] */ LCID __RPC_FAR *pLocale,
    /* [in] */ BSTR bstrRfc1766);


void __RPC_STUB IMultiLanguage2_GetLcidFromRfc1766_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_EnumRfc1766_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ LANGID LangId,
    /* [out] */ IEnumRfc1766 __RPC_FAR *__RPC_FAR *ppEnumRfc1766);


void __RPC_STUB IMultiLanguage2_EnumRfc1766_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetRfc1766Info_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ LCID Locale,
    /* [in] */ LANGID LangId,
    /* [out] */ PRFC1766INFO pRfc1766Info);


void __RPC_STUB IMultiLanguage2_GetRfc1766Info_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_CreateConvertCharset_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiSrcCodePage,
    /* [in] */ UINT uiDstCodePage,
    /* [in] */ DWORD dwProperty,
    /* [out] */ IMLangConvertCharset __RPC_FAR *__RPC_FAR *ppMLangConvertCharset);


void __RPC_STUB IMultiLanguage2_CreateConvertCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertStringInIStream_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwFlag,
    /* [in] */ WCHAR __RPC_FAR *lpFallBack,
    /* [in] */ DWORD dwSrcEncoding,
    /* [in] */ DWORD dwDstEncoding,
    /* [in] */ IStream __RPC_FAR *pstmIn,
    /* [in] */ IStream __RPC_FAR *pstmOut);


void __RPC_STUB IMultiLanguage2_ConvertStringInIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertStringToUnicodeEx_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwEncoding,
    /* [in] */ CHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ WCHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize,
    /* [in] */ DWORD dwFlag,
    /* [in] */ WCHAR __RPC_FAR *lpFallBack);


void __RPC_STUB IMultiLanguage2_ConvertStringToUnicodeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ConvertStringFromUnicodeEx_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwMode,
    /* [in] */ DWORD dwEncoding,
    /* [in] */ WCHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ UINT __RPC_FAR *pcSrcSize,
    /* [in] */ CHAR __RPC_FAR *pDstStr,
    /* [out][in] */ UINT __RPC_FAR *pcDstSize,
    /* [in] */ DWORD dwFlag,
    /* [in] */ WCHAR __RPC_FAR *lpFallBack);


void __RPC_STUB IMultiLanguage2_ConvertStringFromUnicodeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_DetectCodepageInIStream_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlag,
    /* [in] */ DWORD dwPrefWinCodePage,
    /* [in] */ IStream __RPC_FAR *pstmIn,
    /* [out][in] */ DetectEncodingInfo __RPC_FAR *lpEncoding,
    /* [out][in] */ INT __RPC_FAR *pnScores);


void __RPC_STUB IMultiLanguage2_DetectCodepageInIStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_DetectInputCodepage_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlag,
    /* [in] */ DWORD dwPrefWinCodePage,
    /* [in] */ CHAR __RPC_FAR *pSrcStr,
    /* [out][in] */ INT __RPC_FAR *pcSrcSize,
    /* [out][in] */ DetectEncodingInfo __RPC_FAR *lpEncoding,
    /* [out][in] */ INT __RPC_FAR *pnScores);


void __RPC_STUB IMultiLanguage2_DetectInputCodepage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ValidateCodePage_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [in] */ HWND hwnd);


void __RPC_STUB IMultiLanguage2_ValidateCodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetCodePageDescription_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [in] */ LCID lcid,
    /* [out][in] */ LPWSTR lpWideCharStr,
    /* [in] */ int cchWideChar);


void __RPC_STUB IMultiLanguage2_GetCodePageDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_IsCodePageInstallable_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage);


void __RPC_STUB IMultiLanguage2_IsCodePageInstallable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_SetMimeDBSource_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ MIMECONTF dwSource);


void __RPC_STUB IMultiLanguage2_SetMimeDBSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_GetNumberOfScripts_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pnScripts);


void __RPC_STUB IMultiLanguage2_GetNumberOfScripts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_EnumScripts_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LANGID LangId,
    /* [out] */ IEnumScript __RPC_FAR *__RPC_FAR *ppEnumScript);


void __RPC_STUB IMultiLanguage2_EnumScripts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMultiLanguage2_ValidateCodePageEx_Proxy( 
    IMultiLanguage2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwfIODControl);


void __RPC_STUB IMultiLanguage2_ValidateCodePageEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMultiLanguage2_INTERFACE_DEFINED__ */


#ifndef __IMLangCodePages_INTERFACE_DEFINED__
#define __IMLangCodePages_INTERFACE_DEFINED__

/* interface IMLangCodePages */
/* [object][unique][helpstring][uuid] */ 

typedef /* [unique] */ IMLangCodePages __RPC_FAR *PMLANGCODEPAGES;


EXTERN_C const IID IID_IMLangCodePages;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("359F3443-BD4A-11D0-B188-00AA0038C969")
    IMLangCodePages : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCharCodePages( 
            /* [in] */ WCHAR chSrc,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStrCodePages( 
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ DWORD dwPriorityCodePages,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages,
            /* [out] */ long __RPC_FAR *pcchCodePages) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CodePageToCodePages( 
            /* [in] */ UINT uCodePage,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CodePagesToCodePage( 
            /* [in] */ DWORD dwCodePages,
            /* [in] */ UINT uDefaultCodePage,
            /* [out] */ UINT __RPC_FAR *puCodePage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangCodePagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangCodePages __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangCodePages __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangCodePages __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharCodePages )( 
            IMLangCodePages __RPC_FAR * This,
            /* [in] */ WCHAR chSrc,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrCodePages )( 
            IMLangCodePages __RPC_FAR * This,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ DWORD dwPriorityCodePages,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages,
            /* [out] */ long __RPC_FAR *pcchCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePageToCodePages )( 
            IMLangCodePages __RPC_FAR * This,
            /* [in] */ UINT uCodePage,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePagesToCodePage )( 
            IMLangCodePages __RPC_FAR * This,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ UINT uDefaultCodePage,
            /* [out] */ UINT __RPC_FAR *puCodePage);
        
        END_INTERFACE
    } IMLangCodePagesVtbl;

    interface IMLangCodePages
    {
        CONST_VTBL struct IMLangCodePagesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangCodePages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangCodePages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangCodePages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangCodePages_GetCharCodePages(This,chSrc,pdwCodePages)	\
    (This)->lpVtbl -> GetCharCodePages(This,chSrc,pdwCodePages)

#define IMLangCodePages_GetStrCodePages(This,pszSrc,cchSrc,dwPriorityCodePages,pdwCodePages,pcchCodePages)	\
    (This)->lpVtbl -> GetStrCodePages(This,pszSrc,cchSrc,dwPriorityCodePages,pdwCodePages,pcchCodePages)

#define IMLangCodePages_CodePageToCodePages(This,uCodePage,pdwCodePages)	\
    (This)->lpVtbl -> CodePageToCodePages(This,uCodePage,pdwCodePages)

#define IMLangCodePages_CodePagesToCodePage(This,dwCodePages,uDefaultCodePage,puCodePage)	\
    (This)->lpVtbl -> CodePagesToCodePage(This,dwCodePages,uDefaultCodePage,puCodePage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangCodePages_GetCharCodePages_Proxy( 
    IMLangCodePages __RPC_FAR * This,
    /* [in] */ WCHAR chSrc,
    /* [out] */ DWORD __RPC_FAR *pdwCodePages);


void __RPC_STUB IMLangCodePages_GetCharCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangCodePages_GetStrCodePages_Proxy( 
    IMLangCodePages __RPC_FAR * This,
    /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
    /* [in] */ long cchSrc,
    /* [in] */ DWORD dwPriorityCodePages,
    /* [out] */ DWORD __RPC_FAR *pdwCodePages,
    /* [out] */ long __RPC_FAR *pcchCodePages);


void __RPC_STUB IMLangCodePages_GetStrCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangCodePages_CodePageToCodePages_Proxy( 
    IMLangCodePages __RPC_FAR * This,
    /* [in] */ UINT uCodePage,
    /* [out] */ DWORD __RPC_FAR *pdwCodePages);


void __RPC_STUB IMLangCodePages_CodePageToCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangCodePages_CodePagesToCodePage_Proxy( 
    IMLangCodePages __RPC_FAR * This,
    /* [in] */ DWORD dwCodePages,
    /* [in] */ UINT uDefaultCodePage,
    /* [out] */ UINT __RPC_FAR *puCodePage);


void __RPC_STUB IMLangCodePages_CodePagesToCodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangCodePages_INTERFACE_DEFINED__ */


#ifndef __IMLangFontLink_INTERFACE_DEFINED__
#define __IMLangFontLink_INTERFACE_DEFINED__

/* interface IMLangFontLink */
/* [object][unique][helpstring][uuid] */ 

typedef /* [unique] */ IMLangFontLink __RPC_FAR *PMLANGFONTLINK;


EXTERN_C const IID IID_IMLangFontLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("359F3441-BD4A-11D0-B188-00AA0038C969")
    IMLangFontLink : public IMLangCodePages
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFontCodePages( 
            /* [in] */ HDC hDC,
            /* [in] */ HFONT hFont,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapFont( 
            /* [in] */ HDC hDC,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ HFONT hSrcFont,
            /* [out] */ HFONT __RPC_FAR *phDestFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseFont( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetFontMapping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangFontLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangFontLink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangFontLink __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharCodePages )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ WCHAR chSrc,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrCodePages )( 
            IMLangFontLink __RPC_FAR * This,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ DWORD dwPriorityCodePages,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages,
            /* [out] */ long __RPC_FAR *pcchCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePageToCodePages )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ UINT uCodePage,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePagesToCodePage )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ UINT uDefaultCodePage,
            /* [out] */ UINT __RPC_FAR *puCodePage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontCodePages )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ HDC hDC,
            /* [in] */ HFONT hFont,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapFont )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ HDC hDC,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ HFONT hSrcFont,
            /* [out] */ HFONT __RPC_FAR *phDestFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseFont )( 
            IMLangFontLink __RPC_FAR * This,
            /* [in] */ HFONT hFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetFontMapping )( 
            IMLangFontLink __RPC_FAR * This);
        
        END_INTERFACE
    } IMLangFontLinkVtbl;

    interface IMLangFontLink
    {
        CONST_VTBL struct IMLangFontLinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangFontLink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangFontLink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangFontLink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangFontLink_GetCharCodePages(This,chSrc,pdwCodePages)	\
    (This)->lpVtbl -> GetCharCodePages(This,chSrc,pdwCodePages)

#define IMLangFontLink_GetStrCodePages(This,pszSrc,cchSrc,dwPriorityCodePages,pdwCodePages,pcchCodePages)	\
    (This)->lpVtbl -> GetStrCodePages(This,pszSrc,cchSrc,dwPriorityCodePages,pdwCodePages,pcchCodePages)

#define IMLangFontLink_CodePageToCodePages(This,uCodePage,pdwCodePages)	\
    (This)->lpVtbl -> CodePageToCodePages(This,uCodePage,pdwCodePages)

#define IMLangFontLink_CodePagesToCodePage(This,dwCodePages,uDefaultCodePage,puCodePage)	\
    (This)->lpVtbl -> CodePagesToCodePage(This,dwCodePages,uDefaultCodePage,puCodePage)


#define IMLangFontLink_GetFontCodePages(This,hDC,hFont,pdwCodePages)	\
    (This)->lpVtbl -> GetFontCodePages(This,hDC,hFont,pdwCodePages)

#define IMLangFontLink_MapFont(This,hDC,dwCodePages,hSrcFont,phDestFont)	\
    (This)->lpVtbl -> MapFont(This,hDC,dwCodePages,hSrcFont,phDestFont)

#define IMLangFontLink_ReleaseFont(This,hFont)	\
    (This)->lpVtbl -> ReleaseFont(This,hFont)

#define IMLangFontLink_ResetFontMapping(This)	\
    (This)->lpVtbl -> ResetFontMapping(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink_GetFontCodePages_Proxy( 
    IMLangFontLink __RPC_FAR * This,
    /* [in] */ HDC hDC,
    /* [in] */ HFONT hFont,
    /* [out] */ DWORD __RPC_FAR *pdwCodePages);


void __RPC_STUB IMLangFontLink_GetFontCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink_MapFont_Proxy( 
    IMLangFontLink __RPC_FAR * This,
    /* [in] */ HDC hDC,
    /* [in] */ DWORD dwCodePages,
    /* [in] */ HFONT hSrcFont,
    /* [out] */ HFONT __RPC_FAR *phDestFont);


void __RPC_STUB IMLangFontLink_MapFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink_ReleaseFont_Proxy( 
    IMLangFontLink __RPC_FAR * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IMLangFontLink_ReleaseFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink_ResetFontMapping_Proxy( 
    IMLangFontLink __RPC_FAR * This);


void __RPC_STUB IMLangFontLink_ResetFontMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangFontLink_INTERFACE_DEFINED__ */


#ifndef __IMLangFontLink2_INTERFACE_DEFINED__
#define __IMLangFontLink2_INTERFACE_DEFINED__

/* interface IMLangFontLink2 */
/* [object][unique][helpstring][uuid] */ 

typedef struct tagUNICODERANGE
    {
    WCHAR wcFrom;
    WCHAR wcTo;
    }	UNICODERANGE;

typedef /* [unique] */ IMLangFontLink2 __RPC_FAR *PMLANGFONTLINK2;


EXTERN_C const IID IID_IMLangFontLink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCCFC162-2B38-11d2-B7EC-00C04F8F5D9A")
    IMLangFontLink2 : public IMLangCodePages
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFontCodePages( 
            /* [in] */ HDC hDC,
            /* [in] */ HFONT hFont,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReleaseFont( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetFontMapping( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapFont( 
            /* [in] */ HDC hDC,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ WCHAR chSrc,
            /* [out] */ HFONT __RPC_FAR *pFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFontUnicodeRanges( 
            /* [in] */ HDC hDC,
            /* [out][in] */ UINT __RPC_FAR *puiRanges,
            /* [out] */ UNICODERANGE __RPC_FAR *pUranges) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetScriptFontInfo( 
            /* [in] */ SCRIPT_ID sid,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ UINT __RPC_FAR *puiFonts,
            /* [out] */ SCRIPTFONTINFO __RPC_FAR *pScriptFont) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CodePageToScriptID( 
            /* [in] */ UINT uiCodePage,
            /* [out] */ SCRIPT_ID __RPC_FAR *pSid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMLangFontLink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMLangFontLink2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMLangFontLink2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharCodePages )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ WCHAR chSrc,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrCodePages )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [size_is][in] */ const WCHAR __RPC_FAR *pszSrc,
            /* [in] */ long cchSrc,
            /* [in] */ DWORD dwPriorityCodePages,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages,
            /* [out] */ long __RPC_FAR *pcchCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePageToCodePages )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ UINT uCodePage,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePagesToCodePage )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ UINT uDefaultCodePage,
            /* [out] */ UINT __RPC_FAR *puCodePage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontCodePages )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ HDC hDC,
            /* [in] */ HFONT hFont,
            /* [out] */ DWORD __RPC_FAR *pdwCodePages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseFont )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ HFONT hFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetFontMapping )( 
            IMLangFontLink2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapFont )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ HDC hDC,
            /* [in] */ DWORD dwCodePages,
            /* [in] */ WCHAR chSrc,
            /* [out] */ HFONT __RPC_FAR *pFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontUnicodeRanges )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ HDC hDC,
            /* [out][in] */ UINT __RPC_FAR *puiRanges,
            /* [out] */ UNICODERANGE __RPC_FAR *pUranges);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptFontInfo )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ SCRIPT_ID sid,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ UINT __RPC_FAR *puiFonts,
            /* [out] */ SCRIPTFONTINFO __RPC_FAR *pScriptFont);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodePageToScriptID )( 
            IMLangFontLink2 __RPC_FAR * This,
            /* [in] */ UINT uiCodePage,
            /* [out] */ SCRIPT_ID __RPC_FAR *pSid);
        
        END_INTERFACE
    } IMLangFontLink2Vtbl;

    interface IMLangFontLink2
    {
        CONST_VTBL struct IMLangFontLink2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMLangFontLink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMLangFontLink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMLangFontLink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMLangFontLink2_GetCharCodePages(This,chSrc,pdwCodePages)	\
    (This)->lpVtbl -> GetCharCodePages(This,chSrc,pdwCodePages)

#define IMLangFontLink2_GetStrCodePages(This,pszSrc,cchSrc,dwPriorityCodePages,pdwCodePages,pcchCodePages)	\
    (This)->lpVtbl -> GetStrCodePages(This,pszSrc,cchSrc,dwPriorityCodePages,pdwCodePages,pcchCodePages)

#define IMLangFontLink2_CodePageToCodePages(This,uCodePage,pdwCodePages)	\
    (This)->lpVtbl -> CodePageToCodePages(This,uCodePage,pdwCodePages)

#define IMLangFontLink2_CodePagesToCodePage(This,dwCodePages,uDefaultCodePage,puCodePage)	\
    (This)->lpVtbl -> CodePagesToCodePage(This,dwCodePages,uDefaultCodePage,puCodePage)


#define IMLangFontLink2_GetFontCodePages(This,hDC,hFont,pdwCodePages)	\
    (This)->lpVtbl -> GetFontCodePages(This,hDC,hFont,pdwCodePages)

#define IMLangFontLink2_ReleaseFont(This,hFont)	\
    (This)->lpVtbl -> ReleaseFont(This,hFont)

#define IMLangFontLink2_ResetFontMapping(This)	\
    (This)->lpVtbl -> ResetFontMapping(This)

#define IMLangFontLink2_MapFont(This,hDC,dwCodePages,chSrc,pFont)	\
    (This)->lpVtbl -> MapFont(This,hDC,dwCodePages,chSrc,pFont)

#define IMLangFontLink2_GetFontUnicodeRanges(This,hDC,puiRanges,pUranges)	\
    (This)->lpVtbl -> GetFontUnicodeRanges(This,hDC,puiRanges,pUranges)

#define IMLangFontLink2_GetScriptFontInfo(This,sid,dwFlags,puiFonts,pScriptFont)	\
    (This)->lpVtbl -> GetScriptFontInfo(This,sid,dwFlags,puiFonts,pScriptFont)

#define IMLangFontLink2_CodePageToScriptID(This,uiCodePage,pSid)	\
    (This)->lpVtbl -> CodePageToScriptID(This,uiCodePage,pSid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_GetFontCodePages_Proxy( 
    IMLangFontLink2 __RPC_FAR * This,
    /* [in] */ HDC hDC,
    /* [in] */ HFONT hFont,
    /* [out] */ DWORD __RPC_FAR *pdwCodePages);


void __RPC_STUB IMLangFontLink2_GetFontCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_ReleaseFont_Proxy( 
    IMLangFontLink2 __RPC_FAR * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IMLangFontLink2_ReleaseFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_ResetFontMapping_Proxy( 
    IMLangFontLink2 __RPC_FAR * This);


void __RPC_STUB IMLangFontLink2_ResetFontMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_MapFont_Proxy( 
    IMLangFontLink2 __RPC_FAR * This,
    /* [in] */ HDC hDC,
    /* [in] */ DWORD dwCodePages,
    /* [in] */ WCHAR chSrc,
    /* [out] */ HFONT __RPC_FAR *pFont);


void __RPC_STUB IMLangFontLink2_MapFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_GetFontUnicodeRanges_Proxy( 
    IMLangFontLink2 __RPC_FAR * This,
    /* [in] */ HDC hDC,
    /* [out][in] */ UINT __RPC_FAR *puiRanges,
    /* [out] */ UNICODERANGE __RPC_FAR *pUranges);


void __RPC_STUB IMLangFontLink2_GetFontUnicodeRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_GetScriptFontInfo_Proxy( 
    IMLangFontLink2 __RPC_FAR * This,
    /* [in] */ SCRIPT_ID sid,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ UINT __RPC_FAR *puiFonts,
    /* [out] */ SCRIPTFONTINFO __RPC_FAR *pScriptFont);


void __RPC_STUB IMLangFontLink2_GetScriptFontInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMLangFontLink2_CodePageToScriptID_Proxy( 
    IMLangFontLink2 __RPC_FAR * This,
    /* [in] */ UINT uiCodePage,
    /* [out] */ SCRIPT_ID __RPC_FAR *pSid);


void __RPC_STUB IMLangFontLink2_CodePageToScriptID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMLangFontLink2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CMultiLanguage;

#ifdef __cplusplus

class DECLSPEC_UUID("275c23e2-3747-11d0-9fea-00aa003f8646")
CMultiLanguage;
#endif
#endif /* __MultiLanguage_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_mlang_0120 */
/* [local] */ 

#ifndef _MLANG_H_API_DEF_                                                     
#define _MLANG_H_API_DEF_                                                     
                                                                              
// APIs prototypes                                                            
STDAPI LcidToRfc1766A(LCID Locale, LPSTR pszRfc1766, int iMaxLength);         
STDAPI LcidToRfc1766W(LCID Locale, LPWSTR pszRfc1766, int nChar);             
#ifdef UNICODE                                                                
#define LcidToRfc1766        LcidToRfc1766W                                   
#else                                                                         
#define LcidToRfc1766        LcidToRfc1766A                                   
#endif                                                                        
STDAPI Rfc1766ToLcidA(LCID *pLocale, LPCSTR pszRfc1766);                      
STDAPI Rfc1766ToLcidW(LCID *pLocale, LPCWSTR pszRfc1766);                     
#ifdef UNICODE                                                                
#define Rfc1766ToLcid        Rfc1766ToLcidW                                   
#else                                                                         
#define Rfc1766ToLcid        Rfc1766ToLcidA                                   
#endif                                                                        
                                                                              
STDAPI IsConvertINetStringAvailable(DWORD dwSrcEncoding, DWORD dwDstEncoding);
STDAPI ConvertINetString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize);   
STDAPI ConvertINetMultiByteToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount); 
STDAPI ConvertINetUnicodeToMultiByte(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount); 
                                                                              
#endif // _MLANG_H_API_DEF_                                                   


extern RPC_IF_HANDLE __MIDL_itf_mlang_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mlang_0120_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\prshtp.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHTP_H_
#define _PRSHTP_H_
//  BUGBUG: Exact same block is in commctrl.h   /*
//  BUGBUG: Exact same block is in commctrl.h   /*

#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define PSP_SHPAGE                 0x00000200  // BUGBUG raymondc remove once docfind2.c is fixed
#define PSP_DONOTUSE               0x00000200  // Dead flag - do not recycle
#define PSP_ALL                    0x0000FFFF
#define PSP_IS16                   0x00008000
// we are such morons.  Wiz97 underwent a redesign between IE4 and IE5
// so we have to treat them as two unrelated wizard styles that happen to
// have frighteningly similar names.
#define PSH_WIZARD97IE4         0x00002000
#define PSH_WIZARD97IE5         0x01000000
#define PSH_THUNKED             0x00800000
#define PSH_ALL                 0x03FFFFFF
#ifdef _WIN32
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreateProxyPage32Ex(HPROPSHEETPAGE hpage16, HINSTANCE hinst16);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16);
#endif
// these need to match shell.h's ranges
#define PSN_HASHELP             (PSN_FIRST-4)
#define PSN_LASTCHANCEAPPLY     (PSN_FIRST-11)
// Note!  If you add a new PSN_*, make sure to tell the WOW people
// Do not rely on PSNRET_INVALID because some apps return 1 for
// all WM_NOTIFY messages, even if they weren't handled.
//
// we keep PSM_DISABLEAPPLY / PSM_ENABLEAPPLY messages private,
// because we dont want random prop sheets screwing with this.
//
#define PSM_DISABLEAPPLY        (WM_USER + 122)
#define PropSheet_DisableApply(hDlg) \
        SendMessage(hDlg, PSM_DISABLEAPPLY, 0, 0L)

#define PSM_ENABLEAPPLY         (WM_USER + 123)
#define PropSheet_EnableApply(hDlg) \
        SendMessage(hDlg, PSM_ENABLEAPPLY, 0, 0L)
#define PropSheet_SetWizButtonsNow(hDlg, dwFlags) PropSheet_SetWizButtons(hDlg, dwFlags)

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _PRSHTP_H_     //
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\ocmm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Jan 24 20:16:03 2001
 */
/* Compiler settings for ocmm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ocmm_h__
#define __ocmm_h__

/* Forward Declarations */ 

#ifndef __ITimerService_FWD_DEFINED__
#define __ITimerService_FWD_DEFINED__
typedef interface ITimerService ITimerService;
#endif 	/* __ITimerService_FWD_DEFINED__ */


#ifndef __ITimer_FWD_DEFINED__
#define __ITimer_FWD_DEFINED__
typedef interface ITimer ITimer;
#endif 	/* __ITimer_FWD_DEFINED__ */


#ifndef __ITimerSink_FWD_DEFINED__
#define __ITimerSink_FWD_DEFINED__
typedef interface ITimerSink ITimerSink;
#endif 	/* __ITimerSink_FWD_DEFINED__ */


#ifndef __IMapMIMEToCLSID_FWD_DEFINED__
#define __IMapMIMEToCLSID_FWD_DEFINED__
typedef interface IMapMIMEToCLSID IMapMIMEToCLSID;
#endif 	/* __IMapMIMEToCLSID_FWD_DEFINED__ */


#ifndef __IImageDecodeFilter_FWD_DEFINED__
#define __IImageDecodeFilter_FWD_DEFINED__
typedef interface IImageDecodeFilter IImageDecodeFilter;
#endif 	/* __IImageDecodeFilter_FWD_DEFINED__ */


#ifndef __IImageDecodeEventSink_FWD_DEFINED__
#define __IImageDecodeEventSink_FWD_DEFINED__
typedef interface IImageDecodeEventSink IImageDecodeEventSink;
#endif 	/* __IImageDecodeEventSink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_ocmm_0000 */
/* [local] */ 

#define SURFACE_LOCK_EXCLUSIVE        0x01
#define SURFACE_LOCK_ALLOW_DISCARD    0x02
#define SURFACE_LOCK_WAIT             0x04

#define E_SURFACE_NOSURFACE             0x8000C000L
#define E_SURFACE_UNKNOWN_FORMAT        0x8000C001L
#define E_SURFACE_NOTMYPOINTER          0x8000C002L
#define E_SURFACE_DISCARDED             0x8000C003L
#define E_SURFACE_NODC                  0x8000C004L
#define E_SURFACE_NOTMYDC               0x8000C005L
#define S_SURFACE_DISCARDED             0x0000C003L

typedef GUID BFID;

#ifndef RGBQUAD_DEFINED
#define RGBQUAD_DEFINED
typedef struct tagRGBQUAD RGBQUAD;

#endif
EXTERN_C const GUID BFID_MONOCHROME;
EXTERN_C const GUID BFID_RGB_4;
EXTERN_C const GUID BFID_RGB_8;
EXTERN_C const GUID BFID_RGB_555;
EXTERN_C const GUID BFID_RGB_565;
EXTERN_C const GUID BFID_RGB_24;
EXTERN_C const GUID BFID_RGB_32;
EXTERN_C const GUID BFID_RGBA_32;
EXTERN_C const GUID BFID_GRAY_8;
EXTERN_C const GUID BFID_GRAY_16;

#define SID_SDirectDraw3 IID_IDirectDraw3

#define COLOR_NO_TRANSPARENT 0xFFFFFFFF

#define IMGDECODE_EVENT_PROGRESS 0x01
#define IMGDECODE_EVENT_PALETTE 0x02
#define IMGDECODE_EVENT_BEGINBITS 0x04
#define IMGDECODE_EVENT_BITSCOMPLETE 0x08
#define IMGDECODE_EVENT_USEDDRAW 0x10

#define IMGDECODE_HINT_TOPDOWN 0x01
#define IMGDECODE_HINT_BOTTOMUP 0x02
#define IMGDECODE_HINT_FULLWIDTH 0x04

#define MAPMIME_DEFAULT 0
#define MAPMIME_CLSID 1
#define MAPMIME_DISABLE 2
#define MAPMIME_DEFAULT_ALWAYS 3

#define BFID_INDEXED_RGB_8 BFID_RGB_8
#define BFID_INDEXED_RGB_4 BFID_RGB_4
#define BFID_INDEXED_RGB_1 BFID_MONOCHROME

EXTERN_C const GUID CLSID_IImageDecodeFilter;

EXTERN_C const GUID NAMEDTIMER_DRAW;






extern RPC_IF_HANDLE __MIDL_itf_ocmm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocmm_0000_v0_0_s_ifspec;

#ifndef __ITimerService_INTERFACE_DEFINED__
#define __ITimerService_INTERFACE_DEFINED__

/* interface ITimerService */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITimerService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f35f-98b5-11cf-bb82-00aa00bdce0b")
    ITimerService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateTimer( 
            /* [in] */ ITimer __RPC_FAR *pReferenceTimer,
            /* [out] */ ITimer __RPC_FAR *__RPC_FAR *ppNewTimer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedTimer( 
            /* [in] */ REFGUID rguidName,
            /* [out] */ ITimer __RPC_FAR *__RPC_FAR *ppTimer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamedTimerReference( 
            /* [in] */ REFGUID rguidName,
            /* [in] */ ITimer __RPC_FAR *pReferenceTimer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITimerServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITimerService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITimerService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITimerService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTimer )( 
            ITimerService __RPC_FAR * This,
            /* [in] */ ITimer __RPC_FAR *pReferenceTimer,
            /* [out] */ ITimer __RPC_FAR *__RPC_FAR *ppNewTimer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNamedTimer )( 
            ITimerService __RPC_FAR * This,
            /* [in] */ REFGUID rguidName,
            /* [out] */ ITimer __RPC_FAR *__RPC_FAR *ppTimer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNamedTimerReference )( 
            ITimerService __RPC_FAR * This,
            /* [in] */ REFGUID rguidName,
            /* [in] */ ITimer __RPC_FAR *pReferenceTimer);
        
        END_INTERFACE
    } ITimerServiceVtbl;

    interface ITimerService
    {
        CONST_VTBL struct ITimerServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITimerService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITimerService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITimerService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITimerService_CreateTimer(This,pReferenceTimer,ppNewTimer)	\
    (This)->lpVtbl -> CreateTimer(This,pReferenceTimer,ppNewTimer)

#define ITimerService_GetNamedTimer(This,rguidName,ppTimer)	\
    (This)->lpVtbl -> GetNamedTimer(This,rguidName,ppTimer)

#define ITimerService_SetNamedTimerReference(This,rguidName,pReferenceTimer)	\
    (This)->lpVtbl -> SetNamedTimerReference(This,rguidName,pReferenceTimer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITimerService_CreateTimer_Proxy( 
    ITimerService __RPC_FAR * This,
    /* [in] */ ITimer __RPC_FAR *pReferenceTimer,
    /* [out] */ ITimer __RPC_FAR *__RPC_FAR *ppNewTimer);


void __RPC_STUB ITimerService_CreateTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITimerService_GetNamedTimer_Proxy( 
    ITimerService __RPC_FAR * This,
    /* [in] */ REFGUID rguidName,
    /* [out] */ ITimer __RPC_FAR *__RPC_FAR *ppTimer);


void __RPC_STUB ITimerService_GetNamedTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITimerService_SetNamedTimerReference_Proxy( 
    ITimerService __RPC_FAR * This,
    /* [in] */ REFGUID rguidName,
    /* [in] */ ITimer __RPC_FAR *pReferenceTimer);


void __RPC_STUB ITimerService_SetNamedTimerReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITimerService_INTERFACE_DEFINED__ */


#ifndef __ITimer_INTERFACE_DEFINED__
#define __ITimer_INTERFACE_DEFINED__

/* interface ITimer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITimer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f360-98b5-11cf-bb82-00aa00bdce0b")
    ITimer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ VARIANT vtimeMin,
            /* [in] */ VARIANT vtimeMax,
            /* [in] */ VARIANT vtimeInterval,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITimerSink __RPC_FAR *pTimerSink,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Freeze( 
            /* [in] */ BOOL fFreeze) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ VARIANT __RPC_FAR *pvtime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITimerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITimer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITimer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITimer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            ITimer __RPC_FAR * This,
            /* [in] */ VARIANT vtimeMin,
            /* [in] */ VARIANT vtimeMax,
            /* [in] */ VARIANT vtimeInterval,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITimerSink __RPC_FAR *pTimerSink,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            ITimer __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )( 
            ITimer __RPC_FAR * This,
            /* [in] */ BOOL fFreeze);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            ITimer __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pvtime);
        
        END_INTERFACE
    } ITimerVtbl;

    interface ITimer
    {
        CONST_VTBL struct ITimerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITimer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITimer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITimer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITimer_Advise(This,vtimeMin,vtimeMax,vtimeInterval,dwFlags,pTimerSink,pdwCookie)	\
    (This)->lpVtbl -> Advise(This,vtimeMin,vtimeMax,vtimeInterval,dwFlags,pTimerSink,pdwCookie)

#define ITimer_Unadvise(This,dwCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwCookie)

#define ITimer_Freeze(This,fFreeze)	\
    (This)->lpVtbl -> Freeze(This,fFreeze)

#define ITimer_GetTime(This,pvtime)	\
    (This)->lpVtbl -> GetTime(This,pvtime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITimer_Advise_Proxy( 
    ITimer __RPC_FAR * This,
    /* [in] */ VARIANT vtimeMin,
    /* [in] */ VARIANT vtimeMax,
    /* [in] */ VARIANT vtimeInterval,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITimerSink __RPC_FAR *pTimerSink,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB ITimer_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITimer_Unadvise_Proxy( 
    ITimer __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITimer_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITimer_Freeze_Proxy( 
    ITimer __RPC_FAR * This,
    /* [in] */ BOOL fFreeze);


void __RPC_STUB ITimer_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITimer_GetTime_Proxy( 
    ITimer __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pvtime);


void __RPC_STUB ITimer_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITimer_INTERFACE_DEFINED__ */


#ifndef __ITimerSink_INTERFACE_DEFINED__
#define __ITimerSink_INTERFACE_DEFINED__

/* interface ITimerSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITimerSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f361-98b5-11cf-bb82-00aa00bdce0b")
    ITimerSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTimer( 
            /* [in] */ VARIANT vtimeAdvise) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITimerSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITimerSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITimerSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITimerSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTimer )( 
            ITimerSink __RPC_FAR * This,
            /* [in] */ VARIANT vtimeAdvise);
        
        END_INTERFACE
    } ITimerSinkVtbl;

    interface ITimerSink
    {
        CONST_VTBL struct ITimerSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITimerSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITimerSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITimerSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITimerSink_OnTimer(This,vtimeAdvise)	\
    (This)->lpVtbl -> OnTimer(This,vtimeAdvise)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITimerSink_OnTimer_Proxy( 
    ITimerSink __RPC_FAR * This,
    /* [in] */ VARIANT vtimeAdvise);


void __RPC_STUB ITimerSink_OnTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITimerSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ocmm_0132 */
/* [local] */ 

#define SID_STimerService IID_ITimerService






extern RPC_IF_HANDLE __MIDL_itf_ocmm_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocmm_0132_v0_0_s_ifspec;

#ifndef __IMapMIMEToCLSID_INTERFACE_DEFINED__
#define __IMapMIMEToCLSID_INTERFACE_DEFINED__

/* interface IMapMIMEToCLSID */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMapMIMEToCLSID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9E89500-30FA-11d0-B724-00AA006C1A01")
    IMapMIMEToCLSID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableDefaultMappings( 
            BOOL bEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapMIMEToCLSID( 
            LPCOLESTR pszMIMEType,
            CLSID __RPC_FAR *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMapping( 
            LPCOLESTR pszMIMEType,
            DWORD dwMapMode,
            REFCLSID clsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMapMIMEToCLSIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMapMIMEToCLSID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMapMIMEToCLSID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMapMIMEToCLSID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableDefaultMappings )( 
            IMapMIMEToCLSID __RPC_FAR * This,
            BOOL bEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapMIMEToCLSID )( 
            IMapMIMEToCLSID __RPC_FAR * This,
            LPCOLESTR pszMIMEType,
            CLSID __RPC_FAR *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMapping )( 
            IMapMIMEToCLSID __RPC_FAR * This,
            LPCOLESTR pszMIMEType,
            DWORD dwMapMode,
            REFCLSID clsid);
        
        END_INTERFACE
    } IMapMIMEToCLSIDVtbl;

    interface IMapMIMEToCLSID
    {
        CONST_VTBL struct IMapMIMEToCLSIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMapMIMEToCLSID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMapMIMEToCLSID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMapMIMEToCLSID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMapMIMEToCLSID_EnableDefaultMappings(This,bEnable)	\
    (This)->lpVtbl -> EnableDefaultMappings(This,bEnable)

#define IMapMIMEToCLSID_MapMIMEToCLSID(This,pszMIMEType,pCLSID)	\
    (This)->lpVtbl -> MapMIMEToCLSID(This,pszMIMEType,pCLSID)

#define IMapMIMEToCLSID_SetMapping(This,pszMIMEType,dwMapMode,clsid)	\
    (This)->lpVtbl -> SetMapping(This,pszMIMEType,dwMapMode,clsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMapMIMEToCLSID_EnableDefaultMappings_Proxy( 
    IMapMIMEToCLSID __RPC_FAR * This,
    BOOL bEnable);


void __RPC_STUB IMapMIMEToCLSID_EnableDefaultMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMapMIMEToCLSID_MapMIMEToCLSID_Proxy( 
    IMapMIMEToCLSID __RPC_FAR * This,
    LPCOLESTR pszMIMEType,
    CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IMapMIMEToCLSID_MapMIMEToCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMapMIMEToCLSID_SetMapping_Proxy( 
    IMapMIMEToCLSID __RPC_FAR * This,
    LPCOLESTR pszMIMEType,
    DWORD dwMapMode,
    REFCLSID clsid);


void __RPC_STUB IMapMIMEToCLSID_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMapMIMEToCLSID_INTERFACE_DEFINED__ */


#ifndef __IImageDecodeFilter_INTERFACE_DEFINED__
#define __IImageDecodeFilter_INTERFACE_DEFINED__

/* interface IImageDecodeFilter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IImageDecodeFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3CCEDF3-2DE2-11D0-86F4-00A0C913F750")
    IImageDecodeFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            IImageDecodeEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Process( 
            IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            HRESULT hrStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageDecodeFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageDecodeFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageDecodeFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageDecodeFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IImageDecodeFilter __RPC_FAR * This,
            IImageDecodeEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Process )( 
            IImageDecodeFilter __RPC_FAR * This,
            IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Terminate )( 
            IImageDecodeFilter __RPC_FAR * This,
            HRESULT hrStatus);
        
        END_INTERFACE
    } IImageDecodeFilterVtbl;

    interface IImageDecodeFilter
    {
        CONST_VTBL struct IImageDecodeFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageDecodeFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageDecodeFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageDecodeFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageDecodeFilter_Initialize(This,pEventSink)	\
    (This)->lpVtbl -> Initialize(This,pEventSink)

#define IImageDecodeFilter_Process(This,pStream)	\
    (This)->lpVtbl -> Process(This,pStream)

#define IImageDecodeFilter_Terminate(This,hrStatus)	\
    (This)->lpVtbl -> Terminate(This,hrStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImageDecodeFilter_Initialize_Proxy( 
    IImageDecodeFilter __RPC_FAR * This,
    IImageDecodeEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IImageDecodeFilter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeFilter_Process_Proxy( 
    IImageDecodeFilter __RPC_FAR * This,
    IStream __RPC_FAR *pStream);


void __RPC_STUB IImageDecodeFilter_Process_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeFilter_Terminate_Proxy( 
    IImageDecodeFilter __RPC_FAR * This,
    HRESULT hrStatus);


void __RPC_STUB IImageDecodeFilter_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageDecodeFilter_INTERFACE_DEFINED__ */


#ifndef __IImageDecodeEventSink_INTERFACE_DEFINED__
#define __IImageDecodeEventSink_INTERFACE_DEFINED__

/* interface IImageDecodeEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IImageDecodeEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BAA342A0-2DED-11d0-86F4-00A0C913F750")
    IImageDecodeEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ LONG nWidth,
            /* [in] */ LONG nHeight,
            /* [in] */ REFGUID bfid,
            /* [in] */ ULONG nPasses,
            /* [in] */ DWORD dwHints,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBeginDecode( 
            /* [out] */ DWORD __RPC_FAR *pdwEvents,
            /* [out] */ ULONG __RPC_FAR *pnFormats,
            /* [size_is][size_is][out] */ BFID __RPC_FAR *__RPC_FAR *ppFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBitsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDecodeComplete( 
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPalette( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ RECT __RPC_FAR *pBounds,
            /* [in] */ BOOL bComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageDecodeEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageDecodeEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageDecodeEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageDecodeEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IImageDecodeEventSink __RPC_FAR * This,
            /* [in] */ LONG nWidth,
            /* [in] */ LONG nHeight,
            /* [in] */ REFGUID bfid,
            /* [in] */ ULONG nPasses,
            /* [in] */ DWORD dwHints,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnBeginDecode )( 
            IImageDecodeEventSink __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwEvents,
            /* [out] */ ULONG __RPC_FAR *pnFormats,
            /* [size_is][size_is][out] */ BFID __RPC_FAR *__RPC_FAR *ppFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnBitsComplete )( 
            IImageDecodeEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDecodeComplete )( 
            IImageDecodeEventSink __RPC_FAR * This,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPalette )( 
            IImageDecodeEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnProgress )( 
            IImageDecodeEventSink __RPC_FAR * This,
            /* [in] */ RECT __RPC_FAR *pBounds,
            /* [in] */ BOOL bComplete);
        
        END_INTERFACE
    } IImageDecodeEventSinkVtbl;

    interface IImageDecodeEventSink
    {
        CONST_VTBL struct IImageDecodeEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageDecodeEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageDecodeEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageDecodeEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageDecodeEventSink_GetSurface(This,nWidth,nHeight,bfid,nPasses,dwHints,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,nWidth,nHeight,bfid,nPasses,dwHints,ppSurface)

#define IImageDecodeEventSink_OnBeginDecode(This,pdwEvents,pnFormats,ppFormats)	\
    (This)->lpVtbl -> OnBeginDecode(This,pdwEvents,pnFormats,ppFormats)

#define IImageDecodeEventSink_OnBitsComplete(This)	\
    (This)->lpVtbl -> OnBitsComplete(This)

#define IImageDecodeEventSink_OnDecodeComplete(This,hrStatus)	\
    (This)->lpVtbl -> OnDecodeComplete(This,hrStatus)

#define IImageDecodeEventSink_OnPalette(This)	\
    (This)->lpVtbl -> OnPalette(This)

#define IImageDecodeEventSink_OnProgress(This,pBounds,bComplete)	\
    (This)->lpVtbl -> OnProgress(This,pBounds,bComplete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImageDecodeEventSink_GetSurface_Proxy( 
    IImageDecodeEventSink __RPC_FAR * This,
    /* [in] */ LONG nWidth,
    /* [in] */ LONG nHeight,
    /* [in] */ REFGUID bfid,
    /* [in] */ ULONG nPasses,
    /* [in] */ DWORD dwHints,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IImageDecodeEventSink_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeEventSink_OnBeginDecode_Proxy( 
    IImageDecodeEventSink __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwEvents,
    /* [out] */ ULONG __RPC_FAR *pnFormats,
    /* [size_is][size_is][out] */ BFID __RPC_FAR *__RPC_FAR *ppFormats);


void __RPC_STUB IImageDecodeEventSink_OnBeginDecode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeEventSink_OnBitsComplete_Proxy( 
    IImageDecodeEventSink __RPC_FAR * This);


void __RPC_STUB IImageDecodeEventSink_OnBitsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeEventSink_OnDecodeComplete_Proxy( 
    IImageDecodeEventSink __RPC_FAR * This,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB IImageDecodeEventSink_OnDecodeComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeEventSink_OnPalette_Proxy( 
    IImageDecodeEventSink __RPC_FAR * This);


void __RPC_STUB IImageDecodeEventSink_OnPalette_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageDecodeEventSink_OnProgress_Proxy( 
    IImageDecodeEventSink __RPC_FAR * This,
    /* [in] */ RECT __RPC_FAR *pBounds,
    /* [in] */ BOOL bComplete);


void __RPC_STUB IImageDecodeEventSink_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageDecodeEventSink_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\inetcpl.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

#ifndef _INETCPLP_H_
#define _INETCPLP_H_

// property sheet page IDs
#define INET_PAGE_GENERAL       0x00000001
#define INET_PAGE_CONNECTION    0x00000002
#define INET_PAGE_PLACES        0x00000004      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_PROGRAMS      0x00000008
#define INET_PAGE_SECURITY_OLD  0x00000010      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_ADVANCED      0x00000020
#define INET_PAGE_PRINT         0x00000040      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_CONTENT       0x00000080
#define INET_PAGE_SECURITY      0x00000100
#define INET_PAGE_ASSOC         0x00000200      // UNIX Assocations
#define INET_PAGE_ALIAS         0x00000400      // UNIX Aliases


//  restrict flags
#define R_MULTIMEDIA    0x00000001              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_COLORS        0x00000002              // colors section of the Colors Dialog
#define R_LINKS         0x00000004              // links section of the Colors Dialog
#define R_TOOLBARS      0x00000008              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_FONTS         0x00000010              // Fonts Dialog
#define R_DIALING       0x00000020              // Connection section of Connection tab (incl Settings subdialog)
#define R_PROXYSERVER   0x00000040              // Proxy server section of Connection tab (incl Advanced subdialog)
#define R_CUSTOMIZE     0x00000080              // Homepage section of General tab
#define R_HISTORY       0x00000100              // History section of General tab
#define R_MAILANDNEWS   0x00000200              // Messaging section of Programs tab
#define R_VIEWERS       0x00000400              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_RATINGS       0x00000800              // Ratings section of Content tab
#define R_CERTIFICATES  0x00001000              // Certificates section of Content tab
#define R_ACTIVECONTENT 0x00002000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_WARNINGS      0x00004000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CACHE         0x00008000              // Temporary Internet Files section of General Tab (incl Settings subdialog)
#define R_CRYPTOGRAPHY  0x00010000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_PLACESDEFAULT 0x00020000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_OTHER         0x00040000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CHECKBROWSER  0x00080000              // "IE should check if default browser" checkbox on Programs tab
#define R_LANGUAGES     0x00100000              // Languages Dialog off of the General tab
#define R_ACCESSIBILITY 0x00200000              // Accessibility Dialog off of the General tab
#define R_SECURITY_HKLM_ONLY 0x00400000         // Security tab settings (everything is read only)
#define R_SECURITY_CHANGE_SETTINGS 0x00800000   // Security tab settings (can't change security level for a zone)
#define R_SECURITY_CHANGE_SITES 0x01000000      // Security tab settings (disable everything on Add sites)
#define R_PROFILES      0x02000000              // Profile Asst. section of Content tab
#define R_WALLET        0x04000000              // MS Wallet section of Content tab
#define R_CONNECTION_WIZARD 0x08000000          // Connection wizard button on Connection tab
#define R_AUTOCONFIG    0x10000000              // Auto config section of Programs tab
#define R_ADVANCED      0x20000000              // Entire Advanced tab (including "Restore Defaults")
#define R_CAL_CONTACT   0x40000000              // Personal Info section of Programs tab

#define STR_INETCPL TEXT("inetcpl.cpl") // LoadLibrary() with this string

// structure to pass info to the control panel
typedef struct {
    UINT cbSize;                    // size of the structure
    DWORD dwFlags;                  // enabled page flags (remove pages)
    LPSTR pszCurrentURL;            // the current URL (NULL=none)
    DWORD dwRestrictMask;           // disable sections of the control panel
    DWORD dwRestrictFlags;          // masking for the above
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETS "AddInternetPropertySheets"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETS)(
    LPFNADDPROPSHEETPAGE pfnAddPage,   // add PS callback function
    LPARAM lparam,                     // pointer to prop. sheet header
    PUINT pucRefCount,                 // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback        // PS-to-be-added's callback function (NULL if not used);
);


// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETSEX "AddInternetPropertySheetsEx"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETSEX)(
    LPFNADDPROPSHEETPAGE pfnAddPage, // add PS callback function
    LPARAM lparam,                   // pointer to prop. sheet header
    PUINT pucRefCount,               // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback,     // PS-to-be-added's callback function (NULL if not used)
    LPIEPROPPAGEINFO piepi           // structure to pass info to control panel
);

STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath);
STDAPI_(BOOL) LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, DWORD dwFlags);

#define STR_LAUNCHSECURITYDIALOGEX TEXT("LaunchSecurityDialogEx")

// Flags understood by LaunchSecurityDialog
typedef enum {
    LSDFLAG_DEFAULT    = 0x00000000,
    LSDFLAG_NOADDSITES = 0x00000001,
    LSDFLAG_FORCEUI    = 0x00000002
} LSDFLAG;

typedef BOOL (STDMETHODCALLTYPE * PFNLAUNCHSECURITYDIALOGEX)(
    HWND        hDlg,    // Parent Window
    DWORD       dwZone,  // Initial Zone to display, as defined in urlmon
    DWORD       dwFlags // Initialization flags: or'd combination of LSD_FLAGS
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\pstore.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__

#if _MSC_VER > 1000
#pragma once
#endif

/*
    Typedefs, values
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/*
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/*
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004


//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/*
    Security masks, rule modifiers
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }   PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }   PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }   PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }   PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }   PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }   PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }   PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }   PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif  /* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif  /* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif  /* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif  /* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreItems __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy(
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy(
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo(
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProvParam(
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProvParam(
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumItems(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPStore __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )(
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)  \
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)  \
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)    \
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)    \
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)  \
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags) \
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)  \
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)  \
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)  \
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)  \
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum) \
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)    \
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)  \
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)   \
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)   \
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreProviders __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy(
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1999               **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, LPCSTR pszUsername, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
_inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, &szSup, &cbSize) == ERROR_SUCCESS);
}

#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\regapix.h ===
//
//  REGAPIX.H
//
//  Copyright (C) Microsoft Corporation, 1995-1999
//
//  Public definitions for the VMM registry library (all modes).
//

#ifndef _REGAPIX_
#define _REGAPIX_

#if _MSC_VER > 1000
#pragma once
#endif

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

/*XLATOFF*/
#if defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
#define REGAPI                      WINAPI
#else
#if defined(IS_32)
#ifndef FAR
#define FAR
#endif
#define REGAPI                      __cdecl
#else
#ifndef FAR
#define FAR                         _far
#endif
#define REGAPI                      _far _cdecl
#endif // defined(IS_32)
#endif // defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
/*XLATON*/

#ifndef _REGPRIV_
#ifndef _INC_WINDOWS
typedef DWORD HKEY;
#endif
#endif
typedef HKEY FAR* LPHKEY;

//
//  Predefined key handles.
//

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_CLASSES_ROOT           ((HKEY) 0x80000000)
#define HKEY_CURRENT_USER           ((HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE          ((HKEY) 0x80000002)
#define HKEY_USERS                  ((HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA       ((HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG         ((HKEY) 0x80000005)
#define HKEY_DYN_DATA               ((HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS            7
#endif

//
//  Maximum size of registry data elements.
//

#define MAXIMUM_SUB_KEY_LENGTH      256
#define MAXIMUM_VALUE_NAME_LENGTH   256
#define MAXIMUM_DATA_LENGTH         16384

//
//  Standard data types.
//

#ifndef REG_SZ
#define REG_SZ                      1
#endif

#ifndef REG_BINARY
#define REG_BINARY                  3
#endif

#ifndef REG_DWORD
#define REG_DWORD                   4
#endif

//
//  Registry error codes.
//

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS               0
#endif

#ifndef ERROR_INVALID_FUNCTION
#define ERROR_INVALID_FUNCTION      1
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED         5
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY           14
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED           167
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA             234
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS         259
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                 1009
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY                1010
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN              1011
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD              1012
#endif

#ifndef ERROR_CANTWRITE
#define ERROR_CANTWRITE             1013
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED    1016
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED           1018
#endif

//  Internal registry error codes.  Not exposed to most clients.
#if defined(VXD)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ((ERROR_CANTOPEN << 16) | ERROR_FILE_NOT_FOUND)
#define ERROR_CANTREAD16_FILENOTFOUND32 ((ERROR_CANTREAD << 16) | ERROR_FILE_NOT_FOUND)
#else
#if defined(WIN32)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#else
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_CANTOPEN
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_CANTREAD
#endif
#endif

//
//  Registry application interfaces.
//

/*XLATOFF*/

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    );

VOID
REGAPI
VMMRegLibDetach(
    VOID
    );

/*XLATON*/
#define GRFT_SYSTEM                 0       //  SYSTEM.DAT
#define GRFT_USER                   1       //  USER.DAT
/*XLATOFF*/

BOOL
REGAPI
VMMRegGetRegistryFile(
    char FAR* lpBuffer,
    UINT BufferSize,
    UINT FileType
    );

//  Creates a new registry file.  Fails if the specified file already exists.
#define MPKF_CREATENEW              0x0001

//  If MPKF_VERSION20 is specified, create the file using compact keynodes.
//  Such a file will only be readable by users of this library, not Win95
//  clients.  Use only for system registries (SYSTEM.DAT, USER.DAT).
#define MPKF_VERSION20              0x0002

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    const char FAR* lpFileName,
    UINT Flags
    );

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hSourceKey,
    HKEY hPredefKey
    );

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    void FAR* val_list,
    DWORD num_vals,
    char FAR* lpValueBuffer,
    DWORD FAR* lpdwTotalSize
    );

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD Reserved,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    const char FAR* lpValueName
    );

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    char FAR* lpKeyName,
    DWORD cbKeyName
    );

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    char FAR* lpValueName,
    DWORD FAR* lpcbValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData
    );
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    char FAR* lpClass,
    DWORD FAR* lpcbClass,
    DWORD FAR* lpReserved,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcbMaxClassLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData,
    void FAR* lpcbSecurityDescriptor,
    void FAR* lpftLastWriteTime
    );
#endif

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpFileName
    );

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    const char FAR* lpFileName,
    void FAR* lpSecurityAttributes
    );

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpNewFileName,
    const char FAR* lpOldFileName
    );

//
//  Optional macros for callers (typically 16-bit) that map the registry APIs
//  to the equivalent Win32 API name.
//

#if defined(IS_16) || defined(WANTREGAPIMACROS)
#if !defined(NOREGAPIMACROS) && !defined(SETUPX_INC)
#define RegCreateKey                VMMRegCreateKey
#define RegOpenKey                  VMMRegOpenKey
#define RegCloseKey                 VMMRegCloseKey
#define RegFlushKey                 VMMRegFlushKey
#define RegQueryValue               VMMRegQueryValue
#define RegQueryValueEx             VMMRegQueryValueEx
#define RegQueryMultipleValues      VMMRegQueryMultipleValues
#define RegSetValue                 VMMRegSetValue
#define RegSetValueEx               VMMRegSetValueEx
#define RegDeleteKey                VMMRegDeleteKey
#define RegDeleteValue              VMMRegDeleteValue
#define RegEnumKey                  VMMRegEnumKey
#define RegEnumValue                VMMRegEnumValue
#define RegQueryInfoKey             VMMRegQueryInfoKey
#define RegLoadKey                  VMMRegLoadKey
#define RegUnLoadKey                VMMRegUnLoadKey
#define RegSaveKey                  VMMRegSaveKey
#define RegReplaceKey               VMMRegReplaceKey
#endif
#endif

/*XLATON*/

//
//  Registry services available via VMM's interrupt 2Fh handler.
//

#define RegOpenKey_Idx              0x0100
#define RegCreateKey_Idx            0x0101
#define RegCloseKey_Idx             0x0102
#define RegDeleteKey_Idx            0x0103
#define RegSetValue_Idx             0x0104
#define RegQueryValue_Idx           0x0105
#define RegEnumKey_Idx              0x0106
#define RegDeleteValue_Idx          0x0107
#define RegEnumValue_Idx            0x0108
#define RegQueryValueEx_Idx         0x0109
#define RegSetValueEx_Idx           0x010A
#define RegFlushKey_Idx             0x010B
#define RegLoadKey_Idx              0x010C
#define RegUnLoadKey_Idx            0x010D
#define RegSaveKey_Idx              0x010E
#define RegRestore_Idx              0x010F
#define RegRemapPreDefKey_Idx       0x0110

/*XLATOFF*/
#ifdef __cplusplus
}
#endif
/*XLATON*/

#endif // _REGAPIX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\shlguidp.h ===
#ifndef _SHLGUIDP_H_
#define _SHLGUIDP_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

#ifndef DEFINE_SHLGUID
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
#endif
#if (_WIN32_IE >= 0x0400)
#endif
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IShellIconOverlayManager, 0x63B51F80L, 0xC868, 0x11D0, 0x99, 0x9C, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1);
// {6B707A1C-744F-11d2-86B9-00C04F8EEA99}
DEFINE_GUID(IID_IBrowserBand, 0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

// {95CE8410-7027-11D1-B879-006008059382}
DEFINE_GUID(IID_IShellTreeWalker, 0x95CE8410L, 0x7027, 0x11D1, 0xB8, 0x79, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {95CE8411-7027-11D1-B879-006008059382}
DEFINE_GUID(IID_IShellTreeWalkerCallBack, 0x95CE8411L, 0x7027, 0x11D1, 0xB8, 0x79, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {be1af9f0-b231-11d2-963e-00c04f79adf0}
DEFINE_GUID(IID_IDropTargetWithDADSupport, 0xb0061660, 0xb231, 0x11d2, 0x96, 0x3e, 0x00, 0xc0, 0x4f, 0x79, 0xad, 0xf0);
// {27DC26B1-41B3-11D1-B850-006008059382}
DEFINE_GUID(CLSID_CMultiMonConfig,           0x27DC26B1L, 0x41B3, 0x11D1, 0xB8, 0x50, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {95CE8412-7027-11D1-B879-006008059382}
DEFINE_GUID(CLSID_CShellTreeWalker,          0x95CE8412L, 0x7027, 0x11D1, 0xB8, 0x79, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
#if (_WIN32_IE >= 0x0500)
// {48C8118C-B924-11d1-98D5-00C04FB687DA}
DEFINE_GUID(IID_IShellImageStore,            0x48c8118c, 0xb924, 0x11d1, 0x98, 0xd5, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {6DFD582B-92E3-11d1-98A3-00C04FB687DA}
DEFINE_GUID(IID_IEnumShellImageStore,        0x6dfd582b, 0x92e3, 0x11d1, 0x98, 0xa3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {1EBDCF80-A200-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(CLSID_ShellThumbnailDiskCache,   0x1ebdcf80, 0xa200, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif

// same interface as IID_IExtractImage
// {D4029EC0-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractLogo,                0xd4029ec0, 0x920, 0x11d1, 0x9a, 0xb, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {6CCB7BE0-6807-11d0-B810-00C04FD706EC}
DEFINE_GUID(IID_IShellTaskScheduler,         0x6ccb7be0, 0x6807, 0x11d0, 0xb8, 0x10, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {603D3800-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ShellTaskScheduler,        0x603d3800, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {603D3801-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_SharedTaskScheduler,       0x603d3801, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {3F4EEF80-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ImageListCache,            0x3f4eef80, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {4FCE9180-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IImageCache,                 0x4fce9180, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

#if (_WIN32_IE >= 0x0500)
// {AC3E9E59-96D7-11d1-98A4-00C04FB687DA}
DEFINE_GUID(IID_IImageCache2,                0xac3e9e59, 0x96d7, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {7BB0B520-B1A7-11d2-BB23-00C04F79ABCD}
DEFINE_GUID(IID_IThumbnailView,              0x7bb0b520, 0xb1a7, 0x11d2, 0xbb, 0x23, 0x0, 0xc0, 0x4f, 0x79, 0xab, 0xcd);

#endif

DEFINE_GUID(IID_IMultiMonitorDockingSite, 0x03879DE0L, 0xA205, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1); 
DEFINE_GUID(CGID_AddressEditBox, 0x72730b70, 0xe8f7, 0x11d0, 0xbc, 0x44, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// {27DC26B0-41B3-11D1-B850-006008059382}
DEFINE_GUID(IID_IMultiMonConfig, 0x27DC26B0L, 0x41B3, 0x11D1, 0xB8, 0x50, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {45B324CE-B8A1-11d1-98D3-00C04FB687DA}
DEFINE_GUID(IID_IScaleAndSharpenImage2, 0x45b324ce, 0xb8a1, 0x11d1, 0x98, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {8A4D3EDC-13A4-11d1-9A22-00C04FC2D6C1}
DEFINE_GUID(CLSID_ThumbnailScaler, 0x8a4d3edc, 0x13a4, 0x11d1, 0x9a, 0x22, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {04B3813B-0A23-11d2-B5AC-006097DF5BD4} - For JITting in FTP Shell Extension.
DEFINE_GUID(CLSID_FTPShellExtension, 0x4b3813b, 0xa23, 0x11d2, 0xb5, 0xac, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {????} - For JITting in HTML Help Feature
DEFINE_GUID(CLSID_IEHelp, 0x45ea75a0L, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

#define CGID_ShellToolband IID_IDeskBand  //
#endif // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IShellDetails2,         0xb1223e01, 0xb1db, 0x11d0, 0x82, 0xcc, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);
DEFINE_GUID(IID_IDeskBar,               0xEB0FE173L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
DEFINE_GUID(IID_IDeskBarClient,         0xEB0FE175L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
DEFINE_GUID(IID_IBandSite,              0x4CF504B0L, 0xDE96, 0x11D0, 0x8B, 0x3F, 0x00, 0xA0, 0xC9, 0x11, 0xE8, 0xE5);
DEFINE_GUID(IID_IWinEventHandler,       0xEA5F2D61L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);
#define SID_SBandSite IID_IBandSite

#define CGID_BandSite  IID_IBandSite
#define CGID_DeskBar  IID_IDeskBar
#define CGID_DeskBarClient IID_IDeskBarClient

// These can probably move back to shell\inc\shellp.h...
DEFINE_GUID(SID_DefView,                0x6D12FE80, 0x7911, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);
DEFINE_GUID(CGID_DefView,               0x4af07f10, 0xd231, 0x11d0, 0xb9, 0x42, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

DEFINE_GUID(CLSID_MenuBand,             0x5b4dae26, 0xb807, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
#define CLSID_ShellMenu CLSID_MenuBand

// {568804CD-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_IMenuBand,                  0x568804cd, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {EE1F7637-E138-11d1-8379-00C04FD918D0}
DEFINE_GUID(IID_IShellMenu,                 0xee1f7637, 0xe138, 0x11d1, 0x83, 0x79, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {4CA300A1-9B8D-11d1-8B22-00C04FD918D0}
DEFINE_GUID(IID_IShellMenuCallback,         0x4ca300a1, 0x9b8d, 0x11d1, 0x8b, 0x22, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {8278F931-2A3E-11d2-838F-00C04FD918D0}
DEFINE_GUID(CLSID_TrackShellMenu, 
0x8278f931, 0x2a3e, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {8278F932-2A3E-11d2-838F-00C04FD918D0}
DEFINE_GUID(IID_ITrackShellMenu, 
0x8278f932, 0x2a3e, 0x11d2, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {0D14E31C-D8C0-11d0-9816-00C04FD91972}
DEFINE_GUID(SID_SMenuBandHandler,           0xd14e31c, 0xd8c0, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

DEFINE_GUID(IID_IAddressBand,           0x106E86E1, 0x52B5, 0x11D0, 0xBF, 0xED, 0x0, 0xAA, 0x0, 0x5B, 0x43, 0x83);

/// AddressEditBox stuff
// {A08C11D1-A228-11d0-825B-00AA005B4383}
DEFINE_GUID(IID_IAddressEditBox, 0xa08c11d1, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
DEFINE_GUID(CLSID_AddressEditBox,0xa08c11d2, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);


// {D12F26B1-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(IID_IRestrict, 0xd12f26b1, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B2-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(SID_SRestrictionHandler, 0xd12f26b2, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B3-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(RID_RDeskBars, 0xd12f26b3, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// IShellFolderBand stuff
// {7FE80CC8-C247-11d0-B93A-00A0C90312E1}
DEFINE_GUID(IID_IShellFolderBand, 0x7fe80cc8, 0xc247, 0x11d0, 0xb9, 0x3a, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
#define CGID_ShellFolderBand    IID_IShellFolderBand

// favorites band
// {EFA24E61-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_FavBand,              0xefa24e61, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// history band
// {EFA24E62-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_HistBand,              0xefa24e62, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// channels band
// {EFA24E63-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ChannelBand,          0xefa24e63, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// IQueryCodePage {C7B236CE-EE80-11D0-985F-006008059382}
DEFINE_GUID(IID_IQueryCodePage, 0xC7B236CEL, 0xEE80, 0x11D0, 0x98, 0x5F, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

#if (_WIN32_IE >= 0x0500)
// 37A378C0-F82D-11CE-AE65-08002B2E1262
DEFINE_GUID(IID_IShellFolderView, 0x37A378C0L, 0xF82D, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 3D8ECEA0-0242-11CF-AE65-08002B2E1262
DEFINE_GUID(IID_IEnumSFVViews, 0x3D8ECEA0L, 0x0242, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// D5E37E20-0257-11CF-AE65-08002B2E1262
DEFINE_GUID(IID_IPersistString, 0xD5E37E20L, 0x0257, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {8210BAC0-C6D2-11cf-89AA-00A0C9054129}
DEFINE_GUID(IID_IDefViewExtInit, 0x8210bac0, 0xc6d2, 0x11cf, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
// {2CEB7CB2-E64C-11d2-9652-00C04FC30871}
DEFINE_GUID(IID_IDefViewExtInit2, 0x2ceb7cb2, 0xe64c, 0x11d2, 0x96, 0x52, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);


// 710EB7A0-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(IID_IDefViewFrame, 0x710EB7A0L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);


// 710EB7A1-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(IID_IDefViewFrame2, 0x710EB7A1L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);

#endif // _WIN32_IE >= 0x0500

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

//
//  When the browser is navigating to a document, we call IBC::SetObjectParam
// with "{d4db6850-5385-11d0-89e9-00a0c90a90ac}" so that the DocObject can get
// to the client site while processing IPersistMoniker::Load.
//
#define WSZGUID_OPID_DocObjClientSite L"{d4db6850-5385-11d0-89e9-00a0c90a90ac}"
DEFINE_GUID(OPID_DobObjClientSite,0xd4db6850L, 0x5385, 0x11d0, 0x89, 0xe9, 0x00, 0xa0, 0xc9, 0x0a, 0x90, 0xac);
#endif // _WIN32_IE >= 0x0400

// 0057D0E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_LargeIcons, 0x0057D0E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 089000C0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_SmallIcons, 0x089000C0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 0E1FA5E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_List      , 0x0E1FA5E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 137E7700-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_Details   , 0x137E7700L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 5984FFE0-28D4-11CF-AE66-08002B2E1262
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(VID_WebView, 0x5984FFE0L, 0x28D4, 0x11CF, 0xAE, 0x66, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {BE098140-A513-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(VID_FolderState, 0xbe098140, 0xa513, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif // _WIN32_IE >= 0x0400
// To keep people from breaking, let the old misnamed dudes work
#define IID_IShellExplorer        IID_IWebBrowser
#define DIID_DShellExplorerEvents DIID_DWebBrowserEvents
#define CLSID_ShellExplorer       CLSID_WebBrowser
#define IID_DIExplorer            IID_IWebBrowserApp
#define DIID_DExplorerEvents      DIID_DInternetExplorer
#if (_WIN32_IE >= 0x0400)
#define DIID_DInternetExplorerEvents DIID_DWebBrowserEvents
#define DInternetExplorerEvents DWebBrowserEvents
#define IID_IInternetExplorer IID_IWebBrowserApp

// Thumbnail Guids
DEFINE_GUID(IID_IThumbnail,             0x6d45a930L, 0xf71a, 0x11d0, 0x9e, 0xa7, 0x00, 0x80, 0x5f, 0x71, 0x47, 0x72);
DEFINE_GUID(CLSID_Thumbnail,            0x7487cd30L, 0xf71a, 0x11d0, 0x9e, 0xa7, 0x00, 0x80, 0x5f, 0x71, 0x47, 0x72);
#endif // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0400)

// 266F5E60-80E6-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellTargetFrame, 0x266F5E60L, 0x80E6, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

//B091E540-83E3-11CF-A713-0020AFD79762
DEFINE_GUID(CLSID_FileTypes, 0xB091E540, 0x83E3, 0x11CF, 0xA7,0x13,0x00,0x20,0xAF,0xD7,0x97,0x62);

// CShellList implementation
//
// {FC2A24F0-5876-11d0-97D8-00C04FD91972}
DEFINE_GUID(CLSID_CShellList, 0xfc2a24f0, 0x5876, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {FE5C88F4-587F-11d0-97D8-00C04FD91972}
DEFINE_GUID(IID_IShellList, 0xfe5c88f4, 0x587f, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {FE5C88F5-587F-11d0-97D8-00C04FD91972}
DEFINE_GUID(IID_IShellListSink, 0xfe5c88f5, 0x587f, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);


#endif

#if (_WIN32_IE >= 0x0300)
// {05f6fe1a-ecef-11d0-aae7-00c04fc9b304}
DEFINE_GUID( CLSID_IntDitherer, 0x05f6fe1a, 0xecef, 0x11d0, 0xaa, 0xe7, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x04 );

// {06670ca0-ecef-11d0-aae7-00c04fc9b304}
DEFINE_GUID( IID_IIntDitherer, 0x06670ca0, 0xecef, 0x11d0, 0xaa, 0xe7, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x04 );

#endif // _WIN32_IE >= 0x0300

#if (_WIN32_IE >= 0x0400)
// {52502EE0-EC80-11D0-89AB-00C04FC2972D}
DEFINE_GUID(IID_IActiveDesktopP, 0x52502EE0L, 0xEC80, 0x11D0, 0x89, 0xAB, 0x00, 0xC0, 0x4F, 0xC2, 0x97, 0x2D);

// {B22754E2-4574-11d1-9888-006097DEACF9}
DEFINE_GUID(IID_IADesktopP2, 0xb22754e2, 0x4574, 0x11d1, 0x98, 0x88, 0x0, 0x60, 0x97, 0xde, 0xac, 0xf9);

// {f39a0dc0-9cc8-11d0-a599-00c04fd64433}
DEFINE_GUID(CLSID_CDFView, 0xf39a0dc0L, 0x9cc8, 0x11d0, 0xa5, 0x99, 0x00, 0xc0, 0x4f, 0xd6, 0x44, 0x33);
#endif  // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0500)
//  MonikerHelper is currently internal only.
// {679d9e36-f8f9-11d2-8deb-00c04f6837d5}
DEFINE_GUID(IID_IMonikerHelper, 0x679d9e36, 0xf8f9, 0x11d2, 0x8d, 0xeb, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// {679d9e37-f8f9-11d2-8deb-00c04f6837d5}
DEFINE_GUID(CLSID_CShellMonikerHelper, 0x679d9e37, 0xf8f9, 0x11d2, 0x8d, 0xeb, 0x00, 0xc0, 0x4f, 0x68, 0x37, 0xd5);

// Define the CLSID for local and net users prop pages
// {D707877E-4D9C-11d2-8784-F6E920524153}
DEFINE_GUID(CLSID_UserPropertyPages, 
0xd707877e, 0x4d9c, 0x11d2, 0x87, 0x84, 0xf6, 0xe9, 0x20, 0x52, 0x41, 0x53);

// IOleCommandTarget arugments for the Network Connections Folder.
// {EAF70CE4-B521-11d1-B550-00C04FD918D0}
DEFINE_GUID(CGID_ConnectionsFolder, 
    0xeaf70ce4, 0xb521, 0x11d1, 0xb5, 0x50, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {C0A651F5-B48B-11d2-B5ED-006097C686F6}
DEFINE_GUID(IID_IShellFolderFilterSite,  0xc0a651f5, 0xb48b, 0x11d2, 0xb5, 0xed, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);
// {9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E}
DEFINE_GUID(IID_IShellFolderFilter,		 0x9cc22886, 0xdc8e, 0x11d2, 0xb1, 0xd0, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e);

// {A470F8CF-A1E8-4f65-8335-227475AA5C46}
DEFINE_GUID(CLSID_EncryptionContextMenuHandler, 0xa470f8cf, 0xa1e8, 0x4f65, 0x83, 0x35, 0x22, 0x74, 0x75, 0xAA, 0x5C, 0x46);
#endif // _WIN32_IE >= 0x0500
#endif // _SHLGUIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\shlwapi.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/


#ifndef _INC_SHLWAPI
#define _INC_SHLWAPI

#ifndef NOSHLWAPI

#include <objbase.h>

#ifndef _WINRESRC_
#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif
#endif


#ifdef UNIX
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
typedef interface IInternetSecurityManager IInternetSecurityManager;
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHLWAPI
#if !defined(_SHLWAPI_)
#define LWSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define LWSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define LWSTDAPIV         EXTERN_C DECLSPEC_IMPORT HRESULT STDAPIVCALLTYPE
#define LWSTDAPIV_(type)  EXTERN_C DECLSPEC_IMPORT type STDAPIVCALLTYPE
#else
#define LWSTDAPI          STDAPI
#define LWSTDAPI_(type)   STDAPI_(type)
#define LWSTDAPIV         STDAPIV
#define LWSTDAPIV_(type)  STDAPIV_(type)
#endif
#endif // WINSHLWAPI

#ifdef _WIN32
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_GDI        GDI helper functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

LWSTDAPI_(LPSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrIW(LPCWSTR lpStart, WCHAR wMatch);
LWSTDAPI_(int)      StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCSpnA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(LPSTR)    StrDupA(LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrDupW(LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrFormatByteSizeA(DWORD dw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPSTR)    StrFormatByteSize64A(LONGLONG qdw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPWSTR)   StrFormatByteSizeW(LONGLONG qdw, LPWSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPWSTR)   StrFormatKBSizeW(LONGLONG qdw, LPWSTR szBuf, UINT uiBufSize);
LWSTDAPI_(LPSTR)    StrFormatKBSizeA(LONGLONG qdw, LPSTR szBuf, UINT uiBufSize);
LWSTDAPI_(int)      StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(int)      StrFromTimeIntervalW(LPWSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(BOOL)     StrIsIntlEqualA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     StrIsIntlEqualW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);
LWSTDAPI_(LPSTR)    StrNCatA(LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrNCatW(LPWSTR psz1, LPCWSTR psz2, int cchMax);
LWSTDAPI_(LPSTR)    StrPBrkA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(LPWSTR)   StrPBrkW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch);
LWSTDAPI_(LPSTR)    StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrSpnA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(int)      StrSpnW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(LPSTR)    StrStrA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrToIntA(LPCSTR lpSrc);
LWSTDAPI_(int)      StrToIntW(LPCWSTR lpSrc);
LWSTDAPI_(BOOL)     StrToIntExA(LPCSTR pszString, DWORD dwFlags, int * piRet);
LWSTDAPI_(BOOL)     StrToIntExW(LPCWSTR pszString, DWORD dwFlags, int * piRet);
LWSTDAPI_(BOOL)     StrTrimA(LPSTR psz, LPCSTR pszTrimChars);
LWSTDAPI_(BOOL)     StrTrimW(LPWSTR psz, LPCWSTR pszTrimChars);

LWSTDAPI_(LPWSTR)   StrCatW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(int)      StrCmpIW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax);

LWSTDAPI_(LPWSTR)   StrCatBuffW(LPWSTR pszDest, LPCWSTR pszSrc, int cchDestBuffSize);
LWSTDAPI_(LPSTR)    StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize);

LWSTDAPI_(BOOL)     ChrCmpIA(WORD w1, WORD w2);
LWSTDAPI_(BOOL)     ChrCmpIW(WCHAR w1, WCHAR w2);

LWSTDAPI_(int)      wvnsprintfA(LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, va_list arglist);
LWSTDAPI_(int)      wvnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list arglist);
LWSTDAPIV_(int)     wnsprintfA(LPSTR lpOut, int cchLimitIn, LPCSTR lpFmt, ...);
LWSTDAPIV_(int)     wnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ...);

#define StrIntlEqNA( s1, s2, nChar) StrIsIntlEqualA( TRUE, s1, s2, nChar)
#define StrIntlEqNW( s1, s2, nChar) StrIsIntlEqualW( TRUE, s1, s2, nChar)
#define StrIntlEqNIA(s1, s2, nChar) StrIsIntlEqualA(FALSE, s1, s2, nChar)
#define StrIntlEqNIW(s1, s2, nChar) StrIsIntlEqualW(FALSE, s1, s2, nChar)

LWSTDAPI StrRetToStrA(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPSTR *ppsz);
LWSTDAPI StrRetToStrW(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPWSTR *ppsz);
#ifdef UNICODE
#define StrRetToStr  StrRetToStrW
#else
#define StrRetToStr  StrRetToStrA
#endif // !UNICODE
LWSTDAPI StrRetToBufA(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI StrRetToBufW(struct _STRRET *pstr, const UNALIGNED struct _ITEMIDLIST *pidl, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define StrRetToBuf  StrRetToBufW
#else
#define StrRetToBuf  StrRetToBufA
#endif // !UNICODE

// helper to duplicate a string using the task allocator

LWSTDAPI SHStrDupA(LPCSTR psz, WCHAR **ppwsz);
LWSTDAPI SHStrDupW(LPCWSTR psz, WCHAR **ppwsz);
#ifdef UNICODE
#define SHStrDup  SHStrDupW
#else
#define SHStrDup  SHStrDupA
#endif // !UNICODE



#ifdef UNICODE
#define StrChr                  StrChrW
#define StrRChr                 StrRChrW
#define StrChrI                 StrChrIW
#define StrRChrI                StrRChrIW
#define StrCmpN                 StrCmpNW
#define StrCmpNI                StrCmpNIW
#define StrStr                  StrStrW
#define StrStrI                 StrStrIW
#define StrDup                  StrDupW
#define StrRStrI                StrRStrIW
#define StrCSpn                 StrCSpnW
#define StrCSpnI                StrCSpnIW
#define StrSpn                  StrSpnW
#define StrToInt                StrToIntW
#define StrPBrk                 StrPBrkW
#define StrToIntEx              StrToIntExW
#define StrFromTimeInterval     StrFromTimeIntervalW
#define StrIntlEqN              StrIntlEqNW
#define StrIntlEqNI             StrIntlEqNIW
#define StrFormatByteSize       StrFormatByteSizeW
#define StrFormatByteSize64     StrFormatByteSizeW
#define StrFormatKBSize         StrFormatKBSizeW
#define StrNCat                 StrNCatW
#define StrTrim                 StrTrimW
#define StrCatBuff              StrCatBuffW
#define ChrCmpI                 ChrCmpIW
#define wvnsprintf              wvnsprintfW
#define wnsprintf               wnsprintfW
#define StrIsIntlEqual          StrIsIntlEqualW


#else
#define StrChr                  StrChrA
#define StrRChr                 StrRChrA
#define StrChrI                 StrChrIA
#define StrRChrI                StrRChrIA
#define StrCmpN                 StrCmpNA
#define StrCmpNI                StrCmpNIA
#define StrStr                  StrStrA
#define StrStrI                 StrStrIA
#define StrDup                  StrDupA
#define StrRStrI                StrRStrIA
#define StrCSpn                 StrCSpnA
#define StrCSpnI                StrCSpnIA
#define StrSpn                  StrSpnA
#define StrToInt                StrToIntA
#define StrPBrk                 StrPBrkA
#define StrToIntEx              StrToIntExA
#define StrFromTimeInterval     StrFromTimeIntervalA
#define StrIntlEqN              StrIntlEqNA
#define StrIntlEqNI             StrIntlEqNIA
#define StrFormatByteSize       StrFormatByteSizeA
#define StrFormatByteSize64     StrFormatByteSize64A
#define StrFormatKBSize         StrFormatKBSizeA
#define StrNCat                 StrNCatA
#define StrTrim                 StrTrimA
#define StrCatBuff              StrCatBuffA
#define ChrCmpI                 ChrCmpIA
#define wvnsprintf              wvnsprintfA
#define wnsprintf               wnsprintfA
#define StrIsIntlEqual          StrIsIntlEqualA
#endif


// Backward compatible to NT's non-standard naming (strictly
// for comctl32)
//
LWSTDAPI_(BOOL)     IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);

#define IntlStrEqNA( s1, s2, nChar) IntlStrEqWorkerA( TRUE, s1, s2, nChar)
#define IntlStrEqNW( s1, s2, nChar) IntlStrEqWorkerW( TRUE, s1, s2, nChar)
#define IntlStrEqNIA(s1, s2, nChar) IntlStrEqWorkerA(FALSE, s1, s2, nChar)
#define IntlStrEqNIW(s1, s2, nChar) IntlStrEqWorkerW(FALSE, s1, s2, nChar)

#ifdef UNICODE
#define IntlStrEqN              IntlStrEqNW
#define IntlStrEqNI             IntlStrEqNIW
#else
#define IntlStrEqN              IntlStrEqNA
#define IntlStrEqNI             IntlStrEqNIA
#endif

#define SZ_CONTENTTYPE_HTMLA       "text/html"
#define SZ_CONTENTTYPE_HTMLW       L"text/html"
#define SZ_CONTENTTYPE_CDFA        "application/x-cdf"
#define SZ_CONTENTTYPE_CDFW        L"application/x-cdf"

#ifdef UNICODE
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLW
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFW
#else
#define SZ_CONTENTTYPE_HTML     SZ_CONTENTTYPE_HTMLA
#define SZ_CONTENTTYPE_CDF      SZ_CONTENTTYPE_CDFA
#endif

#define PathIsHTMLFileA(pszPath)     PathIsContentTypeA(pszPath, SZ_CONTENTTYPE_HTMLA)
#define PathIsHTMLFileW(pszPath)     PathIsContentTypeW(pszPath, SZ_CONTENTTYPE_HTMLW)

// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L


#define StrCatA                 lstrcatA
#define StrCmpA                 lstrcmpA
#define StrCmpIA                lstrcmpiA
#define StrCpyA                 lstrcpyA
#define StrCpyNA                lstrcpynA


#define StrToLong               StrToInt
#define StrNCmp                 StrCmpN
#define StrNCmpI                StrCmpNI
#define StrNCpy                 StrCpyN
#define StrCatN                 StrNCat

#ifdef UNICODE
#define StrCat                  StrCatW
#define StrCmp                  StrCmpW
#define StrCmpI                 StrCmpIW
#define StrCpy                  StrCpyW
#define StrCpyN                 StrCpyNW
#define StrCatBuff              StrCatBuffW
#else
#define StrCat                  lstrcatA
#define StrCmp                  lstrcmpA
#define StrCmpI                 lstrcmpiA
#define StrCpy                  lstrcpyA
#define StrCpyN                 lstrcpynA
#define StrCatBuff              StrCatBuffA
#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//

LWSTDAPI_(LPSTR)  PathAddBackslashA(LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathAddBackslashW(LPWSTR pszPath);
#ifdef UNICODE
#define PathAddBackslash  PathAddBackslashW
#else
#define PathAddBackslash  PathAddBackslashA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAddExtensionA(LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathAddExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
#ifdef UNICODE
#define PathAddExtension  PathAddExtensionW
#else
#define PathAddExtension  PathAddExtensionA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathAppendA(LPSTR pszPath, LPCSTR pMore);
LWSTDAPI_(BOOL)     PathAppendW(LPWSTR pszPath, LPCWSTR pMore);
LWSTDAPI_(LPSTR)  PathBuildRootA(LPSTR pszRoot, int iDrive);
LWSTDAPI_(LPWSTR)  PathBuildRootW(LPWSTR pszRoot, int iDrive);
#ifdef UNICODE
#define PathBuildRoot  PathBuildRootW
#else
#define PathBuildRoot  PathBuildRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCanonicalizeA(LPSTR pszBuf, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathCanonicalizeW(LPWSTR pszBuf, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathCombineA(LPSTR pszDest, LPCSTR pszDir, LPCSTR pszFile);
LWSTDAPI_(LPWSTR)  PathCombineW(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
#ifdef UNICODE
#define PathCombine  PathCombineW
#else
#define PathCombine  PathCombineA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathCompactPathA(HDC hDC, LPSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathW(HDC hDC, LPWSTR pszPath, UINT dx);
LWSTDAPI_(BOOL)     PathCompactPathExA(LPSTR pszOut, LPCSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(BOOL)     PathCompactPathExW(LPWSTR pszOut, LPCWSTR pszSrc, UINT cchMax, DWORD dwFlags);
LWSTDAPI_(int)      PathCommonPrefixA(LPCSTR pszFile1, LPCSTR pszFile2, LPSTR achPath);
LWSTDAPI_(int)      PathCommonPrefixW(LPCWSTR pszFile1, LPCWSTR pszFile2, LPWSTR achPath);
LWSTDAPI_(BOOL)     PathFileExistsA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathFileExistsW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFileExists  PathFileExistsW
#else
#define PathFileExists  PathFileExistsA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindExtensionA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindExtensionW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindExtension  PathFindExtensionW
#else
#define PathFindExtension  PathFindExtensionA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindFileNameA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindFileNameW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindFileName  PathFindFileNameW
#else
#define PathFindFileName  PathFindFileNameA
#endif // !UNICODE
LWSTDAPI_(LPSTR)  PathFindNextComponentA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathFindNextComponentW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathFindNextComponent  PathFindNextComponentW
#else
#define PathFindNextComponent  PathFindNextComponentA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathFindOnPathA(LPSTR pszPath, LPCSTR * ppszOtherDirs);
LWSTDAPI_(BOOL)     PathFindOnPathW(LPWSTR pszPath, LPCWSTR * ppszOtherDirs);
LWSTDAPI_(LPSTR)  PathGetArgsA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathGetArgsW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetArgs  PathGetArgsW
#else
#define PathGetArgs  PathGetArgsA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) PathFindSuffixArrayA(LPCSTR pszPath, const LPCSTR *apszSuffix, int iArraySize);
LWSTDAPI_(LPCWSTR) PathFindSuffixArrayW(LPCWSTR pszPath, const LPCWSTR *apszSuffix, int iArraySize);
#ifdef UNICODE
#define PathFindSuffixArray  PathFindSuffixArrayW
#else
#define PathFindSuffixArray  PathFindSuffixArrayA
#endif // !UNICODE
STDAPI_(BOOL)       PathIsLFNFileSpecA(LPCSTR lpName);
STDAPI_(BOOL)       PathIsLFNFileSpecW(LPCWSTR lpName);
#ifdef UNICODE
#define PathIsLFNFileSpec  PathIsLFNFileSpecW
#else
#define PathIsLFNFileSpec  PathIsLFNFileSpecA
#endif // !UNICODE

LWSTDAPI_(UINT)     PathGetCharTypeA(UCHAR ch);
LWSTDAPI_(UINT)     PathGetCharTypeW(WCHAR ch);

// Return flags for PathGetCharType
#define GCT_INVALID             0x0000
#define GCT_LFNCHAR             0x0001
#define GCT_SHORTCHAR           0x0002
#define GCT_WILD                0x0004
#define GCT_SEPARATOR           0x0008

LWSTDAPI_(int)      PathGetDriveNumberA(LPCSTR pszPath);
LWSTDAPI_(int)      PathGetDriveNumberW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathGetDriveNumber  PathGetDriveNumberW
#else
#define PathGetDriveNumber  PathGetDriveNumberA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectory  PathIsDirectoryW
#else
#define PathIsDirectory  PathIsDirectoryA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsDirectoryEmptyW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyW
#else
#define PathIsDirectoryEmpty  PathIsDirectoryEmptyA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsFileSpecA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsFileSpecW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsFileSpec  PathIsFileSpecW
#else
#define PathIsFileSpec  PathIsFileSpecA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsPrefixA(LPCSTR pszPrefix, LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsPrefixW(LPCWSTR pszPrefix, LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsPrefix  PathIsPrefixW
#else
#define PathIsPrefix  PathIsPrefixA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRelativeA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRelativeW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRelative  PathIsRelativeW
#else
#define PathIsRelative  PathIsRelativeA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsRootA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsRoot  PathIsRootW
#else
#define PathIsRoot  PathIsRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSameRootA(LPCSTR pszPath1, LPCSTR pszPath2);
LWSTDAPI_(BOOL)     PathIsSameRootW(LPCWSTR pszPath1, LPCWSTR pszPath2);
#ifdef UNICODE
#define PathIsSameRoot  PathIsSameRootW
#else
#define PathIsSameRoot  PathIsSameRootA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNC  PathIsUNCW
#else
#define PathIsUNC  PathIsUNCA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsNetworkPathA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsNetworkPathW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsNetworkPath  PathIsNetworkPathW
#else
#define PathIsNetworkPath  PathIsNetworkPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServer  PathIsUNCServerW
#else
#define PathIsUNCServer  PathIsUNCServerA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsUNCServerShareA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsUNCServerShareW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsUNCServerShare  PathIsUNCServerShareW
#else
#define PathIsUNCServerShare  PathIsUNCServerShareA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsContentTypeA(LPCSTR pszPath, LPCSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsContentTypeW(LPCWSTR pszPath, LPCWSTR pszContentType);
LWSTDAPI_(BOOL)     PathIsURLA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathIsURLW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsURL  PathIsURLW
#else
#define PathIsURL  PathIsURLA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathMakePrettyA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathMakePrettyW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathMatchSpecA(LPCSTR pszFile, LPCSTR pszSpec);
LWSTDAPI_(BOOL)     PathMatchSpecW(LPCWSTR pszFile, LPCWSTR pszSpec);
LWSTDAPI_(int)      PathParseIconLocationA(LPSTR pszIconFile);
LWSTDAPI_(int)      PathParseIconLocationW(LPWSTR pszIconFile);
LWSTDAPI_(void)     PathQuoteSpacesA(LPSTR lpsz);
LWSTDAPI_(void)     PathQuoteSpacesW(LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathRelativePathToA(LPSTR pszPath, LPCSTR pszFrom, DWORD dwAttrFrom, LPCSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(BOOL)     PathRelativePathToW(LPWSTR pszPath, LPCWSTR pszFrom, DWORD dwAttrFrom, LPCWSTR pszTo, DWORD dwAttrTo);
LWSTDAPI_(void)     PathRemoveArgsA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveArgsW(LPWSTR pszPath);
LWSTDAPI_(LPSTR)  PathRemoveBackslashA(LPSTR pszPath);
LWSTDAPI_(LPWSTR)  PathRemoveBackslashW(LPWSTR pszPath);
#ifdef UNICODE
#define PathRemoveBackslash  PathRemoveBackslashW
#else
#define PathRemoveBackslash  PathRemoveBackslashA
#endif // !UNICODE
LWSTDAPI_(void)     PathRemoveBlanksA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveBlanksW(LPWSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionA(LPSTR pszPath);
LWSTDAPI_(void)     PathRemoveExtensionW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathRemoveFileSpecW(LPWSTR pszPath);
LWSTDAPI_(BOOL)     PathRenameExtensionA(LPSTR pszPath, LPCSTR pszExt);
LWSTDAPI_(BOOL)     PathRenameExtensionW(LPWSTR pszPath, LPCWSTR pszExt);
LWSTDAPI_(BOOL)     PathSearchAndQualifyA(LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathSearchAndQualifyW(LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
LWSTDAPI_(void)     PathSetDlgItemPathA(HWND hDlg, int id, LPCSTR pszPath);
LWSTDAPI_(void)     PathSetDlgItemPathW(HWND hDlg, int id, LPCWSTR pszPath);
LWSTDAPI_(LPSTR)  PathSkipRootA(LPCSTR pszPath);
LWSTDAPI_(LPWSTR)  PathSkipRootW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathSkipRoot  PathSkipRootW
#else
#define PathSkipRoot  PathSkipRootA
#endif // !UNICODE
LWSTDAPI_(void)     PathStripPathA(LPSTR pszPath);
LWSTDAPI_(void)     PathStripPathW(LPWSTR pszPath);
#ifdef UNICODE
#define PathStripPath  PathStripPathW
#else
#define PathStripPath  PathStripPathA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathStripToRootA(LPSTR pszPath);
LWSTDAPI_(BOOL)     PathStripToRootW(LPWSTR pszPath);
#ifdef UNICODE
#define PathStripToRoot  PathStripToRootW
#else
#define PathStripToRoot  PathStripToRootA
#endif // !UNICODE
LWSTDAPI_(void)     PathUnquoteSpacesA(LPSTR lpsz);
LWSTDAPI_(void)     PathUnquoteSpacesW(LPWSTR lpsz);
LWSTDAPI_(BOOL)     PathMakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathMakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathMakeSystemFolder  PathMakeSystemFolderW
#else
#define PathMakeSystemFolder  PathMakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderA(LPCSTR pszPath);
LWSTDAPI_(BOOL)     PathUnmakeSystemFolderW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderW
#else
#define PathUnmakeSystemFolder  PathUnmakeSystemFolderA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathIsSystemFolderA(LPCSTR pszPath, DWORD dwAttrb);
LWSTDAPI_(BOOL)     PathIsSystemFolderW(LPCWSTR pszPath, DWORD dwAttrb);
#ifdef UNICODE
#define PathIsSystemFolder  PathIsSystemFolderW
#else
#define PathIsSystemFolder  PathIsSystemFolderA
#endif // !UNICODE
LWSTDAPI_(void)     PathUndecorateA(LPSTR pszPath);
LWSTDAPI_(void)     PathUndecorateW(LPWSTR pszPath);
#ifdef UNICODE
#define PathUndecorate  PathUndecorateW
#else
#define PathUndecorate  PathUndecorateA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsA(LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsW(LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsW
#else
#define PathUnExpandEnvStrings  PathUnExpandEnvStringsA
#endif // !UNICODE


#ifdef UNICODE
#define PathAppend              PathAppendW
#define PathCanonicalize        PathCanonicalizeW
#define PathCompactPath         PathCompactPathW
#define PathCompactPathEx       PathCompactPathExW
#define PathCommonPrefix        PathCommonPrefixW
#define PathFindOnPath          PathFindOnPathW
#define PathGetCharType         PathGetCharTypeW
#define PathIsContentType       PathIsContentTypeW
#define PathIsHTMLFile          PathIsHTMLFileW
#define PathMakePretty          PathMakePrettyW
#define PathMatchSpec           PathMatchSpecW
#define PathParseIconLocation   PathParseIconLocationW
#define PathQuoteSpaces         PathQuoteSpacesW
#define PathRelativePathTo      PathRelativePathToW
#define PathRemoveArgs          PathRemoveArgsW
#define PathRemoveBlanks        PathRemoveBlanksW
#define PathRemoveExtension     PathRemoveExtensionW
#define PathRemoveFileSpec      PathRemoveFileSpecW
#define PathRenameExtension     PathRenameExtensionW
#define PathSearchAndQualify    PathSearchAndQualifyW
#define PathSetDlgItemPath      PathSetDlgItemPathW
#define PathUnquoteSpaces       PathUnquoteSpacesW
#else
#define PathAppend              PathAppendA
#define PathCanonicalize        PathCanonicalizeA
#define PathCompactPath         PathCompactPathA
#define PathCompactPathEx       PathCompactPathExA
#define PathCommonPrefix        PathCommonPrefixA
#define PathFindOnPath          PathFindOnPathA
#define PathGetCharType         PathGetCharTypeA
#define PathIsContentType       PathIsContentTypeA
#define PathIsHTMLFile          PathIsHTMLFileA
#define PathMakePretty          PathMakePrettyA
#define PathMatchSpec           PathMatchSpecA
#define PathParseIconLocation   PathParseIconLocationA
#define PathQuoteSpaces         PathQuoteSpacesA
#define PathRelativePathTo      PathRelativePathToA
#define PathRemoveArgs          PathRemoveArgsA
#define PathRemoveBlanks        PathRemoveBlanksA
#define PathRemoveExtension     PathRemoveExtensionA
#define PathRemoveFileSpec      PathRemoveFileSpecA
#define PathRenameExtension     PathRenameExtensionA
#define PathSearchAndQualify    PathSearchAndQualifyA
#define PathSetDlgItemPath      PathSetDlgItemPathA
#define PathUnquoteSpaces       PathUnquoteSpacesA
#endif

typedef enum {
    URL_SCHEME_INVALID     = -1,
    URL_SCHEME_UNKNOWN     =  0,
    URL_SCHEME_FTP,
    URL_SCHEME_HTTP,
    URL_SCHEME_GOPHER,
    URL_SCHEME_MAILTO,
    URL_SCHEME_NEWS,
    URL_SCHEME_NNTP,
    URL_SCHEME_TELNET,
    URL_SCHEME_WAIS,
    URL_SCHEME_FILE,
    URL_SCHEME_MK,
    URL_SCHEME_HTTPS,
    URL_SCHEME_SHELL,
    URL_SCHEME_SNEWS,
    URL_SCHEME_LOCAL,
    URL_SCHEME_JAVASCRIPT,
    URL_SCHEME_VBSCRIPT,
    URL_SCHEME_ABOUT,
    URL_SCHEME_RES,
    URL_SCHEME_MAXVALUE
} URL_SCHEME;

typedef enum {
    URL_PART_NONE       = 0,
    URL_PART_SCHEME     = 1,
    URL_PART_HOSTNAME,
    URL_PART_USERNAME,
    URL_PART_PASSWORD,
    URL_PART_PORT,
    URL_PART_QUERY,
} URL_PART;

typedef enum {
    URLIS_URL,
    URLIS_OPAQUE,
    URLIS_NOHISTORY,
    URLIS_FILEURL,
    URLIS_APPLIABLE,
    URLIS_DIRECTORY,
    URLIS_HASQUERY,
} URLIS;

#define URL_UNESCAPE                    0x10000000
#define URL_ESCAPE_UNSAFE               0x20000000
#define URL_PLUGGABLE_PROTOCOL          0x40000000
#define URL_WININET_COMPATIBILITY       0x80000000
#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_ESCAPE_SPACES_ONLY          0x04000000
#define URL_DONT_SIMPLIFY               0x08000000
#define URL_NO_META                     URL_DONT_SIMPLIFY
#define URL_UNESCAPE_INPLACE            0x00100000
#define URL_CONVERT_IF_DOSPATH          0x00200000
#define URL_UNESCAPE_HIGH_ANSI_ONLY     0x00400000
#define URL_INTERNAL_PATH               0x00800000  // Will escape #'s in paths
#define URL_FILE_USE_PATHURL            0x00010000
#define URL_ESCAPE_PERCENT              0x00001000
#define URL_ESCAPE_SEGMENT_ONLY         0x00002000  // Treat the entire URL param as one URL segment.

#define URL_PARTFLAG_KEEPSCHEME         0x00000001

#define URL_APPLY_DEFAULT               0x00000001
#define URL_APPLY_GUESSSCHEME           0x00000002
#define URL_APPLY_GUESSFILE             0x00000004
#define URL_APPLY_FORCEAPPLY            0x00000008


LWSTDAPI_(int)          UrlCompareA(LPCSTR psz1, LPCSTR psz2, BOOL fIgnoreSlash);
LWSTDAPI_(int)          UrlCompareW(LPCWSTR psz1, LPCWSTR psz2, BOOL fIgnoreSlash);
LWSTDAPI                UrlCombineA(LPCSTR pszBase, LPCSTR pszRelative, LPSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCombineW(LPCWSTR pszBase, LPCWSTR pszRelative, LPWSTR pszCombined, LPDWORD pcchCombined, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeA(LPCSTR pszUrl, LPSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI                UrlCanonicalizeW(LPCWSTR pszUrl, LPWSTR pszCanonicalized, LPDWORD pcchCanonicalized, DWORD dwFlags);
LWSTDAPI_(BOOL)         UrlIsOpaqueA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsOpaqueW(LPCWSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryA(LPCSTR pszURL);
LWSTDAPI_(BOOL)         UrlIsNoHistoryW(LPCWSTR pszURL);
#define                 UrlIsFileUrlA(pszURL) UrlIsA(pszURL, URLIS_FILEURL)
#define                 UrlIsFileUrlW(pszURL) UrlIsW(pszURL, URLIS_FILEURL)
LWSTDAPI_(BOOL)         UrlIsA(LPCSTR pszUrl, URLIS UrlIs);
LWSTDAPI_(BOOL)         UrlIsW(LPCWSTR pszUrl, URLIS UrlIs);
LWSTDAPI_(LPCSTR)       UrlGetLocationA(LPCSTR psz1);
LWSTDAPI_(LPCWSTR)      UrlGetLocationW(LPCWSTR psz1);
LWSTDAPI                UrlUnescapeA(LPSTR pszUrl, LPSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlUnescapeW(LPWSTR pszUrl, LPWSTR pszUnescaped, LPDWORD pcchUnescaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeA(LPCSTR pszUrl, LPSTR pszEscaped, LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlEscapeW(LPCWSTR pszUrl, LPWSTR pszEscaped, LPDWORD pcchEscaped, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathA(LPCSTR pszPath, LPSTR pszUrl, LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                UrlCreateFromPathW(LPCWSTR pszPath, LPWSTR pszUrl, LPDWORD pcchUrl, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlA(LPCSTR pszUrl, LPSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                PathCreateFromUrlW(LPCWSTR pszUrl, LPWSTR pszPath, LPDWORD pcchPath, DWORD dwFlags);
LWSTDAPI                UrlHashA(LPCSTR pszUrl, LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlHashW(LPCWSTR pszUrl, LPBYTE pbHash, DWORD cbHash);
LWSTDAPI                UrlGetPartW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlGetPartA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwPart, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeA(LPCSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                UrlApplySchemeW(LPCWSTR pszIn, LPWSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);
LWSTDAPI                HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash);



#ifdef UNICODE
#define UrlCompare              UrlCompareW
#define UrlCombine              UrlCombineW
#define UrlCanonicalize         UrlCanonicalizeW
#define UrlIsOpaque             UrlIsOpaqueW
#define UrlIsFileUrl            UrlIsFileUrlW
#define UrlGetLocation          UrlGetLocationW
#define UrlUnescape             UrlUnescapeW
#define UrlEscape               UrlEscapeW
#define UrlCreateFromPath       UrlCreateFromPathW
#define PathCreateFromUrl       PathCreateFromUrlW
#define UrlHash                 UrlHashW
#define UrlGetPart              UrlGetPartW
#define UrlApplyScheme          UrlApplySchemeW
#define UrlIs                   UrlIsW


#else //!UNICODE
#define UrlCompare              UrlCompareA
#define UrlCombine              UrlCombineA
#define UrlCanonicalize         UrlCanonicalizeA
#define UrlIsOpaque             UrlIsOpaqueA
#define UrlIsFileUrl            UrlIsFileUrlA
#define UrlGetLocation          UrlGetLocationA
#define UrlUnescape             UrlUnescapeA
#define UrlEscape               UrlEscapeA
#define UrlCreateFromPath       UrlCreateFromPathA
#define PathCreateFromUrl       PathCreateFromUrlA
#define UrlHash                 UrlHashA
#define UrlGetPart              UrlGetPartA
#define UrlApplyScheme          UrlApplySchemeA
#define UrlIs                   UrlIsA


#endif //UNICODE

#define UrlEscapeSpaces(pszUrl, pszEscaped, pcchEscaped)        UrlCanonicalize(pszUrl, pszEscaped, pcchEscaped, URL_ESCAPE_SPACES_ONLY |URL_DONT_ESCAPE_EXTRA_INFO )
#define UrlUnescapeInPlace(pszUrl, dwFlags)                     UrlUnescape(pszUrl, NULL, NULL, dwFlags | URL_UNESCAPE_INPLACE)



#endif //  NO_SHLWAPI_PATH



#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//

// SHDeleteEmptyKey mimics RegDeleteKey as it behaves on NT.
// SHDeleteKey mimics RegDeleteKey as it behaves on Win95.

LWSTDAPI_(DWORD)    SHDeleteEmptyKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteEmptyKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteEmptyKey  SHDeleteEmptyKeyW
#else
#define SHDeleteEmptyKey  SHDeleteEmptyKeyA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHDeleteKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteKey  SHDeleteKeyW
#else
#define SHDeleteKey  SHDeleteKeyA
#endif // !UNICODE
LWSTDAPI_(HKEY)     SHRegDuplicateHKey(HKEY hkey);


// These functions open the key, get/set/delete the value, then close
// the key.

LWSTDAPI_(DWORD)    SHDeleteValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue);
LWSTDAPI_(DWORD)    SHDeleteValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue);
#ifdef UNICODE
#define SHDeleteValue  SHDeleteValueW
#else
#define SHDeleteValue  SHDeleteValueA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHGetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(DWORD)    SHGetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHGetValue  SHGetValueW
#else
#define SHGetValue  SHGetValueA
#endif // !UNICODE
LWSTDAPI_(DWORD)    SHSetValueA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
LWSTDAPI_(DWORD)    SHSetValueW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
#ifdef UNICODE
#define SHSetValue  SHSetValueW
#else
#define SHSetValue  SHSetValueA
#endif // !UNICODE

// These functions work just like RegQueryValueEx, except if the
// data type is REG_EXPAND_SZ, then these will go ahead and expand
// out the string.  *pdwType will always be massaged to REG_SZ
// if this happens.  REG_SZ values are also guaranteed to be null
// terminated.

LWSTDAPI_(DWORD)    SHQueryValueExA(HKEY hkey, LPCSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI_(DWORD)    SHQueryValueExW(HKEY hkey, LPCWSTR pszValue, DWORD *pdwReserved, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SHQueryValueEx  SHQueryValueExW
#else
#define SHQueryValueEx  SHQueryValueExA
#endif // !UNICODE

// Enumeration functions support.

LWSTDAPI_(LONG)     SHEnumKeyExA(HKEY hkey, DWORD dwIndex, LPSTR pszName, LPDWORD pcchName);
LWSTDAPI_(LONG)     SHEnumKeyExW(HKEY hkey, DWORD dwIndex, LPWSTR pszName, LPDWORD pcchName);
LWSTDAPI_(LONG)     SHEnumValueA(HKEY hkey, DWORD dwIndex, LPSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData);
LWSTDAPI_(LONG)     SHEnumValueW(HKEY hkey, DWORD dwIndex, LPWSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData);
LWSTDAPI_(LONG)     SHQueryInfoKeyA(HKEY hkey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen);
LWSTDAPI_(LONG)     SHQueryInfoKeyW(HKEY hkey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen);

// recursive key copy
LWSTDAPI_(DWORD)     SHCopyKeyA(HKEY hkeySrc, LPCSTR   szSrcSubKey, HKEY hkeyDest, DWORD fReserved);
LWSTDAPI_(DWORD)     SHCopyKeyW(HKEY hkeySrc, LPCWSTR wszSrcSubKey, HKEY hkeyDest, DWORD fReserved);

// Getting and setting file system paths with environment variables

LWSTDAPI_(DWORD)    SHRegGetPathA(HKEY hKey, LPCSTR pcszSubKey, LPCSTR pcszValue, LPSTR pszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegGetPathW(HKEY hKey, LPCWSTR pcszSubKey, LPCWSTR pcszValue, LPWSTR pszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegSetPathA(HKEY hKey, LPCSTR pcszSubKey, LPCSTR pcszValue, LPCSTR pcszPath, DWORD dwFlags);
LWSTDAPI_(DWORD)    SHRegSetPathW(HKEY hKey, LPCWSTR pcszSubKey, LPCWSTR pcszValue, LPCWSTR pcszPath, DWORD dwFlags);

#ifdef UNICODE
#define SHEnumKeyEx           SHEnumKeyExW
#define SHEnumValue           SHEnumValueW
#define SHQueryInfoKey        SHQueryInfoKeyW
#define SHCopyKey             SHCopyKeyW
#define SHRegGetPath          SHRegGetPathW
#define SHRegSetPath          SHRegSetPathW
#else
#define SHEnumKeyEx           SHEnumKeyExA
#define SHEnumValue           SHEnumValueA
#define SHQueryInfoKey        SHQueryInfoKeyA
#define SHCopyKey             SHCopyKeyA
#define SHRegGetPath          SHRegGetPathA
#define SHRegSetPath          SHRegSetPathA
#endif


//////////////////////////////////////////////
// User Specific Registry Access Functions
//////////////////////////////////////////////

//
// Type definitions.
//

typedef enum
{
    SHREGDEL_DEFAULT = 0x00000000,       // Delete's HKCU, or HKLM if HKCU is not found.
    SHREGDEL_HKCU    = 0x00000001,       // Delete HKCU only
    SHREGDEL_HKLM    = 0x00000010,       // Delete HKLM only.
    SHREGDEL_BOTH    = 0x00000011,       // Delete both HKCU and HKLM.
} SHREGDEL_FLAGS;

typedef enum
{
    SHREGENUM_DEFAULT = 0x00000000,       // Enumerates HKCU or HKLM if not found.
    SHREGENUM_HKCU    = 0x00000001,       // Enumerates HKCU only
    SHREGENUM_HKLM    = 0x00000010,       // Enumerates HKLM only.
    SHREGENUM_BOTH    = 0x00000011,       // Enumerates both HKCU and HKLM without duplicates.
                                          // This option is NYI.
} SHREGENUM_FLAGS;

#define     SHREGSET_HKCU           0x00000001       // Write to HKCU if empty.
#define     SHREGSET_FORCE_HKCU     0x00000002       // Write to HKCU.
#define     SHREGSET_HKLM           0x00000004       // Write to HKLM if empty.
#define     SHREGSET_FORCE_HKLM     0x00000008       // Write to HKLM.
#define     SHREGSET_DEFAULT        (SHREGSET_FORCE_HKCU | SHREGSET_HKLM)          // Default is SHREGSET_FORCE_HKCU | SHREGSET_HKLM.

typedef HANDLE HUSKEY;  // HUSKEY is a Handle to a User Specific KEY.
typedef HUSKEY *PHUSKEY;

LWSTDAPI_(LONG)        SHRegCreateUSKeyA(LPCSTR pszPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegCreateUSKeyW(LPCWSTR pwzPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegOpenUSKeyA(LPCSTR pszPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, BOOL fIgnoreHKCU);
LWSTDAPI_(LONG)        SHRegOpenUSKeyW(LPCWSTR pwzPath, REGSAM samDesired, HUSKEY hRelativeUSKey, PHUSKEY phNewUSKey, BOOL fIgnoreHKCU);
LWSTDAPI_(LONG)        SHRegQueryUSValueA(HUSKEY hUSKey, LPCSTR pszValue, LPDWORD pdwType, void *pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegQueryUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, LPDWORD pdwType, void *pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegWriteUSValueA(HUSKEY hUSKey, LPCSTR pszValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegWriteUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegDeleteUSValueA(HUSKEY hUSKey, LPCSTR pszValue, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteEmptyUSKeyW(HUSKEY hUSKey, LPCWSTR pwzSubKey, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteEmptyUSKeyA(HUSKEY hUSKey, LPCSTR pszSubKey, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegDeleteUSValueW(HUSKEY hUSKey, LPCWSTR pwzValue, SHREGDEL_FLAGS delRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSKeyA(HUSKEY hUSKey, DWORD dwIndex, LPSTR pszName, LPDWORD pcchName, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSKeyW(HUSKEY hUSKey, DWORD dwIndex, LPWSTR pwzName, LPDWORD pcchName, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSValueA(HUSKEY hUSkey, DWORD dwIndex, LPSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegEnumUSValueW(HUSKEY hUSkey, DWORD dwIndex, LPWSTR pszValueName, LPDWORD pcchValueName, LPDWORD pdwType, void *pvData, LPDWORD pcbData, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegQueryInfoUSKeyA(HUSKEY hUSKey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegQueryInfoUSKeyW(HUSKEY hUSKey, LPDWORD pcSubKeys, LPDWORD pcchMaxSubKeyLen, LPDWORD pcValues, LPDWORD pcchMaxValueNameLen, SHREGENUM_FLAGS enumRegFlags);
LWSTDAPI_(LONG)        SHRegCloseUSKey(HUSKEY hUSKey);


// These calls are equal to an SHRegOpenUSKey, SHRegQueryUSValue, and then a SHRegCloseUSKey.
LWSTDAPI_(LONG)        SHRegGetUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, LPDWORD pdwType, void * pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegGetUSValueW(LPCWSTR pwzSubKey, LPCWSTR pwzValue, LPDWORD pdwType, void * pvData, LPDWORD pcbData, BOOL fIgnoreHKCU, void *pvDefaultData, DWORD dwDefaultDataSize);
LWSTDAPI_(LONG)        SHRegSetUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(LONG)        SHRegSetUSValueW(LPCWSTR pwzSubKey, LPCWSTR pwzValue, DWORD dwType, const void *pvData, DWORD cbData, DWORD dwFlags);
LWSTDAPI_(int)         SHRegGetIntW(HKEY hk, LPCWSTR pwzKey, int iDefault);

#ifdef UNICODE
#define SHRegCreateUSKey        SHRegCreateUSKeyW
#define SHRegOpenUSKey          SHRegOpenUSKeyW
#define SHRegQueryUSValue       SHRegQueryUSValueW
#define SHRegWriteUSValue       SHRegWriteUSValueW
#define SHRegDeleteUSValue      SHRegDeleteUSValueW
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyW
#define SHRegEnumUSKey          SHRegEnumUSKeyW
#define SHRegEnumUSValue        SHRegEnumUSValueW
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyW
#define SHRegGetUSValue         SHRegGetUSValueW
#define SHRegSetUSValue         SHRegSetUSValueW
#define SHRegGetInt             SHRegGetIntW
#else
#define SHRegCreateUSKey        SHRegCreateUSKeyA
#define SHRegOpenUSKey          SHRegOpenUSKeyA
#define SHRegQueryUSValue       SHRegQueryUSValueA
#define SHRegWriteUSValue       SHRegWriteUSValueA
#define SHRegDeleteUSValue      SHRegDeleteUSValueA
#define SHRegDeleteEmptyUSKey   SHRegDeleteEmptyUSKeyA
#define SHRegEnumUSKey          SHRegEnumUSKeyA
#define SHRegEnumUSValue        SHRegEnumUSValueA
#define SHRegQueryInfoUSKey     SHRegQueryInfoUSKeyA
#define SHRegGetUSValue         SHRegGetUSValueA
#define SHRegSetUSValue         SHRegSetUSValueA
#endif

LWSTDAPI_(BOOL) SHRegGetBoolUSValueA(LPCSTR pszSubKey, LPCSTR pszValue, BOOL fIgnoreHKCU, BOOL fDefault);
LWSTDAPI_(BOOL) SHRegGetBoolUSValueW(LPCWSTR pszSubKey, LPCWSTR pszValue, BOOL fIgnoreHKCU, BOOL fDefault);

#ifdef UNICODE
#define SHRegGetBoolUSValue SHRegGetBoolUSValueW
#else
#define SHRegGetBoolUSValue SHRegGetBoolUSValueA
#endif

//
//  Association APIs
//
//  these APIs are to assist in accessing the data in HKCR
//  getting the Command strings and exe paths
//  for different verbs and extensions are simplified this way
//

enum {
    ASSOCF_INIT_NOREMAPCLSID           = 0x00000001,  //  do not remap clsids to progids
    ASSOCF_INIT_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_OPEN_BYEXENAME              = 0x00000002,  //  executable is being passed in
    ASSOCF_INIT_DEFAULTTOSTAR          = 0x00000004,  //  treat "*" as the BaseClass
    ASSOCF_INIT_DEFAULTTOFOLDER        = 0x00000008,  //  treat "Folder" as the BaseClass
    ASSOCF_NOUSERSETTINGS              = 0x00000010,  //  dont use HKCU
    ASSOCF_NOTRUNCATE                  = 0x00000020,  //  dont truncate the return string
    ASSOCF_VERIFY                      = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCF_REMAPRUNDLL                 = 0x00000080,  //  actually gets info about rundlls target if applicable
    ASSOCF_NOFIXUPS                    = 0x00000100,  //  attempt to fix errors if found
    ASSOCF_IGNOREBASECLASS             = 0x00000200,  //  dont recurse into the baseclass
};

typedef DWORD ASSOCF;


typedef enum {
    ASSOCSTR_COMMAND      = 1,  //  shell\verb\command string
    ASSOCSTR_EXECUTABLE,        //  the executable part of command string
    ASSOCSTR_FRIENDLYDOCNAME,   //  friendly name of the document type
    ASSOCSTR_FRIENDLYAPPNAME,   //  friendly name of executable
    ASSOCSTR_NOOPEN,            //  noopen value
    ASSOCSTR_SHELLNEWVALUE,     //  query values under the shellnew key
    ASSOCSTR_DDECOMMAND,        //  template for DDE commands
    ASSOCSTR_DDEIFEXEC,         //  DDECOMMAND to use if just create a process
    ASSOCSTR_DDEAPPLICATION,    //  Application name in DDE broadcast
    ASSOCSTR_DDETOPIC,          //  Topic Name in DDE broadcast
    ASSOCSTR_INFOTIP,           //  info tip for an item, or list of properties to create info tip from
    ASSOCSTR_MAX                //  last item in enum...
} ASSOCSTR;

typedef enum {
    ASSOCKEY_SHELLEXECCLASS = 1,  //  the key that should be passed to ShellExec(hkeyClass)
    ASSOCKEY_APP,                 //  the "Application" key for the association
    ASSOCKEY_CLASS,               //  the progid or class key
    ASSOCKEY_BASECLASS,           //  the BaseClass key
    ASSOCKEY_MAX                  //  last item in enum...
} ASSOCKEY;

typedef enum {
    ASSOCDATA_MSIDESCRIPTOR = 1,  //  Component Descriptor to pass to MSI APIs
    ASSOCDATA_NOACTIVATEHANDLER,  //  restrict attempts to activate window
    ASSOCDATA_QUERYCLASSSTORE,    //  should check with the NT Class Store
    ASSOCDATA_HASPERUSERASSOC,    //  defaults to user specified association
    ASSOCDATA_MAX
} ASSOCDATA;

typedef enum {
    ASSOCENUM_NONE
} ASSOCENUM;

#undef INTERFACE
#define INTERFACE IQueryAssociations

DECLARE_INTERFACE_( IQueryAssociations, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IAssociations methods
    STDMETHOD (Init)(THIS_ ASSOCF flags, LPCWSTR pszAssoc, HKEY hkProgid, HWND hwnd) PURE;
    STDMETHOD (GetString)(THIS_ ASSOCF flags, ASSOCSTR str, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut) PURE;
    STDMETHOD (GetKey)(THIS_ ASSOCF flags, ASSOCKEY key, LPCWSTR pszExtra, HKEY *phkeyOut) PURE;
    STDMETHOD (GetData)(THIS_ ASSOCF flags, ASSOCDATA data, LPCWSTR pszExtra, LPVOID pvOut, DWORD *pcbOut) PURE;
    STDMETHOD (GetEnum)(THIS_ ASSOCF flags, ASSOCENUM assocenum, LPCWSTR pszExtra, REFIID riid, LPVOID *ppvOut) PURE;
};

#define CLSID_QueryAssociations IID_IQueryAssociations


LWSTDAPI AssocCreate(CLSID clsid, REFIID riid, LPVOID *ppv);

//  wrappers for the interface
LWSTDAPI AssocQueryStringA(ASSOCF flags, ASSOCSTR str, LPCSTR pszAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut);
//  wrappers for the interface
LWSTDAPI AssocQueryStringW(ASSOCF flags, ASSOCSTR str, LPCWSTR pszAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryString  AssocQueryStringW
#else
#define AssocQueryString  AssocQueryStringA
#endif // !UNICODE
LWSTDAPI AssocQueryStringByKeyA(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCSTR pszExtra, LPSTR pszOut, DWORD *pcchOut);
LWSTDAPI AssocQueryStringByKeyW(ASSOCF flags, ASSOCSTR str, HKEY hkAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
#ifdef UNICODE
#define AssocQueryStringByKey  AssocQueryStringByKeyW
#else
#define AssocQueryStringByKey  AssocQueryStringByKeyA
#endif // !UNICODE
LWSTDAPI AssocQueryKeyA(ASSOCF flags, ASSOCKEY key, LPCSTR pszAssoc, LPCSTR pszExtra, HKEY *phkeyOut);
LWSTDAPI AssocQueryKeyW(ASSOCF flags, ASSOCKEY key, LPCWSTR pszAssoc, LPCWSTR pszExtra, HKEY *phkeyOut);
#ifdef UNICODE
#define AssocQueryKey  AssocQueryKeyW
#else
#define AssocQueryKey  AssocQueryKeyA
#endif // !UNICODE



#endif //  NO_SHLWAPI_REG



#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//

LWSTDAPI_(struct IStream *) SHOpenRegStreamA(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStreamW(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream  SHOpenRegStreamW
#else
#define SHOpenRegStream  SHOpenRegStreamA
#endif // !UNICODE
LWSTDAPI_(struct IStream *) SHOpenRegStream2A(HKEY hkey, LPCSTR pszSubkey, LPCSTR pszValue, DWORD grfMode);
LWSTDAPI_(struct IStream *) SHOpenRegStream2W(HKEY hkey, LPCWSTR pszSubkey, LPCWSTR pszValue, DWORD grfMode);
#ifdef UNICODE
#define SHOpenRegStream2  SHOpenRegStream2W
#else
#define SHOpenRegStream2  SHOpenRegStream2A
#endif // !UNICODE
// New code always wants new implementation...
#undef SHOpenRegStream
#define SHOpenRegStream SHOpenRegStream2

LWSTDAPI SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, struct IStream **ppstm);
LWSTDAPI SHCreateStreamOnFileW(LPCWSTR pszFile, DWORD grfMode, struct IStream **ppstm);
#ifdef UNICODE
#define SHCreateStreamOnFile  SHCreateStreamOnFileW
#else
#define SHCreateStreamOnFile  SHCreateStreamOnFileA
#endif // !UNICODE



#endif // NO_SHLWAPI_STREAM



#if (_WIN32_IE >= 0x0500)

// SHAutoComplete
//      hwndEdit - HWND of editbox, ComboBox or ComboBoxEx.
//      dwFlags - Flags to indicate what to AutoAppend or AutoSuggest for the editbox.
//
// WARNING:
//    Caller needs to have called CoInitialize() or OleInitialize()
//    and cannot call CoUninit/OleUninit until after
//    WM_DESTROY on hwndEdit.
//
//  dwFlags values:
#define SHACF_DEFAULT                   0x00000000  // Currently (SHACF_FILESYSTEM | SHACF_URLALL)
#define SHACF_FILESYSTEM                0x00000001  // This includes the File System as well as the rest of the shell (Desktop\My Computer\Control Panel\)
#define SHACF_URLALL                    (SHACF_URLHISTORY | SHACF_URLMRU)
#define SHACF_URLHISTORY                0x00000002  // URLs in the User's History
#define SHACF_URLMRU                    0x00000004  // URLs in the User's Recently Used list.
#define SHACF_USETAB                    0x00000008  // URLs in the User's Recently Used list.
#define SHACF_FILESYS_ONLY              0x00000010  // Don't AutoComplete non-File System items.

#define SHACF_AUTOSUGGEST_FORCE_ON      0x10000000  // Ignore the registry default and force the feature on.
#define SHACF_AUTOSUGGEST_FORCE_OFF     0x20000000  // Ignore the registry default and force the feature off.
#define SHACF_AUTOAPPEND_FORCE_ON       0x40000000  // Ignore the registry default and force the feature on. (Also know as AutoComplete)
#define SHACF_AUTOAPPEND_FORCE_OFF      0x80000000  // Ignore the registry default and force the feature off. (Also know as AutoComplete)

LWSTDAPI SHAutoComplete(HWND hwndEdit, DWORD dwFlags);

STDAPI SHSetThreadRef(IUnknown *punk);
STDAPI SHGetThreadRef(IUnknown **ppunk);

LWSTDAPI_(BOOL) SHSkipJunction(struct IBindCtx* pbc, const CLSID *pclsid);
#endif

#define CTF_INSIST          0x00000001      // SHCreateThread() dwFlags - call pfnThreadProc synchronously if CreateThread() fails
#define CTF_THREAD_REF      0x00000002      // hold a reference to the creating thread
#define CTF_PROCESS_REF     0x00000004      // hold a reference to the creating process
#define CTF_COINIT          0x00000008      // init COM for the created thread

LWSTDAPI_(BOOL) SHCreateThread(LPTHREAD_START_ROUTINE pfnThreadProc, void *pData, DWORD dwFlags, LPTHREAD_START_ROUTINE pfnCallback);


#ifndef NO_SHLWAPI_GDI
//
//====== GDI helper functions  ================================================
//

LWSTDAPI_(HPALETTE) SHCreateShellPalette(HDC hdc);

#if (_WIN32_IE >= 0x0500)

LWSTDAPI_(void)     ColorRGBToHLS(COLORREF clrRGB, WORD* pwHue, WORD* pwLuminance, WORD* pwSaturation);
LWSTDAPI_(COLORREF) ColorHLSToRGB(WORD wHue, WORD wLuminance, WORD wSaturation);
LWSTDAPI_(COLORREF) ColorAdjustLuma(COLORREF clrRGB, int n, BOOL fScale);


#endif  // _WIN32_IE >= 0x0500

#endif // NO_SHLWAPI_GDI


//
//====== DllGetVersion  =======================================================
//

typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

#if (_WIN32_IE >= 0x0501)

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

#define DLLVER_MAJOR_MASK                    0xFFFF000000000000
#define DLLVER_MINOR_MASK                    0x0000FFFF00000000
#define DLLVER_BUILD_MASK                    0x00000000FFFF0000
#define DLLVER_QFE_MASK                      0x000000000000FFFF

#endif

#define MAKEDLLVERULL(major, minor, build, qfe) \
        (((ULONGLONG)(major) << 48) |        \
         ((ULONGLONG)(minor) << 32) |        \
         ((ULONGLONG)(build) << 16) |        \
         ((ULONGLONG)(  qfe) <<  0))

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);

// DllInstall (to be implemented by self-installing DLLs)
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine);



#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif


#endif  // _INC_SHLWAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\shlobjp.h ===
#ifndef _SHLOBJP_H_
#define _SHLOBJP_H_
#define NO_MONIKER
#include <docobj.h>
#include <shldisp.h>
#ifndef RC_INVOKED
#include <pshpack1.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
// HMONITOR is already declared in NT 5's windef.h.
#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
DECLARE_HANDLE(HMONITOR);
#define HMONITOR_DECLARED
#endif
SHSTDAPI_(void *) SHAlloc(SIZE_T cb);
SHSTDAPI_(void *) SHRealloc(void * pv, SIZE_T cbNew);
SHSTDAPI_(SIZE_T)  SHGetSize(void * pv);
SHSTDAPI_(void)   SHFree(void * pv);
#define CMICEXSIZE_NT4          (SIZEOF(CMINVOKECOMMANDINFOEX) - SIZEOF(POINT))
#define CMIC_MASK_NO_HOOKS      SEE_MASK_NO_HOOKS
#define CMIC_MASK_DATAOBJECT    0x40000000   // lpPara is IDataObject*
#define CMIC_MASK_MODAL         0x80000000

#define CMIC_VALID_SEE_FLAGS    SEE_VALID_CMIC_FLAGS
//----------------------------------------------------------------------------
// Internal helper macro
//----------------------------------------------------------------------------

#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)

//
// Helper macro definitions
//
#define S_BOOL(f)   MAKE_SCODE(SEVERITY_SUCCESS, 0, f)

#ifdef DEBUG
#define ReleaseAndAssert(punk) Assert(punk->lpVtbl->Release(punk)==0)
#else
#define ReleaseAndAssert(punk) (punk->lpVtbl->Release(punk))
#endif
// Property sheet ID for Explorer->View->Options File Types property sheet
// replacement.

#define EXPPS_FILETYPES 1
//  this interface is just the IID.  return back
//  a pointer to the IDropTarget interface if the
//  object calls DAD_DragLeave/DAD_SetDragImage
//  in its IDropTarget::Drop().
//
#define IDropTargetWithDADSupport IDropTarget
//===========================================================================
//
// IShellIconOverlayManager
//
// Used to return the icon overlay information including OverlayIndex, Image Index or Priority for an IShellFolder
// object, this is only inherited by CFSFolder_IconOverlayManager, it enumerates through all IconOverlayID's and
// keep their information in an array.
//
// IShellIconOverlayManager:GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags)
//      pwszPath        full path of the file
//      dwAttrib        attribute of this file
//      pIndex          pointer to the Icon Index in the system image list
//      pOverlayIndex   pointer to the OverlayIndex in the system image list
//      pPriority       pointer to the Priority of this overlay
// IShellIconOverlayManager:GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID)
//      iReservedID     reserved icon overlay id
//  returns:
//      S_OK,  if the index of an Overlay is found
//      S_FALSE, if no Overlay exists for this file
//      E_FAIL, if lpfd is bad
// IShellIconOverlayManager:RefreshOverlayImages(DWORD dwFlags)
//      This will refresh the overlay cache, depends on the dwFlags passed in
//      It will reload the icons into the imagelist, when passed SIOM_ICONINDEX
// IShellIconOverlayManager::LoadNonloadedOverlayIdentifiers()
//      This method loads any registered overlay identifiers (handlers) that
//      are not currently loaded.
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellIconOverlayManager

DECLARE_INTERFACE_(IShellIconOverlayManager, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellIconOverlayManager methods ***
    STDMETHOD(GetFileOverlayInfo)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags) PURE;
    STDMETHOD(GetReservedOverlayInfo)(THIS_ LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwflags, int iReservedID) PURE;
    STDMETHOD(RefreshOverlayImages)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(LoadNonloadedOverlayIdentifiers)(THIS) PURE;
    STDMETHOD(SetIndependentOverlay)(int iImage, int * piIndex) PURE;
};
#define SIOM_OVERLAYINDEX         1
#define SIOM_ICONINDEX            2
// #define SIOM_PRIORITY          3
#define SIOM_RESERVED_SHARED      0
#define SIOM_RESERVED_LINK        1
#define SIOM_RESERVED_SLOWFILE    2
//===========================================================================
//
// IBrowserBand
//
// IBrowserBand::GetObjectBB(REFIID riid, void **ppv)
//  Obtain a service from the web browser.
//
// IBrowserBand::SetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
//  Set browser band properties based on members of browserbandinfo struct
//  specified by dwMask.  These properties include title, deskband mode, and
//  current size.
//
//===========================================================================

typedef struct {
    UINT    cbSize;
    DWORD   dwModeFlags;
    BSTR    bstrTitle;
    SIZE    sizeMin;
    SIZE    sizeMax;
    SIZE    sizeCur;
} BROWSERBANDINFO, *PBROWSERBANDINFO;

#define BBIM_MODEFLAGS  0x00000001
#define BBIM_TITLE      0x00000002
#define BBIM_SIZEMIN    0x00000004
#define BBIM_SIZEMAX    0x00000008
#define BBIM_SIZECUR    0x00000010

#undef  INTERFACE
#define INTERFACE  IBrowserBand
DECLARE_INTERFACE_(IBrowserBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBrowserBand methods ***
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD(SetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) PURE;
    STDMETHOD(GetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) PURE;
};


typedef struct _TreeWalkerStats {
    int nFiles;               // number of files we have seen
    int nFolders;             // number of folders we have seen (does not include the root)
    int nDepth;               // the current depth
    DWORD dwClusterSize;      // cluster size of the disk we are currently on
    ULONGLONG  ulTotalSize;   // total size of all files we have seen
    ULONGLONG  ulActualSize;  // total size on disk of all files, taking into account compression, sparse files, and cluster slop
} TREEWALKERSTATS,  *LPTREEWALKERSTATS;

//===========================================================================
//
// IShellTreeWalkerCallBack Interface
// The callback interface for IShellTreeWalker
//
// All callbacks receives fully-qualified paths to the item found, being
// entered, being left, etc.
//
// Return values for all methods:
// S_OK    -- Normal, continue processing files, skip the problem file in error case
// S_FALSE -- Conitnue but quit the current directory
// E_NOTIMPL -- same as S_OK
// E_* -- Stop right away.
//
//===========================================================================
#undef  INTERFACE
#define INTERFACE   IShellTreeWalkerCallBack

DECLARE_INTERFACE_(IShellTreeWalkerCallBack, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellTreeWalkerCallBack methods ***
    STDMETHOD(FoundFile)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws, WIN32_FIND_DATAW * pwfd) PURE;
    STDMETHOD(EnterFolder)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws, WIN32_FIND_DATAW * pwfd) PURE;
    STDMETHOD(LeaveFolder)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws) PURE;
    STDMETHOD(HandleError)(THIS_ LPCWSTR pwszPath, LPTREEWALKERSTATS ptws, HRESULT hrError) PURE;
};

typedef IShellTreeWalkerCallBack * LPSHELLTREEWALKERCALLBACK;

#define WT_FOLDERFIRST          0x00000001 // default to files first
#define WT_MAXDEPTH             0x00000002 // specify the maximum depth we go into
#define WT_FOLDERONLY           0x00000004 // only walks directories: default is to only return files
#define WT_NOTIFYFOLDERENTER    0x00000008 // notifies whenever entering a folder :default is to notify on every file
#define WT_NOTIFYFOLDERLEAVE    0x00000010 // notifies whenever leaving a folder
#define WT_GOINTOREPARSEPOINT   0x00000020 // default is to stop at any reparse points
#define WT_EXCLUDEWALKROOT      0x00000040 // default is to EnterFolder the starting point

#define WT_ALL                  0x0000007F

//===========================================================================
//
// IShellTreeWalker Interface
// The common File System tree traversal interface in shell.
//
// IShellTreeWalker::WalkTree(DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxPath, IShellTreeWalkerCallBack * pstwcb)
// Parameters:
// dwFlags      -- search flags: details above
// pwszWalkRoot -- the root directory to start from
// pwszWalkSpec -- the spec used to match files
// iMaxDepth    -- maximum depth to go into
// pstwcb       -- pointer to the callback interface
//
// Return Value:
// S_OK -- succeeded
// E_*  -- failed
//===========================================================================
#undef  INTERFACE
#define INTERFACE   IShellTreeWalker

DECLARE_INTERFACE_(IShellTreeWalker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellTreeWalker methods ***
    STDMETHOD(WalkTree)(THIS_ DWORD dwFlags, LPCWSTR pwszWalkRoot, LPCWSTR pwszWalkSpec, int iMaxPath, IShellTreeWalkerCallBack * pstwcb) PURE;
};

typedef IShellTreeWalker * LPSHELLTREEWALKER;

// NT4 Console Server included shell32\shlink.h to get structure
// definitions and mimicked shell32\shlink.c to understand the
// stream format so our stream format is fixed forever. This is
// not bad since it was designed with extension in mind. We need
// to publish (as privately as possible) the file format and
// structures needed to read the file format.
//
// The stream format is a SHELL_LINK_DATA followed by
//   if SLDF_HAS_ID_LIST an ILSaveToStream followed by
//   if SLDF_HAS_LINK_INFO a LINKINFO followed by
//   if SLDF_HAS_NAME a STREAMSTRING followed by
//   if SLDF_RELPATH a STREAMSTRING followed by
//   if SLDF_WORKINGDIR a STREAMSTRING followed by
//   if SLDF_HAS_ARGS a STREAMSTRING followed by
//   if SLDF_HAS_ICON_LOCATION a STREAMSTRING followed by
//   SHWriteDataBlockList list of signature blocks
//
// Where a STREAMSTRING is a USHORT count of characters
// followed by that many (SLDF_UNICODE ? WIDE : ANSI) characters.
//
typedef struct {        // sld
    DWORD       cbSize;                 // signature for this data structure
    CLSID       clsid;                  // our GUID
    DWORD       dwFlags;                // SHELL_LINK_DATA_FLAGS enumeration

    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeLow;

    int         iIcon;
    int         iShowCmd;
    WORD        wHotkey;
    WORD        wUnused;
    DWORD       dwRes1;
    DWORD       dwRes2;
} SHELL_LINK_DATA, *LPSHELL_LINK_DATA;
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
} EXP_HEADER, *LPEXP_HEADER;
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    BYTE        abTracker[ 1 ];     //
} EXP_TRACKER, *LPEXP_TRACKER;
#define EXP_TRACKER_SIG                0xA0000003   // LPEXP_TRACKER
// NT40 Console Control Panel Applet does a CoCreateInstance(CLSID_CShellLink),
// used the CShellLink definition to get the 'this' pointer, and passed that
// along to some private exports in shell32. This completely prevents us
// from moving the CShellLink implementation to another DLL. (If we do, or an
// ISV takes our stream format and implements a better link by pointing the
// classid to their implementation, the NT40 Console CPA will fault.)
//
// To fix this problem in future revs, CShellLink will support IShellLinkDataList
//   AddDataBlock    adds the data block
//   FindDataBloc    returns a LocalAlloc()d COPY of a data block with the
//                   signature dwSig (NOTE: this is different than SHFindDataBlock)
//   RemoveDataBlock removes a data block with signature dwSig
// Plan is for NT50's Console CPA to use this interface instead.
//

//
// IURLSearchHook Interface is called whenever the browser navigates to a
// non-standard URL. It can be used to redirect the user's request to a
// search engine or a specific web site.
//
// A non-standard URL does not have a protocol prefix (e.g.,
// "www.microsoft.com") and the protocol cannot be easily guessed by
// the browser (e.g., "home.microsoft.com").
//
// The parameters of Translate(..)
//    lpwszSearchURL -- (IN/OUT) Wide char buffer that contains the request
//                      "URL" user typed in as input and the tranlated URL
//                      as output.
//    cchBufferSize  -- (IN) size of lpwszSearchURL
//
// Return Values:
// S_OK         Search handled completely, pszResult has the full URL to
//              browse to.  Stop running any further IURLSearchHooks and
//              pass this URL back to the browser for browsing.
//
// S_FALSE      Query has been preprocessed, pszResult has the result of
//              the preprocess, further search still needed. Go on
//              executing the rest of the IURLSearchHooks.  The
//              preprocessing steps can be:
//
//                      1. replaced certain characters
//                      2. added more hints
//
// E_ABORT      Search handled completely, stop running any further
//              IURLSearchHooks, but NO BROWSING NEEDED as a result,
//              pszResult is a copy of pcszQuery.
//
//              ;BUGBUG: This is not fully implemented, yet, making IURLQualify return this
//              involves too much change.
//
// BUGBUG:: E_ABORT is currently treated as E_FAIL. It requires too much change.
//
// E_FAIL       This Hook was unsuccessful. Search not handled at all,
//              pcszQueryURL has the query string. Please go on running
//              other IURLSearchHooks.
//
// BUGBUG:  There is a potential danger in this Interface, that is people can write
//          very bad SearchHooks, but we (Microsoft) take the blame.

// History:
//  --/--/94 KurtE Created
//
// History:
//  3/4/94 kraigb Created
//

//  CGID_DefView Command Target IDs. used to persist global DefView state

enum
{
    DVID_SETASDEFAULT,          // Set the DefView state of this folder as default for all of the same class
    DVID_RESETDEFAULT           // Reset the DefView state to the default (delete subkeys)
};

// CGID_ShellDocView Command Target IDs. for shell doc view wedge
enum {
    SHDVID_FINALTITLEAVAIL,     // DEAD: variantIn bstr - sent after final OLECMDID_SETTITLE is sent
    SHDVID_MIMECSETMENUOPEN,    // mimecharset menu open commands
    SHDVID_PRINTFRAME,          // print HTML frame
    SHDVID_PUTOFFLINE,          // DEAD: The Offline property has been changed
    SHDVID_PUTSILENT,           // DEAD: The frame's Silent property has been changed
    SHDVID_GOBACK,              // Navigate Back
    SHDVID_GOFORWARD,           // Navigate Forward
    SHDVID_CANGOBACK,           // Is Back Navigation Possible?
    SHDVID_CANGOFORWARD,        // Is Forward Navigation Possible?
    SHDVID_CANACTIVATENOW,      // (down) (PICS) OK to navigate to this view now?
    SHDVID_ACTIVATEMENOW,       // (up) (PICS) Rating checks out, navigate now
    SHDVID_CANSUPPORTPICS,      // (down) variantIn I4: IOleCommandTarget to reply to
    SHDVID_PICSLABELFOUND,      // (up) variantIn bstr: PICS label
    SHDVID_NOMOREPICSLABELS,    // (up) End of document, no more PICS labels coming
    SHDVID_CANDEACTIVATENOW,    // (QS down) (in script/etc) OK to deactivate view now?
    SHDVID_DEACTIVATEMENOW,     // (EXEC up) (in script/etc) out of script, deactivate view now
    SHDVID_NODEACTIVATENOW,     // (EXEC up) (in script/etc) entering script, disable deactivate
    SHDVID_AMBIENTPROPCHANGE,   // variantIn I4: dispid of ambient property that changed
    SHDVID_GETSYSIMAGEINDEX,    // variantOut: image index for current page
    SHDVID_GETPENDINGOBJECT,    // variantOut: IUnknown of pending shellview/docobject
    SHDVID_GETPENDINGURL,       // variantOut: BSTR of URL for pending docobject
    SHDVID_SETPENDINGURL,       // variantIn: BSTR of URL passed to pending docobject
    SHDVID_ISDRAGSOURCE,        // (down) varioutOut I4: non-zero if it's initiated drag&drop
    SHDVID_DOCFAMILYCHARSET,    // variantOut: I4: windows (family) codepage
    SHDVID_DOCCHARSET,          // variantOut: I4: actual (mlang) codepage
    SHDVID_RAISE,               // vaIn:I4:DTRF_*, vaOut:NULL unless DTRF_QUERY
    SHDVID_GETTRANSITION,       // (down) vaIn: I4: TransitionEvent; vaOut BSTR (CLSID), I4 (dwSpeed)
    SHDVID_GETMIMECSETMENU,     // get menu handle for mimecharset
    SHDVID_DOCWRITEABORT,       // Abort binding but activate pending docobject
    SHDVID_SETPRINTSTATUS,      // VariantIn: BOOL, TRUE - Started printing, FALSE - Finished printing
    SHDVID_NAVIGATIONSTATUS,    // QS for tooltip text and Exec when user clicks
    SHDVID_PROGRESSSTATUS,      // QS for tooltip text and Exec when user clicks
    SHDVID_ONLINESTATUS,        // QS for tooltip text and Exec when user clicks
    SHDVID_SSLSTATUS,           // QS for tooltip text and Exec when user clicks
    SHDVID_PRINTSTATUS,         // QS for tooltip text and Exec when user clicks
    SHDVID_ZONESTATUS,          // QS for tooltip text and Exec when user clicks
    SHDVID_ONCODEPAGECHANGE,    // variantIn I4: new specified codepage
    SHDVID_SETSECURELOCK,       // set the secure icon
    SHDVID_SHOWBROWSERBAR,      // show browser bar of clsid guid
    SHDVID_NAVIGATEBB,          // navigate to pidl in browserbar.
    SHDVID_UPDATEOFFLINEDESKTOP,// put the desktop in ON-LINE mode, update and put it back in Offline mode
    SHDVID_PICSBLOCKINGUI,      // (up) In I4: pointer to "ratings nugget" for block API
    SHDVID_ONCOLORSCHANGE,      // (up) sent by mshtml to indicate color set change
    SHDVID_CANDOCOLORSCHANGE,   // (down) used to query if document supports the above
    SHDVID_QUERYMERGEDHELPMENU, // was the help menu micro-merged?
    SHDVID_QUERYOBJECTSHELPMENU,// return the object's help menu
    SHDVID_HELP,                // do help
    SHDVID_UEMLOG,              // set UEM logging vaIn:I4:UEMIND_*, vaOut:NULL
    SHDVID_GETBROWSERBAR,       // get IDeskBand for browser bar of clsid guid
    SHDVID_GETFONTMENU,
    SHDVID_FONTMENUOPEN,
    SHDVID_CLSIDTOIDM,          // get the idm for the given clsid
    SHDVID_GETDOCDIRMENU,       // get menu handle for document direction
    SHDVID_ADDMENUEXTENSIONS,   // Context Menu Extensions
    SHDVID_CLSIDTOMONIKER,      // CLSID to property page resource mapping
    SHDVID_RESETSTATUSBAR,      // set the status bar back to "normal" icon w/out text
    SHDVID_ISBROWSERBARVISIBLE, // is browser bar of clsid guid visible?
    SHDVID_GETOPTIONSHWND,      // gets hwnd for internet options prop sheet (NULL if not open)
    SHDVID_DELEGATEWINDOWOM,    // set policy for whether window OM methods should be delegated.
    SHDVID_PAGEFROMPOSTDATA,    // determines if page was generated by post data
    SHDVID_DISPLAYSCRIPTERRORS, // tells the top docobject host to display his script err dialog
};

// CGID_SearchBand Command Target IDs.
enum {
    SBID_SEARCH_NEW,            // (re)load the context-appropriate url
    SBID_SEARCH_NEXT,           // cycle between multiple providers
    SBID_SEARCH_CUSTOMIZE,      // navigate to customization url
    SBID_SEARCH_HELP,           // what it says
    SBID_GETPIDL,               // get the search pane's pidl
};

//
//  this enum is used by SHDVID_SETSECURELOCK and SBCMDID_SETSECURELOCKICON
//  when adding new values, make sure to add to both SET and SUGGEST, and
//  the code depends on a direct correlation between the level of security
//  and the value of the enum.  so keep new values in the correct order
//
enum {
    SECURELOCK_NOCHANGE        = -1,
    SECURELOCK_SET_UNSECURE    = 0,
    SECURELOCK_SET_MIXED,
    SECURELOCK_SET_SECUREUNKNOWNBIT,
    SECURELOCK_SET_SECURE40BIT,
    SECURELOCK_SET_SECURE56BIT,
    SECURELOCK_SET_FORTEZZA,
    SECURELOCK_SET_SECURE128BIT,
    SECURELOCK_FIRSTSUGGEST,
    SECURELOCK_SUGGEST_UNSECURE = SECURELOCK_FIRSTSUGGEST,
    SECURELOCK_SUGGEST_MIXED,
    SECURELOCK_SUGGEST_SECUREUNKNOWNBIT,
    SECURELOCK_SUGGEST_SECURE40BIT,
    SECURELOCK_SUGGEST_SECURE56BIT,
    SECURELOCK_SUGGEST_FORTEZZA,
    SECURELOCK_SUGGEST_SECURE128BIT,
};

#define FCIDM_DRIVELIST    (FCIDM_BROWSERFIRST + 2) //
#define FCIDM_TREE         (FCIDM_BROWSERFIRST + 3) //
#define FCIDM_TABS         (FCIDM_BROWSERFIRST + 4) //
#define FCIDM_REBAR        (FCIDM_BROWSERFIRST + 5) //
typedef FOLDERSETTINGS *PFOLDERSETTINGS;
#define FCW_VIEW        0x0004
#define FCW_BROWSER     0x0005
#define FCW_MENUBAR     0x0007
#define FCW_ADDRESSBAR  0x0009
#define FCW_TOOLBAND    0x000a
#define FCW_LINKSBAR    0x000b
// CGID_Explorer Command Target IDs
enum {
    SBCMDID_ENABLESHOWTREE          = 0,
    SBCMDID_SHOWCONTROL             = 1,        // variant vt_i4 = loword = FCW_* hiword = SBSC_*
    SBCMDID_CANCELNAVIGATION        = 2,        // cancel last navigation
    SBCMDID_MAYSAVECHANGES          = 3,        // about to close and may save changes
    SBCMDID_SETHLINKFRAME           = 4,        // variant vt_i4 = phlinkframe
    SBCMDID_ENABLESTOP              = 5,        // variant vt_bool = fEnable
    SBCMDID_OPTIONS                 = 6,        // the view.options page
    SBCMDID_EXPLORER                = 7,        // are you explorer.exe?
    SBCMDID_ADDTOFAVORITES          = 8,
    SBCMDID_ACTIVEOBJECTMENUS       = 9,
    SBCMDID_MAYSAVEVIEWSTATE        = 10,       // Should we save view stream
    SBCMDID_DOFAVORITESMENU         = 11,       // popup the favorites menu
    SBCMDID_DOMAILMENU              = 12,       // popup the mail menu
    SBCMDID_GETADDRESSBARTEXT       = 13,       // get user-typed text
    SBCMDID_ASYNCNAVIGATION         = 14,       // do an async navigation
    SBCMDID_SEARCHBAROBSOLETE       = 15,       // OBSOLETE beta-1 SEARCHBAR
    SBCMDID_FLUSHOBJECTCACHE        = 16,       // flush object cache
    SBCMDID_CREATESHORTCUT          = 17,       // create a shortcut
    SBCMDID_SETMERGEDWEBMENU        = 18,       // set pre-merged menu for HTML
    SBCMDID_REMOVELOCKICON          = 19,       // Remove lock icon
    SBCMDID_SELECTHISTPIDL          = 20,       // QS:EXEC select history pidl on navigate
    SBCMDID_WRITEHIST               = 21,       // QS only:write history sf on navigate
    SBCMDID_GETHISTPIDL             = 22,       // EXEC gets most recent history pidl
    SBCMDID_REGISTERNSCBAND         = 23,       // EXEC registers NscBand when visible
    SBCMDID_COCREATEDOCUMENT        = 24,       // Create an instance of MSHTML
    SBCMDID_SETSECURELOCKICON       = 25,       // sets the SSL lock icon for the current page
    SBCMDID_INITFILECTXMENU         = 26,       // EXEC,QS: file context menu for band item
    SBCMDID_UNREGISTERNSCBAND       = 27,       // EXEC unregisters NscBand when invisible
    SBCMDID_SEARCHBAR               = 28,       // show/hide/toggle BrowserBar search
    SBCMDID_HISTORYBAR              = 29,       // show/hide/toggle BrowserBar history
    SBCMDID_FAVORITESBAR            = 30,       // show/hide/toggle BrowserBar favorites
#ifdef ENABLE_CHANNELS
    SBCMDID_CHANNELSBAR             = 31,       // show/hide/toggle BrowserBar channels
#endif
    SBCMDID_SENDPAGE                = 32,       // sends the current page via email
    SBCMDID_SENDSHORTCUT            = 33,       // sends a shortcut to current page via email
    SBCMDID_TOOLBAREMPTY            = 34,       // toolbar has nothing visible
    SBCMDID_EXPLORERBAR             = 35,       // show/hide/toggle BrowserBar all folders
    SBCMDID_GETUSERADDRESSBARTEXT   = 36,       // get the exact text the user-entered
    SBCMDID_HISTSFOLDER             = 37,       // EXEC varOut returns cached history IShellFolder
    SBCMDID_UPDATETRAVELLOG         = 38,       // updates the travellog with the current info
    SBCMDID_MIXEDZONE               = 39,       // The current view has mixed zones
    SBCMDID_REPLACELOCATION         = 40,       // replace the current URL with this one.
    SBCMDID_GETPANE                 = 41,       // Browser asks the view for pane ordinal
    SBCMDID_FILERENAME              = 42,       // Browser forwards file->rename to explorer bar
    SBCMDID_FILEDELETE              = 43,       // Browser forwards file->delete to explorer bar
    SBCMDID_FILEPROPERTIES          = 44,       // Browser forwards file->properties to explorer bar
    SBCMDID_IESHORTCUT              = 45,       // Navigates the browser to an .url file
    SBCMDID_GETSHORTCUTPATH         = 46,       // Asks for the path to the shortcut - if it exists
    SBCMDID_DISCUSSIONBAND          = 47,       // show/hide/toggle the Office discussion band
    SBCMDID_SETADDRESSBARFOCUS      = 48,       // Set focus on address bar on WM_ACTIVATE (UNIX)
    SBCMDID_HASADDRESSBARFOCUS      = 49,       // Checks whether address bar has focus (UNIX)
    SBCMDID_MSGBAND                 = 50,       // MsgBand Message (UNIX)
    SBCMDID_ISIEMODEBROWSER         = 51,       // returns S_OK if browser is in IE mode
    SBCMDID_GETTEMPLATEMENU         = 52,       // get handle to template menu
    SBCMDID_GETCURRENTMENU          = 53,       // get handle to current menu
    SBCMDID_ERRORPAGE               = 54,       // informs addressbar mru that this is an error page
    SBCMDID_AUTOSEARCHING           = 55,       // informs addressbar mru that we are trying a new url
    SBCMDID_STARTEDFORINTERNET      = 56,       // return S_OK if window started as IE window, S_FALSE otherwise
    SBCMDID_ISBROWSERACTIVE         = 57,       // return S_OK if the browser is active, S_FALSE otherwise
    SBCMDID_SUGGESTSAVEWINPOS       = 58,       // return S_OK if browser decides to save window position, S_FALSE otherwise
    SBCMDID_CACHEINETZONEICON       = 59,       // Cache/refresh internet zone icons painted by status bar
    SBCMDID_ONVIEWMOVETOTOP         = 60,       // Notification that the view window has moved to HWND_TOP
};

#define ZONE_UNKNOWN    -1
#define ZONE_MIXED      -2
#define IS_SPECIAL_ZONE(a) (((a) == ZONE_UNKNOWN) || ((a) == ZONE_MIXED))

// SBCMDID_GETPANE
#define PANE_NONE        -1
#define PANE_ZONE        1
#define PANE_OFFLINE     2
#define PANE_PRINTER     3
#define PANE_SSL         4
#define PANE_NAVIGATION  5
#define PANE_PROGRESS    6



#if (_WIN32_IE >= 0x0400)
// CGID_AddresseditBox Command Target IDs
enum {
    AECMDID_SAVE                    = 0,        // Ask AddressEditBox to save
};
#endif

// The pvid parameter of the GetView() method of IShellView2 is normally only an OUT parameter.
// But, for SV2GV_ISEXTENDEDVIEW, it is an IN parameter.
#define SV2GV_ISEXTENDEDVIEW    ((UINT)-3)
#define STRRET_OLESTR   0x0000          // same as STRRET_WSTR
#define STRRET_OFFPTR(pidl,lpstrret) ((LPSTR)((LPBYTE)(pidl)+(lpstrret)->NAMELESS_MEMBER(uOffset)))
SHSTDAPI_(int) SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);	//
#define REGSTR_PATH_INTERNET_EXPLORER   TEXT("\\SOFTWARE\\Microsoft\\Internet Explorer")
#define REGSTR_PATH_IE_MAIN             REGSTR_PATH_INTERNET_EXPLORER TEXT("\\Main")
#define REGSTR_VALUE_USER_AGENT         TEXT("UserAgent")
#define REGSTR_DEFAULT_USER_AGENT       TEXT("Mozilla/2.0 (compatible; MSIE 3.0A; Windows 95)")
                                    //  0x000c
                                    //  0x000d
                                    //  0x000e
                                    //  0x000f
#define CSIDL_FLAG_DONT_UNEXPAND        0x2000        // combine with CSIDL_ value to avoid unexpanding environment variables
SHSTDAPI_(void) SHFlushSFCache(void);
SHSTDAPI_(LPITEMIDLIST) SHCloneSpecialIDList(HWND hwnd, int csidl, BOOL fCreate);
SHFOLDERAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszPath);
SHFOLDERAPI SHSetFolderPathW(int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszPath);
#ifdef UNICODE
#define SHSetFolderPath  SHSetFolderPathW
#else
#define SHSetFolderPath  SHSetFolderPathA
#endif // !UNICODE
#if (_WIN32_IE >= 0x0500)

#define FCS_READ                    0x00000001
#define FCS_FORCEWRITE              0x00000002
#define FCS_WRITE                   (FCS_READ | FCS_FORCEWRITE)

#define FCS_FLAG_DRAGDROP           2

// Mask which values have been retreived or being set.
#define FCSM_VIEWID                 0x00000001
#define FCSM_WEBVIEWTEMPLATE        0x00000002
#define FCSM_INFOTIP                0x00000004
#define FCSM_CLSID                  0x00000008
#define FCSM_ICONFILE               0x00000010
#define FCSM_LOGO                   0x00000020
#define FCSM_FLAGS                  0x00000040

// Used by SHGetSetFolderCustomSettingsA
typedef struct
{
    DWORD           dwSize;
    DWORD           dwMask;             // IN/OUT   Which Attributes to Get/Set
    SHELLVIEWID*    pvid;               // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // The folder's WebView template path
    LPSTR           pszWebViewTemplate;  // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchWebViewTemplate;  // IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
                                        // Ignored if dwReadWrite is FCS_READ
    LPSTR           pszWebViewTemplateVersion;  // currently IN only
    // Infotip for the folder
    LPSTR           pszInfoTip;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchInfoTip;         // IN - Specifies the size of the buffer pointed to by pszInfoTip
                                        // Ignored if dwReadWrite is FCS_READ
    // CLSID that points to more info in the registry
    CLSID*          pclsid;             // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // Other flags for the folder. Takes FCS_FLAG_* values
    DWORD           dwFlags;            // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPSTR           pszIconFile;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchIconFile;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                        // Ignored if dwReadWrite is FCS_READ

    int             iIconIndex;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPSTR           pszLogo;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchLogo;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                        // Ignored if dwReadWrite is FCS_READ


} SHFOLDERCUSTOMSETTINGSA, *LPSHFOLDERCUSTOMSETTINGSA;
// Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE
HRESULT SHGetSetFolderCustomSettingsA(LPSHFOLDERCUSTOMSETTINGSA pfcs, LPCSTR pszPath, DWORD dwReadWrite);

// Used by SHGetSetFolderCustomSettingsW
typedef struct
{
    DWORD           dwSize;
    DWORD           dwMask;              // IN/OUT  Which Attributes to Get/Set
    SHELLVIEWID*    pvid;                // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // The folder's WebView template path
    LPWSTR          pszWebViewTemplate;   // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchWebViewTemplate;   // IN - Specifies the size of the buffer pointed to by pszWebViewTemplate
                                         // Ignored if dwReadWrite is FCS_READ
    LPWSTR           pszWebViewTemplateVersion;  // currently IN only
    // Infotip for the folder
    LPWSTR          pszInfoTip;          // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD           cchInfoTip;          // IN - Specifies the size of the buffer pointed to by pszInfoTip
                                         // Ignored if dwReadWrite is FCS_READ
    // CLSID that points to more info in the registry
    CLSID*          pclsid;              // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    // Other flags for the folder. Takes FCS_FLAG_* values
    DWORD           dwFlags;             // OUT - if dwReadWrite is FCS_READ, IN - otherwise


    LPWSTR           pszIconFile;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchIconFile;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ

    int              iIconIndex;         // OUT - if dwReadWrite is FCS_READ, IN - otherwise

    LPWSTR           pszLogo;        // OUT - if dwReadWrite is FCS_READ, IN - otherwise
    DWORD            cchLogo;        // IN - Specifies the size of the buffer pointed to by pszIconFile
                                         // Ignored if dwReadWrite is FCS_READ
} SHFOLDERCUSTOMSETTINGSW, *LPSHFOLDERCUSTOMSETTINGSW;
// Gets/Sets the Folder Custom Settings for pszPath based on dwReadWrite. dwReadWrite can be FCS_READ/FCS_WRITE/FCS_FORCEWRITE
HRESULT SHGetSetFolderCustomSettingsW(LPSHFOLDERCUSTOMSETTINGSW pfcs, LPCWSTR pszPath, DWORD dwReadWrite);

#ifdef UNICODE
#define SHFOLDERCUSTOMSETTINGS          SHFOLDERCUSTOMSETTINGSW
#define SHGetSetFolderCustomSettings    SHGetSetFolderCustomSettingsW
#define LPSHFOLDERCUSTOMSETTINGS        LPSHFOLDERCUSTOMSETTINGSW
#else
#define SHFOLDERCUSTOMSETTINGS          SHFOLDERCUSTOMSETTINGSA
#define SHGetSetFolderCustomSettings    SHGetSetFolderCustomSettingsA
#define LPSHFOLDERCUSTOMSETTINGS        LPSHFOLDERCUSTOMSETTINGSA
#endif

#endif  // _WIN32_IE >= 0x0500
    // pszTitle can be a resource, but the hinst is assumed to be shell32.dll
    // lpszTitle can be a resource, but the hinst is assumed to be shell32.dll

//-------------------------------------------------------------------------
//
// Shell Service Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShellServiceObject
enum {
    SSOCMDID_LOAD        = 0,
    SSOCMDID_UNLOAD      = 1,
    SSOCMDID_OPEN        = 2,
    SSOCMDID_CLOSE       = 3,
    SSOCMDID_STARTMENU   = 4,
    SSOCMDID_SAVETODOCUMENT=5,
};
#define CMDID_SAVEASTHICKET  SSOCMDID_SAVETODOCUMENT

//-------------------------------------------------------------------------
//
// Internet Shortcut Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShortCut
enum {
    ISHCUTCMDID_DOWNLOADICON  = 0,
    ISHCUTCMDID_INTSHORTCUTCREATE = 1,
};
#define CMDID_INTSHORTCUTCREATE ISHCUTCMDID_INTSHORTCUTCREATE



//-------------------------------------------------------------------------
// STR_DISPLAY_UI_DURING_BINDING - IBindCtx Key
//-------------------------------------------------------------------------
// If displaying UI during binding is allowed, this parameter
// will be in the IBindCtx so the object binding can get the
// IUnknown* of the site in order to:
// 1. Use the site's hwnd as the parent hwnd of any UI dialogs.
//    This is done via. IOleWindow::GetWindow() or IInternetSecurityMgrSite::GetWindow()
// 2. While the dialog is being displayed, make the site modal
//    This is done via:
//       IOleInPlaceActiveObject::EnableModeless()
//       IOleInPlaceUIWindow::EnableModelessSB()
//       IInternetSecurityMgrSite::EnableModeless()

#define STR_DISPLAY_UI_DURING_BINDING      L"UI During Binding"


//  This member function should always create a new
//
//  SHCIDS_ALLFIELDS is a mask for lParam indicating that the shell folder
//  should first compare on the lParam column, and if that proves equal,
//  then perform a full comparison on all fields.  This flag is supported
//  if the IShellFolder supports IShellFolder2.
//
//  If you add more flags in the future, you need to enhance the return
//  value from SFVM_SUPPORTSIDENTITY.
//
// IShellFolderFilterSite

#undef  INTERFACE
#define INTERFACE       IShellFolderFilterSite

DECLARE_INTERFACE_(IShellFolderFilterSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderFilterSite methods ***
    STDMETHOD(SetFilter)(THIS_ IUnknown* punk) PURE;
};

// IIDListFilter

#undef  INTERFACE
#define INTERFACE       IShellFolderFilter

DECLARE_INTERFACE_(IShellFolderFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderFilter methods ***
    STDMETHOD(ShouldShow)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem) PURE;
    STDMETHOD(GetEnumFlags)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags) PURE;
};

//
// The IShellDetails interface was private in win95 and didnt have a _WIN32_IE guard,
// so it is now in shlobj.h, along with the definition of SHELLDETAILS
//


//-------------------------------------------------------------------------
//
// DELEGATEITEMID structure
//
//
// A Delegate Item ID is a standard SHITEMID with some additional
// fields defined.
//
//-------------------------------------------------------------------------

typedef struct tagDELEGATEITEMID {
    WORD cbSize;                // Size of entire item ID
    WORD wOuter;                // Private data owned by the outer folder
    WORD cbInner;               // Size of delegate's data
    BYTE rgb[1];                // Inner folder's data,
                                //   followed by outer folder's data.
} DELEGATEITEMID;

typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;
typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;


//-------------------------------------------------------------------------
//
// IDelegateFolder interface
//
//
// [Member functions]
//
// IDelegateFolder::SetItemAlloc(pm)
//   This function gives the object an IMalloc interface that it
//   should use to alloc and free item IDs.  These IDs are in the
//   form of DELEGATEITEMIDs.
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDelegateFolder

DECLARE_INTERFACE_(IDelegateFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDelegateFolder methods ***
    STDMETHOD(SetItemAlloc)(THIS_ IMalloc *pmalloc) PURE;
};

#undef  INTERFACE
#define INTERFACE   IMountedVolume

DECLARE_INTERFACE_(IMountedVolume, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMountedVolume methods ***
    STDMETHOD(Initialize)(THIS_ LPCWSTR pcszHostFolderPath) PURE;
};
//-------------------------------------------------------------------------
// This is the interface for a browser to "subclass" the main File Cabinet
// window.  Note that only the hwnd, message, wParam, and lParam fields of
// the msg structure are used.  The browser window will get a WM_NOTIFY
// message with NULL ID, FCN_MESSAGE as the code, and a far pointer to
// FCMSG_NOTIFY as the lParam.
//
//-------------------------------------------------------------------------
typedef struct tagFCMSG_NOTIFY
{
    NMHDR   hdr;
    MSG     msg;
    LRESULT lResult;
} FCMSG_NOTIFY;

#define FCN_MESSAGE (100)


//---------------------------------------------------------------------------
// messages that can be send to the cabinet by other apps
//
// REVIEW: Do we really need to publish any of those?
//---------------------------------------------------------------------------

#define NF_INHERITVIEW 0x0000
#define NF_LOCALVIEW   0x0001

// Change the path of an existing folder.
// wParam:
//      0:              LPARAM is a pidl, handle the message immediately.
//      CSP_REPOST:     LPARAM is a pidl, copy the pidl and handle the
//                      message later.
//      CSP_NOEXECUTE:  if this path is not a folder, fail, don't shell exec
//
//
// lParam: LPITEMIDLIST of path.
//
//
#define CSP_REPOST                  0x0001
#define CSP_INITIATEDBYHLINKFRAME   0x0002
#define CSP_NOEXECUTE               0x0004
#define CSP_NONAVIGATE              0x0008
#define CWM_SETPATH                 (WM_USER + 2)

// lpsv points to the Shell View extension that requested idle processing
// uID is an app define identifier for the processor
// returns: TRUE if there is more idle processing necessary, FALSE if all done
// Note that the idle processor should do one "atomic" operation and return
// as soon as possible.
typedef BOOL (CALLBACK *FCIDLEPROC)(void *lpsv, UINT uID);

// Inform the File Cabinet that you want idle messages.
// This should ONLY be used by File Cabinet extensions.
// wParam: app define UINT (passed to FCIDLEPROC).
// lParam: pointer to an FCIDLEPROC.
// return: TRUE if successful; FALSE otherwise
//
#define CWM_WANTIDLE                (WM_USER + 3)

// get or set the FOLDERSETTINGS for a view
// wParam: BOOL TRUE -> set to view info buffer, FALSE -> get view info buffer
// lParam: LPFOLDERSETTINGS buffer to get or set view info
//
#define CWM_GETSETCURRENTINFO       (WM_USER + 4)
#define FileCabinet_GetSetCurrentInfo(_hwnd, _bSet, _lpfs) \
             SendMessage(_hwnd, CWM_GETSETCURRENTINFO, (WPARAM)(_bSet), (LPARAM)(LPFOLDERSETTINGS)_lpfs)

// selects the specified item in the current view
// wParam: SVSI_* flags
// lParam: LPCITEMIDLIST of the item ID, NULL -> all items
//
#define CWM_SELECTITEM              (WM_USER + 5)
#define FileCabinet_SelectItem(_hwnd, _sel, _item) \
            SendMessage(_hwnd, CWM_SELECTITEM, _sel, (LPARAM)(LPCITEMIDLIST)(_item))

// selects the specified path in the current view
// wParam: SVSI_* flags
// lParam: LPCSTR of the display name
//
#define CWM_SELECTPATH              (WM_USER + 6)
#define FileCabinet_SelectPath(_hwnd, _sel, _path)  \
            SendMessage(_hwnd, CWM_SELECTPATH, _sel, (LPARAM)(LPCSTR)(_path))

// Get the IShellBrowser object associated with an hwndMain
#define CWM_GETISHELLBROWSER        (WM_USER + 7)
#define FileCabinet_GetIShellBrowser(_hwnd)     \
            (IShellBrowser*)SendMessage(_hwnd, CWM_GETISHELLBROWSER, 0, 0L)

//
//  two pidls can have the same path, so we need a compare pidl message
#define CWM_COMPAREPIDL                (WM_USER + 9)
//
//  sent when the global state changes
#define CWM_GLOBALSTATECHANGE           (WM_USER + 10)
#define CWMF_GLOBALSTATE                0x0000
#define CWMF_SECURITY                   0x0001

//  sent to the desktop from a second instance
#define CWM_COMMANDLINE                 (WM_USER + 11)
// global clone your current pidl
#define CWM_CLONEPIDL                   (WM_USER + 12)
// See if the root of the instance is as specified
#define CWM_COMPAREROOT                 (WM_USER + 13)
// Tell desktop our root
#define CWM_SPECIFYCOMPARE              (WM_USER + 14)
// See if the root of the instance matches a hwnd
#define CWM_PERFORMCOMPARE              (WM_USER + 15)
// Forward SHChangeNotify events
#define CWM_FSNOTIFY                    (WM_USER + 16)
// Forward SHChangeRegistration events
#define CWM_CHANGEREGISTRATION          (WM_USER + 17)
// For AddToRecentDocs processing by desktop
#define CWM_ADDTORECENT                 (WM_USER + 18)
// For SHWaitForFile processing by desktopop
#define CWM_WAITOP                      (WM_USER + 19)

// Notify for changes to the fav's folder.
#define CWM_FAV_CHANGE                  (WM_USER + 20)
#define CWM_SHOWDRAGIMAGE               (WM_USER + 21)
#define CWM_SHOWFOLDEROPT               (WM_USER + 22)

#define CWM_FSNOTIFYSUSPENDRESUME       (WM_USER + 23)

#define CWM_RESERVEDFORCOMDLG_FIRST     (WM_USER + 100)
#define CWM_RESERVEDFORCOMDLG_LAST      (WM_USER + 199)
#define CWM_RESERVEDFORWEBBROWSER_FIRST (WM_USER + 200)
#define CWM_RESERVEDFORWEBBROWSER_LAST  (WM_USER + 299)
//   ;BUGBUG (scotth): fill this in
#define STFRF_NORMAL            DWFRF_NORMAL
#define STFRF_DELETECONFIGDATA  DWFRF_DELETECONFIGDATA
//
//   formerly IDockingWindow::SetToolbarSite
//   ;BUGBUG (scotth): what's the difference b/t punkToolbarSite
//                    and the punkSite provided by the
//                    SetToolbarSite method?

#undef  INTERFACE
#define INTERFACE   IMultiMonitorDockingSite

DECLARE_INTERFACE_(IMultiMonitorDockingSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMultiMonitorDockingSite methods ***
    STDMETHOD(GetMonitor) (THIS_ IUnknown* punkSrc, HMONITOR * phMon) PURE;
    STDMETHOD(RequestMonitor) (THIS_ IUnknown* punkSrc, HMONITOR * phMon) PURE;
    STDMETHOD(SetMonitor) (THIS_ IUnknown* punkSrc, HMONITOR hMonNew, HMONITOR *phMonOld) PURE;
};
#define DBIMF_FIXED             0x0001  //
#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)   //
#define DBIMF_UNDELETEABLE      0x0010   //
#define DBIMF_USECHEVRON        0x0080  //
#define DBIMF_BREAK             0x0100  //
// flags for DBID_PUSHCHEVRON
#define DBPC_SELECTFIRST    (DWORD)-1
#define DBPC_SELECTLAST     (DWORD)-2

#ifdef ISHELLTOOLBAND_COMPAT
#undef  INTERFACE
#define INTERFACE   IShellToolband

DECLARE_INTERFACE_(IShellToolband, IDockingWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDockingWindow methods ***
    STDMETHOD(ShowDW)         (THIS_ BOOL fShow) PURE;
    STDMETHOD(CloseDW)        (THIS_ DWORD dwReserved) PURE;
    STDMETHOD(ResizeBorderDW) (THIS_ LPCRECT   prcBorder,
                                     IUnknown* punkToolbarSite,
                                     BOOL      fReserved) PURE;
    // *** IShellToolband methods ***
    STDMETHOD(GetBandInfo)    (THIS_ DWORD fViewMode, LPPOINT pptSize,
                              LPWSTR pszTitle, int cchTitle, DWORD *dwSizeMode) PURE;
};

// IShellToolband Enum
typedef enum {
        STBE_MINSIZE = 0,
        STBE_MAXSIZE,
        STBE_INTEGRAL,
        STBE_ACTUAL,

        STBE_MAX   // how many are there?
} STBENUM;

// command target ids
enum {
        STBID_BANDINFOCHANGED,
};

#define STBBIF_VIEWMODE_NORMAL   0x0000
#define STBBIF_VIEWMODE_VERTICAL 0x0001
#define STBBIF_VIEWMODE_FLOATING 0x0002

#define STBBIF_SIZEMODE_NORMAL  0x0
#define STBBIF_SIZEMODE_FIXED   0x1
#define STBBIF_SIZEMODE_TITLE   0x2
#define STBBIF_SIZEMODE_FIXEDBMP 0x4   // a fixed background bitmap (if supported)
#define STBBIF_SIZEMODE_VARIABLEHEIGHT 0x8

#define STBBIF_DRAGMODE_UNDELETEABLE 0x10
#endif
#if (_WIN32_IE >= 0x0400)

#define TASKOWNERID     GUID
#define REFTASKOWNERID  REFGUID


// ---ITaskScheduler
// An interface for interacting with and controlling a task scheduler. This
// interface does not need to be free-threaded unless the items in the queue
// interact with the scheduler as well as the main execution thread on which the
// task scheduler was created.

// ITaskScheduler::AddTask()
//      Adds Tasks to the scheduler's background queue. The TASKOWNERID allow particular types
//      of tasks to be grouped so that they can be counted or removed. The lParam allows the task
//      to be associated with a particular item (for example an item in a listview).
// ITaskScheduler::RemoveTasks()
//      Removes tasks from the scheduler's queue. These can be sepcified in terms of their TASKOWNERID
//      or their LPARAM, or both, or neither (TOID_NULL && ITSAT_DEFAULT_LPARAM results in all tasks being
//      removed). If a task that matches is currently running and ITaskScheduler::Status() has been
//      passeed ITSSFLAG_KILL_ON_DESTROY then the scheduler will attempt to kill the current task. The
//      fWaitIfRunning parameter is then passed to IRunnableTask::Kill().
// ITaskScheduler::CountTasks()
//      Counts the tasks in the queue depending upon the TASKOWNERID and the LPARAM passed. (TOID_NULL and
//      ITSAT_DEFAULT_LPARAM will count all tasks in the queue)
// ITaskScheduler::Status()
//      This sets the ReleaseStatus for the current task and the background thread timeout. When
//      ITaskScheduler::RemoveTasks() is called and there is a task currently running that matches
//      ITSSFLAG_COMPLETE_ON_DESTROY will cause TRUE to be passed to the task's IRunnableTask::Kill().
//      The dwThreadTimeout parameter if not set to the default will cause the background thread to
//      die if no new tasks have been added to the queue in the timeout period. The Thread will be
//      recreated when the next new task is added.

////////////////////////
// Status() flags,
// wait for the current task to complete before deleting the scheduler
#define ITSSFLAG_COMPLETE_ON_DESTROY        0x0000

// kill the current task (if there is one) when the task scheduler is deleted
#define ITSSFLAG_KILL_ON_DESTROY            0x0001

#define ITSSFLAG_SUPPORTS_TERMINATE         0x0002

#define ITSSFLAG_FLAGS_MASK                 0x0003

// set the timeout for killing the thread when the object is terminated.
// this timeout can be used to stop the object from blocking the system
// indefinitely.
#define ITSSFLAG_THREAD_TERMINATE_TIMEOUT   0x0010

// set the timeout for threads that are idle in the thread pool
#define ITSSFLAG_THREAD_POOL_TIMEOUT        0x0020

// The default timeout passed to release Status to determine how long the thread
// can be asleep before the thread is expired
#define ITSS_THREAD_DESTROY_DEFAULT_TIMEOUT     (60*1000)

// default, we won't kill it...
#define ITSS_THREAD_TERMINATE_TIMEOUT           (INFINITE)

// there is no change to the thread timeout
#define ITSS_THREAD_TIMEOUT_NO_CHANGE           (INFINITE - 1)

// the LPARAM allows task to be associated with items thus all tasks owned by a
// particular item can be accessed by passing a non default value for this parameter
#define ITSAT_DEFAULT_LPARAM        0xffffffff

// Task priorities
// ---------------
// This depends on the cooperation of tasks currently under execution. New tasks will
// be inserted in the queue in priority order. If a task of a low priority is currently
// under execution when a higher priority task is added, the scheduler will attempt
// to suspend the task currently under execution. It will be resumed when the other tasks
// have been completed.
#define ITSAT_DEFAULT_PRIORITY      0x10000000
#define ITSAT_MAX_PRIORITY          0x7fffffff
#define ITSAT_MIN_PRIORITY          0x00000000

#define TOID_NULL   CLSID_NULL

#undef INTERFACE
#define INTERFACE IShellTaskScheduler

DECLARE_INTERFACE_( IShellTaskScheduler, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IShellTaskScheduler methods ***
    STDMETHOD (AddTask)(THIS_ IRunnableTask * pTask,
               REFTASKOWNERID rtoid,
               DWORD_PTR lParam,
               DWORD dwPriority ) PURE;

    STDMETHOD (RemoveTasks)(THIS_ REFTASKOWNERID rtoid,
               DWORD_PTR lParam,
               BOOL fWaitIfRunning ) PURE;

    STDMETHOD_(UINT, CountTasks)(THIS_ REFTASKOWNERID rtoid) PURE;

    STDMETHOD (Status)(THIS_ DWORD dwReleaseStatus, DWORD dwThreadTimeout ) PURE;
};

typedef IShellTaskScheduler * LPSHELLTASKSCHEDULER;


// --- IExtractImage
//-------------------------------------------------------------------------
//
// IThumbnail interface
//
//
// [Member functions]
//
// IThumbnail::Init(HWND hwnd, UINT uMsg)
//   Must initialize interface before use.  The hwnd given will receive the
//   uMsg message when the bitmap is computed (cf. GetBitmap()).
//
// IThumbnail::GetBitmap(LPCWSTR pwszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
//   Call this function to actually compute and return the bitmap.  pszFile is
//   the file UNC whose bitmap is to be computed.  lWidth and lHeight are the
//   width and height respectively of the rectangle containing the thumbnail,
//   i.e. the size of the resultant bitmap.  When the bitmap is computed, the
//   uMsg is sent to the hwnd (cf. Init()) where LPARAM is the HBITMAP, and
//   WPARAM is dwItem (so it's an ID to identify the bitmap).
//   NOTE: Call GetBitmap(NULL,...) to cancel any pending requests.
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IThumbnail

DECLARE_INTERFACE_(IThumbnail, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IThumbnail specific methods ***
    STDMETHOD(Init) (THIS_ HWND hwnd, UINT uMsg) PURE;
    STDMETHOD(GetBitmap) (THIS_ LPCWSTR wszFile, DWORD dwItem, LONG lWidth, LONG lHeight) PURE;
};

#endif
#if (_WIN32_IE >= 0x0400)

// Interface used to scale and sharpen images...
// right now, always pass the palette from SHCreateShellPalette on a 256 colour machine...
#undef  INTERFACE
#define INTERFACE   IScaleAndSharpenImage2

DECLARE_INTERFACE_ (IScaleAndSharpenImage2, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IScaleAndSharpenImage methods ***
    STDMETHOD( ScaleSharpen2 ) ( THIS_ BITMAPINFO * pbi,
                                void * pBits,
                                HBITMAP * phBmpThumbnail,
                                const SIZE * prgSize,
                                DWORD dwRecClrDepth,
                                HPALETTE hpal,
                                UINT uiSharpPct,
                                BOOL fOrigSize) PURE;
};

// IImageCache
// Interface for controlling and accessing an imagecache of bitmaps for icons..

// flags for the dwMask member of IMAGECACHEINFO
#define ICIFLAG_LARGE       0x0001
#define ICIFLAG_SMALL       0x0002
#define ICIFLAG_BITMAP      0x0004
#define ICIFLAG_ICON        0x0008
#define ICIFLAG_INDEX       0x0010
#define ICIFLAG_NAME        0x0020
#define ICIFLAG_FLAGS       0x0040
#define ICIFLAG_NOUSAGE     0x0080
#define ICIFLAG_DATESTAMP   0x0100
#define ICIFLAG_MIRROR      0x2000

typedef struct _tagImageCacheInfo
{
    DWORD        cbSize;
    DWORD        dwMask;
    union
    {
        HBITMAP  hBitmapLarge;
        HICON    hIconLarge;
    };
    HBITMAP      hMaskLarge;
    union
    {
        HBITMAP  hBitmapSmall;
        HICON    hIconSmall;
    };
    HBITMAP      hMaskSmall;
    LPCWSTR      pszName;
    int          iIndex;
    DWORD        dwFlags;
#if (_WIN32_IE >= 0x0500)
    FILETIME     ftDateStamp;
#endif
} IMAGECACHEINFO;

typedef IMAGECACHEINFO * LPIMAGECACHEINFO;
typedef const IMAGECACHEINFO * LPCIMAGECACHEINFO;

#define ICIIFLAG_LARGE          0x0001
#define ICIIFLAG_SMALL          0x0002

typedef struct _tagImageCacheInitInfo
{
    DWORD cbSize;
    DWORD dwMask;
    HIMAGELIST himlLarge;
    HIMAGELIST himlSmall;
    SIZEL rgSizeLarge;
    SIZEL rgSizeSmall;
    DWORD dwFlags;
    int   iStart;
    int   iGrow;
}IMAGECACHEINITINFO;

typedef IMAGECACHEINITINFO * LPIMAGECACHEINITINFO;

#undef  INTERFACE
#define INTERFACE   IImageCache

DECLARE_INTERFACE_ ( IImageCache, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;
};
typedef IImageCache * LPIMAGECACHE;

#if (_WIN32_IE >= 0x0500)

// IImageCache 2

#undef  INTERFACE
#define INTERFACE  IImageCache2

DECLARE_INTERFACE_ ( IImageCache2, IImageCache )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;

    // IImageCache2 methods
    STDMETHOD ( DeleteImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( GetImageInfo ) (THIS_ UINT iImageIndex, LPIMAGECACHEINFO pInfo ) PURE;
};

#endif

#if ( _WIN32_IE >= 0x0500 )
///////////////////////////////////////////////////////////////////////
// interface for
typedef struct _EnumImageStoreDATAtag
{
    WCHAR     szPath[MAX_PATH];
    FILETIME  ftTimeStamp;
} ENUMSHELLIMAGESTOREDATA, * PENUMSHELLIMAGESTOREDATA;

#undef  INTERFACE
#define INTERFACE   IEnumShellImageStore

DECLARE_INTERFACE_( IEnumShellImageStore, IUnknown )
{
    STDMETHOD ( QueryInterface ) ( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    STDMETHOD ( Reset ) ( THIS ) PURE;
    STDMETHOD ( Next ) ( THIS_ ULONG celt, PENUMSHELLIMAGESTOREDATA * prgElt, ULONG * pceltFetched ) PURE;
    STDMETHOD ( Skip ) ( THIS_ ULONG celt ) PURE;
    STDMETHOD ( Clone ) ( THIS_ IEnumShellImageStore ** ppEnum ) PURE;
};

typedef IEnumShellImageStore * LPENUMSHELLIMAGESTORE;


// flags used to determine the capabilities of the storage for the images
#define SHIMSTCAPFLAG_LOCKABLE    0x0001       // does the store require/support locking
#define SHIMSTCAPFLAG_PURGEABLE   0x0002       // does the store require dead items purging externally ?

#undef  INTERFACE
#define INTERFACE   IShellImageStore

// this interface is used to manipulate the Image cache. It can potentially be used
// in a free threaded manner in conjunction with the Lock parameter to Open and close
DECLARE_INTERFACE_( IShellImageStore, IUnknown )
{
    STDMETHOD ( QueryInterface )( THIS_ REFIID riid, void **ppv ) PURE;
    STDMETHOD_( ULONG, AddRef ) ( THIS ) PURE;
    STDMETHOD_( ULONG, Release ) ( THIS ) PURE;

    // if the lock parameter is used, then all other calls into
    // open and/or create will block until the lock is released.
    STDMETHOD ( Open ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;
    STDMETHOD ( Create ) ( THIS_ DWORD dwMode, DWORD * pdwLock ) PURE;

    // if the lock is passed to either of these two methods, it releases the lock
    // once the operation is complete.
    STDMETHOD ( ReleaseLock ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Close ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( Commit ) ( THIS_ DWORD const * pdwLock ) PURE;
    STDMETHOD ( IsLocked ) ( THIS ) PURE;

    STDMETHOD ( GetMode ) ( THIS_ DWORD * pdwMode ) PURE;
    STDMETHOD ( GetCapabilities ) ( THIS_ DWORD * pdwCapMask ) PURE;

    STDMETHOD ( AddEntry ) ( THIS_ LPCWSTR pszName, const FILETIME * pftTimeStamp, DWORD dwMode, HBITMAP hImage ) PURE;
    STDMETHOD ( GetEntry ) ( THIS_ LPCWSTR pszName, DWORD dwMode, HBITMAP * phImage ) PURE;
    STDMETHOD ( DeleteEntry ) ( THIS_ LPCWSTR pszName ) PURE;
    STDMETHOD ( IsEntryInStore ) ( THIS_ LPCWSTR pszName, FILETIME * pftTimeStamp ) PURE;

    STDMETHOD ( Enum ) ( THIS_ LPENUMSHELLIMAGESTORE * ppEnum ) PURE;
};

typedef IShellImageStore * LPSHELLIMAGESTORE;
#endif
//
// Interface for interacting with the IE splash screen
//

#undef  INTERFACE
#define INTERFACE   ISplashScreen

DECLARE_INTERFACE_( ISplashScreen, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** ISplashScreen methods ***
    STDMETHOD ( Show ) ( THIS_ HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwnd ) PURE;
    STDMETHOD ( Dismiss ) (THIS) PURE;
};

typedef ISplashScreen * LPSPLASHSCREEN;

//
// Interface for Multiple Monitor Configurations
//

#define MD_PRIMARY  0x00000001
#define MD_ATTACHED 0x00000002
typedef struct _MonitorData
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwStatus;
    RECT rcPos;
} MonitorData, * LPMONITORDATA;
#undef  INTERFACE
#define INTERFACE   IMultiMonConfig

DECLARE_INTERFACE_( IMultiMonConfig, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IMultiMonConfig methods ***
    STDMETHOD ( Initialize ) ( THIS_ HWND hwndHost, WNDPROC WndProc, DWORD dwReserved) PURE;
    STDMETHOD ( GetNumberOfMonitors ) (THIS_ int * pCMon, DWORD dwReserved) PURE;
    STDMETHOD ( GetMonitorData) (THIS_ int iMonitor, MonitorData * pmd, DWORD dwReserved) PURE;
    STDMETHOD ( Paint) (THIS_ int iMonitor, DWORD dwReserved) PURE;
};

typedef IMultiMonConfig * LPMULTIMONCONFIG;

#endif // _WIN32_IE > 0x0400

////  IRestrict
// For the pdwRestrictionResult out parameter in IRestrict::IsRestricted() for
// all pguidIDs.
typedef enum
{
    RR_ALLOW  = 1,
    RR_DISALLOW,
    RR_NOCHANGE,
} RESTRICTION_RESULT;

// IRestrict::IsRestricted() dwRestrictAction parameter values for
// the RID_RDeskBars pguidID.
typedef enum
{
    RA_DRAG  = 1,
    RA_DROP,
    RA_ADD,
    RA_CLOSE,
    RA_MOVE,
} RESTRICT_ACTIONS;

#undef INTERFACE
#define INTERFACE IRestrict

DECLARE_INTERFACE_(IRestrict, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRestrict Methods ***
    STDMETHOD(IsRestricted) (THIS_ const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, OUT DWORD * pdwRestrictionResult) PURE;
};


////  IAddressBand
#define OLECMD_REFRESH_TOPMOST     0x00000000
#define OLECMD_REFRESH_ENTIRELIST  0x00000001

#undef INTERFACE
#define INTERFACE IAddressBand

DECLARE_INTERFACE_(IAddressBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAddressBand Methods ***
    STDMETHOD(FileSysChange) (THIS_ DWORD dwEvent, LPCITEMIDLIST * ppidl1) PURE;
    STDMETHOD(Refresh) (THIS_ VARIANT * pvarType) PURE;
};

#undef INTERFACE
#define INTERFACE IAddressEditBox

// Init Flags
#define AEB_INIT_DEFAULT     0x00000000
#define AEB_INIT_NOSHELL     0x00000001
#define AEB_INIT_NOWEB       0x00000002
#define AEB_INIT_NOFILE      0x00000004
#define AEB_INIT_AUTOEXEC    0x00000008     // Set if you want the item Navigated/ShellExeced when ENTER occurs.
#define AEB_INIT_SUBCLASS    0x00000010     // If set parent needs to pass HWND events thru IWinEventHandler::OnWinEvent()

// Parse Flags for IAddressEditBox::ParseNow()
#define SHURL_FLAGS_NONE        0x00000000
#define SHURL_FLAGS_NOUI        0x00000001      // Don't display any UI.
#define SHURL_FLAGS_NOSNS       0x00000002      // Ignore SHELL URLs. (FILE and Internet URLs still work)
#define SHURL_FLAGS_NOWEB       0x00000004      // Ignore WEB URLs. (Don't successfully parse if not found in shell name space)
#define SHURL_FLAGS_NOPATHSEARCH 0x00000008     // don't search on dos paths or app path
#define SHURL_FLAGS_AUTOCORRECT 0x00000010      // Try to autocorrect WEB URLs

// Exec Flags for IAddressEditBox::Execute()
#define SHURL_EXECFLAGS_NONE        0x00000000
#define SHURL_EXECFLAGS_SEPVDM      0x00000001      // If ShellExec(), set SEE_MASK_FLAG_SEPVDM fMask.
#define SHURL_EXECFLAGS_DONTFORCEIE 0x00000002      // If some browser other than IE is associated with HTML files, allow them to launch.


DECLARE_INTERFACE_(IAddressEditBox, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAddressEditBox Methods ***
    STDMETHOD(Init) (THIS_ HWND hwnd, HWND hwndEditBox, DWORD dwFlags, IUnknown * punkParent) PURE;
    STDMETHOD(SetCurrentDir) (THIS_ LPCOLESTR pwzDir) PURE;
    STDMETHOD(ParseNow) (THIS_ DWORD dwParseFlags) PURE;
    STDMETHOD(Execute) (THIS_ DWORD dwExecFlags) PURE;
    STDMETHOD(Save) (THIS_ DWORD dwReserved) PURE;
};


#if (_WIN32_IE >= 0x0400)

////  IShellFolderBand

// Field mask
#define ISFB_MASK_STATE          0x00000001 // TRUE if dwStateMask and dwState is valid
#define ISFB_MASK_BKCOLOR        0x00000002 // TRUE if crBkgnd field is valid
#define ISFB_MASK_VIEWMODE       0x00000004 // TRUE if wViewMode field is valid
#define ISFB_MASK_SHELLFOLDER    0x00000008
#define ISFB_MASK_IDLIST         0x00000010
#define ISFB_MASK_COLORS         0x00000020 // TRUE if crXXXX fields are valid (except bkgnd)
#define ISFB_MASK_ALL            0x0000003F         //
#define ISFB_MASK_INVALID        (~(ISFB_MASK_ALL)) //

#define ISFB_STATE_DEFAULT       0x00000000
#define ISFB_STATE_DEBOSSED      0x00000001
#define ISFB_STATE_ALLOWRENAME   0x00000002
#define ISFB_STATE_NOSHOWTEXT    0x00000004 // TRUE if _fNoShowText
//#define ISFB_STATE_NOTITLE       0x00000008 // obsolete! (use cbs::SetBandState)
#define ISFB_STATE_CHANNELBAR    0x00000010 // TRUE if we want NavigateTarget support
#define ISFB_STATE_QLINKSMODE    0x00000020 // TRUE if we want to turn off drag & drop onto content items
#define ISFB_STATE_FULLOPEN      0x00000040 // TRUE if band should maximize when opened
#define ISFB_STATE_NONAMESORT    0x00000080 // TRUE if band should _not_ sort icons by name
#define ISFB_STATE_BTNMINSIZE    0x00000100 // TRUE if band should report min thickness of button
#define ISFB_STATE_ALL           0x000001FF //

#define ISFBVIEWMODE_SMALLICONS   0x0001
#define ISFBVIEWMODE_LARGEICONS   0x0002
#define ISFBVIEWMODE_LOGOS        0x0003

typedef struct {
    DWORD       dwMask;       // [in] ISFB_MASK mask of valid fields from crBkgnd on
    DWORD       dwStateMask;  // [in] ISFB_STATE mask of dwState bits being set/queried
    DWORD       dwState;      // [in/out] ISFB_STATE bits
    COLORREF    crBkgnd;      // [in/out]
    COLORREF    crBtnLt;      // [in/out]
    COLORREF    crBtnDk;      // [in/out]
    WORD        wViewMode;    // [in/out]
    WORD        wAlign;       // not used (yet)
    IShellFolder * psf;       // [out]
    LPITEMIDLIST   pidl;      // [out]
} BANDINFOSFB, *PBANDINFOSFB;

#undef INTERFACE
#define INTERFACE IShellFolderBand

DECLARE_INTERFACE_(IShellFolderBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderBand Methods ***
    STDMETHOD(InitializeSFB)(THIS_ IShellFolder *psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(SetBandInfoSFB)(THIS_ PBANDINFOSFB pbi) PURE;
    STDMETHOD(GetBandInfoSFB)(THIS_ PBANDINFOSFB pbi) PURE;
};

// Command Target IDs
enum {
    SFBID_PIDLCHANGED,
};

//-------------------------------------------------------------------------
//
// IWinEventHandler interface
//
//   An object that wants to send messages to another object (typically
// a sub-object) QI's for the sub-object's IWinEventHandler interface.
// Once the object determines the hwnd is owned by the sub-object (via
// IsWindowOwner), the object calls OnWinEvent for send the message.
//
//
// [Member functions]
//
// IWinEventHandler::IsWindowOwner(hwnd)
//   Returns S_OK if the hwnd is owned by the object, S_FALSE if not.
//
// IWinEventHandler::OnWinEvent(hwnd, dwMsg, wParam, lParam, plRet)
//   Sends a message to the object.  The Win32 return value (i.e., the
//   value returned by DefWindowProc) is returned in *plRet.  Return
//   S_OK if the message is handled, otherwise S_FALSE.
//
//-------------------------------------------------------------------------


#undef INTERFACE
#define INTERFACE IWinEventHandler

DECLARE_INTERFACE_(IWinEventHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWinEventHandler Methods ***
    STDMETHOD(OnWinEvent) (THIS_ HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres) PURE;
    STDMETHOD(IsWindowOwner) (THIS_ HWND hwnd) PURE;
};


////  IDeskBarClient

#undef  INTERFACE
#define INTERFACE   IDeskBarClient

DECLARE_INTERFACE_(IDeskBarClient, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetDeskBarSite)   (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(SetModeDBC)          (THIS_ DWORD dwMode) PURE;
    STDMETHOD(UIActivateDBC)    (THIS_ DWORD dwState) PURE;
    STDMETHOD(GetSize)    (THIS_ DWORD dwWhich, LPRECT prc) PURE;
};

#define DBC_GS_IDEAL    0  // get the ideal size

#define DBC_HIDE        0 // Band is hidden (being destroyed)
#define DBC_SHOW        1 // Band is visible
#define DBC_SHOWOBSCURE 2 // Band is completely obscured


enum {
    DBCID_EMPTY = 0,        // bandsite is empty
    DBCID_ONDRAG = 1,       // (down)DragMoveEnter/Leave vaIn:I4:eDrag
    DBCID_CLSIDOFBAR = 2,   // clsid of bar inside
    DBCID_RESIZE = 3,		// resize from keyboard
};

///// IDeskBar

#undef  INTERFACE
#define INTERFACE   IDeskBar

DECLARE_INTERFACE_(IDeskBar, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetClient)          (THIS_ IUnknown* punkClient) PURE;
    STDMETHOD(GetClient)          (THIS_ IUnknown** ppunkClient) PURE;
    STDMETHOD(OnPosRectChangeDB)(THIS_ LPRECT prc) PURE;
};


//-------------------------------------------------------------------------
//
// IBandSite interface
//
//   This interface provides methods to get or set bandsite information.
//
// [Member functions]
//
// IBandSite::AddBand(punk)
//   Add a band to the bandsite.  Returns the band ID in ShortFromResult(hres).
//
// IBandSite::EnumBands(uBand, *pdwBandID)
//   Enumerate the bands. If uBand is -1, pdwBandID is ignored and this
//   method returns the count of bands in the bandsite.  Call this method
//   with uBand starting at 0 to begin enumerating.  Returns S_OK and the
//   band ID in *pdwBandID of the next band.
//
// IBandSite::QueryBand(dwBandID, ppstb, pdwState, pszName, cchName)
//   Get info about a band.
//
// IBandSite::SetBandState(dwBandID, dwState)
//   Set the band's state.
//   ;BUGBUG (scotth): no one implements this right now!
//
// IBandSite::RemoveBand(dwBandID)
//   Remove the band.
//
// IBandSite::GetBandObject(dwBandID, riid, ppv)
//   Get an object that support riid for the band.
//
// IBandSite::GetBandSiteInfo(pbsinfo)
//   Get info about the bandsite.
//
// IBandSite::SetBandSiteInfo(pbsinfo)
//   Set info about the bandsite.
//
//-------------------------------------------------------------------------

// Field mask
#define BSIM_STATE          0x00000001
#define BSIM_STYLE          0x00000002

// State flags
#define BSSF_VISIBLE        0x00000001
#define BSSF_NOTITLE        0x00000002
#define BSSF_UNDELETEABLE   0x00001000  // OBSOLETE

// Style flags
#define BSIS_AUTOGRIPPER    0x00000000
#define BSIS_NOGRIPPER      0x00000001
#define BSIS_ALWAYSGRIPPER  0x00000002
#define BSIS_LEFTALIGN      0x00000004
#define BSIS_SINGLECLICK    0x00000008
#define BSIS_NOCONTEXTMENU  0x00000010
#define BSIS_NODROPTARGET   0x00000020

typedef struct {
    DWORD       dwMask;         // BSIM_* flags
    DWORD       dwState;        // BSSF_* flags
    DWORD       dwStyle;        // BSIS_* flags
} BANDSITEINFO;

// Passed to parent and child context menus in
// lpParameters field of CMINVOKECOMMANDINFO
typedef struct {
    DWORD       dwID;
    IUnknown *  punkSite;
} BANDSITEINVOKEPARAM;

#undef  INTERFACE
#define INTERFACE   IBandSite

DECLARE_INTERFACE_(IBandSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandSite methods ***
    STDMETHOD(AddBand)          (THIS_ IUnknown* punk) PURE;
    STDMETHOD(EnumBands)        (THIS_ UINT uBand, DWORD* pdwBandID) PURE;
    STDMETHOD(QueryBand)        (THIS_ DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName) PURE;
    STDMETHOD(SetBandState)     (THIS_ DWORD dwBandID, DWORD dwMask, DWORD dwState) PURE;
    STDMETHOD(RemoveBand)       (THIS_ DWORD dwBandID) PURE;
    STDMETHOD(GetBandObject)    (THIS_ DWORD dwBandID, REFIID riid, void **ppv) PURE;
    STDMETHOD(SetBandSiteInfo)  (THIS_ const BANDSITEINFO * pbsinfo) PURE;
    STDMETHOD(GetBandSiteInfo)  (THIS_ BANDSITEINFO * pbsinfo) PURE;
};

// BSID_BANDREMOVED means removed *or* hidden
enum {
    BSID_BANDADDED,
    BSID_BANDREMOVED,
};
#endif // _WIN32_IE > 0x0400


//==========================================================================
// IExplorerToolbar interfaces
//
//  This is an interface to the shell toolbar which allows shell views
// to add buttons and process.
// See http://ohserv/users/satona/toolbar_extension.htm for spec.
//
//==========================================================================

// Bitmap types
#define BITMAP_NORMAL         0x1
#define BITMAP_HOT            0x2
#define BITMAP_DISABLED       0x3

// Band Visibility Flags
#define VBF_TOOLS               0x00000001
#define VBF_ADDRESS             0x00000002
#define VBF_LINKS               0x00000004
#define VBF_BRAND               0x00000008
#define VBF_MENU                0x00000010

#define VBF_ONELINETEXT         0x00000020
#define VBF_TWOLINESTEXT        0x00000040
#define VBF_NOCUSTOMIZE         0x00000080

#define VBF_EXTERNALBANDS       0xFFFF0000

#define VBF_VALID               (VBF_TOOLS | VBF_ADDRESS | VBF_LINKS | VBF_BRAND | VBF_MENU | VBF_EXTERNALBANDS)

#undef  INTERFACE
#define INTERFACE   IExplorerToolbar

typedef enum {
    ETCMDID_GETBUTTONS          = 0x0001,
    ETCMDID_NEWCOMMANDTARGET    = 0x0002,   // sent to the previous command target when a new one is coming in
#if (_WIN32_IE >= 0x500)
    ETCMDID_RELOADBUTTONS       = 0x0003,   // command target needs to call AddButtons again
#endif
} ENUM_ETCMDID;

DECLARE_INTERFACE_(IExplorerToolbar, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExplorerToolbar methods ***
    STDMETHOD(SetCommandTarget) (THIS_ IUnknown* punkCmdTarget, const GUID* pguidCmdGrp, DWORD dwFlags) PURE;
    STDMETHOD(AddStdBrowserButtons) (THIS) PURE;

    // Wrap of the TB_* messages the messages that are implmented
    // are just the ones to add delete and modify the buttons, and not
    // the ones to manipulate the toolbar.
    STDMETHOD(AddButtons)       (THIS_ const GUID * pguidButtonGroup, UINT nButtons, const TBBUTTON * lpButtons) PURE;
    STDMETHOD(AddString)        (THIS_ const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LRESULT * pOffset) PURE;
    STDMETHOD(GetButton)        (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) PURE;
    STDMETHOD(GetState)         (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, UINT * pfState) PURE;
    STDMETHOD(SetState)         (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, UINT fState) PURE;
    STDMETHOD(AddBitmap)        (THIS_ const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb,
                                                        LRESULT * pOffset, COLORREF rgbMask) PURE;
    STDMETHOD(GetBitmapSize)    (THIS_ UINT * uiID) PURE;
    STDMETHOD(SendToolbarMsg)   (THIS_ const GUID * pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes) PURE;

    STDMETHOD(SetImageList) (THIS_ const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled) PURE;
    STDMETHOD(ModifyButton)     (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) PURE;
};

//==========================================================================
// DefView supports a private service id for extended views.
// DefView's IOleCommandTarget supports the below command group and ids too.
//==========================================================================
// SID_DefView and CGID_DefView are defined in shlguid.w
//
#define DVCMDID_GETTHISDIRPATH 1 // pvaOut = path to this directory (if in filesystem)
#define DVCMDID_GETTHISDIRNAME 2 // pvaOut = friendly name of this directory
#define DVCMDID_GETTEMPLATEDIRNAME 3 // pvaOut = webview template (.htt) dir
#define IS_ADJUSTLISTVIEW       0x80000000
#define IS_INTERNALDUMMYBIT     0x40000000
#define IS_VALIDINTERNALBITS    (IS_ADJUSTLISTVIEW | IS_INTERNALDUMMYBIT)

// Flags for SetSafeMode
#define SSM_CLEAR   0x0000
#define SSM_SET     0x0001
#define SSM_REFRESH 0x0002
#define SSM_UPDATE  0x0004

// Flags for Set/GetScheme
#define SCHEME_DISPLAY          0x0001
#define SCHEME_EDIT             0x0002
#define SCHEME_LOCAL            0x0004
#define SCHEME_GLOBAL           0x0008
#define SCHEME_REFRESH          0x0010
#define SCHEME_UPDATE           0x0020
#define SCHEME_DONOTUSE 0x0040 // used to be SCHEME_ENUMERATE; no longer supported
#define SCHEME_CREATE           0x0080

#undef INTERFACE
#define INTERFACE IActiveDesktopP

DECLARE_INTERFACE_( IActiveDesktopP, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IActiveDesktopP methods
    STDMETHOD (SetSafeMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD (EnsureUpdateHTML)(THIS) PURE;
    STDMETHOD (SetScheme)(THIS_ LPCWSTR pwszSchemeName, DWORD dwFlags) PURE;
    STDMETHOD (GetScheme)(THIS_ LPWSTR pwszSchemeName, DWORD *lpdwcchBuffer, DWORD dwFlags) PURE;
    //
};

typedef IActiveDesktopP * LPACTIVEDESKTOPP;

//Flags for GetObjectFlags
#define GADOF_DIRTY    0x00000001

#undef INTERFACE
#define INTERFACE IADesktopP2

DECLARE_INTERFACE_( IADesktopP2, IUnknown )
{
    // IUnknown methods
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // IADesktopP2 methods
    STDMETHOD (ReReadWallpaper)(THIS) PURE;
    STDMETHOD (GetADObjectFlags)(THIS_ DWORD *lpdwFlags, DWORD dwMask) PURE;
    STDMETHOD (UpdateAllDesktopSubscriptions)(THIS) PURE;
    STDMETHOD (MakeDynamicChanges)(THIS_ IOleObject *pOleObj) PURE;
};

typedef IADesktopP2 * LPADESKTOPP2;

#define CFSTR_SHELLIDLISTP      TEXT("Shell IDLData Private")
#define CFSTR_SHELLCOPYDATA     TEXT("Shell Copy Data")
//
// Win 3.1 style HDROP
//
//  Notes: Our API works only if pFiles == sizeof(DROPFILES16)
//
typedef struct _DROPFILES16 {
    WORD pFiles;                // offset to double null list of files
    POINTS pt;                  // drop point (client coords)
    WORD fNC;                   // is it on non client area
                                // and pt is in screen coords
} DROPFILES16, * LPDROPFILES16;

//
// format of CF_SHELLCOPYDATA
//

typedef struct _SHELLCOPYDATA {
    DWORD dwEffect;                 // Intended effect
} SHELLCOPYDATA;
//------ See shelldll\fsnotify.c for function descriptions. ----------

//
//  Definition of the function type to be called by the notification
//  service when a file the client has registered to monitor changes.
//

typedef struct _SHChangeNotifyEntry
{
    LPCITEMIDLIST pidl;
    BOOL   fRecursive;
} SHChangeNotifyEntry;
#define SHCNRF_InterruptLevel      0x0001
#define SHCNRF_ShellLevel          0x0002

// If the caller passes SHCNRF_RecursiveInterrupt (meaning that they want interrupt events on the whole
// subtree), then they must also pass SHCNRF_InterruptLevel flag (duh), and they must be a recursive (eg
// fRecursive == TRUE) type notification.
#define SHCNRF_RecursiveInterrupt  0x1000
#define SHCNRF_ResumeThread        0x2000
#define SHCNRF_CreateSuspended     0x4000
#define SHCNRF_NewDelivery         0x8000

// !! WARNING !!
// If you change/add any new SHCNE_ events, you will need
// to possibly modify the SHCNE_XXXXEVENTS masks that are
// defined below as well.
// NOTE: SHCNE_GLOBALEVENTS are typically used to pass
// non-pidl information (packed into pidl format). We cannot
// extend SHCNE_GLOBALEVENTS and expect clients of the new
// events to work on a down-level shell32. In fact, they
// may very well fault during psfDesktop->CompareIDs.
// So be careful when adding to this bitfield!
//
// Win95 and NT4 and IE4 shipped with 0x0C0581E0L.
// We use this event mask to tell if we need to possibly throw out a SHCNE_UPDATEDIR that was
// generated by the filesystem because we have a more specific event already in our queue.
// NOTE: only non-interrupt events could cause us to throw out a interrupt generated UPDATEDIR event.
#define SHCNE_UPDATEDIR_OVERRIDE_EVENTS 0x00023818L
// This event was defined early on in IE4 for the Theme Switcher to
// notify the shell that a system-wide update needed to happen.
// This has been removed but I don't want to re-use the id just yet...

// BUGBUG (scotth) 6/11/98: can we remove this yet??

//#define SHCNEE_THEMECHANGED       1L  // The theme changed
#define SHCNEE_WININETCHANGED       3L  // dwItem2 contains CACHE_NOTIFY_* bits
#define SHCNEE_PROMOTEDITEM         6L  // pidl2 is the pidl of the Promoted item
#define SHCNEE_DEMOTEDITEM          7L  // pidl2 is the pidl of the demoted item
#define SHCNEE_ALIASINUSE           8L  // some alias style folder is now being used
// Update types for the UpdateEntryList api
#define SHCNNU_SET        1   // Set the notify list to passed in list
#define SHCNNU_ADD        2   // Add the items to the current list
#define SHCNNU_REMOVE     3   // Remove the items from the current list
#define SHCNF_PRINTJOBA   0x0004        // dwItem1: printer name
                                        // dwItem2: SHCNF_PRINTJOB_DATA
#define SHCNF_PRINTJOBW   0x0007        // dwItem1: printer name
                                        // dwItem2: SHCNF_PRINTJOB_DATA
#define SHCNF_INSTRUMENT  0x0080        // dwItem1: LPSHCNF_INSTRUMENT
#define SHCNF_NONOTIFYINTERNALS     0x4000 // means don't do shell notify internals.  see comments in code
#define SHCNF_ONLYNOTIFYINTERNALS   0x8000 // only notify internal clients
#ifdef UNICODE
#define SHCNF_PRINTJOB  SHCNF_PRINTJOBW
#else
#define SHCNF_PRINTJOB  SHCNF_PRINTJOBA
#endif

typedef struct tagSHCNF_PRINTJOB_DATA {
    DWORD JobId;
    DWORD Status;
    DWORD TotalPages;
    DWORD Size;
    DWORD PagesPrinted;
} SHCNF_PRINTJOB_DATA, *LPSHCNF_PRINTJOB_DATA;

//
// This is all the INSTRUMENTation stuff...
// make this look like an ITEMIDLIST (uOffset points to 0 uTerm)
#include <pshpack1.h>
typedef struct tagSHCNF_INSTRUMENT {
    USHORT uOffset;
    USHORT uAlign;
    DWORD dwEventType;
    DWORD dwEventStructure;
    SYSTEMTIME st;
    union tagEvents {
        struct tagSTRING {
            TCHAR sz[32];
        } string;
        struct tagHOTKEY {
            WPARAM wParam;
        } hotkey;
        struct tagWNDPROC {
            HWND hwnd;
            UINT uMsg;
            WPARAM wParam;
            LPARAM lParam;
        } wndproc;
        struct tagCOMMAND {
            HWND hwnd;
            UINT idCmd;
        } command;
        struct tagDROP {
            HWND hwnd;
            UINT idCmd;
//          TCHAR sz[32]; // convert pDataObject into something we can log
        } drop;
    } e;
    USHORT uTerm;
} SHCNF_INSTRUMENT_INFO, * LPSHCNF_INSTRUMENT_INFO;
#include <poppack.h>

#define SHCNFI_EVENT_STATECHANGE          0   // dwEventType
#define SHCNFI_EVENT_STRING               1   // e.string
#define SHCNFI_EVENT_HOTKEY               2   // e.hotkey
#define SHCNFI_EVENT_WNDPROC              3   // e.wndproc
#define SHCNFI_EVENT_WNDPROC_HOOK         4   // e.wndproc
#define SHCNFI_EVENT_ONCOMMAND            5   // e.command
#define SHCNFI_EVENT_INVOKECOMMAND        6   // e.command
#define SHCNFI_EVENT_TRACKPOPUPMENU       7   // e.command
#define SHCNFI_EVENT_DROP                 8   // e.drop
#define SHCNFI_EVENT_MAX                  9

#define SHCNFI_STRING_SHOWEXTVIEW         0

#define SHCNFI_STATE_KEYBOARDACTIVE         0   // _KEYBOARDACTIVE or _MOUSEACTIVE
#define SHCNFI_STATE_MOUSEACTIVE            1   // _KEYBOARDACTIVE or _MOUSEACTIVE
#define SHCNFI_STATE_ACCEL_TRAY             2   // _ACCEL_TRAY or _ACCEL_DESKTOP
#define SHCNFI_STATE_ACCEL_DESKTOP          3   // _ACCEL_TRAY or _ACCEL_DESKTOP
#define SHCNFI_STATE_START_DOWN             4   // _START_DOWN or _START_UP
#define SHCNFI_STATE_START_UP               5   // _START_DOWN or _START_UP
#define SHCNFI_STATE_TRAY_CONTEXT           6
#define SHCNFI_STATE_TRAY_CONTEXT_CLOCK     7
#define SHCNFI_STATE_TRAY_CONTEXT_START     8
#define SHCNFI_STATE_DEFVIEWX_ALT_DBLCLK    9
#define SHCNFI_STATE_DEFVIEWX_SHIFT_DBLCLK 10
#define SHCNFI_STATE_DEFVIEWX_DBLCLK       11

#define SHCNFI_GLOBALHOTKEY               0

#define SHCNFI_CABINET_WNDPROC            0
#define SHCNFI_DESKTOP_WNDPROC            1
#define SHCNFI_PROXYDESKTOP_WNDPROC       2
#define SHCNFI_TRAY_WNDPROC               3
#define SHCNFI_DRIVES_WNDPROC             4
#define SHCNFI_ONETREE_WNDPROC            5
#define SHCNFI_MAIN_WNDPROC               6
#define SHCNFI_FOLDEROPTIONS_DLGPROC      7
#define SHCNFI_VIEWOPTIONS_DLGPROC        8
#define SHCNFI_FT_DLGPROC                 9
#define SHCNFI_FTEdit_DLGPROC            10
#define SHCNFI_FTCmd_DLGPROC             11
#define SHCNFI_TASKMAN_DLGPROC           12
#define SHCNFI_TRAYVIEWOPTIONS_DLGPROC   13
#define SHCNFI_INITSTARTMENU_DLGPROC     14
#define SHCNFI_PRINTERQUEUE_DLGPROC      15

#define SHCNFI_CABINET_ONCOMMAND          0
#define SHCNFI_TRAYCOMMAND                1

#define SHCNFI_BITBUCKET_DFM_INVOKE       0
#define SHCNFI_BITBUCKET_FNV_INVOKE       1
#define SHCNFI_BITBUCKET_INVOKE           2
#define SHCNFI_BITBUCKETBG_DFM_INVOKE     3
#define SHCNFI_CONTROLS_DFM_INVOKE        4
#define SHCNFI_CONTROLS_FNV_INVOKE        5
#define SHCNFI_CONTROLSBG_DFM_INVOKE      6
#define SHCNFI_DEFFOLDER_DFM_INVOKE       7
#define SHCNFI_DEFFOLDER_INVOKE           8
#define SHCNFI_FINDEXT_INVOKE             9
#define SHCNFI_DEFFOLDER_FNV_INVOKE      10
#define SHCNFI_DRIVESBG_DFM_INVOKE       11
#define SHCNFI_DRIVES_FNV_INVOKE         12
#define SHCNFI_DRIVES_DFM_INVOKE         13
#define SHCNFI_FOLDERBG_DFM_INVOKE       14
#define SHCNFI_FOLDER_FNV_INVOKE         15
#define SHCNFI_FOLDER_DFM_INVOKE         16
#define SHCNFI_NETWORKBG_DFM_INVOKE      17
#define SHCNFI_NETWORK_FNV_INVOKE        18
#define SHCNFI_NETWORK_DFM_INVOKE        19
#define SHCNFI_NETWORKPRINTER_DFM_INVOKE 20
#define SHCNFI_DESKTOPBG_DFM_INVOKE      21
#define SHCNFI_DESKTOP_DFM_INVOKE        22
#define SHCNFI_DESKTOP_FNV_INVOKE        23
#define SHCNFI_PRINTERS_DFM_INVOKE       24
#define SHCNFI_PRINTERSBG_DFM_INVOKE     25
#define SHCNFI_PRINTERS_FNV_INVOKE       26
#define SHCNFI_DEFVIEWX_INVOKE           27

#define SHCNFI_FOLDER_DROP                0
#define SHCNFI_PRINTQUEUE_DROP            1
#define SHCNFI_DEFVIEWX_TPM               2
#define SHCNFI_DROP_EXE_TPM               3
#define SHCNFI_IDLDT_TPM                  4

#define SHCNFI_DROP_BITBUCKET             0
#define SHCNFI_DROP_PRINTFOLDER           1
#define SHCNFI_DROP_PRINTER               2
#define SHCNFI_DROP_RUN                   3
#define SHCNFI_DROP_SHELLLINK             4
#define SHCNFI_DROP_DRIVES                5
#define SHCNFI_DROP_FS                    6
#define SHCNFI_DROP_EXE                   7
#define SHCNFI_DROP_NETROOT               8
#define SHCNFI_DROP_PRINTQUEUE            9
#define SHCNFI_DROP_BRIEFCASE            10

#ifdef WANT_SHELL_INSTRUMENTATION
#define INSTRUMENT_STATECHANGE(t)                               \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_STATECHANGE;                \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_STRING(t,p)                                  \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_STRING;                     \
    lstrcpyn(s.e.string.sz,(p),ARRAYSIZE(s.e.string.sz));       \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_HOTKEY(t,w)                                  \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_HOTKEY;                     \
    s.e.hotkey.wParam=(w);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_WNDPROC(t,h,u,w,l)                           \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_WNDPROC;                    \
    s.e.wndproc.hwnd=(h);                                       \
    s.e.wndproc.uMsg=(u);                                       \
    s.e.wndproc.wParam=(w);                                     \
    s.e.wndproc.lParam=(l);                                     \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_WNDPROC_HOOK(h,u,w,l)                        \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=0;                                            \
    s.dwEventStructure=SHCNFI_EVENT_WNDPROC_HOOK;               \
    s.e.wndproc.hwnd=(h);                                       \
    s.e.wndproc.uMsg=(u);                                       \
    s.e.wndproc.wParam=(w);                                     \
    s.e.wndproc.lParam=(l);                                     \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_ONCOMMAND(t,h,u)                             \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_ONCOMMAND;                  \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_INVOKECOMMAND(t,h,u)                         \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_INVOKECOMMAND;              \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_TRACKPOPUPMENU(t,h,u)                        \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_TRACKPOPUPMENU;             \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_DROP(t,h,u,p)                                \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_DROP;                       \
    s.e.drop.hwnd=(h);                                          \
    s.e.drop.idCmd=(u);                                         \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#else
#define INSTRUMENT_STATECHANGE(t)
#define INSTRUMENT_STRING(t,p)
#define INSTRUMENT_HOTKEY(t,w)
#define INSTRUMENT_WNDPROC(t,h,u,w,l)
#define INSTRUMENT_WNDPROC_HOOK(h,u,w,l)
#define INSTRUMENT_ONCOMMAND(t,h,u)
#define INSTRUMENT_INVOKECOMMAND(t,h,u)
#define INSTRUMENT_TRACKPOPUPMENU(t,h,u)
#define INSTRUMENT_DROP(t,h,u,p)
#endif //WANT_SHELL_INSTRUMENTATION
//
//
// IQueryCodePage
//
#undef  INTERFACE
#define INTERFACE  IQueryCodePage

DECLARE_INTERFACE_(IQueryCodePage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryCodePage methods ***
    STDMETHOD(GetCodePage)(THIS_ UINT * puiCodePage) PURE;
    STDMETHOD(SetCodePage)(THIS_ UINT uiCodePage) PURE;
} ;
SHSTDAPI_(void) ReceiveAddToRecentDocs(HANDLE hARD, DWORD dwProcId);

SHSTDAPI_(void) SHWaitOp_Operate(HANDLE hWaitOp, DWORD dwProcId);

/// THESE ARE INTERNAL ....

#define SHCR_CMD_REGISTER   1
#define SHCR_CMD_DEREGISTER 2

typedef struct _SHChangeRegistration {
    UINT    uCmd;
    ULONG   ulID;
    DWORD   hwnd;
    UINT    uMsg;
    DWORD   fSources;
    LONG    lEvents;
    BOOL    fRecursive;
    UINT    uidlRegister;
} SHChangeRegistration, *LPSHChangeRegistration;

typedef struct _SHChangeNotification {
    DWORD   dwSize;
    LONG    lEvent;
    UINT    uFlags;
    UINT    cRef;
    DWORD   dwEventTime;
    UINT    uidlMain;
    UINT    uidlExtra;
} SHChangeNotification, *LPSHChangeNotification;

typedef struct _SHChangeNotificationLock {
    LPITEMIDLIST            pidlMain;
    LPITEMIDLIST            pidlExtra;
    LPSHChangeNotification  pshcn;
#ifdef DEBUG
    DWORD                   dwSignature;
#endif
} SHChangeNotificationLock, * LPSHChangeNotificationLock;

typedef struct _SHChangeDWORDAsIDList {
    USHORT   cb;
    DWORD    dwItem1;
    DWORD    dwItem2;
    USHORT   cbZero;
} SHChangeDWORDAsIDList, *LPSHChangeDWORDAsIDList;



#if (_WIN32_IE >= 0x0400)

// Use this instead of SHChangeDWORDAsIDList for SHCNEE_ORDERCHANGED
// SHCNEE_PROMOTEDITEM and SHCNEE_DEMOTEDITEM
//
// When filling in the pSender, cast LPVOID directly to INT64.
// Do not cast through DWORD_PTR because that will not sign extend
// properly on Win32.

typedef struct _SHChangeMenuAsIDList {
    USHORT  cb;
    DWORD   dwItem1;        // SHCNEE_EXTENDED_EVENT requires this
    // pSender must appear immediately after dwItem1 for IE5.0 compat
    INT64 pSender;          // address of sender (64-bit for Win64)
    DWORD   dwProcessID;    // pid of sender
    USHORT  cbZero;
} SHChangeMenuAsIDList, * LPSHChangeMenuAsIDList;

typedef struct _SHChangeUpdateImageIDList {
    USHORT cb;
    int iIconIndex;
    int iCurIndex;
    UINT uFlags;
    DWORD dwProcessID;
    WCHAR szName[MAX_PATH];
    USHORT cbZero;
} SHChangeUpdateImageIDList, * LPSHChangeUpdateImageIDList;

SHSTDAPI_(int)  SHHandleUpdateImage( LPCITEMIDLIST pidlExtra );			
#endif /* _WIN32_IE */
#define SHChangeNotifyHandleEvents() SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL)
SHSTDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne);
#define SHChangeNotifyRegisterORD 2
SHSTDAPI_(BOOL) SHChangeNotifyDeregister(unsigned long ulID);
#define SHChangeNotifyDeregisterORD 4

SHSTDAPI_(BOOL) SHChangeNotifyUpdateEntryList(unsigned long ulID, int iUpdateType, int cEntries, SHChangeNotifyEntry *pshcne);

SHSTDAPI_(void)   SHChangeNotifyReceive(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
SHSTDAPI_(HANDLE) SHChangeNotification_Create(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidlMain, LPCITEMIDLIST pidlExtra, DWORD dwProcessId, DWORD dwEventTime);
SHSTDAPI_(ULONG)  SHChangeNotification_Release(HANDLE hChangeNotification, DWORD dwProcessId);
SHSTDAPI_(LPSHChangeNotificationLock) SHChangeNotification_Lock(HANDLE hChangeNotification, DWORD dwProcessId, LPITEMIDLIST **pppidl, LONG *plEvent);
SHSTDAPI_(BOOL) SHChangeNotification_Unlock(LPSHChangeNotificationLock pshcnl);
SHSTDAPI_(BOOL) SHChangeRegistrationReceive(HANDLE hChangeNotification, DWORD dwProcId);
SHSTDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd);
SHSTDAPI_(LRESULT) SHChangeNotifySuspendResumeReceive(WPARAM wParam, LPARAM lParam);
SHSTDAPI_(BOOL) SHChangeNotifySuspendResume(BOOL bSuspend, LPITEMIDLIST pidlSuspend, BOOL bRescursive, DWORD dwReserved);

#if (_WIN32_IE >= 0x0400)
// The pidls that are given to the view via the ChangeNotifyEvents are simple Pidls,
// SHGetRealIDL() will convert them to true PIDLs.
SHSTDAPI SHGetRealIDL(IShellFolder *psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST * ppidlReal);
#endif // _WIN32_IE >= 0x0400
#ifndef NOOCHOST // {

//
// ====== OCHOST CONTROL ==========================================
//
// The following are all definations of structures, windows messages needed for OCHOST,
// the window control you can use to host an OC.
// To use OCHOST, you must specify the window class as OCHOST_CLASS or "OCHOST"
// -- To Create and initialize OCHOST:
// 1. CreateWindow with window title = the string version of class id or the OC
// 2. CreateWindow with a pointer to the OCHINITSTRUCT structure as the last parameter
//    you must allocate and initialize the OCHINITSTRUCT structure
// 3. CreateWindow with no title and the last param == NULL, then use the OCM_INITIALIZE message
//    or the OCHost_InitOC macro to initialize it.
// 4. Use OCM_QUERYINTERFACE to QI an interface pointer from the OC.
// 5. Simply destroy the window when you exit.

// SHDRC -- Shell Doc Register Classes

typedef struct _SHDRC {
    DWORD cbSize;   // size of this structure in bytes
    DWORD dwFlags;  // SHDRCF_ flags
} SHDRC;

#define SHDRCF_OCHOST   0x0001 // Register the OCHOST_CLASS window
#define SHDRCF_ALL      0x0001 //

SHDOCAPI_(BOOL)     DllRegisterWindowClasses(const SHDRC * pshdrc);
BROWSEUIAPI_(BOOL)  InitOCHostClass(const SHDRC *pshdrc);

#define OCHOST_CLASSA   "OCHost"
#define OCHOST_CLASSW   L"OCHost"

#ifdef UNICODE
#define OCHOST_CLASS    OCHOST_CLASSW
#else
#define OCHOST_CLASS    OCHOST_CLASSA
#endif

// ------------------- Window messages for OC Host --------------------

// IUnknown::QueryInterface the hosted OC
typedef struct _QIMSG {
    const IID * qiid;
    void **ppvObject;
} QIMSG, *LPQIMSG;

// ................. Query Interface Message ..........
#define OCM_QUERYINTERFACE      (WM_USER+0)

#ifdef __cplusplus
inline HRESULT OCHost_QueryInterface(HWND hwndOCH, REFIID riid, void **ppv) \
{ QIMSG qimsg = {&riid, ppv}; \
  return (HRESULT)SNDMSG((hwndOCH), OCM_QUERYINTERFACE, (WPARAM)sizeof(qimsg), (LPARAM)&qimsg); \
}
#else
#define OCHost_QueryInterface(hwndOCH, riid, ppv) \
{ QIMSG qimsg = {&riid, ppv}; \
  SNDMSG((hwndOCH), OCM_QUERYINTERFACE, (WPARAM)sizeof(qimsg), (LPARAM)&qimsg); \
}
#endif


// ------------------- OC Initialization Structure ---------------------
// This is intended to be passed in as the lParam of the OCM_INITOC message
typedef struct _OCHINITSTRUCT {
    UINT cbSize;                    // size of this structure
    CLSID clsidOC;                  // class ID of the OC
    IUnknown * punkOwner;           // owner of OCHOST
} OCHINITSTRUCT, *LPOCHINITSTRUCT;
//--------------------------------------------------------------------

// ................ Initialize and activate the OC ...............
#define OCM_INITIALIZE      (WM_USER+1)
#define OCM_INITOC          OCM_INITIALIZE
#define OCHost_InitOC(hwndOCH, lpOCS) \
  (HRESULT)SNDMSG((hwndOCH), OCM_INITOC, 0, (LPARAM)lpOCS)


// ............... give ochost a parent IUnknown .......
#define OCM_SETOWNER            (WM_USER+2)
#define OCHost_SetOwner(hwndOC, punk) \
  (HRESULT)SNDMSG((hwndOC), OCM_SETOWNER, 0, (LPARAM)(IUnknown*)(punk))

// ............... DoVerb the OC .......
// n.b. iVerb is technically a long, WPARAM might truncate it
#define OCM_DOVERB              (WM_USER+3)
#define OCHost_DoVerb(hwndOC, iVerb, lpMsg) \
  (HRESULT)SNDMSG((hwndOC), OCM_DOVERB, (WPARAM)iVerb, (LPARAM)lpMsg)

//.................Enable/Disable OC event notifications
#define OCM_ENABLEEVENTS       (WM_USER+4)
//  WPARAM: TRUE to enable event notifications, FALSE to disable.
//  returns: TRUE if successful, otherwise FALSE.
//  Event notification is in the form of a WM_NOTIFY with
//  code OCN_OCEVENT and an NMOCEVENT block.

#define OCHost_EnableEvents(hwndOC, bEnable) \
    (BOOL)SNDMSG((hwndOC), OCM_ENABLEEVENTS, (WPARAM)bEnable, 0L)

// ------------------ Window Notify messages from OC Host --------------

#define OCN_FIRST               0x1300
#define OCN_COCREATEINSTANCE    (OCN_FIRST + 1)

typedef struct _OCNCOCREATEMSG {
    NMHDR nmhdr;
    CLSID clsidOC;
    IUnknown ** ppunk;
} OCNCOCREATEMSG, *LPOCNCOCREATEMSG;

// NOTE: return values are defined as the following
// If the handler of OCN_COCREATEINSTANCE Notify message returns OCNCOCREATE_ALREADYCREATED,
// on return the (*ppvObj) is assumed to have the value of the OC's IUnkown pointer
#define OCNCOCREATE_CONTINUE       0
#define OCNCOCREATE_HANDLED       -1


#define OCN_PERSISTINIT         (OCN_FIRST + 2)
// NOTE: return values are defined as the following
// If the handler of OCN_PERSISTINIT Notify message returns OCNPERSIST_ABORT,
// the OCHOST will abort IPersist's initialization.
#define OCNPERSISTINIT_CONTINUE    0
#define OCNPERSISTINIT_HANDLED    -1

// The return value on the following notify messages are ignored.
#define OCN_ACTIVATE            (OCN_FIRST + 3)
#define OCN_DEACTIVATE          (OCN_FIRST + 4)
#define OCN_EXIT                (OCN_FIRST + 5)
#define OCN_ONPOSRECTCHANGE     (OCN_FIRST + 6)

typedef struct _OCNONPOSRECTCHANGEMSG {
    NMHDR nmhdr;
    LPCRECT prcPosRect;
} OCNONPOSRECTCHANGEMSG, *LPOCNONPOSRECTCHANGEMSG;

#define OCN_ONUIACTIVATE        (OCN_FIRST + 7)
typedef struct _OCNONUIACTIVATEMSG {
    NMHDR nmhdr;
    IUnknown *punk;
} OCNONUIACTIVATEMSG, *LPOCNONUIACTIVATEMSG;

#define OCNONUIACTIVATE_HANDLED       -1

#define OCN_ONSETSTATUSTEXT     (OCN_FIRST + 8)
typedef struct _OCNONSETSTATUSTEXT {
    NMHDR nmhdr;
    LPCOLESTR pwszStatusText;
} OCNONSETSTATUSTEXTMSG, *LPOCNONSETSTATUSTEXTMSG;


#define OCN_OCEVENT    (OCN_FIRST + 9)
//  OC event notification block.
//  Recipient should return nonzero if any outbound parameters were modified
//  and should be returned to the ActiveX control object; otherwse zero.
typedef struct tagNMOCEVENT
{
    IN NMHDR           hdr ;
    IN DISPID          dispID ;
    IN IID             iid ;
    IN LCID            lcid ;
    IN WORD            wFlags ;
    IN OUT DISPPARAMS  *pDispParams ;
    OUT VARIANT        *pVarResult ;
    OUT EXCEPINFO      *pExepInfo ;
    OUT UINT           *puArgErr ;
} NMOCEVENT, *PNMOCEVENT, *LPNMOCEVENT ;


#endif // NOOCHOST // }

//
// Access to shdocvw's active session count
//
enum SessionOp {
    SESSION_QUERY = 0,
    SESSION_INCREMENT,
    SESSION_DECREMENT,
	SESSION_INCREMENT_NODEFAULTBROWSERCHECK
};

long SetQueryNetSessionCount(enum SessionOp Op);
void IEWriteErrorLog(const EXCEPTION_RECORD* pexr);

//
// Internal APIs Follow.  NOT FOR PUBLIC CONSUMPTION.
//

// Errors shared in the shell

#define E_FILE_NOT_FOUND        MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND        MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)


// Useful macros

#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))
#define ShortFromResult(r)      (short)HRESULT_CODE(r)


#if (defined(UNICODE) && !defined(_X86_)) // all non-x86 systems require alignment
#ifndef ALIGNMENT_SCENARIO
#define ALIGNMENT_SCENARIO
#endif
#endif

#ifndef LPNTSTR_DEFINED
#define LPNTSTR_DEFINED
typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;
#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif
#endif // LPNTSTR_DEFINED

#define RFN_FIRST       (0U-510U) // run file dialog notify
#define RFN_LAST        (0U-519U)


//=======================================================================
// String constants for
//  1. Registration database keywords       (prefix STRREG_)
//  2. Exported functions from handler dlls (prefix STREXP_)
//  3. .INI file keywords                   (prefix STRINI_)
//  4. Others                               (prefix STR_)
//=======================================================================
#define STRREG_SHELLUI          TEXT("ShellUIHandler")
#define STRREG_SHELL            TEXT("Shell")
#define STRREG_DEFICON          TEXT("DefaultIcon")
#define STRREG_SHEX             TEXT("shellex")
#define STRREG_SHEX_PROPSHEET   STRREG_SHEX TEXT("\\PropertySheetHandlers")
#define STRREG_SHEX_DDHANDLER   STRREG_SHEX TEXT("\\DragDropHandlers")
#define STRREG_SHEX_MENUHANDLER STRREG_SHEX TEXT("\\ContextMenuHandlers")
#define STRREG_SHEX_COPYHOOK    TEXT("Directory\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_SHEX_PRNCOPYHOOK TEXT("Printers\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_STARTMENU TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Start Menu")
#define STRREG_FAVORITES TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Favorites")
#define STRREG_DISCARDABLE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Discardable")
#define STRREG_POSTSETUP        TEXT("\\PostSetup")

#define STREXP_CANUNLOAD        "DllCanUnloadNow"       // From OLE 2.0

#define STRINI_CLASSINFO        TEXT(".ShellClassInfo")       // secton name
#define STRINI_SHELLUI          TEXT("ShellUIHandler")
#define STRINI_OPENDIRICON      TEXT("OpenDirIcon")
#define STRINI_DIRICON          TEXT("DirIcon")

#define STR_DESKTOPINI          TEXT("desktop.ini")
#define STR_DESKTOPINIA         "desktop.ini"

#define DRIVEID(path)   ((*path - 'A') & 31)

#define PATH_CCH_EXT    64
// PathResolve flags
#define PRF_VERIFYEXISTS            0x0001
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)
#define PRF_FIRSTDIRDEF             0x0004
#define PRF_DONTFINDLNK             0x0008      // if PRF_TRYPROGRAMEXTENSIONS is specified

#ifndef NOUSER

typedef struct {
    NMHDR  hdr;
    CHAR   szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
    HMONITOR hMonitor;
} NMVIEWFOLDERA, *LPNMVIEWFOLDERA;
typedef struct {
    NMHDR  hdr;
    WCHAR  szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
    HMONITOR hMonitor;
} NMVIEWFOLDERW, *LPNMVIEWFOLDERW;
#ifdef UNICODE
typedef NMVIEWFOLDERW NMVIEWFOLDER;
typedef LPNMVIEWFOLDERW LPNMVIEWFOLDER;
#else
typedef NMVIEWFOLDERA NMVIEWFOLDER;
typedef LPNMVIEWFOLDERA LPNMVIEWFOLDER;
#endif // UNICODE

#endif

//
//  DDE related APIs
//
STDAPI_(void) ShellDDEInit(BOOL fInit);
STDAPI_(BOOL) DDEHandleViewFolderNotify(IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER lpnm);
STDAPI_(LPNMVIEWFOLDER) DDECreatePostNotify(LPNMVIEWFOLDER lpnm);

SHSTDAPI_(int) RestartDialog(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn);

SHSTDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID * lpclsid, IUnknown *pUnkOuter, REFIID riid, void **ppv);

SHSTDAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject ** ppdtobj);


// Common strings
#define STR_DESKTOPCLASS        "Progman"

//
// Storage name of a scrap/bookmark item
//
#define WSTR_SCRAPITEM L"\003ITEM000"


// For CallCPLEntry16
//
DECLARE_HANDLE(FARPROC16);
STDAPI_(LRESULT) CallCPLEntry16(HINSTANCE hinst, FARPROC16 lpfnEntry, HWND hwndCPL, UINT msg, LPARAM lParam1, LPARAM lParam2);

#ifdef RFN_FIRST
#define RFN_EXECUTE             (RFN_FIRST - 0)
typedef struct {
    NMHDR hdr;
    LPCSTR   lpszCmd;
    LPCSTR   lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEA, *LPNMRUNFILEA;
typedef struct {
    NMHDR hdr;
    LPCWSTR  lpszCmd;
    LPCWSTR  lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEW, *LPNMRUNFILEW;
#ifdef UNICODE
typedef NMRUNFILEW NMRUNFILE;
typedef LPNMRUNFILEW LPNMRUNFILE;
#else
typedef NMRUNFILEA NMRUNFILE;
typedef LPNMRUNFILEA LPNMRUNFILE;
#endif // UNICODE

#endif


SHSTDAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], IEnumFORMATETC **ppenumFormatEtc);


// Shell create link API
#define SHCL_USETEMPLATE        0x0001
#define SHCL_USEDESKTOP         0x0002
#define SHCL_CONFIRM            0x0004
#define SHCL_MAKEFOLDERSHORTCUT 0x0008

SHSTDAPI SHCreateLinks(HWND hwnd, LPCTSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl);

SHSTDAPI SHRegisterDragDrop(HWND hwnd, IDropTarget *pdtgt);
SHSTDAPI SHRevokeDragDrop(HWND hwnd);
SHSTDAPI SHDoDragDrop(HWND hwnd, IDataObject *pdata, IDropSource *pdsrc, DWORD dwEffect, DWORD *pdwEffect);

//===========================================================================
// office 9 pluggable UI
//===========================================================================

#define PUI_OFFICE_COMMAND     (WM_USER + 0x901)
#define PLUGUI_CMD_SHUTDOWN    0 // wParam value
#define PLUGUI_CMD_QUERY       1 // wParam value
#define OFFICE_VERSION_9       9 // standardized value to return for Office 9 apps

typedef struct _PLUGUI_INFO
{
    unsigned uMajorVersion : 8; // Used to indicate App's major version number
    unsigned uOleServer : 1;    // BOOL, TRUE if this is an OLE process
    unsigned uUnused : 23;      // not used
} PLUGUI_INFO;

typedef union _PLUGUI_QUERY
{
    UINT uQueryVal;
    PLUGUI_INFO PlugUIInfo;
} PLUGUI_QUERY;

//===========================================================================
// Image dragging API (definitely private)
//===========================================================================

// stuff for doing auto scrolling
#define NUM_POINTS      3
typedef struct {        // asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

//Contains the drag context header.
typedef struct {
    BOOL  fImage;
    BOOL  fLayered;
    POINT ptOffset;
} DragContextHeader;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0

SHSTDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT * pptOffset);
SHSTDAPI_(BOOL) DAD_DragEnter(HWND hwndTarget);
SHSTDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
SHSTDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtObject);
SHSTDAPI_(BOOL) DAD_ShowDragImage(BOOL fShow);
SHSTDAPI_(BOOL) DAD_DragMove(POINT pt);
SHSTDAPI_(BOOL) DAD_DragLeave(void);
SHSTDAPI_(BOOL) DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
SHSTDAPI_(BOOL) DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);
SHSTDAPI_(void) DAD_InvalidateCursors(void);



//----------------------------------------------------------------------------
// CABINETSTATE holds the global configuration for the Explorer and its cohorts.
//
// Originally the cLength was an 'int', it is now two words, allowing us to
// specify a version number.
//----------------------------------------------------------------------------

typedef struct {
    WORD cLength;
    WORD nVersion;

    BOOL fFullPathTitle            : 1;
    BOOL fSaveLocalView            : 1;
    BOOL fNotShell                 : 1;
    BOOL fSimpleDefault            : 1;
    BOOL fDontShowDescBar          : 1;
    BOOL fNewWindowMode            : 1;
    BOOL fShowCompColor            : 1;  // NT: Show compressed volumes in a different colour
    BOOL fDontPrettyNames          : 1;  // NT: Do 8.3 name conversion, or not!
    BOOL fAdminsCreateCommonGroups : 1;  // NT: Administrators create comon groups
    UINT fUnusedFlags : 7;

    UINT fMenuEnumFilter;

} CABINETSTATE, * LPCABINETSTATE;

#define CABINETSTATE_VERSION 2

// APIs for reading and writing the cabinet state.
SHSTDAPI_(BOOL) ReadCabinetState( LPCABINETSTATE lpState, int iSize );
SHSTDAPI_(BOOL) WriteCabinetState( LPCABINETSTATE lpState );


// RUN FILE RETURN values from notify message
#define RFR_NOTHANDLED 0
#define RFR_SUCCESS 1
#define RFR_FAILURE 2

#define PathGetExtensionORD     158

SHSTDAPI_(LPTSTR) PathGetExtension(LPCTSTR pszPath, LPTSTR pszExtension, int cchExt);
SHSTDAPI_(BOOL) PathMakeUniqueName(LPTSTR pszUniqueName, UINT cchMax, LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir);
SHSTDAPI_(BOOL) PathGetShortName(LPCTSTR pszLongName, LPTSTR pszShortName, UINT cbShortName);
SHSTDAPI_(BOOL) PathGetLongName(LPCTSTR pszShortName, LPTSTR pszLongName, UINT cbLongName);
SHSTDAPI_(BOOL) PathDirectoryExists(LPCTSTR pszDir);
SHSTDAPI_(void) PathQualify(LPTSTR psz);
SHSTDAPI_(LPTSTR) PathGetNextComponent(LPCTSTR pszPath, LPTSTR pszComponent);
SHSTDAPI_(BOOL) PathIsExe(LPCTSTR pszPath);

SHSTDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwAttr);
SHSTDAPI_(BOOL) PathIsSlowW(LPCWSTR pszFile, DWORD dwAttr);
#ifdef UNICODE
#define PathIsSlow  PathIsSlowW
#else
#define PathIsSlow  PathIsSlowA
#endif // !UNICODE
SHSTDAPI_(BOOL) PathIsTemporaryA(LPCSTR pszPath);
SHSTDAPI_(BOOL) PathIsTemporaryW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsTemporary  PathIsTemporaryW
#else
#define PathIsTemporary  PathIsTemporaryA
#endif // !UNICODE

//
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL           0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED       0x00000004
#define PCS_PATHTOOLONG     0x00000008  // Always combined with FATAL

SHSTDAPI_(int) PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);
SHSTDAPI_(int) PathCleanupSpecEx(LPCTSTR pszDir, LPTSTR pszSpec);
SHSTDAPI_(int) PathResolve(LPTSTR pszPath, LPCTSTR dirs[], UINT fFlags);
SHSTDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen);

// Needed for RunFileDlg
#define RFD_NOBROWSE            0x00000001
#define RFD_NODEFFILE           0x00000002
#define RFD_USEFULLPATHDIR      0x00000004
#define RFD_NOSHOWOPEN          0x00000008
#define RFD_WOW_APP             0x00000010
#define RFD_NOSEPMEMORY_BOX     0x00000020


SHSTDAPI_(int) RunFileDlg(HWND hwnd, HICON hIcon, LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
                          LPCTSTR pszPrompt, DWORD dwFlags);

SHSTDAPI_(BOOL) GetFileNameFromBrowse(HWND hwnd, LPTSTR pszFilePath, UINT cbFilePath,
                                      LPCTSTR pszWorkingDir, LPCTSTR pszDefExt, LPCTSTR pszFilters, LPCTSTR pszTitle);

SHSTDAPI_(int) DriveType(int iDrive);
SHSTDAPI_(int) RealDriveTypeFlags(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet);
SHSTDAPI_(void) InvalidateDriveType(int iDrive);
SHSTDAPI_(int) IsNetDrive(int iDrive);

//
// Constants used for dwNumFmtFlags argument in Int64ToString and LargeIntegerToString.
//
#define NUMFMT_IDIGITS    0x00000001
#define NUMFMT_ILZERO     0x00000002
#define NUMFMT_SGROUPING  0x00000004
#define NUMFMT_SDECIMAL   0x00000008
#define NUMFMT_STHOUSAND  0x00000010
#define NUMFMT_INEGNUMBER 0x00000020
#define NUMFMT_ALL        0xFFFFFFFF

SHSTDAPI_(int) LargeIntegerToString(LARGE_INTEGER *pN, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
SHSTDAPI_(int) Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);

//-------- drive type identification --------------
// iDrive      drive index (0=A, 1=B, ...)
//
#define DRIVE_CDROM     5           // extended DriveType() types
#define DRIVE_RAMDRIVE  6
#define DRIVE_TYPE      0x000F      // type masek
#define DRIVE_SLOW      0x0010      // drive is on a slow link
#define DRIVE_LFN       0x0020      // drive supports LFNs
#define DRIVE_AUTORUN   0x0040      // drive has AutoRun.inf in root.
#define DRIVE_AUDIOCD   0x0080      // drive is a AudioCD
#define DRIVE_AUTOOPEN  0x0100      // should *always* auto open on insert
#define DRIVE_NETUNAVAIL 0x0200     // Network drive that is not available
#define DRIVE_SHELLOPEN  0x0400     // should auto open on insert, if shell has focus
#define DRIVE_SECURITY   0x0800     // Supports ACLs
#define DRIVE_COMPRESSED 0x1000     // Root of volume is compressed
#define DRIVE_ISCOMPRESSIBLE 0x2000 // Drive supports compression (not nescesarrily compressed)
#define DRIVE_DVD       0x4000      // drive is a DVD

#define DriveTypeFlags(iDrive)      DriveType('A' + (iDrive))
#define DriveIsSlow(iDrive)         (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SLOW)
#define DriveIsLFN(iDrive)          (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_LFN)
#define DriveIsAutoRun(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTORUN)
#define DriveIsAutoOpen(iDrive)     (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTOOPEN)
#define DriveIsShellOpen(iDrive)    (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SHELLOPEN)
#define DriveIsAudioCD(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUDIOCD)
#define DriveIsNetUnAvail(iDrive)   (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_NETUNAVAIL)
#define DriveIsSecure(iDrive)       (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_SECURITY)
#define DriveIsCompressed(iDrive)   (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_COMPRESSED)
#define DriveIsCompressible(iDrive) (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_ISCOMPRESSIBLE)
#define DriveIsDVD(iDrive)          (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_DVD)

#define IsCDRomDrive(iDrive)        (RealDriveType(iDrive, FALSE) == DRIVE_CDROM)
#define IsRamDrive(iDrive)          (RealDriveType(iDrive, FALSE) == DRIVE_RAMDRIVE)
#define IsRemovableDrive(iDrive)    (RealDriveType(iDrive, FALSE) == DRIVE_REMOVABLE)
#define IsRemoteDrive(iDrive)       (RealDriveType(iDrive, FALSE) == DRIVE_REMOTE)


//
// For SHCreateDefClassObject
//
typedef HRESULT (CALLBACK *LPFNCREATEINSTANCE)(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);

SHSTDAPI SHCreateDefClassObject(REFIID riid, void **ppv, LPFNCREATEINSTANCE lpfn, UINT *pcRefDll, REFIID riidInstance);


// Flags for Shell_MergeMenus
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L
#define MM_DONTREMOVESEPS       0x00000004L

SHSTDAPI_(UINT) Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);


typedef HANDLE HNRES;           // for SHGetNetResource

SHSTDAPI_(UINT) SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);


/*
 * The SHObjectProperties API provides an easy way to invoke
 *   the Properties context menu command on shell objects.
 *
 *   PARAMETERS
 *
 *     hwnd    The window handle of the window which will own the dialog
 *     dwType       A SHOP_ value as defined below
 *     lpObject     Name of the object, see SHOP_ values below
 *     lpPage       The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
SHSTDAPI_(BOOL) SHObjectProperties(HWND hwnd, DWORD dwType, LPCTSTR lpObject, LPCTSTR lpPage);

#define SHOP_PRINTERNAME 0x00000001  // lpObject points to a printer friendly name
#define SHOP_FILEPATH    0x00000002  // lpObject points to a fully qualified path+file name
#define SHOP_VOLUMEGUID  0x00000004  // lpObject points to a Volume GUID
#define SHOP_TYPEMASK	 0x00000007
#define SHOP_MODAL       0x80000000


/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *               NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *               this dialog to come up as a "top level application" window.
 *               This parameter should always be non-null, this dialog is
 *               only designed to be the child of another window, not a
 *               stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *               NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *                     default format specified by the DMaint_FormatDrive
 *                     engine". If you want to FORCE a particular format
 *                     ID "up front" you will have to call
 *                     DMaint_GetFormatOptions yourself before calling
 *                     this to obtain the valid list of phys format IDs
 *                     (contents of the PhysFmtIDList array in the
 *                     FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *                SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *               The normal defualt in the Shell format dialog is
 *               "Quick Format", setting this option bit indicates that
 *               the caller wants to start with FULL format selected
 *               (this is useful for folks detecting "unformatted" disks
 *               and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *               All other bits are reserved for future expansion and
 *               must be 0.
 *
 *               Please note that this is a bit field and not a value
 *               and treat it accordingly.
 *
 *   RETURN
 *      The return is either one of the SHFMT_* values, or if the
 *      returned DWORD value is not == to one of these values, then
 *      the return is the physical format ID of the last succesful
 *      format. The LOWORD of this value can be passed on subsequent
 *      calls as the fmtID parameter to "format the same type you did
 *      last time".
 *
 */
SHSTDAPI_(DWORD) SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

SHSTDAPI_(DWORD) SHChkDskDrive(HWND hwnd, UINT drive);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR     0xFFFFFFFFL     // Error on last format, drive may be formatable
#define SHFMT_CANCEL    0xFFFFFFFEL     // Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL     // Drive is not formatable

//====== SEMI-PRIVATE API ===============================
#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif
WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
WINSHELLAPI HPSXA SHCreatePropSheetExtArrayEx( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface, IDataObject * pdo );

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHGetNetResourceORD                      69
#define SHObjectPropertiesORD                   178
#define SHAddFromPropSheetExtArrayORD           167
#define SHCreatePropSheetExtArrayORD            168
#define SHDestroyPropSheetExtArrayORD           169
#define SHReplaceFromPropSheetExtArrayORD       170
#define SHCreateDefClassObjectORD                70

#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)

#define SHEXP_SHADDFROMPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHAddFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEPROPSHEETEXTARRAY         MAKEINTRESOURCE(SHCreatePropSheetExtArrayORD)
#define SHEXP_SHDESTROYPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHDestroyPropSheetExtArrayORD)
#define SHEXP_SHREPLACEFROMPROPSHEETEXTARRAY    MAKEINTRESOURCE(SHReplaceFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)


// This avoids duplicate definition problems in the net\config project
// which defines *some* of its own PIDL utility functions, but depends on
// us for others (ILClone())
SHSTDAPI_(LPITEMIDLIST) ILClone(LPCITEMIDLIST pidl);

#ifndef AVOID_NET_CONFIG_DUPLICATES
//===========================================================================
// ITEMIDLIST
//===========================================================================

// flags for ILGetDisplayNameEx
#define ILGDN_FULLNAME  0
#define ILGDN_ITEMONLY  1
#define ILGDN_INFOLDER  2

SHSTDAPI_(LPITEMIDLIST) ILGetNext(LPCITEMIDLIST pidl);
SHSTDAPI_(UINT)         ILGetSize(LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) ILFindLastID(LPCITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILRemoveLastID(LPITEMIDLIST pidl);

#define ILIsEmpty(pidl)     ((pidl) == NULL || (pidl)->mkid.cb==0)

SHSTDAPI_(LPITEMIDLIST) ILCreate(void);
SHSTDAPI_(LPITEMIDLIST) ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);
SHSTDAPI_(void)         ILFree(LPITEMIDLIST pidl);
SHSTDAPI_(void)         ILGlobalFree(LPITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName);
SHSTDAPI_(BOOL)         ILGetDisplayNameEx(IShellFolder *psfRoot, LPCITEMIDLIST pidl, LPTSTR pszName, int fType);
SHSTDAPI_(BOOL)         ILGetPseudoNameA(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlBase, LPSTR pszName, int fType);
SHSTDAPI_(BOOL)         ILGetPseudoNameW(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlBase, LPWSTR pszName, int fType);
#ifdef UNICODE
#define ILGetPseudoName  ILGetPseudoNameW
#else
#define ILGetPseudoName  ILGetPseudoNameA
#endif // !UNICODE

SHSTDAPI_(LPITEMIDLIST) ILCloneFirst(LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) ILGlobalClone(LPCITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
SHSTDAPI_(BOOL)         ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
SHSTDAPI_(LPITEMIDLIST) ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
SHSTDAPI_(LPITEMIDLIST) ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
SHSTDAPI                ILLoadFromStream(IStream *pstm, LPITEMIDLIST *pidl);
SHSTDAPI                ILSaveToStream(IStream *pstm, LPCITEMIDLIST pidl);
SHSTDAPI                ILLoadFromFile(HFILE hfile, LPITEMIDLIST *pidl);
SHSTDAPI                ILSaveToFile(HFILE hfile, LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) _ILCreate(UINT cbSize);

#if (_WIN32_IE >= 0x0400)
SHSTDAPI_(LPITEMIDLIST) ILCreateFromPathA(LPCSTR pszPath);
SHSTDAPI_(LPITEMIDLIST) ILCreateFromPathW(LPCWSTR pszPath);
#ifdef UNICODE
#define ILCreateFromPath  ILCreateFromPathW
#else
#define ILCreateFromPath  ILCreateFromPathA
#endif // !UNICODE
#endif
SHSTDAPI SHILCreateFromPath(LPCTSTR szPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);

// helper macros
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

#endif // AVOID_NET_CONFIG_DUPLICATES

//
#undef  INTERFACE
#define INTERFACE   IDefViewFrame
DECLARE_INTERFACE_(IDefViewFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ IShellFolder **ppsf) PURE;

    // Warning!  Do not change or add any methods to this interface
    // because IE4 shell32.dll uses it, so changing the interface
    // breaks IE4 interop.

};

// Warning!  IE4's shell32.dll does not support IDefViewFrame2, so make
//           sure you can survive its absence.

#undef  INTERFACE
#define INTERFACE   IDefViewFrame2
DECLARE_INTERFACE_(IDefViewFrame2, IDefViewFrame)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewFrame methods ***
    STDMETHOD(GetWindowLV) (THIS_ HWND * phwnd) PURE;
    STDMETHOD(ReleaseWindowLV) (THIS) PURE;
    STDMETHOD(GetShellFolder)(THIS_ IShellFolder **ppsf) PURE;

    // *** IDefViewFrame2 methods ***
    STDMETHOD(GetWindowLV2) (THIS_ HWND * phwnd, IUnknown * punk) PURE;
    STDMETHOD(AutoAutoArrange)(THIS_ DWORD dwReserved) PURE;
};

#undef  INTERFACE
#define INTERFACE   IWebViewOCWinMan
DECLARE_INTERFACE_(IWebViewOCWinMan, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWebViewOCWinMan methods ***
    STDMETHOD(SwapWindow) (THIS_ HWND hwndLV, IWebViewOCWinMan **pocWinMan) PURE;
};

//===========================================================================
// Shell restrictions. (Parameter for SHRestricted)
typedef enum
{
    // Classic Win95 policy bits.  Do NOT add any more bits in
    // this range.  See the ranges below to add new policies.
    //          |                        |
    //          v                        v
    REST_NONE                       = 0x00000000,
    REST_NORUN                      = 0x00000001,
    REST_NOCLOSE                    = 0x00000002,
    REST_NOSAVESET                  = 0x00000004,
    REST_NOFILEMENU                 = 0x00000008,
    REST_NOSETFOLDERS               = 0x00000010,
    REST_NOSETTASKBAR               = 0x00000020,
    REST_NODESKTOP                  = 0x00000040,
    REST_NOFIND                     = 0x00000080,
    REST_NODRIVES                   = 0x00000100,
    REST_NODRIVEAUTORUN             = 0x00000200,
    REST_NODRIVETYPEAUTORUN         = 0x00000400,
    REST_NONETHOOD                  = 0x00000800,
    REST_STARTBANNER                = 0x00001000,
    REST_RESTRICTRUN                = 0x00002000,
    REST_NOPRINTERTABS              = 0x00004000,
    REST_NOPRINTERDELETE            = 0x00008000,
    REST_NOPRINTERADD               = 0x00010000,
    REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
    REST_MYDOCSONNET                = 0x00040000,
    REST_NOEXITTODOS                = 0x00080000,
    REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
    REST_LINKRESOLVEIGNORELINKINFO  = 0x00200000,
    REST_NOCOMMONGROUPS             = 0x00400000,
    REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
    REST_NOWEB                      = 0x01000000,
    REST_NOTRAYCONTEXTMENU          = 0x02000000,
    REST_NOVIEWCONTEXTMENU          = 0x04000000,
    REST_NONETCONNECTDISCONNECT     = 0x08000000,
    REST_STARTMENULOGOFF            = 0x10000000,
    REST_NOSETTINGSASSIST           = 0x20000000,

    // Values starting at 4000001 are treated as raw INTs.  New
    // *shell-specific* policies (NOT browser policies) should
    // be added in this range.  Use SHRestricted() with these bits.
    //          |                        |
    //          v                        v

    REST_NOINTERNETICON             = 0x40000001,
    REST_NORECENTDOCSHISTORY        = 0x40000002,
    REST_NORECENTDOCSMENU           = 0x40000003,
    REST_NOACTIVEDESKTOP            = 0x40000004,
    REST_NOACTIVEDESKTOPCHANGES     = 0x40000005,
    REST_NOFAVORITESMENU            = 0x40000006,
    REST_CLEARRECENTDOCSONEXIT      = 0x40000007,
    REST_CLASSICSHELL               = 0x40000008,
    REST_NOCUSTOMIZEWEBVIEW         = 0x40000009,
    REST_NOHTMLWALLPAPER            = 0x40000010,
    REST_NOCHANGINGWALLPAPER        = 0x40000011,
    REST_NODESKCOMP                 = 0x40000012,
    REST_NOADDDESKCOMP              = 0x40000013,
    REST_NODELDESKCOMP              = 0x40000014,
    REST_NOCLOSEDESKCOMP            = 0x40000015,
    REST_NOCLOSE_DRAGDROPBAND       = 0x40000016,   // Disable Close and Drag & Drop on ALL Bands
    REST_NOMOVINGBAND               = 0x40000017,   // Disable Moving ALL Bands
    REST_NOEDITDESKCOMP             = 0x40000018,
    REST_NORESOLVESEARCH            = 0x40000019,
    REST_NORESOLVETRACK             = 0x4000001A,
    REST_FORCECOPYACLWITHFILE       = 0X4000001B,
    REST_NOLOGO3CHANNELNOTIFY       = 0x4000001C,
    REST_NOFORGETSOFTWAREUPDATE     = 0x4000001D,
    REST_NOSETACTIVEDESKTOP         = 0x4000001E,   // No Active desktop on Settings Menu
    REST_NOUPDATEWINDOWS            = 0x4000001F,   // No Windows Update on Settings Menu
    REST_NOCHANGESTARMENU           = 0x40000020,   // No Context menu or Drag and Drop on Start menu
    REST_NOFOLDEROPTIONS            = 0x40000021,   // No Folder Options on Settings Menu
    REST_HASFINDCOMPUTERS           = 0x40000022,   // Show Start/Search/Computers
    REST_INTELLIMENUS               = 0x40000023,
    REST_RUNDLGMEMCHECKBOX          = 0x40000024,
    REST_ARP_ShowPostSetup          = 0x40000025,   // ARP: Show Post-Setup page
    REST_NOCSC                      = 0x40000026,   // Disable the ClientSide caching on SM
    REST_NOCONTROLPANEL             = 0x40000027,   // Remove the Control Panel only from SM|Settings
    REST_ENUMWORKGROUP              = 0x40000028,   // Enumerate workgroup in root of nethood
    REST_ARP_NOARP                  = 0x40000029,   // ARP: Don't Allow ARP to come up at all
    REST_ARP_NOREMOVEPAGE           = 0x4000002A,   // ARP: Don't allow Remove page
    REST_ARP_NOADDPAGE              = 0x4000002B,   // ARP: Don't allow Add page
    REST_ARP_NOWINSETUPPAGE         = 0x4000002C,   // ARP: Don't allow opt components page
    REST_GREYMSIADS                 = 0x4000002D,    // SM: Allow the greying of Darwin Ads in SM
    REST_NOCHANGEMAPPEDDRIVELABEL   = 0x4000002E,   // Don't enable the UI which allows users to rename mapped drive labels
    REST_NOCHANGEMAPPEDDRIVECOMMENT = 0x4000002F,   // Don't enable the UI which allows users to change mapped drive comments
    REST_MaxRecentDocs              = 0x40000030,
    REST_NONETWORKCONNECTIONS       = 0x40000031,   // No Start Menu | Settings |Network Connections
    REST_FORCESTARTMENULOGOFF       = 0x40000032,   // Force logoff on the Start Menu
    REST_NOWEBVIEW                  = 0x40000033,   // Disable Web View
    REST_NOCUSTOMIZETHISFOLDER      = 0x40000034,   // Disable Customize This Folder
    REST_NOENCRYPTION               = 0x40000035,   // Don't allow file encryption
    REST_ALLOWFRENCRYPTION          = 0x40000036,   // Allow encryption in France (Do not publish)
    REST_DONTSHOWSUPERHIDDEN        = 0x40000037,   // don't show super hidden files
    REST_NOSHELLSEARCHBUTTON        = 0x40000038,
    REST_NOHARDWARETAB              = 0x40000039,   // No Hardware tab on Drives or in control panel
    REST_NORUNASINSTALLPROMPT       = 0x4000003A,   // Don't bring up "Run As" prompt for install programs
    REST_PROMPTRUNASINSTALLNETPATH  = 0x4000003B,   // Force the  "Run As" prompt for install programs on unc/network shares
    REST_NOMANAGEMYCOMPUTERVERB     = 0x4000003C,   // No Manage verb on My Computer
    REST_NORECENTDOCSNETHOOD        = 0x4000003D,   // dont add the recent docs shares to nethood
    REST_DISALLOWRUN                = 0x4000003E,   // don't allow certain apps to be run
    REST_NOWELCOMESCREEN            = 0x4000003F,   // don't allow the welcome screen to be displayed.
    REST_RESTRICTCPL                = 0x40000040,   // only allow certain cpls to be run
    REST_DISALLOWCPL                = 0x40000041,   // don't allow certain cpls to be run
    REST_NOSMBALLOONTIP             = 0x40000042,   // No Start Menu Balloon Tip
    REST_NOSMHELP                   = 0x40000043,   // No Help on the Start Menu
    REST_NOWINKEYS                  = 0x40000044,   // No Windows-X Hot keys
    REST_NOENCRYPTONMOVE            = 0x40000045,   // Don't automatically try to encrypt files that are moved to encryped directories
    REST_NOLOCALMACHINERUN          = 0x40000046,   // ignore HKLM\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOCURRENTUSERRUN           = 0x40000047,   // ignore HKCU\sw\ms\win\cv\Run and all of it's sub keys
    REST_NOLOCALMACHINERUNONCE      = 0x40000048,   // ignore HKLM\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_NOCURRENTUSERRUNONCE       = 0x40000049,   // ignore HKCU\sw\ms\win\cv\RunOnce and all of it's sub keys
    REST_FORCEACTIVEDESKTOPON       = 0x4000004A,   // Force ActiveDesktop to be turned ON all the time.
    REST_NOCOMPUTERSNEARME          = 0x4000004B,   // removes the "Computers near me" link
    REST_NOVIEWONDRIVE              = 0x4000004C,   // disallows CreateViewObject() on specified drives (CFSFolder only)

// BUGBUG: Space is taken by Millennium changes
    REST_NOSMMYDOCS                 = 0x4000004F,   // Don't show the My Documents item on the Start Menu.
#ifdef WINNT // hydra specific ids
    REST_NODISCONNECT               = 0x41000001,   // No Disconnect option in Start menu
    REST_NOSECURITY                 = 0x41000002,   // No Security option in start menu
    REST_NOFILEASSOCIATE            = 0x41000003,   // Do not allow user to change file association
#endif
} RESTRICTIONS;


// Browser restrictions (parameter for SHRestricted2)
//
// The browser restrictions are divided into two ranges, "explorer restrictions" and
// "infodelivery restrictions".  Explorer restrictions are kept under "Software\\Microsoft\\
// Windows\\CurrentVersion\\Policies\\Explorer," while infodelivery restrictions are kept
// under "Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions."
//
// **NOTE**: SHRestricted2 assumes each range is continuous.
typedef enum {
    // explorer restrictions
    REST_BROWSER_NONE               = 0x00000000,   // REST_EXPLORER_FIRST
    REST_NOTOOLBARCUSTOMIZE         = 0x00000001,
    REST_NOBANDCUSTOMIZE            = 0x00000002,
    REST_SMALLICONS                 = 0x00000003,
    REST_LOCKICONSIZE               = 0x00000004,
    REST_SPECIFYDEFAULTBUTTONS      = 0x00000005,
    REST_BTN_BACK                   = 0x00000006,
    REST_BTN_FORWARD                = 0x00000007,
    REST_BTN_STOPDOWNLOAD           = 0x00000008,
    REST_BTN_REFRESH                = 0x00000009,
    REST_BTN_HOME                   = 0x0000000A,
    REST_BTN_SEARCH                 = 0x0000000B,
    REST_BTN_HISTORY                = 0x0000000C,
    REST_BTN_FAVORITES              = 0x0000000D,
    REST_BTN_ALLFOLDERS             = 0x0000000E,
    REST_BTN_THEATER                = 0x0000000F,
    REST_BTN_TOOLS                  = 0x00000010,
    REST_BTN_MAIL                   = 0x00000011,
    REST_BTN_FONTS                  = 0x00000012,
    REST_BTN_PRINT                  = 0x00000013,
    REST_BTN_EDIT                   = 0x00000014,
    REST_BTN_DISCUSSIONS            = 0x00000015,
    REST_BTN_CUT                    = 0x00000016,
    REST_BTN_COPY                   = 0x00000017,
    REST_BTN_PASTE                  = 0x00000018,
    REST_BTN_ENCODING               = 0x00000019,
    REST_NoUserAssist               = 0x0000001A,
    REST_NoWindowsUpdate            = 0x0000001B,
    REST_NoExpandedNewMenu          = 0x0000001C,
    REST_NOFILEURL                  = 0x0000001D,   // REST_EXPLORER_LAST

    // infodelivery restrictions
    REST_NoChannelUI                = 0x50000001,   // REST_INFO_FIRST
    REST_NoAddingChannels           = 0x50000002,
    REST_NoEditingChannels          = 0x50000003,
    REST_NoRemovingChannels         = 0x50000004,
    REST_NoAddingSubscriptions      = 0x50000005,
    REST_NoEditingSubscriptions     = 0x50000006,
    REST_NoRemovingSubscriptions    = 0x50000007,
    REST_NoChannelLogging           = 0x50000008,
    REST_NoManualUpdates            = 0x50000009,
    REST_NoScheduledUpdates         = 0x5000000A,
    REST_NoUnattendedDialing        = 0x5000000B,
    REST_NoChannelContent           = 0x5000000C,
    REST_NoSubscriptionContent      = 0x5000000D,
    REST_NoEditingScheduleGroups    = 0x5000000E,
    REST_MaxChannelSize             = 0x5000000F,
    REST_MaxSubscriptionSize        = 0x50000010,
    REST_MaxChannelCount            = 0x50000011,
    REST_MaxSubscriptionCount       = 0x50000012,
    REST_MinUpdateInterval          = 0x50000013,
    REST_UpdateExcludeBegin         = 0x50000014,
    REST_UpdateExcludeEnd           = 0x50000015,
    REST_UpdateInNewProcess         = 0x50000016,
    REST_MaxWebcrawlLevels          = 0x50000017,
    REST_MaxChannelLevels           = 0x50000018,
    REST_NoSubscriptionPasswords    = 0x50000019,
    REST_NoBrowserSaveWebComplete   = 0x5000001A,
    REST_NoSearchCustomization      = 0x5000001B,
    REST_NoSplash                   = 0x5000001C,  // REST_INFO_LAST

    // restrictions ported from SP2
    REST_NoFileOpen                 = 0x60000001,  // REST_BROWSER_FIRST
    REST_NoFileNew                  = 0x60000002,
    REST_NoBrowserSaveAs            = 0x60000003,
    REST_NoBrowserOptions           = 0x60000004,
    REST_NoFavorites                = 0x60000005,
    REST_NoSelectDownloadDir        = 0x60000006,
    REST_NoBrowserContextMenu       = 0x60000007,
    REST_NoBrowserClose             = 0x60000008,
    REST_NoOpeninNewWnd             = 0x60000009,
    REST_NoTheaterMode              = 0x6000000A,
    REST_NoFindFiles                = 0x6000000B,
    REST_NoViewSource               = 0x6000000C,
    REST_GoMenu                     = 0x6000000D,
    REST_NoToolbarOptions           = 0x6000000E,

    REST_NoHelpItem_TipOfTheDay     = 0x6000000F,
    REST_NoHelpItem_NetscapeHelp    = 0x60000010,
    REST_NoHelpItem_Tutorial        = 0x60000011,
    REST_NoHelpItem_SendFeedback    = 0x60000012,
    REST_AlwaysPromptWhenDownload   = 0x60000013,

    REST_NoNavButtons               = 0x60000014,
    REST_NoHelpMenu                 = 0x60000015,
    REST_NoBrowserBars              = 0x60000016,
    REST_NoToolBar                  = 0x60000017,
    REST_NoAddressBar               = 0x60000018,
    REST_NoLinksBar                 = 0x60000019,  // REST_BROWSER_LAST

} BROWSER_RESTRICTIONS;

#define REST_EXPLORER_FIRST     REST_BROWSER_NONE
#define REST_EXPLORER_LAST      REST_NOFILEURL

#define REST_INFO_FIRST         REST_NoChannelUI
#define REST_INFO_LAST          REST_NoSplash

#define REST_BROWSER_FIRST      REST_NoFileOpen
#define REST_BROWSER_LAST       REST_NoLinksBar

// codes for REST_BTN policies
#define RESTOPT_BTN_STATE_DEFAULT       0   // must be zero, else break browseui\itbar.cpp assumption
#define RESTOPT_BTN_STATE_VISIBLE       1
#define RESTOPT_BTN_STATE_HIDDEN        2

// REST_INTELLIMENUS
#define RESTOPT_INTELLIMENUS_USER       0
#define RESTOPT_INTELLIMENUS_DISABLED   1       // Match Restriction assumption: 1 == Off
#define RESTOPT_INTELLIMENUS_ENABLED    2


// FTP Exports
STDAPI IsIEDefautlFTPClient(void);
STDAPI MakeIEDefautlFTPClient(void);
STDAPI RestoreFTPClient(void);


SHSTDAPI_(void) SHSettingsChanged(WPARAM wParam, LPARAM lParam);
SHSTDAPI_(BOOL) SHIsBadInterfacePtr(LPCVOID pv, UINT cbVtbl);
SHSTDAPI_(IStream *) OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode);
SHSTDAPI_(void) SHHandleDiskFull(HWND hwnd, int idDrive);

SHSTDAPI_(BOOL) SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
SHSTDAPI_(BOOL) SHFindComputer(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);

SHSTDAPI_(void) PathGetShortPath(LPTSTR pszLongPath);
SHSTDAPI_(BOOL) PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName, LPCTSTR pszPath, LPCTSTR pszShort, LPCTSTR pszFileSpec);

SHSTDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszPath);
SHSTDAPI_(BOOL) Win32DeleteFile(LPCTSTR pszPath);

SHSTDAPI_(void) SHUpdateRecycleBinIcon();

//
// Path processing function
//

#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_NORELATIVEOBJECTQUALIFY 0x00000020        // don't return fully qualified relative objects
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names
#define PPCF_LONGESTPOSSIBLE         0x00000080        // always find the longest possible name

SHSTDAPI_(LONG) PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iMax, DWORD dwFlags);
SHSTDAPI_(LPITEMIDLIST) SHLogILFromFSIL(LPCITEMIDLIST pidlFS);
SHSTDAPI_(BOOL) StrRetToStrN(LPTSTR szOut, UINT uszOut, STRRET *pStrRet, LPCITEMIDLIST pidl);
SHSTDAPI_(DWORD) SHWaitForFileToOpen(LPCITEMIDLIST pidl, UINT uOptions, DWORD dwtimeout);
SHSTDAPI_(void) SetAppStartingCursor(HWND hwnd, BOOL fSet);
SHSTDAPI_(DWORD) SHRestricted(RESTRICTIONS rest);
SHSTDAPI_(void *) SHGetHandlerEntry(LPCTSTR szHandler, LPCSTR szProcName, HINSTANCE *lpModule);


SHSTDAPI_(BOOL) SignalFileOpen(LPCITEMIDLIST pidl);
SHSTDAPI_(LPITEMIDLIST) SHSimpleIDListFromPath(LPCTSTR pszPath);

SHSTDAPI SHCreatePropertyBag(REFIID riid, void **ppv);

SHSTDAPI_(DWORD) SHNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType);
SHSTDAPI SHLoadOLE(LPARAM lParam);
SHSTDAPI_(void) Desktop_UpdateBriefcaseOnEvent(HWND hwnd, UINT uEvent);


SHSTDAPI SHStartNetConnectionDialogA(HWND hwnd, LPCSTR pszRemoteName, DWORD dwType);
SHSTDAPI SHStartNetConnectionDialogW(HWND hwnd, LPCWSTR pszRemoteName, DWORD dwType);
#ifdef UNICODE
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogW
#else
#define SHStartNetConnectionDialog  SHStartNetConnectionDialogA
#endif // !UNICODE
SHSTDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags,
                           HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
SHSTDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags,
                           HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
#ifdef UNICODE
#define SHDefExtractIcon  SHDefExtractIconW
#else
#define SHDefExtractIcon  SHDefExtractIconA
#endif // !UNICODE
SHSTDAPI_(int) SHLookupIconIndexA(LPCSTR pszFile, int iIconIndex, UINT uFlags);
SHSTDAPI_(int) SHLookupIconIndexW(LPCWSTR pszFile, int iIconIndex, UINT uFlags);
#ifdef UNICODE
#define SHLookupIconIndex  SHLookupIconIndexW
#else
#define SHLookupIconIndex  SHLookupIconIndexA
#endif // !UNICODE
SHSTDAPI_(UINT) SHExtractIconsA(LPCSTR pszFileName, int nIconIndex, int cxIcon, int cyIcon,
                                HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
SHSTDAPI_(UINT) SHExtractIconsW(LPCWSTR pszFileName, int nIconIndex, int cxIcon, int cyIcon,
                                HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
#ifdef UNICODE
#define SHExtractIcons  SHExtractIconsW
#else
#define SHExtractIcons  SHExtractIconsA
#endif // !UNICODE
SHSTDAPI SHGetAssociations(LPCITEMIDLIST pidl, void **ppvQueryAssociations);

#define SHLookupIconIndexAORD   7
#define SHLookupIconIndexWORD   8
#ifdef UNICODE
#define SHLookupIconIndexORD    SHLookupIconIndexWORD
#else
#define SHDefExtractIcon    SHDefExtractIconA
#endif


// BUGBUG (scotth): temporary.  move to shdocvw.
// OpenAsInfo flags
#define OAIF_ALLOW_REGISTRATION     0x00000001      // enable the "always use this file" checkbox (NOTE if you dont pass this, it will be disabled)
#define OAIF_REGISTER_EXT           0x00000002      // do the registration after the user hits "ok"
#define OAIF_EXEC                   0x00000004      // execute file after registering
#define OAIF_FORCE_REGISTRATION     0x00000008      // force the "always use this file" checkbox to be checked (normally, you wont use the OAIF_ALLOW_REGISTRATION wen you pass this)
#define OAIF_ALL                    (OAIF_ALLOW_REGISTRATION | OAIF_REGISTER_EXT | OAIF_EXEC | OAIF_FORCE_REGISTRATION)  //

typedef struct _openasinfo
{
    LPCTSTR pcszFile;           // [in] file name
    LPCTSTR pcszClass;          // [in] file class description.  NULL means
                                //      use pcszFile's extension
    DWORD dwInFlags;            // [in] input flags from OAIF_*

    TCHAR szApp[MAX_PATH];      // [out] application selected
} OPENASINFO, * POPENASINFO;

SHSTDAPI OpenAsDialog(HWND hwnd, POPENASINFO poainfo);

//
// Interface pointer validation
//
#define IsBadInterfacePtr(pitf, ITF)  SHIsBadInterfacePtr(pitf, sizeof(ITF##Vtbl))

//===========================================================================
// Another block of private API
//===========================================================================

// indexes into the shell image lists (Shell_GetImageList) for default images
// If you add to this list, you also need to update II_LASTSYSICON!

#define II_DOCNOASSOC         0  // document (blank page) (not associated)
#define II_DOCUMENT           1  // document (with stuff on the page)
#define II_APPLICATION        2  // application (exe, com, bat)
#define II_FOLDER             3  // folder (plain)
#define II_FOLDEROPEN         4  // folder (open)
#define II_DRIVE525           5
#define II_DRIVE35            6
#define II_DRIVEREMOVE        7
#define II_DRIVEFIXED         8
#define II_DRIVENET           9
#define II_DRIVENETDISABLED  10
#define II_DRIVECD           11
#define II_DRIVERAM          12
#define II_WORLD             13
#define II_NETWORK           14
#define II_SERVER            15
#define II_PRINTER           16
#define II_MYNETWORK         17
#define II_GROUP             18
// Startmenu images.
#define II_STPROGS           19
#define II_STDOCS            20
#define II_STSETNGS          21
#define II_STFIND            22
#define II_STHELP            23
#define II_STRUN             24
#define II_STSUSPEND         25
#define II_STEJECT           26
#define II_STSHUTD           27

#define II_SHARE             28
#define II_LINK              29
#define II_SLOWFILE          30
#define II_RECYCLER          31
#define II_RECYCLERFULL      32
#define II_RNA               33
#define II_DESKTOP           34

// More startmenu image.
#define II_STCPANEL          35
#define II_STSPROGS          36
#define II_STPRNTRS          37
#define II_STFONTS           38
#define II_STTASKBR          39

#define II_CDAUDIO           40
#define II_TREE              41
#define II_STCPROGS          42
#define II_STFAVORITES       43
#define II_STLOGOFF          44
#define II_STFLDRPROP        45
#define II_WINUPDATE         46

#define II_MU_STSECURITY     47
#define II_MU_STDISCONN      48

#ifdef WINNT // hydra specific id
#define II_LASTSYSICON       II_MU_STDISCONN
#else
// Last system image list icon index - used by icon cache manager
#define II_LASTSYSICON       II_WINUPDATE
#endif

// Overlay indexes
#define II_OVERLAYFIRST      II_SHARE
#define II_OVERLAYLAST       II_SLOWFILE

#define II_NDSCONTAINER      72
#define II_SERVERSHARE       73

SHSTDAPI_(BOOL) FileIconInit( BOOL fRestoreCache );

SHSTDAPI_(BOOL) Shell_GetImageLists(HIMAGELIST *phiml, HIMAGELIST *phimlSmall);
SHSTDAPI_(void) Shell_SysColorChange(void);
SHSTDAPI_(int)  Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);


// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
SHSTDAPI_(int) SHMapPIDLToSystemImageListIndex(IShellFolder *pshf, LPCITEMIDLIST pidl, int *piIndexSel);
//
// OLE string
//
SHSTDAPI_(int) OleStrToStrN(LPTSTR, int, LPCOLESTR, int);
SHSTDAPI_(int) StrToOleStrN(LPOLESTR, int, LPCTSTR, int);
SHSTDAPI_(int) OleStrToStr(LPTSTR, LPCOLESTR);
SHSTDAPI_(int) StrToOleStr(LPOLESTR, LPCTSTR);


// Tray CopyData Messages
#define TCDM_APPBAR     0x00000000
#define TCDM_NOTIFY     0x00000001
#define TCDM_LOADINPROC 0x00000002

//
//  new navigation stack interfaces

#undef  INTERFACE
#define INTERFACE   ITravelEntry

DECLARE_INTERFACE_(ITravelEntry, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ITravelEntry specific methods
    STDMETHOD(Invoke)(THIS_ IUnknown *punk) PURE;
    STDMETHOD(Update)(THIS_ IUnknown *punk, BOOL fIsLocalAnchor) PURE;
    STDMETHOD(GetPidl)(THIS_ LPITEMIDLIST *ppidl) PURE;
};

#undef  INTERFACE
#define INTERFACE   ITravelLog

#define TLOG_BACK   -1
#define TLOG_FORE   1

#define TLMENUF_INCLUDECURRENT                  0x00000001
#define TLMENUF_CHECKCURRENT                    (TLMENUF_INCLUDECURRENT | 0x00000002)
#define TLMENUF_BACK                            0x00000010  // Default
#define TLMENUF_FORE                            0x00000020
#define TLMENUF_BACKANDFORTH                    (TLMENUF_BACK | TLMENUF_FORE | TLMENUF_INCLUDECURRENT)

DECLARE_INTERFACE_(ITravelLog, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ITravelLog specific methods
    STDMETHOD(AddEntry)(THIS_ IUnknown *punk, BOOL fIsLocalAnchor) PURE;
    STDMETHOD(UpdateEntry)(THIS_ IUnknown *punk, BOOL fIsLocalAnchor) PURE;
    STDMETHOD(UpdateExternal)(THIS_ IUnknown *punk, IUnknown *punkHLBrowseContext) PURE;
    STDMETHOD(Travel)(THIS_ IUnknown *punk, int iOffset) PURE;
    STDMETHOD(GetTravelEntry)(THIS_ IUnknown *punk, int iOffset, ITravelEntry **ppte) PURE;
    STDMETHOD(FindTravelEntry)(THIS_ IUnknown *punk, LPCITEMIDLIST pidl, ITravelEntry **ppte) PURE;
    STDMETHOD(GetToolTipText)(THIS_ IUnknown *punk, int iOffset, int idsTemplate, LPWSTR pwzText, DWORD cchText) PURE;
    STDMETHOD(InsertMenuEntries)(THIS_ IUnknown *punk, HMENU hmenu, int nPos, int idFirst, int idLast, DWORD dwFlags) PURE;
    STDMETHOD(Clone)(THIS_ ITravelLog **pptl) PURE;
    STDMETHOD_(DWORD, CountEntries)(THIS_ IUnknown *punk) PURE;
    STDMETHOD(Revert)(void) PURE;
};


//
// Private QueryContextMenuFlag passed from Bands
//
#define CMF_BANDCMD      0x00020000     // Install Band Context menu commands

//
// Functions to help the cabinets sync to each other
//  uOptions parameter to SHWaitForFileOpen
//
#define WFFO_WAITTIME 10000L

#define WFFO_ADD        0x0001
#define WFFO_REMOVE     0x0002
#define WFFO_WAIT       0x0004
#define WFFO_SIGNAL     0x0008



//
// NOTES: IShellService is used when we share a service component
//  (which implements a certain interface) among multiple clients
//  (such as IE 3.0 and Explorer). The client always CoCreateInstance
//  it and call SetOwner(this). When the client is going away
//  (typically when the window is closed), it calls SetOwner(NULL)
//  to let the service object releases the reference to the owner
//  object.
//
#undef  INTERFACE
#define INTERFACE   IShellService

DECLARE_INTERFACE_(IShellService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellService specific methods ***
    STDMETHOD(SetOwner)(THIS_ struct IUnknown* punkOwner) PURE;
};


//
// NOTES: IHistSFPrivate is used when manipulating a history IShellFolder object
//      It includes methods for pointing the shell folder at the correct virtual
//      directory.  QIing for IHistSFPrivate also guarantees the pidl format can
//      safely be delved into to access the INTERNET_CACHE_ENTRY_INFO structure
//
#undef  INTERFACE
#define INTERFACE   IHistSFPrivate

DECLARE_INTERFACE_(IHistSFPrivate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IHistPrivate specific methods ***
    STDMETHOD(SetCachePrefix)(THIS_ LPCWSTR pszCachePrefix) PURE;
    STDMETHOD(SetDomain)(THIS_ LPCWSTR pszDomain) PURE;
    STDMETHOD(WriteHistory)(THIS_ LPCWSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, LPITEMIDLIST * ppidlSelect) PURE;
    STDMETHOD(ClearHistory) (THIS) PURE;
};

//
// NOTES:  IShellFolderViewType lets a shell folder support different "views" on
//      its contents (meaning different hierarchical layouts of its data) with
//      the default "view" being the one the shell folder displays normally.
//      This enumerator returns pidls that are special hidden folders at the
//      top level of the shell folder (which are not otherwise enumerated).
#undef  INTERFACE
#define INTERFACE   IShellFolderViewType
DECLARE_INTERFACE_(IShellFolderViewType, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewType Methods ***

    // NOTE: "Views" are seen by the user as hidden folders off the
    //       root (represented by pidls).  Whenever appropriate, the
    //       default view (coming off the root folder) is represented
    //       as the NULL *or* empty pidl.

    // EnumViews:
    //   Return an enumerator which will give out one pidl for every extended view.
    STDMETHOD(EnumViews)(THIS_ ULONG grfFlags, IEnumIDList **ppenum) PURE;

    // GetDefaultViewName:
    //   Return the name of the default view.  The names of the other views
    //   can be retrieved by calling GetDisplayNameOf.
    STDMETHOD(GetDefaultViewName)(THIS_ DWORD  uFlags, LPWSTR *ppwszName)      PURE;
    STDMETHOD(GetViewTypeProperties)(THIS_ LPCITEMIDLIST pidl, DWORD *pdwFlags)  PURE;

    // TranslateViewPidl:
    //   Attempt to take a pidl represented in one heirarchical representation of
    //   the shell folder, and find it in a different representation.
    //   pidl should be relative to the root folder.
    //   Remember to ILFree ppidlOut
    STDMETHOD(TranslateViewPidl)(THIS_ LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView, LPITEMIDLIST *ppidlOut) PURE;
};

#define SFVTFLAG_NOTIFY_CREATE  0x00000001
#define SFVTFLAG_NOTIFY_RESORT  0x00000002

//
// NOTES: IShellFolderSearchableCallback allows the searcher to provide
//          callback routines that moniter the search process
//
#undef  INTERFACE
#define INTERFACE IShellFolderSearchableCallback
DECLARE_INTERFACE_(IShellFolderSearchableCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderSearchableCallback Methods ***

    // NOTE: Caller may pass NULL for pVar or pdwFlags as a legal value
    STDMETHOD(RunBegin)(DWORD dwReserved) PURE;
    STDMETHOD(RunEnd)(DWORD dwReserved) PURE;
};

//
// NOTES: IShellFolderSearchable allows a shell extension to provide a searchable
//        namespace.
#undef  INTERFACE
#define INTERFACE IShellFolderSearchable
DECLARE_INTERFACE_(IShellFolderSearchable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderSearchable methods ***

    // FindString -
    //  The returned shell folder's enumerator will have any
    //   search hits for the given search string.
    //  As no flags are currently defined, we suggest you pass
    //    NULL as lpdword
    //  punkOnAsyncSearch will be QI'd for IShellFolderSearchableCallback
    STDMETHOD(FindString)(THIS_ LPCWSTR pwszTarget, DWORD *pdwFlags,
                          IUnknown *punkOnAsyncSearch, LPITEMIDLIST *ppidlOut)   PURE;
    // CancelAsyncSearch -
    //   Begins the process of cancelling  any pending
    //    asynchronous search from this pidl.
    //    When the search is actually cancelled, RunEnd will be called
    //   Returns: S_OK => cancelling, S_FALSE => not running
    STDMETHOD(CancelAsyncSearch) (THIS_ LPCITEMIDLIST pidlSearch, DWORD *pdwFlags) PURE;

    // InvalidateSearch -
    //   Makes this pidl no longer a valid portion of the shell folder
    //    also does some cleanup of any databases used in the search and
    //    will cause the eventual release of the IRunHook callback
    //   May cause async search to be cancelled
    STDMETHOD(InvalidateSearch)  (THIS_ LPCITEMIDLIST pidlSearch, DWORD *pdwFlags) PURE;
};

//
// NOTES: IBandSiteHelper is used to let explorer's BandSite implementation,
//  which aggregates shdocvw's BandSite, provide callback hooks for shdocvw
//  to call.
//
#undef  INTERFACE
#define INTERFACE   IBandSiteHelper

DECLARE_INTERFACE_(IBandSiteHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandSiteHelper specific methods ***
    STDMETHOD(LoadFromStreamBS)(THIS_ struct IStream* pstm, REFIID riid, void **ppv) PURE;
    STDMETHOD(SaveToStreamBS)(THIS_ struct IUnknown* punk, struct IStream* pstm) PURE;
};

// This private interface is added such that some of the support features that is in
// SHDocvw's Internet explorer frame automation code, that is not part of publicly
// defined interfaces can be used in the Explorer code...
//
// Note: FindCIE4ConnectionPoint was a hack for IE4.  New code should use
//       shlwapi helper functions like IConnectionPoint_Invoke instead.
//

#ifdef __cplusplus
class CIE4ConnectionPoint;
#else
typedef struct CIE4ConnectionPoint CIE4ConnectionPoint;
#endif

#undef  INTERFACE
#define INTERFACE   IExpDispSupport

DECLARE_INTERFACE_(IExpDispSupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExpDispSupport specific methods ***
    STDMETHOD(FindCIE4ConnectionPoint)(THIS_ REFIID riid, CIE4ConnectionPoint **ppccp) PURE;
    STDMETHOD(OnTranslateAccelerator)(MSG  *pMsg, DWORD grfModifiers) PURE;
    STDMETHOD(OnInvoke)(THIS_ DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                        VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) PURE;
};

//
// This interface is related to the above. It contains functions
// that would only be implemented on the WebBrowserOC version if IExpDispSupport.
//
#undef  INTERFACE
#define INTERFACE   IExpDispSupportOC
DECLARE_INTERFACE_(IExpDispSupportOC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExpDispSupportOC specific methods ***
    STDMETHOD(OnOnControlInfoChanged)() PURE;
    STDMETHOD(GetDoVerbMSG)(MSG *pMsg) PURE;
};



//===========================================================================
// IConnectionPointCB interface
#undef  INTERFACE
#define INTERFACE  IConnectionPointCB
DECLARE_INTERFACE_(IConnectionPointCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IConnectionPointCB Methods ***
    STDMETHOD(OnAdvise) (REFIID iid, DWORD cSinks, ULONG_PTR dwCookie) PURE;
    STDMETHOD(OnUnadvise) (REFIID iid, DWORD cSinks, ULONG_PTR dwCookie) PURE;

};

//===========================================================================
// IDelegateDropTargetCB interface
//
// This interface is used by CDelegateDropTarget implementation in shdocvw
// to generate an IDropTarget implementation that delegates to different
// IDropTarget implementations depending on the point currently over. The
// implementor of IDelegateDropTargetCB can handle feedback, scrolling,
// hit testing, and returning interfaces for ids returned from hit testing.
//
// GetWindows returns the hwnd to lock and the hwnd to scroll (not necesarily
//            the same window, as you often want to lock the parent of the window
//            you want to scroll)
//
// HitTest    should return an id of the object over as well as
//            uptate UI (highlights, etc). if ppt is NULL
//            that means remove any UI as the drag is terminating.
//            this should be able to handle hittesting on points not
//            even inside hwndScroll.
//
// GetObject  returns an interface for an id returned from HitTest
//
// OnDrop     gives the CB a chance to take action on the drop.
//            returning S_FALSE from this function prevents
//            CDelegateDropTarget from calling pdt->Drop(...).
//
#undef  INTERFACE
#define INTERFACE  IDelegateDropTargetCB
DECLARE_INTERFACE_(IDelegateDropTargetCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDelegateDropTargetCB Methods ***
    STDMETHOD(GetWindows) (THIS_ HWND * phwndLock, HWND * phwndScroll) PURE;
    STDMETHOD(HitTest) (THIS_ LPPOINT ppt, DWORD * pdwId) PURE;
    STDMETHOD(GetObject) (THIS_ DWORD dwId, REFIID riid, void **ppv) PURE;
    STDMETHOD(OnDrop) (THIS_ IDropTarget *pdt, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;

};


#ifdef __COMMCTRL_DA_DEFINED__ // we need HDPAs for this interface
//
// IOrderList - for ordering info in favorites/channels
//
// Typical usage is: GetOrderList, AllocOrderItem, insert into correct
// position, SetOrderList, and then FreeOrderList.
//
typedef struct
{
    LPITEMIDLIST    pidl;       // IDlist for this item
    int             nOrder;     // Ordinal indicating user preference
    DWORD           lParam;     // store custom order info.
} ORDERITEM, * PORDERITEM;

// Values for SortOrderList
#define OI_SORTBYNAME       0
#define OI_SORTBYORDINAL    1
#define OI_MERGEBYNAME      2

#undef  INTERFACE
#define INTERFACE  IOrderList
DECLARE_INTERFACE_(IOrderList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOrderList Methods ***
    STDMETHOD(GetOrderList)(THIS_ HDPA * phdpa) PURE;
    STDMETHOD(SetOrderList)(THIS_ HDPA hdpa, IShellFolder *psf) PURE;
    STDMETHOD(FreeOrderList)(THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList)(THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM * ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem)(THIS_ PORDERITEM poi) PURE;
};

#undef  INTERFACE
#define INTERFACE  IOrderList2
DECLARE_INTERFACE_(IOrderList2, IOrderList)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOrderList Methods ***
    STDMETHOD(GetOrderList)(THIS_ HDPA * phdpa) PURE;           // BUGBUG (lamadio): This assumes Favorites Menu
    STDMETHOD(SetOrderList)(THIS_ HDPA hdpa, IShellFolder *psf) PURE; // BUGBUG (lamadio): This assumes Favorites Menu
    STDMETHOD(FreeOrderList)(THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList)(THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM * ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem)(THIS_ PORDERITEM poi) PURE;

    // *** IOrderList2
    STDMETHOD(LoadFromStream)(THIS_ IStream* pstm, HDPA* phdpa, IShellFolder* psf) PURE;
    STDMETHOD(SaveToStream)(THIS_ IStream* pstm, HDPA hdpa) PURE;
};

#endif


//===========================================================================
// IShellHTMLWindowSupport private COmWindow interface. This should never be exposed.
#undef  INTERFACE
#define INTERFACE  IShellHTMLWindowSupport
DECLARE_INTERFACE_(IShellHTMLWindowSupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(ViewReleased)() PURE;
    STDMETHOD(ViewActivated)() PURE;
    STDMETHOD(ReadyStateChangedTo)( long, IShellView* ) PURE;
    STDMETHOD(CanNavigate)() PURE;

};



//===========================================================================
// IBandProxy private COmWindow interface. This should never be exposed.
#undef INTERFACE
#define INTERFACE IBandProxy
DECLARE_INTERFACE_(IBandProxy, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandProxy Methods ***
    STDMETHOD(SetSite) (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(CreateNewWindow) (THIS_ IUnknown** ppunk) PURE;
    STDMETHOD(GetBrowserWindow) (THIS_ IUnknown** ppunk) PURE;
    STDMETHOD(IsConnected) (THIS) PURE;
    STDMETHOD(NavigateToPIDL) (THIS_ LPCITEMIDLIST pidl) PURE;
    STDMETHOD(NavigateToURL) (THIS_ LPCWSTR wzUrl, VARIANT * Flags) PURE;
};



//===========================================================================
//
// Make it sure that we include ole2x.h and shlobj.h
//
#if defined(__IOleInPlaceSite_FWD_DEFINED__) && defined(FCIDM_SHVIEWFIRST)

#ifdef HLINK_H

#ifndef RC_INVOKED
#include <pshpack8.h>
#endif /* !RC_INVOKED */

typedef struct {
    HWND _hwnd;
    ITravelLog  *_ptl;
    IHlinkFrame *_phlf;
    IWebBrowser2    *_pautoWB2; // use this to reference _pauto's IWebBrowser2 functions
    IExpDispSupport *_pautoEDS; // use this to reference _pauto's IExpDispSupport functions
    IShellService   *_pautoSS;  // use this to reference _pauto's IShellService functions
    int _eSecureLockIcon;
    DWORD _fCreatingViewWindow :1;
    UINT _uActivateState;   // this is the state we should use when we go active..
                            // this is here so that derived classes can set us for UI or non-UI active

    // The following pidl is used in CBaseBrowser2::GetViewStateStream because
    // at that time, neither _pidlCur nor _pidlPending are initialized.
    LPCITEMIDLIST  _pidlNewShellView;

    IOleCommandTarget* _pctView;

    LPITEMIDLIST _pidlCur;
    IShellView *_psv;
    IShellFolder *_psf; // IShellFolder for _psv (used in CVOCBrowser)
    HWND        _hwndView;
    LPWSTR      _pszTitleCur;

    LPITEMIDLIST _pidlPending;
    IShellView *_psvPending;
    IShellFolder *_psfPending;
    HWND        _hwndViewPending;
    LPWSTR      _pszTitlePending;

    BOOL _fIsViewMSHTML;

} BASEBROWSERDATA, *LPBASEBROWSERDATA;
typedef const BASEBROWSERDATA *LPCBASEBROWSERDATA;

#ifndef RC_INVOKED
#include <poppack.h>
#endif /* !RC_INVOKED */

#else
// so (unref'ed) ifaces will compile (?)
typedef LPVOID BASEBROWSERDATA;
typedef LPCVOID *LPBASEBROWSERDATA;     // BUGBUG LPVOID?
typedef LPCVOID *LPCBASEBROWSERDATA;

#endif // hlink_h

typedef struct _travellog * PTRAVELLOG;

typedef enum
{
    BNS_NORMAL = 0,     // Normal state that we are in
    BNS_BEGIN_NAVIGATE, // A Begin navigate event has happened.
    BNS_NAVIGATE       // A Navigate event has happened...
} BNSTATE;             // The navigate state...


#undef  INTERFACE
#define INTERFACE   IBrowserService

DECLARE_INTERFACE_(IBrowserService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Warning!  Do not add any new methods to this interface
    // because IE4 shell32.dll uses it, so changing the interface
    // breaks IE4 interop.
};

#define BSF_REGISTERASDROPTARGET 0x00000001
#define BSF_THEATERMODE          0x00000002
#define BSF_NOLOCALFILEWARNING   0x00000010
#define BSF_UISETBYAUTOMATION    0x00000100
#define BSF_RESIZABLE            0x00000200

#ifndef RC_INVOKED
#include <pshpack8.h>
#endif /* !RC_INVOKED */

typedef struct SToolbarItem {
    IDockingWindow * ptbar;
    BORDERWIDTHS    rcBorderTool;
    LPWSTR          pwszItem;
    BOOL            fShow;
    HMONITOR        hMon;
} TOOLBARITEM, *LPTOOLBARITEM;
#define ITB_VIEW        ((UINT)-1)      // view

#ifndef RC_INVOKED
#include <poppack.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

struct tagFolderSetData;

// TEMPORARY.  this is so that we don't have to keep writing dummy subs in basesb as we're
// building basesb2
DECLARE_INTERFACE_(IBrowserService2, IBrowserService)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    // TODO: break into 3 sections (outer, inner, and both/inherit)
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Stuff added for shbrowse->shbrows2 split
    // These remove "friend" functions and classes
    //
    STDMETHOD_(LRESULT, WndProcBS)(THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    STDMETHOD (SetAsDefFolderSettings)(THIS) PURE;
    STDMETHOD (GetViewRect)(THIS_ RECT * prc) PURE;

    STDMETHOD (OnSize)(THIS_ WPARAM wParam) PURE;
    STDMETHOD (OnCreate)(THIS_ LPCREATESTRUCT pcs) PURE;
    STDMETHOD_(LRESULT, OnCommand)(THIS_ WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (OnDestroy)(THIS ) PURE;
    STDMETHOD_(LRESULT, OnNotify)(THIS_ NMHDR * pnm) PURE;
    STDMETHOD (OnSetFocus)(THIS ) PURE;
    STDMETHOD (OnFrameWindowActivateBS)(THIS_ BOOL fActive) PURE;

    STDMETHOD (ReleaseShellView)(THIS ) PURE;
    STDMETHOD (ActivatePendingView)(THIS ) PURE;
    STDMETHOD (CreateViewWindow)(THIS_ IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd) PURE;
    STDMETHOD (CreateBrowserPropSheetExt)(THIS_ REFIID riid, void **ppv) PURE;

    // these could be base browser only interfaces
    // they are not overridden by anyone, and perhaps only there for the aggregators to get info from the
    // aggregatee. NOTE: where basesb calls these,
    // it does NOT go through _pbsOuter
    STDMETHOD (GetViewWindow)(THIS_ HWND * phwndView) PURE;
    STDMETHOD (GetBaseBrowserData)(THIS_ LPCBASEBROWSERDATA * pbbd) PURE;
    STDMETHOD_(LPBASEBROWSERDATA, PutBaseBrowserData)(THIS) PURE;
    STDMETHOD (InitializeTravelLog)(THIS_ ITravelLog* ptl, DWORD dw) PURE;
    STDMETHOD (SetTopBrowser)(THIS) PURE;
    STDMETHOD (Offline)(THIS_ int iCmd) PURE;
    STDMETHOD (AllowViewResize)(THIS_ BOOL f) PURE;
    STDMETHOD (SetActivateState)(THIS_ UINT u) PURE;
    STDMETHOD (UpdateSecureLockIcon)(THIS_ int eSecureLock) PURE;
    STDMETHOD (InitializeDownloadManager)(THIS) PURE;
    STDMETHOD (InitializeTransitionSite)(THIS) PURE;
    STDMETHOD (_Initialize)(THIS_ HWND hwnd, IUnknown *pauto) PURE;


    // BEGIN REVIEW:  review names and need of each.
    //
    // this first set could be basebrowser only members.  no one overrides
    // NOTE: where basesb calls these, it does NOT go throug _pbsOuter
    STDMETHOD (_CancelPendingNavigationAsync)(THIS) PURE;
    STDMETHOD (_CancelPendingView)(THIS) PURE;
    STDMETHOD (_MaySaveChanges)(THIS) PURE;
    STDMETHOD (_PauseOrResumeView)(THIS_ BOOL fPaused) PURE;
    STDMETHOD (_DisableModeless)(THIS) PURE;

    // rethink these... are all of these necessary?
    STDMETHOD (_NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags)PURE;
    STDMETHOD (_TryShell2Rename)(THIS_ IShellView* psv, LPCITEMIDLIST pidlNew)PURE;
    STDMETHOD (_SwitchActivationNow)(THIS )PURE;

    // this set is overridden and called thru _pbsOuter (and SUPER:_pbsInner)
    STDMETHOD (_ExecChildren)(IUnknown *punkBar, BOOL fBroadcast,
                              const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                              VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)PURE;
    STDMETHOD (_SendChildren)(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    //END REVIEW:

    // querying from the outer.
    STDMETHOD (GetFolderSetData)(THIS_ struct tagFolderSetData* pfsd) PURE;

    // Toolbar stuff is here temporarily. Eventually it will move out
    // of basesb into commonsb, so I'm keeping the underscore "_"
    // Except those noted below, none of these are overridden by
    // outer guys, so no calls are made through _pbsOuter
    STDMETHOD (_OnFocusChange)(UINT itb) PURE;
    STDMETHOD (v_ShowHideChildWindows)(BOOL fChildOnly) PURE; // NOTE: overridden and called thru _pbsOuter
    STDMETHOD_(UINT,_get_itbLastFocus)() PURE;
    STDMETHOD (_put_itbLastFocus)(UINT itbLastFocus) PURE;
    STDMETHOD (_UIActivateView)(UINT uState) PURE;

    // Check the following functions
    STDMETHOD (_GetViewBorderRect)(RECT* prc) PURE;
    STDMETHOD (_UpdateViewRectSize)() PURE;
    STDMETHOD (_ResizeNextBorder)(UINT itb) PURE;
    STDMETHOD (_ResizeView)() PURE;

    STDMETHOD (_GetEffectiveClientArea)(LPRECT lprectBorder, HMONITOR hmon) PURE;

    // Desktop needs to override this from commonsb
    STDMETHOD_(IStream*,v_GetViewStream)(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName) PURE;

    // Desktop needs access to these commonsb functions, they are not overridden:
    STDMETHOD_(LRESULT,ForwardViewMsg)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (SetAcceleratorMenu)(THIS_ HACCEL hacc) PURE;
    STDMETHOD_(int,_GetToolbarCount)(THIS) PURE;
    STDMETHOD_(LPTOOLBARITEM,_GetToolbarItem)(THIS_ int itb) PURE;
    STDMETHOD (_SaveToolbars)(IStream* pstm) PURE;
    STDMETHOD (_LoadToolbars)(IStream* pstm) PURE;
    STDMETHOD (_CloseAndReleaseToolbars)(BOOL fClose) PURE;
    STDMETHOD (v_MayGetNextToolbarFocus)(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd) PURE;
    STDMETHOD (_ResizeNextBorderHelper)(UINT itb, BOOL bUseHmonitor) PURE;
    STDMETHOD_(UINT,_FindTBar)(IUnknown* punkSrc) PURE;
    STDMETHOD (_SetFocus)(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) PURE;
    STDMETHOD (v_MayTranslateAccelerator)(MSG* pmsg) PURE;
    STDMETHOD (_GetBorderDWHelper)(IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) PURE;

    // Shell browser needs to override this from basesb.

    STDMETHOD (v_CheckZoneCrossing)(LPCITEMIDLIST pidl) PURE;
};

// these MUST be listed in  the same order a c_szPropNames in deskbar.cpp
typedef enum {
    PROPDATA_SIDE = 0,
    PROPDATA_MODE,
    PROPDATA_LEFT,
    PROPDATA_TOP,
    PROPDATA_RIGHT,
    PROPDATA_BOTTOM,
    PROPDATA_DELETEABLE,
    PROPDATA_X,
    PROPDATA_Y,
    PROPDATA_CX,
    PROPDATA_CY,

    PROPDATA_COUNT
} ENUMPROPDATA ;

// PROPDATA_MODE values:
//  (aka. WBM_* -- webbar modes (_eMode))
#define WBM_BOTTOMMOST  ((UINT) 0x0)      // bottommost
#define WBM_TOPMOST     ((UINT) 0x1)      // topmost
#define WBM_FLOATING    ((UINT) 0x2)      // floating
#define WBM_NIL         ((UINT) 0x7)      // nil

#undef  INTERFACE
#define INTERFACE  IDockingBarPropertyBagInit
DECLARE_INTERFACE_(IDockingBarPropertyBagInit, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDockingBarPropertyBag ***
    STDMETHOD(SetDataDWORD)(THIS_ ENUMPROPDATA e, DWORD dwData) PURE;
} ;

#if (_WIN32_IE) >= 0x0400
//===========================================================================
// IAddressList private COmWindow interface. This should never be exposed.
#undef INTERFACE
#define INTERFACE IAddressList
DECLARE_INTERFACE_(IAddressList, IWinEventHandler)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWinEventHandler Methods ***
    STDMETHOD(OnWinEvent) (THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres) PURE;
    STDMETHOD(IsWindowOwner) (THIS_ HWND hwnd) PURE;

    // *** IAddressList Methods ***
    STDMETHOD(Connect) (THIS_ BOOL fConnect, HWND hwnd, IBrowserService* pbs, IBandProxy* pbp, IAutoComplete * pac) PURE;
    STDMETHOD(NavigationComplete) (THIS_ void *pvCShellUrl) PURE;
    STDMETHOD(Refresh) (THIS_ DWORD dwType) PURE;
    STDMETHOD(Load) (THIS) PURE;
    STDMETHOD(Save) (THIS) PURE;
    STDMETHOD(SetToListIndex) (THIS_ int nIndex, void *pvShelLUrl) PURE;
    STDMETHOD(FileSysChangeAL) (THIS_ DWORD dw, LPCITEMIDLIST *ppidl) PURE;
};
#endif


//
// IDocViewSite
//
#undef  INTERFACE
#define INTERFACE  IDocViewSite
DECLARE_INTERFACE_(IDocViewSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocViewSite methods ***
    STDMETHOD(OnSetTitle) (THIS_ VARIANTARG *pvTitle) PURE;

} ;

#endif

//===========================================================================
// INSCTree: This is a private interface
// CreateTree() dwStyles - these are normal window styles.
// Initialize() grfFlags - these are SHCONTF_* flags defined in <shlobj.h>.
//              dwFlags - these are NSCTree Behavior flags defined below
//                   NSS_DROPTARGET - Enable drag and drop
//                   NSS_BROWSERSELECT - With this on, a selection is different than the standard
//                      tree view selection in that a box is drawn around the sub heirarchy selected
//                      and the buttons are turned off.
// SetNscMode() nMode - these are modes that inherit general behavior.  Defined below

// NSCTree Behavior flags: (INSCTree::Initialize(..., dwFlags))
#define NSS_DROPTARGET          0x0001      // register as a drop target
#define NSS_BROWSERSELECT       0x0002      // Use the browser style selection (see above)
#define NSS_NOHISTSELECT        0x0004      // Do not select the history entry on navigations.

// NSCTree Modes: (INSCTree::SetNscMode(nMode))
typedef enum
{
    MODE_NORMAL           = 0x0000,             // Act like a normal tree view
    MODE_CONTROL          = 0x0001,             // Have behaviors specific the being hosted in a control
    MODE_HISTORY          = 0x0002,             // Have behaviors specific to the History pane.
    MODE_FAVORITES        = 0x0004,             // Have behaviors specific to the Favorites pane.
} nscTreeMode;


#undef INTERFACE
#define INTERFACE INSCTree
DECLARE_INTERFACE_(INSCTree, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** INSCTree Methods ***
    STDMETHOD(CreateTree) (THIS_ HWND hwndParent, DWORD dwStyles, HWND *phwnd) PURE;
    STDMETHOD(Initialize) (THIS_ LPCITEMIDLIST pidlRoot, DWORD grfFlags, DWORD dwFlags) PURE;
    STDMETHOD(ShowWindow) (THIS_ BOOL fShow) PURE;
    STDMETHOD(Refresh) (THIS) PURE;
    STDMETHOD(GetSelectedItem) (THIS_ LPITEMIDLIST * ppidl, int nItem) PURE;
    STDMETHOD(SetSelectedItem) (THIS_ LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert, int nItem) PURE;
    STDMETHOD(GetNscMode) (THIS_ UINT * pnMode) PURE;
    STDMETHOD(SetNscMode) (THIS_ UINT nMode) PURE;
    STDMETHOD(GetSelectedItemName) (THIS_ LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(BindToSelectedItemParent) (THIS_ REFIID riid, void **ppv, LPITEMIDLIST *ppidl) PURE;
    STDMETHOD_(BOOL, InLabelEdit) (THIS) PURE;
};


//===========================================================================
// IDwnCodePage: This is a private interface to pass codepage info.
#undef INTERFACE
#define INTERFACE IDwnCodePage

DECLARE_INTERFACE_(IDwnCodePage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDwnCodePage Methods ***
    STDMETHOD_(UINT,GetCodePage) (THIS) PURE;
    STDMETHOD(SetCodePage) (THIS_ UINT uiCP) PURE;
};

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
SHSTDAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
SHSTDAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)  SHFree(pidl)

SHSTDAPI SHDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);

//===========================================================================

//----------------------------------------------------------------------------
#define IsLFNDriveORD           119
SHSTDAPI_(int) SHOutOfMemoryMessageBox(HWND hwndOwner, LPTSTR pszTitle, UINT fuStyle);
SHSTDAPI_(BOOL) SHWinHelp(HWND hwndMain, LPCTSTR pszHelp, UINT usCommand, ULONG_PTR ulData);

SHSTDAPI_(BOOL) RLBuildListOfPaths(void);

#ifdef WINNT
SHSTDAPI_(BOOL) RegenerateUserEnvironment(void **pPrevEnv, BOOL bSetCurrentEnv);
#endif

#define SHValidateUNCORD        173

#define VALIDATEUNC_NOUI        0x0002          // don't bring up stinking UI!
#define VALIDATEUNC_CONNECT     0x0001          // connect a drive letter
#define VALIDATEUNC_PRINT       0x0004          // validate as print share instead of disk share
#define VALIDATEUNC_VALID       0x0007          // valid flags


SHSTDAPI_(BOOL) SHValidateUNC(HWND hwndOwner, LPTSTR pszFile, UINT fConnect);

//----------------------------------------------------------------------------
#define OleStrToStrNORD                         78
#define SHCloneSpecialIDListORD                 89
#define SHDllGetClassObjectORD                 128
#define SHLogILFromFSILORD                      95
#define SHMapPIDLToSystemImageListIndexORD      77
#define SHShellFolderView_MessageORD            73
#define Shell_GetImageListsORD                  71
#define SHGetSpecialFolderPathORD              175
#define StrToOleStrNORD                         79

#define ILCloneORD                              18
#define ILCloneFirstORD                         19
#define ILCombineORD                            25
#define ILCreateFromPathORD                     157
#define ILFindChildORD                          24
#define ILFreeORD                               155
#define ILGetNextORD                            153
#define ILGetSizeORD                            152
#define ILIsEqualORD                            21
#define ILRemoveLastIDORD                       17
#define PathAddBackslashORD                     32
#define PathCombineORD                          37
#define PathIsExeORD                            43
#define PathMatchSpecORD                        46
#define SHGetSetSettingsORD                     68
#define SHILCreateFromPathORD                   28

#define SHFreeORD                               195

#define CheckWinIniForAssocsORD                 711

SHSTDAPI_(HANDLE) PifMgr_OpenProperties(LPCTSTR pszApp, LPCTSTR pszPIF, UINT hInf, UINT flOpt);
SHSTDAPI_(int)    PifMgr_GetProperties(HANDLE hProps, LPCSTR pszGroup, void *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(int)    PifMgr_SetProperties(HANDLE hProps, LPCSTR pszGroup, const VOID *lpProps, int cbProps, UINT flOpt);
SHSTDAPI_(HANDLE) PifMgr_CloseProperties(HANDLE hProps, UINT flOpt);

SHSTDAPI_(void) SHSetInstanceExplorer(IUnknown *punk);

#ifndef WINNT
// Always usr TerminateThreadEx.
BOOL APIENTRY TerminateThreadEx(HANDLE hThread, DWORD dwExitCode, BOOL bCleanupFlag);
#define TerminateThread(hThread, dwExitCode) TerminateThreadEx(hThread, dwExitCode, TRUE)
#endif

SHSTDAPI_(BOOL) IsUserAnAdmin(void);

// Sortof Gross but if we pass this flag in with STGM_CREATE we will fail if file already exists
// with ERROR_ALREADY_EXISTS
#define CSOF_FAILIFTHERE         0x80000000L


//===========================================================================
// Structure for covert communication
// between shdocvw's CShellBrowser::Exec()
// and shell32's DefView WM_COMMAND handler
struct _DFVCMDDATA
{
    HWND        hwnd;               // Browser hwnd
    VARIANTARG  *pva;               // Args passed to Exec()
    DWORD       nCmdIDTranslated;   // Replacement OLECMDID_* value
};
typedef struct _DFVCMDDATA DFVCMDDATA;
typedef struct _DFVCMDDATA *LPDFVCMDDATA;
typedef const struct _DFVCMDDATA *LPCDFVCMDDATA;


SHSTDAPI_(DWORD) SHGetProcessDword(DWORD idProcess, LONG iIndex);
SHSTDAPI_(BOOL)  SHSetShellWindowEx(HWND hwnd, HWND hwndChild);

#define CCH_MENUMAX     80          // DOC: max size of a menu string


// WinEventHandler message ranges
#define MBHM_FIRST          (0x00000001)    // MenuBandHandler
#define MBHM_LAST           (0x000000ff)

#define MSFM_FIRST          (0x00000100)    // MenuShellFolder
#define MSFM_LAST           (0x000001ff)

#define FSFM_FIRST          (0x00000200)    // FileShellFolder
#define FSFM_LAST           (0x000002ff)



//-------------------------------------------------------------------------
//
// SID_SMenuBandHandler
//
//  The menuband calls QueryService(SID_SMenuBandHandler, IID_IWinEventHandler)
//  on its shellfolder.  If the shellfolder supports this service, the
//  menuband will call the event handler on certain menu events.  These
//  events and messages are as follows:
//
//    MBHM_INITMENUPOPUP    sent when a drop-down menu or submenu is
//                          about to become active.
//
//
//   File-system ShellFolder events:
//
//    FSFM_COMMAND          sent when a file-system item is executed
//
//-------------------------------------------------------------------------

typedef struct tagMBINITMENUPOPUP
{
    DWORD           dwMask;     // MBIMP_*
    IShellFolder *  psf;
    LPCITEMIDLIST   pidl;
    HMENU           hmenu;
    int             iPos;
} MBINITMENUPOPUP;

#define MBIMP_HMENU     0x00000001      // hmenu and iPos are set


// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ---
#define MBHM_INITMENUPOPUP  (MBHM_FIRST+0)  //  0           MBINITMENUPOPUP *


// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ------
#define FSFM_COMMAND        (FSFM_FIRST+0)  //  cmd ID      pidl


//-------------------------------------------------------------------------
//
// IAugmentedShellFolder interface
//
//   This provides methods to add multiple Shell Folder objects to a
//  single augmented object (CLSID_AugmentedShellFolder), which will
//  enumerate them as if they were in a single namespace.
//
//
// [Member functions]
//
// IAugmentedShellFolder::AddNameSpace(rguidObject, psf, pidl)
//   Add the object represented by the IShellFolder interface to
//   the augmented list.  The rguidObject is used to identify the
//   given object.  It may be NULL.  The optional pidl refers to
//   the location of the psf.
//
// IAugmentedShellFolder::GetNameSpaceID(pidl, rguidOut)
//   This method returns the rguidObject associated with the given
//   pidl.  This is how a caller can identify which namespace the
//   pidl resides, given the list of IShellFolder objects that were
//   added to this augmented object.
//
// IAugmentedShellFolder::QueryNameSpace(dwNameSpaceID, pguidOut, ppsf)
//   Returns the shellfolder and guid associated with the given ID.
//
// IAugmentedShellFolder::EnumNameSpace(uNameSpace, pdwNameSpaceID)
//   Enumerates the namespace shellfolders.  If uNameSpace is -1,
//   pdwNameSpaceID is ignored and this method returns the count of
//   shellfolders in the augmented namespace.  Call this method with
//   uNameSpace starting at 0 to begin enumerating.  Returns S_OK and
//   and namespace ID in *pdwNameSpaceID.
//
//-------------------------------------------------------------------------

//  IAugmentedShellFolder::AddNameSpace flags
enum
{
    ASFF_DEFAULT                   = 0x00000000, // There are no applicable Flags
    ASFF_SORTDOWN                  = 0x00000001, // Sort the items in this ISF to the bottom.
    ASFF_MERGE                     = 0x00000002, // Merge the 2 namespaces
    // the following should all be collapsed to one ASFF_DEFNAMESPACE
    ASFF_DEFNAMESPACE_BINDSTG      = 0x00000100, // The namespace is the default handler for BindToStorage() for merged child items.
    ASFF_DEFNAMESPACE_COMPARE      = 0x00000200, // The namespace is the default handler for CompareIDs() for merged child items.
    ASFF_DEFNAMESPACE_VIEWOBJ      = 0x00000400, // The namespace is the default handler for CreateViewObject() for merged child items.
    ASFF_DEFNAMESPACE_ATTRIB       = 0x00001800, // The namespace is the default handler for GetAttributesOf() for merged child items.
    ASFF_DEFNAMESPACE_DISPLAYNAME  = 0x00001000, // The namespace is the default handler for GetDisplayNameOf(), SetNameOf() and ParseDisplayName() for merged child items.
    ASFF_DEFNAMESPACE_UIOBJ        = 0x00002000, // The namespace is the default handler for GetUIObjectOf() for merged child items.
    ASFF_DEFNAMESPACE_ITEMDATA     = 0x00004000, // The namespace is the default handler for GetItemData() for merged child items.
    ASFF_DEFNAMESPACE_ALL          = 0x0000FF00  // The namespace is the primary handler for all IShellFolder operations on merged child items.
};

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder

DECLARE_INTERFACE_(IAugmentedShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner,LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;
};

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder2

DECLARE_INTERFACE_(IAugmentedShellFolder2, IAugmentedShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;

    // *** IAugmentedShellFolder2 methods ***
    //where are these used?
    //STDMETHOD(GetNameSpaceCount)  (THIS_ OUT LONG * pcNamespaces) PURE ;
    //STDMETHOD(GetIDListWrapCount) (THIS_ LPCITEMIDLIST pidlWrap, OUT LONG * pcPidls) PURE ;
    STDMETHOD(UnWrapIDList)       (THIS_ LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder ** apsf, LPITEMIDLIST * apidlFolder, LPITEMIDLIST * apidlItems, LONG * pcFetched ) PURE ;
};


//-------------------------------------------------------------------------
//
// IProxyShellFolder interface
//
//   This provides methods to set a proxy object which can respond
//  to GetUIObjectOf instead of or in addition to the hosted object
//  the supports IShellFolder.  All other methods are forwarded onto
//  the hosted object.  The CLSID_HostProxyShellFolder object implements
//  this interface.
//
//   The Win95 shell does not support aggregation, so this object
//  must be extra careful that it follows the rules of COM.
//
//   This interface is implemented by an object that wishes to provide
//  more support for GetUIObjectOf on behalf of another object that
//  implements an original IShellFolder.
//
// [Member functions]
//
// IProxyShellFolder::InitHostProxy(psf, pidl, punk, dwFlags)
//   Set the object that implements IProxyShellFolder.  Depending
//   on dwFlags, this object will be called instead of or in addition
//   to the host's method.
//
//      SPF_PRIORITY            - call the proxy's method instead of
//                              the host's method.
//      SPF_SECONDARY           - call the proxy's method only if the
//                              host's method doesn't support it.
//      SPF_INHERIT             - create a new object of this class and
//                              hand it back for BindToObject.
//      SPF_FOLDERPRECEDENCE    - have the proxy give folders priority
//                              over files in a call to CompareIDs.
//      SPF_HAVECALLBACK        - have the proxy call the owner's
//                              IOleCommandTarget on each enumerated
//                              object, for filtering.
//
//   Also sets as the host the given object which fully implements
//   IShellFolder.  pidl refers to the shell folder.
//
// IProxyShellFolder::CloneProxyPSF(riid, ppv)
//   Tells the object to clone itself.  The host proxy will call this
//   whenever IShellFolder::BindToObject is called.
//
// IProxyShellFolder::GetUIObjectOfPSF(hwndOwner, cidl, apidl, riid, prgfInOut, ppv)
//   Called by CLSID_HostProxyShellFolder to allow the proxy object
//   an opportunity to respond.
//
// IProxyShellFolder::CreateViewObjectPSF(hwndOwner, riid, ppv)
//   Called by CLSID_HostProxyShellFolder to allow the proxy object
//   an opportunity to respond.
//
//-------------------------------------------------------------------------

// SetProxyObject flags
#define SPF_PRIORITY            0x00000001       // This is mutually exclusive w/ SPF_SECONDARY
#define SPF_SECONDARY           0x00000002
#define SPF_INHERIT             0x00000004
#define SPF_FOLDERPRECEDENCE    0x00000008
#define SPF_HAVECALLBACK        0x00000010

//For filtering of Pidls
#define PHID_FilterOutPidl  0


#undef  INTERFACE
#define INTERFACE   IProxyShellFolder

DECLARE_INTERFACE_(IProxyShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IProxyShellFolder methods ***
    STDMETHOD(InitHostProxy)     (THIS_ IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(CloneProxyPSF)     (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD(GetUIObjectOfPSF) (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(CreateViewObjectPSF) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;

};


//-------------------------------------------------------------------------
//
// BUGBUG (scotth): I don't think we're using this anymore.
//
// ISetWinHandler interface
//
// [Member functions]
//
// ISetWinHandler::SetWindow(hwndOwner)
//   Specifies the window owner.  This may be NULL.
//
// ISetWinHandler::SetWinHandler(punk)
//   Gives a pointer to an object which supports IWinEventHandler.  The
//   hwnd will be the window handle set by the SetWindow method.  The
//   handler should return S_OK if the message is handled, otherwise S_FALSE.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   ISetWinHandler

DECLARE_INTERFACE_(ISetWinHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** ISetWinHandler methods ***
    STDMETHOD(SetWindow)        (THIS_ HWND hwndOwner) PURE;
    STDMETHOD(SetWinHandler)    (THIS_ IUnknown * punk) PURE;
};


//-------------------------------------------------------------------------
//
// IMenuShellFolder interface
//
//   This wraps a static HMENU with an IShellFolder interface.
//
//
// [Member functions]
//
// IMenuShellFolder::SetMenu(hmenu)
//   Specifies the hmenu to wrap.  This may be NULL.
//
//   BUGBUG (scotth): does this copy or not?
//
// IMenuShellFolder::GetMenu(phmenu)
//   Returns the current menu in *phmenu.  Returns S_FALSE if no menu is
//   set (*phmenu will be NULL).
//
// IMenuShellFolder::SetWindow(hwndOwner)
//   Specifies the window owner.  This may be NULL.
//
//-------------------------------------------------------------------------

// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ---
#define MSFM_COMMAND        (MSFM_FIRST+0)  //  cmd ID      0
#define MSFM_ISDROPTARGET   (MSFM_FIRST+1)  //  id          0           1 if yes


#undef  INTERFACE
#define INTERFACE   IMenuShellFolder

DECLARE_INTERFACE_(IMenuShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IMenuShellFolder methods ***
    STDMETHOD(SetMenu)          (THIS_ HMENU hmenu) PURE;
    STDMETHOD(GetMenu)          (THIS_ HMENU * phmenu) PURE;
    STDMETHOD(SetWindow)        (THIS_ HWND hwndOwner) PURE;
    STDMETHOD(GetWindow)        (THIS_ HWND *phwndOwner) PURE;
    STDMETHOD(GetIDPosition)    (THIS_ LPCITEMIDLIST pidl, int * pnPos) PURE;
};


//-------------------------------------------------------------------------
//
// ITranslateShellChangeNotify interface
//
//   This interface allows an object to translate the pidls that are
// passed to it.
//
// Note:  IE4 had an interface of the same name but with a different IID,
//        so there is no conflict.
//
// [Member functions]
//
// ITranslateShellChangeNotify::TranslateIDs(&lEvent, pidl1, pidl2, ppidlOut1, ppidlOut2)
//   Return converted pidls given the event. it also can change the event if appropriate
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   ITranslateShellChangeNotify

DECLARE_INTERFACE_(ITranslateShellChangeNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** ITranslateShellChangeNotify methods ***
    STDMETHOD(TranslateIDs) (THIS_ LONG *plEvent , LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                   LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2) PURE;
    STDMETHOD(IsChildID)(THIS_ LPCITEMIDLIST pidlKid, BOOL fImmediate) PURE;
    STDMETHOD(IsEqualID)(THIS_ LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(Register)(THIS_ HWND hwnd, UINT uMsg, long lEvents) PURE;
    STDMETHOD(Unregister)(THIS) PURE;
};

////////////////////////////////////////////////////
//
// IRegTreeOptions
//
typedef enum tagBUTTON_STATES
{
    IDCHECKED,
    IDUNCHECKED,
    IDRADIOON,
    IDRADIOOFF,
    IDUNKNOWN
} BUTTON_STATES;

//
// Avoid conflicts in the windows\shell project
//
#ifndef NO_SHELL_TREE_TYPE
typedef enum tagTREE_TYPE
{
    TREE_CHECKBOX,
    TREE_RADIO,
    TREE_GROUP,
    TREE_UNKNOWN
} TREE_TYPE;
#endif // NO_SHELL_TREE_TYPE

typedef enum tagWALK_TREE_CMD
{
    WALK_TREE_SAVE,
    WALK_TREE_DELETE,
    WALK_TREE_RESTORE,
    WALK_TREE_REFRESH
} WALK_TREE_CMD;


enum REG_CMD
{
    REG_SET,
    REG_GET,
    REG_GETDEFAULT
};

#undef  INTERFACE
#define INTERFACE   IRegTreeOptions

DECLARE_INTERFACE_(IRegTreeOptions, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRegTreeOptions specific methods ***
    STDMETHOD(InitTree)(THIS_ HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam) PURE;
    STDMETHOD(WalkTree)(THIS_ WALK_TREE_CMD cmd ) PURE;
    STDMETHOD(ToggleItem)(THIS_ HTREEITEM hti ) PURE;
    STDMETHOD(ShowHelp)(THIS_ HTREEITEM hti , DWORD dwFlags ) PURE;
};



//
// Interface: IShellHotKey
//

#undef  INTERFACE
#define INTERFACE   IShellHotKey

DECLARE_INTERFACE_(IShellHotKey, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellHotKey methods ***
    STDMETHOD(RegisterHotKey)(THIS_ IShellFolder * psf, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl) PURE;
};


//
// Interface: ITrayPriv
//
// Purpose: Talks to the new Start Menu code in Shdocvw from explorer.exe
//
// For flags on ShowFolder see inc\IETHREAD.H
//

#undef  INTERFACE
#define INTERFACE   ITrayPriv

DECLARE_INTERFACE_(ITrayPriv, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** ITrayPriv methods ***
    STDMETHOD(ExecItem)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(GetFindCM)(THIS_ HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu** ppcmFind) PURE;
    STDMETHOD(GetStaticStartMenu)(THIS_ HMENU* phmenu) PURE;
};


#undef  INTERFACE
#define INTERFACE   IInitializeObject

DECLARE_INTERFACE_(IInitializeObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IInitializeObject methods
    STDMETHOD(Initialize)(THIS) PURE;
};

enum
{
    BMICON_LARGE = 0,
    BMICON_SMALL
};

#undef  INTERFACE
#define INTERFACE   IBanneredBar

DECLARE_INTERFACE_(IBanneredBar, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBanneredBar methods ***
    STDMETHOD(SetIconSize)(THIS_ DWORD iIcon) PURE;
    STDMETHOD(GetIconSize)(THIS_ DWORD* piIcon) PURE;
    STDMETHOD(SetBitmap)(THIS_ HBITMAP hBitmap) PURE;
    STDMETHOD(GetBitmap)(THIS_ HBITMAP* phBitmap) PURE;

};

//
// Interface: IFolderShortcutConvert
//
// Purpose: Converts between FolderShortcuts and links
//

#undef  INTERFACE
#define INTERFACE   IFolderShortcutConvert

DECLARE_INTERFACE_(IFolderShortcutConvert, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //*** IFolderShortcutConvert methods ***
    STDMETHOD(ConvertToLink)(THIS_ LPCOLESTR pszFSPath, DWORD fFlags) PURE;
    STDMETHOD(ConvertToFolderShortcut)(THIS_ LPCOLESTR pszLinkPath, DWORD fFlags) PURE;
};

//
// Interface: IShellFolderTask
//
// Purpose: Initializes a task that does something by enumerating a shellfolder
//

#undef  INTERFACE
#define INTERFACE   IShellFolderTask

DECLARE_INTERFACE_(IShellFolderTask, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IShellFolderTask methods ***
    STDMETHOD(InitTaskSFT)(THIS_ IShellFolder *psfParent, LPITEMIDLIST pidlFull,
                           LONG nMaxRecursionLevel, DWORD dwFlags, DWORD dwTaskPriority) PURE;
};

// Flags for InitTaskSFT
#define ITSFT_RECURSE   0x00000001      // recurse into subfolders


//
// Interface: IStartMenuTask
//
// Purpose: Initializes a task that does something for the start menu
//

#undef  INTERFACE
#define INTERFACE   IStartMenuTask

DECLARE_INTERFACE_(IStartMenuTask, IShellFolderTask)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IShellFolderTask methods ***
    STDMETHOD(InitTaskSFT)(THIS_ IShellFolder *psfParent, LPITEMIDLIST pidlFull,
                           LONG nMaxRecursionLevel, DWORD dwFlags, DWORD dwTaskPriority) PURE;

    // *** IStartMenuTask methods ***
    STDMETHOD(InitTaskSMT)(THIS_ IShellHotKey * photkey, int iThreadPriority) PURE;
};

//
// Interface: IContextMenuCB
//
// Purpose: A call defview context menu callback object
//

#undef  INTERFACE
#define INTERFACE   IContextMenuCB

DECLARE_INTERFACE_(IContextMenuCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IContextMenuCB methods ***
    STDMETHOD(CallBack) (THIS_  IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg,
                                WPARAM wParam, LPARAM lParam) PURE;
};

// let the context menu handler call up to it's site to let the site implement certain functions
// BUGBUG: may need to add QueryRename(), QueryCut(), etc.

DECLARE_INTERFACE_(IContextMenuSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IContextMenuSite methods ***
    STDMETHOD(DoRename)() PURE;
    STDMETHOD(DoCut)() PURE;
};

#define SID_SContextMenuSite IID_IContextMenuSite

//
// Possible underline settings for shell icons.
//
enum
{
    ICON_YES,
    ICON_NO,
    ICON_HOVER,
    ICON_IE         // Use IE hyperlink settings
};

//-----------------------------------------------
// IOleCommand Target Command IDs

// CGID_BandHandler
    //  Get the order stream from parent.
#define BHCMDID_GetOrderStream      0x00000001

// CGID_Persist
    // Set the storage key.
#define MCBID_SetKey                0x00000001

// CGID_MenuBandItem
#define MBICMDID_IsVisible          0x00000001

// CGID_MenuBand
#define MBANDCID_REFRESH            0x10000000


//
// Interface: IShellMallocSpy
//
// Purpose: Facilitate IMallocSpy in the shell
//

#undef  INTERFACE
#define INTERFACE  IShellMallocSpy
DECLARE_INTERFACE_(IShellMallocSpy, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMallocSpy methods ***
    STDMETHOD(RegisterSpy) (THIS) PURE;
    STDMETHOD(RevokeSpy) (THIS) PURE;
    STDMETHOD(SetTracking) (THIS_ BOOL bTrack) PURE;
    STDMETHOD(AddToList) (THIS_ void *pv, SIZE_T cb) PURE;
    STDMETHOD(RemoveFromList) (THIS_ void *pv) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchProvider

DECLARE_INTERFACE_(ISearchProvider, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchObject methods ***
    STDMETHOD(GetSearchGUID)(THIS_ LPGUID lpGuid) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchItems

DECLARE_INTERFACE_(ISearchItems, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchItems methods ***
    //used by CSearchBand
    STDMETHOD(GetDefaultSearchUrl) (THIS_ LPWSTR pwzUrl, UINT cch) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchBandTBHelper

DECLARE_INTERFACE_(ISearchBandTBHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchBandTBHelper methods ***
    // implemented by CSearchBand
    STDMETHOD(AddNextMenuItem) (THIS_ LPCWSTR pwszText, int idItem) PURE;
    STDMETHOD(SetOCCallback) (THIS_ IOleCommandTarget *pOleCmdTarget) PURE;
    STDMETHOD(ResetNextMenu) (THIS) PURE;
};

#undef  INTERFACE
#define INTERFACE   IEnumUrlSearch

typedef struct
{
    GUID  guid;
    WCHAR wszName[80];
    WCHAR wszUrl[2048];
}URLSEARCH, *LPURLSEARCH;

DECLARE_INTERFACE_(IEnumUrlSearch, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUrlSearch methods ***
    STDMETHOD(Next)(THIS_ ULONG celt, LPURLSEARCH rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ IEnumUrlSearch **ppenum) PURE;
};

#undef  INTERFACE
#define INTERFACE   IFolderSearches

DECLARE_INTERFACE_(IFolderSearches, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFolderSearches methods ***
    STDMETHOD(EnumSearches) (THIS_ IEnumUrlSearch **ppenum) PURE;
    STDMETHOD(DefaultSearch) (THIS_ GUID *pguid) PURE;
};
#undef  INTERFACE
#define INTERFACE   IUserAssist

typedef struct
{
    DWORD   cbSize;     // SIZEOF
    DWORD   dwMask;     // INOUT requested/given (UEIM_*)
    int     cHit;       // profile count
    DWORD   dwAttrs;    // attributes (UEIA_*)
    FILETIME ftExecute; // Last execute filetime
} UEMINFO, *LPUEMINFO;

#define UEIM_HIT        0x01
#define UEIM_FILETIME   0x02

DECLARE_INTERFACE_(IUserAssist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IUserAssist methods ***
    STDMETHOD(FireEvent)(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(QueryEvent)(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui) PURE;
    STDMETHOD(SetEvent)(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui) PURE;
};



// This exists for the Internet Control Panel to be able to toggle who is the
// currently installed handler for FTP for the browser.
DECLARE_INTERFACE_(IFtpInstaller, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IFtpInstaller methods ***
    STDMETHOD(IsIEDefautlFTPClient)(THIS) PURE;
    STDMETHOD(RestoreFTPClient)(THIS) PURE;
    STDMETHOD(MakeIEDefautlFTPClient)(THIS) PURE;
};


//
// Private QueryContextMenuFlag passed from DefView
//
#define CMF_DVFILE       0x00010000     // "File" pulldown

SHSTDAPI_(LRESULT) SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);


//
// Callback interface for the IShellFolderView
//
#undef  INTERFACE
#define INTERFACE   IShellFolderViewCB

DECLARE_INTERFACE_(IShellFolderViewCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewCB methods ***
    STDMETHOD(MessageSFVCB)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};

// StringFromGUID and its constants
BOOL _StringFromGUID(GUID const* pid, LPTSTR pszString, UINT cb, UINT idString);

// Note:  The following are used by _StringFromGUID and/or are indexes into the
// c_szExtViewUIRegKeys string array in sfvext.cpp.
#define ID_EXTVIEWSTRFIRST          0
#define ID_EXTVIEWNAME              0 // name of view in menu
#define ID_EXTVIEWHELPTEXT          1 // help text for this view
#define ID_EXTVIEWTTTEXT            2 // tooltip text for this view
#define ID_EXTVIEWICONAREAIMAGE     3 // url of background bitmap for WebViewFolderContents OC
#define ID_EXTVIEWSTRLAST           3

#define ID_EXTVIEWCOLORSFIRST       4
#define ID_EXTVIEWTEXTBACKGROUND    4 // background text color for WebViewFolderContents OC
#define ID_EXTVIEWTEXT              5 // foreground text color for WebViewFolderContents OC
#define ID_EXTVIEWCOLORSLAST        5

#define ID_EXTVIEWMAX               5
#define ID_EXTVIEWSTRCOUNT  (ID_EXTVIEWSTRLAST - ID_EXTVIEWSTRFIRST + 1)
#define ID_EXTVIEWCOLORCOUNT    (ID_EXTVIEWCOLORSLAST - ID_EXTVIEWCOLORSFIRST + 1)
#define ID_EXTVIEWUICOUNT           (ID_EXTVIEWMAX + 1)

#define CLR_MYINVALID 0x8fffffff       // I need to use a special value since CLR_INVALID == CLR_NONE!!!!
#define ISVALIDCOLOR(a) ((a) != CLR_MYINVALID)

// The following are used as indexes into the crCustomColors array, and must be in the same
// order as their ID_EXTVIEW* counterparts above.  They are also used in an analogous array in CDefView.
#define CRID_CUSTOMTEXTBACKGROUND   ID_EXTVIEWTEXTBACKGROUND - ID_EXTVIEWCOLORSFIRST
#define CRID_CUSTOMTEXT             ID_EXTVIEWTEXT - ID_EXTVIEWCOLORSFIRST
#define CRID_COLORCOUNT             ID_EXTVIEWCOLORSLAST - ID_EXTVIEWCOLORSFIRST + 1

typedef struct _CUSTOMVIEWSDATA
{
    DWORD      cchSizeOfBlock;  // size of lpDataBlock in WCHARs
    LPWSTR     lpDataBlock;     // Pointer to the Strings data block, allocated by the task allocator (SHAlloc)

    // The following are offsets (in WCHARs) to be added to lpDataBlock.
    // If the offset is -1 => That data is not present for this view.
    int        acchOffExtViewUIstr[ID_EXTVIEWSTRCOUNT];
    COLORREF   crCustomColors[CRID_COLORCOUNT];

    // Once IE4 ships, we can extend this structure by adding new SFVF_ flags
    // in the main structure that say "customviewsdata contains xxx info".

} CUSTOMVIEWSDATA;

//
// Interface for enumerating "external" views for the ShellFolderView
//
typedef struct _SFVVIEWSDATA
{
    // idView specifies the view. Unless specified in pCustomData, look up
    // HKLM\CLSID\Software\Microsoft\Windows\CurrentVersion\ExtShellFolderViews\idView
    // to find the menu name, help text, tt text.
    //
    // the shell's IShellFolderView implementations get these as
    // subkeys of the shellex\ExtShellFolderViews key under the folder's
    // clsid type (or progid type, depending on the IShellFolderView impl).
    //
    // In desktop.ini, these are keys read from the [ExtShellFolderViews]
    // section, in the form of "{idView}" or "{idView}={idExtShellView}"
    //
    GUID idView;    // This is the GUID that specifies the View.

    // idExtShellView specifies the IDefViewExtInit IShellView extension
    // to use for this view.
    //
    // the shell's IShellFolderView implementations get this from
    // the "ISV" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [ExtShellFolderViews]
    // section, in the form of "{idView}={idExtShellView}"
    //
    GUID idExtShellView; // [optional] This is the GUID for the extended IShellView

    // dwFlags - see the SFVF_ flags below.
    //
    // the shell's IShellFolderView implementations get this from
    // the "Attributes" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "Attributes=" line.
    //
    DWORD dwFlags;

    // lParam is passed to IShellView view extensions
    //
    // the shell's IShellFolderView implementations get this from
    // the "lparam" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "LParam=" line.
    //
    DWORD lParam;

    // wszMoniker is used to either bind to a docobject extended view,
    // or as the data for an idExtShellView view.
    //
    // the shell's IShellFolderView implementations get this from
    // the "PersistMoniker" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "PersistMoniker=" line.
    //
    WCHAR wszMoniker[MAX_PATH];

    // pCustomData overrides/provides menu and other ui options
    // for this view. If a WebViewFolderContents OC appears in the
    // docobject extended view, it pays attention to color and
    // background bitmaps.
    //
    // the shell's IShellFolderView implementations do not fill out this structure.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "IconArea_Image", "IconArea_TextBackground", and "IconArea_Text".
    //
    CUSTOMVIEWSDATA *pCustomData; //This is valid only if SFVF_CUSTOMIZEDVIEW is set.

} SFVVIEWSDATA;

//
// SFVF_CUSTOMIZEDVIEW - This flag is set only for those views whose
// data are picked up from the Desktop.ini.
//
#define SFVF_CUSTOMIZEDVIEW  0x80000000

//
// SFVF_TREATASNORMAL - This flag is set for those views that wish to
// be treated as normal views, this means they will show up in the file-open/SaveAs
// Dialogs.
//
#define SFVF_TREATASNORMAL   0x40000000

//
// SFVF_NOWEBVIEWFOLDERCONTENTS - This is used to detect those views that
// never host the WebViewFolderContents OC and so cannot toggle on and off,
// ie, they are exclusive views such as Thumbnail View.
//
#define SFVF_NOWEBVIEWFOLDERCONTENTS   0x20000000


#undef  INTERFACE
#define INTERFACE   IEnumSFVViews

DECLARE_INTERFACE_(IEnumSFVViews, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumSFVViews methods ***
    STDMETHOD(Next)  (THIS_ ULONG celt,
                      SFVVIEWSDATA **ppData,
                      ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)  (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSFVViews **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IPersistString

DECLARE_INTERFACE_(IPersistString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistString methods ***
    STDMETHOD(Initialize) (THIS_ LPCWSTR pwszInit) PURE;
};

#pragma warning (disable: 4200)
#pragma warning (disable: 4510)
#pragma warning (disable: 4512)
#pragma warning (disable: 4610)
// From sdkinc\platform.h
// We can't simply include that file because it breaks other projects
// that include platform.h.
#undef UNSIZED_ARRAY
#undef EMPTY_SIZE
#   ifdef UNIX
        // Unix specific compiler problems
#       define UNSIZED_ARRAY 1
#   else
#       define UNSIZED_ARRAY
#   endif // UNIX
#define EMPTY_SIZE UNSIZED_ARRAY
#define QCMINFO_PLACE_BEFORE    0
#define QCMINFO_PLACE_AFTER     1
typedef struct _QCMINFO_IDMAP_PLACEMENT
{
    UINT id;
    UINT fFlags;
} QCMINFO_IDMAP_PLACEMENT;

typedef struct _QCMINFO_IDMAP
{
    UINT    nMaxIds;
    const QCMINFO_IDMAP_PLACEMENT   pIdList[EMPTY_SIZE];
} QCMINFO_IDMAP;

typedef struct _QCMINFO
{
    HMENU       hmenu;          // in
    UINT        indexMenu;      // in
    UINT        idCmdFirst;     // in/out
    UINT        idCmdLast;      // in
    const QCMINFO_IDMAP*  pIdMap;      //out
} QCMINFO;
typedef QCMINFO * LPQCMINFO;

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2
#define TBIF_DEFAULT      0x00000000
#define TBIF_INTERNETBAR  0x00010000
#define TBIF_STANDARDTOOLBAR   0x00020000
#define TBIF_NOTOOLBAR  0x00030000

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO;


typedef struct _SFVM_SELCHANGE_DATA
{
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
} SFVM_SELCHANGE_DATA;


typedef struct _COPYHOOKINFO
{
    HWND hwnd;
    DWORD wFunc;
    DWORD wFlags;
    LPCTSTR pszSrcFile;
    DWORD dwSrcAttribs;
    LPCTSTR pszDestFile;
    DWORD dwDestAttribs;
} COPYHOOKINFO;

typedef struct _DETAILSINFO
{
    LPCITEMIDLIST pidl;
    int fmt;
    int cxChar;
    STRRET str;
    int iImage;
} DETAILSINFO;

typedef struct _SFVM_PROPPAGE_DATA
{
    DWORD                dwReserved;
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM               lParam;
} SFVM_PROPPAGE_DATA;

typedef struct _SFVM_HELPTOPIC_DATA
{
    WCHAR wszHelpFile[MAX_PATH];
    WCHAR wszHelpTopic[MAX_PATH];
} SFVM_HELPTOPIC_DATA;


// SFVM_GETNOTIFY: The shell will use the pidl returned from this message to synch
//                 change notifies.  Folders in Folder Shortcuts should return pidlTarget
//                 because that is where the change notifies are sent.
//
//                                uMsg    wParam             lParam
#define SFVM_MERGEMENU            1    // 0                  LPQCMINFO
#define SFVM_INVOKECOMMAND        2    // idCmd              0
#define SFVM_GETHELPTEXT          3    // idCmd,cchMax       pszText - Ansi/unicode (yup, old Tchar version)
#define SFVM_GETTOOLTIPTEXT       4    // idCmd,cchMax       pszText - Ansi/unicode (yup, old tchar version)
#define SFVM_GETBUTTONINFO        5    // 0                  LPTBINFO
#define SFVM_GETBUTTONS           6    // idCmdFirst,cbtnMax LPTBBUTTON
#define SFVM_INITMENUPOPUP        7    // idCmdFirst,nIndex  hmenu
#define SFVM_SELCHANGE            8    // idCmdFirst,nItem   SFVM_SELCHANGE_DATA*
#define SFVM_DRAWITEM             9    // idCmdFirst         DRAWITEMSTRUCT*
#define SFVM_MEASUREITEM         10    // idCmdFirst         MEASUREITEMSTRUCT*
#define SFVM_EXITMENULOOP        11    // -                  -
#define SFVM_PRERELEASE          12    // -                  -
#define SFVM_GETCCHMAX           13    // LPCITEMIDLIST      pcchMax
#define SFVM_FSNOTIFY            14    // LPCITEMIDLIST*     lEvent
#define SFVM_WINDOWCREATED       15    // hwnd               -
#define SFVM_WINDOWDESTROY       16    // hwnd               -
#define SFVM_REFRESH             17    // BOOL fPreOrPost    -                          NB: this may be called multiple times in a row
#define SFVM_SETFOCUS            18    // -                  -
#define SFVM_QUERYCOPYHOOK       20    // -                  -
#define SFVM_NOTIFYCOPYHOOK      21    // -                  COPYHOOKINFO*
#define SFVM_GETDETAILSOF        23    // iColumn            DETAILSINFO*
#define SFVM_COLUMNCLICK         24    // iColumn            -
#define SFVM_QUERYFSNOTIFY       25    // -                  SHChangeNotifyEntry *
#define SFVM_DEFITEMCOUNT        26    // -                  UINT*
#define SFVM_DEFVIEWMODE         27    // -                  FOLDERVIEWMODE*
#define SFVM_UNMERGEMENU         28    // -                  hmenu
#define SFVM_INSERTITEM          29    // pidl               -
#define SFVM_DELETEITEM          30    // pidl               -
#define SFVM_UPDATESTATUSBAR     31    // fInitialize        -
#define SFVM_BACKGROUNDENUM      32    // -                  -
#define SFVM_GETWORKINGDIR       33    // uMax               pszDir
#define SFVM_GETCOLSAVESTREAM    34    // flags              IStream **
#define SFVM_SELECTALL           35    // -                  -
#define SFVM_DIDDRAGDROP         36    // dwEffect           IDataObject *
#define SFVM_SUPPORTSIDENTITY    37    // -                  -
#define SFVM_FOLDERISPARENT      38    // -                  pidlChild
#define SFVM_SETISFV             39    // -                  IShellFolderView*
#define SFVM_GETVIEWS            40    // SHELLVIEWID*       IEnumSFVViews **
#define SFVM_THISIDLIST          41    // -                  LPITMIDLIST*
#define SFVM_GETITEMIDLIST       42    // iItem              LPITMIDLIST*
#define SFVM_SETITEMIDLIST       43    // iItem              LPITEMIDLIST
#define SFVM_INDEXOFITEMIDLIST   44    // *iItem             LPITEMIDLIST
#define SFVM_ODFINDITEM          45    // *iItem             NM_FINDITEM*
#define SFVM_HWNDMAIN            46    //                    hwndMain
#define SFVM_ADDPROPERTYPAGES    47    // -                  SFVM_PROPPAGE_DATA *
#define SFVM_BACKGROUNDENUMDONE  48    // -                  -
#define SFVM_GETNOTIFY           49    // LPITEMIDLIST*      LONG*
#define SFVM_ARRANGE             50    // -                  lParamSort
#define SFVM_QUERYSTANDARDVIEWS  51    // -                  BOOL *
#define SFVM_QUERYREUSEEXTVIEW   52    // -                  BOOL *
#define SFVM_GETSORTDEFAULTS     53    // iDirection         iParamSort
#define SFVM_GETEMPTYTEXT        54    // cchMax             pszText
#define SFVM_GETITEMICONINDEX    55    // iItem              int *piIcon
#define SFVM_DONTCUSTOMIZE       56    // -                  BOOL *pbDontCustomize
#define SFVM_SIZE                57    // resizing flag      cx, cy
#define SFVM_GETZONE             58    // -                  DWORD*
#define SFVM_GETPANE             59    // Pane ID            DWORD*
#define SFVM_ISOWNERDATA         60    // ISOWNERDATA        BOOL *
#define SFVM_GETODRANGEOBJECT    61    // iWhich             ILVRange **
#define SFVM_ODCACHEHINT         62    // -                  NMLVCACHEHINT *
#define SFVM_GETHELPTOPIC        63    // 0                  SFVM_HELPTOPIC_DATA *
#define SFVM_OVERRIDEITEMCOUNT   64    // -                  UINT*
#define SFVM_GETHELPTEXTW        65    // idCmd,cchMax       pszText - unicode
#define SFVM_GETTOOLTIPTEXTW     66    // idCmd,cchMax       pszText - unicode
#define SFVM_GETIPERSISTHISTORY  67    //                    IPersistHistory **
#define SFVM_GETANIMATION        68    // HINSTANCE *        WCHAR *
#define SFVM_GETHELPTEXTA        69    // idCmd,cchMax       pszText - ansi
#define SFVM_GETTOOLTIPTEXTA     70    // idCmd,cchMax       pszText - ansi

// The below two messages are only used in ownder data case, i.e. when SFVM_ISOWNERDATA returns TRUE
#define SFVM_GETICONOVERLAY      71    // iItem              int iOverlayIndex
#define SFVM_SETICONOVERLAY      72    // iItem              int * piOverlayIndex

#define SFVM_ALTERDROPEFFECT     73    // DWORD*             IDataObject*

// All of these macros are compatible with HANDLE_MSG in WINDOWSX.H

#define HANDLE_SFVM_MERGEMENU(pv, wP, lP, fn) \
    ((fn)((pv), (QCMINFO*)(lP)))

#define HANDLE_SFVM_INVOKECOMMAND(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP)))

#define HANDLE_SFVM_GETHELPTEXT(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETTOOLTIPTEXT(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETBUTTONINFO(pv, wP, lP, fn) \
    ((fn)((pv), (TBINFO*)(lP)))

#define HANDLE_SFVM_GETBUTTONS(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (TBBUTTON*)(lP)))

#define HANDLE_SFVM_INITMENUPOPUP(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (HMENU)(lP)))

#define HANDLE_SFVM_SELCHANGE(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (SFVM_SELCHANGE_DATA*)(lP)))

#define HANDLE_SFVM_DRAWITEM(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (DRAWITEMSTRUCT*)(lP)))

#define HANDLE_SFVM_MEASUREITEM(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (MEASUREITEMSTRUCT*)(lP)))

#define HANDLE_SFVM_EXITMENULOOP(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_PRERELEASE(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_GETCCHMAX(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(wP), (UINT*)(lP)))

#define HANDLE_SFVM_FSNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST*)(wP), (lP)))

#define HANDLE_SFVM_WINDOWCREATED(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_WINDOWDESTROY(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_REFRESH(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL) wP))

#define HANDLE_SFVM_SETFOCUS(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_QUERYCOPYHOOK(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_NOTIFYCOPYHOOK(pv, wP, lP, fn) \
    ((fn)((pv), (COPYHOOKINFO*)(lP)))

#define HANDLE_SFVM_GETDETAILSOF(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (DETAILSINFO*)(lP)))

#define HANDLE_SFVM_COLUMNCLICK(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP)))

#define HANDLE_SFVM_QUERYFSNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (SHChangeNotifyEntry*)(lP)))

#define HANDLE_SFVM_DEFITEMCOUNT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT*)(lP)))

#define HANDLE_SFVM_OVERRIDEITEMCOUNT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT*)(lP)))

#define HANDLE_SFVM_DEFVIEWMODE(pv, wP, lP, fn) \
    ((fn)((pv), (FOLDERVIEWMODE*)(lP)))

#define HANDLE_SFVM_UNMERGEMENU(pv, wP, lP, fn) \
    ((fn)((pv), (HMENU)(lP)))

#define HANDLE_SFVM_INSERTITEM(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(lP)))

#define HANDLE_SFVM_DELETEITEM(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(lP)))

#define HANDLE_SFVM_UPDATESTATUSBAR(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL)(wP)))

#define HANDLE_SFVM_BACKGROUNDENUM(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_GETWORKINGDIR(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETCOLSAVESTREAM(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (IStream**)(lP)))

#define HANDLE_SFVM_SELECTALL(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_DIDDRAGDROP(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD)(wP), (IDataObject*)(lP)))

#define HANDLE_SFVM_HWNDMAIN(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(lP)))

#define HANDLE_SFVM_GETNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST*)(wP), (LONG*)(lP)))

#define HANDLE_SFVM_SETISFV(pv, wP, lP, fn) \
    ((fn)((pv), (IShellFolderView*)(lP)))

#define HANDLE_SFVM_GETVIEWS(pv, wP, lP, fn) \
    ((fn)((pv), (SHELLVIEWID*)(wP), (IEnumSFVViews**)(lP)))

#define HANDLE_SFVM_THISIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST*)(lP)))

#define HANDLE_SFVM_GETITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (LPITEMIDLIST*)(lP)))

#define HANDLE_SFVM_SETITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_INDEXOFITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (int*)(wP), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_ODFINDITEM(pv, wP, lP, fn) \
    ((fn)((pv), (int*)(wP), (NM_FINDITEM*)(lP)))

#define HANDLE_SFVM_ADDPROPERTYPAGES(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_PROPPAGE_DATA *)(lP)))

#define HANDLE_SFVM_FOLDERISPARENT(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_ARRANGE(pv, wP, lP, fn) \
    ((fn)((pv), (LPARAM)(lP)))

#define HANDLE_SFVM_QUERYSTANDARDVIEWS(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_QUERYREUSEEXTVIEW(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_GETEMPTYTEXT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETITEMICONINDEX(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int*)(lP)))

#define HANDLE_SFVM_SIZE(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(lP), HIWORD(lP)))

#define HANDLE_SFVM_GETZONE(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD *)(lP)))

#define HANDLE_SFVM_GETPANE(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (DWORD *)(lP)))

#define HANDLE_SFVM_ISOWNERDATA(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_GETODRANGEOBJECT(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (ILVRange **)(lP)))

#define HANDLE_SFVM_ODCACHEHINT(pv, wP, lP, fn) \
    ((fn)((pv), (NMLVCACHEHINT*)(lP)))

#define HANDLE_SFVM_GETHELPTOPIC(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_HELPTOPIC_DATA *)(lP)))

#define HANDLE_SFVM_GETIPERSISTHISTORY(pv, wP, lP, fn) \
    ((fn)((pv), (IPersistHistory **)(lP)))

#define HANDLE_SFVM_SETICONOVERLAY(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int)(lP)))

#define HANDLE_SFVM_GETICONOVERLAY(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int *)(lP)))

#define HANDLE_SFVM_ALTERDROPEFFECT(pv, wP, lP, fn) \
	((fn)((pv), (DWORD *)(wP), (IDataObject *)(lP)))

//
// Return values for SFVM_GETICONOVERLAY:
// If the icon overlay is not set and you want the shell to set it for you.
// return SFVOVERLAY_UNSET. This will cause the shell to retrieve the overlay and
// send SFVM_SETICONOVERLAY.
// If there is no overlay for this item at all, the correct return value is
// SFVOVERLAY_DEFAULT
// If you return SFVOVERLAY_UNSET every time for SFVM_GETICONOVERLAY, the
// shell will keep setting it indefinitely, so there is a danger of infinite loop
//
#define SFV_ICONOVERLAY_DEFAULT    0
#define SFV_ICONOVERLAY_UNSET      0xFFFFFFFF

//
// What you can return from SFVM_UPDATESTATUSBAR:
//
//  E_NOTIMPL - Message not handled; DefView should manage status bar
//
// Otherwise, update the status bar yourself and return a bitmask of the
// following codes indicating what you want DefView to do for you.
//
#define SFVUSB_HANDLED      0x0000  // Client handled completely - DefView does nothing
#define SFVUSB_INITED       0x0001  // Client initialized parts  - DefView will set text
#define SFVUSB_ALL          0x0001

// IShellFolderView interface for getting the SFV to do things
//

typedef struct _ITEMSPACING
{
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING;


// Define OPtions for SetObjectCount
#define SFVSOC_INVALIDATE_ALL   0x00000001  // Assumed to reset only what is neccessary...
#define SFVSOC_NOSCROLL         LVSICF_NOSCROLL

// defines for IShellFolderView::SelectItems()
#define SFVS_SELECT_NONE        0x0 // unselect all
#define SFVS_SELECT_ALLITEMS    0x1 // select all
#define SFVS_SELECT_INVERT      0x2 // Inver the selection

// defines for IShellFolderView::QuerySupport()
// allows a view to be queried to see if it supports various operations (useful for
// enabling menu items)
#define SFVQS_AUTO_ARRANGE      0x0001
#define SFVQS_ARRANGE_GRID      0x0002
#define SFVQS_SELECT_ALL        0x0004
#define SFVQS_SELECT_NONE       0x0008
#define SFVQS_SELECT_INVERT     0x0010

#undef  INTERFACE
#define INTERFACE   IShellFolderView

DECLARE_INTERFACE_(IShellFolderView, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderView methods ***
    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE;
    STDMETHOD(GetArrangeParam) (THIS_ LPARAM *plParamSort) PURE;
    STDMETHOD(ArrangeGrid) (THIS) PURE;
    STDMETHOD(AutoArrange) (THIS) PURE;
    STDMETHOD(GetAutoArrange) (THIS) PURE;
    STDMETHOD(AddObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(GetObject) (THIS_ LPITEMIDLIST *ppidl, UINT uItem) PURE;
    STDMETHOD(RemoveObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(GetObjectCount) (THIS_ UINT *puCount) PURE;
    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem) PURE;
    STDMETHOD(RefreshObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE;
    STDMETHOD(GetSelectedCount) (THIS_ UINT *puSelected) PURE;
    STDMETHOD(GetSelectedObjects) (THIS_ LPCITEMIDLIST **pppidl, UINT *puItems) PURE;
    STDMETHOD(IsDropOnSource) (THIS_ IDropTarget *pDropTarget) PURE;
    STDMETHOD(GetDragPoint) (THIS_ POINT *ppt) PURE;
    STDMETHOD(GetDropPoint) (THIS_ POINT *ppt) PURE;
    STDMETHOD(MoveIcons) (THIS_ IDataObject *pDataObject) PURE;
    STDMETHOD(SetItemPos) (THIS_ LPCITEMIDLIST pidl, POINT *ppt) PURE;
    STDMETHOD(IsBkDropTarget) (THIS_ IDropTarget *pDropTarget) PURE;
    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE;
    STDMETHOD(SetPoints) (THIS_ IDataObject *pDataObject) PURE;
    STDMETHOD(GetItemSpacing) (THIS_ ITEMSPACING *pSpacing) PURE;
    STDMETHOD(SetCallback) (THIS_ IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB) PURE;
    STDMETHOD(Select) ( THIS_  UINT dwFlags ) PURE;
    STDMETHOD(QuerySupport) (THIS_ UINT * pdwSupport ) PURE;
    STDMETHOD(SetAutomationObject)(THIS_ IDispatch* pdisp) PURE;
} ;

// CDTURNER start
////////////////////////////////////////////////////////////////////////////////////
DECLARE_INTERFACE_( IDefViewExtInit, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewExtInit methods ***
    STDMETHOD(SetOwnerDetails)(THIS_ IShellFolder * pSF, DWORD lParam ) PURE;
};

////////////////////////////////////////////////////////////////////////////////////
DECLARE_INTERFACE_( IDefViewExtInit2, IDefViewExtInit )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDefViewExtInit methods ***
    STDMETHOD(SetOwnerDetails)(THIS_ IShellFolder * pSF, DWORD lParam ) PURE;

    // *** IDefViewExtInit2 methods ***
    STDMETHOD( SetViewWindowStyle )( THIS_ DWORD dwBits, DWORD dwVal) PURE;
    STDMETHOD( SetViewWindowBkImage )( THIS_ LPCWSTR pszImage) PURE;
    STDMETHOD( SetViewWindowColors )( THIS_ COLORREF clrText, COLORREF clrTextBk, COLORREF clrWindow) PURE;

    STDMETHOD( IsModal )( THIS ) PURE;

    STDMETHOD( AutoAutoArrange )( THIS_ DWORD dwReserved ) PURE;
    STDMETHOD(SetStatusText)( THIS_ LPCWSTR pwszStatusText) PURE;
};
// CDTURNER end

// SHCreateShellFolderView struct
#include <pshpack8.h>
typedef struct _SFV_CREATE
{
    UINT            cbSize;
    IShellFolder*   pshf;
    IShellView*     psvOuter;
    IShellFolderViewCB* psfvcb; // No callback if NULL
} SFV_CREATE;
#include <poppack.h>

SHSTDAPI SHCreateShellFolderView(const SFV_CREATE* pcsfv, IShellView **ppsv);
#define SHCreateShellFolderViewORD      256

SHSTDAPI_(IShellFolderViewCB*) SHGetShellFolderViewCB(HWND hwndMain);
#define SHGetShellFolderViewCBORD   257


//===========================================================================
// Defview APIs to make name space author lives somewhat easier

typedef HRESULT (CALLBACK * LPFNDFMCALLBACK)(IShellFolder *psf, HWND hwnd,
                                             IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

SHSTDAPI CDefFolderMenu_Create2(LPCITEMIDLIST pidlFolder, HWND hwnd,
                                UINT cidl, LPCITEMIDLIST *apidl,
                                IShellFolder *psf, LPFNDFMCALLBACK lpfn,
                                UINT nKeys, const HKEY *ahkeyClsKeys,
                                IContextMenu **ppcm);

SHSTDAPI_(BOOL) SHOpenPropSheetA(LPCSTR pszCaption, HKEY ahkeys[], UINT cikeys,
                                 const CLSID * pclsidDefault, IDataObject *pdtobj,
                                 IShellBrowser *psb, LPCSTR pStartPage);
SHSTDAPI_(BOOL) SHOpenPropSheetW(LPCWSTR pszCaption, HKEY ahkeys[], UINT cikeys,
                                 const CLSID * pclsidDefault, IDataObject *pdtobj,
                                 IShellBrowser *psb, LPCWSTR pStartPage);
#ifdef UNICODE
#define SHOpenPropSheet  SHOpenPropSheetW
#else
#define SHOpenPropSheet  SHOpenPropSheetA
#endif // !UNICODE


// structure for lParam of DFM_INFOKECOMMANDEX
typedef struct
{
    DWORD  cbSize;

    DWORD  fMask;   // CMIC_MASK_ values for the invoke
    LPARAM lParam;  // same as lParam of DFM_INFOKECOMMAND
    UINT idCmdFirst;
    UINT idDefMax;
    LPCMINVOKECOMMANDINFO pici; // the whole thing so you can re-invoke on a child
} DFMICS, *PDFMICS;

//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_ADDREF                   3      // 0            0
#define DFM_RELEASE                  4      // 0            0
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_INVOKECOMMANDEX          12     // idCmd        PDFMICS
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName
#define DFM_GETDEFSTATICID           14     // idCmd *      0
#define DFM_GETVERBW                 15     // idCmd,cchMax pszText -Unicode
#define DFM_GETVERBA                 16     // idCmd,cchMax pszText -Ansi


// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE          ((WPARAM)-1)
#define DFM_CMD_MOVE            ((WPARAM)-2)
#define DFM_CMD_COPY            ((WPARAM)-3)
#define DFM_CMD_LINK            ((WPARAM)-4)
#define DFM_CMD_PROPERTIES      ((WPARAM)-5)
#define DFM_CMD_NEWFOLDER       ((WPARAM)-6)
#define DFM_CMD_PASTE           ((WPARAM)-7)
#define DFM_CMD_VIEWLIST        ((WPARAM)-8)
#define DFM_CMD_VIEWDETAILS     ((WPARAM)-9)
#define DFM_CMD_PASTELINK       ((WPARAM)-10)
#define DFM_CMD_PASTESPECIAL    ((WPARAM)-11)
#define DFM_CMD_MODALPROP       ((WPARAM)-12)
#define DFM_CMD_RENAME          ((WPARAM)-13)

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
                             HWND hwndOwner,
                             UINT cidl, LPCITEMIDLIST * apidl,
                             IShellFolder *psf,
                             LPFNDFMCALLBACK lpfn,
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu ** ppcm);



STDAPI_(void) CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge,
        LPQCMINFO pqcm);
STDAPI_(void) Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        BOOL bContext);
STDAPI_(void) Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        IDropTarget *pdtgt, UINT fContext);

// indeces in bitmap strip
#define VIEW_MOVETO     24
#define VIEW_COPYTO     25
#define VIEW_OPTIONS    26

//===========================================================================
// Default IShellView for IShellFolder
//===========================================================================

// Menu ID's
#define SFVIDM_FIRST            (FCIDM_SHVIEWLAST-0x0fff)
#define SFVIDM_LAST             (FCIDM_SHVIEWLAST)

// Hardcoded message values => This range can be used for messages that we
// pass from shdoc401 to shell32
#define SFVIDM_HARDCODED_FIRST  (SFVIDM_LAST-0x0010)
#define SFVIDM_HARDCODED_LAST   (SFVIDM_LAST)

#define SFVIDM_MISC_SETWEBVIEW  (SFVIDM_HARDCODED_FIRST)

// Popup menu ID's used in merging menus
#define SFVIDM_MENU_ARRANGE     (SFVIDM_FIRST + 0x0001)
#define SFVIDM_MENU_VIEW        (SFVIDM_FIRST + 0x0002)
#define SFVIDM_MENU_SELECT      (SFVIDM_FIRST + 0x0003)

#define SHARED_FILE_FIRST               0x0010
#define SHARED_FILE_LINK                (SHARED_FILE_FIRST + 0x0000)
#define SHARED_FILE_DELETE              (SHARED_FILE_FIRST + 0x0001)
#define SHARED_FILE_RENAME              (SHARED_FILE_FIRST + 0x0002)
#define SHARED_FILE_PROPERTIES          (SHARED_FILE_FIRST + 0x0003)

#define SHARED_EDIT_FIRST               0x0018
#define SHARED_EDIT_CUT                 (SHARED_EDIT_FIRST + 0x0000)
#define SHARED_EDIT_COPY                (SHARED_EDIT_FIRST + 0x0001)
#define SHARED_EDIT_PASTE               (SHARED_EDIT_FIRST + 0x0002)
#define SHARED_EDIT_UNDO                (SHARED_EDIT_FIRST + 0x0003)
#define SHARED_EDIT_PASTELINK           (SHARED_EDIT_FIRST + 0x0004)
#define SHARED_EDIT_PASTESPECIAL        (SHARED_EDIT_FIRST + 0x0005)
#define SHARED_EDIT_COPYTO              (SHARED_EDIT_FIRST + 0x0006)
#define SHARED_EDIT_MOVETO              (SHARED_EDIT_FIRST + 0x0007)

#define SFVIDM_FILE_FIRST               (SFVIDM_FIRST + SHARED_FILE_FIRST)
#define SFVIDM_FILE_LINK                (SFVIDM_FIRST + SHARED_FILE_LINK)
#define SFVIDM_FILE_DELETE              (SFVIDM_FIRST + SHARED_FILE_DELETE)
#define SFVIDM_FILE_RENAME              (SFVIDM_FIRST + SHARED_FILE_RENAME)
#define SFVIDM_FILE_PROPERTIES          (SFVIDM_FIRST + SHARED_FILE_PROPERTIES)

#define SFVIDM_EDIT_FIRST               (SFVIDM_FIRST + SHARED_EDIT_FIRST)
#define SFVIDM_EDIT_CUT                 (SFVIDM_FIRST + SHARED_EDIT_CUT)
#define SFVIDM_EDIT_COPY                (SFVIDM_FIRST + SHARED_EDIT_COPY)
#define SFVIDM_EDIT_PASTE               (SFVIDM_FIRST + SHARED_EDIT_PASTE)
#define SFVIDM_EDIT_UNDO                (SFVIDM_FIRST + SHARED_EDIT_UNDO)
#define SFVIDM_EDIT_PASTELINK           (SFVIDM_FIRST + SHARED_EDIT_PASTELINK)
#define SFVIDM_EDIT_PASTESPECIAL        (SFVIDM_FIRST + SHARED_EDIT_PASTESPECIAL)
#define SFVIDM_EDIT_COPYTO              (SFVIDM_FIRST + SHARED_EDIT_COPYTO)
#define SFVIDM_EDIT_MOVETO              (SFVIDM_FIRST + SHARED_EDIT_MOVETO)

#define SFVIDM_SELECT_FIRST             (SFVIDM_FIRST + 0x0020)
#define SFVIDM_SELECT_ALL               (SFVIDM_SELECT_FIRST + 0x0001)
#define SFVIDM_SELECT_INVERT            (SFVIDM_SELECT_FIRST + 0x0002)
#define SFVIDM_DESELECT_ALL             (SFVIDM_SELECT_FIRST + 0x0003)

#define SFVIDM_VIEW_FIRST               (SFVIDM_FIRST + 0x0028)
#define SFVIDM_VIEW_ICON                (SFVIDM_VIEW_FIRST + 0x0001)
#define SFVIDM_VIEW_SMALLICON           (SFVIDM_VIEW_FIRST + 0x0002)
#define SFVIDM_VIEW_LIST                (SFVIDM_VIEW_FIRST + 0x0003)
#define SFVIDM_VIEW_DETAILS             (SFVIDM_VIEW_FIRST + 0x0004)
#define SFVIDM_VIEW_FIRSTVIEW           (SFVIDM_VIEW_ICON)
#define SFVIDM_VIEW_LASTVIEW            (SFVIDM_VIEW_DETAILS)
#define SFVIDM_VIEW_OPTIONS             (SFVIDM_VIEW_FIRST + 0x0005)
#define SFVIDM_VIEW_VIEWMENU            (SFVIDM_VIEW_FIRST + 0x0006)
#define SFVIDM_VIEW_CUSTOMWIZARD        (SFVIDM_VIEW_FIRST + 0x0007)
#define SFVIDM_VIEW_COLSETTINGS         (SFVIDM_VIEW_FIRST + 0x0008)

#define SFVIDM_VIEW_EXTFIRST            (SFVIDM_VIEW_FIRST + 0x0009)
#define SFVIDM_VIEW_EXTLAST             (SFVIDM_VIEW_EXTFIRST + 0x0017)
#define SFVIDM_VIEW_SVEXTFIRST          (SFVIDM_VIEW_EXTFIRST)
#define SFVIDM_VIEW_SVEXTLAST           (SFVIDM_VIEW_EXTFIRST + 0x000F)
#define SFVIDM_VIEW_EXTENDEDFIRST       (SFVIDM_VIEW_EXTFIRST + 0x0010)
#define SFVIDM_VIEW_EXTENDEDLAST        (SFVIDM_VIEW_EXTLAST)

#define SFVIDM_ARRANGE_FIRST            (SFVIDM_FIRST + 0x0050)
#define SFVIDM_ARRANGE_AUTO             (SFVIDM_ARRANGE_FIRST + 0x0001)
#define SFVIDM_ARRANGE_GRID             (SFVIDM_ARRANGE_FIRST + 0x0002)
#define SFVIDM_ARRANGE_DISPLAYICONS     (SFVIDM_ARRANGE_FIRST + 0x0003)

#define SFVIDM_TOOL_FIRST               (SFVIDM_FIRST + 0x0060)
#define SFVIDM_TOOL_CONNECT             (SFVIDM_TOOL_FIRST + 0x0001)
#define SFVIDM_TOOL_DISCONNECT          (SFVIDM_TOOL_FIRST + 0x0002)
#define SFVIDM_TOOL_OPTIONS             (SFVIDM_TOOL_FIRST + 0x0003)

#define SFVIDM_HELP_FIRST               (SFVIDM_FIRST + 0x0070)
#define SFVIDM_HELP_TOPIC               (SFVIDM_HELP_FIRST + 0x0001)

#define SFVIDM_MISC_FIRST               (SFVIDM_FIRST + 0x0100)
#define SFVIDM_MISC_REFRESH             (SFVIDM_MISC_FIRST + 0x0003)

// Range for the client's additional menus
#define SFVIDM_CLIENT_FIRST             (SFVIDM_FIRST + 0x0200)
#define SFVIDM_CLIENT_LAST              (SFVIDM_FIRST + 0x02ff)

#define SFVIDM_DESKTOP_FIRST            (SFVIDM_FIRST + 0x0400)
#define SFVIDM_DESKTOPHTML_CUSTOMIZE    (SFVIDM_DESKTOP_FIRST + 0x0000)
#define SFVIDM_DESKTOPHTML_NEWITEM      (SFVIDM_DESKTOP_FIRST + 0x0001)
#define SFVIDM_DESKTOPHTML_WEBCONTENT   (SFVIDM_DESKTOP_FIRST + 0x0002)
#define SFVIDM_DESKTOPHTML_ICONS        (SFVIDM_DESKTOP_FIRST + 0x0003)
#define SFVIDM_DESKTOPHTML_LOCK         (SFVIDM_DESKTOP_FIRST + 0x0004)
#define SFVIDM_DESKTOPHTML_SYNCHRONIZE  (SFVIDM_DESKTOP_FIRST + 0x0005)
#define SFVIDM_DESKTOPHTML_ADDSEPARATOR (SFVIDM_DESKTOP_FIRST + 0x0010)
// The values after ADDSEPARATOR are reserved for each item dynamically added to the menu
#define SFVIDM_DESKTOP_LAST             (SFVIDM_FIRST + 0x04ff)

#define SFVIDM_COLUMN_FIRST             (SFVIDM_FIRST + 0x0500)
#define SFVIDM_COLUMN_LAST              (SFVIDM_FIRST + 0x05ff)


// Range for context menu id's
#define SFVIDM_CONTEXT_FIRST            (SFVIDM_FIRST + 0x0800)
#define SFVIDM_CONTEXT_LAST             (SFVIDM_FIRST + 0x0900)
#define SFVIDM_BACK_CONTEXT_FIRST       (SFVIDM_FIRST + 0x0901)
#define SFVIDM_BACK_CONTEXT_LAST        (SFVIDM_FIRST + 0x09ff)



typedef TBINFO * LPTBINFO;

typedef COPYHOOKINFO *LPCOPYHOOKINFO;

typedef DETAILSINFO *PDETAILSINFO;

//                              uMsg                     wParam         lParam
#define DVM_MERGEMENU           SFVM_MERGEMENU        // uFlags             LPQCMINFO
#define DVM_INVOKECOMMAND       SFVM_INVOKECOMMAND    // idCmd              0
#define DVM_GETHELPTEXT         SFVM_GETHELPTEXT      // idCmd,cchMax       pszText - Ansi
#define DVM_GETTOOLTIPTEXT      SFVM_GETTOOLTIPTEXT   // idCmd,cchMax       pszText
#define DVM_GETBUTTONINFO       SFVM_GETBUTTONINFO    // 0                  LPTBINFO
#define DVM_GETBUTTONS          SFVM_GETBUTTONS       // idCmdFirst,cbtnMax LPTBBUTTON
#define DVM_INITMENUPOPUP       SFVM_INITMENUPOPUP    // idCmdFirst,nIndex  hmenu
#define DVM_SELCHANGE           SFVM_SELCHANGE        // idCmdFirst,nItem   PDVSELCHANGEINFO
#define DVM_DRAWITEM            SFVM_DRAWITEM         // idCmdFirst         pdis
#define DVM_MEASUREITEM         SFVM_MEASUREITEM      // idCmdFirst         pmis
#define DVM_EXITMENULOOP        SFVM_EXITMENULOOP     // -                  -
#define DVM_RELEASE             SFVM_PRERELEASE       // -                  lSelChangeInfo (ShellFolder private)
#define DVM_GETCCHMAX           SFVM_GETCCHMAX        // pidlItem           pcchMax
#define DVM_FSNOTIFY            SFVM_FSNOTIFY         // LPITEMIDLIST*      lEvent
#define DVM_WINDOWCREATED       SFVM_WINDOWCREATED    // hwnd               PDVSELCHANGEINFO
#define DVM_WINDOWDESTROY       SFVM_WINDOWDESTROY    // hwnd               PDVSELCHANGEINFO
#define DVM_REFRESH             SFVM_REFRESH          // -                  lSelChangeInfo
#define DVM_SETFOCUS            SFVM_SETFOCUS         // -                  lSelChangeInfo
#define DVM_KILLFOCUS           19                    // unused
#define DVM_QUERYCOPYHOOK       SFVM_QUERYCOPYHOOK    // -                  -
#define DVM_NOTIFYCOPYHOOK      SFVM_NOTIFYCOPYHOOK   // -                  LPCOPYHOOKINFO
#define DVM_NOTIFY              SFVM_NOTIFY           // idFrom             LPNOTIFY
#define DVM_GETDETAILSOF        SFVM_GETDETAILSOF     // iColumn            PDETAILSINFO
#define DVM_COLUMNCLICK         SFVM_COLUMNCLICK      // iColumn            -
#define DVM_QUERYFSNOTIFY       SFVM_QUERYFSNOTIFY    // -                  FSNotifyEntry *
#define DVM_DEFITEMCOUNT        SFVM_DEFITEMCOUNT     // -                  PINT
#define DVM_DEFVIEWMODE         SFVM_DEFVIEWMODE      // -                  PFOLDERVIEWMODE
#define DVM_UNMERGEMENU         SFVM_UNMERGEMENU      // uFlags
#define DVM_INSERTITEM          SFVM_INSERTITEM       // pidl               PDVSELCHANGEINFO
#define DVM_DELETEITEM          SFVM_DELETEITEM       // pidl               PDVSELCHANGEINFO
#define DVM_UPDATESTATUSBAR     SFVM_UPDATESTATUSBAR  // -                  lSelChangeInfo
#define DVM_BACKGROUNDENUM      SFVM_BACKGROUNDENUM   //
#define DVM_GETWORKINGDIR       SFVM_GETWORKINGDIR    //
#define DVM_GETCOLSAVESTREAM    SFVM_GETCOLSAVESTREAM // flags              IStream **
#define DVM_SELECTALL           SFVM_SELECTALL        //                    lSelChangeInfo
#define DVM_DIDDRAGDROP         SFVM_DIDDRAGDROP      // dwEffect           IDataObject *
#define DVM_SUPPORTSIDENTIFY    SFVM_SUPPORTSIDENTITY // -                  -
#define DVM_FOLDERISPARENT      SFVM_FOLDERISPARENT   // -                  pidlChild

// max length for guid strings
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

typedef struct _DVSELCHANGEINFO {
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
    LPARAM* plParam;
} DVSELCHANGEINFO, *PDVSELCHANGEINFO;

typedef HRESULT (CALLBACK * LPFNVIEWCALLBACK)(IShellView *psvOuter,
                                                IShellFolder *psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT            cbSize;
    IShellFolder *  pshf;
    IShellView *    psvOuter;
    LPCITEMIDLIST   pidl;
    LONG            lEvents;
    LPFNVIEWCALLBACK pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE  fvm;
} CSFV, * LPCSFV;

// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE          0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)

// Get the last sorting parameter given to FolderView
#define SFVM_GETARRANGEPARAM    0x00000002
#define ShellFolderView_GetArrangeParam(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETARRANGEPARAM, 0L)

// Add an OBJECT into the view (May need to add insert also)
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)_pidl)

// Gets the count of objects in the view
#define SFVM_GETOBJECTCOUNT         0x00000004
#define ShellFolderView_GetObjectCount(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECTCOUNT, (LPARAM)0)

// Returns a pointer to the Idlist associated with the specified index
// Returns NULL if at end of list.
#define SFVM_GETOBJECT         0x00000005
#define ShellFolderView_GetObject(_hwnd, _iObject) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECT, _iObject)

// Remove an OBJECT into the view (This works by pidl, may need index also);
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)_pidl)

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
//
// _ppidl[1] must be a *copy* of a pidl, as control over the lifetime
// of the pidl belongs to the view after successful completion of
// this call.  (Unsuccessful completion (a -1 return) implies failure
// and the caller must free the memory.)  Win95 waits a while before
// freeing the pidl, IE4 frees the pidl immediately.
// IShellFolderView::UpdateObject does not suffer from this problem.
//
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)_ppidl)

// Sets the redraw mode for the window that is displaying the information
#define SFVM_SETREDRAW           0x00000008
#define ShellFolderView_SetRedraw(_hwnd, fRedraw) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_SETREDRAW, (LPARAM)fRedraw)

// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)ppidl)

// Checks if the current drop is on the view window
//     lparam is unused
//     return value is TRUE if the current drop is upon the background of the
//         view window, FALSE otherwise
#define SFVM_ISDROPONSOURCE     0x0000000a
#define ShellFolderView_IsDropOnSource(_hwnd, _pdtgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISDROPONSOURCE, (LPARAM)_pdtgt)

// Moves the selected icons in the listview
//     lparam is a pointer to a drop target
//     return value is unused
#define SFVM_MOVEICONS          0x0000000b
#define ShellFolderView_MoveIcons(_hwnd, _pdt) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_MOVEICONS, (LPARAM)(LPDROPTARGET)_pdt)

// Gets the start point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDRAGPOINT       0x0000000c
#define ShellFolderView_GetDragPoint(_hwnd, _ppt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETDRAGPOINT, (LPARAM)(LPPOINT)_ppt)

// Gets the end point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDROPPOINT       0x0000000d
#define ShellFolderView_GetDropPoint(_hwnd, _ppt) \
        SHShellFolderView_Message(_hwnd, SFVM_GETDROPPOINT, (LPARAM)(LPPOINT)_ppt)

#define ShellFolderView_GetAnchorPoint(_hwnd, _fStart, _ppt) \
        (BOOL)((_fStart) ? ShellFolderView_GetDragPoint(_hwnd, _ppt) : ShellFolderView_GetDropPoint(_hwnd, _ppt))

typedef struct _SFV_SETITEMPOS
{
        LPCITEMIDLIST pidl;
        POINT pt;
} SFV_SETITEMPOS, *LPSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS         0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{       SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
        SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}

// Determines if a given drop target interface is the one being used for
// the background of the ShellFolderView (as opposed to an object in the
// view)
//     lparam is a pointer to a drop target interface
//     return value is TRUE if it is the background drop target, FALSE otherwise
#define SFVM_ISBKDROPTARGET     0x0000000f
#define ShellFolderView_IsBkDropTarget(_hwnd, _pdptgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISBKDROPTARGET, (LPARAM)(LPDROPTARGET)_pdptgt)

//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//  called by defcm.c when it does a copy/cut
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))


// sets auto arrange
#define SFVM_AUTOARRANGE        0x00000011
#define ShellFolderView_AutoArrange(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_AUTOARRANGE, 0)

// sets snap to grid
#define SFVM_ARRANGEGRID        0x00000012
#define ShellFolderView_ArrangeGrid(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_ARRANGEGRID, 0)

#define SFVM_GETAUTOARRANGE     0x00000013
#define ShellFolderView_GetAutoArrange(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETAUTOARRANGE, 0)

#define SFVM_GETSELECTEDCOUNT     0x00000014
#define ShellFolderView_GetSelectedCount(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDCOUNT, 0)

typedef ITEMSPACING *LPITEMSPACING;

#define SFVM_GETITEMSPACING     0x00000015
#define ShellFolderView_GetItemSpacing(_hwnd, lpis) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETITEMSPACING, (LPARAM)lpis)

// Causes an object to be repainted
#define SFVM_REFRESHOBJECT      0x00000016
#define ShellFolderView_RefreshObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REFRESHOBJECT, (LPARAM)_ppidl)

// Causes the the whole view to be refreshed
#define ShellFolderView_RefreshAll(_hwnd) \
        (LPARAM)PostMessage(_hwnd, WM_KEYDOWN, (WPARAM)VK_F5, (LPARAM)0);

#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)_pdtobj)

// SVM_SELECTANDPOSITIONITEM lParam
typedef struct
{
        LPCITEMIDLIST pidl;     // relative pidl to the view
        UINT  uSelectFlags;     // select flags
        BOOL fMove; // if true, we should also move it to point pt
        POINT pt;
} SFM_SAP;

// shell view messages
#define SVM_SELECTITEM                  (WM_USER + 1)
#define SVM_MOVESELECTEDITEMS           (WM_USER + 2)
#define SVM_GETANCHORPOINT              (WM_USER + 3)
#define SVM_GETITEMPOSITION             (WM_USER + 4)
#define SVM_SELECTANDPOSITIONITEM       (WM_USER + 5)

//===========================================================================
// CDefShellFolder members (for easy subclassing)
//===========================================================================

// Default implementation (no dependencies to the instance data)
STDMETHODIMP CDefShellFolder_QueryInterface(IShellFolder *psf, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_BindToStorage(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_BindToObject(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_GetAttributesOf(IShellFolder *psf, UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfOut);
STDMETHODIMP CDefShellFolder_SetNameOf(IShellFolder *psf, HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwReserved, LPITEMIDLIST * ppidlOut);

// File Search APIS
SHSTDAPI_(IContextMenu *) SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);

SHSTDAPI_(void) Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
SHSTDAPI_(void) Control_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow);
SHSTDAPI_(void) Control_RunDLLAsUserW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow);


// to add 16 bit pages to 32bit things.  hGlobal can be NULL
SHSTDAPI_(UINT) SHAddPages16(HGLOBAL hGlobal, LPCTSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

SHSTDAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, IShellView ** ppsv);


// Access to MSHMTL's ditherer

/* Definition of interface: IIntDitherer */
#undef INTERFACE
#define INTERFACE IIntDitherer

DECLARE_INTERFACE_(IIntDitherer, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    // *** IIntDitherer methods ***
    STDMETHOD(DitherTo8bpp)(THIS_ BYTE * pDestBits, LONG nDestPitch,
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc,
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans) PURE;
};

#ifdef COBJMACROS


#define IntDitherer_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IntDitherer_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IntDitherer_Release(This)   \
    (This)->lpVtbl -> Release(This)

#define IntDitherer_DitherTo8bpp(This, pDestBits, nDestPitch, \
                    pSrcBits, nSrcPitch, bfidSrc, \
                    prgbDestColors, prgbSrcColors, \
                    pbDestInvMap, x, y, cx, cy, \
                    lDestTrans, lSrcTrans)  \
    (This)->lpVtbl -> DitherTo8bpp(This, pDestBits, nDestPitch, pSrcBits, nSrcPitch, bfidSrc, \
                    prgbDestColors, prgbSrcColors, pbDestInvMap, x, y, cx, cy, lDestTrans, lSrcTrans)

#endif

//      PID_IS_SCHEME       [VT_UI4]      Scheme value
#define PID_IS_FIRST         2
#define PID_IS_SCHEME        3
#define PID_IS_IDLIST        14
#define PID_IS_LAST          14
//      PID_INTSITE_FLAGS        [VT_UI4]      PIDISF_ flags
//      PID_INTSITE_CONTENTLEN   [VT_UI4]      Content length
//      PID_INTSITE_CONTENTCODE  [VT_UI8]      Content code
//      PID_INTSITE_FRAGMENT     [VT_NULL]     Fragments
#define PID_INTSITE_FIRST         2
#define PID_INTSITE_FRAGMENT      17
#define PID_INTSITE_LAST          21
  //Is URL entered in IE history bucket?
#define PIDISF_HISTORY          0x10000000
// Athena needs this to determine whether to double click or not.
//
// NOTE: if user uninstalls IE4, the Win95 code will
// realize that the size has changed (even though it's not
// in this struct, it is saved) and drop back to default state.
//
// Since we're exporting this so ISVs can get access to our flags,
// let's avoid the need for a thunk and export the beginning section
// of this structure ONLY. Here are the A and W versions for internal use:
//
typedef struct {
    // These were in Win95 //
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;

    // The below were added for IE4 //
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1; // No longer used, dead bit
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;

    // These were in Win95 Gold
    LPSTR pszHiddenFileExts;
    UINT cbHiddenFileExts;

    // These must have been an OSR release, as they aren't on \\guilo\slmadd\src\dev\inc16\shsemip.h
    LPARAM lParamSort;
    int    iSortDirection;

    // This was added for IE4
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;
    // If you need a new flag, steal a bit from from fSpareFlags.
    UINT fSpareFlags : 15;

    //
    // If you add any fields to this structure, you
    // must also add upgrade code to shell32\util.cpp.
    //
} SHELLSTATEA, * LPSHELLSTATEA;

typedef struct {
    BOOL fShowAllObjects : 1;
    BOOL fShowExtensions : 1;
    BOOL fNoConfirmRecycle : 1;
    BOOL fShowSysFiles : 1;
    BOOL fShowCompColor : 1;
    BOOL fDoubleClickInWebView : 1;
    BOOL fDesktopHTML : 1;
    BOOL fWin95Classic : 1;
    BOOL fDontPrettyPath : 1;
    BOOL fShowAttribCol : 1;
    BOOL fMapNetDrvBtn : 1;
    BOOL fShowInfoTip : 1;
    BOOL fHideIcons : 1;
    BOOL fWebView : 1;
    BOOL fFilter : 1;
    BOOL fShowSuperHidden : 1;

    LPWSTR pszHiddenFileExts;
    UINT   cbHiddenFileExts;

    LPARAM lParamSort;
    int    iSortDirection;
    UINT   version;

    // new for win2k. need notUsed var to calc the right size of ie4 struct
    // FIELD_OFFSET does not work on bit fields
    UINT uNotUsed; // feel free to rename and use
    BOOL fSepProcess: 1;
    // If you need a new flag, steal a bit from from fSpareFlags.
    UINT fSpareFlags : 15;

    //
    // If you add any fields to this structure, you
    // must also add upgrade code to shell32\util.cpp.
    //
} SHELLSTATEW, * LPSHELLSTATEW;

#define SHELLSTATEVERSION_IE4 9
#define SHELLSTATEVERSION 10 // rev if defaults change but size doesn't //

#ifdef UNICODE
#define SHELLSTATE   SHELLSTATEW
#define LPSHELLSTATE LPSHELLSTATEW
#else
#define SHELLSTATE   SHELLSTATEA
#define LPSHELLSTATE LPSHELLSTATEA
#endif

#define SHELLSTATE_SIZE_WIN95 FIELD_OFFSET(SHELLSTATE,lParamSort)
#define SHELLSTATE_SIZE_NT4   FIELD_OFFSET(SHELLSTATE,version)
#define SHELLSTATE_SIZE_IE4   FIELD_OFFSET(SHELLSTATE,uNotUsed)
#define SHELLSTATE_SIZE_WIN2K sizeof(SHELLSTATE)

SHSTDAPI_(void) SHGetSetSettings(LPSHELLSTATE lpss, DWORD dwMask, BOOL bSet);

// And here's the beginning portion for public use:
#define SSF_HIDDENFILEEXTS          0x00000004  //
#define SSF_SORTCOLUMNS             0x00000010  //
#define SSF_FILTER                  0x00010000  //
#define SSF_WEBVIEW                 0x00020000  //
#define SSF_SHOWSUPERHIDDEN         0x00040000  //
#define SSF_SEPPROCESS              0x00080000  //

//--------------------------------------------------------------------------
//
// Interface used for exposing the INI file methods on a shortcut file
//
//
//--------------------------------------------------------------------------
#undef  INTERFACE
#define INTERFACE  INamedPropertyBag
DECLARE_INTERFACE_(INamedPropertyBag, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    // *** INamedPropertyBag methods ***
    STDMETHOD(ReadPropertyNPB) (THIS_  /* [in] */ LPCOLESTR pszBagname,
                            /* [in] */ LPCOLESTR pszPropName,
                            /* [out][in] */ PROPVARIANT *pVar) PURE;

    STDMETHOD(WritePropertyNPB)(THIS_ /* [in] */ LPCOLESTR pszBagname,
                           /* [in] */ LPCOLESTR pszPropName,
                           /* [in] */ PROPVARIANT  *pVar) PURE;

    STDMETHOD(RemovePropertyNPB)(THIS_ /* [in] */ LPCOLESTR pszBagname,
                          /* [in] */ LPCOLESTR pszPropName) PURE;
};
//-------------------------------------------------------------------------
//
// IShellMenuCallback interface
//
//
// [Member functions]
//
//  TBD
//
//-------------------------------------------------------------------------

#ifndef RC_INVOKED
#include <pshpack8.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

typedef struct _tagSMDATA
{
    DWORD   dwMask;             // SMDM_* values
    DWORD   dwFlags;            // Not used
    HMENU   hmenu;              // Static HMENU portion.
    HWND    hwnd;               // HWND owning the HMENU
    UINT    uId;                // Id of the item in the menu (-1 for menu itself)
    UINT    uIdParent;          // Id of the item spawning this menu
    UINT    uIdAncestor;        // Id of the very top item in the chain of ShellFolders
    IUnknown*    punk;          // IUnkown of the menuband
    LPITEMIDLIST   pidlFolder;  // pidl of the ShellFolder portion
    LPITEMIDLIST   pidlItem;    // pidl of the item in the ShellFolder portion
    IShellFolder*   psf;        // IShellFolder for the shell folder portion

    void*   pvUserData;         // User defined Data associated with a pane.

} SMDATA, *LPSMDATA;

#ifndef RC_INVOKED
#include <poppack.h>   /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

// Mask
#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band
#define SMDM_HMENU                     0x00000002  // This is for the Band itself

// Flags (bitmask)
typedef struct
{
    DWORD   dwMask;     // SMIM_*
    DWORD   dwType;     // SMIT_*
    DWORD   dwFlags;    // SMIF_*
    int     iIcon;
} SMINFO, * PSMINFO;

typedef struct
{
    LONG            lEvent;     // Change notify Event
    LPCITEMIDLIST   pidl1;      // Pidl 1 Passed in from the Change notify
    LPCITEMIDLIST   pidl2;      // Pidl 2 Passed in from the Change notify
} SMCSHCHANGENOTIFYSTRUCT, *PSMCSHCHANGENOTIFYSTRUCT;

// Mask flags
enum
{
    SMIM_TYPE           = 0x00000001,
    SMIM_FLAGS          = 0x00000002,
    SMIM_ICON           = 0x00000004
};

// Types for mbiinfo.dwType
enum
{
    SMIT_SEPARATOR      = 0x00000001,
    SMIT_STRING         = 0x00000002
};

// Flags for mbiinfo.dwFlags
enum
{
    SMIF_ICON           = 0x00000001,       // Show an icon
    SMIF_ACCELERATOR    = 0x00000002,       // Underline the character marked w/ '&'
    SMIF_DROPTARGET     = 0x00000004,       // Item is a drop target
    SMIF_SUBMENU        = 0x00000008,       // Item has a submenu
    SMIF_VOLATILE       = 0x00000010,       // Obsolete.
    SMIF_CHECKED        = 0x00000020,       // Item has a Checkmark
    SMIF_DROPCASCADE    = 0x00000040,       // Item can cascade out during drag/drop
    SMIF_HIDDEN         = 0x00000080,       // Don't display item
    SMIF_DISABLED       = 0x00000100,       // Should be unselectable. Grey.
    SMIF_TRACKPOPUP     = 0x00000200,       // Should be unselectable. Grey.
    SMIF_DEMOTED        = 0x00000400,       // Display item in "Demoted" state.
    SMIF_ALTSTATE       = 0x00000800,       // Displayed in "Altered State"
};

// Messages
//
//  SMC_INITMENU        Sent when a menu is shown.
//
//
//  SMC_GETOBJECT
//    wParam = riid
//    lParam = ppv
//      Sent to get an object that supports riid.
//
#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband
#define SMC_CREATE              0x00000002
#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing
#define SMC_EXEC                0x00000004  // The callback is called to execute an item
#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values
#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values
#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object
#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object
#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item
#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected
#define SMC_SELECTITEM          0x0000000B  // The callback is called when an item is selected
#define SMC_GETSFINFOTIP        0x0000000C  // The callback is called to get some object
#define SMC_GETINFOTIP          0x0000000D  // The callback is called to get some object
#define SMC_INSERTINDEX         0x0000000E  // New item insert index
#define SMC_POPUP               0x0000000F  // InitMenu/InitMenuPopup (sort of)
#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.
#define SMC_DEMOTE              0x00000011  // Demote an item
#define SMC_PROMOTE             0x00000012  // Promote an item
#define SMC_BEGINENUM           0x00000013  // tell callback that we are beginning to ENUM the indicated parent
#define SMC_ENDENUM             0x00000014  // tell callback that we are ending the ENUM of the indicated paren
#define SMC_MAPACCELERATOR      0x00000015  // Called when processing an accelerator.
#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam
#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.
#define SMC_GETMINPROMOTED      0x00000018  // Returns the minimum number of promoted items
#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron
#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.
#define SMC_DESTROY             0x0000002B  // Called when a pane is being destroyed.
#define SMC_SETOBJECT           0x0000002C  // Called to save the passed object
#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object
#define SMC_SHCHANGENOTIFY      0x0000002E	// Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT
#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH
#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.
#define SMC_FILTERPIDL          0x10000000  // The callback is called to see if an item is visible
#define SMC_CALLBACKMASK        0xF0000000  // Mask of comutationally intense messages


#undef  INTERFACE
#define INTERFACE   IShellMenuCallback

DECLARE_INTERFACE_(IShellMenuCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMenuCallback methods ***
    STDMETHOD(CallbackSM)         (THIS_ LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
};

//-------------------------------------------------------------------------
//
// IMenuBand interface
//
//   This interface provides methods the menuband (CLSID_MenuBand)
//  to receive pertinent messages.
//
// [Member functions]
//
// IMenuBand::IsMenuMessage(pmsg)
//   A message pump calls this function to see if any messages need
//   to be redirected to this object.  If this returns S_OK, the
//   message loop should not call TranslateMessage or DispatchMessage.
//   If this returns E_FAIL, the menu has exited menu mode and is ready
//   to be destroyed.
//
// IMenuBand::TranslateMenuMessage(pmsg, plRet)
//   Offers the object an opportunity to translate messages.  The
//   parent window proc must call this method for every message (not
//   the message pump).  The message, wParam, and lParam should be
//   delivered to this method in *pmsg.  This method may change the
//   values of pmsg->wParam or pmsg->lParam, in which case these changes
//   should be forwarded on.
//
//   This method is required because some modal message pumps (like the one
//   in TrackPopupMenu) do not give an opportunity to call a custom
//   TranslateAccelerator method like IInputObject::TranslateAcceleratorIO.
//
//   TranslateMenuMessage returns S_OK if the message was handled and
//   should be eaten.  *plRet is not touched if this returns S_FALSE.
//
//
//-------------------------------------------------------------------------

// CmdIDs for the IOleCommandTarget Group: CGID_MenuBandHandler (defined in shguidp.h)
#define MBHANDCID_PIDLSELECT    0           // A PIDL from a menuband was selected

#undef  INTERFACE
#define INTERFACE   IMenuBand

DECLARE_INTERFACE_(IMenuBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IMenuBand methods ***
    STDMETHOD(IsMenuMessage)    (THIS_ MSG * pmsg) PURE;
    STDMETHOD(TranslateMenuMessage) (THIS_ MSG * pmsg, LRESULT * plRet) PURE;
};



//-------------------------------------------------------------------------
//
// IShellMenu interface
//
//-------------------------------------------------------------------------

#define SMINIT_DEFAULT              0x00000000  // No Options
#define SMINIT_RESTRICT_CONTEXTMENU 0x00000001  // Don't allow Context Menus
#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop
#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.
#define SMINIT_DEFAULTTOTRACKPOPUP  0x00000008  // When no callback is specified,
                                                // default all HMENU items to Trackpopup
#define SMINIT_CACHED               0x00000010
#define SMINIT_USEMESSAGEFILTER     0x00000020
#define SMINIT_LEGACYMENU           0x00000040  // Old Menu behaviour.

// Internal Menuband setting
#define SMINIT_NOSETSITE            0x00010000  // Internal setting

// These are mutually Exclusive
#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu
#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)
#define SMINIT_MULTICOLUMN          0x40000000  // this is a multi column menu

#define ANCESTORDEFAULT      (UINT)-1

#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu
#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu
#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object
                                                  // and should not destroy it.
#define SMSET_MERGE                 0x00000002
#define SMSET_NOEMPTY               0x00000004   // Dont show (Empty) on shell folder
#define SMSET_USEBKICONEXTRACTION   0x00000008   // Use the background icon extractor
#define SMSET_HASEXPANDABLEFOLDERS  0x00000010   // Need to call SHIsExpandableFolder
#define SMSET_DONTREGISTERCHANGENOTIFY 0x00000020 // ShellFolder is a discontiguous child of a parent shell folder
#define SMSET_COLLAPSEONEMPTY       0x00000040   // When Empty, causes a menus to collapse

#define SMINV_REFRESH        0x00000001
#define SMINV_ICON           0x00000002
#define SMINV_POSITION       0x00000004
#define SMINV_ID             0x00000008
#define SMINV_NEXTSHOW       0x00000010       // Does Invalidates on next show.
#define SMINV_PROMOTE        0x00000020       // Does Invalidates on next show.
#define SMINV_DEMOTE         0x00000040       // Does Invalidates on next show.
#define SMINV_FORCE          0x00000080
#define SMINV_NOCALLBACK     0x00000100       // Invalidates, but does not call the callback.

#undef  INTERFACE
#define INTERFACE   IShellMenu

DECLARE_INTERFACE_(IShellMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMenu methods ***
    STDMETHOD(Initialize)(THIS_ IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags) PURE;
    STDMETHOD(GetMenuInfo)(THIS_ IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags) PURE;
    STDMETHOD(SetShellFolder)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags) PURE;
    STDMETHOD(GetShellFolder)(THIS_ DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppv) PURE;
    STDMETHOD(SetMenu)(THIS_ HMENU hmenu, HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(GetMenu)(THIS_ HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) PURE;
    STDMETHOD(InvalidateItem)(THIS_ LPSMDATA psmd, DWORD dwFlags) PURE;
    STDMETHOD(GetState)(THIS_ LPSMDATA psmd) PURE;
    STDMETHOD(SetMenuToolbar)(THIS_ IUnknown* punk, DWORD dwFlags) PURE;
};



#undef  INTERFACE
#define INTERFACE   ITrackShellMenu

DECLARE_INTERFACE_(ITrackShellMenu, IShellMenu)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMenu methods ***
    STDMETHOD(Initialize)(THIS_ IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags) PURE;
    STDMETHOD(GetMenuInfo)(THIS_ IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags) PURE;
    STDMETHOD(SetShellFolder)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags) PURE;
    STDMETHOD(GetShellFolder)(THIS_ DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppv) PURE;
    STDMETHOD(SetMenu)(THIS_ HMENU hmenu, HWND hwnd, DWORD dwFlags) PURE;
    STDMETHOD(GetMenu)(THIS_ HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) PURE;
    STDMETHOD(InvalidateItem)(THIS_ LPSMDATA psmd, DWORD dwFlags) PURE;
    STDMETHOD(GetState)(THIS_ LPSMDATA psmd) PURE;
    STDMETHOD(SetMenuToolbar)(THIS_ IUnknown* punk, DWORD dwFlags) PURE;

    // *** ITrackShellMenu methods ***
    STDMETHOD(SetObscured)(THIS_ HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags) PURE;
    STDMETHOD(Popup)(THIS_ HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) PURE;
};

//-------------------------------------------------------------------------
//
// IMenuPopup interface
//
//   This interface provides methods to navigate thru a menu.
//
// [Member functions]
//
// IMenuPopup::Popup(ppt, prcExclude, dwFlags)
//   Invoke the menu, located at the point *ppt (in screen coordinates).
//   The optional prcExclude points to the rectangle to exclude when
//   positioning the menu, otherwise it should be NULL.  dwFlags may be:
//
//      MDBPU_SETFOCUS: the menu can take the focus.
//
//   Returns S_OK if the object implements the popup menu as a modeless
//   menu.  Otherwise it returns S_FALSE, and the menu is finished.
//
// IMenuPopup::OnSelect(dwSelectType)
//   This method handles selection notifications.
//
// IMenuPopup::SetSubMenu(pmp, fSet)
//   Sets the given menu bar interface to be the submenu of this
//   object's interface.  Set fSet == FALSE to remove the submenu.
//
//-------------------------------------------------------------------------

// Type values for IMenuPopup::OnSelect
enum
{
    MPOS_EXECUTE = 0,           // Execute the selected menu item
    MPOS_FULLCANCEL,            // Cancel the entire menu
    MPOS_CANCELLEVEL,           // Cancel the current cascaded menu
    MPOS_SELECTLEFT,            // select one to the left of the cur selection
    MPOS_SELECTRIGHT,           // select one to the right of the cur selection
    MPOS_CHILDTRACKING          // the child got a tracking select (mouse moved over)
};

// Flags for IMenuPopup::Popup
enum
{
    MPPF_SETFOCUS       = 0x00000001,    // Menu can take the focus
    MPPF_INITIALSELECT  = 0x00000002,    // Select the first item
    MPPF_NOANIMATE      = 0x00000004,    // Do not animate this show
    MPPF_KEYBOARD       = 0x00000010,    // The menu is activated by keyboard
    MPPF_REPOSITION     = 0x00000020,    // Resposition the displayed bar.
    MPPF_FORCEZORDER    = 0x00000040,    // internal: Tells menubar to ignore Submenu positions
    MPPF_FINALSELECT    = 0x00000080,    // Select the last item
    MPPF_TOP            = 0x20000000,    // Popup menu up from point
    MPPF_LEFT           = 0x40000000,    // Popup menu left from point
    MPPF_RIGHT          = 0x60000000,    // Popup menu right from point
    MPPF_BOTTOM         = 0x80000000,    // Popup menu below point
    MPPF_POS_MASK       = 0xE0000000     // Menu Position Mask
};

#if (_WIN32_IE) >= 0x0400
#undef  INTERFACE
#define INTERFACE   IMenuPopup

DECLARE_INTERFACE_(IMenuPopup, IDeskBar)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS)  PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow)        (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IDeskBarClient methods ***
    STDMETHOD(SetClient)        (THIS_ IUnknown* punkClient) PURE;
    STDMETHOD(GetClient)        (THIS_ IUnknown** ppunkClient) PURE;
    STDMETHOD(OnPosRectChangeDB)(THIS_ LPRECT prc) PURE;

    // *** IMenuPopup methods ***
    STDMETHOD(Popup)            (THIS_ POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) PURE;
    STDMETHOD(OnSelect)         (THIS_ DWORD dwSelectType) PURE;
    STDMETHOD(SetSubMenu)       (THIS_ IMenuPopup* pmp, BOOL fSet) PURE;
};
#endif


//
// Net Access Wizard - called from NetID and WinLogon.
//

#define NAW_NETID              0x00          // called from netid tab
#define NAW_PSWORKGROUP        0x01          // post setup (joined workgroup)
#define NAW_PSDOMAINJOINED     0x02          // post setup (joined domain)
#define NAW_PSDOMAINJOINFAILED 0x03          // post setup (domain joined failed)

STDAPI NetAccessWizard(HWND hwnd, UINT uType, BOOL *pfReboot);
typedef HRESULT (CALLBACK *LPNETACCESSWIZARD)(HWND hwnd, UINT uType, BOOL *pfReboot);

STDAPI ClearAutoLogon(VOID);

//
// Net Places API's called from mpr.
//

typedef enum
{
    NETPLACES_WIZARD_MAPDRIVE = 0,
    NETPLACES_WIZARD_ADDPLACE,
} NETPLACESWIZARDTYPE;

STDAPI_(DWORD)
NetPlacesWizardDoModal(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct,
    NETPLACESWIZARDTYPE npwt,
    BOOL                fIsRoPath
    );

// Definition for the exported function types (for GetProcAddress)
typedef DWORD (STDAPICALLTYPE*NetPlacesWizardDoModal_t)(LPCONNECTDLGSTRUCTW lpConnDlgStruct, NETPLACESWIZARDTYPE npwt, BOOL fIsROPath);

//
// moved here from nettarg.h (shell\inc)
//

// nCmdID
#define CFCID_SETENUMTYPE       0

//nCmdExecOpt
#define CFCOPT_ENUMINCOMING     1
#define CFCOPT_ENUMOUTGOING     2
#define CFCOPT_ENUMALL          3


/****************************************************
 Items to display in the shutdown dialog (dwItems)
 -------------------------------------------------

  These flags can be |'d when passed in. A single
  value will be returned, with NONE indicating an
  error or the user clicked cancel.
  -dsheldon
****************************************************/
#define SHTDN_NONE                      0x000000000
#define SHTDN_LOGOFF                    0x000000001
#define SHTDN_SHUTDOWN                  0x000000002
#define SHTDN_RESTART                   0x000000004
#define SHTDN_RESTART_DOS               0x000000008
#define SHTDN_SLEEP                     0x000000010
#define SHTDN_SLEEP2                    0x000000020
#define SHTDN_HIBERNATE                 0x000000040
#define SHTDN_DISCONNECT                0x000000080

// Shutdown dialog function exported from MSGINA.dll

STDAPI_(DWORD) ShellShutdownDialog(HWND hwndParent, LPCTSTR szUsername, DWORD dwExcludeItems);
typedef DWORD (STDAPICALLTYPE*PFNSHELLSHUTDOWNDIALOG)(HWND hwndParent, LPCTSTR szUsername, DWORD dwExcludeItems);


// Define a clipboard format for a data object to pass a user's SID
// A data object supporting this format is passed to IShellExtInit::Initialize
// before calling IShellPropSheetExt::AddPages.
#define CFSTR_USERPROPPAGESSID TEXT("UserPropertyPagesSid")


// Registry paths where extra IShellPropSheetExt handlers can be put so that
// extended pages are added to the CPL or User Properties
#define REGSTR_USERSANDPASSWORDS_CPL \
/* HKLM\\ */ TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Users and Passwords")
// CLSIDs go in HKLM\Software\Microsoft\Windows\CurrentVersion\Control Panel\Users and Passwords\shellex\PropertySheetHandlers

#define REGSTR_USERPROPERTIES_SHEET \
/* HKLM\\ */ TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Users and Passwords\\User Properties")
// CLSIDs go in HKLM\Software\Microsoft\Windows\CurrentVersion\Control Panel\Users and Passwords\User Properties\shellex\PropertySheetHandlers

//  SHStgOpenStorage()
//  Wrap of StgOpenStorage for binding to file-based storage.
//
//  pszPath,     // storage path
//  grfMode,     // STGM_ flags.  Note: if requesting a stream or property set, use STGM_DIRECT|STGM_SHARE_EXCLUSIVE.
//  grfAttr,     // reserved for future use.
//  grfFileAttr, // win32 file attributes, if available; otherwise zero.
//  riid,        // interface requested
//  ppvObj       // receives address of storage object
//
STDAPI SHStgOpenStorageA(IN LPCSTR pszPath, IN OPTIONAL DWORD grfMode, IN OPTIONAL DWORD grfAttr, IN OPTIONAL DWORD grfFileAttr, REFIID riid, OUT void ** ppvObj);
//  riid,        // interface requested
//  ppvObj       // receives address of storage object
//
STDAPI SHStgOpenStorageW(IN LPCWSTR pszPath, IN OPTIONAL DWORD grfMode, IN OPTIONAL DWORD grfAttr, IN OPTIONAL DWORD grfFileAttr, REFIID riid, OUT void ** ppvObj);
#ifdef UNICODE
#define SHStgOpenStorage  SHStgOpenStorageW
#else
#define SHStgOpenStorage  SHStgOpenStorageA
#endif // !UNICODE


//  SHPropStgCreate()
//  Wrap of IPropertySetStorage::Open/Create
//
//  This function ensures proper handling of code page retrieval/assignment
//  for the requested property set operation.
//
//  psstg,          //  Address of IPropertySetStorage vtable
//  fmtid,          //  property set ID
//  pclsid,         //  class ID associated with the set. This can be NULL
//  grfFlags,       //  PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                    //  PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT.
//  grfMode,        //  STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
//  dwDisposition,  //  OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, or CREATE_ALWAYS
//  IPropertyStorage** ppstg,  // Address to receive requested vtable
//  puCodePage      //  Optional address to receive the code page ID for the set.
//
STDAPI SHPropStgCreate( IPropertySetStorage* psstg, REFFMTID fmtid, CLSID* pclsid, DWORD grfFlags, DWORD grfMode, DWORD dwDisposition, OUT IPropertyStorage** ppstg, OUT OPTIONAL UINT* puCodePage );


//  SHPropStgReadMultiple()
//  IPropertyStorage::ReadMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,       // address of IPropertyStorage vtable.
//  uCodePage, //Code page value retrieved from SHCreatePropertySet
//  cpspec,    //Count of properties being read
//  rgpspec,   //Array of the properties to be read
//  rgvar      //Array of PROPVARIANTs containing the property values on return
//
STDAPI SHPropStgReadMultiple( IPropertyStorage* pps, UINT uCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[] );


//  SHPropStgWriteMultiple()
//  IPropertyStorage::WriteMultiple wrap
//
//  The wrap ensures ANSI/UNICODE translations are handled properly for
//  legacy property sets.
//
//  pps,        // address of IPropertyStorage vtable.
//  puCodePage, // (in, out) address of code page value retrieved from SHCreatePropertySet.
//  cpspec,     // The number of properties being set
//  rgpspec,    // Property specifiers
//  rgvar,      // Array of PROPVARIANT values
//  propidNameFirst // Minimum value for property identifiers. This value should be >= PID_FIRST_USABLE
//
STDAPI SHPropStgWriteMultiple( IPropertyStorage* pps, UINT* puCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[], PROPID propidNameFirst );

//  SHIsLegacyAnsiProperty()
//
//  Determine whether the property is a legacy ANSI property, and if so,
//  compute a conversion type for the property.
//
//  fmtid,     // property set identifier
//  propid,    // property identifier
//  pvt,       // optional:  if non-null, contains on input the VARTYPE for the property; on output,
               //            the converted type.  (e.g., VT_LPSTR <--> VT_LPWSTR).

STDAPI_(BOOL) SHIsLegacyAnsiProperty( REFFMTID fmtid, PROPID propid, IN OUT OPTIONAL VARTYPE* pvt );



//-------------------------------------------------------------------------//
//  linkwnd.h - declaration of LinkWindow control
//
//  LinkWindow supports HTML-like embedded links in the caption text.
//  (e.g. "<a>Click Here</a> to see something cool"
//
//  An unlimited number of embedded links are supported.   When the user clicks
//  on a link, an WM_NOTIFY - LWN_CLICK notification message is sent to the
//  parent window.   The message data includes the zero-based index
//  (left to right orientation) of the link that was clicked.
//
//  (BUGBUG: need to add link-identifier support to accommodate right-to-left
//  captions, <a id:Foo>Click Here</a> ).
//
//  scotthan: author/owner
//  dsheldon: moved this to shlobjp.h. Eventually destined for comctl32.

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48
#define LINKWINDOW_CLASS    TEXT("Link Window")

#define LWIF_ITEMINDEX  0x00000001
#define LWIF_STATE      0x00000002
#define LWIF_ITEMID     0x00000004
#define LWIF_URL        0x00000008

#define LWIS_FOCUSED    0x0001
#define LWIS_ENABLED    0x0002
#define LWIS_VISITED    0x0004

//  BUGBUG: we've got to change the following definition to
//  wininet.h::INTERNET_MAX_URL_LENGTH.
//  Currently, this breaks various dependents.
#define LW_MAX_URL_LENGTH   (2048 + 32 + sizeof("://"))

//  LWITEM
typedef struct tagLWITEMA {
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    CHAR        szID[MAX_LINKID_TEXT] ;
    CHAR        szUrl[LW_MAX_URL_LENGTH] ;   //bugbug: INTERNET_MAX_URL_LENGTH
} LWITEMA, FAR* LPLWITEMA ;

typedef struct tagLWITEMW {
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    WCHAR       szID[MAX_LINKID_TEXT] ;
    WCHAR       szUrl[LW_MAX_URL_LENGTH] ;  //bugbug: INTERNET_MAX_URL_LENGTH
} LWITEMW, FAR* LPLWITEMW ;

//  LWHITTESTINFO
typedef struct tagLWHITTESTINFOA {
    POINT       pt ;
    LWITEMA     item ;
} LWHITTESTINFOA, FAR* LPLWHITTESTINFOA ;

//  LWHITTESTINFO
typedef struct tagLWHITTESTINFOW {
    POINT       pt ;
    LWITEMW     item ;
} LWHITTESTINFOW, FAR* LPLWHITTESTINFOW ;

//  NMLINKWND
typedef struct tagNMLINKWNDA {
    NMHDR       hdr;
    LWITEMA     item ;
} NMLINKWNDA, FAR *LPNMLINKWNDA;

typedef struct tagNMLINKWNDW {
    NMHDR       hdr;
    LWITEMW     item ;
} NMLINKWNDW, FAR *LPNMLINKWNDW;

#ifdef UNICODE
#define LWITEM          LWITEMW
#define LPLWITEM        LPLWITEMW
#define LWHITTESTINFO   LWHITTESTINFOW
#define LPLWHITTESTINFO LPLWHITTESTINFOW
#define NMLINKWND       NMLINKWNDW
#define LPNMLINKWND     LPNMLINKWNDW
#else //UNICODE
#define LWITEM          LWITEMA
#define LPLWITEM        LPLWITEMA
#define LWHITTESTINFO   LWHITTESTINFOA
#define LPLWHITTESTINFO LPLWHITTESTINFOA
#define NMLINKWND       NMLINKWNDA
#define LPNMLINKWND     LPNMLINKWNDA
#endif //UNICODE

//  LinkWindow notifications
//  NM_CLICK   // wParam: n/a, lParam: LPLWITEM, ret: ignored.

//  LinkWindow messages
#define LWM_HITTEST         (WM_USER+0x300)  // wParam: n/a, lparam: LPLWHITTESTINFO, ret: BOOL
#define LWM_GETIDEALHEIGHT  (WM_USER+0x301)  // wParam: n/a, lparam: n/a, ret: cy
#define LWM_SETITEM        (WM_USER+0x302)  // wParam: n/a, lparam: LWITEM*, ret: BOOL
#define LWM_GETITEM        (WM_USER+0x303)  // wParam: n/a, lparam: LWITEM*, ret: BOOL
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  grpbtn.h - declaration of GroupButton control
//
//  GroupButton is a variation of a group box control but supports a link-like
//  caption bar, and optionally, can be buddied to a containee window for
//  auto-positioning behavior.
//
//  scotthan: author/owner
//            (Eventually destined for comctl32.)

#define GROUPBUTTON_CLASS  TEXT("GroupButton")

EXTERN_C ATOM WINAPI GroupButton_RegisterClass() ;
EXTERN_C BOOL WINAPI GroupButton_UnregisterClass() ;

typedef struct tagGBPLACEMENT
{
    LONG x ;            // in: top left; -1 to ignore
    LONG y ;            // in: top right; -1 to ignore
    LONG cx ;           // in: width to assign; -1 to ignore.
                        //     If cx != -1, cxContain and cxMax are ignored.
    LONG cy ;           // in: height to assign; -1 to ignore.
                        //     If cy != -1, cyContain and cyMax are ignored.
    LONG cxBuddy ;      // in: width of buddy area; -1 to ignore
    LONG cyBuddy ;      // in: height of buddy area; -1 to ignore
    LONG cxBuddyMargin ;// in: width of buddy margin; -1 to ignore
    LONG cyBuddyMargin ;// in: height of buddy margin; -1 to ignore
    RECT rcBuddy ;      // out: new buddy rect in parent coords.
    RECT rcWindow ;     // out: new window rect in parent coords.
    HDWP hdwp ;         // optional in: Non-NULL => DeferWindowPos,
                        //              NULL => SetWindowPos
} GBPLACEMENT, *PGBPLACEMENT, *LPGBPLACEMENT ;

//  Buddy flags
#define GBBF_HRESIZE   0x00000001
#define GBBF_VRESIZE   0x00000002
#define GBBF_HSCROLL   0x00000004
#define GBBF_VSCROLL   0x00000008
#define GBBF_HSLAVE    0x00000010
#define GBBF_VSLAVE    0x00000020

//  Group button messages
#define GBM_FIRST        (WM_USER+0x400) // arbitrary
#define GBM_SETPLACEMENT (GBM_FIRST+0)   // WPARAM: n/a, LPARAM: PGBPLACEMENT, return: BOOL
#define GBM_SETBUDDY     (GBM_FIRST+1)   // WPARAM: HWND hwndBuddy, LPARAM: dwBuddyFlags, return: BOOL
#define GBM_GETBUDDY     (GBM_FIRST+2)   // WPARAM: n/a, LPARAM: n/a, return: HWND
#define GBM_SETDROPSTATE (GBM_FIRST+3)   // WPARAM: BOOL fDropped, LPARAM: n/a, return: BOOL
#define GBM_GETDROPSTATE (GBM_FIRST+4)   // WPARAM: n/a, LPARAM: n/a, return: BOOL fDropped
#define GBM_LAST         GBM_GETDROPSTATE

typedef struct tagGBNQUERYBUDDYSIZE
{
    NMHDR   hdr;
    LONG    cx ;
    LONG    cy ;
} GBNQUERYBUDDYSIZE, *LPGBNQUERYBUDDYSIZE, *PGBNQUERYBUDDYSIZE ;

//  Group button notifications
#define GBN_FIRST               2000U
#define GBN_LAST                2020U
#define GBN_QUERYBUDDYHEIGHT    (GBN_FIRST+0)   // LPARAM: LPGBNQUERYBUDDYSIZE
#define GBN_QUERYBUDDYWIDTH     (GBN_FIRST+1)   // LPARAM: LPGBNQUERYBUDDYSIZE.

//-------------------------------------------------------------------------//
#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifndef RC_INVOKED
#include <poppack.h>
#endif  /* !RC_INVOKED */
#endif // _SHLOBJP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\shldispp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Jan 24 20:18:24 2001
 */
/* Compiler settings for shldispp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shldispp_h__
#define __shldispp_h__

/* Forward Declarations */ 

#ifndef __IFolderViewOC_FWD_DEFINED__
#define __IFolderViewOC_FWD_DEFINED__
typedef interface IFolderViewOC IFolderViewOC;
#endif 	/* __IFolderViewOC_FWD_DEFINED__ */


#ifndef __DShellFolderViewEvents_FWD_DEFINED__
#define __DShellFolderViewEvents_FWD_DEFINED__
typedef interface DShellFolderViewEvents DShellFolderViewEvents;
#endif 	/* __DShellFolderViewEvents_FWD_DEFINED__ */


#ifndef __ShellFolderViewOC_FWD_DEFINED__
#define __ShellFolderViewOC_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderViewOC ShellFolderViewOC;
#else
typedef struct ShellFolderViewOC ShellFolderViewOC;
#endif /* __cplusplus */

#endif 	/* __ShellFolderViewOC_FWD_DEFINED__ */


#ifndef __DFConstraint_FWD_DEFINED__
#define __DFConstraint_FWD_DEFINED__
typedef interface DFConstraint DFConstraint;
#endif 	/* __DFConstraint_FWD_DEFINED__ */


#ifndef __ISearchCommandExt_FWD_DEFINED__
#define __ISearchCommandExt_FWD_DEFINED__
typedef interface ISearchCommandExt ISearchCommandExt;
#endif 	/* __ISearchCommandExt_FWD_DEFINED__ */


#ifndef __FolderItem_FWD_DEFINED__
#define __FolderItem_FWD_DEFINED__
typedef interface FolderItem FolderItem;
#endif 	/* __FolderItem_FWD_DEFINED__ */


#ifndef __FolderItems_FWD_DEFINED__
#define __FolderItems_FWD_DEFINED__
typedef interface FolderItems FolderItems;
#endif 	/* __FolderItems_FWD_DEFINED__ */


#ifndef __FolderItemVerb_FWD_DEFINED__
#define __FolderItemVerb_FWD_DEFINED__
typedef interface FolderItemVerb FolderItemVerb;
#endif 	/* __FolderItemVerb_FWD_DEFINED__ */


#ifndef __FolderItemVerbs_FWD_DEFINED__
#define __FolderItemVerbs_FWD_DEFINED__
typedef interface FolderItemVerbs FolderItemVerbs;
#endif 	/* __FolderItemVerbs_FWD_DEFINED__ */


#ifndef __Folder_FWD_DEFINED__
#define __Folder_FWD_DEFINED__
typedef interface Folder Folder;
#endif 	/* __Folder_FWD_DEFINED__ */


#ifndef __Folder2_FWD_DEFINED__
#define __Folder2_FWD_DEFINED__
typedef interface Folder2 Folder2;
#endif 	/* __Folder2_FWD_DEFINED__ */


#ifndef __FolderItem2_FWD_DEFINED__
#define __FolderItem2_FWD_DEFINED__
typedef interface FolderItem2 FolderItem2;
#endif 	/* __FolderItem2_FWD_DEFINED__ */


#ifndef __ShellFolderItem_FWD_DEFINED__
#define __ShellFolderItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderItem ShellFolderItem;
#else
typedef struct ShellFolderItem ShellFolderItem;
#endif /* __cplusplus */

#endif 	/* __ShellFolderItem_FWD_DEFINED__ */


#ifndef __FolderItems2_FWD_DEFINED__
#define __FolderItems2_FWD_DEFINED__
typedef interface FolderItems2 FolderItems2;
#endif 	/* __FolderItems2_FWD_DEFINED__ */


#ifndef __IShellLinkDual_FWD_DEFINED__
#define __IShellLinkDual_FWD_DEFINED__
typedef interface IShellLinkDual IShellLinkDual;
#endif 	/* __IShellLinkDual_FWD_DEFINED__ */


#ifndef __IShellLinkDual2_FWD_DEFINED__
#define __IShellLinkDual2_FWD_DEFINED__
typedef interface IShellLinkDual2 IShellLinkDual2;
#endif 	/* __IShellLinkDual2_FWD_DEFINED__ */


#ifndef __ShellLinkObject_FWD_DEFINED__
#define __ShellLinkObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLinkObject ShellLinkObject;
#else
typedef struct ShellLinkObject ShellLinkObject;
#endif /* __cplusplus */

#endif 	/* __ShellLinkObject_FWD_DEFINED__ */


#ifndef __IShellFolderViewDual_FWD_DEFINED__
#define __IShellFolderViewDual_FWD_DEFINED__
typedef interface IShellFolderViewDual IShellFolderViewDual;
#endif 	/* __IShellFolderViewDual_FWD_DEFINED__ */


#ifndef __ShellFolderView_FWD_DEFINED__
#define __ShellFolderView_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellFolderView ShellFolderView;
#else
typedef struct ShellFolderView ShellFolderView;
#endif /* __cplusplus */

#endif 	/* __ShellFolderView_FWD_DEFINED__ */


#ifndef __IShellDispatch_FWD_DEFINED__
#define __IShellDispatch_FWD_DEFINED__
typedef interface IShellDispatch IShellDispatch;
#endif 	/* __IShellDispatch_FWD_DEFINED__ */


#ifndef __IShellDispatch2_FWD_DEFINED__
#define __IShellDispatch2_FWD_DEFINED__
typedef interface IShellDispatch2 IShellDispatch2;
#endif 	/* __IShellDispatch2_FWD_DEFINED__ */


#ifndef __Shell_FWD_DEFINED__
#define __Shell_FWD_DEFINED__

#ifdef __cplusplus
typedef class Shell Shell;
#else
typedef struct Shell Shell;
#endif /* __cplusplus */

#endif 	/* __Shell_FWD_DEFINED__ */


#ifndef __ShellDispatchInproc_FWD_DEFINED__
#define __ShellDispatchInproc_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellDispatchInproc ShellDispatchInproc;
#else
typedef struct ShellDispatchInproc ShellDispatchInproc;
#endif /* __cplusplus */

#endif 	/* __ShellDispatchInproc_FWD_DEFINED__ */


#ifndef __WebViewFolderContents_FWD_DEFINED__
#define __WebViewFolderContents_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebViewFolderContents WebViewFolderContents;
#else
typedef struct WebViewFolderContents WebViewFolderContents;
#endif /* __cplusplus */

#endif 	/* __WebViewFolderContents_FWD_DEFINED__ */


#ifndef __DSearchCommandEvents_FWD_DEFINED__
#define __DSearchCommandEvents_FWD_DEFINED__
typedef interface DSearchCommandEvents DSearchCommandEvents;
#endif 	/* __DSearchCommandEvents_FWD_DEFINED__ */


#ifndef __SearchCommand_FWD_DEFINED__
#define __SearchCommand_FWD_DEFINED__

#ifdef __cplusplus
typedef class SearchCommand SearchCommand;
#else
typedef struct SearchCommand SearchCommand;
#endif /* __cplusplus */

#endif 	/* __SearchCommand_FWD_DEFINED__ */


#ifndef __IFileSearchBand_FWD_DEFINED__
#define __IFileSearchBand_FWD_DEFINED__
typedef interface IFileSearchBand IFileSearchBand;
#endif 	/* __IFileSearchBand_FWD_DEFINED__ */


#ifndef __FileSearchBand_FWD_DEFINED__
#define __FileSearchBand_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileSearchBand FileSearchBand;
#else
typedef struct FileSearchBand FileSearchBand;
#endif /* __cplusplus */

#endif 	/* __FileSearchBand_FWD_DEFINED__ */


#ifndef __IAutoComplete_FWD_DEFINED__
#define __IAutoComplete_FWD_DEFINED__
typedef interface IAutoComplete IAutoComplete;
#endif 	/* __IAutoComplete_FWD_DEFINED__ */


#ifndef __IAutoComplete2_FWD_DEFINED__
#define __IAutoComplete2_FWD_DEFINED__
typedef interface IAutoComplete2 IAutoComplete2;
#endif 	/* __IAutoComplete2_FWD_DEFINED__ */


#ifndef __IAsyncOperation_FWD_DEFINED__
#define __IAsyncOperation_FWD_DEFINED__
typedef interface IAsyncOperation IAsyncOperation;
#endif 	/* __IAsyncOperation_FWD_DEFINED__ */


#ifndef __IBrowserFrameOptions_FWD_DEFINED__
#define __IBrowserFrameOptions_FWD_DEFINED__
typedef interface IBrowserFrameOptions IBrowserFrameOptions;
#endif 	/* __IBrowserFrameOptions_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_shldispp_0000 */
/* [local] */ 


EXTERN_C const IID IID_IAsyncOperation;
#ifndef _SHLDISP_PUB_H_
#define _SHLDISP_PUB_H_



extern RPC_IF_HANDLE __MIDL_itf_shldispp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0000_v0_0_s_ifspec;


#ifndef __Shell32_LIBRARY_DEFINED__
#define __Shell32_LIBRARY_DEFINED__

/* library Shell32 */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("418f4e6a-b903-11d1-b0a6-00c04fc33aa5") 
enum SearchCommandExecuteErrors
    {	SCEE_PATHNOTFOUND	= 1,
	SCEE_MAXFILESFOUND	= SCEE_PATHNOTFOUND + 1,
	SCEE_INDEXSEARCH	= SCEE_MAXFILESFOUND + 1,
	SCEE_CONSTRAINT	= SCEE_INDEXSEARCH + 1,
	SCEE_SCOPEMISMATCH	= SCEE_CONSTRAINT + 1,
	SCEE_CASESENINDEX	= SCEE_SCOPEMISMATCH + 1,
	SCEE_INDEXNOTCOMPLETE	= SCEE_CASESENINDEX + 1
    }	SearchCommandExecuteErrors;





typedef /* [helpstring][uuid] */  DECLSPEC_UUID("35f1a0d0-3e9a-11d2-8499-005345000000") 
enum OfflineFolderStatus
    {	OFS_INACTIVE	= -1,
	OFS_ONLINE	= OFS_INACTIVE + 1,
	OFS_OFFLINE	= OFS_ONLINE + 1,
	OFS_SERVERBACK	= OFS_OFFLINE + 1,
	OFS_DIRTYCACHE	= OFS_SERVERBACK + 1
    }	OfflineFolderStatus;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("742A99A0-C77E-11D0-A32C-00A0C91EEDBA") 
enum ShellFolderViewOptions
    {	SFVVO_SHOWALLOBJECTS	= 0x1,
	SFVVO_SHOWEXTENSIONS	= 0x2,
	SFVVO_SHOWCOMPCOLOR	= 0x8,
	SFVVO_SHOWSYSFILES	= 0x20,
	SFVVO_WIN95CLASSIC	= 0x40,
	SFVVO_DOUBLECLICKINWEBVIEW	= 0x80,
	SFVVO_DESKTOPHTML	= 0x200
    }	ShellFolderViewOptions;

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("CA31EA20-48D0-11CF-8350-444553540000") 
enum ShellSpecialFolderConstants
    {	ssfDESKTOP	= 0,
	ssfPROGRAMS	= 0x2,
	ssfCONTROLS	= 0x3,
	ssfPRINTERS	= 0x4,
	ssfPERSONAL	= 0x5,
	ssfFAVORITES	= 0x6,
	ssfSTARTUP	= 0x7,
	ssfRECENT	= 0x8,
	ssfSENDTO	= 0x9,
	ssfBITBUCKET	= 0xa,
	ssfSTARTMENU	= 0xb,
	ssfDESKTOPDIRECTORY	= 0x10,
	ssfDRIVES	= 0x11,
	ssfNETWORK	= 0x12,
	ssfNETHOOD	= 0x13,
	ssfFONTS	= 0x14,
	ssfTEMPLATES	= 0x15,
	ssfCOMMONSTARTMENU	= 0x16,
	ssfCOMMONPROGRAMS	= 0x17,
	ssfCOMMONSTARTUP	= 0x18,
	ssfCOMMONDESKTOPDIR	= 0x19,
	ssfAPPDATA	= 0x1a,
	ssfPRINTHOOD	= 0x1b,
	ssfLOCALAPPDATA	= 0x1c,
	ssfALTSTARTUP	= 0x1d,
	ssfCOMMONALTSTARTUP	= 0x1e,
	ssfCOMMONFAVORITES	= 0x1f,
	ssfINTERNETCACHE	= 0x20,
	ssfCOOKIES	= 0x21,
	ssfHISTORY	= 0x22,
	ssfCOMMONAPPDATA	= 0x23,
	ssfWINDOWS	= 0x24,
	ssfSYSTEM	= 0x25,
	ssfPROGRAMFILES	= 0x26,
	ssfMYPICTURES	= 0x27,
	ssfPROFILE	= 0x28,
	ssfSYSTEMx86	= 0x29,
	ssfPROGRAMFILESx86	= 0x30
    }	ShellSpecialFolderConstants;


EXTERN_C const IID LIBID_Shell32;

#ifndef __IFolderViewOC_INTERFACE_DEFINED__
#define __IFolderViewOC_INTERFACE_DEFINED__

/* interface IFolderViewOC */
/* [object][dual][oleautomation][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IFolderViewOC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9BA05970-F6A8-11CF-A442-00A0C90A8F39")
    IFolderViewOC : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE SetFolderView( 
            /* [in] */ IDispatch __RPC_FAR *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderViewOCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFolderViewOC __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFolderViewOC __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFolderViewOC __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFolderView )( 
            IFolderViewOC __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdisp);
        
        END_INTERFACE
    } IFolderViewOCVtbl;

    interface IFolderViewOC
    {
        CONST_VTBL struct IFolderViewOCVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderViewOC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderViewOC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderViewOC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderViewOC_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFolderViewOC_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFolderViewOC_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFolderViewOC_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFolderViewOC_SetFolderView(This,pdisp)	\
    (This)->lpVtbl -> SetFolderView(This,pdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IFolderViewOC_SetFolderView_Proxy( 
    IFolderViewOC __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdisp);


void __RPC_STUB IFolderViewOC_SetFolderView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderViewOC_INTERFACE_DEFINED__ */


#ifndef __DShellFolderViewEvents_DISPINTERFACE_DEFINED__
#define __DShellFolderViewEvents_DISPINTERFACE_DEFINED__

/* dispinterface DShellFolderViewEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DShellFolderViewEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("62112AA2-EBE4-11cf-A5FB-0020AFE7292D")
    DShellFolderViewEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DShellFolderViewEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DShellFolderViewEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DShellFolderViewEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DShellFolderViewEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DShellFolderViewEventsVtbl;

    interface DShellFolderViewEvents
    {
        CONST_VTBL struct DShellFolderViewEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DShellFolderViewEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DShellFolderViewEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DShellFolderViewEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DShellFolderViewEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DShellFolderViewEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DShellFolderViewEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DShellFolderViewEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DShellFolderViewEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderViewOC;

#ifdef __cplusplus

class DECLSPEC_UUID("9BA05971-F6A8-11CF-A442-00A0C90A8F39")
ShellFolderViewOC;
#endif

#ifndef __DFConstraint_INTERFACE_DEFINED__
#define __DFConstraint_INTERFACE_DEFINED__

/* interface DFConstraint */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_DFConstraint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a3df050-23bd-11d2-939f-00a0c91eedba")
    DFConstraint : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DFConstraintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DFConstraint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DFConstraint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DFConstraint __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DFConstraint __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            DFConstraint __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            DFConstraint __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pv);
        
        END_INTERFACE
    } DFConstraintVtbl;

    interface DFConstraint
    {
        CONST_VTBL struct DFConstraintVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DFConstraint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DFConstraint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DFConstraint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DFConstraint_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DFConstraint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DFConstraint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DFConstraint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define DFConstraint_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define DFConstraint_get_Value(This,pv)	\
    (This)->lpVtbl -> get_Value(This,pv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE DFConstraint_get_Name_Proxy( 
    DFConstraint __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB DFConstraint_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE DFConstraint_get_Value_Proxy( 
    DFConstraint __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pv);


void __RPC_STUB DFConstraint_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __DFConstraint_INTERFACE_DEFINED__ */


#ifndef __ISearchCommandExt_INTERFACE_DEFINED__
#define __ISearchCommandExt_INTERFACE_DEFINED__

/* interface ISearchCommandExt */
/* [object][oleautomation][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ISearchCommandExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D2EFD50-75CE-11d1-B75A-00A0C90564FE")
    ISearchCommandExt : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearResults( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NavigateToSearchResults( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProgressText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveSearch( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *phr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchFor( 
            /* [in] */ int iFor) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetScopeInfo( 
            /* [in] */ BSTR bsScope,
            /* [out] */ int __RPC_FAR *pdwScopeInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreSavedSearch( 
            /* [in] */ VARIANT __RPC_FAR *pvarFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [optional][in] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [optional][in] */ long Options) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddConstraint( 
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNextConstraint( 
            /* [in] */ VARIANT_BOOL fReset,
            /* [retval][out] */ DFConstraint __RPC_FAR *__RPC_FAR *ppdfc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchCommandExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISearchCommandExt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISearchCommandExt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearResults )( 
            ISearchCommandExt __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateToSearchResults )( 
            ISearchCommandExt __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProgressText )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveSearch )( 
            ISearchCommandExt __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *phr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SearchFor )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ int iFor);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScopeInfo )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ BSTR bsScope,
            /* [out] */ int __RPC_FAR *pdwScopeInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreSavedSearch )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvarFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [optional][in] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [optional][in] */ long Options);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddConstraint )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextConstraint )( 
            ISearchCommandExt __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fReset,
            /* [retval][out] */ DFConstraint __RPC_FAR *__RPC_FAR *ppdfc);
        
        END_INTERFACE
    } ISearchCommandExtVtbl;

    interface ISearchCommandExt
    {
        CONST_VTBL struct ISearchCommandExtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCommandExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchCommandExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchCommandExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchCommandExt_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISearchCommandExt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISearchCommandExt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISearchCommandExt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISearchCommandExt_ClearResults(This)	\
    (This)->lpVtbl -> ClearResults(This)

#define ISearchCommandExt_NavigateToSearchResults(This)	\
    (This)->lpVtbl -> NavigateToSearchResults(This)

#define ISearchCommandExt_get_ProgressText(This,pbs)	\
    (This)->lpVtbl -> get_ProgressText(This,pbs)

#define ISearchCommandExt_SaveSearch(This)	\
    (This)->lpVtbl -> SaveSearch(This)

#define ISearchCommandExt_GetErrorInfo(This,pbs,phr)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbs,phr)

#define ISearchCommandExt_SearchFor(This,iFor)	\
    (This)->lpVtbl -> SearchFor(This,iFor)

#define ISearchCommandExt_GetScopeInfo(This,bsScope,pdwScopeInfo)	\
    (This)->lpVtbl -> GetScopeInfo(This,bsScope,pdwScopeInfo)

#define ISearchCommandExt_RestoreSavedSearch(This,pvarFile)	\
    (This)->lpVtbl -> RestoreSavedSearch(This,pvarFile)

#define ISearchCommandExt_Execute(This,RecordsAffected,Parameters,Options)	\
    (This)->lpVtbl -> Execute(This,RecordsAffected,Parameters,Options)

#define ISearchCommandExt_AddConstraint(This,Name,Value)	\
    (This)->lpVtbl -> AddConstraint(This,Name,Value)

#define ISearchCommandExt_GetNextConstraint(This,fReset,ppdfc)	\
    (This)->lpVtbl -> GetNextConstraint(This,fReset,ppdfc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_ClearResults_Proxy( 
    ISearchCommandExt __RPC_FAR * This);


void __RPC_STUB ISearchCommandExt_ClearResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_NavigateToSearchResults_Proxy( 
    ISearchCommandExt __RPC_FAR * This);


void __RPC_STUB ISearchCommandExt_NavigateToSearchResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_get_ProgressText_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB ISearchCommandExt_get_ProgressText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_SaveSearch_Proxy( 
    ISearchCommandExt __RPC_FAR * This);


void __RPC_STUB ISearchCommandExt_SaveSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_GetErrorInfo_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbs,
    /* [retval][out] */ int __RPC_FAR *phr);


void __RPC_STUB ISearchCommandExt_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_SearchFor_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ int iFor);


void __RPC_STUB ISearchCommandExt_SearchFor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_GetScopeInfo_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ BSTR bsScope,
    /* [out] */ int __RPC_FAR *pdwScopeInfo);


void __RPC_STUB ISearchCommandExt_GetScopeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_RestoreSavedSearch_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvarFile);


void __RPC_STUB ISearchCommandExt_RestoreSavedSearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_Execute_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [optional][in] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
    /* [optional][in] */ long Options);


void __RPC_STUB ISearchCommandExt_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_AddConstraint_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ VARIANT Value);


void __RPC_STUB ISearchCommandExt_AddConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISearchCommandExt_GetNextConstraint_Proxy( 
    ISearchCommandExt __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fReset,
    /* [retval][out] */ DFConstraint __RPC_FAR *__RPC_FAR *ppdfc);


void __RPC_STUB ISearchCommandExt_GetNextConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchCommandExt_INTERFACE_DEFINED__ */


#ifndef __FolderItem_INTERFACE_DEFINED__
#define __FolderItem_INTERFACE_DEFINED__

/* interface FolderItem */
/* [object][dual][oleautomation][helpstring][uuid] */ 

typedef /* [unique] */ FolderItem __RPC_FAR *LPFOLDERITEM;


EXTERN_C const IID IID_FolderItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC32C80-CBE4-11CE-8350-444553540000")
    FolderItem : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetLink( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_GetFolder( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsLink( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFolder( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsFileSystem( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsBrowsable( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ModifyDate( 
            /* [retval][out] */ DATE __RPC_FAR *pdt) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ModifyDate( 
            /* [in] */ DATE dt) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ LONG __RPC_FAR *pul) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Verbs( 
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerb( 
            /* [optional][in] */ VARIANT vVerb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetLink )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetFolder )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsLink )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFolder )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFileSystem )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBrowsable )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModifyDate )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModifyDate )( 
            FolderItem __RPC_FAR * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Verbs )( 
            FolderItem __RPC_FAR * This,
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerb )( 
            FolderItem __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb);
        
        END_INTERFACE
    } FolderItemVtbl;

    interface FolderItem
    {
        CONST_VTBL struct FolderItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItem_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItem_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItem_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItem_put_Name(This,bs)	\
    (This)->lpVtbl -> put_Name(This,bs)

#define FolderItem_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define FolderItem_get_GetLink(This,ppid)	\
    (This)->lpVtbl -> get_GetLink(This,ppid)

#define FolderItem_get_GetFolder(This,ppid)	\
    (This)->lpVtbl -> get_GetFolder(This,ppid)

#define FolderItem_get_IsLink(This,pb)	\
    (This)->lpVtbl -> get_IsLink(This,pb)

#define FolderItem_get_IsFolder(This,pb)	\
    (This)->lpVtbl -> get_IsFolder(This,pb)

#define FolderItem_get_IsFileSystem(This,pb)	\
    (This)->lpVtbl -> get_IsFileSystem(This,pb)

#define FolderItem_get_IsBrowsable(This,pb)	\
    (This)->lpVtbl -> get_IsBrowsable(This,pb)

#define FolderItem_get_ModifyDate(This,pdt)	\
    (This)->lpVtbl -> get_ModifyDate(This,pdt)

#define FolderItem_put_ModifyDate(This,dt)	\
    (This)->lpVtbl -> put_ModifyDate(This,dt)

#define FolderItem_get_Size(This,pul)	\
    (This)->lpVtbl -> get_Size(This,pul)

#define FolderItem_get_Type(This,pbs)	\
    (This)->lpVtbl -> get_Type(This,pbs)

#define FolderItem_Verbs(This,ppfic)	\
    (This)->lpVtbl -> Verbs(This,ppfic)

#define FolderItem_InvokeVerb(This,vVerb)	\
    (This)->lpVtbl -> InvokeVerb(This,vVerb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Application_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Parent_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Name_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE FolderItem_put_Name_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB FolderItem_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Path_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_GetLink_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_GetLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_GetFolder_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItem_get_GetFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsLink_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsFolder_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsFileSystem_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsFileSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_IsBrowsable_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);


void __RPC_STUB FolderItem_get_IsBrowsable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_ModifyDate_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pdt);


void __RPC_STUB FolderItem_get_ModifyDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE FolderItem_put_ModifyDate_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [in] */ DATE dt);


void __RPC_STUB FolderItem_put_ModifyDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Size_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pul);


void __RPC_STUB FolderItem_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItem_get_Type_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItem_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem_Verbs_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);


void __RPC_STUB FolderItem_Verbs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem_InvokeVerb_Proxy( 
    FolderItem __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb);


void __RPC_STUB FolderItem_InvokeVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItem_INTERFACE_DEFINED__ */


#ifndef __FolderItems_INTERFACE_DEFINED__
#define __FolderItems_INTERFACE_DEFINED__

/* interface FolderItems */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("744129E0-CBE5-11CE-8350-444553540000")
    FolderItems : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItems __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItems __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItems __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItems __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } FolderItemsVtbl;

    interface FolderItems
    {
        CONST_VTBL struct FolderItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItems_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItems_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItems_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItems_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItems__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Count_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB FolderItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Application_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItems_get_Parent_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItems_Item_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItems_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FolderItems__NewEnum_Proxy( 
    FolderItems __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB FolderItems__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItems_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerb_INTERFACE_DEFINED__
#define __FolderItemVerb_INTERFACE_DEFINED__

/* interface FolderItemVerb */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08EC3E00-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerb : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DoIt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItemVerb __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItemVerb __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItemVerb __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItemVerb __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItemVerb __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItemVerb __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItemVerb __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoIt )( 
            FolderItemVerb __RPC_FAR * This);
        
        END_INTERFACE
    } FolderItemVerbVtbl;

    interface FolderItemVerb
    {
        CONST_VTBL struct FolderItemVerbVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItemVerb_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItemVerb_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItemVerb_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItemVerb_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItemVerb_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItemVerb_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItemVerb_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItemVerb_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItemVerb_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItemVerb_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItemVerb_DoIt(This)	\
    (This)->lpVtbl -> DoIt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_get_Application_Proxy( 
    FolderItemVerb __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerb_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_get_Parent_Proxy( 
    FolderItemVerb __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerb_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_get_Name_Proxy( 
    FolderItemVerb __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB FolderItemVerb_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItemVerb_DoIt_Proxy( 
    FolderItemVerb __RPC_FAR * This);


void __RPC_STUB FolderItemVerb_DoIt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItemVerb_INTERFACE_DEFINED__ */


#ifndef __FolderItemVerbs_INTERFACE_DEFINED__
#define __FolderItemVerbs_INTERFACE_DEFINED__

/* interface FolderItemVerbs */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItemVerbs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F8352C0-50B0-11CF-960C-0080C7F4EE85")
    FolderItemVerbs : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItemVerb __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItemVerbsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItemVerbs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItemVerbs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItemVerb __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItemVerbs __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } FolderItemVerbsVtbl;

    interface FolderItemVerbs
    {
        CONST_VTBL struct FolderItemVerbsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItemVerbs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItemVerbs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItemVerbs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItemVerbs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItemVerbs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItemVerbs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItemVerbs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItemVerbs_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItemVerbs_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItemVerbs_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItemVerbs_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItemVerbs__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_get_Count_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB FolderItemVerbs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_get_Application_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerbs_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_get_Parent_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerbs_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs_Item_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [optional][in] */ VARIANT index,
    /* [retval][out] */ FolderItemVerb __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB FolderItemVerbs_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FolderItemVerbs__NewEnum_Proxy( 
    FolderItemVerbs __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB FolderItemVerbs__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItemVerbs_INTERFACE_DEFINED__ */


#ifndef __Folder_INTERFACE_DEFINED__
#define __Folder_INTERFACE_DEFINED__

/* interface Folder */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BBCBDE60-C3FF-11CE-8350-444553540000")
    Folder : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ParentFolder( 
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Items( 
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ParseName( 
            /* [in] */ BSTR bName,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewFolder( 
            /* [in] */ BSTR bName,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveHere( 
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyHere( 
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDetailsOf( 
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Folder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Folder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Folder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Folder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Folder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Folder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Folder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Title )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParentFolder )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Items )( 
            Folder __RPC_FAR * This,
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseName )( 
            Folder __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            Folder __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveHere )( 
            Folder __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyHere )( 
            Folder __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDetailsOf )( 
            Folder __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        END_INTERFACE
    } FolderVtbl;

    interface Folder
    {
        CONST_VTBL struct FolderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Folder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Folder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Folder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Folder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Folder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Folder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Folder_get_Title(This,pbs)	\
    (This)->lpVtbl -> get_Title(This,pbs)

#define Folder_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define Folder_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define Folder_get_ParentFolder(This,ppsf)	\
    (This)->lpVtbl -> get_ParentFolder(This,ppsf)

#define Folder_Items(This,ppid)	\
    (This)->lpVtbl -> Items(This,ppid)

#define Folder_ParseName(This,bName,ppid)	\
    (This)->lpVtbl -> ParseName(This,bName,ppid)

#define Folder_NewFolder(This,bName,vOptions)	\
    (This)->lpVtbl -> NewFolder(This,bName,vOptions)

#define Folder_MoveHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> MoveHere(This,vItem,vOptions)

#define Folder_CopyHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> CopyHere(This,vItem,vOptions)

#define Folder_GetDetailsOf(This,vItem,iColumn,pbs)	\
    (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder_get_Title_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB Folder_get_Title_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder_get_Application_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder_get_Parent_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder_get_ParentFolder_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf);


void __RPC_STUB Folder_get_ParentFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_Items_Proxy( 
    Folder __RPC_FAR * This,
    /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_Items_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_ParseName_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ BSTR bName,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB Folder_ParseName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_NewFolder_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ BSTR bName,
    /* [optional][in] */ VARIANT vOptions);


void __RPC_STUB Folder_NewFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_MoveHere_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ VARIANT vItem,
    /* [optional][in] */ VARIANT vOptions);


void __RPC_STUB Folder_MoveHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_CopyHere_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ VARIANT vItem,
    /* [optional][in] */ VARIANT vOptions);


void __RPC_STUB Folder_CopyHere_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder_GetDetailsOf_Proxy( 
    Folder __RPC_FAR * This,
    /* [in] */ VARIANT vItem,
    /* [in] */ int iColumn,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB Folder_GetDetailsOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Folder_INTERFACE_DEFINED__ */


#ifndef __Folder2_INTERFACE_DEFINED__
#define __Folder2_INTERFACE_DEFINED__

/* interface Folder2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_Folder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f0d2d8ef-3890-11d2-bf8b-00c04fb93661")
    Folder2 : public Folder
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Self( 
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OfflineStatus( 
            /* [retval][out] */ LONG __RPC_FAR *pul) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Synchronize( void) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HaveToShowWebViewBarricade( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveToShowWebViewBarricade) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DismissedWebViewBarricade( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct Folder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Folder2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Folder2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Folder2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Title )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParentFolder )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Items )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseName )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewFolder )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ BSTR bName,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveHere )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyHere )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [optional][in] */ VARIANT vOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDetailsOf )( 
            Folder2 __RPC_FAR * This,
            /* [in] */ VARIANT vItem,
            /* [in] */ int iColumn,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Self )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OfflineStatus )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Synchronize )( 
            Folder2 __RPC_FAR * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HaveToShowWebViewBarricade )( 
            Folder2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveToShowWebViewBarricade);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DismissedWebViewBarricade )( 
            Folder2 __RPC_FAR * This);
        
        END_INTERFACE
    } Folder2Vtbl;

    interface Folder2
    {
        CONST_VTBL struct Folder2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Folder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Folder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Folder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Folder2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Folder2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Folder2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Folder2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Folder2_get_Title(This,pbs)	\
    (This)->lpVtbl -> get_Title(This,pbs)

#define Folder2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define Folder2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define Folder2_get_ParentFolder(This,ppsf)	\
    (This)->lpVtbl -> get_ParentFolder(This,ppsf)

#define Folder2_Items(This,ppid)	\
    (This)->lpVtbl -> Items(This,ppid)

#define Folder2_ParseName(This,bName,ppid)	\
    (This)->lpVtbl -> ParseName(This,bName,ppid)

#define Folder2_NewFolder(This,bName,vOptions)	\
    (This)->lpVtbl -> NewFolder(This,bName,vOptions)

#define Folder2_MoveHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> MoveHere(This,vItem,vOptions)

#define Folder2_CopyHere(This,vItem,vOptions)	\
    (This)->lpVtbl -> CopyHere(This,vItem,vOptions)

#define Folder2_GetDetailsOf(This,vItem,iColumn,pbs)	\
    (This)->lpVtbl -> GetDetailsOf(This,vItem,iColumn,pbs)


#define Folder2_get_Self(This,ppfi)	\
    (This)->lpVtbl -> get_Self(This,ppfi)

#define Folder2_get_OfflineStatus(This,pul)	\
    (This)->lpVtbl -> get_OfflineStatus(This,pul)

#define Folder2_Synchronize(This)	\
    (This)->lpVtbl -> Synchronize(This)

#define Folder2_get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade)	\
    (This)->lpVtbl -> get_HaveToShowWebViewBarricade(This,pbHaveToShowWebViewBarricade)

#define Folder2_DismissedWebViewBarricade(This)	\
    (This)->lpVtbl -> DismissedWebViewBarricade(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder2_get_Self_Proxy( 
    Folder2 __RPC_FAR * This,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);


void __RPC_STUB Folder2_get_Self_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE Folder2_get_OfflineStatus_Proxy( 
    Folder2 __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pul);


void __RPC_STUB Folder2_get_OfflineStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder2_Synchronize_Proxy( 
    Folder2 __RPC_FAR * This);


void __RPC_STUB Folder2_Synchronize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE Folder2_get_HaveToShowWebViewBarricade_Proxy( 
    Folder2 __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbHaveToShowWebViewBarricade);


void __RPC_STUB Folder2_get_HaveToShowWebViewBarricade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE Folder2_DismissedWebViewBarricade_Proxy( 
    Folder2 __RPC_FAR * This);


void __RPC_STUB Folder2_DismissedWebViewBarricade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Folder2_INTERFACE_DEFINED__ */


#ifndef __FolderItem2_INTERFACE_DEFINED__
#define __FolderItem2_INTERFACE_DEFINED__

/* interface FolderItem2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("edc817aa-92b8-11d1-b075-00c04fc33aa5")
    FolderItem2 : public FolderItem
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerbEx( 
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExtendedProperty( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItem2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItem2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItem2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetLink )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GetFolder )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsLink )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFolder )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsFileSystem )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBrowsable )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModifyDate )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pdt);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModifyDate )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ DATE dt);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pul);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Verbs )( 
            FolderItem2 __RPC_FAR * This,
            /* [retval][out] */ FolderItemVerbs __RPC_FAR *__RPC_FAR *ppfic);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerb )( 
            FolderItem2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerbEx )( 
            FolderItem2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtendedProperty )( 
            FolderItem2 __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvRet);
        
        END_INTERFACE
    } FolderItem2Vtbl;

    interface FolderItem2
    {
        CONST_VTBL struct FolderItem2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItem2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItem2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItem2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItem2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItem2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItem2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItem2_get_Name(This,pbs)	\
    (This)->lpVtbl -> get_Name(This,pbs)

#define FolderItem2_put_Name(This,bs)	\
    (This)->lpVtbl -> put_Name(This,bs)

#define FolderItem2_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define FolderItem2_get_GetLink(This,ppid)	\
    (This)->lpVtbl -> get_GetLink(This,ppid)

#define FolderItem2_get_GetFolder(This,ppid)	\
    (This)->lpVtbl -> get_GetFolder(This,ppid)

#define FolderItem2_get_IsLink(This,pb)	\
    (This)->lpVtbl -> get_IsLink(This,pb)

#define FolderItem2_get_IsFolder(This,pb)	\
    (This)->lpVtbl -> get_IsFolder(This,pb)

#define FolderItem2_get_IsFileSystem(This,pb)	\
    (This)->lpVtbl -> get_IsFileSystem(This,pb)

#define FolderItem2_get_IsBrowsable(This,pb)	\
    (This)->lpVtbl -> get_IsBrowsable(This,pb)

#define FolderItem2_get_ModifyDate(This,pdt)	\
    (This)->lpVtbl -> get_ModifyDate(This,pdt)

#define FolderItem2_put_ModifyDate(This,dt)	\
    (This)->lpVtbl -> put_ModifyDate(This,dt)

#define FolderItem2_get_Size(This,pul)	\
    (This)->lpVtbl -> get_Size(This,pul)

#define FolderItem2_get_Type(This,pbs)	\
    (This)->lpVtbl -> get_Type(This,pbs)

#define FolderItem2_Verbs(This,ppfic)	\
    (This)->lpVtbl -> Verbs(This,ppfic)

#define FolderItem2_InvokeVerb(This,vVerb)	\
    (This)->lpVtbl -> InvokeVerb(This,vVerb)


#define FolderItem2_InvokeVerbEx(This,vVerb,vArgs)	\
    (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs)

#define FolderItem2_ExtendedProperty(This,bstrPropName,pvRet)	\
    (This)->lpVtbl -> ExtendedProperty(This,bstrPropName,pvRet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem2_InvokeVerbEx_Proxy( 
    FolderItem2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb,
    /* [optional][in] */ VARIANT vArgs);


void __RPC_STUB FolderItem2_InvokeVerbEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItem2_ExtendedProperty_Proxy( 
    FolderItem2 __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvRet);


void __RPC_STUB FolderItem2_ExtendedProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItem2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderItem;

#ifdef __cplusplus

class DECLSPEC_UUID("2fe352ea-fd1f-11d2-b1f4-00c04f8eeb3e")
ShellFolderItem;
#endif

#ifndef __FolderItems2_INTERFACE_DEFINED__
#define __FolderItems2_INTERFACE_DEFINED__

/* interface FolderItems2 */
/* [object][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_FolderItems2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C94F0AD0-F363-11d2-A327-00C04F8EEC7F")
    FolderItems2 : public FolderItems
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeVerbEx( 
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct FolderItems2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            FolderItems2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            FolderItems2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            FolderItems2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            FolderItems2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            FolderItems2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT index,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            FolderItems2 __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeVerbEx )( 
            FolderItems2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vVerb,
            /* [optional][in] */ VARIANT vArgs);
        
        END_INTERFACE
    } FolderItems2Vtbl;

    interface FolderItems2
    {
        CONST_VTBL struct FolderItems2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define FolderItems2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define FolderItems2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define FolderItems2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define FolderItems2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define FolderItems2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define FolderItems2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define FolderItems2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define FolderItems2_get_Count(This,plCount)	\
    (This)->lpVtbl -> get_Count(This,plCount)

#define FolderItems2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define FolderItems2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define FolderItems2_Item(This,index,ppid)	\
    (This)->lpVtbl -> Item(This,index,ppid)

#define FolderItems2__NewEnum(This,ppunk)	\
    (This)->lpVtbl -> _NewEnum(This,ppunk)


#define FolderItems2_InvokeVerbEx(This,vVerb,vArgs)	\
    (This)->lpVtbl -> InvokeVerbEx(This,vVerb,vArgs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE FolderItems2_InvokeVerbEx_Proxy( 
    FolderItems2 __RPC_FAR * This,
    /* [optional][in] */ VARIANT vVerb,
    /* [optional][in] */ VARIANT vArgs);


void __RPC_STUB FolderItems2_InvokeVerbEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __FolderItems2_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDual_INTERFACE_DEFINED__
#define __IShellLinkDual_INTERFACE_DEFINED__

/* interface IShellLinkDual */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellLinkDual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88A05C00-F000-11CE-8350-444553540000")
    IShellLinkDual : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_WorkingDirectory( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_WorkingDirectory( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Arguments( 
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Arguments( 
            /* [in] */ BSTR bs) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Hotkey( 
            /* [retval][out] */ int __RPC_FAR *piHK) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Hotkey( 
            /* [in] */ int iHK) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ShowCommand( 
            /* [retval][out] */ int __RPC_FAR *piShowCommand) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ShowCommand( 
            /* [in] */ int iShowCommand) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ int fFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *piIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIconLocation( 
            /* [in] */ BSTR bs,
            /* [in] */ int iIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vWhere) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellLinkDual __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellLinkDual __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellLinkDual __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkingDirectory )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkingDirectory )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Arguments )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Arguments )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hotkey )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piHK);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Hotkey )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ int iHK);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowCommand )( 
            IShellLinkDual __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piShowCommand);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowCommand )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ int iShowCommand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resolve )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ int fFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIconLocation )( 
            IShellLinkDual __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *piIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIconLocation )( 
            IShellLinkDual __RPC_FAR * This,
            /* [in] */ BSTR bs,
            /* [in] */ int iIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IShellLinkDual __RPC_FAR * This,
            /* [optional][in] */ VARIANT vWhere);
        
        END_INTERFACE
    } IShellLinkDualVtbl;

    interface IShellLinkDual
    {
        CONST_VTBL struct IShellLinkDualVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDual_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellLinkDual_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellLinkDual_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellLinkDual_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellLinkDual_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellLinkDual_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellLinkDual_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellLinkDual_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define IShellLinkDual_put_Path(This,bs)	\
    (This)->lpVtbl -> put_Path(This,bs)

#define IShellLinkDual_get_Description(This,pbs)	\
    (This)->lpVtbl -> get_Description(This,pbs)

#define IShellLinkDual_put_Description(This,bs)	\
    (This)->lpVtbl -> put_Description(This,bs)

#define IShellLinkDual_get_WorkingDirectory(This,pbs)	\
    (This)->lpVtbl -> get_WorkingDirectory(This,pbs)

#define IShellLinkDual_put_WorkingDirectory(This,bs)	\
    (This)->lpVtbl -> put_WorkingDirectory(This,bs)

#define IShellLinkDual_get_Arguments(This,pbs)	\
    (This)->lpVtbl -> get_Arguments(This,pbs)

#define IShellLinkDual_put_Arguments(This,bs)	\
    (This)->lpVtbl -> put_Arguments(This,bs)

#define IShellLinkDual_get_Hotkey(This,piHK)	\
    (This)->lpVtbl -> get_Hotkey(This,piHK)

#define IShellLinkDual_put_Hotkey(This,iHK)	\
    (This)->lpVtbl -> put_Hotkey(This,iHK)

#define IShellLinkDual_get_ShowCommand(This,piShowCommand)	\
    (This)->lpVtbl -> get_ShowCommand(This,piShowCommand)

#define IShellLinkDual_put_ShowCommand(This,iShowCommand)	\
    (This)->lpVtbl -> put_ShowCommand(This,iShowCommand)

#define IShellLinkDual_Resolve(This,fFlags)	\
    (This)->lpVtbl -> Resolve(This,fFlags)

#define IShellLinkDual_GetIconLocation(This,pbs,piIcon)	\
    (This)->lpVtbl -> GetIconLocation(This,pbs,piIcon)

#define IShellLinkDual_SetIconLocation(This,bs,iIcon)	\
    (This)->lpVtbl -> SetIconLocation(This,bs,iIcon)

#define IShellLinkDual_Save(This,vWhere)	\
    (This)->lpVtbl -> Save(This,vWhere)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Path_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Path_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Description_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Description_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_WorkingDirectory_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_WorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_WorkingDirectory_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_WorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Arguments_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellLinkDual_get_Arguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Arguments_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs);


void __RPC_STUB IShellLinkDual_put_Arguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_Hotkey_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *piHK);


void __RPC_STUB IShellLinkDual_get_Hotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_Hotkey_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ int iHK);


void __RPC_STUB IShellLinkDual_put_Hotkey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_get_ShowCommand_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *piShowCommand);


void __RPC_STUB IShellLinkDual_get_ShowCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_put_ShowCommand_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ int iShowCommand);


void __RPC_STUB IShellLinkDual_put_ShowCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_Resolve_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ int fFlags);


void __RPC_STUB IShellLinkDual_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_GetIconLocation_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbs,
    /* [retval][out] */ int __RPC_FAR *piIcon);


void __RPC_STUB IShellLinkDual_GetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_SetIconLocation_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [in] */ BSTR bs,
    /* [in] */ int iIcon);


void __RPC_STUB IShellLinkDual_SetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellLinkDual_Save_Proxy( 
    IShellLinkDual __RPC_FAR * This,
    /* [optional][in] */ VARIANT vWhere);


void __RPC_STUB IShellLinkDual_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellLinkDual_INTERFACE_DEFINED__ */


#ifndef __IShellLinkDual2_INTERFACE_DEFINED__
#define __IShellLinkDual2_INTERFACE_DEFINED__

/* interface IShellLinkDual2 */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellLinkDual2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("317EE249-F12E-11d2-B1E4-00C04F8EEB3E")
    IShellLinkDual2 : public IShellLinkDual
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Target( 
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellLinkDual2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellLinkDual2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellLinkDual2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Description )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkingDirectory )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WorkingDirectory )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Arguments )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Arguments )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Hotkey )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piHK);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Hotkey )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ int iHK);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowCommand )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *piShowCommand);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowCommand )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ int iShowCommand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resolve )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ int fFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIconLocation )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbs,
            /* [retval][out] */ int __RPC_FAR *piIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIconLocation )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [in] */ BSTR bs,
            /* [in] */ int iIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [optional][in] */ VARIANT vWhere);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Target )( 
            IShellLinkDual2 __RPC_FAR * This,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);
        
        END_INTERFACE
    } IShellLinkDual2Vtbl;

    interface IShellLinkDual2
    {
        CONST_VTBL struct IShellLinkDual2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellLinkDual2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellLinkDual2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellLinkDual2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellLinkDual2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellLinkDual2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellLinkDual2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellLinkDual2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellLinkDual2_get_Path(This,pbs)	\
    (This)->lpVtbl -> get_Path(This,pbs)

#define IShellLinkDual2_put_Path(This,bs)	\
    (This)->lpVtbl -> put_Path(This,bs)

#define IShellLinkDual2_get_Description(This,pbs)	\
    (This)->lpVtbl -> get_Description(This,pbs)

#define IShellLinkDual2_put_Description(This,bs)	\
    (This)->lpVtbl -> put_Description(This,bs)

#define IShellLinkDual2_get_WorkingDirectory(This,pbs)	\
    (This)->lpVtbl -> get_WorkingDirectory(This,pbs)

#define IShellLinkDual2_put_WorkingDirectory(This,bs)	\
    (This)->lpVtbl -> put_WorkingDirectory(This,bs)

#define IShellLinkDual2_get_Arguments(This,pbs)	\
    (This)->lpVtbl -> get_Arguments(This,pbs)

#define IShellLinkDual2_put_Arguments(This,bs)	\
    (This)->lpVtbl -> put_Arguments(This,bs)

#define IShellLinkDual2_get_Hotkey(This,piHK)	\
    (This)->lpVtbl -> get_Hotkey(This,piHK)

#define IShellLinkDual2_put_Hotkey(This,iHK)	\
    (This)->lpVtbl -> put_Hotkey(This,iHK)

#define IShellLinkDual2_get_ShowCommand(This,piShowCommand)	\
    (This)->lpVtbl -> get_ShowCommand(This,piShowCommand)

#define IShellLinkDual2_put_ShowCommand(This,iShowCommand)	\
    (This)->lpVtbl -> put_ShowCommand(This,iShowCommand)

#define IShellLinkDual2_Resolve(This,fFlags)	\
    (This)->lpVtbl -> Resolve(This,fFlags)

#define IShellLinkDual2_GetIconLocation(This,pbs,piIcon)	\
    (This)->lpVtbl -> GetIconLocation(This,pbs,piIcon)

#define IShellLinkDual2_SetIconLocation(This,bs,iIcon)	\
    (This)->lpVtbl -> SetIconLocation(This,bs,iIcon)

#define IShellLinkDual2_Save(This,vWhere)	\
    (This)->lpVtbl -> Save(This,vWhere)


#define IShellLinkDual2_get_Target(This,ppfi)	\
    (This)->lpVtbl -> get_Target(This,ppfi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellLinkDual2_get_Target_Proxy( 
    IShellLinkDual2 __RPC_FAR * This,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppfi);


void __RPC_STUB IShellLinkDual2_get_Target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellLinkDual2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLinkObject;

#ifdef __cplusplus

class DECLSPEC_UUID("11219420-1768-11d1-95BE-00609797EA4F")
ShellLinkObject;
#endif

#ifndef __IShellFolderViewDual_INTERFACE_DEFINED__
#define __IShellFolderViewDual_INTERFACE_DEFINED__

/* interface IShellFolderViewDual */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellFolderViewDual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")
    IShellFolderViewDual : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Folder( 
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectedItems( 
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_FocusedItem( 
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ VARIANT __RPC_FAR *pvfi,
            /* [in] */ int dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PopupItemMenu( 
            /* [in] */ FolderItem __RPC_FAR *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ BSTR __RPC_FAR *pbs) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Script( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
        virtual /* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ViewOptions( 
            /* [retval][out] */ long __RPC_FAR *plViewOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderViewDualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellFolderViewDual __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellFolderViewDual __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Folder )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectedItems )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FocusedItem )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectItem )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvfi,
            /* [in] */ int dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopupItemMenu )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [in] */ FolderItem __RPC_FAR *pfi,
            /* [optional][in] */ VARIANT vx,
            /* [optional][in] */ VARIANT vy,
            /* [retval][out] */ BSTR __RPC_FAR *pbs);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Script )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        /* [helpcontext][helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ViewOptions )( 
            IShellFolderViewDual __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plViewOptions);
        
        END_INTERFACE
    } IShellFolderViewDualVtbl;

    interface IShellFolderViewDual
    {
        CONST_VTBL struct IShellFolderViewDualVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolderViewDual_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFolderViewDual_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFolderViewDual_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFolderViewDual_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellFolderViewDual_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellFolderViewDual_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellFolderViewDual_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellFolderViewDual_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define IShellFolderViewDual_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define IShellFolderViewDual_get_Folder(This,ppid)	\
    (This)->lpVtbl -> get_Folder(This,ppid)

#define IShellFolderViewDual_SelectedItems(This,ppid)	\
    (This)->lpVtbl -> SelectedItems(This,ppid)

#define IShellFolderViewDual_get_FocusedItem(This,ppid)	\
    (This)->lpVtbl -> get_FocusedItem(This,ppid)

#define IShellFolderViewDual_SelectItem(This,pvfi,dwFlags)	\
    (This)->lpVtbl -> SelectItem(This,pvfi,dwFlags)

#define IShellFolderViewDual_PopupItemMenu(This,pfi,vx,vy,pbs)	\
    (This)->lpVtbl -> PopupItemMenu(This,pfi,vx,vy,pbs)

#define IShellFolderViewDual_get_Script(This,ppDisp)	\
    (This)->lpVtbl -> get_Script(This,ppDisp)

#define IShellFolderViewDual_get_ViewOptions(This,plViewOptions)	\
    (This)->lpVtbl -> get_ViewOptions(This,plViewOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Application_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Parent_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Folder_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_Folder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_SelectedItems_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ FolderItems __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_SelectedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_FocusedItem_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ FolderItem __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellFolderViewDual_get_FocusedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_SelectItem_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvfi,
    /* [in] */ int dwFlags);


void __RPC_STUB IShellFolderViewDual_SelectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_PopupItemMenu_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [in] */ FolderItem __RPC_FAR *pfi,
    /* [optional][in] */ VARIANT vx,
    /* [optional][in] */ VARIANT vy,
    /* [retval][out] */ BSTR __RPC_FAR *pbs);


void __RPC_STUB IShellFolderViewDual_PopupItemMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_Script_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IShellFolderViewDual_get_Script_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellFolderViewDual_get_ViewOptions_Proxy( 
    IShellFolderViewDual __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plViewOptions);


void __RPC_STUB IShellFolderViewDual_get_ViewOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFolderViewDual_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellFolderView;

#ifdef __cplusplus

class DECLSPEC_UUID("62112AA1-EBE4-11cf-A5FB-0020AFE7292D")
ShellFolderView;
#endif

#ifndef __IShellDispatch_INTERFACE_DEFINED__
#define __IShellDispatch_INTERFACE_DEFINED__

/* interface IShellDispatch */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8F015C0-C278-11CE-A49E-444553540000")
    IShellDispatch : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NameSpace( 
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BrowseForFolder( 
            /* [in] */ long Hwnd,
            /* [in] */ BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Windows( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VARIANT vDir) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Explore( 
            /* [in] */ VARIANT vDir) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MinimizeAll( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UndoMinimizeALL( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FileRun( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CascadeWindows( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TileVertically( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TileHorizontally( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShutdownWindows( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EjectPC( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTime( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TrayProperties( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Help( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindFiles( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindComputer( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RefreshMenu( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlPanelItem( 
            /* [in] */ BSTR szDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IShellDispatch __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IShellDispatch __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NameSpace )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BrowseForFolder )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ long Hwnd,
            /* [in] */ BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Windows )( 
            IShellDispatch __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Explore )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MinimizeAll )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UndoMinimizeALL )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRun )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CascadeWindows )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileVertically )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileHorizontally )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownWindows )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EjectPC )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTime )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TrayProperties )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Help )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFiles )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindComputer )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshMenu )( 
            IShellDispatch __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlPanelItem )( 
            IShellDispatch __RPC_FAR * This,
            /* [in] */ BSTR szDir);
        
        END_INTERFACE
    } IShellDispatchVtbl;

    interface IShellDispatch
    {
        CONST_VTBL struct IShellDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellDispatch_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define IShellDispatch_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define IShellDispatch_NameSpace(This,vDir,ppsdf)	\
    (This)->lpVtbl -> NameSpace(This,vDir,ppsdf)

#define IShellDispatch_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)

#define IShellDispatch_Windows(This,ppid)	\
    (This)->lpVtbl -> Windows(This,ppid)

#define IShellDispatch_Open(This,vDir)	\
    (This)->lpVtbl -> Open(This,vDir)

#define IShellDispatch_Explore(This,vDir)	\
    (This)->lpVtbl -> Explore(This,vDir)

#define IShellDispatch_MinimizeAll(This)	\
    (This)->lpVtbl -> MinimizeAll(This)

#define IShellDispatch_UndoMinimizeALL(This)	\
    (This)->lpVtbl -> UndoMinimizeALL(This)

#define IShellDispatch_FileRun(This)	\
    (This)->lpVtbl -> FileRun(This)

#define IShellDispatch_CascadeWindows(This)	\
    (This)->lpVtbl -> CascadeWindows(This)

#define IShellDispatch_TileVertically(This)	\
    (This)->lpVtbl -> TileVertically(This)

#define IShellDispatch_TileHorizontally(This)	\
    (This)->lpVtbl -> TileHorizontally(This)

#define IShellDispatch_ShutdownWindows(This)	\
    (This)->lpVtbl -> ShutdownWindows(This)

#define IShellDispatch_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IShellDispatch_EjectPC(This)	\
    (This)->lpVtbl -> EjectPC(This)

#define IShellDispatch_SetTime(This)	\
    (This)->lpVtbl -> SetTime(This)

#define IShellDispatch_TrayProperties(This)	\
    (This)->lpVtbl -> TrayProperties(This)

#define IShellDispatch_Help(This)	\
    (This)->lpVtbl -> Help(This)

#define IShellDispatch_FindFiles(This)	\
    (This)->lpVtbl -> FindFiles(This)

#define IShellDispatch_FindComputer(This)	\
    (This)->lpVtbl -> FindComputer(This)

#define IShellDispatch_RefreshMenu(This)	\
    (This)->lpVtbl -> RefreshMenu(This)

#define IShellDispatch_ControlPanelItem(This,szDir)	\
    (This)->lpVtbl -> ControlPanelItem(This,szDir)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellDispatch_get_Application_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellDispatch_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IShellDispatch_get_Parent_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellDispatch_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_NameSpace_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ VARIANT vDir,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);


void __RPC_STUB IShellDispatch_NameSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_BrowseForFolder_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ long Hwnd,
    /* [in] */ BSTR Title,
    /* [in] */ long Options,
    /* [optional][in] */ VARIANT RootFolder,
    /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);


void __RPC_STUB IShellDispatch_BrowseForFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Windows_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);


void __RPC_STUB IShellDispatch_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Open_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ VARIANT vDir);


void __RPC_STUB IShellDispatch_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Explore_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ VARIANT vDir);


void __RPC_STUB IShellDispatch_Explore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_MinimizeAll_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_MinimizeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_UndoMinimizeALL_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_UndoMinimizeALL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_FileRun_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_FileRun_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_CascadeWindows_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_CascadeWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_TileVertically_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_TileVertically_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_TileHorizontally_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_TileHorizontally_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_ShutdownWindows_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_ShutdownWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Suspend_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_EjectPC_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_EjectPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_SetTime_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_SetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_TrayProperties_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_TrayProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_Help_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_Help_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_FindFiles_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_FindFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_FindComputer_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_FindComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_RefreshMenu_Proxy( 
    IShellDispatch __RPC_FAR * This);


void __RPC_STUB IShellDispatch_RefreshMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch_ControlPanelItem_Proxy( 
    IShellDispatch __RPC_FAR * This,
    /* [in] */ BSTR szDir);


void __RPC_STUB IShellDispatch_ControlPanelItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellDispatch_INTERFACE_DEFINED__ */


#ifndef __IShellDispatch2_INTERFACE_DEFINED__
#define __IShellDispatch2_INTERFACE_DEFINED__

/* interface IShellDispatch2 */
/* [object][dual][hidden][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellDispatch2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C6892C-3BA9-11d2-9DEA-00C04FB16162")
    IShellDispatch2 : public IShellDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsRestricted( 
            /* [in] */ BSTR Group,
            /* [in] */ BSTR Restriction,
            /* [retval][out] */ long __RPC_FAR *plRestrictValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShellExecute( 
            /* [in] */ BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPrinter( 
            /* [optional][in] */ BSTR name,
            /* [optional][in] */ BSTR location,
            /* [optional][in] */ BSTR model) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSystemInformation( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceStart( 
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ServiceStop( 
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsServiceRunning( 
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pRunning) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CanStartStopService( 
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pCanStartStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowBrowserBar( 
            /* [in] */ BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellDispatch2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellDispatch2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellDispatch2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NameSpace )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ VARIANT vDir,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BrowseForFolder )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ long Hwnd,
            /* [in] */ BSTR Title,
            /* [in] */ long Options,
            /* [optional][in] */ VARIANT RootFolder,
            /* [retval][out] */ Folder __RPC_FAR *__RPC_FAR *ppsdf);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Windows )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Explore )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ VARIANT vDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MinimizeAll )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UndoMinimizeALL )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FileRun )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CascadeWindows )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileVertically )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TileHorizontally )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownWindows )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EjectPC )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTime )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TrayProperties )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Help )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFiles )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindComputer )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RefreshMenu )( 
            IShellDispatch2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlPanelItem )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR szDir);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRestricted )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR Group,
            /* [in] */ BSTR Restriction,
            /* [retval][out] */ long __RPC_FAR *plRestrictValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShellExecute )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR File,
            /* [optional][in] */ VARIANT vArgs,
            /* [optional][in] */ VARIANT vDir,
            /* [optional][in] */ VARIANT vOperation,
            /* [optional][in] */ VARIANT vShow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPrinter )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [optional][in] */ BSTR name,
            /* [optional][in] */ BSTR location,
            /* [optional][in] */ BSTR model);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemInformation )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServiceStart )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServiceStop )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [in] */ VARIANT Persistent,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsServiceRunning )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pRunning);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanStartStopService )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR ServiceName,
            /* [retval][out] */ VARIANT __RPC_FAR *pCanStartStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowBrowserBar )( 
            IShellDispatch2 __RPC_FAR * This,
            /* [in] */ BSTR bstrClsid,
            /* [in] */ VARIANT bShow,
            /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);
        
        END_INTERFACE
    } IShellDispatch2Vtbl;

    interface IShellDispatch2
    {
        CONST_VTBL struct IShellDispatch2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellDispatch2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellDispatch2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellDispatch2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellDispatch2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IShellDispatch2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IShellDispatch2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IShellDispatch2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IShellDispatch2_get_Application(This,ppid)	\
    (This)->lpVtbl -> get_Application(This,ppid)

#define IShellDispatch2_get_Parent(This,ppid)	\
    (This)->lpVtbl -> get_Parent(This,ppid)

#define IShellDispatch2_NameSpace(This,vDir,ppsdf)	\
    (This)->lpVtbl -> NameSpace(This,vDir,ppsdf)

#define IShellDispatch2_BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)	\
    (This)->lpVtbl -> BrowseForFolder(This,Hwnd,Title,Options,RootFolder,ppsdf)

#define IShellDispatch2_Windows(This,ppid)	\
    (This)->lpVtbl -> Windows(This,ppid)

#define IShellDispatch2_Open(This,vDir)	\
    (This)->lpVtbl -> Open(This,vDir)

#define IShellDispatch2_Explore(This,vDir)	\
    (This)->lpVtbl -> Explore(This,vDir)

#define IShellDispatch2_MinimizeAll(This)	\
    (This)->lpVtbl -> MinimizeAll(This)

#define IShellDispatch2_UndoMinimizeALL(This)	\
    (This)->lpVtbl -> UndoMinimizeALL(This)

#define IShellDispatch2_FileRun(This)	\
    (This)->lpVtbl -> FileRun(This)

#define IShellDispatch2_CascadeWindows(This)	\
    (This)->lpVtbl -> CascadeWindows(This)

#define IShellDispatch2_TileVertically(This)	\
    (This)->lpVtbl -> TileVertically(This)

#define IShellDispatch2_TileHorizontally(This)	\
    (This)->lpVtbl -> TileHorizontally(This)

#define IShellDispatch2_ShutdownWindows(This)	\
    (This)->lpVtbl -> ShutdownWindows(This)

#define IShellDispatch2_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IShellDispatch2_EjectPC(This)	\
    (This)->lpVtbl -> EjectPC(This)

#define IShellDispatch2_SetTime(This)	\
    (This)->lpVtbl -> SetTime(This)

#define IShellDispatch2_TrayProperties(This)	\
    (This)->lpVtbl -> TrayProperties(This)

#define IShellDispatch2_Help(This)	\
    (This)->lpVtbl -> Help(This)

#define IShellDispatch2_FindFiles(This)	\
    (This)->lpVtbl -> FindFiles(This)

#define IShellDispatch2_FindComputer(This)	\
    (This)->lpVtbl -> FindComputer(This)

#define IShellDispatch2_RefreshMenu(This)	\
    (This)->lpVtbl -> RefreshMenu(This)

#define IShellDispatch2_ControlPanelItem(This,szDir)	\
    (This)->lpVtbl -> ControlPanelItem(This,szDir)


#define IShellDispatch2_IsRestricted(This,Group,Restriction,plRestrictValue)	\
    (This)->lpVtbl -> IsRestricted(This,Group,Restriction,plRestrictValue)

#define IShellDispatch2_ShellExecute(This,File,vArgs,vDir,vOperation,vShow)	\
    (This)->lpVtbl -> ShellExecute(This,File,vArgs,vDir,vOperation,vShow)

#define IShellDispatch2_FindPrinter(This,name,location,model)	\
    (This)->lpVtbl -> FindPrinter(This,name,location,model)

#define IShellDispatch2_GetSystemInformation(This,name,pv)	\
    (This)->lpVtbl -> GetSystemInformation(This,name,pv)

#define IShellDispatch2_ServiceStart(This,ServiceName,Persistent,pSuccess)	\
    (This)->lpVtbl -> ServiceStart(This,ServiceName,Persistent,pSuccess)

#define IShellDispatch2_ServiceStop(This,ServiceName,Persistent,pSuccess)	\
    (This)->lpVtbl -> ServiceStop(This,ServiceName,Persistent,pSuccess)

#define IShellDispatch2_IsServiceRunning(This,ServiceName,pRunning)	\
    (This)->lpVtbl -> IsServiceRunning(This,ServiceName,pRunning)

#define IShellDispatch2_CanStartStopService(This,ServiceName,pCanStartStop)	\
    (This)->lpVtbl -> CanStartStopService(This,ServiceName,pCanStartStop)

#define IShellDispatch2_ShowBrowserBar(This,bstrClsid,bShow,pSuccess)	\
    (This)->lpVtbl -> ShowBrowserBar(This,bstrClsid,bShow,pSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_IsRestricted_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR Group,
    /* [in] */ BSTR Restriction,
    /* [retval][out] */ long __RPC_FAR *plRestrictValue);


void __RPC_STUB IShellDispatch2_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ShellExecute_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR File,
    /* [optional][in] */ VARIANT vArgs,
    /* [optional][in] */ VARIANT vDir,
    /* [optional][in] */ VARIANT vOperation,
    /* [optional][in] */ VARIANT vShow);


void __RPC_STUB IShellDispatch2_ShellExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_FindPrinter_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [optional][in] */ BSTR name,
    /* [optional][in] */ BSTR location,
    /* [optional][in] */ BSTR model);


void __RPC_STUB IShellDispatch2_FindPrinter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_GetSystemInformation_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pv);


void __RPC_STUB IShellDispatch2_GetSystemInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ServiceStart_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [in] */ VARIANT Persistent,
    /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);


void __RPC_STUB IShellDispatch2_ServiceStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ServiceStop_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [in] */ VARIANT Persistent,
    /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);


void __RPC_STUB IShellDispatch2_ServiceStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_IsServiceRunning_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [retval][out] */ VARIANT __RPC_FAR *pRunning);


void __RPC_STUB IShellDispatch2_IsServiceRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_CanStartStopService_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR ServiceName,
    /* [retval][out] */ VARIANT __RPC_FAR *pCanStartStop);


void __RPC_STUB IShellDispatch2_CanStartStopService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IShellDispatch2_ShowBrowserBar_Proxy( 
    IShellDispatch2 __RPC_FAR * This,
    /* [in] */ BSTR bstrClsid,
    /* [in] */ VARIANT bShow,
    /* [retval][out] */ VARIANT __RPC_FAR *pSuccess);


void __RPC_STUB IShellDispatch2_ShowBrowserBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellDispatch2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Shell;

#ifdef __cplusplus

class DECLSPEC_UUID("13709620-C279-11CE-A49E-444553540000")
Shell;
#endif

EXTERN_C const CLSID CLSID_ShellDispatchInproc;

#ifdef __cplusplus

class DECLSPEC_UUID("0A89A860-D7B1-11CE-8350-444553540000")
ShellDispatchInproc;
#endif

EXTERN_C const CLSID CLSID_WebViewFolderContents;

#ifdef __cplusplus

class DECLSPEC_UUID("1820FED0-473E-11D0-A96C-00C04FD705A2")
WebViewFolderContents;
#endif

#ifndef __DSearchCommandEvents_DISPINTERFACE_DEFINED__
#define __DSearchCommandEvents_DISPINTERFACE_DEFINED__

/* dispinterface DSearchCommandEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_DSearchCommandEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("60890160-69f0-11d1-b758-00a0c90564fe")
    DSearchCommandEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DSearchCommandEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            DSearchCommandEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            DSearchCommandEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            DSearchCommandEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } DSearchCommandEventsVtbl;

    interface DSearchCommandEvents
    {
        CONST_VTBL struct DSearchCommandEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DSearchCommandEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define DSearchCommandEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define DSearchCommandEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define DSearchCommandEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define DSearchCommandEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define DSearchCommandEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define DSearchCommandEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DSearchCommandEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SearchCommand;

#ifdef __cplusplus

class DECLSPEC_UUID("B005E690-678D-11d1-B758-00A0C90564FE")
SearchCommand;
#endif

#ifndef __IFileSearchBand_INTERFACE_DEFINED__
#define __IFileSearchBand_INTERFACE_DEFINED__

/* interface IFileSearchBand */
/* [object][unique][hidden][dual][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_IFileSearchBand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D91EEA1-9932-11d2-BE86-00A0C9A83DA1")
    IFileSearchBand : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSearchParameters( 
            /* [in] */ BSTR __RPC_FAR *pbstrSearchID,
            /* [in] */ VARIANT_BOOL bNavToResults,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarScope,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarQueryFile) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SearchID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchID) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarScope) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_QueryFile( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSearchBandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFileSearchBand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFileSearchBand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IFileSearchBand __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFocus )( 
            IFileSearchBand __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSearchParameters )( 
            IFileSearchBand __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *pbstrSearchID,
            /* [in] */ VARIANT_BOOL bNavToResults,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarScope,
            /* [optional][in] */ VARIANT __RPC_FAR *pvarQueryFile);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchID )( 
            IFileSearchBand __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchID);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Scope )( 
            IFileSearchBand __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarScope);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryFile )( 
            IFileSearchBand __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarFile);
        
        END_INTERFACE
    } IFileSearchBandVtbl;

    interface IFileSearchBand
    {
        CONST_VTBL struct IFileSearchBandVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSearchBand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFileSearchBand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFileSearchBand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFileSearchBand_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IFileSearchBand_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IFileSearchBand_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IFileSearchBand_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IFileSearchBand_SetFocus(This)	\
    (This)->lpVtbl -> SetFocus(This)

#define IFileSearchBand_SetSearchParameters(This,pbstrSearchID,bNavToResults,pvarScope,pvarQueryFile)	\
    (This)->lpVtbl -> SetSearchParameters(This,pbstrSearchID,bNavToResults,pvarScope,pvarQueryFile)

#define IFileSearchBand_get_SearchID(This,pbstrSearchID)	\
    (This)->lpVtbl -> get_SearchID(This,pbstrSearchID)

#define IFileSearchBand_get_Scope(This,pvarScope)	\
    (This)->lpVtbl -> get_Scope(This,pvarScope)

#define IFileSearchBand_get_QueryFile(This,pvarFile)	\
    (This)->lpVtbl -> get_QueryFile(This,pvarFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_SetFocus_Proxy( 
    IFileSearchBand __RPC_FAR * This);


void __RPC_STUB IFileSearchBand_SetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_SetSearchParameters_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *pbstrSearchID,
    /* [in] */ VARIANT_BOOL bNavToResults,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarScope,
    /* [optional][in] */ VARIANT __RPC_FAR *pvarQueryFile);


void __RPC_STUB IFileSearchBand_SetSearchParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_get_SearchID_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSearchID);


void __RPC_STUB IFileSearchBand_get_SearchID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_get_Scope_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarScope);


void __RPC_STUB IFileSearchBand_get_Scope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IFileSearchBand_get_QueryFile_Proxy( 
    IFileSearchBand __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarFile);


void __RPC_STUB IFileSearchBand_get_QueryFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFileSearchBand_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_FileSearchBand;

#ifdef __cplusplus

class DECLSPEC_UUID("C4EE31F3-4768-11D2-BE5C-00A0C9A83DA1")
FileSearchBand;
#endif
#endif /* __Shell32_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shldispp_0261 */
/* [local] */ 


//-------------------------------------------------------------------------
//
// IAutoComplete interface
//
//
// [Member functions]
//
// IAutoComplete::Init(hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete)
//   This function initializes an AutoComplete object, telling it
//   what control to subclass, and what list of strings to process.
//
// IAutoComplete::Enable(fEnable)
//   This function enables or disables the AutoComplete functionality.
//
//-------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_shldispp_0261_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0261_v0_0_s_ifspec;

#ifndef __IAutoComplete_INTERFACE_DEFINED__
#define __IAutoComplete_INTERFACE_DEFINED__

/* interface IAutoComplete */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IAutoComplete __RPC_FAR *LPAUTOCOMPLETE;


EXTERN_C const IID IID_IAutoComplete;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00bb2762-6a77-11d0-a535-00c04fd7d062")
    IAutoComplete : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ HWND hwndEdit,
            /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
            /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
            /* [in] */ LPCOLESTR pwszQuickComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoCompleteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAutoComplete __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAutoComplete __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAutoComplete __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IAutoComplete __RPC_FAR * This,
            /* [in] */ HWND hwndEdit,
            /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
            /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
            /* [in] */ LPCOLESTR pwszQuickComplete);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            IAutoComplete __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IAutoCompleteVtbl;

    interface IAutoComplete
    {
        CONST_VTBL struct IAutoCompleteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoComplete_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoComplete_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoComplete_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoComplete_Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)	\
    (This)->lpVtbl -> Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)

#define IAutoComplete_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAutoComplete_Init_Proxy( 
    IAutoComplete __RPC_FAR * This,
    /* [in] */ HWND hwndEdit,
    /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
    /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
    /* [in] */ LPCOLESTR pwszQuickComplete);


void __RPC_STUB IAutoComplete_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoComplete_Enable_Proxy( 
    IAutoComplete __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IAutoComplete_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoComplete_INTERFACE_DEFINED__ */


#ifndef __IAutoComplete2_INTERFACE_DEFINED__
#define __IAutoComplete2_INTERFACE_DEFINED__

/* interface IAutoComplete2 */
/* [unique][uuid][object][local][helpstring] */ 

typedef /* [unique] */ IAutoComplete2 __RPC_FAR *LPAUTOCOMPLETE2;

typedef 
enum _tagAUTOCOMPLETEOPTIONS
    {	ACO_NONE	= 0,
	ACO_AUTOSUGGEST	= 0x1,
	ACO_AUTOAPPEND	= 0x2,
	ACO_SEARCH	= 0x4,
	ACO_FILTERPREFIXES	= 0x8,
	ACO_USETAB	= 0x10,
	ACO_UPDOWNKEYDROPSLIST	= 0x20,
	ACO_RTLREADING	= 0x40
    }	AUTOCOMPLETEOPTIONS;


EXTERN_C const IID IID_IAutoComplete2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAC04BC0-3791-11d2-BB95-0060977B464C")
    IAutoComplete2 : public IAutoComplete
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ DWORD dwFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out] */ DWORD __RPC_FAR *pdwFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoComplete2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAutoComplete2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAutoComplete2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ HWND hwndEdit,
            /* [unique][in] */ IUnknown __RPC_FAR *punkACL,
            /* [unique][in] */ LPCOLESTR pwszRegKeyPath,
            /* [in] */ LPCOLESTR pwszQuickComplete);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enable )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOptions )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [in] */ DWORD dwFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptions )( 
            IAutoComplete2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFlag);
        
        END_INTERFACE
    } IAutoComplete2Vtbl;

    interface IAutoComplete2
    {
        CONST_VTBL struct IAutoComplete2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoComplete2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoComplete2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoComplete2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoComplete2_Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)	\
    (This)->lpVtbl -> Init(This,hwndEdit,punkACL,pwszRegKeyPath,pwszQuickComplete)

#define IAutoComplete2_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)


#define IAutoComplete2_SetOptions(This,dwFlag)	\
    (This)->lpVtbl -> SetOptions(This,dwFlag)

#define IAutoComplete2_GetOptions(This,pdwFlag)	\
    (This)->lpVtbl -> GetOptions(This,pdwFlag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAutoComplete2_SetOptions_Proxy( 
    IAutoComplete2 __RPC_FAR * This,
    /* [in] */ DWORD dwFlag);


void __RPC_STUB IAutoComplete2_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoComplete2_GetOptions_Proxy( 
    IAutoComplete2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFlag);


void __RPC_STUB IAutoComplete2_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoComplete2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldispp_0263 */
/* [local] */ 

// INTERFACE: IAsyncOperation
//
// This interface was implemented to turn some previously synchronous
// interfaces into async.  The following example is for
// doing the IDataObject::Drop() operation asynchronously.
//
// Sometimes the rendering of the IDataObject data (IDataObject::GetData() or
// STGMEDIUM.pStream->Read()) can be time intensive.  The IDropTarget
// may want to do this on another thread.
//
// Implimentation Check list:
// DoDragDrop Caller:
//    If this code can support asynch operations, then it needs to
//    QueryInterface() the IDataObject for IAsyncOperation.
//    IAsyncOperation::SetAsyncMode(VARIANT_TRUE).
//    After calling DoDragDrop(), call InOperation().  If any call fails
//    or InOperation() return FALSE, use the pdwEffect returned by DoDragDrop()
//    and the operation completed synchrously.
//
// OleSetClipboard Caller:
//    If this code can support asynch operations, then it needs to
//    QueryInterface() the IDataObject for IAsyncOperation.  Then call
//    IAsyncOperation::SetAsyncMode(VARIANT_TRUE).
//    If any of that fails, the final dwEffect should be passed to the IDataObject via
//    CFSTR_PERFORMEDDROPEFFECT.
//
// IDataObect Object:
//    IAsyncOperation::GetAsyncMode() should return whatever was last passed in
//          fDoOpAsync to ::SetAsyncMode() or VARIANT_FALSE if ::SetAsyncMode()
//          was never called.
//    IAsyncOperation::SetAsyncMode() should AddRef and store paocb.
//    IAsyncOperation::StartOperation() should store the fact that this was called and
//          cause InOperation() to return VARIANT_TRUE.  pbcReserved is not used and needs
//          to be NULL.
//    IAsyncOperation::InOperation() should return VARIANT_TRUE only if ::StartOperation()
//          was called.
//    IAsyncOperation::EndOperation() needs to call paocbpaocb->EndOperation() with the same
//          parameters.  Then release paocb.
//    IDataObject::SetData(CFSTR_PERFORMEDDROPEFFECT) When this happens, call
//          EndOperation(<into VAR>S_OK, NULL, <into VAR>dwEffect) and pass the dwEffect from the hglobal.
//
// IDropTarget Object:
//    IDropTarget::Drop() If asynch operations aren't supported, nothing is required.
//          The asynch operation can only happen if GetAsyncMode() returns VARIANT_TRUE.
//          Before starting the asynch operation, StartOperation(NULL) needs to be called before
//          returning from IDropTarget::Drop().



extern RPC_IF_HANDLE __MIDL_itf_shldispp_0263_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0263_v0_0_s_ifspec;

#ifndef __IAsyncOperation_INTERFACE_DEFINED__
#define __IAsyncOperation_INTERFACE_DEFINED__

/* interface IAsyncOperation */
/* [object][uuid][helpstring] */ 

typedef /* [unique] */ IAsyncOperation __RPC_FAR *LPASYNCOPERATION;


EXTERN_C const IID IID_IAsyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D8B0590-F691-11d2-8EA9-006097DF5BD4")
    IAsyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAsyncMode( 
            /* [in] */ BOOL fDoOpAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAsyncMode( 
            /* [out] */ BOOL __RPC_FAR *pfIsOpAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartOperation( 
            /* [optional][unique][in] */ IBindCtx __RPC_FAR *pbcReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InOperation( 
            /* [out] */ BOOL __RPC_FAR *pfInAsyncOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOperation( 
            /* [in] */ HRESULT hResult,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbcReserved,
            /* [in] */ DWORD dwEffects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAsyncOperation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAsyncOperation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAsyncOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsyncMode )( 
            IAsyncOperation __RPC_FAR * This,
            /* [in] */ BOOL fDoOpAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAsyncMode )( 
            IAsyncOperation __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsOpAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOperation )( 
            IAsyncOperation __RPC_FAR * This,
            /* [optional][unique][in] */ IBindCtx __RPC_FAR *pbcReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InOperation )( 
            IAsyncOperation __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfInAsyncOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOperation )( 
            IAsyncOperation __RPC_FAR * This,
            /* [in] */ HRESULT hResult,
            /* [unique][in] */ IBindCtx __RPC_FAR *pbcReserved,
            /* [in] */ DWORD dwEffects);
        
        END_INTERFACE
    } IAsyncOperationVtbl;

    interface IAsyncOperation
    {
        CONST_VTBL struct IAsyncOperationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncOperation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncOperation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncOperation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncOperation_SetAsyncMode(This,fDoOpAsync)	\
    (This)->lpVtbl -> SetAsyncMode(This,fDoOpAsync)

#define IAsyncOperation_GetAsyncMode(This,pfIsOpAsync)	\
    (This)->lpVtbl -> GetAsyncMode(This,pfIsOpAsync)

#define IAsyncOperation_StartOperation(This,pbcReserved)	\
    (This)->lpVtbl -> StartOperation(This,pbcReserved)

#define IAsyncOperation_InOperation(This,pfInAsyncOp)	\
    (This)->lpVtbl -> InOperation(This,pfInAsyncOp)

#define IAsyncOperation_EndOperation(This,hResult,pbcReserved,dwEffects)	\
    (This)->lpVtbl -> EndOperation(This,hResult,pbcReserved,dwEffects)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAsyncOperation_SetAsyncMode_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [in] */ BOOL fDoOpAsync);


void __RPC_STUB IAsyncOperation_SetAsyncMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_GetAsyncMode_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsOpAsync);


void __RPC_STUB IAsyncOperation_GetAsyncMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_StartOperation_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [optional][unique][in] */ IBindCtx __RPC_FAR *pbcReserved);


void __RPC_STUB IAsyncOperation_StartOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_InOperation_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfInAsyncOp);


void __RPC_STUB IAsyncOperation_InOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncOperation_EndOperation_Proxy( 
    IAsyncOperation __RPC_FAR * This,
    /* [in] */ HRESULT hResult,
    /* [unique][in] */ IBindCtx __RPC_FAR *pbcReserved,
    /* [in] */ DWORD dwEffects);


void __RPC_STUB IAsyncOperation_EndOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAsyncOperation_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldispp_0264 */
/* [local] */ 

#endif // _SHLDISP_PUB_H_
#ifndef _SHLDISP_PRIV_H_
#define _SHLDISP_PRIV_H_
// INTERFACE: IBrowserFrameOptions
//
// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what
// kind of 'Behavior' is appropriate for that view.  These are normally PM type decisions to
// refine the user experience.
// 
// For example, should the IE globe be added to the toolbar
// when the view is a HTTP web page? (Yes)  When the view is a FTP Folders?  When the view
// is the file system? (No) When the view is Web Folders? (Maybe, did you as a PM?)
// It's very important for the view to ask the NSE if it does or doesn't want the behavior instead of
// trying to sniff the pidl and guess.  An example of this kind of bad coding style is all the
// code that calls IsURLChild().  Currently we have a lot of hacky code that says turn such-and-such
// behavior on for HTTP and FTP URLs but not Web Folders and not ABOUT URLs, so it's very important to
// use this interface to do the work for you.  This will also allow Web Folders to fix a lot of bugs because
// the code hasn't yet been 'tweaked' to give the behavior Web Folders wants.
//
//    IBrowserFrameOptions::GetBrowserOptions()
//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and
//       it's return value will always equal or will be a subset of dwMask.
//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.
//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.
//
// NOTE: The definition of the bit needs to be OFF for the most common NSE.  This way shell name space
//       extensions that don't implement this interface or haven't been updated to handle this bit will
//       default to behavior that is the most common.  An example of this is the BFO_NO_FOLDER_OPTIONS
//       where this bit off will give the 'Folder Options', which is the most common case.  This is especially
//       true since this interface is internal only.



extern RPC_IF_HANDLE __MIDL_itf_shldispp_0264_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0264_v0_0_s_ifspec;

#ifndef __IBrowserFrameOptions_INTERFACE_DEFINED__
#define __IBrowserFrameOptions_INTERFACE_DEFINED__

/* interface IBrowserFrameOptions */
/* [object][uuid][helpstring] */ 

typedef /* [unique] */ IBrowserFrameOptions __RPC_FAR *LPBROWSERFRAMEOPTIONS;


enum __MIDL_IBrowserFrameOptions_0001
    {	BFO_NONE	= 0,
	BFO_BROWSER_PERSIST_SETTINGS	= 0x1,
	BFO_RENAME_FOLDER_OPTIONS_TOINTERNET	= 0x2,
	BFO_BOTH_OPTIONS	= 0x4,
	BIF_PREFER_INTERNET_SHORTCUT	= 0x8,
	BFO_BROWSE_NO_IN_NEW_PROCESS	= 0x10,
	BFO_ENABLE_HYPERLINK_TRACKING	= 0x20,
	BFO_USE_IE_OFFLINE_SUPPORT	= 0x40,
	BFO_SUBSTITUE_INTERNET_START_PAGE	= 0x80,
	BFO_USE_IE_LOGOBANDING	= 0x100,
	BFO_ADD_IE_TOCAPTIONBAR	= 0x200,
	BFO_USE_DIALUP_REF	= 0x400,
	BFO_USE_IE_TOOLBAR	= 0x800,
	BFO_NO_PARENT_FOLDER_SUPPORT	= 0x1000,
	BFO_NO_REOPEN_NEXT_RESTART	= 0x2000,
	BFO_GO_HOME_PAGE	= 0x4000,
	BFO_PREFER_IEPROCESS	= 0x8000,
	BFO_QUERY_ALL	= 0xffffffff
    };
typedef DWORD BROWSERFRAMEOPTIONS;


EXTERN_C const IID IID_IBrowserFrameOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10DF43C8-1DBE-11d3-8B34-006097DF5BD4")
    IBrowserFrameOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [in] */ BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ BROWSERFRAMEOPTIONS __RPC_FAR *pdwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBrowserFrameOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBrowserFrameOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBrowserFrameOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBrowserFrameOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameOptions )( 
            IBrowserFrameOptions __RPC_FAR * This,
            /* [in] */ BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ BROWSERFRAMEOPTIONS __RPC_FAR *pdwOptions);
        
        END_INTERFACE
    } IBrowserFrameOptionsVtbl;

    interface IBrowserFrameOptions
    {
        CONST_VTBL struct IBrowserFrameOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBrowserFrameOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBrowserFrameOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBrowserFrameOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBrowserFrameOptions_GetFrameOptions(This,dwMask,pdwOptions)	\
    (This)->lpVtbl -> GetFrameOptions(This,dwMask,pdwOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBrowserFrameOptions_GetFrameOptions_Proxy( 
    IBrowserFrameOptions __RPC_FAR * This,
    /* [in] */ BROWSERFRAMEOPTIONS dwMask,
    /* [out] */ BROWSERFRAMEOPTIONS __RPC_FAR *pdwOptions);


void __RPC_STUB IBrowserFrameOptions_GetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBrowserFrameOptions_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shldispp_0265 */
/* [local] */ 

#endif // _SHLDISP_PRIV_H_


extern RPC_IF_HANDLE __MIDL_itf_shldispp_0265_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shldispp_0265_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\shlapip.h ===
#ifndef _SHELAPIP_
#define _SHELAPIP_

#include <objbase.h>

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI       DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if !defined(_SHELL32_)
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if !defined(_SHDOCVW_)
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#endif
#endif // SHDOCAPI


#include <pshpack1.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


SHSTDAPI_(HICON) ExtractAssociatedIconExA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
SHSTDAPI_(HICON) ExtractAssociatedIconExW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
#ifdef UNICODE
#define ExtractAssociatedIconEx  ExtractAssociatedIconExW
#else
#define ExtractAssociatedIconEx  ExtractAssociatedIconExA
#endif // !UNICODE
// BUGBUG this API needs to be A/W. Don't make it public until it is.
SHSTDAPI_(BOOL) DragQueryInfo(HDROP hDrop, LPDRAGINFO lpdi);
#define ABE_MAX         4
SHSTDAPI_(HGLOBAL) InternalExtractIconA(HINSTANCE hInst, LPCSTR lpszFile, UINT nIconIndex, UINT nIcons);
SHSTDAPI_(HGLOBAL) InternalExtractIconW(HINSTANCE hInst, LPCWSTR lpszFile, UINT nIconIndex, UINT nIcons);
#ifdef UNICODE
#define InternalExtractIcon  InternalExtractIconW
#else
#define InternalExtractIcon  InternalExtractIconA
#endif // !UNICODE
SHSTDAPI_(HGLOBAL) InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons);
SHSTDAPI_(HGLOBAL) InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons);
#ifdef UNICODE
#define InternalExtractIconList  InternalExtractIconListW
#else
#define InternalExtractIconList  InternalExtractIconListA
#endif // !UNICODE
SHSTDAPI_(BOOL)    RegisterShellHook(HWND, BOOL);
#define SHGetNameMappingCount(_hnm) DSA_GetItemCount(_hnm)
#define SHGetNameMappingPtr(_hnm, _iItem) (LPSHNAMEMAPPING)DSA_GetItemPtr(_hnm, _iItem)

typedef struct _RUNDLL_NOTIFYA {
    NMHDR     hdr;
    HICON     hIcon;
    LPSTR     lpszTitle;
} RUNDLL_NOTIFYA;
typedef struct _RUNDLL_NOTIFYW {
    NMHDR     hdr;
    HICON     hIcon;
    LPWSTR    lpszTitle;
} RUNDLL_NOTIFYW;
#ifdef UNICODE
typedef RUNDLL_NOTIFYW RUNDLL_NOTIFY;
#else
typedef RUNDLL_NOTIFYA RUNDLL_NOTIFY;
#endif // UNICODE

typedef void (WINAPI *RUNDLLPROCA)(HWND hwndStub, HINSTANCE hInstance, LPSTR pszCmdLine, int nCmdShow);
typedef void (WINAPI *RUNDLLPROCW)(HWND hwndStub, HINSTANCE hInstance, LPWSTR pszCmdLine, int nCmdShow);
#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif // !UNICODE

#define RDN_FIRST       (0U-500U)
#define RDN_LAST        (0U-509U)
#define RDN_TASKINFO    (RDN_FIRST-0)

#define SEN_DDEEXECUTE (SEN_FIRST-0)

HINSTANCE RealShellExecuteA(
    HWND hwndParent,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    LPSTR lpResult,
    LPCSTR lpTitle,
    LPSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess);
HINSTANCE RealShellExecuteW(
    HWND hwndParent,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    LPWSTR lpResult,
    LPCWSTR lpTitle,
    LPWSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess);
#ifdef UNICODE
#define RealShellExecute  RealShellExecuteW
#else
#define RealShellExecute  RealShellExecuteA
#endif // !UNICODE

HINSTANCE RealShellExecuteExA(
    HWND hwndParent,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    LPSTR lpResult,
    LPCSTR lpTitle,
    LPSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess,
    DWORD dwFlags);
HINSTANCE RealShellExecuteExW(
    HWND hwndParent,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    LPWSTR lpResult,
    LPCWSTR lpTitle,
    LPWSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess,
    DWORD dwFlags);
#ifdef UNICODE
#define RealShellExecuteEx  RealShellExecuteExW
#else
#define RealShellExecuteEx  RealShellExecuteExA
#endif // !UNICODE

//
// RealShellExecuteEx flags
//
#define EXEC_SEPARATE_VDM     0x00000001
#define EXEC_NO_CONSOLE       0x00000002
#define SEE_MASK_FLAG_SHELLEXEC   0x00000800
#define SEE_MASK_FORCENOIDLIST    0x00001000
#define SEE_MASK_NO_HOOKS         0x00002000
#define SEE_MASK_HASLINKNAME      0x00010000
#define SEE_MASK_FLAG_SEPVDM      0x00020000
#define SEE_MASK_RESERVED         0x00040000
#define SEE_MASK_HASTITLE         0x00080000
#define SEE_MASK_FILEANDURL       0x00400000
// we have two CMIC_MASK_ values that don't have corospongind SEE_MASK_ counterparts
//      CMIC_MASK_SHIFT_DOWN      0x10000000
//      CMIC_MASK_CONTROL_DOWN    0x20000000

// All other bits are masked off when we do an InvokeCommand
#define SEE_VALID_CMIC_BITS     0x308FAFF0
#define SEE_VALID_CMIC_FLAGS    0x000FAFC0
// The LPVOID lpIDList parameter is the IDList
//
//  We have to define this structure twice.
//  The public definition uses HWNDs and HICONs.
//  The private definition uses DWORDs for Win32/64 interop.
//  The private version is called "NOTIFYICONDATA32" because it is the
//  explicit 32-bit version.
//
//  Make sure to keep them in sync!
//

typedef struct _NOTIFYICONDATA32A {
        DWORD cbSize;
        DWORD dwWnd;                        // NB!
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        DWORD dwIcon;                       // NB!
#if (_WIN32_IE < 0x0500)
        CHAR   szTip[64];
#else
        CHAR   szTip[128];
#endif
#if (_WIN32_IE >= 0x0500)
        DWORD dwState;
        DWORD dwStateMask;
        CHAR   szInfo[256];
        union {
            UINT  uTimeout;
            UINT  uVersion;
        } DUMMYUNIONNAME;
        CHAR   szInfoTitle[64];
        DWORD dwInfoFlags;
#endif
} NOTIFYICONDATA32A, *PNOTIFYICONDATA32A;
typedef struct _NOTIFYICONDATA32W {
        DWORD cbSize;
        DWORD dwWnd;                        // NB!
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        DWORD dwIcon;                       // NB!
#if (_WIN32_IE < 0x0500)
        WCHAR  szTip[64];
#else
        WCHAR  szTip[128];
#endif
#if (_WIN32_IE >= 0x0500)
        DWORD dwState;
        DWORD dwStateMask;
        WCHAR  szInfo[256];
        union {
            UINT  uTimeout;
            UINT  uVersion;
        } DUMMYUNIONNAME;
        WCHAR  szInfoTitle[64];
        DWORD dwInfoFlags;
#endif
} NOTIFYICONDATA32W, *PNOTIFYICONDATA32W;
#ifdef UNICODE
typedef NOTIFYICONDATA32W NOTIFYICONDATA32;
typedef PNOTIFYICONDATA32W PNOTIFYICONDATA32;
#else
typedef NOTIFYICONDATA32A NOTIFYICONDATA32;
typedef PNOTIFYICONDATA32A PNOTIFYICONDATA32;
#endif // UNICODE
typedef struct _TRAYNOTIFYDATAA {
        DWORD dwSignature;
        DWORD dwMessage;
        NOTIFYICONDATA32 nid;
} TRAYNOTIFYDATAA, *PTRAYNOTIFYDATAA;
typedef struct _TRAYNOTIFYDATAW {
        DWORD dwSignature;
        DWORD dwMessage;
        NOTIFYICONDATA32 nid;
} TRAYNOTIFYDATAW, *PTRAYNOTIFYDATAW;
#ifdef UNICODE
typedef TRAYNOTIFYDATAW TRAYNOTIFYDATA;
typedef PTRAYNOTIFYDATAW PTRAYNOTIFYDATA;
#else
typedef TRAYNOTIFYDATAA TRAYNOTIFYDATA;
typedef PTRAYNOTIFYDATAA PTRAYNOTIFYDATA;
#endif // UNICODE

#define NI_SIGNATURE    0x34753423

#define WNDCLASS_TRAYNOTIFY     "Shell_TrayWnd"
//                          (WM_USER + 1) = NIN_KEYSELECT
#define NIF_VALID_V1    0x00000007
#define NIF_VALID       0x0000001F
//
// Old NT Compatibility stuff (remove later)
//
SHSTDAPI_(VOID) CheckEscapesA(LPSTR lpFileA, DWORD cch);
//                          (WM_USER + 1) = NIN_KEYSELECT
#define NIF_VALID_V1    0x00000007
#define NIF_VALID       0x0000001F
//
// Old NT Compatibility stuff (remove later)
//
SHSTDAPI_(VOID) CheckEscapesW(LPWSTR lpFileA, DWORD cch);
#ifdef UNICODE
#define CheckEscapes  CheckEscapesW
#else
#define CheckEscapes  CheckEscapesA
#endif // !UNICODE
SHSTDAPI_(LPSTR) SheRemoveQuotesA(LPSTR sz);
SHSTDAPI_(LPWSTR) SheRemoveQuotesW(LPWSTR sz);
#ifdef UNICODE
#define SheRemoveQuotes  SheRemoveQuotesW
#else
#define SheRemoveQuotes  SheRemoveQuotesA
#endif // !UNICODE
SHSTDAPI_(WORD) ExtractIconResInfoA(HANDLE hInst,LPSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
SHSTDAPI_(WORD) ExtractIconResInfoW(HANDLE hInst,LPWSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
#ifdef UNICODE
#define ExtractIconResInfo  ExtractIconResInfoW
#else
#define ExtractIconResInfo  ExtractIconResInfoA
#endif // !UNICODE
SHSTDAPI_(int) SheSetCurDrive(int iDrive);
SHSTDAPI_(int) SheChangeDirA(register CHAR *newdir);
SHSTDAPI_(int) SheChangeDirW(register WCHAR *newdir);
#ifdef UNICODE
#define SheChangeDir  SheChangeDirW
#else
#define SheChangeDir  SheChangeDirA
#endif // !UNICODE
SHSTDAPI_(int) SheGetDirA(int iDrive, CHAR *str);
SHSTDAPI_(int) SheGetDirW(int iDrive, WCHAR *str);
#ifdef UNICODE
#define SheGetDir  SheGetDirW
#else
#define SheGetDir  SheGetDirA
#endif // !UNICODE
SHSTDAPI_(BOOL) SheConvertPathA(LPSTR lpApp, LPSTR lpFile, UINT cchCmdBuf);
SHSTDAPI_(BOOL) SheConvertPathW(LPWSTR lpApp, LPWSTR lpFile, UINT cchCmdBuf);
#ifdef UNICODE
#define SheConvertPath  SheConvertPathW
#else
#define SheConvertPath  SheConvertPathA
#endif // !UNICODE
SHSTDAPI_(BOOL) SheShortenPathA(LPSTR pPath, BOOL bShorten);
SHSTDAPI_(BOOL) SheShortenPathW(LPWSTR pPath, BOOL bShorten);
#ifdef UNICODE
#define SheShortenPath  SheShortenPathW
#else
#define SheShortenPath  SheShortenPathA
#endif // !UNICODE
SHSTDAPI_(BOOL) RegenerateUserEnvironment(PVOID *pPrevEnv,
                                        BOOL bSetCurrentEnv);
SHSTDAPI_(INT) SheGetPathOffsetW(LPWSTR lpszDir);
SHSTDAPI_(BOOL) SheGetDirExW(LPWSTR lpszCurDisk, LPDWORD lpcchCurDir,LPWSTR lpszCurDir);
SHSTDAPI_(DWORD) ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData);
SHSTDAPI_(INT) SheChangeDirExA(register CHAR *newdir);
SHSTDAPI_(INT) SheChangeDirExW(register WCHAR *newdir);
#ifdef UNICODE
#define SheChangeDirEx  SheChangeDirExW
#else
#define SheChangeDirEx  SheChangeDirExA
#endif // !UNICODE

//
// PRINTQ
//
VOID Printer_LoadIconsA(LPCSTR pszPrinterName, HICON* phLargeIcon, HICON* phSmallIcon);
//
// PRINTQ
//
VOID Printer_LoadIconsW(LPCWSTR pszPrinterName, HICON* phLargeIcon, HICON* phSmallIcon);
#ifdef UNICODE
#define Printer_LoadIcons  Printer_LoadIconsW
#else
#define Printer_LoadIcons  Printer_LoadIconsA
#endif // !UNICODE
LPSTR ShortSizeFormatA(DWORD dw, LPSTR szBuf);
LPWSTR ShortSizeFormatW(DWORD dw, LPWSTR szBuf);
#ifdef UNICODE
#define ShortSizeFormat  ShortSizeFormatW
#else
#define ShortSizeFormat  ShortSizeFormatA
#endif // !UNICODE
LPSTR AddCommasA(DWORD dw, LPSTR pszResult);
LPWSTR AddCommasW(DWORD dw, LPWSTR pszResult);
#ifdef UNICODE
#define AddCommas  AddCommasW
#else
#define AddCommas  AddCommasA
#endif // !UNICODE

BOOL Printers_RegisterWindowA(LPCSTR pszPrinter, DWORD dwType, PHANDLE phClassPidl, HWND *phwnd);
BOOL Printers_RegisterWindowW(LPCWSTR pszPrinter, DWORD dwType, PHANDLE phClassPidl, HWND *phwnd);
#ifdef UNICODE
#define Printers_RegisterWindow  Printers_RegisterWindowW
#else
#define Printers_RegisterWindow  Printers_RegisterWindowA
#endif // !UNICODE
VOID Printers_UnregisterWindow(HANDLE hClassPidl, HWND hwnd);

#define PRINTER_PIDL_TYPE_PROPERTIES       0x1
#define PRINTER_PIDL_TYPE_DOCUMENTDEFAULTS 0x2
#define PRINTER_PIDL_TYPE_ALL_USERS_DOCDEF 0x3
#define PRINTER_PIDL_TYPE_JOBID            0x80000000
//
// Internal APIs Follow.  NOT FOR PUBLIC CONSUMPTION.
//

//====== ShellMessageBox ================================================

// If lpcTitle is NULL, the title is taken from hWnd
// If lpcText is NULL, this is assumed to be an Out Of Memory message
// If the selector of lpcTitle or lpcText is NULL, the offset should be a
//     string resource ID
// The variable arguments must all be 32-bit values (even if fewer bits
//     are actually used)
// lpcText (or whatever string resource it causes to be loaded) should
//     be a formatting string similar to wsprintf except that only the
//     following formats are available:
//         %%              formats to a single '%'
//         %nn%s           the nn-th arg is a string which is inserted
//         %nn%ld          the nn-th arg is a DWORD, and formatted decimal
//         %nn%lx          the nn-th arg is a DWORD, and formatted hex
//     note that lengths are allowed on the %s, %ld, and %lx, just
//                         like wsprintf
//

int _cdecl ShellMessageBoxA(
    HINSTANCE hAppInst,
    HWND hWnd,
    LPCSTR lpcText,
    LPCSTR lpcTitle,
    UINT fuStyle, ...);
int _cdecl ShellMessageBoxW(
    HINSTANCE hAppInst,
    HWND hWnd,
    LPCWSTR lpcText,
    LPCWSTR lpcTitle,
    UINT fuStyle, ...);
#ifdef UNICODE
#define ShellMessageBox  ShellMessageBoxW
#else
#define ShellMessageBox  ShellMessageBoxA
#endif // !UNICODE

//====== Random stuff ================================================

SHSTDAPI_(BOOL) IsLFNDriveA(LPCSTR pszPath);
SHSTDAPI_(BOOL) IsLFNDriveW(LPCWSTR pszPath);
#ifdef UNICODE
#define IsLFNDrive  IsLFNDriveW
#else
#define IsLFNDrive  IsLFNDriveA
#endif // !UNICODE


#if (_WIN32_WINNT >= 0x0500) || (_WIN32_WINDOWS >= 0x0500)  

//
// The SHMultiFileProperties API displays a property sheet for a 
// set of files specified in an IDList Array.
//
// Parameters:
//      pdtobj  - Data object containing list of files.  The data
//                object must provide the "Shell IDList Array" 
//                clipboard format.  The parent folder's implementation of
//                IShellFolder::GetDisplayNameOf must return a fully-qualified
//                filesystem path for each item in response to the 
//                SHGDN_FORPARSING flag.
//
//      dwFlags - Reserved for future use.  Should be set to 0.
//
// Returns:
//      S_OK
// 
SHSTDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);

#endif 


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>
#endif  /* _SHELAPIP_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\bands.h ===
#ifndef BANDS_H_
#define BANDS_H_

#include "cowsite.h"

// this is a virtual class!
class CToolBand : public IDeskBand
                , public CObjectWithSite
                , public IInputObject
                , public IPersistStream
                , public IOleCommandTarget
                , public IServiceProvider
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPersistStreamInit methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) = 0;
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm) = 0;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) = 0;
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                             IUnknown* punkToolbarSite,
                                             BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi) PURE;

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

protected:
    CToolBand();
    virtual ~CToolBand();

    HRESULT _BandInfoChanged();

    int         _cRef;
    HWND        _hwnd;
    HWND        _hwndParent;
    //IUnknown* CObjectWithSite::_punkSite;
    BOOL        _fCanFocus:1;   // we accept focus (see UIActivateIO)
    DWORD       _dwBandID;
};


IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl);
IDeskBand* CSearchBand_Create();

#define CX_FILENAME_AVG    (6 * 12)    // '8.3' name in 'typical' font (approx)






class CToolbarBand: public CToolBand,
                    public IWinEventHandler
{
public:
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

protected:
    HRESULT _PushChevron(BOOL bLast);
    LRESULT _OnHotItemChange(LPNMTBHOTITEM pnmtb);
    virtual LRESULT _OnNotify(LPNMHDR pnmh);
};



#endif  // BANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\shlwapip.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHLWAPIP
#define _INC_SHLWAPIP
#ifndef NOSHLWAPI

#include <objbase.h>
#ifdef _WIN32
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_UALSTR     Unaligned string functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_HTTP       HTTP helper routines
//    NO_SHLWAPI_INTERNAL   Other random internal things
//    NO_SHLWAPI_GDI        GDI helper functions
//    NO_SHLWAPI_UNITHUNK   Unicode wrapper functions
//    NO_SHLWAPI_TPS        Thread Pool Services
//    NO_SHLWAPI_MLUI       Multi Language UI functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

LWSTDAPI_(LPSTR)    StrCpyNXA(LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrCpyNXW(LPWSTR psz1, LPCWSTR psz2, int cchMax);

#define ORD_SHLOADREGUISTRINGA  438
#define ORD_SHLOADREGUISTRINGW  439
LWSTDAPI SHLoadRegUIStringA(HKEY hkey, LPCSTR pszValue, LPSTR pszOutBuf, UINT cchOutBuf);
LWSTDAPI SHLoadRegUIStringW(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf);
#ifdef UNICODE
#define SHLoadRegUIString  SHLoadRegUIStringW
#else
#define SHLoadRegUIString  SHLoadRegUIStringA
#endif // !UNICODE

LWSTDAPI_(BOOL) IsCharCntrlW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharDigitW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharXDigitW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharSpaceW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharBlankW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharPunctW(WCHAR wch);
LWSTDAPI_(BOOL) GetStringType3ExW( LPCWSTR, int, LPWORD );

// StrCmp*C* - Compare strings using C runtime collation rules.
// These functions are faster than the StrCmp family of functions
// above and can be used when the character set of the strings is
// known to be limited to seven ASCII character set.

LWSTDAPI_(int)  StrCmpNCA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpNCW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpNICA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpNICW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpCA(LPCSTR lpStr1, LPCSTR lpStr2);
LWSTDAPI_(int)  StrCmpCW(LPCWSTR lpStr1, LPCWSTR lpStr2);
LWSTDAPI_(int)  StrCmpICA(LPCSTR lpStr1, LPCSTR lpStr2);
LWSTDAPI_(int)  StrCmpICW(LPCWSTR lpStr1, LPCWSTR lpStr2);

// This is a true-Unicode version of CompareString.  It only supports
// STRING_SORT, however.  After better test coverage, it shall replace
// the CompareString Unicode wrapper itself.  In the mean time, we only
// call this from the find dialog/OM method of Trident.

LWSTDAPI_(int)  CompareStringAltW( LCID lcid, DWORD dwFlags, LPCWSTR lpchA, int cchA, LPCWSTR lpchB, int cchB );

//
// Macros for IsCharAlpha, IsCharAlphaNumeric, IsCharLower, IsCharUpper
// are in winuser.h
//
//

#define IsCharCntrl             IsCharCntrlW
#define IsCharDigit             IsCharDigitW
#define IsCharXDigit            IsCharXDigitW
#define IsCharSpace             IsCharSpaceW
#define IsCharBlank             IsCharBlankW
#define IsCharPunct             IsCharPunctW
#define GetStringType3Ex        GetStringType3ExW


#ifdef UNICODE

#define StrCmpNC                StrCmpNCW
#define StrCmpNIC               StrCmpNICW
#define StrCmpC                 StrCmpCW
#define StrCmpIC                StrCmpICW
#define StrCpyNX                StrCpyNXW

#else

#define StrCmpNC                StrCmpNCA
#define StrCmpNIC               StrCmpNICA
#define StrCmpC                 StrCmpCA
#define StrCmpIC                StrCmpICA
#define StrCpyNX                StrCpyNXA

#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//


#if (_WIN32_IE >= 0x0501)

LWSTDAPI_(BOOL)     PathUnExpandEnvStringsForUserA(HANDLE hToken, LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsForUserW(HANDLE hToken, LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStringsForUser  PathUnExpandEnvStringsForUserW
#else
#define PathUnExpandEnvStringsForUser  PathUnExpandEnvStringsForUserA
#endif // !UNICODE

#endif // (_WIN32_IE >= 0x0501)

LWSTDAPI                UrlFixupW(LPCWSTR pszIn, LPWSTR pszOut, DWORD cchOut);
#define UrlFixup                UrlFixupW
// no UrlFixupA
//
// Internal APIs which we're not yet sure whether to make public
//

// Private IHlinkFrame::Navigate flags related to history
// This navigate should not go in the History ShellFolder
#define SHHLNF_WRITENOHISTORY 0x08000000
// This navigate should not automatically select History ShellFolder
#define SHHLNF_NOAUTOSELECT       0x04000000

// The order of these flags is important.  See the source before
// changing these.

#define PFOPEX_NONE        0x00000000
#define PFOPEX_PIF         0x00000001
#define PFOPEX_COM         0x00000002
#define PFOPEX_EXE         0x00000004
#define PFOPEX_BAT         0x00000008
#define PFOPEX_LNK         0x00000010
#define PFOPEX_CMD         0x00000020
#define PFOPEX_OPTIONAL    0x00000040   // Search only if Extension not present
#define PFOPEX_DEFAULT     (PFOPEX_CMD | PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE | PFOPEX_LNK)

LWSTDAPI_(BOOL)     PathFileExistsDefExtA(LPSTR pszPath, UINT uFlags);
LWSTDAPI_(BOOL)     PathFileExistsDefExtW(LPWSTR pszPath, UINT uFlags);
#ifdef UNICODE
#define PathFileExistsDefExt  PathFileExistsDefExtW
#else
#define PathFileExistsDefExt  PathFileExistsDefExtA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathFindOnPathExA(LPSTR pszPath, LPCSTR * ppszOtherDirs, UINT uFlags);
LWSTDAPI_(BOOL)     PathFindOnPathExW(LPWSTR pszPath, LPCWSTR * ppszOtherDirs, UINT uFlags);
#ifdef UNICODE
#define PathFindOnPathEx  PathFindOnPathExW
#else
#define PathFindOnPathEx  PathFindOnPathExA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) PathSkipLeadingSlashesA(LPCSTR pszURL);
LWSTDAPI_(LPCWSTR) PathSkipLeadingSlashesW(LPCWSTR pszURL);
#ifdef UNICODE
#define PathSkipLeadingSlashes  PathSkipLeadingSlashesW
#else
#define PathSkipLeadingSlashes  PathSkipLeadingSlashesA
#endif // !UNICODE

LWSTDAPI_(UINT)     SHGetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
LWSTDAPI_(UINT)     SHGetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
#ifdef UNICODE
#define SHGetSystemWindowsDirectory  SHGetSystemWindowsDirectoryW
#else
#define SHGetSystemWindowsDirectory  SHGetSystemWindowsDirectoryA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0501)
//
// These are functions that used to be duplicated in shell32, but have
// be consolidated here. They are exported privately until someone decides
// we really want to document them.
//
LWSTDAPI_(BOOL) PathFileExistsAndAttributesA(LPCSTR pszPath, OPTIONAL DWORD* pdwAttributes);
//
// These are functions that used to be duplicated in shell32, but have
// be consolidated here. They are exported privately until someone decides
// we really want to document them.
//
LWSTDAPI_(BOOL) PathFileExistsAndAttributesW(LPCWSTR pszPath, OPTIONAL DWORD* pdwAttributes);
#ifdef UNICODE
#define PathFileExistsAndAttributes  PathFileExistsAndAttributesW
#else
#define PathFileExistsAndAttributes  PathFileExistsAndAttributesA
#endif // !UNICODE
LWSTDAPI_(void) FixSlashesAndColonA(LPSTR pszPath);
LWSTDAPI_(void) FixSlashesAndColonW(LPWSTR pszPath);
#ifdef UNICODE
#define FixSlashesAndColon  FixSlashesAndColonW
#else
#define FixSlashesAndColon  FixSlashesAndColonA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) NextPathA(LPCSTR lpPath, LPSTR szPath, int cchPath);
LWSTDAPI_(LPCWSTR) NextPathW(LPCWSTR lpPath, LPWSTR szPath, int cchPath);
#ifdef UNICODE
#define NextPath  NextPathW
#else
#define NextPath  NextPathA
#endif // !UNICODE
LWSTDAPI_(LPSTR) CharUpperNoDBCSA(LPSTR psz);
LWSTDAPI_(LPWSTR) CharUpperNoDBCSW(LPWSTR psz);
#ifdef UNICODE
#define CharUpperNoDBCS  CharUpperNoDBCSW
#else
#define CharUpperNoDBCS  CharUpperNoDBCSA
#endif // !UNICODE
LWSTDAPI_(LPSTR) CharLowerNoDBCSA(LPSTR psz);
LWSTDAPI_(LPWSTR) CharLowerNoDBCSW(LPWSTR psz);
#ifdef UNICODE
#define CharLowerNoDBCS  CharLowerNoDBCSW
#else
#define CharLowerNoDBCS  CharLowerNoDBCSA
#endif // !UNICODE


//
// flags for PathIsValidChar()
//
#define PIVC_ALLOW_QUESTIONMARK     0x00000001  // treat '?' as valid
#define PIVC_ALLOW_STAR             0x00000002  // treat '*' as valid
#define PIVC_ALLOW_DOT              0x00000004  // treat '.' as valid
#define PIVC_ALLOW_SLASH            0x00000008  // treat '\\' as valid
#define PIVC_ALLOW_COLON            0x00000010  // treat ':' as valid
#define PIVC_ALLOW_SEMICOLON        0x00000020  // treat ';' as valid
#define PIVC_ALLOW_COMMA            0x00000040  // treat ',' as valid
#define PIVC_ALLOW_SPACE            0x00000080  // treat ' ' as valid
#define PIVC_ALLOW_NONALPAHABETIC   0x00000100  // treat non-alphabetic exteneded chars as valid
#define PIVC_ALLOW_QUOTE            0x00000200  // treat '"' as valid

//
// standard masks for PathIsValidChar()
//
#define PIVC_SFN_NAME               (PIVC_ALLOW_DOT | PIVC_ALLOW_NONALPAHABETIC)
#define PIVC_SFN_FULLPATH           (PIVC_SFN_NAME | PIVC_ALLOW_COLON | PIVC_ALLOW_SLASH)
#define PIVC_LFN_NAME               (PIVC_ALLOW_DOT | PIVC_ALLOW_NONALPAHABETIC | PIVC_ALLOW_SEMICOLON | PIVC_ALLOW_COMMA | PIVC_ALLOW_SPACE)
#define PIVC_LFN_FULLPATH           (PIVC_LFN_NAME | PIVC_ALLOW_COLON | PIVC_ALLOW_SLASH)
#define PIVC_SFN_FILESPEC           (PIVC_SFN_FULLPATH | PIVC_ALLOW_STAR | PIVC_ALLOW_QUESTIONMARK)
#define PIVC_LFN_FILESPEC           (PIVC_LFN_FULLPATH | PIVC_ALLOW_STAR | PIVC_ALLOW_QUESTIONMARK)

LWSTDAPI_(BOOL) PathIsValidCharA(UCHAR ch, DWORD dwFlags);
LWSTDAPI_(BOOL) PathIsValidCharW(WCHAR ch, DWORD dwFlags);
#ifdef UNICODE
#define PathIsValidChar  PathIsValidCharW
#else
#define PathIsValidChar  PathIsValidCharA
#endif // !UNICODE

#endif // (_WIN32_IE >= 0x0501)


// parsed URL information returned by ParseURL()
//
// Internet_CrackURL is the correct function for external components
// to use. URL.DLL calls this function to do some work and the shell
// uses this function as a leight-weight parsing function as well.

typedef struct tagPARSEDURLA {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCSTR    pszProtocol;
    UINT      cchProtocol;
    LPCSTR    pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLA, * PPARSEDURLA;
typedef struct tagPARSEDURLW {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCWSTR   pszProtocol;
    UINT      cchProtocol;
    LPCWSTR   pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLW, * PPARSEDURLW;
#ifdef UNICODE
typedef PARSEDURLW PARSEDURL;
typedef PPARSEDURLW PPARSEDURL;
#else
typedef PARSEDURLA PARSEDURL;
typedef PPARSEDURLA PPARSEDURL;
#endif // UNICODE

LWSTDAPI            ParseURLA(LPCSTR pcszURL, PARSEDURLA * ppu);
LWSTDAPI            ParseURLW(LPCWSTR pcszURL, PARSEDURLW * ppu);
#ifdef UNICODE
#define ParseURL  ParseURLW
#else
#define ParseURL  ParseURLA
#endif // !UNICODE



#endif //  NO_SHLWAPI_PATH


#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//

// BUGBUG (scotth): SHDeleteOrphanKey is the old name for SHDeleteEmptyKey.
//                  This will be removed soon.  SHDeleteOrphanKey already
//                  maps to SHDeleteEmptyKey in the DLL exports.

LWSTDAPI_(DWORD)    SHDeleteOrphanKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteOrphanKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteOrphanKey  SHDeleteOrphanKeyW
#else
#define SHDeleteOrphanKey  SHDeleteOrphanKeyA
#endif // !UNICODE

typedef struct tagAssocDDEExec
{
    LPCWSTR pszDDEExec;
    LPCWSTR pszApplication;
    LPCWSTR pszTopic;
    BOOL fNoActivateHandler;
} ASSOCDDEEXEC;

typedef struct tagAssocVerb
{
    LPCWSTR pszVerb;
    LPCWSTR pszTitle;
    LPCWSTR pszFriendlyAppName;
    LPCWSTR pszApplication;
    LPCWSTR pszParams;
    ASSOCDDEEXEC *pDDEExec;
} ASSOCVERB;

typedef struct tagAssocShell
{
    ASSOCVERB *rgVerbs;
    DWORD cVerbs;
    DWORD iDefaultVerb;
} ASSOCSHELL;

typedef struct tagAssocProgid
{
    DWORD cbSize;
    LPCWSTR pszProgid;
    LPCWSTR pszFriendlyDocName;
    LPCWSTR pszDefaultIcon;
    ASSOCSHELL *pShellKey;
    LPCWSTR pszExtensions;
} ASSOCPROGID;

typedef struct tagAssocApp
{
    DWORD cbSize;
    LPCWSTR pszFriendlyAppName;
    ASSOCSHELL *pShellKey;
} ASSOCAPP;

enum {
    ASSOCMAKEF_VERIFY                  = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCMAKEF_USEEXPAND               = 0x00000200,  //  strings have environment vars and need REG_EXPAND_SZ
    ASSOCMAKEF_SUBSTENV                = 0x00000400,  //  attempt to use std env if they match...
    ASSOCMAKEF_VOLATILE                = 0x00000800,  //  the progid will not persist between sessions
    ASSOCMAKEF_DELETE                  = 0x00002000,  //  remove this association if possible
};

typedef DWORD ASSOCMAKEF;

LWSTDAPI AssocMakeProgid(ASSOCMAKEF flags, LPCWSTR pszApplication, ASSOCPROGID *pProgid, HKEY *phkProgid);
LWSTDAPI AssocMakeApp(ASSOCMAKEF flags, LPCWSTR pszApplication, ASSOCAPP *pApp, HKEY *phkApp);

LWSTDAPI AssocMakeApplicationByKeyA(ASSOCMAKEF flags, HKEY hkAssoc, LPCSTR pszVerb);
LWSTDAPI AssocMakeApplicationByKeyW(ASSOCMAKEF flags, HKEY hkAssoc, LPCWSTR pszVerb);
#ifdef UNICODE
#define AssocMakeApplicationByKey  AssocMakeApplicationByKeyW
#else
#define AssocMakeApplicationByKey  AssocMakeApplicationByKeyA
#endif // !UNICODE
LWSTDAPI AssocMakeFileExtsToApplicationA(ASSOCMAKEF flags, LPCSTR pszExt, LPCSTR pszApplication);
LWSTDAPI AssocMakeFileExtsToApplicationW(ASSOCMAKEF flags, LPCWSTR pszExt, LPCWSTR pszApplication);
#ifdef UNICODE
#define AssocMakeFileExtsToApplication  AssocMakeFileExtsToApplicationW
#else
#define AssocMakeFileExtsToApplication  AssocMakeFileExtsToApplicationA
#endif // !UNICODE

LWSTDAPI AssocCopyVerbs(HKEY hkSrc, HKEY hkDst);


#endif //  NO_SHLWAPI_REG


#ifndef NO_SHLWAPI_UALSTR
#include <uastrfnc.h>
#endif //  NO_SHLWAPI_UALSTR


#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//
//
//  We must say "struct IStream" instead of "IStream" in case we are
//  #include'd before <ole2.h>.
//

LWSTDAPI_(struct IStream *) SHCreateMemStream(LPBYTE pInit, UINT cbInit);

// SHCreateStreamWrapper creates an IStream that spans multiple IStream implementations.
// NOTE: STGM_READ is the only mode currently supported
LWSTDAPI SHCreateStreamWrapper(IStream *aStreams[], UINT cStreams, DWORD grfMode, IStream **ppstm);


// These functions read, write, and maintain a list of DATABLOCK_HEADERs.
// Blocks can be of any size (cbSize) and they are added, found, and removed
// by dwSignature. Each block is guranteed to be aligned on a DWORD boundary
// in memory. The stream format is identical to Windows 95 and NT 4
// CShellLink's "EXP" data format (with one bug fix: stream data is NULL
// terminated on write...)
//
// SHReadDataBlocks and SHAddDataBlock will allocate your pdbList for you.
//
// SHFindDataBlock returns a pointer into the pdbList.
//
// SHAddDataBlock and SHRemoveDataBlock return TRUE if ppdbList modified.
//
#ifndef __DATABLOCKHEADER_DEFINED
#define __DATABLOCKHEADER_DEFINED
typedef struct tagDATABLOCKHEADER {
    DWORD   cbSize;             // Size of this extra data block
    DWORD   dwSignature;        // signature of this extra data block
} DATABLOCK_HEADER, *LPDATABLOCK_HEADER, *LPDBLIST;
#endif

STDAPI SHWriteDataBlockList(struct IStream* pstm, LPDBLIST pdbList);
STDAPI SHReadDataBlockList(struct IStream* pstm, LPDBLIST * ppdbList);
STDAPI_(void) SHFreeDataBlockList(LPDBLIST pdbList);
STDAPI_(BOOL) SHAddDataBlock(LPDBLIST * ppdbList, LPDATABLOCK_HEADER pdb);
STDAPI_(BOOL) SHRemoveDataBlock(LPDBLIST * ppdbList, DWORD dwSignature);
STDAPI_(void *) SHFindDataBlock(LPDBLIST pdbList, DWORD dwSignature);


// FUNCTION: SHCheckDiskForMedia
//
// hwnd - NULL means no UI will be displayed.  Non-NULL means
// punkEnableModless - Make caller modal during UI. (OPTIONAL)
// pszPath - Path that needs verification.
// wFunc - Type of operation (FO_MOVE, FO_COPY, FO_DELETE, FO_RENAME - shellapi.h)
//
// NOTE: USE NT5's SHPathPrepareForWrite() instead, it's MUCH MUCH BETTER.

STDAPI_(BOOL) SHCheckDiskForMediaA(HWND hwnd, IUnknown * punkEnableModless, LPCSTR pszPath, UINT wFunc);
STDAPI_(BOOL) SHCheckDiskForMediaW(HWND hwnd, IUnknown * punkEnableModless, LPCWSTR pwzPath, UINT wFunc);

#ifdef UNICODE
#define SHCheckDiskForMedia      SHCheckDiskForMediaW
#else
#define SHCheckDiskForMedia      SHCheckDiskForMediaA
#endif

#endif // NO_SHLWAPI_STREAM

#ifndef NO_SHLWAPI_MLUI
//
//=============== Multi Language UI Routines ===================================
//


#define     ORD_SHGETWEBFOLDERFILEPATHA 440
#define     ORD_SHGETWEBFOLDERFILEPATHW 441
LWSTDAPI    SHGetWebFolderFilePathA(LPCSTR pszFileName, LPSTR pszMUIPath, UINT cchMUIPath);
LWSTDAPI    SHGetWebFolderFilePathW(LPCWSTR pszFileName, LPWSTR pszMUIPath, UINT cchMUIPath);
#ifdef UNICODE
#define SHGetWebFolderFilePath  SHGetWebFolderFilePathW
#else
#define SHGetWebFolderFilePath  SHGetWebFolderFilePathA
#endif // !UNICODE

// Use MLLoadLibrary to get the ML-resource file.  This function tags the file so
// all standard shlwapi wrap functions automatically get ML-behavior.
//

#define ORD_MLLOADLIBRARYA  377
#define ORD_MLLOADLIBRARYW  378
LWSTDAPI_(HINSTANCE) MLLoadLibraryA(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
LWSTDAPI_(HINSTANCE) MLLoadLibraryW(LPCWSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
#ifdef UNICODE
#define MLLoadLibrary  MLLoadLibraryW
#else
#define MLLoadLibrary  MLLoadLibraryA
#endif // !UNICODE
LWSTDAPI_(BOOL) MLFreeLibrary(HMODULE hModule);

#define ML_NO_CROSSCODEPAGE     0
#define ML_CROSSCODEPAGE_NT     1
#define ML_CROSSCODEPAGE        2
#define ML_SHELL_LANGUAGE       4
#define ML_CROSSCODEPAGE_MASK   7

// If you are a global distributable a-la comctl32 that doesn't follow the IE5
// PlugUI resource layout, then load your own hinstance and poke it into shlwapi
// using these functions:
//
LWSTDAPI MLSetMLHInstance(HINSTANCE hInst, LANGID lidUI);
LWSTDAPI MLClearMLHInstance(HINSTANCE hInst);

// Of course you need to know what UI language to use:
//
#define ORD_MLGETUILANGUAGE 376
LWSTDAPI_(LANGID) MLGetUILanguage(void);

// Super internal and you probably don't need this one, but comctl32 does
// some font munging in PlugUI cases on your apps behalf:
//
LWSTDAPI_(BOOL) MLIsMLHInstance(HINSTANCE hInst);


LWSTDAPI_(HRESULT) MLBuildResURLA(LPCSTR szLibFile, HMODULE hModule, DWORD dwCrossCodePage, LPCSTR szResourceName, LPSTR pszResURL, int nBufSize);
LWSTDAPI_(HRESULT) MLBuildResURLW(LPCWSTR szLibFile, HMODULE hModule, DWORD dwCrossCodePage, LPCWSTR szResourceName, LPWSTR pszResURL, int nBufSize);
#ifdef UNICODE
#define MLBuildResURL  MLBuildResURLW
#else
#define MLBuildResURL  MLBuildResURLA
#endif // !UNICODE
#define ORD_MLWINHELPA      395
#define ORD_MLWINHELPW      397
LWSTDAPI_(BOOL) MLWinHelpA(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
LWSTDAPI_(BOOL) MLWinHelpW(HWND hWndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
#ifdef UNICODE
#define MLWinHelp  MLWinHelpW
#else
#define MLWinHelp  MLWinHelpA
#endif // !UNICODE
#define ORD_MLHTMLHELPA     396
#define ORD_MLHTMLHELPW     398
LWSTDAPI_(HWND) MLHtmlHelpA(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
LWSTDAPI_(HWND) MLHtmlHelpW(HWND hWndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
#ifdef UNICODE
#define MLHtmlHelp  MLHtmlHelpW
#else
#define MLHtmlHelp  MLHtmlHelpA
#endif // !UNICODE



#endif // NO_SHLWAPI_MLUI


#ifndef NO_SHLWAPI_HTTP
//
//=============== HTTP helper Routines ===================================
//  The calling thread must have called CoInitialize() before using this
//  function - it will create a format enumerator and associate it as a
// property with the IShellBrowser passed in, so that it will be reused.
//

//
//  We must say "struct IWhatever" instead of "IWhatever" in case we are
//  #include'd before <ole2.h>.
//
STDAPI RegisterDefaultAcceptHeaders(struct IBindCtx* pbc, struct IShellBrowser* psb);

LWSTDAPI RunRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey);
LWSTDAPI RunIndirectRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey, LPCWSTR pszVerb);
LWSTDAPI SHRunIndirectRegClientCommand(HWND hwnd, LPCWSTR pszClient);

LWSTDAPI   GetAcceptLanguagesA(LPSTR psz, LPDWORD pcch);
LWSTDAPI   GetAcceptLanguagesW(LPWSTR pwz, LPDWORD pcch);

#ifdef UNICODE
#define GetAcceptLanguages      GetAcceptLanguagesW
#else
#define GetAcceptLanguages      GetAcceptLanguagesA
#endif

#endif // NO_SHLWAPI_HTTP



LWSTDAPI_(HWND) SHHtmlHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML);
LWSTDAPI_(HWND) SHHtmlHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML);
LWSTDAPI_(BOOL) SHWinHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML);
LWSTDAPI_(BOOL) SHWinHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML);
LWSTDAPI_(BOOL) WINAPI Shell_GetCachedImageIndexWrapW(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
LWSTDAPI_(BOOL) WINAPI Shell_GetCachedImageIndexWrapA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);

#ifdef UNICODE
#define SHHtmlHelpOnDemand      SHHtmlHelpOnDemandW
#define SHWinHelpOnDemand       SHWinHelpOnDemandW
#define Shell_GetCachedImageIndexWrap Shell_GetCachedImageIndexWrapW
#else
#define SHHtmlHelpOnDemand      SHHtmlHelpOnDemandA
#define SHWinHelpOnDemand       SHWinHelpOnDemandA
#define Shell_GetCachedImageIndexWrap Shell_GetCachedImageIndexWrapA
#endif


#ifndef NO_SHLWAPI_STOPWATCH
//
//=============== Performance timing macros and prototypes ================

// StopWatch performance mode flags used in dwFlags param in API's and in Mode key at
// HKLM\software\microsoft\windows\currentversion\explorer\performance
// NOTE: low word is used for the mode, high word is used to change the default painter timer interval.
//       If we need more mode bits then we'll need a new reg key for paint timer
#define SPMODE_SHELL      0x00000001
#define SPMODE_DEBUGOUT   0x00000002
#define SPMODE_TEST       0x00000004
#define SPMODE_BROWSER    0x00000008
#define SPMODE_FLUSH      0x00000010
#define SPMODE_EVENT      0x00000020
#define SPMODE_JAVA       0x00000040
#define SPMODE_FORMATTEXT 0x00000080
#define SPMODE_PROFILE    0x00000100
#define SPMODE_DEBUGBREAK 0x00000200
#define SPMODE_MSGTRACE   0x00000400
#define SPMODE_PERFTAGS   0x00000800
#define SPMODE_MEMWATCH   0x00001000
#define SPMODE_DBMON      0x00002000
#define SPMODE_15         0x00004000
#define SPMODE_16         0x00008000
#define SPMODE_RESERVED   0xffff0000
#define SPMODES (SPMODE_SHELL | SPMODE_BROWSER | SPMODE_JAVA |  SPMODE_MSGTRACE | SPMODE_MEMWATCH | SPMODE_DBMON)

// StopWatch node types used in memory log to identify the type of node
#define EMPTY_NODE  0x0
#define START_NODE  0x1
#define LAP_NODE    0x2
#define STOP_NODE   0x3
#define OUT_OF_NODES 0x4

// StopWatch timing ids used to identify the type of timing being performed
#define SWID_STARTUP         0x0
#define SWID_FRAME           0x1
#define SWID_COPY            0x2
#define SWID_TREE            0x3
#define SWID_BROWSER_FRAME   0x4
#define SWID_JAVA_APP        0x5
#define SWID_MENU            0x6
#define SWID_BITBUCKET       0x7
#define SWID_EXPLBAR         0x8
#define SWID_MSGDISPATCH     0x9
#define SWID_TRACEMSG        0xa
#define SWID_DBMON_DLLLOAD   0xb
#define SWID_DBMON_EXCEPTION 0xc
#define SWID_MASK_BROWSER_STOPBTN 0x8000000     // identifies BROWSER_FRAME stop caused by stop button

#define SWID_MASKS         SWID_MASK_BROWSER_STOPBTN // add any SWID_MASK_* defines here

#define SWID(dwId) (dwId & (~SWID_MASKS))

// The following StopWatch messages are used to drive the timer msg handler.  The timer proc is used
// as a means of delaying while watching paint messages.  If the defined number of timer ticks has
// passed without getting any paint messages, then we mark the time of the last paint message we've
// saved as the stop time.
#define SWMSG_PAINT    1    // paint message rcvd
#define SWMSG_TIMER    2    // timer tick
#define SWMSG_CREATE   3    // init handler and create timer
#define SWMSG_STATUS   4    // get status of whether timing is active or not

#define ID_STOPWATCH_TIMER 0xabcd   // Timer id

// Stopwatch defaults
#define STOPWATCH_MAX_NODES                 100
#define STOPWATCH_DEFAULT_PAINT_INTERVAL   1000
#define STOPWATCH_DEFAULT_MAX_DISPATCH_TIME 150
#define STOPWATCH_DEFAULT_MAX_MSG_TIME     1000
#define STOPWATCH_DEFAULT_MAX_MSG_INTERVAL   50
#define STOPWATCH_DEFAULT_CLASSNAMES TEXT("Internet Explorer_Server") TEXT("\0") TEXT("SHELLDLL_DefView") TEXT("\0") TEXT("SysListView32") TEXT("\0\0")

#define MEMWATCH_DEFAULT_PAGES  512
#define MEMWATCH_DEFAULT_TIME  1000
#define MEMWATCH_DEFAULT_FLAGS    0


#ifdef UNICODE
#define StopWatch StopWatchW
#else
#define StopWatch StopWatchA
#endif

#define StopWatch_Start(dwId, pszDesc, dwFlags) StopWatch(dwId, pszDesc, START_NODE, dwFlags, 0)
#define StopWatch_Lap(dwId, pszDesc, dwFlags)   StopWatch(dwId, pszDesc, LAP_NODE, dwFlags, 0)
#define StopWatch_Stop(dwId, pszDesc, dwFlags)  StopWatch(dwId, pszDesc, STOP_NODE, dwFlags, 0)
#define StopWatch_StartTimed(dwId, pszDesc, dwFlags, dwCount)  StopWatch(dwId, pszDesc, START_NODE, dwFlags, dwCount)
#define StopWatch_LapTimed(dwId, pszDesc, dwFlags, dwCount)  StopWatch(dwId, pszDesc, LAP_NODE, dwFlags, dwCount)
#define StopWatch_StopTimed(dwId, pszDesc, dwFlags, dwCount)  StopWatch(dwId, pszDesc, STOP_NODE, dwFlags, dwCount)

VOID InitStopWatchMode(VOID);

// EXPORTED FUNCTIONS
DWORD WINAPI StopWatchW(DWORD dwId, LPCWSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount);
DWORD WINAPI StopWatchA(DWORD dwId, LPCSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount);
DWORD WINAPI StopWatchMode(VOID);
DWORD WINAPI StopWatchFlush(VOID);
BOOL WINAPI StopWatch_TimerHandler(HWND hwnd, UINT uInc, DWORD dwFlag, MSG *pmsg);
VOID WINAPI StopWatch_CheckMsg(HWND hwnd, MSG msg, LPCSTR lpStr);
VOID WINAPI StopWatch_MarkFrameStart(LPCSTR lpExplStr);
VOID WINAPI StopWatch_MarkSameFrameStart(HWND hwnd);
VOID WINAPI StopWatch_MarkJavaStop(LPCSTR  lpStringToSend, HWND hwnd, BOOL fChType);
DWORD WINAPI GetPerfTime(VOID);
VOID WINAPI StopWatch_SetMsgLastLocation(DWORD dwLast);
DWORD WINAPI StopWatch_DispatchTime(BOOL fStartTime, MSG msg, DWORD dwStart);

extern DWORD g_dwStopWatchMode;
//
//=============== End Performance timing macros and prototypes ================

#endif //#ifndef NO_SHLWAPI_STOPWATCH



#ifndef NO_SHLWAPI_INTERNAL
//
//=============== Internal helper routines ===================================

//
//  Declare some OLE interfaces we need to refer to and which aren't
//  already defined in objbase.h
//

#ifndef RC_INVOKED /* { rc doesn't like these long symbol names */
#ifndef __IOleCommandTarget_FWD_DEFINED__
#define __IOleCommandTarget_FWD_DEFINED__
typedef struct IOleCommandTarget IOleCommandTarget;
#endif  /* __IOleCommandTarget_FWD_DEFINED__ */

#ifndef __IDropTarget_FWD_DEFINED__
#define __IDropTarget_FWD_DEFINED__
typedef struct IDropTarget IDropTarget;
#endif  /* __IDropTarget_FWD_DEFINED__ */

#ifndef __IPropertyBag_FWD_DEFINED__
#define __IPropertyBag_FWD_DEFINED__
typedef struct IPropertyBag IPropertyBag;
#endif  /* __IPropertyBag_FWD_DEFINED__ */

#ifndef __IConnectionPoint_FWD_DEFINED__
#define __IConnectionPoint_FWD_DEFINED__
typedef struct IConnectionPoint IConnectionPoint;
#endif  /* __IConnectionPoint_FWD_DEFINED__ */

    LWSTDAPI_(void) IUnknown_AtomicRelease(void ** ppunk);
    LWSTDAPI_(BOOL) SHIsSameObject(IUnknown* punk1, IUnknown* punk2);
    LWSTDAPI IUnknown_GetWindow(IUnknown* punk, HWND* phwnd);
    LWSTDAPI IUnknown_SetOwner(IUnknown* punk, IUnknown* punkOwner);
    LWSTDAPI IUnknown_SetSite(IUnknown *punk, IUnknown *punkSite);
    LWSTDAPI IUnknown_GetSite(IUnknown *punk, REFIID riid, void **ppvOut);
    LWSTDAPI IUnknown_EnableModless(IUnknown * punk, BOOL fEnabled);
    LWSTDAPI IUnknown_GetClassID(IUnknown *punk, CLSID *pclsid);
    LWSTDAPI IUnknown_QueryService(IUnknown* punk, REFGUID guidService, REFIID riid, void ** ppvOut);
    LWSTDAPI IUnknown_HandleIRestrict(IUnknown * punk, const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult);
    LWSTDAPI IUnknown_OnFocusOCS(IUnknown *punk, BOOL fGotFocus);
    LWSTDAPI IUnknown_TranslateAcceleratorOCS(IUnknown *punk, LPMSG lpMsg, DWORD grfMods);
    LWSTDAPI_(void) IUnknown_Set(IUnknown ** ppunk, IUnknown * punk);

    LWSTDAPI SHWeakQueryInterface(IUnknown *punkOuter, IUnknown *punkTarget, REFIID riid, void **ppvOut);
    LWSTDAPI_(void) SHWeakReleaseInterface(IUnknown *punkOuter, IUnknown **ppunk);

    // Helper macros for the Weak interface functions.
    #define     SHQueryInnerInterface           SHWeakQueryInterface
    #define     SHReleaseInnerInterface         SHWeakReleaseInterface
    #define     SHReleaseOuterInterface         SHWeakReleaseInterface

    __inline HRESULT SHQueryOuterInterface(IUnknown *punkOuter, REFIID riid, void **ppvOut)
    {
        return SHWeakQueryInterface(punkOuter, punkOuter, riid, ppvOut);
    }

#if defined(__IOleAutomationTypes_INTERFACE_DEFINED__) && \
    defined(__IOleCommandTarget_INTERFACE_DEFINED__)
    LWSTDAPI IUnknown_QueryStatus(IUnknown *punk, const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    LWSTDAPI IUnknown_Exec(IUnknown* punk, const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // Some of the many connection point helper functions available in
    // connect.cpp.  We export only the ones people actually use.  If
    // you need a helper function, maybe it's already in connect.cpp
    // and merely needs to be exported.

    LWSTDAPI SHPackDispParamsV(DISPPARAMS * pdispparams, VARIANTARG *rgvt,
                               UINT cArgs, va_list arglist);
    LWSTDAPIV SHPackDispParams(DISPPARAMS * pdispparams, VARIANTARG *rgvt,
                               UINT cArgs, ...);

    typedef HRESULT (CALLBACK *SHINVOKECALLBACK)(IDispatch *pdisp, struct SHINVOKEPARAMS *pinv);

    typedef struct SHINVOKEPARAMS {
        UINT flags;                     // mandatory
        DISPID dispidMember;            // mandatory
        const IID*piid;                 // IPFL_USEDEFAULTS will fill this in
        LCID lcid;                      // IPFL_USEDEFAULTS will fill this in
        WORD wFlags;                    // IPFL_USEDEFAULTS will fill this in
        DISPPARAMS * pdispparams;       // mandatory, may be NULL
        VARIANT * pvarResult;           // IPFL_USEDEFAULTS will fill this in
        EXCEPINFO * pexcepinfo;         // IPFL_USEDEFAULTS will fill this in
        UINT * puArgErr;                // IPFL_USEDEFAULTS will fill this in
        SHINVOKECALLBACK Callback;      // required if IPFL_USECALLBACK
    } SHINVOKEPARAMS, *LPSHINVOKEPARAMS;

    #define IPFL_USECALLBACK        0x0001
    #define IPFL_USEDEFAULTS        0x0002

#if 0 // These functions not yet needed
    LWSTDAPI IConnectionPoint_InvokeIndirect(IConnectionPoint *pcp,
                            SHINVOKEPARAMS *pinv);
#endif

    LWSTDAPI IConnectionPoint_InvokeWithCancel(IConnectionPoint *pcp,
                    DISPID dispidMember, DISPPARAMS * pdispparams,
                    LPBOOL pfCancel, LPVOID *ppvCancel);
    LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp,
                    DISPID dispidMember, DISPPARAMS * pdispparams);

#if 0 // These functions not yet needed
    LWSTDAPI IConnectionPoint_InvokeParamV(IConnectionPoint *pcp,
                    DISPID dispidMember, VARIANTARG *rgvarg,
                    UINT cArgs, va_list ap);
    LWSTDAPIV IConnectionPoint_InvokeParam(IConnectionPoint *pcp,
                    DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...)
#endif

    LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);

#if 0 // These functions not yet needed
    LWSTDAPI IUnknown_FindConnectionPoint(IUnknown *punk,
                    REFIID riidCP, IConnectionPoint **pcpOut);
#endif

    LWSTDAPI IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
                SHINVOKEPARAMS *pinv);
    LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP,
                DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);
    LWSTDAPI IUnknown_CPContainerOnChanged(IUnknown *punk, DISPID dispid);

#endif /* IOleAutomationTypes && IOleCommandTarget */
#endif  /* } !RC_INVOKED */

    LWSTDAPI IStream_Read(IStream *pstm, void *pv, ULONG cb);
    LWSTDAPI IStream_Write(IStream *pstm, const void *pv, ULONG cb);
    LWSTDAPI IStream_Reset(IStream *pstm);
    LWSTDAPI IStream_Size(IStream *pstm, ULARGE_INTEGER *pui);

    LWSTDAPI_(BOOL) SHIsEmptyStream(IStream* pstm);

    LWSTDAPI SHSimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                         const POINTL *ppt, DWORD *pdwEffect);

    LWSTDAPI SHLoadFromPropertyBag(IUnknown* punk, IPropertyBag* ppg);

    LWSTDAPI ConnectToConnectionPoint(IUnknown* punkThis, REFIID riidEvent, BOOL fConnect, IUnknown* punkTarget, DWORD* pdwCookie, IConnectionPoint** ppcpOut);

/*
 *  Like PrivateProfileString except that UNICODE strings are encoded so they
 *  will successfully round-trip.
 */
LWSTDAPI_(DWORD) SHGetIniStringW(LPCWSTR lpSection, LPCWSTR lpKey, LPWSTR lpBuf, DWORD nSize, LPCWSTR lpFile);
#define SHGetIniStringA(lpSection, lpKey, lpBuf, nSize, lpFile) \
        GetPrivateProfileStringA(lpSection, lpKey, "", lpBuf, nSize, lpFile)

LWSTDAPI_(BOOL) SHSetIniStringW(LPCWSTR lpSection, LPCWSTR lpKey, LPCWSTR lpString, LPCWSTR lpFile);
#define SHSetIniStringA  WritePrivateProfileStringA

LWSTDAPI CreateURLFileContentsW(LPCWSTR pwszUrl, LPSTR *ppszOut);
LWSTDAPI CreateURLFileContentsA(LPCSTR pszUrl, LPSTR *ppszOut);

#ifdef UNICODE
#define SHGetIniString SHGetIniStringW
#define SHSetIniString SHSetIniStringW
#define CreateURLFileContents CreateURLFileContentsW
#else
#define SHGetIniString SHGetIniStringA
#define SHSetIniString SHSetIniStringA
#define CreateURLFileContents CreateURLFileContentsA
#endif // UNICODE

/*
 *  We say `struct IShellFolder' because the definition of IShellFolder
 *  doesn't show up until later when shlobj.h is included.  Similarly, we
 *  insert a temporary definition of LPCITEMIDLIST.
 */

#define LPCITEMIDLIST const UNALIGNED struct _ITEMIDLIST *
#define  LPITEMIDLIST       UNALIGNED struct _ITEMIDLIST *

#define ISHGDN2_CANREMOVEFORPARSING     0x0001
LWSTDAPI IShellFolder_GetDisplayNameOf(struct IShellFolder *psf,
    LPCITEMIDLIST pidl, DWORD uFlags, struct _STRRET *pstr, DWORD dwFlags2);

LWSTDAPI IShellFolder_ParseDisplayName(struct IShellFolder *psf, HWND hwnd,
    struct IBindCtx *pbc, LPWSTR pszDisplayName, ULONG *pchEaten,
    LPITEMIDLIST *ppidl, ULONG *pdwAttributes);

LWSTDAPI IShellFolder_EnumObjects(struct IShellFolder *psf, HWND hwnd,
    DWORD grfFlags, struct IEnumIDList **ppenumIDList);

LWSTDAPI_(BOOL) SHIsExpandableFolder(struct IShellFolder *psf, LPCITEMIDLIST pidl);
LWSTDAPI IContextMenu_Invoke(struct IContextMenu* pcm, HWND hwndOwner, LPCSTR pVerb, UINT fFlags);

#undef LPCITEMIDLIST
#undef  LPITEMIDLIST

#ifdef UNICODE
// SHTruncateString takes a BUFFER SIZE, so subtract 1 to properly null terminate.
//
#define SHTruncateString(wzStr, cch)            ((cch) ? ((wzStr)[cch-1]=L'\0', (cch-1)) : 0)
#else
LWSTDAPI_(int)  SHTruncateString(CHAR *sz, int cchBufferSize);
#endif // UNICODE

// SHFormatDateTime flags
//  (FDTF_SHORTDATE and FDTF_LONGDATE are mutually exclusive, as is
//   FDTF_SHORTIME and FDTF_LONGTIME.)
//
#define FDTF_SHORTTIME      0x00000001      // eg, "7:48 PM"
#define FDTF_SHORTDATE      0x00000002      // eg, "3/29/98"
#define FDTF_DEFAULT        (FDTF_SHORTDATE | FDTF_SHORTTIME) // eg, "3/29/98 7:48 PM"
#define FDTF_LONGDATE       0x00000004      // eg, "Monday, March 29, 1998"
#define FDTF_LONGTIME       0x00000008      // eg. "7:48:33 PM"
#define FDTF_RELATIVE       0x00000010      // uses "Yesterday", etc. if possible
#define FDTF_LTRDATE        0x00000100      // Left To Right reading order
#define FDTF_RTLDATE        0x00000200      // Right To Left reading order

LWSTDAPI_(int)  SHFormatDateTimeA(const FILETIME * pft, DWORD * pdwFlags, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(int)  SHFormatDateTimeW(const FILETIME * pft, DWORD * pdwFlags, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define SHFormatDateTime  SHFormatDateTimeW
#else
#define SHFormatDateTime  SHFormatDateTimeA
#endif // !UNICODE

LWSTDAPI_(SECURITY_ATTRIBUTES*) CreateAllAccessSecurityAttributes(SECURITY_ATTRIBUTES* psa, SECURITY_DESCRIPTOR* psd, PACL *ppacl);

LWSTDAPI_(int)  SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
LWSTDAPI_(int)  SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
LWSTDAPI_(int)  SHAnsiToAnsi(LPCSTR pszSrc, LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToAnsiCP(UINT uiCP, LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToUnicode(LPCWSTR pwzSrc, LPWSTR pwzDst, int cwchBuf);
LWSTDAPI_(BOOL) DoesStringRoundTripA(LPCSTR pwszIn, LPSTR pszOut, UINT cchOut);
LWSTDAPI_(BOOL) DoesStringRoundTripW(LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut);
#ifdef UNICODE
#define DoesStringRoundTrip     DoesStringRoundTripW
#else
#define DoesStringRoundTrip     DoesStringRoundTripA
#endif

// The return value from all SH<Type>To<Type> is the size of szDest including the terminater.
#ifdef UNICODE
#define SHTCharToUnicode(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToUnicodeCP(uiCP, wzSrc, wzDest, cchSize)        SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToAnsi(wzSrc, szDest, cchSize)                   SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHTCharToAnsiCP(uiCP, wzSrc, szDest, cchSize)           SHUnicodeToAnsiCP(uiCP, wzSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHUnicodeToTCharCP(uiCP, wzSrc, wzDest, cchSize)        SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHAnsiToTChar(szSrc, wzDest, cchSize)                   SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHAnsiToTCharCP(uiCP, szSrc, wzDest, cchSize)           SHAnsiToUnicodeCP(uiCP, szSrc, wzDest, cchSize)
#define SHOtherToTChar(szSrc, szDest, cchSize)                  SHAnsiToUnicode(szSrc, szDest, cchSize)
#define SHTCharToOther(szSrc, szDest, cchSize)                  SHUnicodeToAnsi(szSrc, szDest, cchSize)
#else // UNICODE
#define SHTCharToUnicode(szSrc, wzDest, cchSize)                SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHTCharToUnicodeCP(uiCP, szSrc, wzDest, cchSize)        SHAnsiToUnicodeCP(uiCP, szSrc, wzDest, cchSize)
#define SHTCharToAnsi(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHTCharToAnsiCP(uiCP, szSrc, szDest, cchSize)           SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, szDest, cchSize)                SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHUnicodeToTCharCP(uiCP, wzSrc, szDest, cchSize)        SHUnicodeToAnsiCP(uiCP, wzSrc, szDest, cchSize)
#define SHAnsiToTChar(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHAnsiToTCharCP(uiCP, szSrc, szDest, cchSize)           SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHOtherToTChar(szSrc, szDest, cchSize)                  SHUnicodeToAnsi(szSrc, szDest, cchSize)
#define SHTCharToOther(szSrc, szDest, cchSize)                  SHAnsiToUnicode(szSrc, szDest, cchSize)
#endif // UNICODE

LWSTDAPI_(BOOL)    SHRegisterClassA(const WNDCLASSA* pwc);
LWSTDAPI_(BOOL)    SHRegisterClassW(const WNDCLASSW* pwc);
LWSTDAPI_(void)    SHUnregisterClassesA(HINSTANCE hinst, const LPCSTR *rgpszClasses, UINT cpsz);
LWSTDAPI_(void)    SHUnregisterClassesW(HINSTANCE hinst, const LPCWSTR *rgpszClasses, UINT cpsz);
LWSTDAPI_(int) SHMessageBoxCheckW(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, int iDefault, LPCWSTR pszRegVal);
LWSTDAPI_(int) SHMessageBoxCheckA(HWND hwnd, LPCSTR pszText, LPCSTR pszCaption, UINT uType, int iDefault, LPCSTR pszRegVal);
LWSTDAPI_(void) SHRestrictedMessageBox(HWND hwnd);
LWSTDAPI_(HMENU) SHGetMenuFromID(HMENU hmMain, UINT uID);
LWSTDAPI_(int) SHMenuIndexFromID(HMENU hm, UINT id);
LWSTDAPI_(void) SHRemoveDefaultDialogFont(HWND hDlg);
LWSTDAPI_(void) SHSetDefaultDialogFont(HWND hDlg, int idCtl);
LWSTDAPI_(void) SHRemoveAllSubMenus(HMENU hmenu);
LWSTDAPI_(void) SHEnableMenuItem(HMENU hmenu, UINT id, BOOL fEnable);
LWSTDAPI_(void) SHCheckMenuItem(HMENU hmenu, UINT id, BOOL fChecked);
LWSTDAPI_(void) SHSetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
LWSTDAPI_(HMENU) SHLoadMenuPopup(HINSTANCE hinst, UINT id);
LWSTDAPI_(void) SHPropagateMessage(HWND hwndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fSend);
LWSTDAPI_(void) SHSetParentHwnd(HWND hwnd, HWND hwndParent);
LWSTDAPI_(UINT) SHGetCurColorRes();
LWSTDAPI_(DWORD) SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);
LWSTDAPI_(BOOL) SHVerbExistsNA(LPCSTR szExtension, LPCSTR pszVerb, LPSTR pszCommand, DWORD cchCommand);
LWSTDAPI_(void) SHFillRectClr(HDC hdc, LPRECT prc, COLORREF clr);
LWSTDAPI_(int) SHSearchMapInt(const int *src, const int *dst, int cnt, int val);
LWSTDAPI_(CHAR) SHStripMneumonicA(LPSTR pszMenu);
LWSTDAPI_(WCHAR) SHStripMneumonicW(LPWSTR pszMenu);
LWSTDAPI SHIsChildOrSelf(HWND hwndParent, HWND hwnd);
LWSTDAPI_(DWORD) SHGetValueGoodBootA(HKEY hkeyParent, LPCSTR pcszSubKey,
                                   LPCSTR pcszValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen);
LWSTDAPI_(DWORD) SHGetValueGoodBootW(HKEY hkeyParent, LPCWSTR pcwzSubKey,
                                   LPCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen);
LWSTDAPI_(LRESULT) SHDefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


LWSTDAPI_(BOOL) SHGetFileDescriptionA(LPCSTR pszPath, LPCSTR pszVersionKeyIn, LPCSTR pszCutListIn, LPSTR pszDesc, UINT *pcchDesc);
LWSTDAPI_(BOOL) SHGetFileDescriptionW(LPCWSTR pszPath, LPCWSTR pszVersionKeyIn, LPCWSTR pszCutListIn, LPWSTR pszDesc, UINT *pcchDesc);
#ifdef UNICODE
#define SHGetFileDescription  SHGetFileDescriptionW
#else
#define SHGetFileDescription  SHGetFileDescriptionA
#endif // !UNICODE

LWSTDAPI_(int) SHMessageBoxCheckExA(HWND hwnd, HINSTANCE hinst, LPCSTR pszTemplateName, DLGPROC pDlgProc, LPVOID pData, int iDefault, LPCSTR pszRegVal);
LWSTDAPI_(int) SHMessageBoxCheckExW(HWND hwnd, HINSTANCE hinst, LPCWSTR pszTemplateName, DLGPROC pDlgProc, LPVOID pData, int iDefault, LPCWSTR pszRegVal);
#ifdef UNICODE
#define SHMessageBoxCheckEx  SHMessageBoxCheckExW
#else
#define SHMessageBoxCheckEx  SHMessageBoxCheckExA
#endif // !UNICODE

#define IDC_MESSAGEBOXCHECKEX 0x1202

// Prevents shell hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastA(UINT uMsg, WPARAM wParam, LPARAM lParam);
// Prevents shell hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastW(UINT uMsg, WPARAM wParam, LPARAM lParam);
#ifdef UNICODE
#define SHSendMessageBroadcast  SHSendMessageBroadcastW
#else
#define SHSendMessageBroadcast  SHSendMessageBroadcastA
#endif // !UNICODE

#ifdef UNICODE
#define SHGetValueGoodBoot      SHGetValueGoodBootW
#define SHStripMneumonic        SHStripMneumonicW
#define SHMessageBoxCheck       SHMessageBoxCheckW
#define SHRegisterClass         SHRegisterClassW
#define SHUnregisterClasses     SHUnregisterClassesW
#define SHSendMessageBroadcast  SHSendMessageBroadcastW
#else // UNICODE
#define SHGetValueGoodBoot      SHGetValueGoodBootA
#define SHStripMneumonic        SHStripMneumonicA
#define SHMessageBoxCheck       SHMessageBoxCheckA
#define SHRegisterClass         SHRegisterClassA
#define SHUnregisterClasses     SHUnregisterClassesA
#define SHSendMessageBroadcast  SHSendMessageBroadcastA
#endif // UNICODE





// Returns TRUE/FALSE depending on question

#define OS_WINDOWS                  0           // windows vs. NT
#define OS_NT                       1           // windows vs. NT
#define OS_WIN95                    2           // Win95 or greater
#define OS_NT4                      3           // NT4 or greater
#define OS_NT5                      4           // NT5 or greater
#define OS_MEMPHIS                  5           // Win98 or greater
#define OS_MEMPHIS_GOLD             6           // Win98 Gold
#define OS_WIN2000                  7           // Some derivative of Win2000
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server
#define OS_WIN2000EMBED             13          // Windows 2000 Embedded Edition
#define OS_TERMINALCLIENT           14          // Windows Terminal Client (Not version specific)
#define OS_TERMINALREMOTEADMIN      15          // Windows 2000 Terminal Server in "Remote Administration" mode
#define OS_WIN95GOLD                16          // Windows 95 Gold (Version 4.0 Build 1995)

LWSTDAPI_(BOOL) IsOS(DWORD dwOS);

///// BEGIN Private CommandTarget helpers
//***   IOleCommandTarget helpers {

//***   octd -- OleCT direction
// NOTES
//  used both as a return value from IsXxxForward, and as an iUpDown
//  param for MayXxxForward.
enum octd {
    // do *not* change these values; we rely upon all 3 of:
    //  - sign +/-
    //  - powers of 2
    //  - (?) broadcast > down
    OCTD_DOWN=+1,
    OCTD_DOWNBROADCAST=+2,
    OCTD_UP=-1
};


#ifndef RC_INVOKED /* { rc doesn't like these long symbol names */
#ifdef __IOleCommandTarget_INTERFACE_DEFINED__
    HRESULT IsQSForward(const GUID *pguidCmdGroup, int cCmds, OLECMD rgCmds[]);
    // WARNING: note the hoaky cast of nCmdID to a struct ptr
    #define IsExecForward(pguidCmdGroup, nCmdID) \
        IsQSForward(pguidCmdGroup, 1, (OLECMD *) &nCmdID)

    HRESULT MayQSForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    HRESULT MayExecForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
#endif //__IOleCommandTarget_INTERFACE_DEFINED__
#endif  /* } !RC_INVOKED */
// }
///// end



#ifdef WANT_SHLWAPI_POSTSPLIT

typedef struct _FDSA {
    // cItem *must* be at beginning of struct for GetItemCount() to work
    int     cItem;          // # elements
    void *  aItem;          // data for elements (either static or dynamic)
    int     cItemAlloc;     // # of elements currently alloc'ed (>= cItem)
    int     cItemGrow:8;    // # of elements to grow cItemAlloc by
    int     cbItem:8;       // sizeof element
    DWORD   fAllocated:1;   // 1:overflowed from static to dynamic array
    DWORD     unused:15;
} FDSA, *PFDSA;

LWSTDAPI_(BOOL)  FDSA_Initialize(int cbItem, int cItemGrow, PFDSA pfdsa, void * aItemStatic, int cItemStatic);
LWSTDAPI_(BOOL)  FDSA_Destroy(PFDSA pfdsa);
LWSTDAPI_(int)   FDSA_InsertItem(PFDSA pfdsa, int index, void * pitem);
LWSTDAPI_(BOOL)  FDSA_DeleteItem(PFDSA pfdsa, int index);

#define FDSA_AppendItem(pfdsa, pitem)       FDSA_InsertItem(pfdsa, DA_LAST, pitem)
#define FDSA_GetItemPtr(pfdsa, i, type)     (&(((type *)((pfdsa)->aItem))[(i)]))
#define FDSA_GetItemCount(hdsa)      (*(int *)(hdsa))
#endif // WANT_SHLWAPI_POSTSPLIT




#if defined( __LPGUID_DEFINED__ )
// Copied from OLE source code
// format for string form of GUID is:
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

LWSTDAPI_(BOOL) GUIDFromStringA(LPCSTR psz, LPGUID pguid);
LWSTDAPI_(BOOL) GUIDFromStringW(LPCWSTR psz, LPGUID pguid);
#ifdef UNICODE
#define GUIDFromString  GUIDFromStringW
#else
#define GUIDFromString  GUIDFromStringA
#endif // !UNICODE

#endif

#ifdef _REFGUID_DEFINED
LWSTDAPI_(int) SHStringFromGUIDA(UNALIGNED REFGUID rguid, LPSTR psz, int cchMax);
LWSTDAPI_(int) SHStringFromGUIDW(UNALIGNED REFGUID rguid, LPWSTR psz, int cchMax);
#ifdef UNICODE
#define SHStringFromGUID  SHStringFromGUIDW
#else
#define SHStringFromGUID  SHStringFromGUIDA
#endif // !UNICODE

LWSTDAPI SHRegGetCLSIDKeyA(UNALIGNED REFGUID rguid, LPCSTR lpszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey);
LWSTDAPI SHRegGetCLSIDKeyW(UNALIGNED REFGUID rguid, LPCWSTR lpszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey);
#ifdef UNICODE
#define SHRegGetCLSIDKey  SHRegGetCLSIDKeyW
#else
#define SHRegGetCLSIDKey  SHRegGetCLSIDKeyA
#endif // !UNICODE

LWSTDAPI_(HANDLE) SHGlobalCounterCreate(REFGUID rguid);
LWSTDAPI_(HANDLE) SHGlobalCounterCreateNamedA(LPCSTR szName, LONG lInitialValue);
LWSTDAPI_(HANDLE) SHGlobalCounterCreateNamedW(LPCWSTR szName, LONG lInitialValue);
#ifdef UNICODE
#define SHGlobalCounterCreateNamed  SHGlobalCounterCreateNamedW
#else
#define SHGlobalCounterCreateNamed  SHGlobalCounterCreateNamedA
#endif // !UNICODE
LWSTDAPI_(long) SHGlobalCounterGetValue(HANDLE hCounter);
LWSTDAPI_(long) SHGlobalCounterIncrement(HANDLE hCounter);
LWSTDAPI_(long) SHGlobalCounterDecrement(HANDLE hCounter);
#define         SHGlobalCounterDestroy      CloseHandle
#endif

// WNDPROCs are thunked by user to send ANSI/UNICODE messages (ex: WM_WININICHANGE)
// so providing a W version that automatically thunks to the A version
// is dangerous.  but we do it anyway.  if a caller needs to work on both win95 and NT
// it needs to be aware that on win95 the W version actually calls the A version.
// thus all worker windows on win95 are ANSI.  this should rarely affect worker wndprocs
// because they are internal, and the messages are usually custom.  but system messages
// like WM_WININICHANGE, and the WM_DDE* messages will be changed accordingly
HWND SHCreateWorkerWindowA(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p);
HWND SHCreateWorkerWindowW(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p);
#ifdef UNICODE
#define SHCreateWorkerWindow SHCreateWorkerWindowW
#else
#define SHCreateWorkerWindow SHCreateWorkerWindowA
#endif

BOOL    SHAboutInfoA(LPSTR lpszInfo, DWORD cchSize);
BOOL    SHAboutInfoW(LPWSTR lpszInfo, DWORD cchSize);

#ifdef UNICODE
#define SHAboutInfo SHAboutInfoW
#else
#define SHAboutInfo SHAboutInfoA
#endif

// Types for SHIsLowMemoryMachine
#define ILMM_IE4    0       // 1997-style machine

LWSTDAPI_(BOOL) SHIsLowMemoryMachine(DWORD dwType);

LWSTDAPI_(HINSTANCE) SHPinDllOfCLSID(const CLSID *pclsid);

// Menu Helpers
LWSTDAPI_(int)  GetMenuPosFromID(HMENU hmenu, UINT id);

LWSTDAPI        SHGetInverseCMAP(BYTE *pbMap, ULONG cbMap);

//
// Shared memory apis
//

LWSTDAPI_(HANDLE)   SHAllocShared(LPCVOID lpvData, DWORD dwSize, DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHFreeShared(HANDLE hData,DWORD dwProcessId);
LWSTDAPI_(void *)   SHLockShared(HANDLE hData, DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHUnlockShared(void *lpvData);
LWSTDAPI_(HANDLE)   SHMapHandle(HANDLE h, DWORD dwProcSrc, DWORD dwProcDest, DWORD dwDesiredAccess, DWORD dwFlags);

#ifdef UNIX
#include <urlmon.h>
#endif /* UNIX */

//
//  Zone Security APIs
//
LWSTDAPI ZoneCheckPathA(LPCSTR pszPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckPathW(LPCWSTR pwzPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);

LWSTDAPI ZoneCheckUrlA(LPCSTR pszUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlW(LPCWSTR pwzUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlExA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlExW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlExCacheA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize,
                            DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache);
LWSTDAPI ZoneCheckUrlExCacheW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize,
                            DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache);

LWSTDAPI ZoneCheckHost(IInternetHostSecurityManager * pihsm, DWORD dwActionType, DWORD dwFlags);
LWSTDAPI ZoneCheckHostEx(IInternetHostSecurityManager * pihsm, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags);
LWSTDAPI_(int) ZoneComputePaneSize(HWND hwndStatus);
LWSTDAPI_(void) ZoneConfigureW(HWND hwnd, LPCWSTR pwszUrl);

#ifdef UNICODE
#define ZoneCheckUrl            ZoneCheckUrlW
#define ZoneCheckPath           ZoneCheckPathW
#define ZoneCheckUrlEx          ZoneCheckUrlExW
#define ZoneCheckUrlExCache     ZoneCheckUrlExCacheW
#else // UNICODE
#define ZoneCheckUrl            ZoneCheckUrlA
#define ZoneCheckPath           ZoneCheckPathA
#define ZoneCheckUrlEx          ZoneCheckUrlExA
#define ZoneCheckUrlExCache     ZoneCheckUrlExCacheA
#endif // UNICODE

LWSTDAPI SHRegisterValidateTemplate(LPCWSTR pwzTemplate, DWORD dwFlags);

// Flags for SHRegisterValidateTemplate
#define SHRVT_REGISTER                  0x00000001
#define SHRVT_VALIDATE                  0x00000002
#define SHRVT_PROMPTUSER                0x00000004
#define SHRVT_REGISTERIFPROMPTOK        0x00000008
#define SHRVT_VALID                     0x0000000f

BOOL RegisterGlobalHotkeyW(WORD wOldHotkey, WORD wNewHotkey,LPCWSTR pcwszPath);
BOOL RegisterGlobalHotkeyA(WORD wOldHotkey, WORD wNewHotkey,LPCSTR pcszPath);

LWSTDAPI_(UINT) WhichPlatform(void);

// Return values of WhichPlatform
#define PLATFORM_UNKNOWN     0
#define PLATFORM_IE3         1      // obsolete: use PLATFORM_BROWSERONLY
#define PLATFORM_BROWSERONLY 1      // browser-only (no new shell)
#define PLATFORM_INTEGRATED  2      // integrated shell

#ifdef UNICODE
#define RegisterGlobalHotkey    RegisterGlobalHotkeyW
#else // UNICODE
#define RegisterGlobalHotkey    RegisterGlobalHotkeyA
#endif // UNICODE

// qistub {

//***   QueryInterface helpers
// NOTES
//  ATL has a fancier version of this.  if we need to extend ours, we
//  should probably just switch to ATL's rather than reinvent.
// EXAMPLE
//  Cfoo::QI(REFIID riid, void **ppv)
//  {
//      // (the IID_xxx comments make grep'ing work!)
//      static const QITAB qit = {
//          QITABENT(Cfoo, Iiface1),    // IID_Iiface1
//          ...
//          QITABENT(Cfoo, IifaceN),    // IID_IifaceN
//          { 0 },                      // n.b. don't forget the 0
//      };
//
//      // n.b. make sure you don't cast 'this'
//      hr = QISearch(this, qit, riid, ppv);
//      if (FAILED(hr))
//          hr = SUPER::QI(riid, ppv);
//      // custom code could be added here for FAILED() case
//      return hr;
//  }

typedef struct
{
    const IID * piid;
    int         dwOffset;
} QITAB, *LPQITAB;
typedef const QITAB *LPCQITAB;

#define QITABENTMULTI(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#define QITABENTMULTI2(Cthis, Ifoo, Iimpl) \
    { (IID*) &Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#define QITABENT(Cthis, Ifoo) QITABENTMULTI(Cthis, Ifoo, Ifoo)

STDAPI QISearch(void* that, LPCQITAB pqit, REFIID riid, void **ppv);


#ifndef STATIC_CAST
//***   STATIC_CAST -- 'portable' static_cast<>
// NOTES
//  do *not* use SAFE_CAST (see comment in OFFSETOFCLASS)
#define STATIC_CAST(typ)   static_cast<typ>
#ifndef _X86_
    // assume only intel compiler (>=vc5) supports static_cast for now
    // we could key off of _MSC_VER >= 1100 but i'm not sure that will work
    //
    // a straight cast will give the correct result but no error checking,
    // so we'll have to catch errors on intel.
    #undef  STATIC_CAST
    #define STATIC_CAST(typ)   (typ)
#endif
#endif

#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(STATIC_CAST(base*)((derived*)8))-8)
#endif

// } qistub


#if (_WIN32_IE >= 0x0500)

// SHRestrictionLookup
typedef struct
{
    INT     iFlag;
    LPCWSTR pszKey;
    LPCWSTR pszValue;
} SHRESTRICTIONITEMS;

LWSTDAPI_(DWORD) SHRestrictionLookup(INT iFlag, LPCWSTR pszBaseKey,
                                     const SHRESTRICTIONITEMS *pRestrictions,
                                     DWORD* rdwRestrictionItemValues);
LWSTDAPI_(DWORD) SHGetRestriction(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszSubKey);

typedef INT_PTR (CALLBACK* SHDLGPROC)(void *lpData, HWND, UINT, WPARAM, LPARAM);
LWSTDAPI_(INT_PTR) SHDialogBox(HINSTANCE hInstance, LPCWSTR lpTemplateName,
    HWND hwndParent, SHDLGPROC lpDlgFunc, void*lpData);

LWSTDAPI SHInvokeDefaultCommand(HWND hwnd, struct IShellFolder* psf, const UNALIGNED struct _ITEMIDLIST *pidl);
LWSTDAPI SHInvokeCommand(HWND hwnd, struct IShellFolder* psf, const UNALIGNED struct _ITEMIDLIST *pidl, LPCSTR lpVerb);

#endif // _WIN32_IE >= 0x0500

//============= Internal Routines that are always to be built ================
LWSTDAPI_(DWORD)
GetLongPathNameWrapW(
        LPCWSTR lpszShortPath,
        LPWSTR lpszLongPath,
        DWORD cchBuffer);

LWSTDAPI_(DWORD)
GetLongPathNameWrapA(
        LPCSTR lpszShortPath,
        LPSTR lpszLongPath,
        DWORD cchBuffer);

#ifdef UNICODE
#define GetLongPathNameWrap         GetLongPathNameWrapW
#else
#define GetLongPathNameWrap         GetLongPathNameWrapA
#endif //UNICODE


//=============== Unicode Wrapper Routines ===================================

#if (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_UNITHUNK)

//
//  There are two styles of usage for the wrap functions.
//
//  *   Explicit wrapping.
//
//      If you explicitly call GetPropWrap (for example), then
//      your UNICODE build will call the wrapper function, and your ANSI
//      build will call the normal ANSI API directly.
//
//      Calls to GetProp, GetPropW, and GetPropA still go
//      directly to the underlying system DLL that implements them.
//
//      This lets you select which calls to UNICODE APIs should get
//      wrapped and which should go straight through to the OS
//      (and most likely fail on Win95).
//
//  *   Automatic wrapping.
//
//      If you #include <w95wraps.h>, then when you call GetProp,
//      your UNICODE build will call the wrapper function, and your ANSI
//      ANSI build will call the normal ANSI API directly.
//
//      This lets you just call the UNICODE APIs normally throughout
//      your code, and the wrappers will do their best.
//
//  Here's a table explaining what you get under the various scenarios.
//
//                    You Get
//                                                <w95wraps.h>  <w95wraps.h>
//      You Write     UNICODE       ANSI          UNICODE       ANSI
//      ============  ============  ============  ============  ============
//      GetProp       GetPropW      GetPropA      GetPropWrapW  GetPropA
//      GetPropWrap   GetPropWrapW  GetPropA      GetPropWrapW  GetPropA
//
//      GetPropW      GetPropW      GetPropW      GetPropWrapW  GetPropWrapW
//      GetPropA      GetPropA      GetPropA      GetPropA      GetPropA
//      GetPropWrapW  GetPropWrapW  GetPropWrapW  GetPropWrapW  GetPropWrapW
//      GetPropWrapA  GetPropA      GetPropA      GetPropA      GetPropA
//
//  Final quirk:  If you are running on a non-x86 platform, then the
//  wrap functions are forwarded to the unwrapped functions, since
//  the only OS that runs on non-x86 is NT.
//
//  Before using the wrapper functions, see the warnings at the top of
//  <w95wraps.h> to make sure you understand the consequences.
//
LWSTDAPI_(BOOL) IsCharAlphaWrapW(IN WCHAR ch);
LWSTDAPI_(BOOL) IsCharUpperWrapW(IN WCHAR ch);
LWSTDAPI_(BOOL) IsCharLowerWrapW(IN WCHAR ch);
LWSTDAPI_(BOOL) IsCharAlphaNumericWrapW(IN WCHAR ch);

LWSTDAPI_(BOOL)
AppendMenuWrapW(
    IN HMENU hMenu,
    IN UINT uFlags,
    IN UINT_PTR uIDNewItem,
    IN LPCWSTR lpNewItem
    );

LWSTDAPI_(LRESULT)
CallWindowProcWrapW(
    WNDPROC lpPrevWndFunc,
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam);

#ifdef POST_IE5_BETA
LWSTDAPI_(BOOL) CallMsgFilterWrapW(LPMSG lpMsg, int nCode);
#endif

LWSTDAPI_(LPWSTR) CharLowerWrapW( LPWSTR pch );

LWSTDAPI_(DWORD)  CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );

LWSTDAPI_(LPWSTR) CharNextWrapW(LPCWSTR lpszCurrent);
LWSTDAPI_(LPWSTR) CharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
LWSTDAPI_(BOOL)   CharToOemWrapW(LPCWSTR lpszSrc, LPSTR lpszDst);
LWSTDAPI_(LPWSTR) CharUpperWrapW( LPWSTR pch );
LWSTDAPI_(DWORD)  CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength );

LWSTDAPI_(HRESULT) CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid);
LWSTDAPI_(HRESULT) CLSIDFromProgIDWrap(LPCOLESTR lpszProgID, LPCLSID lpclsid);

LWSTDAPI_(int)
CompareStringWrapW(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR lpString1,
    int      cchCount1,
    LPCWSTR lpString2,
    int      cchCount2);

LWSTDAPI_(int)
CopyAcceleratorTableWrapW(
        HACCEL  hAccelSrc,
        LPACCEL lpAccelDst,
        int     cAccelEntries);

LWSTDAPI_(HACCEL)
CreateAcceleratorTableWrapW(LPACCEL lpAccel, int cEntries);

LWSTDAPI_(HDC)
CreateDCWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData);

LWSTDAPI_(BOOL)
CreateDirectoryWrapW(
        LPCWSTR                 lpPathName,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes);

LWSTDAPI_(HANDLE)
CreateEventWrapW(
        LPSECURITY_ATTRIBUTES   lpEventAttributes,
        BOOL                    bManualReset,
        BOOL                    bInitialState,
        LPCWSTR                 lpName);

LWSTDAPI_(HANDLE)
CreateFileWrapW(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile);


LWSTDAPI_(HFONT)
CreateFontIndirectWrapW(CONST LOGFONTW * plfw);

LWSTDAPI_(HDC)
CreateICWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData);

LWSTDAPI_(HWND)
CreateWindowExWrapW(
        DWORD       dwExStyle,
        LPCWSTR     lpClassName,
        LPCWSTR     lpWindowName,
        DWORD       dwStyle,
        int         X,
        int         Y,
        int         nWidth,
        int         nHeight,
        HWND        hWndParent,
        HMENU       hMenu,
        HINSTANCE   hInstance,
        void *     lpParam);

LWSTDAPI_(LRESULT)
DefWindowProcWrapW(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

LWSTDAPI_(BOOL) DeleteFileWrapW(LPCWSTR pwsz);

LWSTDAPI_(LRESULT)
DispatchMessageWrapW(CONST MSG * lpMsg);

LWSTDAPI_(int)
DrawTextWrapW(
        HDC     hDC,
        LPCWSTR lpString,
        int     nCount,
        LPRECT  lpRect,
        UINT    uFormat);

LWSTDAPI_(int)
EnumFontFamiliesWrapW(
        HDC          hdc,
        LPCWSTR      lpszFamily,
        FONTENUMPROCW lpEnumFontProc,
        LPARAM       lParam);

LWSTDAPI_(int)
EnumFontFamiliesExWrapW(
        HDC          hdc,
        LPLOGFONTW   lplfw,
        FONTENUMPROCW lpEnumFontProc,
        LPARAM       lParam,
        DWORD        dwFlags );

LWSTDAPI_(BOOL)
EnumResourceNamesWrapW(
        HINSTANCE        hModule,
        LPCWSTR          lpType,
        ENUMRESNAMEPROCW lpEnumFunc,
        LONG_PTR         lParam);

LWSTDAPI_(BOOL)
ExtTextOutWrapW(
        HDC             hdc,
        int             x,
        int             y,
        UINT            fuOptions,
        CONST RECT *    lprc,
        LPCWSTR         lpString,
        UINT            nCount,
        CONST INT *     lpDx);

LWSTDAPI_(HANDLE)
FindFirstFileWrapW(
        LPCWSTR             lpFileName,
        LPWIN32_FIND_DATAW  pwszFd);

LWSTDAPI_(HRSRC)
FindResourceWrapW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType);

LWSTDAPI_(HWND)
FindWindowWrapW(LPCWSTR lpClassName, LPCWSTR lpWindowName);

LWSTDAPI_(DWORD)
FormatMessageWrapW(
    DWORD       dwFlags,
    LPCVOID     lpSource,
    DWORD       dwMessageId,
    DWORD       dwLanguageId,
    LPWSTR      lpBuffer,
    DWORD       nSize,
    va_list *   Arguments);

LWSTDAPI_(BOOL)
GetClassInfoWrapW(HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW);

LWSTDAPI_(DWORD)
GetClassLongWrapW(HWND hWnd, int nIndex);

LWSTDAPI_(int)
GetClassNameWrapW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);

LWSTDAPI_(int)
GetClipboardFormatNameWrapW(UINT format, LPWSTR lpFormatName, int cchFormatName);

LWSTDAPI_(DWORD)
GetCurrentDirectoryWrapW(DWORD nBufferLength, LPWSTR lpBuffer);

LWSTDAPI_(UINT)
GetDlgItemTextWrapW(
        HWND    hWndDlg,
        int     idControl,
        LPWSTR  lpsz,
        int     cchMax);

LWSTDAPI_(DWORD)
GetFileAttributesWrapW(LPCWSTR lpFileName);

STDAPI_(BOOL)
GetFileVersionInfoWrapW(LPWSTR pwzFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);

STDAPI_(DWORD)
GetFileVersionInfoSizeWrapW(LPWSTR pwzFilename,  LPDWORD lpdwHandle);

LWSTDAPI_(DWORD)
GetFullPathNameWrapW( LPCWSTR lpFileName,
                     DWORD  nBufferLength,
                     LPWSTR lpBuffer,
                     LPWSTR *lpFilePart);

LWSTDAPI_(int)
GetLocaleInfoWrapW(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData);

LWSTDAPI_(int)
GetMenuStringWrapW(
        HMENU   hMenu,
        UINT    uIDItem,
        LPWSTR  lpString,
        int     nMaxCount,
        UINT    uFlag);

LWSTDAPI_(BOOL)
GetMessageWrapW(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax);

LWSTDAPI_(DWORD)
GetModuleFileNameWrapW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize);

LWSTDAPI_(UINT)
GetSystemDirectoryWrapW(LPWSTR lpBuffer, UINT uSize);

LWSTDAPI_(DWORD)
GetEnvironmentVariableWrapW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);

LWSTDAPI_(DWORD)
SearchPathWrapW(
        LPCWSTR lpPathName,
        LPCWSTR lpFileName,
        LPCWSTR lpExtension,
        DWORD   cchReturnBuffer,
        LPWSTR  lpReturnBuffer,
        LPWSTR *  plpfilePart);

LWSTDAPI_(HMODULE)
GetModuleHandleWrapW(LPCWSTR lpModuleName);

LWSTDAPI_(int)
GetObjectWrapW(HGDIOBJ hgdiObj, int cbBuffer, void *lpvObj);

LWSTDAPI_(UINT)
GetPrivateProfileIntWrapW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT     nDefault,
        LPCWSTR lpFileName);

LWSTDAPI_(DWORD)
GetProfileStringWrapW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpDefault,
        LPWSTR  lpBuffer,
        DWORD   dwBuffersize);

LWSTDAPI_(HANDLE)
GetPropWrapW(HWND hWnd, LPCWSTR lpString);

LWSTDAPI_(DWORD)
GetShortPathNameWrapW(
    LPCWSTR lpszLongPath,
    LPWSTR  lpszShortPath,
    DWORD    cchBuffer);

LWSTDAPI_(BOOL)
GetStringTypeExWrapW(LCID lcid, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);

LWSTDAPI_(UINT)
GetTempFileNameWrapW(
        LPCWSTR lpPathName,
        LPCWSTR lpPrefixString,
        UINT    uUnique,
        LPWSTR  lpTempFileName);

LWSTDAPI_(DWORD)
GetTempPathWrapW(DWORD nBufferLength, LPWSTR lpBuffer);

LWSTDAPI_(BOOL)
GetTextExtentPoint32WrapW(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize);

LWSTDAPI_(int)
GetTextFaceWrapW(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName);

LWSTDAPI_(BOOL)
GetTextMetricsWrapW(HDC hdc, LPTEXTMETRICW lptm);

LWSTDAPI_(BOOL)
GetUserNameWrapW(LPWSTR lpUserName, LPDWORD lpcchName);

LWSTDAPI_(LONG)
GetWindowLongWrapW(HWND hWnd, int nIndex);


LWSTDAPI_(int)
GetWindowTextWrapW(HWND hWnd, LPWSTR lpString, int nMaxCount);

LWSTDAPI_(int)
GetWindowTextLengthWrapW(HWND hWnd);

LWSTDAPI_(UINT)
GetWindowsDirectoryWrapW(LPWSTR lpWinPath, UINT cch);

LWSTDAPI_(BOOL)
InsertMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR  uIDNewItem,
        LPCWSTR lpNewItem);

LWSTDAPI_(BOOL)
IsDialogMessageWrapW(HWND hWndDlg, LPMSG lpMsg);

LWSTDAPI_(HACCEL)
LoadAcceleratorsWrapW(HINSTANCE hInstance, LPCWSTR lpTableName);

LWSTDAPI_(HBITMAP)
LoadBitmapWrapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);

LWSTDAPI_(HCURSOR)
LoadCursorWrapW(HINSTANCE hInstance, LPCWSTR lpCursorName);

LWSTDAPI_(HICON)
LoadIconWrapW(HINSTANCE hInstance, LPCWSTR lpIconName);

LWSTDAPI_(HANDLE)
LoadImageWrapA(
        HINSTANCE hInstance,
        LPCSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad);

LWSTDAPI_(HANDLE)
LoadImageWrapW(
        HINSTANCE hInstance,
        LPCWSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad);

LWSTDAPI_(HINSTANCE)
LoadLibraryExWrapW(
        LPCWSTR lpLibFileName,
        HANDLE  hFile,
        DWORD   dwFlags);

LWSTDAPI_(HMENU)
LoadMenuWrapW(HINSTANCE hInstance, LPCWSTR lpMenuName);

LWSTDAPI_(int)
LoadStringWrapW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);

#ifndef UNIX
LWSTDAPI_(BOOL)
MessageBoxIndirectWrapW(CONST MSGBOXPARAMSW *pmbp);
#else
LWSTDAPI_(int)
MessageBoxIndirectWrapW(LPMSGBOXPARAMSW pmbp);
#endif /* UNIX */

LWSTDAPI_(BOOL)
ModifyMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem);

LWSTDAPI_(BOOL)
GetCharWidth32WrapW(
     HDC hdc,
     UINT iFirstChar,
     UINT iLastChar,
     LPINT lpBuffer);

LWSTDAPI_(DWORD)
GetCharacterPlacementWrapW(
    HDC hdc,            // handle to device context
    LPCWSTR lpString,   // pointer to string
    int nCount,         // number of characters in string
    int nMaxExtent,     // maximum extent for displayed string
    LPGCP_RESULTSW lpResults, // pointer to buffer for placement result
    DWORD dwFlags       // placement flags
   );

LWSTDAPI_(BOOL)
CopyFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);

LWSTDAPI_(BOOL)
MoveFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);

LWSTDAPI_(BOOL)
OemToCharWrapW(LPCSTR lpszSrc, LPWSTR lpszDst);

LWSTDAPI_(HANDLE)
OpenEventWrapW(
        DWORD                   fdwAccess,
        BOOL                    fInherit,
        LPCWSTR                 lpszEventName);


LWSTDAPI_(void)
OutputDebugStringWrapW(LPCWSTR lpOutputString);

LWSTDAPI_(BOOL)
PeekMessageWrapW(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg);

LWSTDAPI_(BOOL)
PlaySoundWrapW(
        LPCWSTR pszSound,
        HMODULE hmod,
        DWORD fdwSound);

LWSTDAPI_(BOOL)
PostMessageWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam);

LWSTDAPI_(BOOL)
PostThreadMessageWrapW(
        DWORD idThread,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);

LWSTDAPI_(LONG)
RegCreateKeyWrapW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);

LWSTDAPI_(LONG)
RegCreateKeyExWrapW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

LWSTDAPI_(LONG)
RegDeleteKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey);

LWSTDAPI_(LONG)
RegDeleteValueWrapW(HKEY hKey, LPCWSTR pwszSubKey);

LWSTDAPI_(LONG)
RegEnumKeyWrapW(
        HKEY    hKey,
        DWORD   dwIndex,
        LPWSTR  lpName,
        DWORD   cbName);

LWSTDAPI_(LONG)
RegEnumKeyExWrapW(
        HKEY        hKey,
        DWORD       dwIndex,
        LPWSTR      lpName,
        LPDWORD     lpcbName,
        LPDWORD     lpReserved,
        LPWSTR      lpClass,
        LPDWORD     lpcbClass,
        PFILETIME   lpftLastWriteTime);

LWSTDAPI_(LONG)
RegOpenKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);

LWSTDAPI_(LONG)
RegOpenKeyExWrapW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   ulOptions,
        REGSAM  samDesired,
        PHKEY   phkResult);

LWSTDAPI_(LONG)
RegQueryInfoKeyWrapW(
        HKEY hKey,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime);

LWSTDAPI_(LONG)
RegQueryValueWrapW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        LPWSTR  pwszValue,
        PLONG   lpcbValue);

LWSTDAPI_(LONG)
RegQueryValueExWrapW(
        HKEY    hKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData);

LWSTDAPI_(LONG)
RegSetValueWrapW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   dwType,
        LPCWSTR lpData,
        DWORD   cbData);

LWSTDAPI_(LONG)
RegSetValueExWrapW(
        HKEY        hKey,
        LPCWSTR     lpValueName,
        DWORD       Reserved,
        DWORD       dwType,
        CONST BYTE* lpData,
        DWORD       cbData);

LWSTDAPI_(ATOM)
RegisterClassWrapW(CONST WNDCLASSW * lpWndClass);

LWSTDAPI_(UINT)
RegisterClipboardFormatWrapW(LPCWSTR lpString);

LWSTDAPI_(UINT)
RegisterWindowMessageWrapW(LPCWSTR lpString);

LWSTDAPI_(BOOL)
RemoveDirectoryWrapW(LPCWSTR lpszDir);

LWSTDAPI_(HANDLE)
RemovePropWrapW(
        HWND    hWnd,
        LPCWSTR lpString);

LWSTDAPI_(LRESULT)
SendDlgItemMessageWrapW(
        HWND    hDlg,
        int     nIDDlgItem,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam);

LWSTDAPI_(LRESULT)
SendMessageWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam);

LWSTDAPI_(LRESULT)
SendMessageTimeoutWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        UINT    uFlags,
        UINT    uTimeout,
        PULONG_PTR lpdwResult);

LWSTDAPI_(BOOL)
SetCurrentDirectoryWrapW(LPCWSTR lpszCurDir);

LWSTDAPI_(BOOL)
SetDlgItemTextWrapW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);

LWSTDAPI_(BOOL)
SetMenuItemInfoWrapW(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmiiW);

LWSTDAPI_(BOOL)
SetPropWrapW(
    HWND    hWnd,
    LPCWSTR lpString,
    HANDLE  hData);

LWSTDAPI_(LONG)
SetWindowLongWrapW(HWND hWnd, int nIndex, LONG dwNewLong);

LWSTDAPI_(HHOOK)
SetWindowsHookExWrapW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);

LWSTDAPI_(int)
StartDocWrapW( HDC hDC, const DOCINFOW * lpdi );

LWSTDAPI_(BOOL)
SystemParametersInfoWrapW(
        UINT    uiAction,
        UINT    uiParam,
        void    *pvParam,
        UINT    fWinIni);

LWSTDAPI_(BOOL)
TrackPopupMenuWrap(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, CONST RECT *prcRect);

LWSTDAPI_(BOOL)
TrackPopupMenuExWrap(HMENU hMenu, UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm);

LWSTDAPI_(int)
TranslateAcceleratorWrapW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);

LWSTDAPI_(BOOL)
UnregisterClassWrapW(LPCWSTR lpClassName, HINSTANCE hInstance);

STDAPI_(BOOL)
VerQueryValueWrapW(const LPVOID pBlock, LPWSTR pwzSubBlock, LPVOID *ppBuffer, PUINT puLen);

LWSTDAPI_(SHORT)
VkKeyScanWrapW(WCHAR ch);

LWSTDAPI_(BOOL)
WinHelpWrapW(HWND hwnd, LPCWSTR szFile, UINT uCmd, DWORD_PTR dwData);

LWSTDAPI_(int)
wvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist);

STDAPI_(DWORD) WNetRestoreConnectionWrapW(IN HWND hwndParent, IN LPCWSTR pwzDevice);
STDAPI_(DWORD) WNetGetLastErrorWrapW(OUT LPDWORD pdwError, OUT LPWSTR pwzErrorBuf, IN DWORD cchErrorBufSize, OUT LPWSTR pwzNameBuf, IN DWORD cchNameBufSize);

LWSTDAPI_(int) DrawTextExWrapW(HDC hdc, LPWSTR pwzText, int cchText, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
LWSTDAPI_(BOOL) GetMenuItemInfoWrapW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFOW pmiiW);
LWSTDAPI_(BOOL) InsertMenuItemWrapW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW pmiiW);

LWSTDAPI_(HFONT) CreateFontWrapW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline,
                    DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision,
                    DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace);
LWSTDAPI_(HDC) CreateMetaFileWrapW(LPCWSTR pwzFile);
LWSTDAPI_(HANDLE) CreateMutexWrapW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR pwzName);
LWSTDAPI_(DWORD) ExpandEnvironmentStringsWrapW(LPCWSTR pwszSrc, LPWSTR pwszDst, DWORD cchSize);
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsA(LPCSTR pszSrc, LPSTR pszDst, DWORD cchSize);
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsW(LPCWSTR pszSrc, LPWSTR pszDst, DWORD cchSize);
#ifdef UNICODE
#define SHExpandEnvironmentStrings  SHExpandEnvironmentStringsW
#else
#define SHExpandEnvironmentStrings  SHExpandEnvironmentStringsA
#endif // !UNICODE
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsForUserA(HANDLE hToken, LPCSTR pszSrc, LPSTR pszDst, DWORD cchSize);
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsForUserW(HANDLE hToken, LPCWSTR pszSrc, LPWSTR pszDst, DWORD cchSize);
#ifdef UNICODE
#define SHExpandEnvironmentStringsForUser  SHExpandEnvironmentStringsForUserW
#else
#define SHExpandEnvironmentStringsForUser  SHExpandEnvironmentStringsForUserA
#endif // !UNICODE

LWSTDAPI_(HANDLE) CreateSemaphoreWrapW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR pwzName);
LWSTDAPI_(BOOL) IsBadStringPtrWrapW(LPCWSTR pwzString, UINT_PTR ucchMax);
LWSTDAPI_(HINSTANCE) LoadLibraryWrapW(LPCWSTR pwzLibFileName);
LWSTDAPI_(int) GetTimeFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, LPCWSTR pwzFormat, LPWSTR pwzTimeStr, int cchTime);
LWSTDAPI_(int) GetDateFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, LPCWSTR pwzFormat, LPWSTR pwzDateStr, int cchDate);
LWSTDAPI_(DWORD) GetPrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzDefault, LPWSTR pwzReturnedString, DWORD cchSize, LPCWSTR pwzFileName);
LWSTDAPI_(BOOL) WritePrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName);

#ifndef SHFILEINFO_DEFINED
#define SHFILEINFO_DEFINED

/*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 */

typedef struct _SHFILEINFOA
{
    HICON       hIcon;                      // out: icon
    int         iIcon;                      // out: icon index
    DWORD       dwAttributes;               // out: SFGAO_ flags
    CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
    CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
    HICON       hIcon;                      // out: icon
    int         iIcon;                      // out: icon index
    DWORD       dwAttributes;               // out: SFGAO_ flags
    WCHAR       szDisplayName[MAX_PATH];    // out: display name (or path)
    WCHAR       szTypeName[80];             // out: type name
} SHFILEINFOW;
#ifdef UNICODE
typedef SHFILEINFOW SHFILEINFO;
#else
typedef SHFILEINFOA SHFILEINFO;
#endif // UNICODE


// NOTE: This is also in shellapi.h.  Please keep in synch.
#endif // !SHFILEINFO_DEFINED
LWSTDAPI_(DWORD_PTR) SHGetFileInfoWrapW(LPCWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);

LWSTDAPI_(ATOM) RegisterClassExWrapW(CONST WNDCLASSEXW *pwcx);
LWSTDAPI_(BOOL) GetClassInfoExWrapW(HINSTANCE hinst, LPCWSTR pwzClass, LPWNDCLASSEXW lpwcx);

// This allows us to be included either before or after shellapi.h
#ifdef STRICT
LWSTDAPI_(UINT) DragQueryFileWrapW(struct HDROP__*,UINT,LPWSTR,UINT);
#else
LWSTDAPI_(UINT) DragQueryFileWrapW(HANDLE,UINT,LPWSTR,UINT);
#endif

LWSTDAPI_(HWND) FindWindowExWrapW(HWND hwndParent, HWND hwndChildAfter, LPCWSTR pwzClassName, LPCWSTR pwzWindowName);
LWSTDAPI_(UNALIGNED struct _ITEMIDLIST *) SHBrowseForFolderWrapW(struct _browseinfoW * pbiW);
LWSTDAPI_(BOOL) SHGetPathFromIDListWrapW(CONST UNALIGNED struct _ITEMIDLIST * pidl, LPWSTR pwzPath);
LWSTDAPI_(BOOL) SHGetNewLinkInfoWrapW(LPCWSTR pszpdlLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags);
LWSTDAPI SHDefExtractIconWrapW(LPCWSTR pszIconFile, int iIndex, UINT uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
LWSTDAPI_(BOOL) GetUserNameWrapW(LPWSTR pszBuffer, LPDWORD pcch);
LWSTDAPI_(LONG) RegEnumValueWrapW(HKEY hkey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LWSTDAPI_(BOOL) WritePrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
LWSTDAPI_(BOOL) GetPrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
LWSTDAPI_(BOOL) CreateProcessWrapW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory,
LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
LWSTDAPI_(HICON) ExtractIconWrapW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);
#ifndef WIN32_LEAN_AND_MEAN
STDAPI_(UINT) DdeInitializeWrapW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
STDAPI_(HSZ) DdeCreateStringHandleWrapW(DWORD idInst, LPCWSTR psz, int iCodePage);
STDAPI_(DWORD) DdeQueryStringWrapW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);
STDAPI_(BOOL) GetSaveFileNameWrapW(LPOPENFILENAMEW lpofn);
STDAPI_(BOOL) GetOpenFileNameWrapW(LPOPENFILENAMEW lpofn);
STDAPI_(BOOL) PrintDlgWrapW(LPPRINTDLGW lppd);
STDAPI_(BOOL) PageSetupDlgWrapW(LPPAGESETUPDLGW lppsd);
#endif
LWSTDAPI_(void) SHChangeNotifyWrap(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
LWSTDAPI_(void) SHFlushSFCacheWrap(void);
LWSTDAPI_(BOOL) ShellExecuteExWrapW(struct _SHELLEXECUTEINFOW * pExecInfoW);
LWSTDAPI_(int) SHFileOperationWrapW(struct _SHFILEOPSTRUCTW * pFileOpW);
LWSTDAPI_(UINT) ExtractIconExWrapW(LPCWSTR pwzFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
LWSTDAPI_(BOOL) SetFileAttributesWrapW(LPCWSTR pwzFile, DWORD dwFileAttributes);
LWSTDAPI_(int) GetNumberFormatWrapW(LCID Locale, DWORD dwFlags, LPCWSTR pwzValue, CONST NUMBERFMTW * pFormatW, LPWSTR pwzNumberStr, int cchNumber);
LWSTDAPI_(int) MessageBoxWrapW(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType);
LWSTDAPI_(BOOL) FindNextFileWrapW(HANDLE hSearchHandle, LPWIN32_FIND_DATAW pFindFileDataW);

#ifdef UNICODE

#define IsCharAlphaWrap             IsCharAlphaWrapW
#define IsCharUpperWrap             IsCharUpperWrapW
#define IsCharLowerWrap             IsCharLowerWrapW
#define IsCharAlphaNumericWrap      IsCharAlphaNumericWrapW
#define AppendMenuWrap              AppendMenuWrapW
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterWrapW
#endif
#define CallWindowProcWrap          CallWindowProcWrapW
#define CharLowerWrap               CharLowerWrapW
#define CharLowerBuffWrap           CharLowerBuffWrapW
#define CharNextWrap                CharNextWrapW
#define CharPrevWrap                CharPrevWrapW
#define CharToOemWrap               CharToOemWrapW
#define CharUpperWrap               CharUpperWrapW
#define CharUpperBuffWrap           CharUpperBuffWrapW
#define CompareStringWrap           CompareStringWrapW
#define CopyAcceleratorTableWrap    CopyAcceleratorTableWrapW
#define CreateAcceleratorTableWrap  CreateAcceleratorTableWrapW
#define CreateDCWrap                CreateDCWrapW
#define CreateDirectoryWrap         CreateDirectoryWrapW
#define CreateEventWrap             CreateEventWrapW
#define CreateFontWrap              CreateFontWrapW
#define CreateFileWrap              CreateFileWrapW
#define CreateFontIndirectWrap      CreateFontIndirectWrapW
#define CreateICWrap                CreateICWrapW
#define CreateMetaFileWrap          CreateMetaFileWrapW
#define CreateMutexWrap             CreateMutexWrapW
#define CreateSemaphoreWrap         CreateSemaphoreWrapW
#define CreateWindowExWrap          CreateWindowExWrapW
#define DefWindowProcWrap           DefWindowProcWrapW
#define DeleteFileWrap              DeleteFileWrapW
#define DispatchMessageWrap         DispatchMessageWrapW
#define DrawTextExWrap              DrawTextExWrapW
#define DrawTextWrap                DrawTextWrapW
#define EnumFontFamiliesWrap        EnumFontFamiliesWrapW
#define EnumFontFamiliesExWrap      EnumFontFamiliesExWrapW
#define EnumResourceNamesWrap       EnumResourceNamesWrapW
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsWrapW
#define ExtractIconExWrap           ExtractIconExWrapW
#define ExtTextOutWrap              ExtTextOutW
#define FindFirstFileWrap           FindFirstFileWrapW
#define FindNextFileWrap            FindNextFileWrapW
#define FindResourceWrap            FindResourceWrapW
#define FindWindowWrap              FindWindowWrapW
#define FindWindowExWrap            FindWindowExWrapW
#define FormatMessageWrap           FormatMessageWrapW
#define GetClassInfoWrap            GetClassInfoWrapW
#define GetClassInfoExWrap          GetClassInfoExWrapW
#define GetClassLongWrap            GetClassLongWrapW
#define GetClassNameWrap            GetClassNameWrapW
#define GetClipboardFormatNameWrap  GetClipboardFormatNameWrapW
#define GetCurrentDirectoryWrap     GetCurrentDirectoryWrapW
#define GetDlgItemTextWrap          GetDlgItemTextWrapW
#define GetFileAttributesWrap       GetFileAttributesWrapW
#define GetFullPathNameWrap         GetFullPathNameWrapW
#define GetLocaleInfoWrap           GetLocaleInfoWrapW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define GetMenuStringWrap           GetMenuStringWrapW
#define GetMessageWrap              GetMessageWrapW
#define GetModuleFileNameWrap       GetModuleFileNameWrapW
#define GetNumberFormatWrap         GetNumberFormatWrapW
#define GetSystemDirectoryWrap      GetSystemDirectoryWrapW
#define GetEnvironmentVariableWrap  GetEnvironmentVariableWrapW
#define GetModuleHandleWrap         GetModuleHandleWrapW
#define GetObjectWrap               GetObjectWrapW
#define GetPrivateProfileIntWrap    GetPrivateProfileIntWrapW
#define GetProfileStringWrap        GetProfileStringWrapW
#define GetPrivateProfileStringWrap GetPrivateProfileStringWrapW
#define WritePrivateProfileStringWrap WritePrivateProfileStringWrapW
#define GetPropWrap                 GetPropWrapW
#define GetStringTypeExWrap         GetStringTypeExWrapW
#define GetTempFileNameWrap         GetTempFileNameWrapW
#define GetTempPathWrap             GetTempPathWrapW
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32WrapW
#define GetTextFaceWrap             GetTextFaceWrapW
#define GetTextMetricsWrap          GetTextMetricsWrapW
#define GetTimeFormatWrap           GetTimeFormatWrapW
#define GetDateFormatWrap           GetDateFormatWrapW
#define GetUserNameWrap             GetUserNameWrapW
#define GetWindowLongWrap           GetWindowLongWrapW
#define GetWindowTextWrap           GetWindowTextWrapW
#define GetWindowTextLengthWrap     GetWindowTextLengthWrapW
#define GetWindowsDirectoryWrap     GetWindowsDirectoryWrapW
#define InsertMenuItemWrap          InsertMenuItemWrapW
#define InsertMenuWrap              InsertMenuWrapW
#define IsBadStringPtrWrap          IsBadStringPtrWrapW
#define IsDialogMessageWrap         IsDialogMessageWrapW
#define LoadAcceleratorsWrap        LoadAcceleratorsWrapW
#define LoadBitmapWrap              LoadBitmapWrapW
#define LoadCursorWrap              LoadCursorWrapW
#define LoadIconWrap                LoadIconWrapW
#define LoadImageWrap               LoadImageWrapW
#define LoadLibraryWrap             LoadLibraryWrapW
#define LoadLibraryExWrap           LoadLibraryExWrapW
#define LoadMenuWrap                LoadMenuWrapW
#define LoadStringWrap              LoadStringWrapW
#define MessageBoxIndirectWrap      MessageBoxIndirectWrapW
#define MessageBoxWrap              MessageBoxWrapW
#define ModifyMenuWrap              ModifyMenuWrapW
#define GetCharWidth32Wrap          GetCharWidth32WrapW
#define GetCharacterPlacementWrap   GetCharacterPlacementWrapW
#define CopyFileWrap                CopyFileWrapW
#define MoveFileWrap                MoveFileWrapW
#define OemToCharWrap               OemToCharWrapW
#define OutputDebugStringWrap       OutputDebugStringWrapW
#define PeekMessageWrap             PeekMessageWrapW
#define PostMessageWrap             PostMessageWrapW
#define PostThreadMessageWrap       PostThreadMessageWrapW
#define RegCreateKeyWrap            RegCreateKeyWrapW
#define RegCreateKeyExWrap          RegCreateKeyExWrapW
#define RegDeleteKeyWrap            RegDeleteKeyWrapW
#define RegDeleteValueWrap          RegDeleteValueWrapW
#define RegEnumKeyWrap              RegEnumKeyWrapW
#define RegEnumKeyExWrap            RegEnumKeyExWrapW
#define RegOpenKeyWrap              RegOpenKeyWrapW
#define RegOpenKeyExWrap            RegOpenKeyExWrapW
#define RegQueryInfoKeyWrap         RegQueryInfoKeyWrapW
#define RegQueryValueWrap           RegQueryValueWrapW
#define RegQueryValueExWrap         RegQueryValueExWrapW
#define RegSetValueWrap             RegSetValueWrapW
#define RegSetValueExWrap           RegSetValueExWrapW
#define RegisterClassWrap           RegisterClassWrapW
#define RegisterClassExWrap         RegisterClassExWrapW
#define RegisterClipboardFormatWrap RegisterClipboardFormatWrapW
#define RegisterWindowMessageWrap   RegisterWindowMessageWrapW
#define RemovePropWrap              RemovePropWrapW
#define SearchPathWrap              SearchPathWrapW
#define SendDlgItemMessageWrap      SendDlgItemMessageWrapW
#define SendMessageWrap             SendMessageWrapW
#define SendMessageTimeoutWrap      SendMessageTimeoutWrapW
#define SetCurrentDirectoryWrap     SetCurrentDirectoryWrapW
#define SetDlgItemTextWrap          SetDlgItemTextWrapW
#define SetMenuItemInfoWrap         SetMenuItemInfoWrapW
#define SetPropWrap                 SetPropWrapW
#define SetFileAttributesWrap       SetFileAttributesWrapW
#define SetWindowLongWrap           SetWindowLongWrapW
#define SetWindowsHookExWrap        SetWindowsHookExWrapW
#define SHBrowseForFolderWrap       SHBrowseForFolderWrapW
#define ShellExecuteExWrap          ShellExecuteExWrapW
#define SHFileOperationWrap         SHFileOperationWrapW
#define SHGetFileInfoWrap           SHGetFileInfoWrapW
#define SHGetPathFromIDListWrap     SHGetPathFromIDListWrapW
#define StartDocWrap                StartDocWrapW
#define SystemParametersInfoWrap    SystemParametersInfoWrapW
#define TranslateAcceleratorWrap    TranslateAcceleratorWrapW
#define UnregisterClassWrap         UnregisterClassWrapW
#define VkKeyScanWrap               VkKeyScanWrapW
#define WinHelpWrap                 WinHelpWrapW
#define WNetRestoreConnectionWrap   WNetRestoreConnectionWrapW
#define WNetGetLastErrorWrap        WNetGetLastErrorWrapW
#define wvsprintfWrap               wvsprintfWrapW
#define CreateFontWrap              CreateFontWrapW
#define DrawTextExWrap              DrawTextExWrapW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define SetMenuItemInfoWrap         SetMenuItemInfoWrapW
#define InsertMenuItemWrap          InsertMenuItemWrapW
#define DragQueryFileWrap           DragQueryFileWrapW

#else

#define IsCharAlphaWrap             IsCharAlphaA
#define IsCharUpperWrap             IsCharUpperA
#define IsCharLowerWrap             IsCharLowerA
#define IsCharAlphaNumericWrap      IsCharAlphaNumericA
#define AppendMenuWrap              AppendMenuA
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterA
#endif
#define CallWindowProcWrap          CallWindowProcA
#define CharLowerWrap               CharLowerA
#define CharLowerBuffWrap           CharLowerBuffA
#define CharNextWrap                CharNextA
#define CharPrevWrap                CharPrevA
#define CharToOemWrap               CharToOemA
#define CharUpperWrap               CharUpperA
#define CharUpperBuffWrap           CharUpperBuffA
#define CompareStringWrap           CompareStringA
#define CopyAcceleratorTableWrap    CopyAcceleratorTableA
#define CreateAcceleratorTableWrap  CreateAcceleratorTableA
#define CreateDCWrap                CreateDCA
#define CreateDirectoryWrap         CreateDirectoryA
#define CreateEventWrap             CreateEventA
#define CreateFontWrap              CreateFontA
#define CreateFileWrap              CreateFileA
#define CreateFontIndirectWrap      CreateFontIndirectA
#define CreateICWrap                CreateICA
#define CreateMetaFileWrap          CreateMetaFileA
#define CreateMutexWrap             CreateMutexA
#define CreateSemaphoreWrap         CreateSemaphoreA
#define CreateWindowExWrap          CreateWindowExA
#define DefWindowProcWrap           DefWindowProcA
#define DeleteFileWrap              DeleteFileA
#define DispatchMessageWrap         DispatchMessageA
#define DrawTextExWrap              DrawTextExA
#define DrawTextWrap                DrawTextA
#define EnumFontFamiliesWrap        EnumFontFamiliesA
#define EnumFontFamiliesExWrap      EnumFontFamiliesExA
#define EnumResourceNamesWrap       EnumResourceNamesA
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsA
#define ExtractIconExWrap           ExtractIconExA
#define ExtTextOutWrap              ExtTextOutA
#define FindFirstFileWrap           FindFirstFileA
#define FindResourceWrap            FindResourceA
#define FindNextFileWrap            FindNextFileA
#define FindWindowWrap              FindWindowA
#define FindWindowExWrap            FindWindowExA
#define FormatMessageWrap           FormatMessageA
#define GetClassInfoWrap            GetClassInfoA
#define GetClassInfoExWrap          GetClassInfoExA
#define GetClassLongWrap            GetClassLongA
#define GetClassNameWrap            GetClassNameA
#define GetClipboardFormatNameWrap  GetClipboardFormatNameA
#define GetCurrentDirectoryWrap     GetCurrentDirectoryA
#define GetDlgItemTextWrap          GetDlgItemTextA
#define GetFileAttributesWrap       GetFileAttributesA
#define GetFullPathNameWrap         GetFullPathNameA
#define GetLocaleInfoWrap           GetLocaleInfoA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define GetMenuStringWrap           GetMenuStringA
#define GetMessageWrap              GetMessageA
#define GetModuleFileNameWrap       GetModuleFileNameA
#define GetNumberFormatWrap         GetNumberFormatA
#define GetPrivateProfileStringWrap GetPrivateProfileStringA
#define WritePrivateProfileStringWrap WritePrivateProfileStringA
#define GetSystemDirectoryWrap      GetSystemDirectoryA
#define GetEnvironmentVariableWrap  GetEnvironmentVariableA
#define SearchPathWrap              SearchPathA
#define GetModuleHandleWrap         GetModuleHandleA
#define GetObjectWrap               GetObjectA
#define GetPrivateProfileIntWrap    GetPrivateProfileIntA
#define GetProfileStringWrap        GetProfileStringA
#define GetPropWrap                 GetPropA
#define GetStringTypeExWrap         GetStringTypeExA
#define GetTempFileNameWrap         GetTempFileNameA
#define GetTempPathWrap             GetTempPathA
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32A
#define GetTextFaceWrap             GetTextFaceA
#define GetTextMetricsWrap          GetTextMetricsA
#define GetTimeFormatWrap           GetTimeFormatA
#define GetDateFormatWrap           GetDateFormatA
#define GetUserNameWrap             GetUserNameA
#define GetWindowLongWrap           GetWindowLongA
#define GetWindowTextWrap           GetWindowTextA
#define GetWindowTextLengthWrap     GetWindowTextLengthA
#define GetWindowsDirectoryWrap     GetWindowsDirectoryA
#define InsertMenuItemWrap          InsertMenuItemA
#define InsertMenuWrap              InsertMenuA
#define IsBadStringPtrWrap          IsBadStringPtrA
#define IsDialogMessageWrap         IsDialogMessageA
#define LoadAcceleratorsWrap        LoadAcceleratorsA
#define LoadBitmapWrap              LoadBitmapA
#define LoadCursorWrap              LoadCursorA
#define LoadIconWrap                LoadIconA
#define LoadImageWrap               LoadImageWrapA
#define LoadLibraryWrap             LoadLibraryA
#define LoadLibraryExWrap           LoadLibraryExA
#define LoadMenuWrap                LoadMenuA
#define LoadStringWrap              LoadStringA
#define MessageBoxIndirectWrap      MessageBoxIndirectA
#define MessageBoxWrap              MessageBoxA
#define ModifyMenuWrap              ModifyMenuA
#define GetCharWidth32Wrap          GetCharWidth32A
#define GetCharacterPlacementWrap   GetCharacterPlacementA
#define CopyFileWrap                CopyFileA
#define MoveFileWrap                MoveFileA
#define OemToCharWrap               OemToCharA
#define OutputDebugStringWrap       OutputDebugStringA
#define PeekMessageWrap             PeekMessageA
#define PostMessageWrap             PostMessageA
#define PostThreadMessageWrap       PostThreadMessageA
#define RegCreateKeyWrap            RegCreateKeyA
#define RegCreateKeyExWrap          RegCreateKeyExA
#define RegDeleteKeyWrap            RegDeleteKeyA
#define RegDeleteValueWrap          RegDeleteValueA
#define RegEnumKeyWrap              RegEnumKeyA
#define RegEnumKeyExWrap            RegEnumKeyExA
#define RegOpenKeyWrap              RegOpenKeyA
#define RegOpenKeyExWrap            RegOpenKeyExA
#define RegQueryInfoKeyWrap         RegQueryInfoKeyA
#define RegQueryValueWrap           RegQueryValueA
#define RegQueryValueExWrap         RegQueryValueExA
#define RegSetValueWrap             RegSetValueA
#define RegSetValueExWrap           RegSetValueExA
#define RegisterClassWrap           RegisterClassA
#define RegisterClassExWrap         RegisterClassExA
#define RegisterClipboardFormatWrap RegisterClipboardFormatA
#define RegisterWindowMessageWrap   RegisterWindowMessageA
#define RemovePropWrap              RemovePropA
#define SendDlgItemMessageWrap      SendDlgItemMessageA
#define SendMessageWrap             SendMessageA
#define SendMessageTimeoutWrap      SendMessageTimeoutA
#define SetCurrentDirectoryWrap     SetCurrentDirectoryA
#define SetDlgItemTextWrap          SetDlgItemTextA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define SetPropWrap                 SetPropA
#define SetWindowLongWrap           SetWindowLongA
#define SHBrowseForFolderWrap       SHBrowseForFolderA
#define ShellExecuteExWrap          ShellExecuteExA
#define SHFileOperationWrap         SHFileOperationA
#define SHGetFileInfoWrap           SHGetFileInfoA
#define SHGetPathFromIDListWrap     SHGetPathFromIDListA
#define SetFileAttributesWrap       SetFileAttributesA
#define SetWindowsHookExWrap        SetWindowsHookExA
#define StartDocWrap                StartDocA
#define SystemParametersInfoWrap    SystemParametersInfoA
#define TranslateAcceleratorWrap    TranslateAcceleratorA
#define UnregisterClassWrap         UnregisterClassA
#define VkKeyScanWrap               VkKeyScanA
#define WinHelpWrap                 WinHelpA
#define WNetRestoreConnectionWrap   WNetRestoreConnectionA
#define WNetGetLastErrorWrap        WNetGetLastErrorA
#define wvsprintfWrap               wvsprintfA
#define CreateFontWrap              CreateFontA
#define DrawTextExWrap              DrawTextExA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define InsertMenuItemWrap          InsertMenuItemA
#define DragQueryFileWrap           DragQueryFileA
#endif

#endif // (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_UNITHUNK)

#if defined(UNIX) && defined(NO_SHLWAPI_UNITHUNK)
#define SHFlushSFCacheWrap()

#ifdef UNICODE
#define IsCharAlphaWrapW            IsCharAlphaW
#define IsCharUpperWrapW            IsCharUpperW
#define IsCharLowerWrapW            IsCharLowerW
#define IsCharAlphaNumericWrapW     IsCharAlphaNumericW
#define AppendMenuWrapW             AppendMenuW
#ifdef POST_IE5_BETA
#define CallMsgFilterWrapW          CallMsgFilterW
#endif
#define CallWindowProcWrapW         CallWindowProcW
#define CharLowerWrapW              CharLowerW
#define CharLowerBuffWrapW          CharLowerBuffW
#define CharNextWrapW               CharNextW
#define CharPrevWrapW               CharPrevW
#define CharToOemWrapW              CharToOemW
#define CharUpperWrapW              CharUpperW
#define CharUpperBuffWrapW          CharUpperBuffW
#define CompareStringWrapW          CompareStringW
#define CopyAcceleratorTableWrapW   CopyAcceleratorTableW
#define CreateAcceleratorTableWrapW CreateAcceleratorTableW
#define CreateDCWrapW               CreateDCW
#define CreateDirectoryWrapW        CreateDirectoryW
#define CreateEventWrapW            CreateEventW
#define CreateFontWrapW             CreateFontW
#define CreateFileWrapW             CreateFileW
#define CreateFontIndirectWrapW     CreateFontIndirectW
#define CreateICWrapW               CreateICW
#define CreateMetaFileWrapW         CreateMetaFileW
#define CreateMutexWrapW            CreateMutexW
#define CreateSemaphoreWrapW        CreateSemaphoreW
#define CreateWindowExWrapW         CreateWindowExW
#define DefWindowProcWrapW          DefWindowProcW
#define DeleteFileWrapW             DeleteFileW
#define DispatchMessageWrapW        DispatchMessageW
#define DrawTextExWrapW             DrawTextExW
#define DrawTextWrapW               DrawTextW
#define EnumFontFamiliesWrapW       EnumFontFamiliesW
#define EnumFontFamiliesExWrapW     EnumFontFamiliesExW
#define EnumResourceNamesWrapW      EnumResourceNamesW
#define ExpandEnvironmentStringsWrapW ExpandEnvironmentStringsW
#define ExtractIconExWrapW          ExtractIconExW
#define ExtTextOutWrapW             ExtTextOutW
#define FindFirstFileWrapW          FindFirstFileW
#define FindNextFileWrapW           FindNextFileW
#define FindResourceWrapW           FindResourceW
#define FindWindowWrapW             FindWindowW
#define FindWindowExWrapW           FindWindowExW
#define FormatMessageWrapW          FormatMessageW
#define GetClassInfoWrapW           GetClassInfoW
#define GetClassInfoExWrapW         GetClassInfoExW
#define GetClassLongWrapW           GetClassLongW
#define GetClassNameWrapW           GetClassNameW
#define GetClipboardFormatNameWrapW GetClipboardFormatNameW
#define GetCurrentDirectoryWrapW    GetCurrentDirectoryW
#define GetDlgItemTextWrapW         GetDlgItemTextW
#define GetFileAttributesWrapW      GetFileAttributesW
#define GetFullPathNameWrapW        GetFullPathNameW
#define GetLocaleInfoWrapW          GetLocaleInfoW
#define GetMenuStringWrapW          GetMenuStringW
#define GetMessageWrapW             GetMessageW
#define GetModuleFileNameWrapW      GetModuleFileNameW
#define GetNumberFormatWrapW        GetNumberFormatW
#define GetSystemDirectoryWrapW     GetSystemDirectoryW
#define GetModuleHandleWrapW        GetModuleHandleW
#define GetObjectWrapW              GetObjectW
#define GetPrivateProfileIntWrapW   GetPrivateProfileIntW
#define GetProfileStringWrapW       GetProfileStringW
#define GetPrivateProfileStringWrapW GetPrivateProfileStringW
#define WritePrivateProfileStringWrapW WritePrivateProfileStringW
#define GetPropWrapW                GetPropW
#define GetStringTypeExWrapW        GetStringTypeExW
#define GetTempFileNameWrapW        GetTempFileNameW
#define GetTempPathWrapW            GetTempPathW
#define GetTextExtentPoint32WrapW   GetTextExtentPoint32W
#define GetTextFaceWrapW            GetTextFaceW
#define GetTextMetricsWrapW         GetTextMetricsW
#define GetTimeFormatWrapW          GetTimeFormatW
#define GetDateFormatWrapW          GetDateFormatW
#define GetUserNameWrapW            GetUserNameW
#define GetWindowLongWrapW          GetWindowLongW
#define GetWindowTextWrapW          GetWindowTextW
#define GetWindowTextLengthWrapW    GetWindowTextLengthW
#define GetWindowsDirectoryWrapW    GetWindowsDirectoryW
#define InsertMenuItemWrapW         InsertMenuItemW
#define InsertMenuWrapW             InsertMenuW
#define IsBadStringPtrWrapW         IsBadStringPtrW
#define IsDialogMessageWrapW        IsDialogMessageW
#define LoadAcceleratorsWrapW       LoadAcceleratorsW
#define LoadBitmapWrapW             LoadBitmapW
#define LoadCursorWrapW             LoadCursorW
#define LoadIconWrapW               LoadIconW
#define LoadImageWrapW              LoadImageW
#define LoadLibraryWrapW            LoadLibraryW
#define LoadLibraryExWrapW          LoadLibraryExW
#define LoadMenuWrapW               LoadMenuW
#define LoadStringWrapW             LoadStringW
#define MessageBoxIndirectWrapW     MessageBoxIndirectW
#define MessageBoxWrapW             MessageBoxW
#define ModifyMenuWrapW             ModifyMenuW
#define GetCharWidth32WrapW         GetCharWidth32W
#define GetCharacterPlacementWrapW  GetCharacterPlacementW
#define CopyFileWrapW               CopyFileW
#define MoveFileWrapW               MoveFileW
#define OemToCharWrapW              OemToCharW
#define OutputDebugStringWrapW      OutputDebugStringW
#define PeekMessageWrapW            PeekMessageW
#define PostMessageWrapW            PostMessageW
#define PostThreadMessageWrapW      PostThreadMessageW
#define RegCreateKeyWrapW           RegCreateKeyW
#define RegCreateKeyExWrapW         RegCreateKeyExW
#define RegDeleteKeyWrapW           RegDeleteKeyW
#define RegDeleteValueWrapW         RegDeleteValueW
#define RegEnumKeyWrapW             RegEnumKeyW
#define RegEnumKeyExWrapW           RegEnumKeyExW
#define RegOpenKeyWrapW             RegOpenKeyW
#define RegOpenKeyExWrapW           RegOpenKeyExW
#define RegQueryInfoKeyWrapW        RegQueryInfoKeyW
#define RegQueryValueWrapW          RegQueryValueW
#define RegQueryValueExWrapW        RegQueryValueExW
#define RegSetValueWrapW            RegSetValueW
#define RegSetValueExWrapW          RegSetValueExW
#define RegisterClassWrapW          RegisterClassW
#define RegisterClassExWrapW        RegisterClassExW
#define RegisterClipboardFormatWrapWRegisterClipboardFormatW
#define RegisterWindowMessageWrapW  RegisterWindowMessageW
#define RemovePropWrapW             RemovePropW
#define SearchPathWrapW             SearchPathW
#define SendDlgItemMessageWrapW     SendDlgItemMessageW
#define SendMessageWrapW            SendMessageW
#define SetCurrentDirectoryWrapW    SetCurrentDirectoryW
#define SetDlgItemTextWrapW         SetDlgItemTextW
#define SetMenuItemInfoWrapW        SetMenuItemInfoW
#define SetPropWrapW                SetPropW
#define SetFileAttributesWrapW      SetFileAttributesW
#define SetWindowLongWrapW          SetWindowLongW
#define SetWindowsHookExWrapW       SetWindowsHookExW
#define SHBrowseForFolderWrapW      SHBrowseForFolderW
#define ShellExecuteExWrapW         ShellExecuteExW
#define SHFileOperationWrapW        SHFileOperationW
#define SHGetFileInfoWrapW          SHGetFileInfoW
#define SHGetPathFromIDListWrapW    SHGetPathFromIDListW
#define StartDocWrapW               StartDocW
#define SystemParametersInfoWrapW   SystemParametersInfoW
#define TranslateAcceleratorWrapW   TranslateAcceleratorW
#define UnregisterClassWrapW        UnregisterClassW
#define VkKeyScanWrapW              VkKeyScanW
#define WinHelpWrapW                WinHelpW
#define WNetRestoreConnectionWrapW  WNetRestoreConnectionW
#define WNetGetLastErrorWrapW       WNetGetLastErrorW
#define wvsprintfWrapW              wvsprintfW
#define CreateFontWrapW             CreateFontW
#define DrawTextExWrapW             DrawTextExW
#define SetMenuItemInfoWrapW        SetMenuItemInfoW
#define InsertMenuItemWrapW         InsertMenuItemW
#define DragQueryFileWrapW          DragQueryFileW

#define IsCharAlphaWrap             IsCharAlphaW
#define IsCharUpperWrap             IsCharUpperW
#define IsCharLowerWrap             IsCharLowerW
#define IsCharAlphaNumericWrap      IsCharAlphaNumericW
#define AppendMenuWrap              AppendMenuW
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterW
#endif
#define CallWindowProcWrap          CallWindowProcW
#define CharLowerWrap               CharLowerW
#define CharLowerBuffWrap           CharLowerBuffW
#define CharNextWrap                CharNextW
#define CharPrevWrap                CharPrevW
#define CharToOemWrap               CharToOemW
#define CharUpperWrap               CharUpperW
#define CharUpperBuffWrap           CharUpperBuffW
#define CompareStringWrap           CompareStringW
#define CopyAcceleratorTableWrap    CopyAcceleratorTableW
#define CreateAcceleratorTableWrap  CreateAcceleratorTableW
#define CreateDCWrap                CreateDCW
#define CreateDirectoryWrap         CreateDirectoryW
#define CreateEventWrap             CreateEventW
#define CreateFontWrap              CreateFontW
#define CreateFileWrap              CreateFileW
#define CreateFontIndirectWrap      CreateFontIndirectW
#define CreateICWrap                CreateICW
#define CreateMetaFileWrap          CreateMetaFileW
#define CreateMutexWrap             CreateMutexW
#define CreateSemaphoreWrap         CreateSemaphoreW
#define CreateWindowExWrap          CreateWindowExW
#define DefWindowProcWrap           DefWindowProcW
#define DeleteFileWrap              DeleteFileW
#define DispatchMessageWrap         DispatchMessageW
#define DrawTextExWrap              DrawTextExW
#define DrawTextWrap                DrawTextW
#define EnumFontFamiliesWrap        EnumFontFamiliesW
#define EnumFontFamiliesExWrap      EnumFontFamiliesExW
#define EnumResourceNamesWrap       EnumResourceNamesW
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsW
#define ExtractIconExWrap           ExtractIconExW
#define ExtTextOutWrap              ExtTextOutW
#define FindFirstFileWrap           FindFirstFileW
#define FindNextFileWrap            FindNextFileW
#define FindResourceWrap            FindResourceW
#define FindWindowWrap              FindWindowW
#define FindWindowExWrap            FindWindowExW
#define FormatMessageWrap           FormatMessageW
#define GetClassInfoWrap            GetClassInfoW
#define GetClassInfoExWrap          GetClassInfoExW
#define GetClassLongWrap            GetClassLongW
#define GetClassNameWrap            GetClassNameW
#define GetClipboardFormatNameWrap  GetClipboardFormatNameW
#define GetCurrentDirectoryWrap     GetCurrentDirectoryW
#define GetDlgItemTextWrap          GetDlgItemTextW
#define GetFileAttributesWrap       GetFileAttributesW
#define GetFullPathNameWrap         GetFullPathNameW
#define GetLocaleInfoWrap           GetLocaleInfoW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define GetMenuStringWrap           GetMenuStringW
#define GetMessageWrap              GetMessageW
#define GetModuleFileNameWrap       GetModuleFileNameW
#define GetNumberFormatWrap         GetNumberFormatW
#define GetSystemDirectoryWrap      GetSystemDirectoryW
#define GetModuleHandleWrap         GetModuleHandleW
#define GetObjectWrap               GetObjectW
#define GetPrivateProfileIntWrap    GetPrivateProfileIntW
#define GetProfileStringWrap        GetProfileStringW
#define GetPrivateProfileStringWrap GetPrivateProfileStringW
#define WritePrivateProfileStringWrap WritePrivateProfileStringW
#define GetPropWrap                 GetPropW
#define GetStringTypeExWrap         GetStringTypeExW
#define GetTempFileNameWrap         GetTempFileNameW
#define GetTempPathWrap             GetTempPathW
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32W
#define GetTextFaceWrap             GetTextFaceW
#define GetTextMetricsWrap          GetTextMetricsW
#define GetTimeFormatWrap           GetTimeFormatW
#define GetDateFormatWrap           GetDateFormatW
#define GetUserNameWrap             GetUserNameW
#define GetWindowLongWrap           GetWindowLongW
#define GetWindowTextWrap           GetWindowTextW
#define GetWindowTextLengthWrap     GetWindowTextLengthW
#define GetWindowsDirectoryWrap     GetWindowsDirectoryW
#define InsertMenuItemWrap          InsertMenuItemW
#define InsertMenuWrap              InsertMenuW
#define IsBadStringPtrWrap          IsBadStringPtrW
#define IsDialogMessageWrap         IsDialogMessageW
#define LoadAcceleratorsWrap        LoadAcceleratorsW
#define LoadBitmapWrap              LoadBitmapW
#define LoadCursorWrap              LoadCursorW
#define LoadIconWrap                LoadIconW
#define LoadImageWrap               LoadImageW
#define LoadLibraryWrap             LoadLibraryW
#define LoadLibraryExWrap           LoadLibraryExW
#define LoadMenuWrap                LoadMenuW
#define LoadStringWrap              LoadStringW
#define MessageBoxIndirectWrap      MessageBoxIndirectW
#define MessageBoxWrap              MessageBoxW
#define ModifyMenuWrap              ModifyMenuW
#define GetCharWidth32Wrap          GetCharWidth32W
#define GetCharacterPlacementWrap   GetCharacterPlacementW
#define CopyFileWrap                CopyFileW
#define MoveFileWrap                MoveFileW
#define OemToCharWrap               OemToCharW
#define OutputDebugStringWrap       OutputDebugStringW
#define PeekMessageWrap             PeekMessageW
#define PostMessageWrap             PostMessageW
#define PostThreadMessageWrap       PostThreadMessageW
#define RegCreateKeyWrap            RegCreateKeyW
#define RegCreateKeyExWrap          RegCreateKeyExW
#define RegDeleteKeyWrap            RegDeleteKeyW
#define RegDeleteValueWrap          RegDeleteValueW
#define RegEnumKeyWrap              RegEnumKeyW
#define RegEnumKeyExWrap            RegEnumKeyExW
#define RegOpenKeyWrap              RegOpenKeyW
#define RegOpenKeyExWrap            RegOpenKeyExW
#define RegQueryInfoKeyWrap         RegQueryInfoKeyW
#define RegQueryValueWrap           RegQueryValueW
#define RegQueryValueExWrap         RegQueryValueExW
#define RegSetValueWrap             RegSetValueW
#define RegSetValueExWrap           RegSetValueExW
#define RegisterClassWrap           RegisterClassW
#define RegisterClassExWrap         RegisterClassExW
#define RegisterClipboardFormatWrap RegisterClipboardFormatW
#define RegisterWindowMessageWrap   RegisterWindowMessageW
#define RemovePropWrap              RemovePropW
#define SearchPathWrap              SearchPathW
#define SendDlgItemMessageWrap      SendDlgItemMessageW
#define SendMessageWrap             SendMessageW
#define SetCurrentDirectoryWrap     SetCurrentDirectoryW
#define SetDlgItemTextWrap          SetDlgItemTextW
#define SetMenuItemInfoWrap         SetMenuItemInfoW
#define SetPropWrap                 SetPropW
#define SetFileAttributesWrap       SetFileAttributesW
#define SetWindowLongWrap           SetWindowLongW
#define SetWindowsHookExWrap        SetWindowsHookExW
#define SHBrowseForFolderWrap       SHBrowseForFolderW
#define ShellExecuteExWrap          ShellExecuteExW
#define SHFileOperationWrap         SHFileOperationW
#define SHGetFileInfoWrap           SHGetFileInfoW
#define SHGetPathFromIDListWrap     SHGetPathFromIDListW
#define StartDocWrap                StartDocW
#define SystemParametersInfoWrap    SystemParametersInfoW
#define TranslateAcceleratorWrap    TranslateAcceleratorW
#define UnregisterClassWrap         UnregisterClassW
#define VkKeyScanWrap               VkKeyScanW
#define WinHelpWrap                 WinHelpW
#define WNetRestoreConnectionWrap   WNetRestoreConnectionW
#define WNetGetLastErrorWrap        WNetGetLastErrorW
#define wvsprintfWrap               wvsprintfW
#define CreateFontWrap              CreateFontW
#define DrawTextExWrap              DrawTextExW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define SetMenuItemInfoWrap         SetMenuItemInfoW
#define InsertMenuItemWrap          InsertMenuItemW
#define DragQueryFileWrap           DragQueryFileW

#else

#define IsCharAlphaWrap             IsCharAlphaA
#define IsCharUpperWrap             IsCharUpperA
#define IsCharLowerWrap             IsCharLowerA
#define IsCharAlphaNumericWrap      IsCharAlphaNumericA
#define AppendMenuWrap              AppendMenuA
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterA
#endif
#define CallWindowProcWrap          CallWindowProcA
#define CharLowerWrap               CharLowerA
#define CharLowerBuffWrap           CharLowerBuffA
#define CharNextWrap                CharNextA
#define CharPrevWrap                CharPrevA
#define CharToOemWrap               CharToOemA
#define CharUpperWrap               CharUpperA
#define CharUpperBuffWrap           CharUpperBuffA
#define CompareStringWrap           CompareStringA
#define CopyAcceleratorTableWrap    CopyAcceleratorTableA
#define CreateAcceleratorTableWrap  CreateAcceleratorTableA
#define CreateDCWrap                CreateDCA
#define CreateDirectoryWrap         CreateDirectoryA
#define CreateEventWrap             CreateEventA
#define CreateFontWrap              CreateFontA
#define CreateFileWrap              CreateFileA
#define CreateFontIndirectWrap      CreateFontIndirectA
#define CreateICWrap                CreateICA
#define CreateMetaFileWrap          CreateMetaFileA
#define CreateMutexWrap             CreateMutexA
#define CreateSemaphoreWrap         CreateSemaphoreA
#define CreateWindowExWrap          CreateWindowExA
#define DefWindowProcWrap           DefWindowProcA
#define DeleteFileWrap              DeleteFileA
#define DispatchMessageWrap         DispatchMessageA
#define DrawTextExWrap              DrawTextExA
#define DrawTextWrap                DrawTextA
#define EnumFontFamiliesWrap        EnumFontFamiliesA
#define EnumFontFamiliesExWrap      EnumFontFamiliesExA
#define EnumResourceNamesWrap       EnumResourceNamesA
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsA
#define ExtractIconExWrap           ExtractIconExA
#define ExtTextOutWrap              ExtTextOutA
#define FindFirstFileWrap           FindFirstFileA
#define FindResourceWrap            FindResourceA
#define FindNextFileWrap            FindNextFileA
#define FindWindowWrap              FindWindowA
#define FindWindowExWrap            FindWindowExA
#define FormatMessageWrap           FormatMessageA
#define GetClassInfoWrap            GetClassInfoA
#define GetClassInfoExWrap          GetClassInfoExA
#define GetClassLongWrap            GetClassLongA
#define GetClassNameWrap            GetClassNameA
#define GetClipboardFormatNameWrap  GetClipboardFormatNameA
#define GetCurrentDirectoryWrap     GetCurrentDirectoryA
#define GetDlgItemTextWrap          GetDlgItemTextA
#define GetFileAttributesWrap       GetFileAttributesA
#define GetFullPathNameWrap         GetFullPathNameA
#define GetLocaleInfoWrap           GetLocaleInfoA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define GetMenuStringWrap           GetMenuStringA
#define GetMessageWrap              GetMessageA
#define GetModuleFileNameWrap       GetModuleFileNameA
#define GetNumberFormatWrap         GetNumberFormatA
#define GetPrivateProfileStringWrap GetPrivateProfileStringA
#define WritePrivateProfileStringWrap WritePrivateProfileStringA
#define GetSystemDirectoryWrap      GetSystemDirectoryA
#define SearchPathWrap              SearchPathA
#define GetModuleHandleWrap         GetModuleHandleA
#define GetObjectWrap               GetObjectA
#define GetPrivateProfileIntWrap    GetPrivateProfileIntA
#define GetProfileStringWrap        GetProfileStringA
#define GetPropWrap                 GetPropA
#define GetStringTypeExWrap         GetStringTypeExA
#define GetTempFileNameWrap         GetTempFileNameA
#define GetTempPathWrap             GetTempPathA
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32A
#define GetTextFaceWrap             GetTextFaceA
#define GetTextMetricsWrap          GetTextMetricsA
#define GetTimeFormatWrap           GetTimeFormatA
#define GetDateFormatWrap           GetDateFormatA
#define GetUserNameWrap             GetUserNameA
#define GetWindowLongWrap           GetWindowLongA
#define GetWindowTextWrap           GetWindowTextA
#define GetWindowTextLengthWrap     GetWindowTextLengthA
#define GetWindowsDirectoryWrap     GetWindowsDirectoryA
#define InsertMenuItemWrap          InsertMenuItemA
#define InsertMenuWrap              InsertMenuA
#define IsBadStringPtrWrap          IsBadStringPtrA
#define IsDialogMessageWrap         IsDialogMessageA
#define LoadAcceleratorsWrap        LoadAcceleratorsA
#define LoadBitmapWrap              LoadBitmapA
#define LoadCursorWrap              LoadCursorA
#define LoadIconWrap                LoadIconA
#define LoadImageWrap               LoadImageWrapA
#define LoadLibraryWrap             LoadLibraryA
#define LoadLibraryExWrap           LoadLibraryExA
#define LoadMenuWrap                LoadMenuA
#define LoadStringWrap              LoadStringA
#define MessageBoxIndirectWrap      MessageBoxIndirectA
#define MessageBoxWrap              MessageBoxA
#define ModifyMenuWrap              ModifyMenuA
#define GetCharWidth32Wrap          GetCharWidth32A
#define GetCharacterPlacementWrap   GetCharacterPlacementA
#define CopyFileWrap                CopyFileA
#define MoveFileWrap                MoveFileA
#define OemToCharWrap               OemToCharA
#define OutputDebugStringWrap       OutputDebugStringA
#define PeekMessageWrap             PeekMessageA
#define PostMessageWrap             PostMessageA
#define PostThreadMessageWrap       PostThreadMessageA
#define RegCreateKeyWrap            RegCreateKeyA
#define RegCreateKeyExWrap          RegCreateKeyExA
#define RegDeleteKeyWrap            RegDeleteKeyA
#define RegDeleteValueWrap          RegDeleteValueA
#define RegEnumKeyWrap              RegEnumKeyA
#define RegEnumKeyExWrap            RegEnumKeyExA
#define RegOpenKeyWrap              RegOpenKeyA
#define RegOpenKeyExWrap            RegOpenKeyExA
#define RegQueryInfoKeyWrap         RegQueryInfoKeyA
#define RegQueryValueWrap           RegQueryValueA
#define RegQueryValueExWrap         RegQueryValueExA
#define RegSetValueWrap             RegSetValueA
#define RegSetValueExWrap           RegSetValueExA
#define RegisterClassWrap           RegisterClassA
#define RegisterClassExWrap         RegisterClassExA
#define RegisterClipboardFormatWrap RegisterClipboardFormatA
#define RegisterWindowMessageWrap   RegisterWindowMessageA
#define RemovePropWrap              RemovePropA
#define SendDlgItemMessageWrap      SendDlgItemMessageA
#define SendMessageWrap             SendMessageA
#define SetCurrentDirectoryWrap     SetCurrentDirectoryA
#define SetDlgItemTextWrap          SetDlgItemTextA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define SetPropWrap                 SetPropA
#define SetWindowLongWrap           SetWindowLongA
#define SHBrowseForFolderWrap       SHBrowseForFolderA
#define ShellExecuteExWrap          ShellExecuteExA
#define SHFileOperationWrap         SHFileOperationA
#define SHGetFileInfoWrap           SHGetFileInfoA
#define SHGetPathFromIDListWrap     SHGetPathFromIDListA
#define SetFileAttributesWrap       SetFileAttributesA
#define SetWindowsHookExWrap        SetWindowsHookExA
#define StartDocWrap                StartDocA
#define SystemParametersInfoWrap    SystemParametersInfoA
#define TranslateAcceleratorWrap    TranslateAcceleratorA
#define UnregisterClassWrap         UnregisterClassA
#define VkKeyScanWrap               VkKeyScanA
#define WinHelpWrap                 WinHelpA
#define WNetRestoreConnectionWrap   WNetRestoreConnectionA
#define WNetGetLastErrorWrap        WNetGetLastErrorA
#define wvsprintfWrap               wvsprintfA
#define CreateFontWrap              CreateFontA
#define DrawTextExWrap              DrawTextExA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define InsertMenuItemWrap          InsertMenuItemA
#define DragQueryFileWrap           DragQueryFileA
#endif
#endif // defined(UNIX) && defined(NO_SHLWAPI_UNITHUNK)

// Some functions are used to wrap unicode win95 functions AND to provide ML wrappers,
// so they are needed unless BOTH NO_SHLWAPI_UNITHUNG and NO_SHLWAPI_MLUI are defined
//
#if (_WIN32_IE >= 0x0500) && (!defined(NO_SHLWAPI_UNITHUNK) || !defined(NO_SHLWAPI_MLUI))

LWSTDAPI_(HWND)
CreateDialogIndirectParamWrapW(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam);

LWSTDAPI_(HWND)
CreateDialogParamWrapW(
        HINSTANCE   hInstance,
        LPCWSTR     lpTemplateName,
        HWND        hWndParent,
        DLGPROC     lpDialogFunc,
        LPARAM      dwInitParam);

LWSTDAPI_(INT_PTR)
DialogBoxIndirectParamWrapW(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam);

LWSTDAPI_(INT_PTR)
DialogBoxParamWrapW(
        HINSTANCE   hInstance,
        LPCWSTR     lpszTemplate,
        HWND        hWndParent,
        DLGPROC     lpDialogFunc,
        LPARAM      dwInitParam);

LWSTDAPI_(BOOL) SetWindowTextWrapW(HWND hWnd, LPCWSTR lpString);

int _cdecl ShellMessageBoxWrapW(HINSTANCE hInst, HWND hWnd, LPCWSTR pszMsg, LPCWSTR pszTitle, UINT fuStyle, ...);

LWSTDAPI_(BOOL) DeleteMenuWrap(HMENU hMenu, UINT uPosition, UINT uFlags);

LWSTDAPI_(BOOL) DestroyMenuWrap(HMENU hMenu);

#ifdef UNICODE

#define CreateDialogIndirectParamWrap CreateDialogIndirectParamWrapW
#define CreateDialogParamWrap       CreateDialogParamWrapW
#define DialogBoxIndirectParamWrap  DialogBoxIndirectParamWrapW
#define DialogBoxParamWrap          DialogBoxParamWrapW
#define SetWindowTextWrap           SetWindowTextWrapW
#define ShellMessageBoxWrap         ShellMessageBoxWrapW

#else

#define CreateDialogIndirectParamWrap CreateDialogIndirectParamA
#define CreateDialogParamWrap       CreateDialogParamA
#define DialogBoxIndirectParamWrap  DialogBoxIndirectParamA
#define DialogBoxParamWrap          DialogBoxParamA
#define SetWindowTextWrap           SetWindowTextA
#define ShellMessageBoxWrap         ShellMessageBoxA

#endif // UNICODE

#endif // (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_UNITHUNK) && !defined (NO_SHLWAPI_MLUI)


//=============== Thread Pool Services ===================================

#if (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_TPS)

//
// SHLWAPIP versions of KERNEL32 Thread Pool Services APIs
//

typedef void (NTAPI * WAITORTIMERCALLBACKFUNC)(void *, BOOLEAN);
typedef void (NTAPI * WORKERCALLBACKFUNC)(void *); // BUGBUG - why declare this?
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;

LWSTDAPI_(HANDLE)
SHRegisterWaitForSingleObject(
    IN HANDLE hObject,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwMilliseconds,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    );

//
// flags for SHRegisterWaitForSingleObject (keep separate from other TPS flags)
//

//
// SRWSO_NOREMOVE - if set, the handle is not to be removed from the list once
// signalled. Intended for use with auto-reset events that the caller wants to
// keep until unregistered
//

#define SRWSO_NOREMOVE      0x00000100

#define SRWSO_VALID_FLAGS   (SRWSO_NOREMOVE)

#define SRWSO_INVALID_FLAGS (~SRWSO_VALID_FLAGS)

LWSTDAPI_(BOOL)
SHUnregisterWait(
    IN HANDLE hWait
    );

typedef struct {
    DWORD dwStructSize;
    DWORD dwMinimumWorkerThreads;
    DWORD dwMaximumWorkerThreads;
    DWORD dwMaximumWorkerQueueDepth;
    DWORD dwWorkerThreadIdleTimeout;
    DWORD dwWorkerThreadCreationDelta;
    DWORD dwMinimumIoWorkerThreads;
    DWORD dwMaximumIoWorkerThreads;
    DWORD dwMaximumIoWorkerQueueDepth;
    DWORD dwIoWorkerThreadCreationDelta;
} SH_THREAD_POOL_LIMITS, *PSH_THREAD_POOL_LIMITS;

LWSTDAPI_(BOOL)
SHSetThreadPoolLimits(
    IN PSH_THREAD_POOL_LIMITS pLimits
    );

LWSTDAPI_(BOOL)
SHTerminateThreadPool(
    VOID
    );

LWSTDAPI_(BOOL)
SHQueueUserWorkItem(
    IN LPTHREAD_START_ROUTINE pfnCallback,
    IN LPVOID pContext,
    IN LONG lPriority,
    IN DWORD_PTR dwTag,
    OUT DWORD_PTR * pdwId OPTIONAL,
    IN LPCSTR pszModule OPTIONAL,
    IN DWORD dwFlags
    );

LWSTDAPI_(DWORD)
SHCancelUserWorkItems(
    IN DWORD_PTR dwTagOrId,
    IN BOOL bTag
    );

LWSTDAPI_(HANDLE)
SHCreateTimerQueue(
    VOID
    );

LWSTDAPI_(BOOL)
SHDeleteTimerQueue(
    IN HANDLE hQueue
    );

LWSTDAPI_(HANDLE)
SHSetTimerQueueTimer(
    IN HANDLE hQueue,
    IN WAITORTIMERCALLBACK pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    );

LWSTDAPI_(BOOL)
SHChangeTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod
    );

LWSTDAPI_(BOOL)
SHCancelTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer
    );

//
// Thread Pool Services flags
//

//
// TPS_EXECUTEIO - execute in I/O thread (via APC). Default is non-IO thread
//

#define TPS_EXECUTEIO       0x00000001

//
// TPS_TAGGEDITEM - the dwTag parameter is meaningful
//

#define TPS_TAGGEDITEM      0x00000002

//
// TPS_DEMANDTHREAD - always create a new thread if none currently available.
// Used in situations where immediate response required
//

#define TPS_DEMANDTHREAD    0x00000004

//
// TPS_LONGEXECTIME - the work item will take relatively long time to execute.
// Used as management hint to TPS
//

#define TPS_LONGEXECTIME    0x00000008

//
// TPS_RESERVED_FLAGS - mask of bits reserved for internal use
//

#define TPS_RESERVED_FLAGS  0xFF000000

#define TPS_VALID_FLAGS     (TPS_EXECUTEIO      \
                            | TPS_TAGGEDITEM    \
                            | TPS_DEMANDTHREAD  \
                            | TPS_LONGEXECTIME  \
                            )
#define TPS_INVALID_FLAGS   (~TPS_VALID_FLAGS)

#endif // (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_TPS)


//
// Private MIME helper functions used by shdocvw & shell32
//
#if (_WIN32_IE >= 0x0500)

STDAPI_(BOOL) GetMIMETypeSubKeyA(LPCSTR pszMIMEType, LPSTR pszBuf, UINT cchBuf);
STDAPI_(BOOL) GetMIMETypeSubKeyW(LPCWSTR pszMIMEType, LPWSTR pszBuf, UINT cchBuf);

STDAPI_(BOOL) RegisterMIMETypeForExtensionA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType);
STDAPI_(BOOL) RegisterMIMETypeForExtensionW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType);

STDAPI_(BOOL) UnregisterMIMETypeForExtensionA(LPCSTR pcszExtension);
STDAPI_(BOOL) UnregisterMIMETypeForExtensionW(LPCWSTR pcszExtension);

STDAPI_(BOOL) RegisterExtensionForMIMETypeA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType);
STDAPI_(BOOL) RegisterExtensionForMIMETypeW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType);

STDAPI_(BOOL) UnregisterExtensionForMIMETypeA(LPCSTR pcszMIMEContentType);
STDAPI_(BOOL) UnregisterExtensionForMIMETypeW(LPCWSTR pcszMIMEContentType);

STDAPI_(BOOL) MIME_GetExtensionA(LPCSTR pcszMIMEType, LPSTR pszExtensionBuf, UINT ucExtensionBufLen);
STDAPI_(BOOL) MIME_GetExtensionW(LPCWSTR pcszMIMEType, LPWSTR pszExtensionBuf, UINT ucExtensionBufLen);

#ifdef UNICODE
#define GetMIMETypeSubKey               GetMIMETypeSubKeyW
#define RegisterMIMETypeForExtension    RegisterMIMETypeForExtensionW
#define UnregisterMIMETypeForExtension  UnregisterMIMETypeForExtensionW
#define RegisterExtensionForMIMEType    RegisterExtensionForMIMETypeW
#define UnregisterExtensionForMIMEType  UnregisterExtensionForMIMETypeW
#define MIME_GetExtension               MIME_GetExtensionW
#else
#define GetMIMETypeSubKey               GetMIMETypeSubKeyA
#define RegisterMIMETypeForExtension    RegisterMIMETypeForExtensionA
#define UnregisterMIMETypeForExtension  UnregisterMIMETypeForExtensionA
#define RegisterExtensionForMIMEType    RegisterExtensionForMIMETypeA
#define UnregisterExtensionForMIMEType  UnregisterExtensionForMIMETypeA
#define MIME_GetExtension               MIME_GetExtensionA
#endif

// Options for SHGetMachineInfo

//
//  Note that GMI_DOCKSTATE is unreliable for ACPI laptops.
//
#define GMI_DOCKSTATE           0x0000
    // Return values for SHGetMachineInfo(GMI_DOCKSTATE)
    #define GMID_NOTDOCKABLE         0  // Cannot be docked
    #define GMID_UNDOCKED            1  // Is undocked
    #define GMID_DOCKED              2  // Is docked

//
//  GMI_BATTERYSTATE reports on the presence and status of non-UPS
//  batteries.
//
#define GMI_BATTERYSTATE        0x0001
    // Return value for SHGetMachineInfo(GMI_BATTERYSTATE) is a bitmask
    #define GMIB_HASBATTERY          0x0001 // Can run on batteries
    #define GMIB_ONBATTERY           0x0002 // Is now on batteries

//
//  WARNING!  DANGER!  EVIL!
//
//  GMI_LAPTOP is not perfect.  It can be fooled by particular hardware
//  configurations.  You are much better off asking specifically why you
//  care about laptops and use one of the above GMI values instead.  For
//  example, if you want to scale back some intensive operation so you
//  don't drain the battery, use GMI_BATTERYSTATE instead.
//
#define GMI_LAPTOP              0x0002  // Returns nonzero if might be a laptop

#if (_WIN32_IE >= 0x0501)

//
//  GMI_TSCLIENT tells you whether you are running as a Terminal Server
//  client and should disable your animations.
//
#define GMI_TSCLIENT            0x0003  // Returns nonzero if TS client

#endif // (_WIN32_IE >= 0x0501)

STDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi);

// support InterlockedCompareExchange() on Win95

STDAPI_(void *) SHInterlockedCompareExchange(void **ppDest, void *pExch, void *pComp);

#if !defined(_X86_)
// Win95 doesn't run on Alpha/UNIX so we can use the OS function directly
// Use a #define instead of a forwarder because it's an intrinsic on most
// compilers.
#define SHInterlockedCompareExchange InterlockedCompareExchangePointer
#endif

LWSTDAPI_(BOOL) SHMirrorIcon(HICON* phiconSmall, HICON* phiconLarge);


#endif // (_WIN32_IE >= 0x0500)


//  Raw Accelerator Table API
//
//  Allows an accelerator table grep without having to invoke ::TranslateAccelerator.
//  Useful for dealing with parent-child window accelerator conflicts.
//

//  HANDLE SHLoadRawAccelerators( HINSTANCE hInst, LPCTSTR lpTableName );
//  Loads the raw accelerator table.
//  hInst       Module instance containing the accelerator resource.
//  lpTableName Names the accelerator table resource to load.

//  The return value is a handle that can be passed to a SHQueryRawAcceleratorXXX function.
//  When the handle is no longer required, it should be freed with LocalFree().
STDAPI_(HANDLE) SHLoadRawAccelerators   ( HINSTANCE hInst, LPCTSTR lpTableName );

//  BOOL SHQueryRawAccelerator   ( HANDLE hcaAcc, IN BYTE fVirtMask, IN BYTE fVirt, IN WPARAM wKey, OUT OPTIONAL UINT* puCmdID );
//  Queries the raw accelererator table for the specified key
//  hcaAcc      Handle returned from SHLoadRawAccelerators().
//  fVirtMask   Relevant accelerator flags (any combo of FALT|FCONTROL|FNOINVERT|FSHIFT|FVIRTKEY)
//  fVirt       Accelerator flags to test (any combo of FALT|FCONTROL|FNOINVERT|FSHIFT|FVIRTKEY).
//  wKey        Accelerator key.  This can either be a virtual key (FVIRTKEY) or an ASCII char code.
//  puCmdID     Optional address to receive command identifier for the accelerator entry if
//              the key is in the table.
//  Returns nonzero if the key is in the accelerator table; otherwise 0.
STDAPI_(BOOL)   SHQueryRawAccelerator   ( HANDLE hcaAcc, IN BYTE fVirtMask, IN BYTE fVirt, IN WPARAM wKey, OUT OPTIONAL UINT* puCmdID );

//  BOOL SHQueryRawAcceleratorMsg( HANDLE hcaAcc, MSG* pmsg, OUT OPTIONAL UINT* puCmdID );
//  Determines whether the specified message is an accelerator message mapping to
//  an entry in the raw accelerator table.
//  hcaAcc      Handle returned from SHLoadRawAccelerators().
//  pmsg        Address of the message to test.
//  puCmdID     Optional address to receive command identifier for the accelerator entry if
//              the message maps to an accelerator in the table.
//  Returns nonzero if the message is a WM_KEYUP or WM_KEYDOWN and the key is in
//  the accelerator table; otherwise 0.
STDAPI_(BOOL)   SHQueryRawAcceleratorMsg( HANDLE hcaAcc, MSG* pmsg, OUT OPTIONAL UINT* puCmdID );
//
//


//
//====== End Internal functions  ===============================================
//
#endif // NO_SHLWAPI_INTERNAL

#ifdef NOTYET       // BUGBUG (scotth): once this is implemented, make this public
// SHGetCommonResourceID
//
// (use MAKEINTRESOURCE on the following IDs)

// These values are indexes into an internal table.  Be careful.
#define SHGCR_BITMAP_WINDOWS_LOGO   MAKEINTRESOURCE(1)
#define SHGCR_AVI_FLASHLIGHT        MAKEINTRESOURCE(2)
#define SHGCR_AVI_FINDFILE          MAKEINTRESOURCE(3)
#define SHGCR_AVI_FINDCOMPUTER      MAKEINTRESOURCE(4)
#define SHGCR_AVI_FILEMOVE          MAKEINTRESOURCE(5)
#define SHGCR_AVI_FILECOPY          MAKEINTRESOURCE(6)
#define SHGCR_AVI_FILEDELETE        MAKEINTRESOURCE(7)
#define SHGCR_AVI_EMPTYWASTEBASKET  MAKEINTRESOURCE(8)
#define SHGCR_AVI_FILEREALDELETE    MAKEINTRESOURCE(9)      // Bypass Recycle Bin
#define SHGCR_AVI_DOWNLOAD          MAKEINTRESOURCE(10)

LWSTDAPI SHGetCommonResourceIDA(IN LPCSTR pszID, IN DWORD dwRes, OUT HMODULE * phmod, OUT UINT * pnID);
LWSTDAPI SHGetCommonResourceIDA(IN LPCSTR pszID, IN DWORD dwRes, OUT HMODULE * phmod, OUT UINT * pnID);

#ifdef UNICODE
#define SHGetCommonResourceID   SHGetCommonResourceIDW
#else
#define SHGetCommonResourceID   SHGetCommonResourceIDW
#endif
#endif // NOTYET
    // dwFlags is really for alignment purposes
#if (_WIN32_IE >= 0x0501)
//
// ======== SHGetAppCompatFlags ================================================
//

//===========================================================================
// Shell Application Compatability flags

// SHGetAppCompatFlags flags
#define ACF_NONE               0x00000000
#define ACF_CONTEXTMENU        0x00000001
#define ACF_CORELINTERNETENUM  0x00000004 // corel suite 8 has this same problem as suite 7 but does not have context menu one so need new bit
#define ACF_OLDCREATEVIEWWND   0x00000004 // PowerDesk relies on CreateViewWindow returning S_OK
#define ACF_WIN95DEFVIEW       0x00000004   // for apps that depend on win95 defview behavior
#define ACF_DOCOBJECT          0x00000002
#define ACF_FLUSHNOWAITALWAYS  0x00000001
#define ACF_MYCOMPUTERFIRST    0x00000008 // MyComp must be first item on the desktop
#define ACF_OLDREGITEMGDN      0x00000010 // Win95-compatible GetDisplayNameOf on regitems
#define ACF_LOADCOLUMNHANDLER  0x00000040 // Dont delay load column handler.
#define ACF_ANSI               0x00000080 // For Apps that Pass in ANSI Strings
#define ACF_FOLDERSCUTASLINK   0x00000100 // make folder shortcuts look like .lnks that point to folders.
#define ACF_WIN95SHLEXEC       0x00000200 // dont use DDEWAIT when thunking to ShellExecEx()
#define ACF_STAROFFICE5PRINTER 0x00000400 // special return values from printer folder GAO
#define ACF_NOVALIDATEFSIDS    0x00000800 // FS pidls should not be validated.
#define ACF_APPISOFFICE        0x01000000 // calling app is office (95, 97, 2000, ++)
#define ACF_KNOWPERPROCESS     0x80000000 // We know the per process flags already.

                                    // The flags that are per-process
#define ACF_PERPROCESSFLAGS    (ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDCREATEVIEWWND | ACF_WIN95DEFVIEW | \
                                ACF_DOCOBJECT | ACF_FLUSHNOWAITALWAYS | ACF_MYCOMPUTERFIRST | ACF_OLDREGITEMGDN | \
                                ACF_LOADCOLUMNHANDLER | ACF_ANSI | ACF_STAROFFICE5PRINTER | ACF_NOVALIDATEFSIDS)

                                    // Flags that are per caller
#define ACF_PERCALLFLAGS        (ACF_APPISOFFICE | ACF_FOLDERSCUTASLINK)


LWSTDAPI_(DWORD) SHGetAppCompatFlags (DWORD dwFlagsNeeded);

#endif // (_WIN32_IE >= 0x0501)


#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif

#endif  // _INC_SHLWAPIP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\unaligned.hpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997-1998.
//
//  File:       unaligned.hpp
//
//  Contents:   Templatized data types for access to unaligned scalar values.
//
//----------------------------------------------------------------------------

// Implementation of UNALIGNED data values.  This works for simple scalar values.
// This file is heavily macro-based.  The intent is to do this work with arithmetic.
// The functionality may be expressed much more consisely with memcpy, but I need an
// implementation faster than that.

// To create an UNALIGNED type, use the MAKE_UNALIGNED_TYPE macro.  For example, if
// you need an int_UNALIGNED, say
//
//        MAKE_UNALIGNED_TYPE( int, 4 );
//
// Note that you need to specifiy the size of the base type.  This is because the
// amount of work to be done needs to be known by the preprocessor, where sizeof()
// doesn't work.

// To use: The intent is that replace occurances of "type UNALIGNED" in your code
// with "type_UNALIGNED".  It's simply a lexical change.  You could automate this
// change in order to easily convert code.  More importantly, the reverse
// transformation may also be easily automated, making it easier to merge with code
// that doesn't use these types.

// UNALIGNED64: The unaligned 64 types are an optimization.  They should only be used
// for values over four bytes in size (e.g. __int64, double).  They assume that the
// pointers are aligned to 4-bytes, so that access may be done with two 32-bit
// references, instead of 8 8-bit references.

#ifndef __unaligned_h__
#define __unaligned_h__

#if defined (_MSC_VER) || defined(__APOGEE__)

#define MAKE_UNALIGNED_TYPE(base,size)    typedef base UNALIGNED   base##_UNALIGNED

//
// Use MAKE_UNALIGNED64_TYPE for QWORD data that may only be DWORD aligned on 64-bit
// machines.  Only 64-bit architectures pay the penalty for accessing such data.
//

#ifdef SPARC
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base base##_UNALIGNED64
#else
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef base UNALIGNED base##_UNALIGNED64
#endif // SPARC

#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef base UNALIGNED *base##_UNALIGNEDPTR

#else // defined (_MSC_VER) || defined(__APOGEE__)


#ifdef BIG_ENDIAN

#define SET2(val,data)                          \
    data[0] = (val) >> 8,                       \
    data[1] = (val)

#define GET2(data)                              \
    ( ( data[0] << 8 ) |                        \
      ( data[1] ) )

#define SET4(val,data)                          \
    data[0] = (val) >> 24,                      \
    data[1] = (val) >> 16,                      \
    data[2] = (val) >> 8,                       \
    data[3] = (val)

#define GET4(data)                              \
    ( ( data[0] << 24 ) |                       \
      ( data[1] << 16 ) |                       \
      ( data[2] << 8 ) |                        \
      ( data[3] ) )

#define SET8(val,data)                          \
    data[0] = (val) >> 56,                      \
    data[1] = (val) >> 48,                      \
    data[2] = (val) >> 40,                      \
    data[3] = (val) >> 32                       \
    data[4] = (val) >> 24,                      \
    data[5] = (val) >> 16,                      \
    data[6] = (val) >> 8,                       \
    data[7] = (val)

#define GET8(data)                              \
    ( ( data[0] << 56 ) |                       \
      ( data[1] << 48 ) |                       \
      ( data[2] << 40 ) |                       \
      ( data[3] << 32 ) |                       \
      ( data[4] << 24 ) |                       \
      ( data[5] << 16 ) |                       \
      ( data[6] << 8 ) |                        \
      ( data[7] ) )

#define SET648(val,data)                        \
    data[0] = (val) >> 32,                      \
    data[1] = (val)

#define GET648(data)                            \
    ( ( data[0] << 32 ) |                       \
      ( data[1] ) )

#else

#define SET2(val,data)                          \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET2(data)                              \
    ( ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET4(val,data)                          \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET4(data)                              \
    ( ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET8(val,data)                          \
    data[7] = (val) >> 56,                      \
    data[6] = (val) >> 48,                      \
    data[5] = (val) >> 40,                      \
    data[4] = (val) >> 32,                      \
    data[3] = (val) >> 24,                      \
    data[2] = (val) >> 16,                      \
    data[1] = (val) >> 8,                       \
    data[0] = (val)

#define GET8(data)                              \
    ( ( data[7] << 56 ) |                       \
      ( data[6] << 48 ) |                       \
      ( data[5] << 40 ) |                       \
      ( data[4] << 32 ) |                       \
      ( data[3] << 24 ) |                       \
      ( data[2] << 16 ) |                       \
      ( data[1] << 8 ) |                        \
      ( data[0] ) )

#define SET648(val,data)                        \
    data[1] = (val) >> 32,                      \
    data[0] = (val)

#define GET648(data)                            \
    ( ( data[1] << 32 ) |                       \
      ( data[0] ) )

#endif

#define GROUP(type,size,get,set,sfx)                                    \
    Unaligned##sfx##size( type v ) { set##size( v, data ); }            \
    type operator = ( type v )     { set##size( v, data ); return v; }  \
    operator type()           { return get##size( data ); }             \
    type operator += (const type v) { set##size( get##size(data) + v, data); return *this; } \
    type operator -= (const type v) { set##size( get##size(data) - v, data); return *this; } \
    type operator <<= (const type v) { set##size( get##size(data) << v, data); return *this; } \
    type operator *= (const type v) { set##size( get##size(data) * v, data); return *this; } \
    type operator /= (const type v) { set##size( get##size(data) / v, data); return *this; } \
    type operator %= (const type v) { set##size( get##size(data) % v, data); return *this; } \
    type operator >>= (const type v) { set##size( get##size(data) >> v, data); return *this; } \
    type operator ^= (const type v) { set##size( get##size(data) ^ v, data); return *this; } \
    type operator &= (const type v) { set##size( get##size(data) & v, data); return *this; } \
    type operator |= (const type v) { set##size( get##size(data) | v, data); return *this; } \


#define MAKE_TEMPLATE(size,type,sfx)                            \
template<class BASE>                                            \
class Unaligned##sfx##size<BASE>                                \
{                                                               \
  protected:                                                    \
    type data[ size / sizeof(type) ];                           \
                                                                \
  public:                                                       \
                                                                \
    GROUP( signed char,      size, GET##sfx, SET##sfx, sfx )    \
    GROUP( short,            size, GET##sfx, SET##sfx, sfx )    \
    GROUP( int,              size, GET##sfx, SET##sfx, sfx )    \
    GROUP( wchar_t,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( long,             size, GET##sfx, SET##sfx, sfx )    \
    GROUP( __int64,          size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned char,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned short,   size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned int,     size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned long,    size, GET##sfx, SET##sfx, sfx )    \
    GROUP( unsigned __int64, size, GET##sfx, SET##sfx, sfx )    \
}

MAKE_TEMPLATE( 2, unsigned char, );
MAKE_TEMPLATE( 4, unsigned char, );
MAKE_TEMPLATE( 8, unsigned char, );
MAKE_TEMPLATE( 8, unsigned int, 64 );

template<class BASE>
class UnalignedPtr<BASE> : Unaligned4<BASE> {
public:
	UnalignedPtr<BASE>(const void * v) : Unaligned4<BASE>((int)v) { }
	void *operator = (void * v)        { SET4((int)v,data); return v; }
	const void *operator = (const void * v)        { SET4((int)v,data); return v; }
	operator BASE()              { return (BASE)GET4(data); }
};

#undef SET2
#undef SET4
#undef SET8
#undef SET648
#undef GROUP
#undef MAKE_TEMPLATE

#define MAKE_UNALIGNED_TYPE(base,size)    typedef Unaligned##size<base>   base##_UNALIGNED
#define MAKE_UNALIGNED64_TYPE(base,size)  typedef Unaligned64##size<base> base##_UNALIGNED64
#define MAKE_UNALIGNEDPTR_TYPE(base)      typedef UnalignedPtr<base> *    base##_UNALIGNEDPTR

#endif  // _MSC_VER

// Predefine some of the basic types.

MAKE_UNALIGNED_TYPE( short, 2 );
MAKE_UNALIGNED_TYPE( int, 4 );
MAKE_UNALIGNED_TYPE( long, 4 );
MAKE_UNALIGNED_TYPE( WORD, 2 );
MAKE_UNALIGNED_TYPE( DWORD, 4 );
MAKE_UNALIGNED_TYPE( USHORT, 4 );
MAKE_UNALIGNED_TYPE( SHORT, 4 );
MAKE_UNALIGNED_TYPE( __int64, 8 );
MAKE_UNALIGNED64_TYPE( __int64, 8 );

#endif __unaligned_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\caggunk.cpp ===
#include "proj.h"
#include "caggunk.h"



ULONG CAggregatedUnknown::AddRef()
{
    return _punkAgg->AddRef();
}

ULONG CAggregatedUnknown::Release()
{
    return _punkAgg->Release();
}


HRESULT CAggregatedUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    return _punkAgg->QueryInterface(riid, ppvObj);
}


HRESULT CAggregatedUnknown::CUnkInner::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
        InterlockedIncrement(&_cRef);
        return S_OK;
    }

    CAggregatedUnknown* pparent = IToClass(CAggregatedUnknown, _unkInner, this);
    return pparent->v_InternalQueryInterface(riid, ppvObj);
}

ULONG CAggregatedUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}


ULONG CAggregatedUnknown::CUnkInner::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    CAggregatedUnknown* pparent = IToClass(CAggregatedUnknown, _unkInner, this);

    if (!pparent->v_HandleDelete(&_cRef))
    {
        _cRef = 1000; // protect against cached pointers bumping us up then down

        delete pparent;
    }

    return 0;
}

CAggregatedUnknown::CAggregatedUnknown(IUnknown* punkAgg)
{
    _punkAgg = punkAgg ? punkAgg : &_unkInner;
}

CAggregatedUnknown::~CAggregatedUnknown()
{
}

//
//  Convert our controlling unknown to its canonical IUnknown *without*
//  altering the reference count on the outer object.
//
//  This is critical in order for QueryOuterInterface to work properly.
//
//  Returns NULL if something horrible went wrong.
//
//  OLE Magic:  Since objects are required also to return the canonical
//  IUnknown in response to any QI(IUnknown), it follows that the canonical
//  IUnknown remains valid so long as there are any outstanding references
//  to the object.  In other words, you can Release() the canonical IUnknown
//  and the pointer remains valid so long as you keep the object alive by
//  other means.
//
//  Believe it or not, this is a feature.  It's in the book!
//
IUnknown *CAggregatedUnknown::_GetCanonicalOuter(void)
{
    IUnknown *punkAggCanon;
    HRESULT hres = _punkAgg->QueryInterface(IID_IUnknown, (void **)&punkAggCanon);
    if (SUCCEEDED(hres)) 
    {
        punkAggCanon->Release(); // see "OLE Magic" comment above
        return punkAggCanon;
    } 
    else 
    {
        // The outer object is most likely some other shell component,
        // so let's ASSERT so whoever owns the outer component will fix it.
        ASSERT(!"The outer object's implementation of QI(IUnknown) is broken.");
        return NULL;
    }
}

void CAggregatedUnknown::_ReleaseOuterInterface(IUnknown** ppunk)
{
    ASSERT(IS_VALID_CODE_PTR(_punkAgg, IUnknown));

    IUnknown *punkAggCanon = _GetCanonicalOuter(); // non-refcounted pointer

    //
    //  SHReleaseOuterInterface can handle punkAggCanon == NULL
    //
    SHReleaseOuterInterface(punkAggCanon, ppunk);
}

HRESULT CAggregatedUnknown::_QueryOuterInterface(REFIID riid, void ** ppvOut)
{
    IUnknown *punkAggCanon = _GetCanonicalOuter(); // non-refcounted pointer
    //
    //  SHQueryOuterInterface can handle punkAggCanon == NULL.
    //
    return SHQueryOuterInterface(punkAggCanon, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\brutil.cpp ===
/*
NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 

This file is #include'd in browseui\ and shdocvw\ util.cpp. these are too small
to add an extra dependency, so they're just shared. ideally, these should move
to shlwapi or comctl32 or some lib or ...

NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
*/

#include "ccstock2.h"
#include "mluisupp.h"

STDAPI_(BOOL) IsBrowseNewProcess()
{
    return SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess"), TEXT("BrowseNewProcess"), FALSE, FALSE);
}

// Should we run browser in a new process?
STDAPI_(BOOL) IsBrowseNewProcessAndExplorer()
{
    if (GetModuleHandle(TEXT("EXPLORER.EXE")))
        return IsBrowseNewProcess();

    return FALSE;   // Not in shell process so ignore browse new process flag
}

HRESULT _NavigateFrame(IUnknown *punkFrame, LPCTSTR pszPath, BOOL fIsInternetShortcut)
{
    HRESULT hr = E_OUTOFMEMORY;
    BSTR bstr = SysAllocStringT(pszPath);

    if (bstr)
    {
        if (fIsInternetShortcut)
        {
            IOleCommandTarget *pcmdt;
            hr = IUnknown_QueryService(punkFrame, SID_SHlinkFrame, IID_PPV_ARG(IOleCommandTarget, &pcmdt));
            if (SUCCEEDED(hr))
            {
                VARIANT varShortCutPath = {0};
                VARIANT varFlag = {0};

                varFlag.vt = VT_BOOL;
                varFlag.boolVal = VARIANT_TRUE;

                varShortCutPath.vt = VT_BSTR;
                varShortCutPath.bstrVal = bstr;

                hr = pcmdt->Exec(&CGID_Explorer, SBCMDID_IESHORTCUT, 0, &varShortCutPath, &varFlag);                
                pcmdt->Release();
            }
        }
        else
        {
            IWebBrowser2 *pwb;
            hr = IUnknown_QueryService(punkFrame, SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser2, &pwb));
            if (SUCCEEDED(hr))
            {
                hr = pwb->Navigate(bstr, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                hr = pwb->put_Visible(VARIANT_TRUE);
                pwb->Release();
            }
        }
        SysFreeString(bstr);
    }
    return hr;
}

//
// Take a path or an URL and create a shorcut to navigare to it
//
STDAPI IENavigateIEProcess(LPCTSTR pszPath, BOOL fIsInternetShortcut)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        hr = _NavigateFrame(punk, pszPath, fIsInternetShortcut);
        punk->Release();
    }
    
    return hr;
}
        


// If this is an internet shortcut (.url file), we want it to
// navigate using using the file name so the frame frame
// can read data beyond out of that file. this includes frame set
// navigation and data that script on the page may have stored.

/*
    Purpose : This function takes a path to a file. if that file is a .URL we try
    to navigate with that file name. this is because .URL files have extra data stored
    in them that we want to let script on the page get to. the exec we send here
    lets the frame know the .URL file that this came from

    Parameters : file name of .URL file (maybe) : In param
    pUnk :       Pointer to Object from which you can get the IOleCommandTarget

  returns:
    TRUE    handled
    FALSE   not handled, file might not be a .URL
*/


STDAPI NavFrameWithFile(LPCTSTR pszPath, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszExt = PathFindExtension(pszPath);
    // HACK: we hard code .URL. this should be a property of the file type
    if (0 == StrCmpI(pszExt, TEXT(".url")))
    {
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
        if (IsBrowseNewProcessAndExplorer())
            hr = IENavigateIEProcess(pszPath, TRUE);
        else
#endif
            hr = _NavigateFrame(punk, pszPath, TRUE);
    }

    return hr;
}

// get the win32 file system name (path) for the item
// and optional attributes
//
// pdwAttrib may be NULL
// in/out:
//      pdwAttrib   may be NULL, attributes to query on the item

STDAPI GetPathForItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD *pdwAttrib)
{
    HRESULT hres = E_FAIL;
    DWORD dwAttrib;

    if (pdwAttrib == NULL)
    {
        pdwAttrib = &dwAttrib;
        dwAttrib = SFGAO_FILESYSTEM;
    }
    else
        *pdwAttrib |= SFGAO_FILESYSTEM;

    if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, pdwAttrib)) &&
        (*pdwAttrib & SFGAO_FILESYSTEM))
    {
        STRRET str;
        hres = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str);
        if (SUCCEEDED(hres))
            StrRetToStrN(pszPath, MAX_PATH, &str, pidl);
    }
    return hres;
}

STDAPI EditBox_TranslateAcceleratorST(LPMSG lpmsg)
{

    switch (lpmsg->message) {
    case WM_KEYUP:      // eat these (if we process corresponding WM_KEYDOWN)
    case WM_KEYDOWN:    // process these
        if (lpmsg->wParam != VK_TAB)
        {
            // all keydown messages except for the tab key should go straight to
            // the edit control -- unless the Ctrl key is down, in which case there
            // are 9 messages that should go straight to the edit control
#ifdef DEBUG
            if (lpmsg->wParam == VK_CONTROL)
                return S_FALSE;
#endif

            if (GetKeyState(VK_CONTROL) & 0x80000000)
            {
                switch (lpmsg->wParam)
                {
                case VK_RIGHT:
                case VK_LEFT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
                case VK_END:
                case VK_F4:
                case VK_INSERT:
                case VK_DELETE:
                case 'C':
                case 'X':
                case 'V':
                case 'A':
                case 'Z':
                    // these Ctrl+key messages are used by the edit control
                    // send 'em straight there
                    break;

                default:
                    return(S_FALSE);
                }
            }
            else
            {
                switch(lpmsg->wParam)
                {
                case VK_F5: // for refresh
                case VK_F6: // for cycle focus
                    return(S_FALSE);
                }
            }

            // Note that we return S_OK.
            goto TranslateDispatch;
        }
        break;


    case WM_CHAR:
TranslateDispatch:
        TranslateMessage(lpmsg);
        DispatchMessage(lpmsg);
        return(S_OK);
    }

    return S_FALSE;
}

// BUGBUG: dupe with shell32 util.cpp function
// like OLE GetClassFile(), but it only works on ProgID\CLSID type registration
// not real doc files or pattern matched files
//
STDAPI _CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid)
{
    TCHAR szProgID[80];
    DWORD cb = SIZEOF(szProgID);
    if (SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb) == ERROR_SUCCESS)
    {
        TCHAR szCLSID[80];

        StrCatBuff(szProgID, TEXT("\\CLSID"), ARRAYSIZE(szProgID));
        cb = SIZEOF(szCLSID);

        if (SHGetValue(HKEY_CLASSES_ROOT, szProgID, NULL, NULL, szCLSID, &cb) == ERROR_SUCCESS)
        {
            return GUIDFromString(szCLSID, pclsid) ? S_OK : E_FAIL;
        }
    }
    return E_FAIL;
}

#if 0 // not used yet
// IShellLink is #defined to IShellLinkA or IShellLinkW depending on compile flags,
// bug Win95 did not support IShellLinkW.  So call this function instead and you
// get the correct results regardless of what platform you are running on.
// REVIEW: In fact, we probably want these for ALL IShellLink functions...
//
LWSTDAPI IShellLink_GetPathA(IUnknown *punk, LPSTR pszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    RIPMSG(cchBuf && pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, char, cchBuf), "IShellLink_GetPathA: callre passed bad pszBuf/cchBuf");
    DEBUGWhackPathBufferA(pszBuf, cchBuf);

    if (cchBuf && pszBuf)
    {
        // In case of gross failure, NULL output buffer
        *pszBuf = 0;

        IShellLinkA * pslA;
        hres = punk->QueryInterface(IID_IShellLinkA, (void**)&pslA);
        if (SUCCEEDED(hres))
        {
            hres = pslA->GetPath(pszBuf, cchBuf, NULL, dwFlags);
            pslA->Release();
        }
        else if (FAILED(hres))
        {
#ifdef UNICODE
            IShellLinkW *pslW;
            hres = punk->QueryInterface(IID_IShellLinkW, (void**)&pslW);
            if (SUCCEEDED(hres))
            {
                WCHAR wszPath[MAX_BUF];
                LPWSTR pwszBuf = wszPath;
                UINT cch = ARRAYSIZE(wszPath);

                // Our stack buffer is too small, allocate one of the output buffer size
                if (cchBuf > cch)
                {
                    LPWSTR pwsz = LocalAlloc(LPTR, cchBuf * sizeof(WCHAR));
                    if (pwsz)
                    {
                        pwszBuf = pwsz;
                        cch = cchBuf;
                    }
                }

                hres = pslW->GetPath(pwszBuf, cch, NULL, dwFlags);
                if (SUCCEEDED(hres))
                {
                    SHUnicodeToAnsi(pwszBuf, pszBuf, cchBuf);
                }

                pslW->Release();
            }
#endif
        }
    }

    return hres;
}

LWSTDAPI IShellLink_GetPathW(IUnknown *punk, LPWSTR pwszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    RIPMSG(cchBuf && pwszBuf && IS_VALID_WRITE_BUFFER(pwszBuf, WCHAR, cchBuf), "IShellLink_GetPathW: caller passed bad pwszBuf/cchBuf");
    DEBUGWhackPathBufferW(pwszBuf, cchBuf);

    if (cchBuf && pwszBuf)
    {
        // In case of gross failure, NULL output buffer
        *pwszBuf = 0;

#ifdef UNICODE
        IShellLinkW * pslW;
        hres = punk->QueryInterface(IID_IShellLinkW, (void**)&pslW);
        if (SUCCEEDED(hres))
        {
            hres = pslW->GetPath(pszBuf, cchBuf, NULL, dwFlags);
            pslW->Release();
        }
        else if (FAILED(hres))
#endif
        {
            IShellLinkA *pslA;
            hres = punk->QueryInterface(IID_IShellLinkA, (void**)&pslA);
            if (SUCCEEDED(hres))
            {
                char szPath[MAX_BUF];
                LPSTR pszBuf = szPath;
                UINT cch = ARRAYSIZE(szPath);

                // Our stack buffer is too small, allocate one of the output buffer size
                if (cchBuf > cch)
                {
                    LPSTR psz = LocalAlloc(LPTR, cchBuf * sizeof(char));
                    if (psz)
                    {
                        pszBuf = psz;
                        cch = cchBuf;
                    }
                }

                hres = pslA->GetPath(pszBuf, cch, NULL, dwFlags);
                if (SUCCEEDED(hres))
                {
                    SHAnsiToUnicode(pszBuf, pwszBuf, cchBuf);
                }

                pslA->Release();
            }
        }
    }

    return hres;
}
#endif // 0

HRESULT IShellLinkAorW_GetPath(IShellLinkA *pslA, LPTSTR pszBuf, UINT cchBuf, 
DWORD dwFlags)
{
    HRESULT hres = E_FAIL;

// If we store the string unicode, we could be losing file information by asking
// through A version. Be unicode friendly and use the W version if it exists
//
#ifdef UNICODE
    IShellLinkW *pslW;
    hres = pslA->QueryInterface(IID_IShellLinkW, (void**)&pslW);
    if (SUCCEEDED(hres))
    {
        hres = pslW->GetPath(pszBuf, cchBuf, NULL, dwFlags);
        pslW->Release();
    }
#endif

    if (FAILED(hres))
    {
        char szBuf[MAX_URL_STRING];  // BOGUS, but this is a common size used, perhaps we should LocalAlloc...

        cchBuf = ARRAYSIZE(szBuf);

        hres = pslA->GetPath(szBuf, cchBuf, NULL, dwFlags);

        SHAnsiToTChar(szBuf, pszBuf, cchBuf);
    }

    return hres;
}

STDAPI GetLinkTargetIDList(LPCTSTR pszPath, LPTSTR pszTarget, DWORD cchTarget, LPITEMIDLIST *ppidl)
{
    IShellLinkA *psl;
    CLSID clsid;
    HRESULT hres;

    *ppidl = NULL;  // assume failure

    // BUGBUG: we really should call GetClassFile() but this could
    // slow this down a lot... so chicken out and just look in the registry

    if (FAILED(_CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IShellLinkA, (void **)&psl);
    if (SUCCEEDED(hres))
    {
        IPersistFile *ppf;
        hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
        if (SUCCEEDED(hres))
        {
            WCHAR wszPath[MAX_PATH];

            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
            hres = ppf->Load(wszPath, 0);
            if (SUCCEEDED(hres))
            {
                psl->GetIDList(ppidl);

                if (*ppidl == NULL)
                    hres = E_FAIL;  // NULL pidl is valid, but
                                    // lets not return that to clients
                if (pszTarget)
                {
                    IShellLinkAorW_GetPath(psl, pszTarget, cchTarget, 0);
                }
            }
            ppf->Release();
        }
        psl->Release();
    }

    // pszPath might == pszTarget so don't null out on entry always
    if (FAILED(hres) && pszTarget)
        *pszTarget = 0;
    return hres;
}



STDAPI_(void) PathToDisplayNameW(LPCTSTR pszPath, LPTSTR pszDisplayName, UINT cchDisplayName)
{
    SHFILEINFO sfi;
    if (SHGetFileInfo(pszPath, 0, &sfi, SIZEOF(sfi), SHGFI_DISPLAYNAME))
    {
        StrCpyN(pszDisplayName, sfi.szDisplayName, cchDisplayName);
    }
    else
    {
        StrCpyN(pszDisplayName, PathFindFileName(pszPath), cchDisplayName);
        PathRemoveExtension(pszDisplayName);
    }
}


STDAPI_(void) PathToDisplayNameA(LPSTR pszPathA, LPSTR pszDisplayNameA, int cchDisplayName)
{
    SHFILEINFOA sfi;
    if (SHGetFileInfoA(pszPathA, 0, &sfi, SIZEOF(sfi), SHGFI_DISPLAYNAME))
    {
        StrCpyNA(pszDisplayNameA, sfi.szDisplayName, cchDisplayName);
    }
    else
    {
        pszPathA = PathFindFileNameA(pszPathA);
        StrCpyNA(pszDisplayNameA, pszPathA, cchDisplayName);
        PathRemoveExtensionA(pszDisplayNameA);
    }
}

// this looks for the file descriptor format to get the display name of a data object
STDAPI DataObj_GetNameFromFileDescriptor(IDataObject *pdtobj, LPWSTR pszDisplayName, UINT cch)
{
    HRESULT hres = E_FAIL;
    STGMEDIUM mediumFGD;

    InitClipboardFormats();
    FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)DataObj_GetDataOfType(pdtobj, g_cfFileDescW, &mediumFGD);
    if (pfgd)
    {
        if (pfgd->cItems > 0)
        {
            LPFILEDESCRIPTORW pfd = &(pfgd->fgd[0]);
            SHUnicodeToTChar(pfd->cFileName, pszDisplayName, cch);
            hres = S_OK;
        }
        ReleaseStgMediumHGLOBAL(&mediumFGD);
    }
    else
    {
        FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)DataObj_GetDataOfType(pdtobj, g_cfFileDescA, &mediumFGD);
        if (pfgd)
        {
            if (pfgd->cItems > 0)
            {
                LPFILEDESCRIPTORA pfd = &(pfgd->fgd[0]);
                SHAnsiToTChar(pfd->cFileName, pszDisplayName, cch);
                hres = S_OK;
            }
            ReleaseStgMediumHGLOBAL(&mediumFGD);
        }
    }
    return hres;
}

STDAPI SHPidlFromDataObject2(IDataObject *pdtobj, LPITEMIDLIST * ppidl)
{
    HRESULT hres = E_FAIL;
    STGMEDIUM medium;

    InitClipboardFormats();
    void *pdata = DataObj_GetDataOfType(pdtobj, g_cfHIDA, &medium);
    if (pdata)
    {
        *ppidl = IDA_ILClone((LPIDA)pdata, 0);
        if (*ppidl)
            hres = S_OK;
        else
            hres = E_OUTOFMEMORY;
        ReleaseStgMediumHGLOBAL(&medium);
    }

    return hres;
}

STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl,
                           LPWSTR pszDisplayNameW, DWORD cchDisplayName)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    *ppidl = NULL;

    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        // This string is also used to store an URL in case it's an URL file
        TCHAR szPath[MAX_URL_STRING];
        hres = E_FAIL;
        if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)))
        {
            SHFILEINFO sfi;
            SHGetFileInfo(szPath, 0, &sfi, SIZEOF(sfi), SHGFI_ATTRIBUTES | SHGFI_DISPLAYNAME);

            if (pszDisplayNameW)
                SHTCharToUnicode(sfi.szDisplayName, pszDisplayNameW, MAX_PATH);

            if (sfi.dwAttributes & SFGAO_LINK)
                hres = GetLinkTargetIDList(szPath, szPath, ARRAYSIZE(szPath), ppidl);

            if (FAILED(hres))
                hres = IECreateFromPath(szPath, ppidl);
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        hres = SHPidlFromDataObject2(pdtobj, ppidl);
        if (FAILED(hres))
        {
            void *pdata = DataObj_GetDataOfType(pdtobj, g_cfURL, &medium);
            if (pdata)
            {
                LPSTR pszPath = (LPSTR)pdata;

                if (pszDisplayNameW) {
                    if (FAILED(DataObj_GetNameFromFileDescriptor(pdtobj, pszDisplayNameW, cchDisplayName))) {
                        CHAR szDisplayNameA[MAX_URL_STRING];
                        ASSERT(cchDisplayName < MAX_URL_STRING);
                        SHUnicodeToAnsi(pszDisplayNameW, szDisplayNameA, cchDisplayName);
                        PathToDisplayNameA(pszPath, szDisplayNameA, cchDisplayName);
                    }
                }
                hres = IECreateFromPathA(pszPath, ppidl);
                ReleaseStgMediumHGLOBAL(&medium);
            }
        }

    }

    return hres;
}



// BharatS - Perhaps all the stuff below here should be moved to shlwapi after beta 2 ?

typedef struct _broadcastmsgparams
{
    BOOL fSendMessage; // If true - we call SendMessageTimeout
    UINT uTimeout; // Only Matters if fSendMessage is set
    UINT uMsg;
    WPARAM wParam;
    LPARAM lParam;
} BROADCAST_MSG_PARAMS;

BOOL CALLBACK EnumShellIEWindowsProc(  
    HWND hwnd,      // handle to parent window
    LPARAM lParam   // application-defined value - this has the info needed for posting/sending the message 
)
{
    BROADCAST_MSG_PARAMS *pParams = (BROADCAST_MSG_PARAMS *)lParam;
    BOOL fRet = TRUE;

    if(IsExplorerWindow(hwnd) || IsFolderWindow(hwnd))
    {
        if(pParams->fSendMessage)
        {
            UINT  uTimeout = (pParams->uTimeout < 4000) ? pParams->uTimeout : 4000;
            LRESULT lResult;
            DWORD_PTR dwpResult;
            if (g_fRunningOnNT)
            {
                lResult = SendMessageTimeout(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam, SMTO_ABORTIFHUNG | SMTO_NORMAL, uTimeout, &dwpResult);
            }
            else
            {           
                lResult = SendMessageTimeoutA(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam, SMTO_ABORTIFHUNG | SMTO_NORMAL, uTimeout, &dwpResult);
            }
            fRet = BOOLIFY(lResult);
        }
        else
        {
            fRet = PostMessage(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam);

        }
    }
    return fRet;

}

// PostShellIEBroadcastMessage is commented out since it is not used currentl
/*

STDAPI_(LRESULT)  PostShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
    BROADCAST_MSG_PARAMS MsgParam;

    MsgParam.uMsg = uMsg;
    MsgParam.wParam = wParam;
    MsgParam.lParam = lParam;
    MsgParam.fSendMessage = FALSE;
    
    return EnumWindows((WNDENUMPROC )EnumShellIEWindowsProc, (LPARAM)&MsgParam);

}
*/

//
// We can be hung if we use sendMessage, and you can not use pointers with asynchronous
// calls such as PostMessage or SendNotifyMessage.  So we resort to using a timeout.
// This function should be used to broadcast notification messages, such as WM_SETTINGCHANGE, 
// that pass pointers. (stevepro)
//
STDAPI_(LRESULT) SendShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, UINT uTimeout)
{

    // Note that each this timeout is applied to each window that we broadcast to 

    BROADCAST_MSG_PARAMS MsgParam;

    MsgParam.uMsg = uMsg;
    MsgParam.wParam = wParam;

#ifdef UNICODE
    CHAR szSection[MAX_PATH];
    
    if (!g_fRunningOnNT && (uMsg == WM_WININICHANGE) && (0 != lParam))
    {
        SHUnicodeToAnsi((LPCWSTR)lParam, szSection, ARRAYSIZE(szSection));
        lParam = (LPARAM)szSection;
    }
#endif

    MsgParam.lParam = lParam;
    MsgParam.fSendMessage = TRUE;
    MsgParam.uTimeout = uTimeout;

    return EnumWindows((WNDENUMPROC )EnumShellIEWindowsProc, (LPARAM)&MsgParam);
}

// Return the parent psf and relative pidl given a pidl.
STDAPI IEBindToParentFolder(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild)
{
    HRESULT hres;

    //
    //  if this is a rooted pidl and it is just the root
    //  then we can bind to the target pidl of the root instead
    //
    if (ILIsRooted(pidl) && ILIsEmpty(_ILNext(pidl)))
        pidl = ILRootedFindIDList(pidl);
        
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    
    if (pidlParent)
    {
        hres = IEBindToObject(pidlParent, ppsfParent);
        ILFree(pidlParent);
    }
    else
        hres = E_OUTOFMEMORY;

    if (ppidlChild)
        *ppidlChild = ILFindLastID(pidl);

    return hres;
}

STDAPI GetDataObjectForPidl(LPCITEMIDLIST pidl, IDataObject ** ppdtobj)
{
    HRESULT hres = E_FAIL;
    if (pidl)
    {
        IShellFolder *psfParent;
        LPCITEMIDLIST pidlChild;
        hres = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
        if (SUCCEEDED(hres))
        {
            hres = psfParent->GetUIObjectOf(NULL, 1, &pidlChild, IID_IDataObject, NULL, (void**)ppdtobj);
            psfParent->Release();
        }
    }
    return hres;
}

// Is this pidl a Folder/Directory in the File System?
STDAPI_(BOOL) ILIsFileSysFolder(LPCITEMIDLIST pidl)
{
    if (!pidl)
        return FALSE;

    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_FILESYSTEM;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);
    return SUCCEEDED(hr) && ((dwAttributes & (SFGAO_FOLDER | SFGAO_FILESYSTEM)) == (SFGAO_FOLDER | SFGAO_FILESYSTEM));
}


// HACKHACK HACKHACK
// the following functions are to work around the menu
// munging that happens in the shlwapi wrappers... when we're
// manipulating menus which are tracked by the system, the
// menu munging code in our shlwapi wrappers (necessary
// for xcp plugUI) trashes them since the system doesn't
// understand munged menus... hence the work arounds below.
// note that many of these functions are copies of the shlwapi
// *WrapW functions (minus the munging).

#undef LoadMenuW

// from winuser.h
EXTERN_C WINUSERAPI HMENU WINAPI LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);

STDAPI_(HMENU)
LoadMenu_PrivateNoMungeW(HINSTANCE hInstance, LPCWSTR lpMenuName)
{
    ASSERT(HIWORD64(lpMenuName) == 0);

    if (g_fRunningOnNT)
    {
        return LoadMenuW(hInstance, lpMenuName);
    }

    return LoadMenuA(hInstance, (LPCSTR) lpMenuName);
}

#define CP_ATOM         0xFFFFFFFF          /* not a string at all */
#undef InsertMenuW

// from winuser.h
EXTERN_C WINUSERAPI BOOL WINAPI InsertMenuW(IN HMENU hMenu, IN UINT uPosition, IN UINT uFlags, IN UINT_PTR uIDNewItem, IN LPCWSTR lpNewItem);

STDAPI_(BOOL)
InsertMenu_PrivateNoMungeW(HMENU       hMenu,
                           UINT        uPosition,
                           UINT        uFlags,
                           UINT_PTR    uIDNewItem,
                           LPCWSTR     lpNewItem)
{
    if (g_fRunningOnNT)
    {
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    char szMenuItem[CCH_MENUMAX];

    SHUnicodeToAnsiCP((uFlags & MFT_NONSTRING) ? CP_ATOM : CP_ACP,
                      lpNewItem,
                      szMenuItem,
                      ARRAYSIZE(szMenuItem));

    return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, szMenuItem);
}

STDAPI_(HMENU)
LoadMenuPopup_PrivateNoMungeW(UINT id)
{
    HINSTANCE hinst;

    hinst = MLLoadShellLangResources();

    HMENU hMenuSub = NULL;
    HMENU hMenu = LoadMenu_PrivateNoMungeW(hinst, MAKEINTRESOURCEW(id));
    if (hMenu)
    {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub)
        {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }

        // note this calls the shlwapi wrapper (that handles
        // destroying munged menus) but it looks like
        // it's safe to do so.
        DestroyMenu(hMenu);
    }

    MLFreeLibrary(hinst);

    return hMenuSub;
}

// determine if a path is just a filespec (contains no path parts)
//
// REVIEW: we may want to count the # of elements, and make sure
// there are no illegal chars, but that is probably another routing
// PathIsValid()
//
// in:
//      lpszPath    path to look at
// returns:
//      TRUE        no ":" or "\" chars in this path
//      FALSE       there are path chars in there
//
//

BOOL PathIsFilePathA(LPCSTR lpszPath)
{
#ifdef UNIX
    if (lpszPath[0] == '/')
#else
    if ((lpszPath[0] == '\\') || (lpszPath[1] == ':'))
#endif
        return TRUE;

    return IsFileUrl(lpszPath);
}

//
// PrepareURLForDisplay
//
//     Decodes without stripping file:// prefix
//
STDAPI_(BOOL) PrepareURLForDisplayA(LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut)
{
    if (PathIsFilePathA(psz))
    {
        if (IsFileUrl(psz))
            return SUCCEEDED(PathCreateFromUrlA(psz, pszOut, pcchOut, 0));

        StrCpyNA(pszOut, psz, *pcchOut);
        *pcchOut = lstrlenA(pszOut);
        return TRUE;
    }


    return SUCCEEDED(UrlUnescapeA((LPSTR)psz, pszOut, pcchOut, 0));
}


#undef InsertMenuW
#undef LoadMenuW

// from w95wraps.h
#define InsertMenuW                 InsertMenuWrapW
#define LoadMenuW                   LoadMenuWrapW

STDAPI SHTitleFromPidl(LPCITEMIDLIST pidl, LPTSTR psz, DWORD cch, BOOL fFullPath)
{
    // Tries to get a system-displayable string from a pidl.
    // (On Win9x and NT4, User32 doesn't support font-linking,
    // so we can't display non-system language strings as window
    // titles or menu items.  In those cases, we call this function
    // to grab the path/URL instead, which will likely be system-
    // displayable).

    UINT uType;

    *psz = NULL;
    TCHAR szName[MAX_URL_STRING];

    if (fFullPath)
        uType = SHGDN_FORPARSING;
    else
        uType = SHGDN_NORMAL;

    uType |= SHGDN_FORADDRESSBAR; 
    DWORD dwAttrib = SFGAO_LINK;

    HRESULT hr = IEGetNameAndFlags(pidl, uType, szName, SIZECHARS(szName), &dwAttrib);
    if (SUCCEEDED(hr))
    {
        if ((uType & SHGDN_FORPARSING) && (dwAttrib & SFGAO_LINK))
        {
            // folder shortcut special case
            IShellLinkA *psl;  // Use A version for W95.
            if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IShellLinkA, &psl))))
            {
                LPITEMIDLIST pidlTarget;
                if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
                {
                    hr = IEGetNameAndFlags(pidlTarget, uType, szName, SIZECHARS(szName), NULL);
                    ILFree(pidlTarget);
                }
            }
        }
    }
    else
    {
        // didn't work, try the reverse
        uType ^= SHGDN_FORPARSING;  // flip the for parsing bit
        hr = IEGetNameAndFlags(pidl, uType, szName, SIZECHARS(szName), NULL);

        // some old namespaces get confused by all our funny bits...
        if (FAILED(hr))
        {
            hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
        }
    }

    if (SUCCEEDED(hr))
    {
        SHRemoveURLTurd(szName);

        // HTTP URLs are not escaped because they come from the
        // user or web page which is required to create correctly
        // escaped URLs.  FTP creates then via results from the
        // FTP session, so their pieces (username, password, path)
        // need to be escaped when put in URL form.  However,
        // we are going to put that URL into the Caption Bar, and
        // and we want to unescape it because it's assumed to be
        // a DBCS name.  All of this is done because unescaped URLs
        // are pretty. (NT #1272882)
        if (URL_SCHEME_FTP == GetUrlScheme(szName))
        {
            CHAR szUrlTemp[MAX_BROWSER_WINDOW_TITLE];
            CHAR szUnEscaped[MAX_BROWSER_WINDOW_TITLE];
            DWORD cchSizeTemp = ARRAYSIZE(szUnEscaped);

            // This this thunking crap is necessary.  Unescaping won't
            // gell into DBCS chars unless it's in ansi.
            SHTCharToAnsi(szName, szUrlTemp, ARRAYSIZE(szUrlTemp));
            PrepareURLForDisplayA(szUrlTemp, szUnEscaped, &cchSizeTemp);
            SHAnsiToTChar(szUnEscaped, psz, cch);
        }
        else
        {
            StrCpyN(psz, szName, cch);
        }
    }

    return hr;
}

BOOL IsSpecialUrl(LPCWSTR pchURL)
{
    UINT      uProt;
    uProt = GetUrlSchemeW(pchURL);
    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT == uProt ||
            URL_SCHEME_ABOUT == uProt);
}

//encode any incoming %1 so that people can't spoof our domain security code
HRESULT WrapSpecialUrl(BSTR * pbstrUrl)
{
    HRESULT     hr = S_OK;
    TCHAR      *pchSafeUrl = NULL;
    TCHAR      *pch;
    TCHAR       achUrl[4096];
    DWORD       dwSize;
    BSTR        bstrURL = *pbstrUrl;
    int         cSize;

    if (IsSpecialUrl(bstrURL))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // QFE 2735 (Georgi XDomain): [alanau]
        //
        // If the special URL contains an %00 sequence, then it will be converted to a Null char when
        // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
        // sequence, and display a "Permission Denied" script error.
        //
        if (StrStrW(bstrURL, L"%00"))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        // Copy the URL so we can munge it.
        //
        cSize = SysStringLen(bstrURL) + 1;
        pchSafeUrl = new TCHAR[cSize];
        if (!pchSafeUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } 
        StrCpyN(pchSafeUrl, bstrURL, cSize);

        // someone could put in a string like this:
        //     %2501 OR %252501 OR %25252501
        // which, depending on the number of decoding steps, will bypass security
        // so, just keep decoding while there are %s and the string is getting shorter
        int nPreviousLen = 0;
        while ( (nPreviousLen != lstrlen(pchSafeUrl)) && (StrChrW(pchSafeUrl, L'%')))
        {
            nPreviousLen = lstrlen(pchSafeUrl);
            int nNumPercents;
            int nNumPrevPercents = 0;

            // Reduce the URL
            //
            for (;;)
            {
                // Count the % signs.
                //
                nNumPercents = 0;

                pch = pchSafeUrl;
                while (pch = StrChrW(pch, L'%'))
                {
                    pch++;
                    nNumPercents++;
                }

                // If the number of % signs has changed, we've reduced the URL one iteration.
                //
                if (nNumPercents != nNumPrevPercents)
                {
                    // Encode the URL 
                    hr = THR(CoInternetParseUrl(pchSafeUrl, 
                        PARSE_ENCODE, 
                        0, 
                        achUrl, 
                        ARRAYSIZE(achUrl), 
                        &dwSize,
                        0));

                    StrCpyN(pchSafeUrl, achUrl, cSize);

                    nNumPrevPercents = nNumPercents;
                }
                else
                {
                    // The URL is fully reduced.  Break out of loop.
                    //
                    break;
                }
            }
        }

        // Now scan for '\1' characters.
        //
        if (StrChrW(pchSafeUrl, L'\1'))
        {
            // If there are '\1' characters, we can't guarantee the safety.  Put up "Permission Denied".
            //
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        SysFreeString(*pbstrUrl);
        *pbstrUrl = SysAllocString(pchSafeUrl);
        if (!*pbstrUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

Cleanup:
    delete [] pchSafeUrl;
    return hr;
}

HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl)
{
    HRESULT     hr = S_OK;

    if (IsSpecialUrl(pszUrl))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // QFE 2735 (Georgi XDomain): [alanau]
        //
        // If the special URL contains an %00 sequence, then it will be converted to a Null char when
        // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
        // sequence, and display a "Permission Denied" script error.
        //
        if (StrStrW(pszUrl, L"%00"))
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            // munge the url in place
            //

            // someone could put in a string like this:
            //     %2501 OR %252501 OR %25252501
            // which, depending on the number of decoding steps, will bypass security
            // so, just keep decoding while there are %s and the string is getting shorter
            int nPreviousLen = 0;
            while ( (nPreviousLen != lstrlen(pszUrl)) && (StrChrW(pszUrl, L'%')))
            {
                nPreviousLen = lstrlen(pszUrl);
                int nNumPercents;
                int nNumPrevPercents = 0;

                // Reduce the URL
                //
                for (;;)
                {
                    // Count the % signs.
                    //
                    nNumPercents = 0;

                    WCHAR *pch = pszUrl;
                    while (pch = StrChrW(pch, L'%'))
                    {
                        pch++;
                        nNumPercents++;
                    }

                    // If the number of % signs has changed, we've reduced the URL one iteration.
                    //
                    if (nNumPercents != nNumPrevPercents)
                    {
                        WCHAR szBuf[MAX_URL_STRING];
                        DWORD dwSize;

                        // Encode the URL 
                        hr = THR(CoInternetParseUrl(pszUrl, 
                            PARSE_ENCODE, 
                            0,
                            szBuf,
                            ARRAYSIZE(szBuf),
                            &dwSize,
                            0));

                        StrCpyN(pszUrl, szBuf, cchUrl);

                        nNumPrevPercents = nNumPercents;
                    }
                    else
                    {
                        // The URL is fully reduced.  Break out of loop.
                        //
                        break;
                    }
                }
            }

            // Now scan for '\1' characters.
            //
            if (StrChrW(pszUrl, L'\1'))
            {
                // If there are '\1' characters, we can't guarantee the safety.  Put up "Permission Denied".
                //
                hr = E_ACCESSDENIED;
            }
        }
    }

    return hr;
}

//
//      GetUIVersion()
//
//  returns the version of shell32
//  3 == win95 gold / NT4
//  4 == IE4 Integ / win98
//  5 == win2k
//
STDAPI_(UINT) GetUIVersion()
{
    static UINT s_uiShell32 = 0;
    if (s_uiShell32 == 0)
    {
        HINSTANCE hinst = GetModuleHandle(TEXT("SHELL32.DLL"));
        if (hinst)
        {
            DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnGetVersion && pfnGetVersion(&dllinfo) == NOERROR)
                s_uiShell32 = dllinfo.dwMajorVersion;
            else
                s_uiShell32 = 3;
        }
    }
    return s_uiShell32;
}

STDAPI GetBrowserFrameOptions(IUnknown *punkFolder, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = E_INVALIDARG;

    *pdwOptions = BFO_NONE;
    if (punkFolder)
    {
        IBrowserFrameOptions *pbfo;
        hr = punkFolder->QueryInterface(IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr))
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);
            pbfo->Release();
        }
    }

    return hr;
}

STDAPI GetBrowserFrameOptionsPidl(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = E_INVALIDARG;

    *pdwOptions = BFO_NONE;
    if (pidl)
    {
        IBrowserFrameOptions *pbfo;
        hr = IEBindToObjectEx(pidl, NULL, IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr))
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);
            pbfo->Release();
        }
    }

    return hr;
}

// Return TRUE only if all the bits in dwMask are set.
STDAPI_(BOOL) IsBrowserFrameOptionsSet(IN IShellFolder * psf, IN BROWSERFRAMEOPTIONS dwMask)
{
    BOOL fSet = FALSE;
    BROWSERFRAMEOPTIONS dwOptions = 0;

    if (SUCCEEDED(GetBrowserFrameOptions(psf, dwMask, &dwOptions)) &&
        (dwOptions == dwMask))
    {
        fSet = TRUE;
    }

    return fSet;
}


// Return TRUE only if all the bits in dwMask are set.
STDAPI_(BOOL) IsBrowserFrameOptionsPidlSet(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask)
{
    BOOL fSet = FALSE;
    BROWSERFRAMEOPTIONS dwOptions = 0;

    if (SUCCEEDED(GetBrowserFrameOptionsPidl(pidl, dwMask, &dwOptions)) &&
        (dwOptions == dwMask))
    {
        fSet = TRUE;
    }

    return fSet;
}


STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf)
{
    BOOL fIsFTPFolder = FALSE;
    CLSID clsid;

    if (psf && SUCCEEDED(IUnknown_GetClassID(psf, &clsid)))
    {
        // Is this an FTP Folder?
        if (IsEqualIID(clsid, CLSID_FtpFolder))
            fIsFTPFolder = TRUE;
        else
        {
            // Not directly, but let's see if it is an Folder Shortcut to
            // an FTP Folder
            if (IsEqualIID(clsid, CLSID_FolderShortcut))
            {
                IShellLinkA * psl = NULL;
                HRESULT hr = psf->QueryInterface(IID_IShellLinkA, (void **) &psl);

                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;

                    hr = psl->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        IShellFolder * psfTarget;

                        hr = IEBindToObject(pidl, &psfTarget);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(IUnknown_GetClassID(psfTarget, &clsid)) &&
                                IsEqualIID(clsid, CLSID_FtpFolder))
                            {
                                fIsFTPFolder = TRUE;
                            }

                            psfTarget->Release();
                        }

                        ILFree(pidl);
                    }

                    psl->Release();
                }
            }
        }
    }

    return fIsFTPFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\cnctnpt.cpp ===
//
//  CConnectionPoint
//
//  Common implementation for CConnectionPoint.
//

//
//  Since EnumConnections is called so much, we have a custom
//  enumerator for it which is faster than CStandardEnum and which
//  performs fewer memory allocations.
//

class CConnectionPointEnum : public IEnumConnections
{
public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods
    //
    STDMETHOD(Next)(ULONG ccd, LPCONNECTDATA rgcd, ULONG *pcdFetched);
    STDMETHOD(Skip)(ULONG ccd) { return Next(ccd, NULL, NULL); }
    STDMETHOD(Reset)(void) { m_iPos = 0; return S_OK; }
    STDMETHOD(Clone)(IEnumConnections **ppecOut);

    friend HRESULT CConnectionPointEnum_Create(CConnectionPoint *pcp, int iPos, IEnumConnections **pecOut);

private:
    CConnectionPointEnum(CConnectionPoint *pcp, int iPos)
    : m_cRef(1), m_pcp(pcp), m_iPos(iPos) { m_pcp->AddRef(); }

    ~CConnectionPointEnum() { m_pcp->Release(); }

    int m_cRef;                         // refcount
    CConnectionPoint *m_pcp;            // my dad
    int m_iPos;                         // enumeration state
};


//
//  When we need to grow the sink array, we grow by this many.
//
#define GROWTH      8

//
//  OLE says that zero is never a valid cookie, so our cookies are
//  the array index biased by unity.
//
#define COOKIEFROMINDEX(i)      ((i) + 1)
#define INDEXFROMCOOKIE(dw)     ((dw) - 1)


CConnectionPoint::~CConnectionPoint ()
{
    // clean up some memory stuff
    UnadviseAll();
    if (m_rgSinks)
        CoTaskMemFree(m_rgSinks);
}


HRESULT CConnectionPoint::UnadviseAll(void)
{
    if (m_rgSinks)
    {
        int x;

        for (x = 0; x < m_cSinksAlloc; x++)
        {
            ATOMICRELEASE(m_rgSinks[x]);
        }
    }

    return S_OK;
}

//
//  For backwards-compatibility with IE4, our superclass is
//  CIE4ConnectionPoint.
//
STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IsEqualIID(riid, IID_IConnectionPoint) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = SAFECAST(this, IConnectionPoint *);
        AddRef();
        return S_OK;
    }

    *ppvObjOut = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *piid)
{
    *piid = *m_piid;

    return S_OK;
}

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    return m_punk->QueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}

STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnk,DWORD *pdwCookie)
{
    HRESULT    hr;
    IUnknown **rgUnkNew;
    IUnknown  *punkTgt;
    int        i = 0;

    if (!pdwCookie)
        return E_POINTER;

    *pdwCookie = 0;

    // first, make sure everybody's got what they thinks they got

    hr = pUnk->QueryInterface(*m_piid, (LPVOID *)&punkTgt);
    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        //
        //  If we are not an IPropertyNotifySink, then we had better
        //  be derived from IDispatch.  Try to confirm.
        //
        if (m_piid != &IID_IPropertyNotifySink)
        {
            IDispatch *pdisp;
            if (SUCCEEDED(pUnk->QueryInterface(IID_IDispatch, (LPVOID *)&pdisp)))
            {
                pdisp->Release();
            }
            else
            {
                AssertMsg(0, TEXT("CConnectionPoint: IID %08x not derived from IDispatch"), m_piid->Data1);
            }
        }
#endif
    }
    else
    {
        if (m_piid != &IID_IPropertyNotifySink)
        {
            // This is against spec, but raymondc is guessing that this is done
            // for compatibility with VB or some other scripting language that
            // talks IDispatch but not necessarily the IDispatch-derived
            // thingie that we officially speak.  Since we really source
            // merely IDispatch::Invoke, we can satisfactorily accept any
            // IDispatch as a sink.
            hr = pUnk->QueryInterface(IID_IDispatch, (LPVOID*)&punkTgt);
        }
    }

    if (SUCCEEDED(hr))
    {

        // we no longer optimize the case where there is only one sink
        // because it's rarely the case any more.

        //
        //  If the table is full, then grow it.
        //
        if (m_cSinks >= m_cSinksAlloc)
        {
            //  CoTaskMemRealloc is so smart.  If you realloc from NULL, it
            //  means Alloc.  What this means for us?  No special cases!

            rgUnkNew = (IUnknown **)CoTaskMemRealloc(m_rgSinks, (m_cSinksAlloc + GROWTH) * sizeof(IUnknown *));
            if (!rgUnkNew)
            {
                punkTgt->Release();
                // GetLastError();
                return E_OUTOFMEMORY;
            }
            m_rgSinks = rgUnkNew;

            //
            //  OLE does not guarantee that the new memory is zero-initialized.
            //
            ZeroMemory(&m_rgSinks[m_cSinksAlloc], GROWTH * sizeof(IUnknown *));

            m_cSinksAlloc += GROWTH;
        }

        //
        //  Look for an empty slot.  There has to be one since we grew the
        //  table if we were full.
        //
        for (i = 0; m_rgSinks[i]; i++) {
            ASSERT(i < m_cSinksAlloc);
        }

        ASSERT(m_rgSinks[i] == NULL);   // Should've found a free slot
        m_rgSinks[i] = punkTgt;

        *pdwCookie = COOKIEFROMINDEX(i);
        m_cSinks++;

        // notify our owner that someone is connecting to us --
        // they may want to hook something up at the last minute
        //
        IConnectionPointCB* pcb;
        if (SUCCEEDED(m_punk->QueryInterface(IID_IConnectionPointCB, (LPVOID*)&pcb)))
        {
            pcb->OnAdvise(*m_piid, m_cSinks, *pdwCookie);
            pcb->Release();
        }
    }
    else
    {
        hr = CONNECT_E_CANNOTCONNECT;
    }

    return hr;
}

STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
{
    if (!dwCookie)
        return S_OK;

    int x = INDEXFROMCOOKIE(dwCookie);

    // Validate the cookie.
    if (x >= m_cSinksAlloc || m_rgSinks[x] == NULL)
        return CONNECT_E_NOCONNECTION;

    // notify our owner that someone is disconnecting from us --
    // they may want to clean up from the OnAdvise call
    // Perform the callback while the sink is still alive, in case
    // the callback wants to do some last-minute communication.
    //
    IConnectionPointCB* pcb;
    if (SUCCEEDED(m_punk->QueryInterface(IID_IConnectionPointCB, (LPVOID*)&pcb)))
    {
        pcb->OnUnadvise(*m_piid, m_cSinks - 1, dwCookie);
        pcb->Release();
    }

    // Free up the slot.  We cannot relocate any elements because that
    // would screw up the outstanding cookies.
    ATOMICRELEASE(m_rgSinks[x]);
    m_cSinks--;

    // Don't free the memory on the loss of the last sink; a new one
    // will probably show up soon.

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
STDMETHODIMP CConnectionPoint::EnumConnections(IEnumConnections **ppEnumOut)
{
#if 1
    return CConnectionPointEnum_Create(this, 0, ppEnumOut);
#else
    CONNECTDATA *rgConnectData = NULL;
    int i, cSinks;

    // CopyAndAddRefObject assumes that the IUnknown comes first
    // So does CStandardEnum
    COMPILETIME_ASSERT(FIELD_OFFSET(CONNECTDATA, pUnk) == 0);

    cSinks = 0;
    if (_HasSinks())
    {
        // allocate some memory big enough to hold all of the sinks.
        //
        // Must use GlobalAlloc because CStandardEnum uses GlobalFree.
        //
        rgConnectData = (CONNECTDATA *)GlobalAlloc(GMEM_FIXED, m_cSinks * sizeof(CONNECTDATA));
        if (!rgConnectData)
            return E_OUTOFMEMORY;

        // fill in the array
        //
        for (i = 0; i < m_cSinksAlloc; i++)
        {
            if (m_rgSinks[i])
            {
                rgConnectData[cSinks].pUnk = m_rgSinks[i];
                rgConnectData[cSinks].dwCookie = i + 1;
                cSinks++;

                // In case m_rgSinks gets out of sync with m_cSinks,
                // just stop when the array gets full.
                if (cSinks >= m_cSinks)
                {
                    break;
                }
            }
        }
        // Make sure we found all the items we should've found
        ASSERT(cSinks == m_cSinks);
    }

    // create a statndard  enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                       TRUE, cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
    if (!*ppEnumOut)
    {
        CoTaskMemFree(rgConnectData);
        return E_OUTOFMEMORY;
    }

    return S_OK;
#endif
}

//
// CConnectionPoint::DoInvokeIE4
//
// Calls all sinks' IDispatch::Invoke() with Cancel semantics.
HRESULT CConnectionPoint::DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams)
{
    return IConnectionPoint_InvokeWithCancel(this->CastToIConnectionPoint(),
                                    dispid, pdispparams, pf, ppv);
}

//
//  CConnectionPointEnum
//

HRESULT CConnectionPointEnum_Create(CConnectionPoint *pcp, int iPos, IEnumConnections **ppecOut)
{
    *ppecOut = new CConnectionPointEnum(pcp, iPos);
    return *ppecOut ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CConnectionPointEnum::QueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IsEqualIID(riid, IID_IEnumConnections) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = (IUnknown *)this;
        AddRef();
        return S_OK;
    }

    *ppvObjOut = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConnectionPointEnum::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConnectionPointEnum::Release()
{
    ULONG cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return cRef;
}

//
//  Next also doubles as Skip.  If you pass a NULL output buffer, then
//  nothing gets copied (i.e., you're a Skip).
//
STDMETHODIMP CConnectionPointEnum::Next(ULONG ccd, LPCONNECTDATA rgcd, ULONG *pcdFetched)
{
    ULONG ccdFetched = 0;

    while (ccdFetched < ccd)
    {
        //
        //  Look for the next sink or the end of the array
        //
        while (m_iPos < m_pcp->m_cSinksAlloc && m_pcp->m_rgSinks[m_iPos] == NULL)
        {
            m_iPos++;
        }

        if (m_iPos >= m_pcp->m_cSinksAlloc)
            break;

        if (rgcd)
        {
            //
            //  Copy it to the output buffer
            //
            rgcd->pUnk = m_pcp->m_rgSinks[m_iPos];
            rgcd->dwCookie = COOKIEFROMINDEX(m_iPos);
            rgcd->pUnk->AddRef();
            rgcd++;
        }
        m_iPos++;
        ccdFetched++;
    }

    if (pcdFetched)
        *pcdFetched = ccdFetched;

    return (ccdFetched < ccd) ? S_FALSE : S_OK;
}

//
//  Our clone enumerates the same CConnectionPoint from the same position.
//
STDMETHODIMP CConnectionPointEnum::Clone(IEnumConnections **ppecOut)
{
    return CConnectionPointEnum_Create(m_pcp, m_iPos, ppecOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\bands.cpp ===
#include "bands.h"

#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

//=================================================================
// Implementation of CToolBand
//=================================================================

ULONG CToolBand::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CToolBand::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CToolBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CToolBand, IDeskBand),         // IID_IDeskBand
        QITABENTMULTI(CToolBand, IOleWindow, IDeskBand),        // IID_IOleWindod
        QITABENTMULTI(CToolBand, IDockingWindow, IDeskBand),    // IID_IDockingWindow
        QITABENT(CToolBand, IInputObject),      // IID_IInputObject
        QITABENT(CToolBand, IOleCommandTarget), // IID_IOleCommandTarget
        QITABENT(CToolBand, IServiceProvider),  // IID_IServiceProvider
        QITABENT(CToolBand, IPersistStream),    // IID_IPersistStream
        QITABENTMULTI(CToolBand, IPersist, IPersistStream),     // IID_IPersist
        QITABENT(CToolBand, IObjectWithSite),   // IID_IObjectWithSite
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

//  *** IOleCommandTarget methods ***

HRESULT CToolBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return E_NOTIMPL;
}

//  *** IServiceProvider methods ***

HRESULT CToolBand::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
}

//  *** IOleWindow methods ***

HRESULT CToolBand::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;

    if (*lphwnd)
        return S_OK;

    return E_FAIL;
}

//  *** IInputObject methods ***

HRESULT CToolBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::HasFocusIO()
{
    HRESULT hres;
    HWND hwndFocus = GetFocus();

    hres = SHIsChildOrSelf(_hwnd, hwndFocus);
    ASSERT(hwndFocus != NULL || hres == S_FALSE);
    ASSERT(_hwnd != NULL || hres == S_FALSE);

    return hres;
}

HRESULT CToolBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    TraceMsg(DM_FOCUS, "ctb.uiaio(fActivate=%d) _fCanFocus=%d _hwnd=%x GF()=%x", fActivate, _fCanFocus, _hwnd, GetFocus());

    if (!_fCanFocus) {
        TraceMsg(DM_FOCUS, "ctb.uiaio: !_fCanFocus ret S_FALSE");
        return S_FALSE;
    }

    if (fActivate)
    {
        UnkOnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        SetFocus(_hwnd);
    }

    return S_OK;
}

HRESULT CToolBand::ResizeBorderDW(LPCRECT prcBorder,
                                         IUnknown* punkToolbarSite,
                                         BOOL fReserved)
{
    return S_OK;
}


HRESULT CToolBand::ShowDW(BOOL fShow)
{
    return S_OK;
}

HRESULT CToolBand::SetSite(IUnknown *punkSite)
{
    if (punkSite != _punkSite)
    {
        IUnknown_Set(&_punkSite, punkSite);
        IUnknown_GetWindow(_punkSite, &_hwndParent);
    }
    return S_OK;
}

HRESULT CToolBand::_BandInfoChanged()
{
    VARIANTARG v = {0};
    VARIANTARG* pv = NULL;
    if (_dwBandID != (DWORD)-1)
    {
        v.vt = VT_I4;
        v.lVal = _dwBandID;
        pv = &v;
    }
    else
    {
        // if this fires, fix your band's GetBandInfo to set _dwBandID.
        // o.w. it's a *big* perf loss since we refresh *all* bands rather
        // than just yours.
        // do *not* remove this ASSERT, bad perf *is* a bug.
        ASSERT(_dwBandID != (DWORD)-1);
    }
    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, pv, NULL);
}

//  *** IPersistStream methods ***

HRESULT CToolBand::IsDirty(void)
{
    return S_FALSE;     // never be dirty
}

HRESULT CToolBand::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

CToolBand::CToolBand() : _cRef(1)
{
    _dwBandID = (DWORD)-1;
    DllAddRef();
}

CToolBand::~CToolBand()
{
    ASSERT(_hwnd == NULL);      // CloseDW was called
    ASSERT(_punkSite == NULL);  // SetSite(NULL) was called

    DllRelease();
}

HRESULT CToolBand::CloseDW(DWORD dw)
{
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    
    return S_OK;
}


//=================================================================
// Implementation of CToolbarBand
//=================================================================
// Class for bands whose _hwnd is a toolbar control.  Implements
// functionality generic to all such bands (e.g. hottracking 
// behavior).
//=================================================================

HRESULT CToolbarBand::_PushChevron(BOOL bLast)
{
    if (_dwBandID == (DWORD)-1)
        return E_UNEXPECTED;

    VARIANTARG v;
    v.vt = VT_I4;
    v.lVal = bLast ? DBPC_SELECTLAST : DBPC_SELECTFIRST;

    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
}

LRESULT CToolbarBand::_OnHotItemChange(LPNMTBHOTITEM pnmtb)
{
    LRESULT lres = 0;

    if (!(pnmtb->dwFlags & (HICF_LEAVING | HICF_MOUSE)))
    {
        // check to see if new hot button is clipped.  if it is,
        // then we pop down the chevron menu.
        RECT rc;
        GetClientRect(_hwnd, &rc);

        int iButton = (int)SendMessage(_hwnd, TB_COMMANDTOINDEX, pnmtb->idNew, 0);
        DWORD dwEdge = SHIsButtonObscured(_hwnd, &rc, iButton);
        if (dwEdge)
        {
            //
            // Only pop down the menu if the button is obscured
            // along the axis of the toolbar
            //
            BOOL fVertical = (ToolBar_GetStyle(_hwnd) & CCS_VERT);

            if ((fVertical && (dwEdge & (EDGE_TOP | EDGE_BOTTOM)))
                || (!fVertical && (dwEdge & (EDGE_LEFT | EDGE_RIGHT))))
            {
                // clear hot item
                SendMessage(_hwnd, TB_SETHOTITEM, -1, 0);

                // figure out whether to highlight first or last button in dd menu
                int cButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
                BOOL bLast = (iButton == cButtons - 1);
                _PushChevron(bLast);
                lres = 1;
            }
        }
    }

    return lres;
}

LRESULT CToolbarBand::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;

    switch (pnmh->code)
    {
    case TBN_HOTITEMCHANGE:
        lres = _OnHotItemChange((LPNMTBHOTITEM)pnmh);
        break;
    }

    return lres;
}

// *** IWinEventHandler methods ***

HRESULT CToolbarBand::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_OK;

    switch (dwMsg)
    {
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_WININICHANGE:
        InvalidateRect(_hwnd, NULL, TRUE);
        _BandInfoChanged();
        break;
    }

    return hres;
}

HRESULT CToolbarBand::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    else
        return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\cwndproc.cpp ===
#include "priv.h"
#include "cwndproc.h"

#define ID_NOTIFY_SUBCLASS (DWORD)'CHN'     // CHN change notify
//
// CImpWndProc
//
LRESULT CALLBACK CImpWndProc::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (WM_NCCREATE == uMsg)
    {
        CImpWndProc* pThis = (CImpWndProc*)(((LPCREATESTRUCT)lParam)->lpCreateParams);
        if (EVAL(pThis))
        {
            pThis->_hwnd = hwnd;
            SetWindowPtr(hwnd, 0, pThis);

            // Even if pThis->vWndProc fails the create, USER will always
            // send us a WM_NCDESTROY so we always get a chance to clean up
            return pThis->v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        return FALSE;
    }
    else
    {
        CImpWndProc* pThis = (CImpWndProc*)GetWindowPtr0(hwnd);    // GetWindowLong(hwnd, 0);
        LRESULT lres;

        if (EVAL(pThis)) {
            // Always retain a ref across the v_WndProc in case
            // the window destroys itself during the callback.
            pThis->AddRef();

            lres = pThis->v_WndProc(hwnd, uMsg, wParam, lParam);

            if (uMsg == WM_NCDESTROY) {
                SetWindowPtr(hwnd, 0, NULL);
                pThis->_hwnd = NULL;
            }
            pThis->Release();
        } else {
            lres = SHDefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        return lres;
    }
}

//
// CNotifySubclassWndProc
//
UINT g_idFSNotify;        // the message SHChangeNotify sends

BOOL CNotifySubclassWndProc::_SubclassWindow(HWND hwnd)
{
    if (0 == g_idFSNotify)
    {
        g_idFSNotify = RegisterWindowMessage(TEXT("SubclassedFSNotify"));
    }

    DEBUG_CODE( _hwndSubclassed = hwnd; );

    return SetWindowSubclass(hwnd, _SubclassWndProc, ID_NOTIFY_SUBCLASS, (DWORD_PTR)this);
}

void CNotifySubclassWndProc::_UnsubclassWindow(HWND hwnd)
{
    RemoveWindowSubclass(hwnd, _SubclassWndProc, ID_NOTIFY_SUBCLASS);
}

LRESULT CNotifySubclassWndProc::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    return DefSubclassProc(hwnd, uMessage, wParam, lParam);
}

LRESULT CALLBACK CNotifySubclassWndProc::_SubclassWndProc(
                                  HWND hwnd, UINT uMessage, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CNotifySubclassWndProc* pObj = (CNotifySubclassWndProc*)dwRefData;

    if (pObj)
    {
        if (uMessage == g_idFSNotify)
        {
            LPSHChangeNotificationLock pshcnl;
            LPITEMIDLIST *ppidl;
            LONG lEvent;

            if (g_fNewNotify && (wParam || lParam))
            {
                // New style of notifications need to lock and unlock in order to free the memory...
                pshcnl = _SHChangeNotification_Lock((HANDLE)wParam, (DWORD) lParam, &ppidl, &lEvent);
                if (pshcnl)
                    pObj->OnChange(lEvent, ppidl[0], ppidl[1]);
            } else {
                lEvent = (DWORD) lParam; // process id's are 32bits even in WIN64
                ppidl = (LPITEMIDLIST*)wParam;
                pshcnl = NULL;
                if (ppidl)
                    pObj->OnChange(lEvent, ppidl[0], ppidl[1]);
            }

            if (pshcnl)
            {
                _SHChangeNotification_Unlock(pshcnl);
            }

            return 0;
        }
        else
            return pObj->_DefWindowProc(hwnd, uMessage, wParam, lParam);
    }
    else
    {
        return DefSubclassProc(hwnd, uMessage, wParam, lParam);
    }
}

void CNotifySubclassWndProc::_FlushNotifyMessages(HWND hwnd)
{
    MSG msg;

#ifdef DEBUG
        TraceMsg(TF_BAND, "ISFBand::_FlushNotifyMessages");
        ASSERT(hwnd == _hwndSubclassed);
#endif

    // This SHChangeNotify calls flushes notifications
    // via PostMessage, so I need to remove them
    // myself and process them immediately...
    //
    SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL);

    while (PeekMessage(&msg, hwnd, g_idFSNotify, g_idFSNotify, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void CNotifySubclassWndProc::_RegisterWindow(HWND hwnd, LPCITEMIDLIST pidl, long lEvents,
                                             UINT uFlags/* = SHCNRF_ShellLevel | SHCNRF_InterruptLevel*/)
{
    ASSERT(0 != g_idFSNotify);

    // We only register if there's something to listen to
    //
    if (0==_uRegister)
    {
        // Since we don't know what this pidl actually points to,
        // we have to register to listen to everything that might affect it...
        //
        _uRegister = RegisterNotify(hwnd, g_idFSNotify, pidl, lEvents, uFlags, TRUE);

#ifdef DEBUG
        TraceMsg(TF_BAND, "ISFBand::_RegisterToolbar id=%d h=%d", g_idFSNotify, _uRegister);
        ASSERT(hwnd == _hwndSubclassed);
#endif
    }
}

void CNotifySubclassWndProc::_UnregisterWindow(HWND hwnd)
{
    if (_uRegister)
    {
#ifdef DEBUG
        TraceMsg(TF_BAND, "ISFBand::_UnregisterToolbar h=%d", _uRegister);
        ASSERT(hwnd == _hwndSubclassed);
#endif
        // Avoid getting reentered...
        UINT uRegister = _uRegister;
        _uRegister = 0;
        SHChangeNotifyDeregister(uRegister);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dbgmem.cpp ===
#ifdef DEBUG

#include <dbgmem.h>

//EXTERN_C BOOL g_bUseNewLeakDetection;
BOOL          g_bRegistered = FALSE;

HINSTANCE g_hinstDBG;
#define   SHELLDBG    "ShellDBG.DLL"

STDAPI_(void) _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc);
// the following are in olestuff.cpp
STDAPI_(void) _DebugMemLeak(UINT flag, LPCTSTR pszFile, UINT iLine);
STDAPI_(void) _add_to_memlist(HMODULE hmod, void *pv, UINT nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine);
STDAPI_(void) _remove_from_memlist(void *pv);
STDAPI_(void) _remove_from_thread_memlist(DWORD dwThreadId, LPVOID pv);
STDAPI_(void) _transfer_to_thread_memlist(DWORD dwThread, LPVOID pv);
STDAPI_(UINT) _mem_thread_message(void);
STDAPI_(void) _received_for_thread_memlist(DWORD dwFlags, void * pData);
STDAPI_(void) _register_intelli_dump(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns);

STDAPI_(void) MemLeakInit(UINT wFlags, LPCTSTR pszFile, UINT iLine);
STDAPI_(void) MemLeakTerminate(DWORD dwFlags);

// should be in olestuff.cpp of each dll
STDAPI_(void) DumpLeakedMemory(PLEAKMEMINFO pmeminfo);
STDAPI_(LPWSTR) GetLeakSymbolicName(PLEAKMEMINFO pmeminfo, LPWSTR pwszBuf, int cchBuf);

static const INTELLILEAKDUMPCBFUNCTIONS c_ildcbf = {
    DumpLeakedMemory,
    GetLeakSymbolicName
};

#define DELAY_LOAD_LEAK_VOID(_fn, _ord, _args, _nargs)  \
void __stdcall _fn _args                                \
{                                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;    \
    if (g_bUseNewLeakDetection)                         \
    {                                                   \
        if (!g_bRegistered)                             \
        {                                               \
            register_intelli_dump(HINST_THISDLL, &c_ildcbf); \
            g_bRegistered = TRUE;                       \
        }                                               \
        _GetProcFromDLL(&g_hinstDBG, SHELLDBG, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    }                           \
    else                         \
        _pfn##_fn = _##_fn;       \
    if (_pfn##_fn)               \
        _pfn##_fn _nargs;        \
    return;                      \
}

#define DELAY_LOAD_LEAK_FN(_ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                            \
{                                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;    \
    if (g_bUseNewLeakDetection)                         \
    {                                                   \
        if (!g_bRegistered)                             \
        {                                               \
            register_intelli_dump(HINST_THISDLL, &c_ildcbf); \
            g_bRegistered = TRUE;                       \
        }                                               \
        _GetProcFromDLL(&g_hinstDBG, SHELLDBG, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    }                            \
    else                         \
        _pfn##_fn = _##_fn;       \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs;        \
    return (_ret)_err;                      \
}

#define _MemLeakInit _DebugMemLeak // for delay load macro to work
DELAY_LOAD_LEAK_VOID(MemLeakInit, 2, 
                     (UINT wFlags, LPCTSTR pszFile, UINT iLine), 
                     (wFlags, pszFile, iLine))

// does nothing for now because MemLeakInit is called to terminate leak detection as well
STDAPI_(void) MemLeakTerminate(DWORD dwFlags)
{
}

DELAY_LOAD_LEAK_VOID(add_to_memlist, 3, 
                     (HMODULE hmod, void *pv, UINT nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine),
                     (hmod, pv, nSize, nType, pszFile, iLine))
DELAY_LOAD_LEAK_FN(UINT, mem_thread_message, 4, (void), (), 0)
DELAY_LOAD_LEAK_VOID(received_for_thread_memlist, 5, (DWORD dwFlags, void *pData), (dwFlags, pData))
DELAY_LOAD_LEAK_VOID(remove_from_memlist, 6, (void *pv), (pv))
DELAY_LOAD_LEAK_VOID(remove_from_thread_memlist, 7, (DWORD dwThreadId, LPVOID pv), (dwThreadId, pv))
DELAY_LOAD_LEAK_VOID(transfer_to_thread_memlist, 8, (DWORD dwThreadId, LPVOID pv), (dwThreadId, pv))

//DELAY_LOAD_LEAK_VOID(register_intelli_dump, 9, (HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns), (hmod, pfns))
void register_intelli_dump(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns)
{
    static void (__stdcall *pfnregister_intelli_dump)(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns) = NULL;

    if (!pfnregister_intelli_dump)
    {
        if (g_bUseNewLeakDetection)
            _GetProcFromDLL(&g_hinstDBG, SHELLDBG, (FARPROC*)&pfnregister_intelli_dump, (LPCSTR)9);
        else
            pfnregister_intelli_dump = _register_intelli_dump;
    }

    if (pfnregister_intelli_dump)
        pfnregister_intelli_dump(hmod, pfns);
}

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\crst.cpp ===
#include "proj.h"
#include "dbutil.h"

///////
// Critical section helper stuff
//
#ifdef DEBUG
UINT g_CriticalSectionCount = 0;
DWORD g_CriticalSectionOwner = 0;
#ifdef STACKBACKTRACE
DBstkback g_CriticalSectionLastCall[4] = { 0 };
#endif


void Dll_EnterCriticalSection(CRITICAL_SECTION * pcsDll)
{
#ifdef STACKBACKTRACE
    int var0;       // *must* be 1st on frame
#endif

    EnterCriticalSection(pcsDll);
    if (g_CriticalSectionCount++ == 0)
    {
        g_CriticalSectionOwner = GetCurrentThreadId();
#ifdef STACKBACKTRACE
        int fp = (int) (1 + (int *)&var0);
        DBGetStackBack(&fp, g_CriticalSectionLastCall, ARRAYSIZE(g_CriticalSectionLastCall));
#endif
    }
}

void Dll_LeaveCriticalSection(CRITICAL_SECTION * pcsDll)
{
    if (--g_CriticalSectionCount == 0)
        g_CriticalSectionOwner = 0;
    LeaveCriticalSection(pcsDll);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\cwndproc.h ===
#ifndef _CWNDPROC_H_
#define _CWNDPROC_H_

// CImpWndProc
//
// Use this class when you want to associate a window with
// an object using a virtual wndproc.
// 
// NOTE: The window's lifetime must be encompassed by the object.
//       I.E. NO REFCOUNT IS HELD ON THE OBJECT!
//
// Messages after WM_NCCREATE up to and including WM_DESTROY
// are forwarded to v_WndProc.
//
// _hwnd is non-NULL from WM_NCCREATE up to but not during WM_DESTROY.
// (Not during because the final release may be tied to WM_DESTROY
// so we cannot reference member variables after forwarding thie message.)
//
class CImpWndProc
{
public:
    virtual ULONG __stdcall AddRef() = 0;
    virtual ULONG __stdcall Release() = 0;

protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND _hwnd;

} ;


// CNotifySubclassWndProc
//
// This class subclasses an HWND, registers for SHChangeNotify events,
// and forwards them to the inheritor's IShellChangeNotify implementation.
//
// You need one instance of this class per window you want to subclass
// and register for events against. (So if you need >1 window hooked up
// in this matter, you need to have member implementations that inherit
// from this class.)
//
class CNotifySubclassWndProc
{
public:
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;

protected:
    BOOL _SubclassWindow(HWND hwnd);
    void _UnsubclassWindow(HWND hwnd);
    void _RegisterWindow(HWND hwnd, LPCITEMIDLIST pidl, long lEvents,
                         UINT uFlags = (SHCNRF_ShellLevel | SHCNRF_InterruptLevel));
    void _UnregisterWindow(HWND hwnd);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    void _FlushNotifyMessages(HWND hwnd);

private:
    static LRESULT CALLBACK _SubclassWndProc(
                                  HWND hwnd, UINT uMessage, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    UINT        _uRegister;         // SHChangeNotify id

#ifdef DEBUG
    HWND        _hwndSubclassed;
#endif
} ;

#endif _CWNDPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\public\winineti.h ===
#if !defined(_WININETEX_)
#define _WININETEX_

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_CACHE_ENTRY_INFO_SIZE       4096
#define INTERNET_FLAG_UNUSED_1          0x00020000
#define INTERNET_FLAG_BGUPDATE          0x00000008
#define INTERNET_FLAG_UNUSED_4          0x00000004

//
// INTERNET_PREFETCH_STATUS -
//

typedef struct {

    //
    // dwStatus - status of download. See INTERNET_PREFETCH_ flags
    //

    DWORD dwStatus;

    //
    // dwSize - size of file downloaded so far
    //

    DWORD dwSize;
} INTERNET_PREFETCH_STATUS, * LPINTERNET_PREFETCH_STATUS;

//
// INTERNET_PREFETCH_STATUS - dwStatus values
//

#define INTERNET_PREFETCH_PROGRESS  0
#define INTERNET_PREFETCH_COMPLETE  1
#define INTERNET_PREFETCH_ABORTED   2

//
// INTERNET_DIAGNOSTIC_SOCKET_INFO - info about the socket in use
// (diagnostic purposes only, hence internal)
//

typedef struct {
    DWORD_PTR Socket;
    DWORD     SourcePort;
    DWORD     DestPort;
    DWORD     Flags;
} INTERNET_DIAGNOSTIC_SOCKET_INFO, * LPINTERNET_DIAGNOSTIC_SOCKET_INFO;

//
// INTERNET_DIAGNOSTIC_SOCKET_INFO.Flags definitions
//

#define IDSI_FLAG_KEEP_ALIVE    0x00000001  // set if from keep-alive pool
#define IDSI_FLAG_SECURE        0x00000002  // set if secure connection
#define IDSI_FLAG_PROXY         0x00000004  // set if using proxy
#define IDSI_FLAG_TUNNEL        0x00000008  // set if tunnelling through proxy

#define INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL      6
#define INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS  7
#define INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME   8
#define INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL    9

#define INTERNET_ONLINE_OFFLINE_INFO    INTERNET_CONNECTED_INFO
#define LPINTERNET_ONLINE_OFFLINE_INFO  LPINTERNET_CONNECTED_INFO
#define dwOfflineState                  dwConnectedState


#define ISO_FORCE_OFFLINE       ISO_FORCE_DISCONNECTED


#ifdef __WINCRYPT_H__
#ifdef ALGIDDEF
//
// INTERNET_SECURITY_INFO - contains information about certificate
// and encryption settings for a connection.
//

#define INTERNET_SECURITY_INFO_DEFINED

typedef struct {

    //
    // dwSize - Size of INTERNET_SECURITY_INFO structure.
    //

    DWORD dwSize;


    //
    // pCertificate - Cert context pointing to leaf of certificate chain.
    //

    PCCERT_CONTEXT pCertificate;

    //
    // Start SecPkgContext_ConnectionInfo
    // The following members must match those
    // of the SecPkgContext_ConnectionInfo
    // sspi structure (schnlsp.h)
    //


    //
    // dwProtocol - Protocol that this connection was made with
    //  (PCT, SSL2, SSL3, etc)
    //

    DWORD dwProtocol;

    //
    // aiCipher - Cipher that this connection as made with
    //

    ALG_ID aiCipher;

    //
    // dwCipherStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwCipherStrength;

    //
    // aiHash - Hash that this connection as made with
    //

    ALG_ID aiHash;

    //
    // dwHashStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwHashStrength;

    //
    // aiExch - Key Exchange type that this connection as made with
    //

    ALG_ID aiExch;

    //
    // dwExchStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwExchStrength;


} INTERNET_SECURITY_INFO, * LPINTERNET_SECURITY_INFO;


typedef struct {
    //
    // dwSize - size of INTERNET_SECURITY_CONNECTION_INFO
    //
    DWORD dwSize;

    // fSecure - Is this a secure connection.
    BOOL fSecure;

    //
    // dwProtocol - Protocol that this connection was made with
    //  (PCT, SSL2, SSL3, etc)
    //

    DWORD dwProtocol;

    //
    // aiCipher - Cipher that this connection as made with
    //

    ALG_ID aiCipher;

    //
    // dwCipherStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwCipherStrength;

    //
    // aiHash - Hash that this connection as made with
    //

    ALG_ID aiHash;

    //
    // dwHashStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwHashStrength;

    //
    // aiExch - Key Exchange type that this connection as made with
    //

    ALG_ID aiExch;

    //
    // dwExchStrength - Strength (in bits) that this connection
    //  was made with;
    //

    DWORD dwExchStrength;

} INTERNET_SECURITY_CONNECTION_INFO , * LPINTERNET_SECURITY_CONNECTION_INFO;


INTERNETAPI
BOOL
WINAPI
InternetAlgIdToStringA(
    IN ALG_ID                         ai,
    IN LPSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    );
INTERNETAPI
BOOL
WINAPI
InternetAlgIdToStringW(
    IN ALG_ID                         ai,
    IN LPWSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    );
#ifdef UNICODE
#define InternetAlgIdToString  InternetAlgIdToStringW
#else
#define InternetAlgIdToString  InternetAlgIdToStringA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetSecurityProtocolToStringA(
    IN DWORD                          dwProtocol,
    IN LPSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    );
INTERNETAPI
BOOL
WINAPI
InternetSecurityProtocolToStringW(
    IN DWORD                          dwProtocol,
    IN LPWSTR                        lpstr,
    IN OUT LPDWORD                    lpdwBufferLength,
    IN DWORD                          dwReserved
    );
#ifdef UNICODE
#define InternetSecurityProtocolToString  InternetSecurityProtocolToStringW
#else
#define InternetSecurityProtocolToString  InternetSecurityProtocolToStringA
#endif // !UNICODE

#endif // ALGIDDEF
#endif // __WINCRYPT_H__

#ifdef INTERNET_SECURITY_INFO_DEFINED

INTERNETAPI
DWORD
WINAPI
ShowSecurityInfo(
    IN HWND                            hWndParent,
    IN LPINTERNET_SECURITY_INFO        pSecurityInfo
    );
#endif // INTERNET_SECURITY_INFO_DEFINED



INTERNETAPI
DWORD
WINAPI
ShowX509EncodedCertificate(
    IN HWND    hWndParent,
    IN LPBYTE  lpCert,
    IN DWORD   cbCert
    );

INTERNETAPI
DWORD
WINAPI
ShowClientAuthCerts(
    IN HWND hWndParent
    );

INTERNETAPI
DWORD
WINAPI
ParseX509EncodedCertificateForListBoxEntry(
    IN LPBYTE  lpCert,
    IN DWORD   cbCert,
    OUT LPSTR  lpszListBoxEntry,
    IN LPDWORD lpdwListBoxEntry
    );

//
// This is a private API for Trident.  It displays
// security info based on a URL
//

INTERNETAPI
BOOL
WINAPI
InternetShowSecurityInfoByURLA(
    IN       LPSTR    lpszURL,
    IN       HWND     hwndParent
    );

INTERNETAPI
BOOL
WINAPI
InternetShowSecurityInfoByURLW(
    IN       LPWSTR    lpszURL,
    IN       HWND     hwndParent
    );

#ifdef UNICODE
#define InternetShowSecurityInfoByURL  InternetShowSecurityInfoByURLW
#else
#ifdef _WINX32_
#define InternetShowSecurityInfoByURL  InternetShowSecurityInfoByURLA
#else
INTERNETAPI
BOOL
WINAPI
InternetShowSecurityInfoByURL(
    IN       LPSTR    lpszURL,
    IN       HWND     hwndParent
    );
#endif // _WINX32_
#endif // !UNICODE

//Fortezza related exports. not public

// The commands that InternetFortezzaCommand supports.

typedef enum {
    FORTCMD_LOGON                   = 1,
    FORTCMD_LOGOFF                  = 2,
    FORTCMD_CHG_PERSONALITY         = 3,
} FORTCMD;

    
INTERNETAPI
BOOL
WINAPI
InternetFortezzaCommand(DWORD dwCommand, HWND hwnd, DWORD_PTR dwReserved);


typedef enum {
    FORTSTAT_INSTALLED          = 0x00000001,
    FORTSTAT_LOGGEDON           = 0x00000002,
}   FORTSTAT ; 

INTERNETAPI
BOOL
WINAPI
InternetQueryFortezzaStatus(DWORD *pdwStatus, DWORD_PTR dwReserved);



BOOLAPI
InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwReserved
    );

#define INTERNET_SERVICE_URL    0
//
// InternetConnectUrl() - a macro which allows you to specify an URL instead of
// the component parts to InternetConnect(). If any API which uses the returned
// connect handle specifies a NULL path then the URL-path part of the URL
// specified in InternetConnectUrl() will be used
//

#define InternetConnectUrl(hInternet, lpszUrl, dwFlags, dwContext) \
    InternetConnect(hInternet,                      \
                    lpszUrl,                        \
                    INTERNET_INVALID_PORT_NUMBER,   \
                    NULL,                           \
                    NULL,                           \
                    INTERNET_SERVICE_URL,           \
                    dwFlags,                        \
                    dwContext                       \
                    )

INTERNETAPI
BOOL
WINAPI
InternetWriteFileExA(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSA lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
INTERNETAPI
BOOL
WINAPI
InternetWriteFileExW(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSW lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
#ifdef UNICODE
#define InternetWriteFileEx  InternetWriteFileExW
#else
#define InternetWriteFileEx  InternetWriteFileExA
#endif // !UNICODE

#define INTERNET_OPTION_CONTEXT_VALUE_OLD       10
#define INTERNET_OPTION_NET_SPEED               61
// Pass in pointer to INTERNET_SECURITY_CONNECTION_INFO to be filled in.
#define INTERNET_OPTION_SECURITY_CONNECTION_INFO  66
#define INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO  67
#define INTERNET_OPTION_DETECT_POST_SEND        71
#define INTERNET_OPTION_DISABLE_NTLM_PREAUTH    72
#define INTERNET_LAST_OPTION_INTERNAL           INTERNET_OPTION_IGNORE_OFFLINE


#define INTERNET_OPTION_OFFLINE_TIMEOUT INTERNET_OPTION_DISCONNECTED_TIMEOUT
#define INTERNET_OPTION_LINE_STATE      INTERNET_OPTION_CONNECTED_STATE


#define INTERNET_STATE_ONLINE       INTERNET_STATE_CONNECTED
#define INTERNET_STATE_OFFLINE      INTERNET_STATE_DISCONNECTED
#define INTERNET_STATE_OFFLINE_USER INTERNET_STATE_DISCONNECTED_BY_USER
#define INTERNET_LINE_STATE_MASK    (INTERNET_STATE_ONLINE | INTERNET_STATE_OFFLINE)
#define INTERNET_BUSY_STATE_MASK    (INTERNET_STATE_IDLE | INTERNET_STATE_BUSY)



//
// the following are used with InternetSetOption(..., INTERNET_OPTION_CALLBACK_FILTER, ...)
// to filter out unrequired callbacks. INTERNET_STATUS_REQUEST_COMPLETE cannot
// be filtered out
//

#define INTERNET_STATUS_FILTER_RESOLVING        0x00000001
#define INTERNET_STATUS_FILTER_RESOLVED         0x00000002
#define INTERNET_STATUS_FILTER_CONNECTING       0x00000004
#define INTERNET_STATUS_FILTER_CONNECTED        0x00000008
#define INTERNET_STATUS_FILTER_SENDING          0x00000010
#define INTERNET_STATUS_FILTER_SENT             0x00000020
#define INTERNET_STATUS_FILTER_RECEIVING        0x00000040
#define INTERNET_STATUS_FILTER_RECEIVED         0x00000080
#define INTERNET_STATUS_FILTER_CLOSING          0x00000100
#define INTERNET_STATUS_FILTER_CLOSED           0x00000200
#define INTERNET_STATUS_FILTER_HANDLE_CREATED   0x00000400
#define INTERNET_STATUS_FILTER_HANDLE_CLOSING   0x00000800
#define INTERNET_STATUS_FILTER_PREFETCH         0x00001000
#define INTERNET_STATUS_FILTER_REDIRECT         0x00002000
#define INTERNET_STATUS_FILTER_STATE_CHANGE     0x00004000


//
// Note that adding any HTTP_QUERY_* codes here must be followed
//   by an equivlent line in wininet\http\hashgen\hashgen.cpp
//   please see that file for further information regarding
//   the addition of new HTTP headers
//


// These are not part of HTTP 1.1 yet. We will propose these to the
// HTTP extensions working group. These are required for the client-caps support
// we are doing in conjuntion with IIS.

typedef struct _INTERNET_COOKIE {
    DWORD cbSize;
    LPSTR pszName;
    LPSTR pszData;
    LPSTR pszDomain;
    LPSTR pszPath;
    FILETIME *pftExpires;
    DWORD dwFlags;
    LPSTR pszUrl;
} INTERNET_COOKIE, *PINTERNET_COOKIE;

#define INTERNET_COOKIE_IS_SECURE   0x01
#define INTERNET_COOKIE_IS_SESSION  0x02

//
// DAV Detection
//
BOOLAPI
HttpCheckDavComplianceA(
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    );
//
// DAV Detection
//
BOOLAPI
HttpCheckDavComplianceW(
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszComplianceToken,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    );
#ifdef UNICODE
#define HttpCheckDavCompliance  HttpCheckDavComplianceW
#else
#define HttpCheckDavCompliance  HttpCheckDavComplianceA
#endif // !UNICODE

BOOLAPI
HttpCheckCachedDavStatusA(
    IN LPCSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    );
BOOLAPI
HttpCheckCachedDavStatusW(
    IN LPCWSTR lpszUrl,
    IN OUT LPDWORD lpdwStatus
    );
#ifdef UNICODE
#define HttpCheckCachedDavStatus  HttpCheckCachedDavStatusW
#else
#define HttpCheckCachedDavStatus  HttpCheckCachedDavStatusA
#endif // !UNICODE

BOOLAPI
HttpCheckDavCollectionA(
    IN LPCSTR lpszUrl,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    );
BOOLAPI
HttpCheckDavCollectionW(
    IN LPCWSTR lpszUrl,
    IN OUT LPBOOL lpfFound,
    IN HWND hWnd,
    IN LPVOID lpvReserved
    );
#ifdef UNICODE
#define HttpCheckDavCollection  HttpCheckDavCollectionW
#else
#define HttpCheckDavCollection  HttpCheckDavCollectionA
#endif // !UNICODE

// DAV detection defines
#define DAV_LEVEL1_STATUS               0x00000001
#define DAV_COLLECTION_STATUS           0x00004000
#define DAV_DETECTION_REQUIRED          0x00008000
#define ERROR_INTERNET_NO_NEW_CONTAINERS        (INTERNET_ERROR_BASE + 51)

#define ERROR_INTERNET_OFFLINE  ERROR_INTERNET_DISCONNECTED

//
// internal error codes that are used to communicate specific information inside
// of Wininet but which are meaningless at the interface
//

#define INTERNET_INTERNAL_ERROR_BASE            (INTERNET_ERROR_BASE + 900)

#define ERROR_INTERNET_INTERNAL_SOCKET_ERROR    (INTERNET_INTERNAL_ERROR_BASE + 1)
#define ERROR_INTERNET_CONNECTION_AVAILABLE     (INTERNET_INTERNAL_ERROR_BASE + 2)
#define ERROR_INTERNET_NO_KNOWN_SERVERS         (INTERNET_INTERNAL_ERROR_BASE + 3)
#define ERROR_INTERNET_PING_FAILED              (INTERNET_INTERNAL_ERROR_BASE + 4)
#define ERROR_INTERNET_NO_PING_SUPPORT          (INTERNET_INTERNAL_ERROR_BASE + 5)
#define ERROR_INTERNET_CACHE_SUCCESS            (INTERNET_INTERNAL_ERROR_BASE + 6)
#define HTTP_1_1_CACHE_ENTRY            0x00000040
#define STATIC_CACHE_ENTRY              0x00000080
#define MUST_REVALIDATE_CACHE_ENTRY     0x00000100
#define PENDING_DELETE_CACHE_ENTRY      0x00400000
#define OTHER_USER_CACHE_ENTRY          0x00800000
#define POST_RESPONSE_CACHE_ENTRY       0x04000000
#define INSTALLED_CACHE_ENTRY           0x10000000
#define POST_CHECK_CACHE_ENTRY          0x20000000

// We include some entry types even if app doesn't specifically ask for them.
#define INCLUDE_BY_DEFAULT_CACHE_ENTRY \
    (HTTP_1_1_CACHE_ENTRY | MUST_REVALIDATE_CACHE_ENTRY)


//
// Well known sticky group ID
//
#define CACHEGROUP_ID_BUILTIN_STICKY       0x1000000000000007

//
// INTERNET_CACHE_CONFIG_PATH_ENTRY
//

typedef struct _INTERNET_CACHE_CONFIG_PATH_ENTRYA {
    CHAR   CachePath[MAX_PATH];
    DWORD dwCacheSize;  // in KBytes
} INTERNET_CACHE_CONFIG_PATH_ENTRYA, * LPINTERNET_CACHE_CONFIG_PATH_ENTRYA;
typedef struct _INTERNET_CACHE_CONFIG_PATH_ENTRYW {
    WCHAR  CachePath[MAX_PATH];
    DWORD dwCacheSize;  // in KBytes
} INTERNET_CACHE_CONFIG_PATH_ENTRYW, * LPINTERNET_CACHE_CONFIG_PATH_ENTRYW;
#ifdef UNICODE
typedef INTERNET_CACHE_CONFIG_PATH_ENTRYW INTERNET_CACHE_CONFIG_PATH_ENTRY;
typedef LPINTERNET_CACHE_CONFIG_PATH_ENTRYW LPINTERNET_CACHE_CONFIG_PATH_ENTRY;
#else
typedef INTERNET_CACHE_CONFIG_PATH_ENTRYA INTERNET_CACHE_CONFIG_PATH_ENTRY;
typedef LPINTERNET_CACHE_CONFIG_PATH_ENTRYA LPINTERNET_CACHE_CONFIG_PATH_ENTRY;
#endif // UNICODE

//
// INTERNET_CACHE_CONFIG_INFO
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

typedef struct _INTERNET_CACHE_CONFIG_INFOA {
    DWORD dwStructSize;
    DWORD dwContainer;
    DWORD dwQuota;
    DWORD dwReserved4;
    BOOL  fPerUser;
    DWORD dwSyncMode;
    DWORD dwNumCachePaths;
    union 
    { 
        struct 
        {
            CHAR   CachePath[MAX_PATH];
            DWORD dwCacheSize;
        };
        INTERNET_CACHE_CONFIG_PATH_ENTRYA CachePaths[ANYSIZE_ARRAY];
    };
    DWORD dwNormalUsage;
    DWORD dwExemptUsage;
} INTERNET_CACHE_CONFIG_INFOA, * LPINTERNET_CACHE_CONFIG_INFOA;
typedef struct _INTERNET_CACHE_CONFIG_INFOW {
    DWORD dwStructSize;
    DWORD dwContainer;
    DWORD dwQuota;
    DWORD dwReserved4;
    BOOL  fPerUser;
    DWORD dwSyncMode;
    DWORD dwNumCachePaths;
    union 
    { 
        struct 
        {
            WCHAR  CachePath[MAX_PATH];
            DWORD dwCacheSize;
        };
        INTERNET_CACHE_CONFIG_PATH_ENTRYW CachePaths[ANYSIZE_ARRAY];
    };
    DWORD dwNormalUsage;
    DWORD dwExemptUsage;
} INTERNET_CACHE_CONFIG_INFOW, * LPINTERNET_CACHE_CONFIG_INFOW;
#ifdef UNICODE
typedef INTERNET_CACHE_CONFIG_INFOW INTERNET_CACHE_CONFIG_INFO;
typedef LPINTERNET_CACHE_CONFIG_INFOW LPINTERNET_CACHE_CONFIG_INFO;
#else
typedef INTERNET_CACHE_CONFIG_INFOA INTERNET_CACHE_CONFIG_INFO;
typedef LPINTERNET_CACHE_CONFIG_INFOA LPINTERNET_CACHE_CONFIG_INFO;
#endif // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif


BOOLAPI
IsUrlCacheEntryExpiredA(
    IN      LPCSTR        lpszUrlName,
    IN      DWORD           dwFlags,
    IN OUT  FILETIME*       pftLastModified
    );
BOOLAPI
IsUrlCacheEntryExpiredW(
    IN      LPCWSTR        lpszUrlName,
    IN      DWORD           dwFlags,
    IN OUT  FILETIME*       pftLastModified
    );
#ifdef UNICODE
#define IsUrlCacheEntryExpired  IsUrlCacheEntryExpiredW
#else
#define IsUrlCacheEntryExpired  IsUrlCacheEntryExpiredA
#endif // !UNICODE


#define INTERNET_CACHE_FLAG_ALLOW_COLLISIONS     0x00000100
#define INTERNET_CACHE_FLAG_INSTALLED_ENTRY      0x00000200
#define INTERNET_CACHE_FLAG_ENTRY_OR_MAPPING     0x00000400
#define INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY    0x00000800
#define INTERNET_CACHE_FLAG_GET_STRUCT_ONLY      0x00001000
#define CACHE_ENTRY_MODIFY_DATA_FC  0x80000000

// Flags for CreateContainer

#define INTERNET_CACHE_CONTAINER_NOSUBDIRS (0x1)
#define INTERNET_CACHE_CONTAINER_AUTODELETE (0x2)
#define INTERNET_CACHE_CONTAINER_RESERVED1 (0x4)
#define INTERNET_CACHE_CONTAINER_NODESKTOPINIT (0x8)
#define INTERNET_CACHE_CONTAINER_MAP_ENABLED (0x10)

BOOLAPI
CreateUrlCacheContainerA(
     IN LPCSTR Name,
     IN LPCSTR lpCachePrefix,
     LPCSTR lpszCachePath,
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,
     IN DWORD dwOptions,
     IN OUT LPVOID pvBuffer,
     IN OUT LPDWORD cbBuffer
     );
BOOLAPI
CreateUrlCacheContainerW(
     IN LPCWSTR Name,
     IN LPCWSTR lpCachePrefix,
     LPCWSTR lpszCachePath,
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,
     IN DWORD dwOptions,
     IN OUT LPVOID pvBuffer,
     IN OUT LPDWORD cbBuffer
     );
#ifdef UNICODE
#define CreateUrlCacheContainer  CreateUrlCacheContainerW
#else
#define CreateUrlCacheContainer  CreateUrlCacheContainerA
#endif // !UNICODE

BOOLAPI
DeleteUrlCacheContainerA(
     IN LPCSTR Name,
     IN DWORD dwOptions
     );
BOOLAPI
DeleteUrlCacheContainerW(
     IN LPCWSTR Name,
     IN DWORD dwOptions
     );
#ifdef UNICODE
#define DeleteUrlCacheContainer  DeleteUrlCacheContainerW
#else
#define DeleteUrlCacheContainer  DeleteUrlCacheContainerA
#endif // !UNICODE

//
// INTERNET_CACHE_ENTRY_INFO -
//


typedef struct _INTERNET_CACHE_CONTAINER_INFOA {
    DWORD dwCacheVersion;       // version of software
    LPSTR   lpszName;             // embedded pointer to the container name string.
    LPSTR   lpszCachePrefix;      // embedded pointer to the container URL prefix
    LPSTR   lpszVolumeLabel;      // embedded pointer to the container volume label if any.
    LPSTR   lpszVolumeTitle;      // embedded pointer to the container volume title if any.
} INTERNET_CACHE_CONTAINER_INFOA, * LPINTERNET_CACHE_CONTAINER_INFOA;
typedef struct _INTERNET_CACHE_CONTAINER_INFOW {
    DWORD dwCacheVersion;       // version of software
    LPWSTR  lpszName;             // embedded pointer to the container name string.
    LPWSTR  lpszCachePrefix;      // embedded pointer to the container URL prefix
    LPWSTR  lpszVolumeLabel;      // embedded pointer to the container volume label if any.
    LPWSTR  lpszVolumeTitle;      // embedded pointer to the container volume title if any.
} INTERNET_CACHE_CONTAINER_INFOW, * LPINTERNET_CACHE_CONTAINER_INFOW;
#ifdef UNICODE
typedef INTERNET_CACHE_CONTAINER_INFOW INTERNET_CACHE_CONTAINER_INFO;
typedef LPINTERNET_CACHE_CONTAINER_INFOW LPINTERNET_CACHE_CONTAINER_INFO;
#else
typedef INTERNET_CACHE_CONTAINER_INFOA INTERNET_CACHE_CONTAINER_INFO;
typedef LPINTERNET_CACHE_CONTAINER_INFOA LPINTERNET_CACHE_CONTAINER_INFO;
#endif // UNICODE

//  FindFirstContainer options
#define CACHE_FIND_CONTAINER_RETURN_NOCHANGE (0x1)

INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
    );
INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheContainerW(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
    );
#ifdef UNICODE
#define FindFirstUrlCacheContainer  FindFirstUrlCacheContainerW
#else
#define FindFirstUrlCacheContainer  FindFirstUrlCacheContainerA
#endif // !UNICODE

BOOLAPI
FindNextUrlCacheContainerA(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize
    );
BOOLAPI
FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize
    );
#ifdef UNICODE
#define FindNextUrlCacheContainer  FindNextUrlCacheContainerW
#else
#define FindNextUrlCacheContainer  FindNextUrlCacheContainerA
#endif // !UNICODE


typedef enum {
    WININET_SYNC_MODE_NEVER=0,
    WININET_SYNC_MODE_ON_EXPIRY, // bogus
    WININET_SYNC_MODE_ONCE_PER_SESSION,
    WININET_SYNC_MODE_ALWAYS,
    WININET_SYNC_MODE_AUTOMATIC,
    WININET_SYNC_MODE_DEFAULT = WININET_SYNC_MODE_AUTOMATIC
} WININET_SYNC_MODE;


BOOLAPI
FreeUrlCacheSpaceA(
    IN LPCSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwFilter
    );
BOOLAPI
FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwFilter
    );
#ifdef UNICODE
#define FreeUrlCacheSpace  FreeUrlCacheSpaceW
#else
#define FreeUrlCacheSpace  FreeUrlCacheSpaceA
#endif // !UNICODE

//
// config APIs.
//

#define CACHE_CONFIG_FORCE_CLEANUP_FC           0x00000020
#define CACHE_CONFIG_DISK_CACHE_PATHS_FC        0x00000040
#define CACHE_CONFIG_SYNC_MODE_FC               0x00000080
#define CACHE_CONFIG_CONTENT_PATHS_FC           0x00000100
#define CACHE_CONFIG_COOKIES_PATHS_FC           0x00000200
#define CACHE_CONFIG_HISTORY_PATHS_FC           0x00000400
#define CACHE_CONFIG_QUOTA_FC                   0x00000800
#define CACHE_CONFIG_USER_MODE_FC               0x00001000
#define CACHE_CONFIG_CONTENT_USAGE_FC           0x00002000
#define CACHE_CONFIG_STICKY_CONTENT_USAGE_FC    0x00004000

BOOLAPI
GetUrlCacheConfigInfoA(
    OUT LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    IN DWORD dwFieldControl
    );
BOOLAPI
GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    IN DWORD dwFieldControl
    );
#ifdef UNICODE
#define GetUrlCacheConfigInfo  GetUrlCacheConfigInfoW
#else
#define GetUrlCacheConfigInfo  GetUrlCacheConfigInfoA
#endif // !UNICODE

BOOLAPI
SetUrlCacheConfigInfoA(
    IN LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
    IN DWORD dwFieldControl
    );
BOOLAPI
SetUrlCacheConfigInfoW(
    IN LPINTERNET_CACHE_CONFIG_INFOW lpCacheConfigInfo,
    IN DWORD dwFieldControl
    );
#ifdef UNICODE
#define SetUrlCacheConfigInfo  SetUrlCacheConfigInfoW
#else
#define SetUrlCacheConfigInfo  SetUrlCacheConfigInfoA
#endif // !UNICODE

INTERNETAPI
DWORD
WINAPI
RunOnceUrlCache(
        HWND    hwnd,
        HINSTANCE hinst,
        LPSTR   lpszCmd,
        int     nCmdShow);

INTERNETAPI
DWORD
WINAPI
DeleteIE3Cache(
        HWND    hwnd,
        HINSTANCE hinst,
        LPSTR   lpszCmd,
        int     nCmdShow);

BOOLAPI
UpdateUrlCacheContentPath(LPSTR szNewPath);

// Cache header data defines.

#define CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION   0
#define CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT       1
#define CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT        2


#define CACHE_HEADER_DATA_NOTIFICATION_HWND          3
#define CACHE_HEADER_DATA_NOTIFICATION_MESG          4
#define CACHE_HEADER_DATA_ROOTGROUP_OFFSET           5
#define CACHE_HEADER_DATA_GID_LOW                    6
#define CACHE_HEADER_DATA_GID_HIGH                   7

// beta logging stats
#define CACHE_HEADER_DATA_CACHE_NOT_EXPIRED         8
#define CACHE_HEADER_DATA_CACHE_NOT_MODIFIED        9
#define CACHE_HEADER_DATA_CACHE_MODIFIED            10
#define CACHE_HEADER_DATA_CACHE_RESUMED             11
#define CACHE_HEADER_DATA_CACHE_NOT_RESUMED         12
#define CACHE_HEADER_DATA_CACHE_MISS                13
#define CACHE_HEADER_DATA_DOWNLOAD_PARTIAL          14
#define CACHE_HEADER_DATA_DOWNLOAD_ABORTED          15
#define CACHE_HEADER_DATA_DOWNLOAD_CACHED           16
#define CACHE_HEADER_DATA_DOWNLOAD_NOT_CACHED       17
#define CACHE_HEADER_DATA_DOWNLOAD_NO_FILE          18
#define CACHE_HEADER_DATA_DOWNLOAD_FILE_NEEDED      19
#define CACHE_HEADER_DATA_DOWNLOAD_FILE_NOT_NEEDED  20

// retail data
#define CACHE_HEADER_DATA_NOTIFICATION_FILTER       21
#define CACHE_HEADER_DATA_ROOT_LEAK_OFFSET          22

// more beta logging stats
#define CACHE_HEADER_DATA_SYNCSTATE_IMAGE           23
#define CACHE_HEADER_DATA_SYNCSTATE_VOLATILE        24
#define CACHE_HEADER_DATA_SYNCSTATE_IMAGE_STATIC    25
#define CACHE_HEADER_DATA_SYNCSTATE_STATIC_VOLATILE 26

// retail data
#define CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET     27 // offset to group list
#define CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET         28 // offset to fixup list
#define CACHE_HEADER_DATA_ROOT_FIXUP_COUNT          29 // num of fixup items
#define CACHE_HEADER_DATA_ROOT_FIXUP_TRIGGER        30 // threshhold to fix up
#define CACHE_HEADER_DATA_HIGH_VERSION_STRING       31 // highest entry ver


#define CACHE_HEADER_DATA_LAST                      31

// options for cache notification filter
#define CACHE_NOTIFY_ADD_URL                        0x00000001
#define CACHE_NOTIFY_DELETE_URL                     0x00000002
#define CACHE_NOTIFY_UPDATE_URL                     0x00000004
#define CACHE_NOTIFY_DELETE_ALL                     0x00000008
#define CACHE_NOTIFY_URL_SET_STICKY                 0x00000010
#define CACHE_NOTIFY_URL_UNSET_STICKY               0x00000020
#define CACHE_NOTIFY_SET_ONLINE                     0x00000100
#define CACHE_NOTIFY_SET_OFFLINE                    0x00000200

#define CACHE_NOTIFY_FILTER_CHANGED                 0x10000000

BOOL
RegisterUrlCacheNotification(
    IN  HWND        hWnd,
    IN  UINT        uMsg,
    IN  GROUPID     gid,
    IN  DWORD       dwOpsFilter,
    IN  DWORD       dwReserved
    );



BOOL
GetUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData);

BOOL
SetUrlCacheHeaderData(IN DWORD nIdx, IN  DWORD  dwData);

BOOL
IncrementUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData);

BOOL
LoadUrlCacheContent();

BOOL
GetUrlCacheContainerInfoA(
    IN LPSTR lpszUrlName,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
    );
BOOL
GetUrlCacheContainerInfoW(
    IN LPWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
    );
#ifdef UNICODE
#define GetUrlCacheContainerInfo  GetUrlCacheContainerInfoW
#else
#define GetUrlCacheContainerInfo  GetUrlCacheContainerInfoA
#endif // !UNICODE


//
// Autodial APIs
//

INTERNETAPI
DWORD
WINAPI
InternetDialA(
    IN HWND     hwndParent,
    IN LPSTR   lpszConnectoid,
    IN DWORD    dwFlags,
    OUT DWORD_PTR *lpdwConnection,
    IN DWORD    dwReserved
    );

INTERNETAPI
DWORD
WINAPI
InternetDialW(
    IN HWND     hwndParent,
    IN LPWSTR   lpszConnectoid,
    IN DWORD    dwFlags,
    OUT DWORD_PTR *lpdwConnection,
    IN DWORD    dwReserved
    );

#ifdef UNICODE
#define InternetDial  InternetDialW
#else
#ifdef _WINX32_
#define InternetDial  InternetDialA
#else
INTERNETAPI
DWORD
WINAPI
InternetDial(
    IN HWND     hwndParent,
    IN LPSTR   lpszConnectoid,
    IN DWORD    dwFlags,
    OUT LPDWORD lpdwConnection,
    IN DWORD    dwReserved
    );
#endif // _WINX32_
#endif // !UNICODE

// Flags for InternetDial - must not conflict with InternetAutodial flags
//                          as they are valid here also.
#define INTERNET_DIAL_FORCE_PROMPT     0x2000
#define INTERNET_DIAL_SHOW_OFFLINE     0x4000
#define INTERNET_DIAL_UNATTENDED       0x8000

INTERNETAPI
DWORD
WINAPI
InternetHangUp(
    IN DWORD    dwConnection,
    IN DWORD    dwReserved);

#define INTERENT_GOONLINE_REFRESH 0x00000001
#define INTERENT_GOONLINE_MASK 0x00000001

INTERNETAPI
BOOL
WINAPI
InternetGoOnlineA(
    IN LPSTR   lpszURL,
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    );

INTERNETAPI
BOOL
WINAPI
InternetGoOnlineW(
    IN LPWSTR   lpszURL,
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    );

#ifdef UNICODE
#define InternetGoOnline  InternetGoOnlineW
#else
#ifdef _WINX32_
#define InternetGoOnline  InternetGoOnlineA
#else
INTERNETAPI
BOOL
WINAPI
InternetGoOnline(
    IN LPSTR   lpszURL,
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    );
#endif // _WINX32_
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetAutodial(
    IN DWORD    dwFlags,
    IN HWND     hwndParent);

// Flags for InternetAutodial
#define INTERNET_AUTODIAL_FORCE_ONLINE          1
#define INTERNET_AUTODIAL_FORCE_UNATTENDED      2
#define INTERNET_AUTODIAL_FAILIFSECURITYCHECK   4

#define INTERNET_AUTODIAL_FLAGS_MASK (INTERNET_AUTODIAL_FORCE_ONLINE | INTERNET_AUTODIAL_FORCE_UNATTENDED | INTERNET_AUTODIAL_FAILIFSECURITYCHECK)
INTERNETAPI
BOOL
WINAPI
InternetAutodialHangup(
    IN DWORD    dwReserved);

INTERNETAPI
BOOL
WINAPI
InternetGetConnectedState(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved);

INTERNETAPI
BOOL
WINAPI
InternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR  lpszConnectionName,
    IN DWORD    dwNameLen,
    IN DWORD    dwReserved
    );

INTERNETAPI
BOOL
WINAPI
InternetGetConnectedStateExW(
    OUT LPDWORD lpdwFlags,
    OUT LPWSTR  lpszConnectionName,
    IN DWORD    dwNameLen,
    IN DWORD    dwReserved
    );

#ifdef UNUSED
INTERNETAPI
BOOL
WINAPI
InternetInitializeAutoProxyDll(
    DWORD dwReserved
    );
#endif
    
#ifdef UNICODE
#define InternetGetConnectedStateEx  InternetGetConnectedStateExW
#else
#ifdef _WINX32_
#define InternetGetConnectedStateEx  InternetGetConnectedStateExA
#else
INTERNETAPI
BOOL
WINAPI
InternetGetConnectedStateEx(
    OUT LPDWORD lpdwFlags,
    IN LPSTR  lpszConnectionName,
    IN DWORD    dwNameLen,
    IN DWORD    dwReserved
    );
#endif // _WINX32_
#endif // !UNICODE

// Flags for InternetGetConnectedState and Ex
#define INTERNET_CONNECTION_MODEM           0x01
#define INTERNET_CONNECTION_LAN             0x02
#define INTERNET_CONNECTION_PROXY           0x04
#define INTERNET_CONNECTION_MODEM_BUSY      0x08  /* no longer used */
#define INTERNET_RAS_INSTALLED              0x10
#define INTERNET_CONNECTION_OFFLINE         0x20
#define INTERNET_CONNECTION_CONFIGURED      0x40

//
// Custom dial handler functions
//

// Custom dial handler prototype
typedef DWORD (CALLBACK * PFN_DIAL_HANDLER) (HWND, LPCSTR, DWORD, LPDWORD);

// Flags for custom dial handler
#define INTERNET_CUSTOMDIAL_CONNECT         0
#define INTERNET_CUSTOMDIAL_UNATTENDED      1
#define INTERNET_CUSTOMDIAL_DISCONNECT      2
#define INTERNET_CUSTOMDIAL_SHOWOFFLINE     4

// Custom dial handler supported functionality flags
#define INTERNET_CUSTOMDIAL_SAFE_FOR_UNATTENDED 1
#define INTERNET_CUSTOMDIAL_WILL_SUPPLY_STATE   2
#define INTERNET_CUSTOMDIAL_CAN_HANGUP          4

INTERNETAPI
BOOL
WINAPI
InternetSetDialStateA(
    IN LPCSTR lpszConnectoid,
    IN DWORD    dwState,
    IN DWORD    dwReserved
    );

INTERNETAPI
BOOL
WINAPI
InternetSetDialStateW(
    IN LPCWSTR lpszConnectoid,
    IN DWORD    dwState,
    IN DWORD    dwReserved
    );

#ifdef UNICODE
#define InternetSetDialState  InternetSetDialStateW
#else
#ifdef _WINX32_
#define InternetSetDialState  InternetSetDialStateA
#else
INTERNETAPI
BOOL
WINAPI
InternetSetDialState(
    IN LPCSTR lpszConnectoid,
    IN DWORD    dwState,
    IN DWORD    dwReserved
    );
#endif // _WINX32_
#endif // !UNICODE

// States for InternetSetDialState
#define INTERNET_DIALSTATE_DISCONNECTED     1

// Registry entries used by the dialing code
// All of these entries are in:
// HKCU\software\microsoft\windows\current version\internet settings

#define REGSTR_DIAL_AUTOCONNECT     "AutoConnect"


// Wininet events

#define REGSTR_PATH_INETEVENTS      "Software\\microsoft\\windows\\currentversion\\internet settings\\Events"

#define INETEVT_RAS_CONNECT         0x00000001
#define INETEVT_RAS_DISCONNECT      0x00000002
#define INETEVT_ONLINE              0x00000004
#define INETEVT_OFFLINE             0x00000008
#define INETEVT_LOGON               0x00000010
#define INETEVT_LOGOFF              0x00000020

INTERNETAPI
DWORD
WINAPI
InternetDispatchEvent(
    IN DWORD dwEvent,
    IN LPWSTR pwsEventDesc,
    IN DWORD dwEventData);



// Used by security manager.

INTERNETAPI
BOOL
WINAPI
IsHostInProxyBypassList(
    IN INTERNET_SCHEME tScheme,
    IN LPCSTR   lpszHost,
    IN DWORD    cchHost);

// Used by Shell to determine if anyone has loaded wininet yet
// Shell code calls OpenMutex with this name and if no mutex is
// obtained, we know that no copy of wininet has been loaded yet

#define WININET_STARTUP_MUTEX "WininetStartupMutex"


BOOL DoConnectoidsExist(void); // Returns TRUE if any RAS connectoids exist and FALSE otherwise

BOOL GetDiskInfoA(
    IN      PSTR pszPath, 
    IN OUT  PDWORD pdwClusterSize, 
    IN OUT  PDWORDLONG pdlAvail, 
    IN OUT  PDWORDLONG pdlTotal);

typedef BOOL (*CACHE_OPERATOR)(INTERNET_CACHE_ENTRY_INFO* pcei, PDWORD pcbcei, PVOID pOpData);

BOOL PerformOperationOverUrlCacheA(
    IN     PCSTR     pszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    PVOID     pReserved1,
    IN OUT PDWORD    pdwReserved2,
    IN     PVOID     pReserved3,
    IN       CACHE_OPERATOR op, 
    IN OUT PVOID     pOperatorData
    );

BOOL IsProfilesCapable();



//  in cookimp.cxx and cookexp.cxx
BOOL ImportCookieFileA( IN LPCSTR szFilename );
//  in cookimp.cxx and cookexp.cxx
BOOL ImportCookieFileW( IN LPCWSTR szFilename );
#ifdef UNICODE
#define ImportCookieFile  ImportCookieFileW
#else
#define ImportCookieFile  ImportCookieFileA
#endif // !UNICODE
BOOL ExportCookieFileA( IN LPCSTR szFilename, BOOL fAppend);
BOOL ExportCookieFileW( IN LPCWSTR szFilename, BOOL fAppend);
#ifdef UNICODE
#define ExportCookieFile  ExportCookieFileW
#else
#define ExportCookieFile  ExportCookieFileA
#endif // !UNICODE


#if defined(__cplusplus)
}
#endif

#endif // !define(_WININETEX_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dbutil.h ===
#ifndef _DBUTIL_H_
//***   dbutil.h -- debug helper routines
//

// dbutil.cpp
struct DBstkback {
    int fp;     // frame ptr
    int ret;    // return addr
};

int DBGetStackBack(int *pfp, struct DBstkback *pstkback, int nstkback);

// dump.c
// ...

#define _DBUTIL_H_
#endif // _DBUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dbutil.cpp ===
//***   dbutil.cpp -- debug helpers
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/dbutil.cpp"

#ifdef DEBUG // {

#if ( _X86_)

// warning: these macros assume we have an ebp-linked chain.  for debug we do.
#define BP_GETOLDBP(pbp)    (*((int *)(pbp) + 0))
#define BP_GETRET(pbp)      (*((int *)(pbp) + 1))

//***   DBGetStackBack -- walk stack frame
// #if 0 w/ sanity checks #endif
// ENTRY/EXIT
//  pfp         INOUT ptr to frame ptr (IN:starting, OUT:ending)
//  pstkback    OUT:fp/ret pairs, IN:optional size/addr pairs for sanity check
//  nstkback    ARRAYSIZE(pstckback)
//  #if 0
//  ncheck      # of IN pstkback size/addr sanity-check pairs
//  #endif
//  n           (return) # of frames successfully walked
// DESCRIPTION
//  fills in OUT pstckback w/ backtrace info for nstckback frames.
//  #if 0
//  if ncheck > 0, makes sure that initial backtrace entries are in the
//  range of the function specified by the IN size/addr pairs in pstkback.
//  #endif
// NOTES
//  BUGBUG not sure if we return the right pfp' value (untested)
int DBGetStackBack(int *pfp, struct DBstkback *pstkback, int nstkback /*,int nchk*/)
{
    int fp = *pfp;
    int ret;
    int i = 0;

    __try {
        for (; i < nstkback; i++, pstkback++) {
            ret = BP_GETRET(fp);
#if 0
            if (i < ncheck && pstkback->ret != 0) {
                ASSERT(pstkback->fp == 0 || pstkback->fp == -1 || pstkback->fp <= 512);
                if (!(pstkback->ret <= ret && ret <= pstkback->ret + pstkback->fp)) {
                    // constraint violated
                    break;
                }
            }
#endif
            fp = BP_GETOLDBP(fp);
            pstkback->ret = ret;
            pstkback->fp = fp;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        TraceMsg(TF_ALWAYS, "atm: GPF");
        // just use last 'ret' we had
    }

    *pfp = fp;
    return i;
}

#endif
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\debug.c ===
//
// Debug squirty functions
//

#ifdef UNIX
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shellib"
#define SZ_MODULE           "SHELLIB"
#endif

#include "proj.h"
#pragma  hdrstop
#include "shellp.h"

#include <platform.h> // LINE_SEPARATOR_STR and friends
#include <winbase.h> // for GetModuleFileNameA


#define DM_DEBUG              0

BOOL UnicodeFromAnsi(LPWSTR *, LPCSTR, LPWSTR, int);

#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];
HANDLE g_hDebugOutputFile = INVALID_HANDLE_VALUE;


void ShellDebugAppendToDebugFileA(LPCSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbWrite = lstrlenA(pszOutputString);
        WriteFile(g_hDebugOutputFile, pszOutputString, cbWrite, &cbWrite, NULL);
    }
}

void ShellDebugAppendToDebugFileW(LPCWSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        char szBuf[500];

        DWORD cbWrite = WideCharToMultiByte(CP_ACP, 0, pszOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        WriteFile(g_hDebugOutputFile, szBuf, cbWrite, &cbWrite, NULL);
    }
}

#if 1 // Looking at the assertW stuff, it delegates already to assertA -- I'm not sure
      // why I really need these wrappers!  (What was broken on my build?  I don't know,
      // but obviously the stuff below was half baked -- there are still problems.)
      // So I'm removing this for now so as to not bother anyone else...  [mikesh]
      //
      // Fixed a few problems and it worked for me. (edwardp)
      //
//
// We cannot link to shlwapi, because comctl32 cannot link to shlwapi.
// Duplicate some functions here so unicode stuff can run on Win95 platforms.
//
VOID MyOutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    if (staticIsOS(OS_NT))
    {
        OutputDebugStringW(lpOutputString);
        ShellDebugAppendToDebugFileW(lpOutputString);
    }
    else
    {
        char szBuf[500];

        WideCharToMultiByte(CP_ACP, 0, lpOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        OutputDebugStringA(szBuf);
        ShellDebugAppendToDebugFileA(szBuf);
    }
}
#define OutputDebugStringW MyOutputDebugStringWrapW

VOID MyOutputDebugStringWrapA(LPCSTR lpOutputString)
{
    OutputDebugStringA(lpOutputString);
    ShellDebugAppendToDebugFileA(lpOutputString);
}

#define OutputDebugStringA MyOutputDebugStringWrapA

LPWSTR MyCharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}
#define CharPrevW MyCharPrevWrapW

int MywvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist)
{
    if (staticIsOS(OS_NT))
    {
        return wvsprintfW(pwszOut, pwszFormat, arglist);
    }
    else
    {
        char szFormat[500];
        char szOut[1024+40]; // this is how big our ach buffers are
        int iRet;

        WideCharToMultiByte(CP_ACP, 0, pwszFormat, -1, szFormat, ARRAYSIZE(szFormat), NULL, NULL);

        iRet = wvsprintfA(szOut, szFormat, arglist);

        MultiByteToWideChar(CP_ACP, 0, szOut, -1, pwszOut, 1024+40);

        return iRet;
    }
}

#define wvsprintfW MywvsprintfWrapW

int MywsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    int iRet;
    
    va_list ArgList;
    va_start(ArgList, pwszFormat);

    iRet = MywvsprintfWrapW(pwszOut, pwszFormat, ArgList);

    va_end(ArgList);

    return iRet;
}
#define wsprintfW MywsprintfWrapW

LPWSTR lstrcpyWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    while((*pszDst++ = *pszSrc++));

    return pszDst;
}
#define lstrcpyW lstrcpyWrapW

LPWSTR lstrcatWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return lstrcpyWrapW(pszDst + lstrlenW(pszDst), pszSrc);
}
#define lstrcatW lstrcatWrapW

#endif 


/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

EXTERN_C g_bUseNewLeakDetection = FALSE;

DWORD g_dwDumpFlags     = 0;        // DF_*

#ifdef FULL_DEBUG
DWORD g_dwTraceFlags    = TF_ERROR | TF_WARNING;     // TF_*
#ifndef BREAK_ON_ASSERTS
#define BREAK_ON_ASSERTS
#endif
#else
DWORD g_dwTraceFlags    = TF_ERROR;  // TF_*
#endif

#ifdef BREAK_ON_ASSERTS
DWORD g_dwBreakFlags    = BF_ASSERT;// BF_*
#else
DWORD g_dwBreakFlags    = 0;        // BF_*
#endif

DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


static CHAR const FAR c_szNewline[] = LINE_SEPARATOR_STR;   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW(LINE_SEPARATOR_STR);

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];

extern CHAR const FAR c_szRip[];
extern CHAR const FAR c_szRipNoFn[];
extern CHAR const FAR c_szRipMsg[];
extern WCHAR const FAR c_wszRip[];
extern WCHAR const FAR c_wszRipNoFn[];


/*-------------------------------------------------------------------------
Purpose: Adds one of the following prefix strings to pszBuf:
           "t   MODULE  "
           "err MODULE  "
           "wrn MODULE  "

         Returns the count of characters written.
*/
int
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  DWORD dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyA(pszBuf, c_szTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyA(pszBuf, c_szWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyA(pszBuf, c_szErrorDbg);
    else
        lstrcpyA(pszBuf, c_szTrace);
    return lstrlenA(pszBuf);
}


int
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  DWORD  dwFlags)
{
    if (TF_ALWAYS == dwFlags)
        lstrcpyW(pszBuf, c_wszTrace);
    else if (IsFlagSet(dwFlags, TF_WARNING))
        lstrcpyW(pszBuf, c_wszWarningDbg);
    else if (IsFlagSet(dwFlags, TF_ERROR))
        lstrcpyW(pszBuf, c_wszErrorDbg);
    else
        lstrcpyW(pszBuf, c_wszTrace);
    return lstrlenW(pszBuf);
}


static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if this process is a primary shell process.
*/
BOOL _IsShellProcess()
{
    CHAR szModuleName[MAX_PATH];
    
    if (GetModuleFileNameA(NULL, szModuleName, sizeof(CHAR) * MAX_PATH) > 0 )
    {                      
        if (StrStrIA(szModuleName, "explorer.exe") || 
            StrStrIA(szModuleName, "iexplore.exe") ||
            StrStrIA(szModuleName, "rundll32.exe") || 
            StrStrIA(szModuleName, "welcome.exe") ||
            StrStrIA(szModuleName, "mshtmpad.exe"))
        {
            // yes, the exe is a shell one
            return TRUE;
        }
    }

    // not a normal shell executable
    return FALSE;
}


// BUGBUG (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        wvsprintfA(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
WINCAPI 
_DebugMsgA(
    DWORD flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfA(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    DWORD flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfW(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                        // ASSERT
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

*/
BOOL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[1024];    // Some callers use more than 256

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellRipA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szRipNoFn, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
            
            // MSDEV USERS:  This is not the real RIP.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

*/
BOOL
CcshellRipW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  
    // We can get this if we get an assert in some of the W functions in 
    // shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellRipA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszRipNoFn, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

BOOL
WINCAPI 
CcshellRipMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        OutputDebugStringA(c_szRipMsg);

        va_start(vArgs, pszMsg);
        wvsprintfA(ach, pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

BOOL
WINCAPI 
CcshellRipMsgW(
    BOOL f, 
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        LPWSTR pwsz;
        WCHAR wszBuf[128];
        OutputDebugStringA(c_szRipMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        ach[0] = L'\0';     // In case this fails
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            va_start(vArgs, pszMsg);
            wvsprintfW(ach, pwsz, vArgs);
            va_end(vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        OutputDebugStringW(ach);
        OutputDebugStringA(c_szNewline);

        if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellDebugMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceW(LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_dwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringW(ach, TF_ATL);
        lstrcatW(ach, L"(ATL) ");
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);
        wvsprintfW(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringW(ach);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellFuncMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfW(ach, L"%s %s", c_wszTrace, g_wszIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
*/
void
CDECL
CcshellDebugMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_dwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceA(LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_dwTraceFlags & TF_ATL)
    {
        int cch;

        SetPrefixStringA(ach, TF_ATL);
        lstrcatA(ach, "(ATL) ");
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
*/
void
CDECL
CcshellFuncMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_dwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        wsprintfA(ach, "%s %s", c_szTrace, g_szIndentLeader);
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if hrTest is a failure code.
*/
HRESULT 
TraceHR(
    HRESULT hrTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING &&
        FAILED(hrTest))
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "THR: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, hrTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return hrTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if bTest is false.
*/
BOOL 
TraceBool(
    BOOL bTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && !bTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TBOOL: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!
        }
    }
    return bTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if iTest is -1.
*/
int 
TraceInt(
    int iTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && -1 == iTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TINT: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!
        }
    }
    return iTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if pvTest is NULL.
*/
LPVOID 
TracePtr(
    LPVOID pvTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING && NULL == pvTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TPTR: Failure of \"%s\" at %s, line %d", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!
        }
    }
    return pvTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if dwTest is a Win32 failure code.
*/
DWORD  
TraceWin32(
    DWORD dwTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_dwTraceFlags & TF_WARNING &&
        ERROR_SUCCESS != dwTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, TF_WARNING);
        wsprintfA(&ach[cch], "TW32: Failure of \"%s\" at %s, line %d (%#08lx)", 
                   pszExpr, _PathFindFileNameA(pszFile), iLine, dwTest);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return dwTest;
}



//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    Assert(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif


#ifdef UNICODE

/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
static
BOOL
MyAnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            Assert(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char wrapper for StrToIntExA.

Returns: see StrToIntExA
*/
static
BOOL
MyStrToIntExW(
    LPCWSTR   pwszString,
    DWORD     dwFlags,          // STIF_ bitfield
    int FAR * piRet)
    {
    // Most strings will simply use this temporary buffer, but AnsiFromUnicode
    // will allocate a buffer if the supplied string is bigger.
    CHAR szBuf[MAX_PATH];

    LPSTR pszString;
    BOOL bRet = MyAnsiFromUnicode(&pszString, pwszString, szBuf, SIZECHARS(szBuf));

    if (bRet)
        {
        bRet = MyStrToIntExA(pszString, dwFlags, piRet);
        MyAnsiFromUnicode(&pszString, NULL, szBuf, 0);
        }
    return bRet;
    }
#endif // UNICODE


#ifdef UNICODE
#define MyStrToIntEx        MyStrToIntExW
#else
#define MyStrToIntEx        MyStrToIntExA
#endif



/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_dwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    int val;

    // BUGBUG (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwTraceFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwTraceFlags = 3; // default to TF_ERROR and TF_WARNING trace messages
#endif

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyTraceFlags, g_dwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwBreakFlags = 5; // default to break on ASSERT and TF_ERROR
#endif

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    // Are we using the new leak detection from shelldbg.dll?
    GetPrivateProfileStringA("ShellDbg",
                            "NewLeakDetection",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_bUseNewLeakDetection = BOOLIFY(val);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "DebugOutputFile",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);
    if (szRHS != TEXT('\0'))
    {
        g_hDebugOutputFile = CreateFileA(szRHS, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    return TRUE;
    }

// Function to call in allocspy.dll (GetShellMallocSpy)
typedef BOOL (__stdcall *pfnGSMS) (IShellMallocSpy **ppout);

STDAPI_(void) IMSAddToList(BOOL bAdd, void*pv, DWORD cb)
{
    static BOOL bDontTry=FALSE;
    static IShellMallocSpy *pms=NULL;

    if (!bDontTry && pms == NULL)
    {
        pfnGSMS pfnGetShellMallocSpy;
        HMODULE hmod;

        bDontTry = TRUE; // assume failure
        if (hmod = LoadLibraryA("ALLOCSPY.DLL"))
        {
            pfnGetShellMallocSpy = (pfnGSMS) GetProcAddress(hmod, "GetShellMallocSpy");

            pfnGetShellMallocSpy(&pms);
        }
    }
    if (bDontTry)
        return;

    if (bAdd)
        pms->lpVtbl->AddToList(pms, pv, cb);
    else
        pms->lpVtbl->RemoveFromList(pms, pv);
}


#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    int val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF 


#ifdef DEBUG

// turn on path whacking for full-debug builds
#ifdef FULL_DEBUG
static BOOL g_fWhackPathBuffers = TRUE;
#else
static BOOL g_fWhackPathBuffers = FALSE;
#endif

void DEBUGWhackPathBufferA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch))
        {
            FillMemory(psz, cch * sizeof(char), 0xFE);
        }
    }
}

void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch))
        {
            FillMemory(psz, cch * sizeof(WCHAR), 0xFE);
        }
    }
}

void DEBUGWhackPathStringA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch) && IS_VALID_STRING_PTRA(psz, -1))
        {
            UINT len = lstrlenA(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringA: caller of caller passed strange Path string (strlen > buffer size)");
            }
            else
            {
                FillMemory(psz+len+1, (cch-len-1) * sizeof(char), 0xFE);
            }
        }
    }
}

void DEBUGWhackPathStringW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch) && IS_VALID_STRING_PTRW(psz, -1))
        {
            UINT len = lstrlenW(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringW: caller of caller passed strange Path string (strlen > buffer size)");
            }
            else
            {
                FillMemory(psz+len+1, (cch-len-1) * sizeof(WCHAR), 0xFE);
            }
        }
    }
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dllver.cpp ===
//
//  This is a separate file so the dependency on c_dllver is pulled
//  in only if the application actually calls CCDllGetVersion.
//

#include "proj.h"

//
//  Common worker function for DllGetVersion.  This means we can add
//  new DLLVERSIONINFO2, 3, 4... structures and have to fix only one
//  function. See ccstock.h for description of usage.
//

extern "C" const DLLVERSIONINFO2 c_dllver;

STDAPI CCDllGetVersion(IN OUT DLLVERSIONINFO * pinfo)
{
    HRESULT hres = E_INVALIDARG;

    if (!IsBadWritePtr(pinfo, SIZEOF(*pinfo)))
    {
        if (pinfo->cbSize == sizeof(DLLVERSIONINFO) ||
            pinfo->cbSize == sizeof(DLLVERSIONINFO2))
        {
            CopyMemory((LPBYTE)pinfo     + sizeof(pinfo->cbSize),
                       (LPBYTE)&c_dllver + sizeof(pinfo->cbSize),
                       pinfo->cbSize     - sizeof(pinfo->cbSize));
            hres = S_OK;
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dllload.c ===
// You are expected to #include this file from your private dllload.c.
//

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_VOID_ORD
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID
//
//
// Use DELAY_LOAD_IE_* for APIs that come from BrowseUI.  This used
// to be important when BrowseUI was in the IEXPLORE directory, but
// now it's in the System directory so the difference is pretty
// meaningless.
//
// Use DELAY_LOAD_OCX_* for APIs that come from OCXs and not DLLs.
//

/**********************************************************************/

#ifdef DEBUG

void _DumpLoading(LPTSTR pszDLL, LPTSTR pszFunc)
{
#ifdef DF_DELAYLOADDLL
    if (g_dwDumpFlags & DF_DELAYLOADDLL)
    {
        TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, pszFunc);
    }
#endif
}

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_DumpLoading(TEXT(#_dll) TEXT(".") TEXT(#_ext), pszfn), \
                        _hmod = LoadLibraryA(#_dll "." #_ext)))

#else

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_hmod = LoadLibraryA(#_dll "." #_ext)))

#endif  // DEBUG


/**********************************************************************/

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (!IS_INTRESOURCE(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wsprintfA(szProcD, "(ordinal %d)", LOWORD((DWORD_PTR)pszProc));
    }
#endif
    // If it's already loaded, return.
    if (*ppfn) {
        return;
    }

    if (*phmod == NULL) {
#ifdef DEBUG
#ifdef DF_DELAYLOADDLL
        if (g_dwDumpFlags & DF_DELAYLOADDLL)
        {
            TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, szProcD);
        }
#endif
        if (g_dwBreakFlags & 0x00000080)
        {
            DebugBreak();
        }
#endif
        *phmod = LoadLibraryA(pszDLL);
#ifdef UNIX
        if (*phmod == NULL) {
           if (lstrcmpiA(pszDLL, "inetcpl.dll") == 0) {
               *phmod = LoadLibraryA("inetcpl.cpl");
           }
        }
#endif
        if (*phmod == NULL) {
            return;
        }
    }

#if defined(DEBUG) && defined(DF_DELAYLOADDLL)
    if (g_dwDumpFlags & DF_DELAYLOADDLL) {
        TraceMsg(TF_ALWAYS, "DLLLOAD: GetProc'ing %s from %s for the first time",
             pszDLL, szProcD);
    }
#endif
    *ppfn = GetProcAddress(*phmod, pszProc);
}

#if defined(DEBUG) && defined(BROWSEUI_IN_IEXPLORE_DIRECTORY)
void _GetProcFromSystemDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{

#ifdef UNIX
    if (lstrcmpiA(pszDLL, "inetcpl.dll") == 0) {
        _GetProcFromDLL(phmod, "inetcpl.cpl", ppfn, pszProc);
        return;
    }
#endif

    // You must use DELAY_LOAD_IE for BROWSEUI since BROWSEUI lives in the
    // IE directory, not the System directory.
    if (lstrcmpiA(pszDLL, "BROWSEUI.DLL") == 0) {
        ASSERT(!"Somebody used DELAY_LOAD instead of DELAY_LOAD_IE on BROWSEUI");
    }
    _GetProcFromDLL(phmod, pszDLL, ppfn, pszProc);
}
#else
#define _GetProcFromSystemDLL           _GetProcFromDLL
#endif

// NOTE: this takes two parameters that are the function name. the First (_fn) is the name that
// NOTE: the function will be called in this DLL and the other (_fni) is the
// NOTE: name of the function we will GetProcAddress. This helps get around functions that
// NOTE: are defined in the header files with _declspec...

//
//  HMODULE _hmod - where we cache the HMODULE (aka HINSTANCE)
//           _dll - Basename of the target DLL, not quoted
//           _ext - Extension of the target DLL, not quoted (usually DLL)
//           _ret - Data type of return value
//        _fnpriv - Local name for the function
//            _fn - Exported name for the function
//          _args - Argument list in the form (TYPE1 arg1, TYPE2 arg2, ...)
//         _nargs - Argument list in the form (arg1, arg2, ...)
//           _err - Return value if we can't call the actual function
//
#define DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll "." #_ext, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define     DELAY_LOAD_NAME_ERR(_hmod, _dll,       _ret, _fnpriv, _fn, _args, _nargs, _err) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll,  DLL, _ret, _fnpriv, _fn, _args, _nargs, _err)

#define DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn,      _args, _nargs, _err) \
   DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hmod, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOL, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_BOOLEAN(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOLEAN, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_DWORD(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_LRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LRESULT, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_WNET(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)
#define DELAY_LOAD_LPVOID(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LPVOID, _fn, _args, _nargs, 0)

// the NAME variants allow the local function to be called something different from the imported
// function to avoid dll linkage problems.
#define DELAY_LOAD_NAME(_hmod, _dll, _ret, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_HRESULT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, HRESULT, _fn, _fni, _args, _nargs, E_FAIL)
#define DELAY_LOAD_NAME_SAFEARRAY(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, SAFEARRAY *, _fn, _fni, _args, _nargs, NULL)
#define DELAY_LOAD_NAME_UINT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, UINT, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_BOOL(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, BOOL, _fn, _fni, _args, _nargs, FALSE)
#define DELAY_LOAD_NAME_DWORD(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, DWORD, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fni, _args, _nargs)                               \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (__stdcall *_pfn##_fni) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hmod, _dll, DLL, TEXT(#_fni)))                                       \
    {                                                                                   \
        AssertMsg(BOOLFROMPTR(_hmod), TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fni == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fni) = GetProcAddress(_hmod, #_fni);                         \
        AssertMsg(BOOLFROMPTR(_pfn##_fni), TEXT("GetProcAddress failed on ") ## TEXT(#_fni));    \
        if (_pfn##_fni == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fni _nargs;                                                                   \
}

#define DELAY_LOAD_VOID(_hmod, _dll, _fn, _args, _nargs)   DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fn, _args, _nargs)



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_ORD(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_EXT_ORD(_hmod, _dll, _ext, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hmod, #_dll "." #_ext, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs)                     \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}
#define DELAY_LOAD_VOID_ORD DELAY_LOAD_ORD_VOID // cuz people screw this up all the time

#define DELAY_LOAD_ORD_BOOL(_hmod, _dll, _fn, _ord, _args, _nargs) \
    DELAY_LOAD_ORD_ERR(_hmod, _dll, BOOL, _fn, _ord, _args, _nargs, 0)

#define DELAY_LOAD_EXT(_hmod, _dll, _ext, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fn, _fn, _args, _nargs, 0)

#define DELAY_LOAD_EXT_WRAP(_hmod, _dll, _ext, _ret, _fnWrap, _fnOrig, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnWrap, _fnOrig, _args, _nargs, 0)

#if defined(BROWSEUI_IN_IEXPLORE_DIRECTORY) || defined(UNIX)
/*----------------------------------------------------------
Purpose: Loads the DLL via a CLSID it is known to be registered for
*/
void _GetProcFromCLSID(HMODULE* phmod, const CLSID *pclsid, FARPROC* ppfn, LPCSTR pszProc)
{
    if (*phmod == NULL) {
        //
        //  SHPinDLLOfCLSID does all the annoying work of opening the
        //  appropriate registry key, doing REG_EXPAND_SZ, etc.
        //  It also loads the DLL with exactly the same name that OLE does,
        //  which is important because NT4 SP3 didn't like it when you loaded
        //  a DLL sometimes via SFN and sometimes via LFN.  (It would
        //  think they were different DLLs, and two copies of it got loaded
        //  into memory.  Aigh!)
        //
        *phmod = (HMODULE)SHPinDllOfCLSID(pclsid);
        if (!*phmod) 
            return;
    }

    // We don't know the name of the DLL, but fortunately _GetProcFromDLL
    // doesn't need it if *phmod is already filled in.
    ASSERT(*phmod);
    _GetProcFromDLL(phmod, "", ppfn, pszProc);
}

//
//  Private exports by ordinal for browseui.  loads from the browseui in apppath dir
//

#ifndef UNIX

#define DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#else

#define DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)#_fn);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#endif
    
#ifndef UNIX

#define DELAY_LOAD_IE_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#else

#define DELAY_LOAD_IE_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)#_fn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#endif

#else // BrowseUI is in the System directory

#define DELAY_LOAD_IE_ORD_ERR       DELAY_LOAD_ORD_ERR
#define DELAY_LOAD_IE_ORD_VOID      DELAY_LOAD_ORD_VOID

#endif

#define DELAY_LOAD_IE(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_IE_HRESULT(_hmod, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)
#define DELAY_LOAD_IE_BOOL(_hmod, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, BOOL, _fn, _ord, _args, _nargs, FALSE)

#define DELAY_LOAD_IE_ORD(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)

#ifndef NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    if (PLATFORM_INTEGRATED == WhichPlatform())
        _GetProcFromSystemDLL(phinst, pszDLL, ppfn, pszProc);
    else
        TraceMsg(TF_ERROR, "Could not load integrated shell version of %s for %d", pszDLL, pszProc);
}

#endif // NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM

//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs ) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL )


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

// Following Macros are functionally  same as above only that they are
// using function name on UNIX rather than ordinals. The above macros 
// are left untouched because other dlls like shdocvw/shdoc401 still use
// them.

#ifndef UNIX

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#else

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)#_realfn);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#endif

#define DELAY_LOAD_SHELL_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0, _realfn)
#define DELAY_LOAD_SHELL_HRESULT_FN(_hinst, _dll, _fn, _ord, _args, _nargs, realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL, _realfn)


#ifndef UNIX

#define DELAY_LOAD_SHELL_VOID_FN(_hinst, _dll, _fn, _ord, _args, _nargs, _realfn) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#else

#define DELAY_LOAD_SHELL_VOID_FN(_hinst, _dll, _fn, _ord, _args, _nargs, _realfn) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)#_realfn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dkaw.cpp ===
#ifndef UNICODE 
#define UNICODE 
#endif 
//
// These APIs were moved from shell32 to stocklib.
//

#include "proj.h"
#include <shellp.h>

#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

//===========================================================================
// DKA stuff (moved from filemenu.c)
//===========================================================================

typedef struct _DKAITEM {       // dkai
    TCHAR    _szKey[CCH_KEYMAX];
} DKAITEM, *PDKAITEM;
typedef const DKAITEM * PCDKAITEM;

typedef struct _DKA {           // dka
    HDSA    _hdsa;
    HKEY    _hkey;
} DKA, *PDKA;

// _KeyIsDisabled           (davepl 4-20-99)
//
// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)
//                       
//                       LegacyDisable       = ""
//  LegacyDisable is set, then the verb exists only for legacy reasons, and 
//  is actually superceded by a context menu extension or some other behavior
//  it there only to retain legacy behavior for external clients that require
//  the existence of a verb.
//

BOOL _KeyIsDisabled(HKEY hkey, LPCTSTR pszSubkey)
{
    if (NOERROR == SHGetValue(hkey, pszSubkey, TEXT("LegacyDisable"), NULL, NULL, NULL))
        return TRUE;

    DWORD dwidRest;
    DWORD cbdwidRest = sizeof(dwidRest);
    DWORD dwKeyType  = REG_DWORD;
    if (NOERROR == SHGetValue(hkey, pszSubkey, TEXT("SuppressionPolicy"), &dwKeyType, &dwidRest, &cbdwidRest))
        if (SHRestricted( (RESTRICTIONS)dwidRest) )
            return TRUE;

    return FALSE;
}


//
//  This function creates a dynamic registration key array from the
// specified location of the registration base.
//
// Arguments:
//  hkey      -- Identifies a currently open key (which can be HKEY_CLASSES_ROOT).
//  pszSubKey -- Points to a null-terminated string specifying the name of the
//               subkey from which we enumerate the list of subkeys.
//  fDefault  -- If true, it will only load the keys that are enumerated in
//               pszSubKey's value
//
// Returns:
//   The return value is non-zero handle to the created dynamic key array
//  if the function is successful. Otherwise, NULL.
//
// History:
//  05-06-93 SatoNa     Created
//
// Notes:
//  The dynamic key array should be destroyed by calling DKA_Destroy function.
//
HDKA DKA_Create(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszFirst, LPCTSTR pszDefOrder, BOOL fDefault)
{
    ASSERT(IS_VALID_HANDLE(hkey, KEY));
    ASSERT(NULL == pszSubKey || IS_VALID_STRING_PTR(pszSubKey, -1));
    ASSERT(NULL == pszFirst || IS_VALID_STRING_PTR(pszFirst, -1));
    ASSERT(NULL == pszDefOrder || IS_VALID_STRING_PTR(pszDefOrder, -1));
    
    PDKA pdka = (PDKA)LocalAlloc(LPTR, SIZEOF(DKA));
    DKAITEM dkai;

    if (pdka)
    {
        pdka->_hdsa = DSA_Create(SIZEOF(DKAITEM), 4);
        if (pdka->_hdsa)
        {
            if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0L, KEY_READ, &pdka->_hkey))
            {
                DSA_Destroy(pdka->_hdsa);
                pdka->_hdsa = NULL;
            }
        }
        
        // Check if the creation succceeded
        if (pdka->_hdsa)
        {
            // Yes, add keys
            TCHAR szValue[MAX_PATH*2+CCH_KEYMAX];
            LONG cchValue=ARRAYSIZE(szValue)-CCH_KEYMAX;
            LONG cbValue;
            LPTSTR lpszValue = szValue;
            TCHAR szKey[CCH_KEYMAX];
            int i;
            LPTSTR psz;
            HKEY hkeyCmd;

            *szValue = TEXT('\0');

            // if there's something we need to add first, do it now.
            if (pszFirst) {
                lstrcpy(szValue, pszFirst);
                lstrcat(szValue, TEXT(" "));
                i = lstrlen(szValue);
                cchValue -= i;
                lpszValue += i;
            }

            // First, add the subkeys from the value of the specified key
            // This should never fail, since we just opened this key

            cbValue = cchValue * SIZEOF(TCHAR);
            RegQueryValue(pdka->_hkey, NULL, lpszValue, &cbValue);
            if (!*szValue && pszDefOrder)
            {
                // If there is no value, default to open for 3.1 compatibility
                lstrcpy(szValue, pszDefOrder);
            }

            psz = szValue;
            do
            {
                // skip the space or comma characters
                while(*psz==TEXT(' ') || *psz==TEXT(','))
                    psz++;          // NLS Notes: OK to ++

                if (*psz)
                {
                    // Search for the space or comma character
                    LPTSTR pszNext = psz + StrCSpn(psz, TEXT(" ,"));
                    if (*pszNext) {
                        *pszNext++=TEXT('\0');    // NLS Notes: OK to ++
                    }

                    // Verify that the key exists before adding it to the list
                    if (RegOpenKeyEx(pdka->_hkey, psz, 0L, KEY_READ, &hkeyCmd) == ERROR_SUCCESS)
                    {
                        if (!_KeyIsDisabled(hkeyCmd, NULL))
                        {
                            lstrcpy(dkai._szKey, psz);
                            DSA_AppendItem(pdka->_hdsa, &dkai);
                        }
                        RegCloseKey(hkeyCmd);
                    }

                    psz = pszNext;
                }
            } while (psz && *psz);


            if (!fDefault) {
                // Then, append the rest if they are not in the list yet.
                for (i=0;
                     RegEnumKey(pdka->_hkey, i, szKey, ARRAYSIZE(szKey))==ERROR_SUCCESS;
                     i++)
                {
                    int idsa;
                    //
                    // Check if the key is already in the list.
                    //
                    for (idsa = 0; idsa < DSA_GetItemCount(pdka->_hdsa); idsa++)
                    {
                        PDKAITEM pdkai = (PDKAITEM)DSA_GetItemPtr(pdka->_hdsa, idsa);
                        if (lstrcmpi(szKey, pdkai->_szKey)==0)
                            break;
                    }

                    if (idsa == DSA_GetItemCount(pdka->_hdsa) && !_KeyIsDisabled(pdka->_hkey, szKey))
                    {
                        //
                        // No, append it.
                        //
                        lstrcpy(dkai._szKey, szKey);
                        DSA_AppendItem(pdka->_hdsa, &dkai);
                    }
                }
            }
        }
        else
        {
            // No, free the memory and return NULL.
            LocalFree((HLOCAL)pdka);
            pdka=NULL;
        }
    }
    return (HDKA)pdka;
}


#ifdef DECLARE_ONCE

int DKA_GetItemCount(HDKA pdka)
{
    return DSA_GetItemCount(pdka->_hdsa);
}


//
//  This function destroys the dynamic key array.
// Arguments:
//  hdka     -- Specifies the dynamic key array
//
// History:
//  05-06-93 SatoNa     Created
//
void DKA_Destroy(HDKA pdka)
{
    if (pdka)
    {
        RegCloseKey(pdka->_hkey);
        DSA_Destroy(pdka->_hdsa);
        LocalFree((HLOCAL)pdka);
    }
}

#endif // DECLARE_ONCE


LPCTSTR DKA_GetKey(HDKA pdka, int iItem)
{
    PDKAITEM pdkai = (PDKAITEM)DSA_GetItemPtr(pdka->_hdsa, iItem);
    return pdkai->_szKey;
}


//
//  This function returns the value of specified sub-key.
//
// Arguments:
//  hdka     -- Specifies the dynamic key array
//  iItem    -- Specifies the index to the sub-key
//  pszValue -- Points to a buffefr that contains the text string when
//              the function returns.
//  pcb      -- Points to a variable specifying the sixze, in bytes, of the buffer
//              pointer by the pszValue parameter. When the function returns,
//              this variable contains the size of the string copied to pszVlaue,
//              including the null-terminating character.
//
// History:
//  05-06-93 SatoNa     Created
//
LONG DKA_QueryValue(HDKA pdka, int iItem, LPTSTR pszValue, LONG * pcb)
{
    PCDKAITEM pdkai = (PCDKAITEM) DSA_GetItemPtr(pdka->_hdsa, iItem);
    if (pdkai) 
    {
        return RegQueryValue(pdka->_hkey, pdkai->_szKey, pszValue, pcb);
    }
    return ERROR_INVALID_PARAMETER;
}


/*----------------------------------------------------------
Purpose: Return a value from under the given sub-key.

Returns: win32 error
*/
DWORD
DKA_QueryOtherValue(
    IN  HDKA    pdka,
    IN  int     iItem,
    IN  LPCTSTR pszName,
    IN  LPTSTR  pszValue,
    OUT LONG *  pcb)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    PCDKAITEM pdkai = (PCDKAITEM) DSA_GetItemPtr(pdka->_hdsa, iItem);

    if (pdkai)
    {
        HKEY hkey;

        dwRet = RegOpenKeyEx(pdka->_hkey, pdkai->_szKey, 0, KEY_QUERY_VALUE,
                             &hkey);
        if (NO_ERROR == dwRet)
        {
            dwRet = RegQueryValueEx(hkey, pszName, 0, NULL, (LPBYTE)pszValue, (DWORD *) pcb);
            RegCloseKey(hkey);
        }
    }

    return dwRet;
}


//===========================================================================
// DCA stuff - Dynamic CLSID array
// 
//  This is a dynamic array of CLSIDs that you can obtain from 
//  a registry key or add individually.  Use DCA_CreateInstance
//  to actually CoCreateInstance the element.
//
//===========================================================================


#ifdef DECLARE_ONCE

HDCA DCA_Create()
{
    HDSA hdsa = DSA_Create(SIZEOF(CLSID), 4);
    return (HDCA)hdsa;
}

void DCA_Destroy(HDCA hdca)
{
    DSA_Destroy((HDSA)hdca);
}

int  DCA_GetItemCount(HDCA hdca)
{
    ASSERT(hdca);
    
    return DSA_GetItemCount((HDSA)hdca);
}

const CLSID * DCA_GetItem(HDCA hdca, int i)
{
    ASSERT(hdca);
    
    return (const CLSID *)DSA_GetItemPtr((HDSA)hdca, i);
}


BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid)
{
    ASSERT(hdca);
    
    int ccls = DCA_GetItemCount(hdca);
    int icls;
    for (icls = 0; icls < ccls; icls++)
    {
        if (IsEqualGUID(rclsid, *DCA_GetItem(hdca,icls))) 
            return FALSE;
    }

    DSA_AppendItem((HDSA)hdca, (LPVOID) &rclsid);
    return TRUE;
}


HRESULT DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, LPVOID FAR* ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    if (pclsid) {
        return SHCoCreateInstance(NULL, pclsid, NULL, riid, ppv);
    }
    return E_INVALIDARG;
}

#endif // DECLARE_ONCE


void DCA_AddItemsFromKey(HDCA hdca, HKEY hkey, LPCTSTR pszSubKey)
{
    HDKA hdka = DKA_Create(hkey, pszSubKey, NULL, NULL, FALSE);
    if (hdka)
    {
        int ikey;
        int ckey = DKA_GetItemCount(hdka);
        for (ikey = 0; ikey < ckey; ikey++)
        {
            HRESULT hres;
            CLSID clsid;
            
            //
            // First, check if the key itself is a CLSID
            //
            hres = GUIDFromString(DKA_GetKey(hdka, ikey), &clsid) ? NOERROR : CO_E_CLASSSTRING;
            if (FAILED(hres))
            {
                //
                // If not, try its value
                //
                TCHAR szCLSID[MAX_PATH];
                LONG cb = SIZEOF(szCLSID);
                if (DKA_QueryValue(hdka, ikey, szCLSID, &cb)==ERROR_SUCCESS)
                {
                    hres = GUIDFromString(szCLSID, &clsid) ? NOERROR : CO_E_CLASSSTRING;
                }
            }

            //
            // Add the CLSID if we successfully got the CLSID.
            //
            if (SUCCEEDED(hres))
            {
                if (_KeyIsDisabled(hdka->_hkey, DKA_GetKey(hdka, ikey)))
                    continue; // key is disabled so don't add it
                DCA_AddItem(hdca, clsid);
            }
        }
        DKA_Destroy(hdka);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dka.cpp ===
//
// These APIs were moved from shell32 to stocklib.
//

#include "proj.h"
#include <shellp.h>

#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

//===========================================================================
// DKA stuff (moved from filemenu.c)
//===========================================================================

typedef struct _DKAITEM {       // dkai
    TCHAR    _szKey[CCH_KEYMAX];
} DKAITEM, *PDKAITEM;
typedef const DKAITEM * PCDKAITEM;

typedef struct _DKA {           // dka
    HDSA    _hdsa;
    HKEY    _hkey;
} DKA, *PDKA;

// _KeyIsDisabled           (davepl 4-20-99)
//
// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)
//                       
//                       LegacyDisable       = ""
//  LegacyDisable is set, then the verb exists only for legacy reasons, and 
//  is actually superceded by a context menu extension or some other behavior
//  it there only to retain legacy behavior for external clients that require
//  the existence of a verb.
//

BOOL _KeyIsDisabled(HKEY hkey, LPCTSTR pszSubkey)
{
    if (NOERROR == SHGetValue(hkey, pszSubkey, TEXT("LegacyDisable"), NULL, NULL, NULL))
        return TRUE;

    DWORD dwidRest;
    DWORD cbdwidRest = sizeof(dwidRest);
    DWORD dwKeyType  = REG_DWORD;
    if (NOERROR == SHGetValue(hkey, pszSubkey, TEXT("SuppressionPolicy"), &dwKeyType, &dwidRest, &cbdwidRest))
        if (SHRestricted( (RESTRICTIONS)dwidRest) )
            return TRUE;

    return FALSE;
}


//
//  This function creates a dynamic registration key array from the
// specified location of the registration base.
//
// Arguments:
//  hkey      -- Identifies a currently open key (which can be HKEY_CLASSES_ROOT).
//  pszSubKey -- Points to a null-terminated string specifying the name of the
//               subkey from which we enumerate the list of subkeys.
//  fDefault  -- If true, it will only load the keys that are enumerated in
//               pszSubKey's value
//
// Returns:
//   The return value is non-zero handle to the created dynamic key array
//  if the function is successful. Otherwise, NULL.
//
// History:
//  05-06-93 SatoNa     Created
//
// Notes:
//  The dynamic key array should be destroyed by calling DKA_Destroy function.
//
HDKA DKA_Create(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszFirst, LPCTSTR pszDefOrder, BOOL fDefault)
{
    ASSERT(IS_VALID_HANDLE(hkey, KEY));
    ASSERT(NULL == pszSubKey || IS_VALID_STRING_PTR(pszSubKey, -1));
    ASSERT(NULL == pszFirst || IS_VALID_STRING_PTR(pszFirst, -1));
    ASSERT(NULL == pszDefOrder || IS_VALID_STRING_PTR(pszDefOrder, -1));
    
    PDKA pdka = (PDKA)LocalAlloc(LPTR, SIZEOF(DKA));
    DKAITEM dkai;

    if (pdka)
    {
        pdka->_hdsa = DSA_Create(SIZEOF(DKAITEM), 4);
        if (pdka->_hdsa)
        {
            if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0L, KEY_READ, &pdka->_hkey))
            {
                DSA_Destroy(pdka->_hdsa);
                pdka->_hdsa = NULL;
            }
        }
        
        // Check if the creation succceeded
        if (pdka->_hdsa)
        {
            // Yes, add keys
            TCHAR szValue[MAX_PATH*2+CCH_KEYMAX];
            LONG cchValue=ARRAYSIZE(szValue)-CCH_KEYMAX;
            LONG cbValue;
            LPTSTR lpszValue = szValue;
            TCHAR szKey[CCH_KEYMAX];
            int i;
            LPTSTR psz;
            HKEY hkeyCmd;

            *szValue = TEXT('\0');

            // if there's something we need to add first, do it now.
            if (pszFirst) {
                lstrcpy(szValue, pszFirst);
                lstrcat(szValue, TEXT(" "));
                i = lstrlen(szValue);
                cchValue -= i;
                lpszValue += i;
            }

            // First, add the subkeys from the value of the specified key
            // This should never fail, since we just opened this key

            cbValue = cchValue * SIZEOF(TCHAR);
            RegQueryValue(pdka->_hkey, NULL, lpszValue, &cbValue);
            if (!*szValue && pszDefOrder)
            {
                // If there is no value, default to open for 3.1 compatibility
                lstrcpy(szValue, pszDefOrder);
            }

            psz = szValue;
            do
            {
                // skip the space or comma characters
                while(*psz==TEXT(' ') || *psz==TEXT(','))
                    psz++;          // NLS Notes: OK to ++

                if (*psz)
                {
                    // Search for the space or comma character
                    LPTSTR pszNext = psz + StrCSpn(psz, TEXT(" ,"));
                    if (*pszNext) {
                        *pszNext++=TEXT('\0');    // NLS Notes: OK to ++
                    }

                    // Verify that the key exists before adding it to the list
                    if (RegOpenKeyEx(pdka->_hkey, psz, 0L, KEY_READ, &hkeyCmd) == ERROR_SUCCESS)
                    {
                        if (!_KeyIsDisabled(hkeyCmd, NULL))
                        {
                            lstrcpy(dkai._szKey, psz);
                            DSA_AppendItem(pdka->_hdsa, &dkai);
                        }
                        RegCloseKey(hkeyCmd);
                    }

                    psz = pszNext;
                }
            } while (psz && *psz);


            if (!fDefault) {
                // Then, append the rest if they are not in the list yet.
                for (i=0;
                     RegEnumKey(pdka->_hkey, i, szKey, ARRAYSIZE(szKey))==ERROR_SUCCESS;
                     i++)
                {
                    int idsa;
                    //
                    // Check if the key is already in the list.
                    //
                    for (idsa = 0; idsa < DSA_GetItemCount(pdka->_hdsa); idsa++)
                    {
                        PDKAITEM pdkai = (PDKAITEM)DSA_GetItemPtr(pdka->_hdsa, idsa);
                        if (lstrcmpi(szKey, pdkai->_szKey)==0)
                            break;
                    }

                    if (idsa == DSA_GetItemCount(pdka->_hdsa) && !_KeyIsDisabled(pdka->_hkey, szKey))
                    {
                        //
                        // No, append it.
                        //
                        lstrcpy(dkai._szKey, szKey);
                        DSA_AppendItem(pdka->_hdsa, &dkai);
                    }
                }
            }
        }
        else
        {
            // No, free the memory and return NULL.
            LocalFree((HLOCAL)pdka);
            pdka=NULL;
        }
    }
    return (HDKA)pdka;
}


#ifdef DECLARE_ONCE

int DKA_GetItemCount(HDKA pdka)
{
    return DSA_GetItemCount(pdka->_hdsa);
}


//
//  This function destroys the dynamic key array.
// Arguments:
//  hdka     -- Specifies the dynamic key array
//
// History:
//  05-06-93 SatoNa     Created
//
void DKA_Destroy(HDKA pdka)
{
    if (pdka)
    {
        RegCloseKey(pdka->_hkey);
        DSA_Destroy(pdka->_hdsa);
        LocalFree((HLOCAL)pdka);
    }
}

#endif // DECLARE_ONCE


LPCTSTR DKA_GetKey(HDKA pdka, int iItem)
{
    PDKAITEM pdkai = (PDKAITEM)DSA_GetItemPtr(pdka->_hdsa, iItem);
    return pdkai->_szKey;
}


//
//  This function returns the value of specified sub-key.
//
// Arguments:
//  hdka     -- Specifies the dynamic key array
//  iItem    -- Specifies the index to the sub-key
//  pszValue -- Points to a buffefr that contains the text string when
//              the function returns.
//  pcb      -- Points to a variable specifying the sixze, in bytes, of the buffer
//              pointer by the pszValue parameter. When the function returns,
//              this variable contains the size of the string copied to pszVlaue,
//              including the null-terminating character.
//
// History:
//  05-06-93 SatoNa     Created
//
LONG DKA_QueryValue(HDKA pdka, int iItem, LPTSTR pszValue, LONG * pcb)
{
    PCDKAITEM pdkai = (PCDKAITEM) DSA_GetItemPtr(pdka->_hdsa, iItem);
    if (pdkai) 
    {
        return RegQueryValue(pdka->_hkey, pdkai->_szKey, pszValue, pcb);
    }
    return ERROR_INVALID_PARAMETER;
}


/*----------------------------------------------------------
Purpose: Return a value from under the given sub-key.

Returns: win32 error
*/
DWORD
DKA_QueryOtherValue(
    IN  HDKA    pdka,
    IN  int     iItem,
    IN  LPCTSTR pszName,
    IN  LPTSTR  pszValue,
    OUT LONG *  pcb)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    PCDKAITEM pdkai = (PCDKAITEM) DSA_GetItemPtr(pdka->_hdsa, iItem);

    if (pdkai)
    {
        HKEY hkey;

        dwRet = RegOpenKeyEx(pdka->_hkey, pdkai->_szKey, 0, KEY_QUERY_VALUE,
                             &hkey);
        if (NO_ERROR == dwRet)
        {
            dwRet = RegQueryValueEx(hkey, pszName, 0, NULL, (LPBYTE)pszValue, (DWORD *) pcb);
            RegCloseKey(hkey);
        }
    }

    return dwRet;
}


//===========================================================================
// DCA stuff - Dynamic CLSID array
// 
//  This is a dynamic array of CLSIDs that you can obtain from 
//  a registry key or add individually.  Use DCA_CreateInstance
//  to actually CoCreateInstance the element.
//
//===========================================================================


#ifdef DECLARE_ONCE

HDCA DCA_Create()
{
    HDSA hdsa = DSA_Create(SIZEOF(CLSID), 4);
    return (HDCA)hdsa;
}

void DCA_Destroy(HDCA hdca)
{
    DSA_Destroy((HDSA)hdca);
}

int  DCA_GetItemCount(HDCA hdca)
{
    ASSERT(hdca);
    
    return DSA_GetItemCount((HDSA)hdca);
}

const CLSID * DCA_GetItem(HDCA hdca, int i)
{
    ASSERT(hdca);
    
    return (const CLSID *)DSA_GetItemPtr((HDSA)hdca, i);
}


BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid)
{
    ASSERT(hdca);
    
    int ccls = DCA_GetItemCount(hdca);
    int icls;
    for (icls = 0; icls < ccls; icls++)
    {
        if (IsEqualGUID(rclsid, *DCA_GetItem(hdca,icls))) 
            return FALSE;
    }

    DSA_AppendItem((HDSA)hdca, (LPVOID) &rclsid);
    return TRUE;
}


HRESULT DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, LPVOID FAR* ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    if (pclsid) {
        return SHCoCreateInstance(NULL, pclsid, NULL, riid, ppv);
    }
    return E_INVALIDARG;
}

#endif // DECLARE_ONCE


void DCA_AddItemsFromKey(HDCA hdca, HKEY hkey, LPCTSTR pszSubKey)
{
    HDKA hdka = DKA_Create(hkey, pszSubKey, NULL, NULL, FALSE);
    if (hdka)
    {
        int ikey;
        int ckey = DKA_GetItemCount(hdka);
        for (ikey = 0; ikey < ckey; ikey++)
        {
            HRESULT hres;
            CLSID clsid;
            
            //
            // First, check if the key itself is a CLSID
            //
            hres = GUIDFromString(DKA_GetKey(hdka, ikey), &clsid) ? NOERROR : CO_E_CLASSSTRING;
            if (FAILED(hres))
            {
                //
                // If not, try its value
                //
                TCHAR szCLSID[MAX_PATH];
                LONG cb = SIZEOF(szCLSID);
                if (DKA_QueryValue(hdka, ikey, szCLSID, &cb)==ERROR_SUCCESS)
                {
                    hres = GUIDFromString(szCLSID, &clsid) ? NOERROR : CO_E_CLASSSTRING;
                }
            }

            //
            // Add the CLSID if we successfully got the CLSID.
            //
            if (SUCCEEDED(hres))
            {
                if (_KeyIsDisabled(hdka->_hkey, DKA_GetKey(hdka, ikey)))
                    continue; // key is disabled so don't add it
                DCA_AddItem(hdca, clsid);
            }
        }
        DKA_Destroy(hdka);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dkaa.cpp ===
#ifdef UNICODE 
#undef UNICODE 
#endif 
//
// These APIs were moved from shell32 to stocklib.
//

#include "proj.h"
#include <shellp.h>

#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

//===========================================================================
// DKA stuff (moved from filemenu.c)
//===========================================================================

typedef struct _DKAITEM {       // dkai
    TCHAR    _szKey[CCH_KEYMAX];
} DKAITEM, *PDKAITEM;
typedef const DKAITEM * PCDKAITEM;

typedef struct _DKA {           // dka
    HDSA    _hdsa;
    HKEY    _hkey;
} DKA, *PDKA;

// _KeyIsDisabled           (davepl 4-20-99)
//
// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)
//                       
//                       LegacyDisable       = ""
//  LegacyDisable is set, then the verb exists only for legacy reasons, and 
//  is actually superceded by a context menu extension or some other behavior
//  it there only to retain legacy behavior for external clients that require
//  the existence of a verb.
//

BOOL _KeyIsDisabled(HKEY hkey, LPCTSTR pszSubkey)
{
    if (NOERROR == SHGetValue(hkey, pszSubkey, TEXT("LegacyDisable"), NULL, NULL, NULL))
        return TRUE;

    DWORD dwidRest;
    DWORD cbdwidRest = sizeof(dwidRest);
    DWORD dwKeyType  = REG_DWORD;
    if (NOERROR == SHGetValue(hkey, pszSubkey, TEXT("SuppressionPolicy"), &dwKeyType, &dwidRest, &cbdwidRest))
        if (SHRestricted( (RESTRICTIONS)dwidRest) )
            return TRUE;

    return FALSE;
}


//
//  This function creates a dynamic registration key array from the
// specified location of the registration base.
//
// Arguments:
//  hkey      -- Identifies a currently open key (which can be HKEY_CLASSES_ROOT).
//  pszSubKey -- Points to a null-terminated string specifying the name of the
//               subkey from which we enumerate the list of subkeys.
//  fDefault  -- If true, it will only load the keys that are enumerated in
//               pszSubKey's value
//
// Returns:
//   The return value is non-zero handle to the created dynamic key array
//  if the function is successful. Otherwise, NULL.
//
// History:
//  05-06-93 SatoNa     Created
//
// Notes:
//  The dynamic key array should be destroyed by calling DKA_Destroy function.
//
HDKA DKA_Create(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszFirst, LPCTSTR pszDefOrder, BOOL fDefault)
{
    ASSERT(IS_VALID_HANDLE(hkey, KEY));
    ASSERT(NULL == pszSubKey || IS_VALID_STRING_PTR(pszSubKey, -1));
    ASSERT(NULL == pszFirst || IS_VALID_STRING_PTR(pszFirst, -1));
    ASSERT(NULL == pszDefOrder || IS_VALID_STRING_PTR(pszDefOrder, -1));
    
    PDKA pdka = (PDKA)LocalAlloc(LPTR, SIZEOF(DKA));
    DKAITEM dkai;

    if (pdka)
    {
        pdka->_hdsa = DSA_Create(SIZEOF(DKAITEM), 4);
        if (pdka->_hdsa)
        {
            if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0L, KEY_READ, &pdka->_hkey))
            {
                DSA_Destroy(pdka->_hdsa);
                pdka->_hdsa = NULL;
            }
        }
        
        // Check if the creation succceeded
        if (pdka->_hdsa)
        {
            // Yes, add keys
            TCHAR szValue[MAX_PATH*2+CCH_KEYMAX];
            LONG cchValue=ARRAYSIZE(szValue)-CCH_KEYMAX;
            LONG cbValue;
            LPTSTR lpszValue = szValue;
            TCHAR szKey[CCH_KEYMAX];
            int i;
            LPTSTR psz;
            HKEY hkeyCmd;

            *szValue = TEXT('\0');

            // if there's something we need to add first, do it now.
            if (pszFirst) {
                lstrcpy(szValue, pszFirst);
                lstrcat(szValue, TEXT(" "));
                i = lstrlen(szValue);
                cchValue -= i;
                lpszValue += i;
            }

            // First, add the subkeys from the value of the specified key
            // This should never fail, since we just opened this key

            cbValue = cchValue * SIZEOF(TCHAR);
            RegQueryValue(pdka->_hkey, NULL, lpszValue, &cbValue);
            if (!*szValue && pszDefOrder)
            {
                // If there is no value, default to open for 3.1 compatibility
                lstrcpy(szValue, pszDefOrder);
            }

            psz = szValue;
            do
            {
                // skip the space or comma characters
                while(*psz==TEXT(' ') || *psz==TEXT(','))
                    psz++;          // NLS Notes: OK to ++

                if (*psz)
                {
                    // Search for the space or comma character
                    LPTSTR pszNext = psz + StrCSpn(psz, TEXT(" ,"));
                    if (*pszNext) {
                        *pszNext++=TEXT('\0');    // NLS Notes: OK to ++
                    }

                    // Verify that the key exists before adding it to the list
                    if (RegOpenKeyEx(pdka->_hkey, psz, 0L, KEY_READ, &hkeyCmd) == ERROR_SUCCESS)
                    {
                        if (!_KeyIsDisabled(hkeyCmd, NULL))
                        {
                            lstrcpy(dkai._szKey, psz);
                            DSA_AppendItem(pdka->_hdsa, &dkai);
                        }
                        RegCloseKey(hkeyCmd);
                    }

                    psz = pszNext;
                }
            } while (psz && *psz);


            if (!fDefault) {
                // Then, append the rest if they are not in the list yet.
                for (i=0;
                     RegEnumKey(pdka->_hkey, i, szKey, ARRAYSIZE(szKey))==ERROR_SUCCESS;
                     i++)
                {
                    int idsa;
                    //
                    // Check if the key is already in the list.
                    //
                    for (idsa = 0; idsa < DSA_GetItemCount(pdka->_hdsa); idsa++)
                    {
                        PDKAITEM pdkai = (PDKAITEM)DSA_GetItemPtr(pdka->_hdsa, idsa);
                        if (lstrcmpi(szKey, pdkai->_szKey)==0)
                            break;
                    }

                    if (idsa == DSA_GetItemCount(pdka->_hdsa) && !_KeyIsDisabled(pdka->_hkey, szKey))
                    {
                        //
                        // No, append it.
                        //
                        lstrcpy(dkai._szKey, szKey);
                        DSA_AppendItem(pdka->_hdsa, &dkai);
                    }
                }
            }
        }
        else
        {
            // No, free the memory and return NULL.
            LocalFree((HLOCAL)pdka);
            pdka=NULL;
        }
    }
    return (HDKA)pdka;
}


#ifdef DECLARE_ONCE

int DKA_GetItemCount(HDKA pdka)
{
    return DSA_GetItemCount(pdka->_hdsa);
}


//
//  This function destroys the dynamic key array.
// Arguments:
//  hdka     -- Specifies the dynamic key array
//
// History:
//  05-06-93 SatoNa     Created
//
void DKA_Destroy(HDKA pdka)
{
    if (pdka)
    {
        RegCloseKey(pdka->_hkey);
        DSA_Destroy(pdka->_hdsa);
        LocalFree((HLOCAL)pdka);
    }
}

#endif // DECLARE_ONCE


LPCTSTR DKA_GetKey(HDKA pdka, int iItem)
{
    PDKAITEM pdkai = (PDKAITEM)DSA_GetItemPtr(pdka->_hdsa, iItem);
    return pdkai->_szKey;
}


//
//  This function returns the value of specified sub-key.
//
// Arguments:
//  hdka     -- Specifies the dynamic key array
//  iItem    -- Specifies the index to the sub-key
//  pszValue -- Points to a buffefr that contains the text string when
//              the function returns.
//  pcb      -- Points to a variable specifying the sixze, in bytes, of the buffer
//              pointer by the pszValue parameter. When the function returns,
//              this variable contains the size of the string copied to pszVlaue,
//              including the null-terminating character.
//
// History:
//  05-06-93 SatoNa     Created
//
LONG DKA_QueryValue(HDKA pdka, int iItem, LPTSTR pszValue, LONG * pcb)
{
    PCDKAITEM pdkai = (PCDKAITEM) DSA_GetItemPtr(pdka->_hdsa, iItem);
    if (pdkai) 
    {
        return RegQueryValue(pdka->_hkey, pdkai->_szKey, pszValue, pcb);
    }
    return ERROR_INVALID_PARAMETER;
}


/*----------------------------------------------------------
Purpose: Return a value from under the given sub-key.

Returns: win32 error
*/
DWORD
DKA_QueryOtherValue(
    IN  HDKA    pdka,
    IN  int     iItem,
    IN  LPCTSTR pszName,
    IN  LPTSTR  pszValue,
    OUT LONG *  pcb)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    PCDKAITEM pdkai = (PCDKAITEM) DSA_GetItemPtr(pdka->_hdsa, iItem);

    if (pdkai)
    {
        HKEY hkey;

        dwRet = RegOpenKeyEx(pdka->_hkey, pdkai->_szKey, 0, KEY_QUERY_VALUE,
                             &hkey);
        if (NO_ERROR == dwRet)
        {
            dwRet = RegQueryValueEx(hkey, pszName, 0, NULL, (LPBYTE)pszValue, (DWORD *) pcb);
            RegCloseKey(hkey);
        }
    }

    return dwRet;
}


//===========================================================================
// DCA stuff - Dynamic CLSID array
// 
//  This is a dynamic array of CLSIDs that you can obtain from 
//  a registry key or add individually.  Use DCA_CreateInstance
//  to actually CoCreateInstance the element.
//
//===========================================================================


#ifdef DECLARE_ONCE

HDCA DCA_Create()
{
    HDSA hdsa = DSA_Create(SIZEOF(CLSID), 4);
    return (HDCA)hdsa;
}

void DCA_Destroy(HDCA hdca)
{
    DSA_Destroy((HDSA)hdca);
}

int  DCA_GetItemCount(HDCA hdca)
{
    ASSERT(hdca);
    
    return DSA_GetItemCount((HDSA)hdca);
}

const CLSID * DCA_GetItem(HDCA hdca, int i)
{
    ASSERT(hdca);
    
    return (const CLSID *)DSA_GetItemPtr((HDSA)hdca, i);
}


BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid)
{
    ASSERT(hdca);
    
    int ccls = DCA_GetItemCount(hdca);
    int icls;
    for (icls = 0; icls < ccls; icls++)
    {
        if (IsEqualGUID(rclsid, *DCA_GetItem(hdca,icls))) 
            return FALSE;
    }

    DSA_AppendItem((HDSA)hdca, (LPVOID) &rclsid);
    return TRUE;
}


HRESULT DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, LPVOID FAR* ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    if (pclsid) {
        return SHCoCreateInstance(NULL, pclsid, NULL, riid, ppv);
    }
    return E_INVALIDARG;
}

#endif // DECLARE_ONCE


void DCA_AddItemsFromKey(HDCA hdca, HKEY hkey, LPCTSTR pszSubKey)
{
    HDKA hdka = DKA_Create(hkey, pszSubKey, NULL, NULL, FALSE);
    if (hdka)
    {
        int ikey;
        int ckey = DKA_GetItemCount(hdka);
        for (ikey = 0; ikey < ckey; ikey++)
        {
            HRESULT hres;
            CLSID clsid;
            
            //
            // First, check if the key itself is a CLSID
            //
            hres = GUIDFromString(DKA_GetKey(hdka, ikey), &clsid) ? NOERROR : CO_E_CLASSSTRING;
            if (FAILED(hres))
            {
                //
                // If not, try its value
                //
                TCHAR szCLSID[MAX_PATH];
                LONG cb = SIZEOF(szCLSID);
                if (DKA_QueryValue(hdka, ikey, szCLSID, &cb)==ERROR_SUCCESS)
                {
                    hres = GUIDFromString(szCLSID, &clsid) ? NOERROR : CO_E_CLASSSTRING;
                }
            }

            //
            // Add the CLSID if we successfully got the CLSID.
            //
            if (SUCCEEDED(hres))
            {
                if (_KeyIsDisabled(hdka->_hkey, DKA_GetKey(hdka, ikey)))
                    continue; // key is disabled so don't add it
                DCA_AddItem(hdca, clsid);
            }
        }
        DKA_Destroy(hdka);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\isos.cpp ===
#include "proj.h"

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) staticIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId));
#endif
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_MEMPHIS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_MEMPHIS_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;

    case OS_NT4:
#ifndef UNIX
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
#else
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId ||
                (VER_PLATFORM_WIN32_UNIX == s_osvi.dwPlatformId)) &&
#endif
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\mmhelper.cpp ===
#include "proj.h"
#include <multimon.h>
#include <mmhelper.h>

/* This file contains the Multi-Monitor helper functions used in side the 
   shell. -- dli */
 
HMONITOR GetPrimaryMonitor()
{
    POINT pt = {0,0};
    return MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY); 
}

// Gets the Monitor's bounding or work rectangle, if the hMon is bad, return
// the primary monitor's bounding rectangle. 
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork)
{
    MONITORINFO mi; 
    mi.cbSize = sizeof(mi);
    if (hMon && GetMonitorInfo(hMon, &mi))
    {
        if (!prc)
            return TRUE;
        
        else if (bWork)
            CopyRect(prc, &mi.rcWork);
        else 
            CopyRect(prc, &mi.rcMonitor);
        
        return TRUE;
    }
    
    if (prc)
        SetRect(prc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\droptgt.h ===
#ifndef _DROPTGT_H_
#define _DROPTGT_H_

// There are two drag-drop support objects:
//
//  CDropTargetWrap -       This object takes a collection of drop-target
//                          objects and wraps them as one drop-target
//                          handler.  The first drop-target wins over the
//                          the last one if there is a conflict in who
//                          will take the drop.
//
//  CDelegateDropTarget -   This class implements IDropTarget given an 
//                          IDelegateDropTargetCB interface.  It handles 
//                          all hit testing, caching, and scrolling for you.
//                          Use this class by inheriting it in your derived
//                          class; it is not intended to be instantiated alone.
//

// Event notifications for HitTestDDT
#define HTDDT_ENTER     0
#define HTDDT_OVER      1
#define HTDDT_LEAVE     2

class CDelegateDropTarget : public IDropTarget
{        
public:
    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** Other methods to be implemented by derived class ***

    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll) PURE;
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD * pdwId, DWORD *pdwEffect) PURE;
    virtual HRESULT GetObjectDDT (DWORD dwId, REFIID riid, LPVOID * ppvObj) PURE;
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect) PURE;

    friend IDropTarget* DropTargetWrap_CreateInstance(IDropTarget* pdtPrimary, 
                                           IDropTarget* pdtSecondary,
                                           HWND hwnd, IDropTarget* pdt3 = NULL);
protected:
    CDelegateDropTarget();
    virtual ~CDelegateDropTarget();

    BOOL IsValid() { return (_hwndLock && _hwndScroll); }
    void SetCallback(IDelegateDropTargetCB* pdtcb);
    HRESULT Init(); // init lock + scroll windows
    friend IDropTarget* DelegateDropTarget_CreateInstance(IDelegateDropTargetCB* pdtcb);

private:
    void _ReleaseCurrentDropTarget();

    // the below are parameters we use to implement this IDropTarget
    HWND                    _hwndLock;
    HWND                    _hwndScroll;

    // the object we are dragging
    LPDATAOBJECT            _pDataObj;      // from DragEnter()/Drop()

    // the below indicate the current drag state
    BITBOOL                 _fPrime:1;      // TRUE iff _itemOver/_grfKeyState is valid
    DWORD                   _itemOver;      // item we are visually dragging over
    IDropTarget*            _pdtCur;        // drop target for _itemOver
    DWORD                   _grfKeyState;   // cached key state
    DWORD                   _dwEffectOut;   // last *pdwEffect out
    POINT                   _ptLast;        // last dragged position

    // for scrolling
    RECT                    _rcLockWindow;  // WindowRect of hwnd for DAD_ENTER
    AUTO_SCROLL_DATA        _asd;           // for auto scrolling
    
} ;

// dummy drop target to only call DAD_DragEnterEx() on DragEnter();

class CDropDummy : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void)   
    { 
        DAD_DragLeave();  
        return(S_OK); 
    };
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)   
    { 
        DragLeave();
        return(S_OK); 
    };

    CDropDummy(HWND hwndLock) : _hwndLock(hwndLock), _cRef(1)  { return; };
protected:
    ~CDropDummy()    { return; };
private:
    HWND _hwndLock;         // window for dummy drop target.
    int  _cRef;

};


#endif // _DROPTGT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dpastuff.h ===
#ifndef DPASTUFF_H_
#define DPASTUFF_H_

typedef struct
{
    DWORD           dwSortBy;           // the sort by flag.
    IShellFolder    *psf;               // shell folder to be ordered.

    // Caller of OrderList_Merge does *not* fill in this field.
    // This field is used internally by OrderList_Merge.
    IShellFolder2   *psf2;              // IShellFolder2 version of psf
    LPARAM          lParam;             // Other user data...

} ORDERINFO, * PORDERINFO;

// see shellp.h for ORDERITEM definition
typedef void (*LPFNORDERMERGENOMATCH)(LPVOID pvParam, LPCITEMIDLIST pidl);

int CALLBACK OrderItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam);
LPVOID CALLBACK OrderItem_Merge(UINT uMsg, LPVOID pvDest, LPVOID pvSrc, LPARAM lParam);
void OrderList_Merge(HDPA hdpaNew, HDPA hdpaOld, int iInsertPos, LPARAM lParam, 
                     LPFNORDERMERGENOMATCH pfn, LPVOID pvParam);
void OrderList_Reorder(HDPA hdpa);
HDPA OrderList_Clone(HDPA hdpa);
PORDERITEM OrderItem_Create(LPITEMIDLIST pidl, int nOrder);
void OrderList_Destroy(HDPA *hdpa, BOOL fKillPidls = TRUE);
int OrderItem_GetSystemImageListIndex(PORDERITEM poi, IShellFolder *psf, BOOL fUseCache);
DWORD OrderItem_GetFlags(PORDERITEM poi);
void OrderItem_SetFlags(PORDERITEM poi, DWORD dwFlags);
HRESULT OrderList_SaveToStream(IStream* pstm, HDPA hdpa, IShellFolder * psf);
HRESULT OrderList_LoadFromStream(IStream* pstm, HDPA * phdpa, IShellFolder * psfParent);
void OrderItem_Free(PORDERITEM poi, BOOL fKillPidls = TRUE);
BOOL OrderList_Append(HDPA hdpa, LPITEMIDLIST pidl, int nOrder);

HRESULT COrderList_GetOrderList(HDPA * phdpa, LPCITEMIDLIST pidl, IShellFolder * psf);
HRESULT COrderList_SetOrderList(HDPA hdpa, LPCITEMIDLIST pidl, IShellFolder *psf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dump.c ===
//
// Debug dump functions for common ADTs
//
// This file should be #included by your DLL.  It is not part of
// stocklib.lib because it requires linking to certain guid libs,
// and DLLs like COMCTL32 do not do this.  (Therefore, COMCTL32
// doesn't #include this file, but still links to stocklib.)
//
//

#include <intshcut.h>       // For error values
#include <intshctp.h>
#include <sherror.h>

#ifdef DEBUG

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


//
//  Debug value-to-string mapping functions
//


/*----------------------------------------------------------
Purpose: Return the string form of the clipboard format.

Returns: pointer to a static string
Cond:    --
*/
LPCTSTR 
Dbg_GetCFName(
    UINT ucf)
{
    LPCTSTR pcsz;
    static TCHAR s_szCFName[MAX_PATH];

    switch (ucf)
    {
        STRING_CASE(CF_TEXT);
        STRING_CASE(CF_BITMAP);
        STRING_CASE(CF_METAFILEPICT);
        STRING_CASE(CF_SYLK);
        STRING_CASE(CF_DIF);
        STRING_CASE(CF_TIFF);
        STRING_CASE(CF_OEMTEXT);
        STRING_CASE(CF_DIB);
        STRING_CASE(CF_PALETTE);
        STRING_CASE(CF_PENDATA);
        STRING_CASE(CF_RIFF);
        STRING_CASE(CF_WAVE);
        STRING_CASE(CF_UNICODETEXT);
        STRING_CASE(CF_ENHMETAFILE);
        STRING_CASE(CF_HDROP);
        STRING_CASE(CF_LOCALE);
        STRING_CASE(CF_MAX);
        STRING_CASE(CF_OWNERDISPLAY);
        STRING_CASE(CF_DSPTEXT);
        STRING_CASE(CF_DSPBITMAP);
        STRING_CASE(CF_DSPMETAFILEPICT);
        STRING_CASE(CF_DSPENHMETAFILE);

    default:
        if (! GetClipboardFormatName(ucf, s_szCFName, SIZECHARS(s_szCFName)))
            lstrcpy(s_szCFName, TEXT("UNKNOWN CLIPBOARD FORMAT"));
        pcsz = s_szCFName;
        break;
    }

    ASSERT(pcsz);

    return(pcsz);
}


LPCTSTR 
Dbg_GetHRESULTName(
    HRESULT hr)
{
    LPCTSTR pcsz;
    static TCHAR s_rgchHRESULT[] = TEXT("0x12345678");

    switch (hr)
        {
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);

        STRING_CASE(DRAGDROP_S_CANCEL);
        STRING_CASE(DRAGDROP_S_DROP);
        STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);

        STRING_CASE(CLASS_E_NOAGGREGATION);

        STRING_CASE(CO_E_NOTINITIALIZED);
        STRING_CASE(CO_E_ALREADYINITIALIZED);
        STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

        STRING_CASE(DV_E_DVASPECT);
        STRING_CASE(DV_E_LINDEX);
        STRING_CASE(DV_E_TYMED);
        STRING_CASE(DV_E_FORMATETC);

        STRING_CASE(E_FLAGS);

        STRING_CASE(URL_E_INVALID_SYNTAX);
        STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

        STRING_CASE(IS_E_EXEC_FAILED);

        STRING_CASE(E_FILE_NOT_FOUND);
        STRING_CASE(E_PATH_NOT_FOUND);

    default:
        wsprintf(s_rgchHRESULT, TEXT("%#lx"), hr);
        pcsz = s_rgchHRESULT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


/*----------------------------------------------------------
Purpose: Dump propvariant types

Returns: 
Cond:    --
*/
LPCTSTR 
Dbg_GetVTName(
    VARTYPE vt)
{
    LPCTSTR pcsz;
    static TCHAR s_szT[] = TEXT("0x12345678");

    switch (vt)
        {
        STRING_CASE(VT_EMPTY);
        STRING_CASE(VT_NULL);
        STRING_CASE(VT_I2);
        STRING_CASE(VT_I4);
        STRING_CASE(VT_R4);
        STRING_CASE(VT_R8);
        STRING_CASE(VT_CY);
        STRING_CASE(VT_DATE);
        STRING_CASE(VT_BSTR);
        STRING_CASE(VT_ERROR);
        STRING_CASE(VT_BOOL);
        STRING_CASE(VT_VARIANT);
        STRING_CASE(VT_UI1);
        STRING_CASE(VT_UI2);
        STRING_CASE(VT_UI4);
        STRING_CASE(VT_I8);
        STRING_CASE(VT_UI8);
        STRING_CASE(VT_LPSTR);
        STRING_CASE(VT_LPWSTR);
        STRING_CASE(VT_FILETIME);
        STRING_CASE(VT_BLOB);
        STRING_CASE(VT_STREAM);
        STRING_CASE(VT_STORAGE);
        STRING_CASE(VT_STREAMED_OBJECT);
        STRING_CASE(VT_STORED_OBJECT);
        STRING_CASE(VT_BLOB_OBJECT);
        STRING_CASE(VT_CLSID);
        STRING_CASE(VT_ILLEGAL);
        STRING_CASE(VT_CF);

    default:
        wsprintf(s_szT, TEXT("%#lx"), vt);
        pcsz = s_szT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


#define STRING_RIID(val)               { &val, TEXT(#val) }

//
//  Alphabetical order, please.
//

struct 
    {
    REFIID riid;
    LPCTSTR psz;
    } const c_mpriid[] = 
{
        STRING_RIID(IID_IAddressList),
        STRING_RIID(IID_IAdviseSink),
#ifdef __IAddressList_INTERFACE_DEFINED__
        STRING_RIID(IID_IAddressList),
#endif
        STRING_RIID(IID_IAugmentedShellFolder),
        STRING_RIID(IID_IAugmentedShellFolder2),
#ifdef __IAuthenticate_INTERFACE_DEFINED__
        STRING_RIID(IID_IAuthenticate),
#endif
#ifdef __IBandSiteHelper_INTERFACE_DEFINED__
        STRING_RIID(IID_IBandSiteHelper),
#endif
#ifdef __IBandProxy_INTERFACE_DEFINED__
        STRING_RIID(IID_IBandProxy),
#endif
#ifdef __IBindStatusCallback_INTERFACE_DEFINED__
        STRING_RIID(IID_IBindStatusCallback),
#endif
        STRING_RIID(IID_IBrowserBand),
#ifdef __IBrowserService_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserService),
#endif
        STRING_RIID(IID_IBrowserService2),
        STRING_RIID(IID_IConnectionPoint),
#ifdef __IConnectionPointCB_INTERFACE_DEFINED__
        STRING_RIID(IID_IConnectionPointCB),
#endif
        STRING_RIID(IID_IConnectionPointContainer),
        STRING_RIID(IID_IContextMenu),
        STRING_RIID(IID_IContextMenu2),
        STRING_RIID(IID_IContextMenuCB),
        STRING_RIID(IID_IContextMenuSite),
        STRING_RIID(IID_IDataObject),
        STRING_RIID(IID_IDeskBand),
        STRING_RIID(IID_IDispatch),
        STRING_RIID(IID_IDocFindBrowser),
        STRING_RIID(IID_IDocFindFileFilter),
#ifdef __IDocHostUIHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_IDocHostUIHandler),
#endif
        STRING_RIID(IID_IDockingWindowFrame),
        STRING_RIID(IID_IDockingWindow),
        STRING_RIID(IID_IDockingWindowSite),
#ifdef __IDocNavigate_INTERFACE_DEFINED__
        STRING_RIID(IID_IDocNavigate),
#endif
        STRING_RIID(IID_IDocViewSite),
        STRING_RIID(IID_IDropTarget),
        STRING_RIID(IID_IDropTargetBackground),
#ifdef __IEFrameAuto_INTERFACE_DEFINED__
        STRING_RIID(IID_IEFrameAuto),
#endif        
        STRING_RIID(IID_IEnumUnknown),
        STRING_RIID(IID_IErrorInfo),
#ifdef __IExpDispSupport_INTERFACE_DEFINED__
        STRING_RIID(IID_IExpDispSupport),
#endif
#ifdef __IExpDispSupportOC_INTERFACE_DEFINED__
        STRING_RIID(IID_IExpDispSupportOC),
#endif
        STRING_RIID(IID_IExplorerToolbar),
        STRING_RIID(IID_IExtractIcon),
        STRING_RIID(IID_IExternalConnection),
        STRING_RIID(IID_FavoriteMenu),
#ifdef __IHistSFPrivate_INTERFACE_DEFINED__
        STRING_RIID(IID_IHistSFPrivate),
#endif
#ifdef __IHlink_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlink),
#endif
#ifdef __IHlinkFrame_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkFrame),
#endif
#ifdef __IHlinkSite_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkSite),
#endif
#ifdef __IHlinkTarget_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkTarget),
#endif
#ifdef __IHttpNegotiate_INTERFACE_DEFINED__
        STRING_RIID(IID_IHttpNegotiate),
#endif
#ifdef __IHttpSecurity_INTERFACE_DEFINED__
        STRING_RIID(IID_IHttpSecurity),
#endif
        STRING_RIID(IID_IInputObject),
        STRING_RIID(IID_IInputObjectSite),
        STRING_RIID(IID_IIsWebBrowserSB),
        STRING_RIID(IID_IMenuBand),
#ifdef __IMRU_INTERFACE_DEFINED__
        STRING_RIID(IID_IMRU),
#endif
#ifdef __INavigationStack_INTERFACE_DEFINED__
        STRING_RIID(IID_INavigationStack),
#endif
#ifdef __INavigationStackItem_INTERFACE_DEFINED__
        STRING_RIID(IID_INavigationStackItem),
#endif
        STRING_RIID(IID_INewShortcutHook),
#ifdef __IObjectCache_INTERFACE_DEFINED__
        STRING_RIID(IID_IObjectCache),
#endif
#ifdef __IObjectSafety_INTERFACE_DEFINED__
        STRING_RIID(IID_IObjectSafety),
#endif
        STRING_RIID(IID_IOleClientSite),
        STRING_RIID(IID_IOleCommandTarget),
        STRING_RIID(IID_IOleContainer),
        STRING_RIID(IID_IOleControl),
        STRING_RIID(IID_IOleControlSite),
        STRING_RIID(IID_IOleDocument),
        STRING_RIID(IID_IOleDocumentSite),
        STRING_RIID(IID_IOleDocumentView),
        STRING_RIID(IID_IOleInPlaceActiveObject),
        STRING_RIID(IID_IOleInPlaceFrame),
        STRING_RIID(IID_IOleInPlaceSite),
        STRING_RIID(IID_IOleInPlaceObject),
        STRING_RIID(IID_IOleInPlaceUIWindow),
        STRING_RIID(IID_IOleObject),
        STRING_RIID(IID_IOleWindow),
        STRING_RIID(IID_IPersist),
        STRING_RIID(IID_IPersistFolder),
#ifdef __IPersistMoniker_INTERFACE_DEFINED__
        STRING_RIID(IID_IPersistMoniker),
#endif
        STRING_RIID(IID_IPersistPropertyBag),
        STRING_RIID(IID_IPersistStorage),
        STRING_RIID(IID_IPersistStream),
        STRING_RIID(IID_IPersistStreamInit),
        STRING_RIID(IID_IPersistString),
        STRING_RIID(IID_IProvideClassInfo),
        STRING_RIID(IID_IPropertyNotifySink),
        STRING_RIID(IID_IPropertySetStorage),
        STRING_RIID(IID_IPropertyStorage),
        STRING_RIID(IID_IProxyShellFolder),
        STRING_RIID(IID_IServiceProvider),
        STRING_RIID(IID_ISetWinHandler),
        STRING_RIID(IID_IShellBrowser),
        STRING_RIID(IID_IShellChangeNotify),
        STRING_RIID(IID_IShellDetails),
        STRING_RIID(IID_IShellDetails2),
        STRING_RIID(IID_IShellExtInit),
        STRING_RIID(IID_IShellFolder),
        STRING_RIID(IID_IShellIcon),
        STRING_RIID(IID_IShellLink),
        STRING_RIID(IID_IShellLinkDataList),
        STRING_RIID(IID_IShellMenu),
        STRING_RIID(IID_IShellMenuCallback),
        STRING_RIID(IID_IShellPropSheetExt),
#ifdef __IShellService_INTERFACE_DEFINED__
        STRING_RIID(IID_IShellService),
#endif
        STRING_RIID(IID_IShellView),
        STRING_RIID(IID_IShellView2),
#ifdef __ITargetEmbedding_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetEmbedding),
#endif
#ifdef __ITargetFrame2_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetFrame2),
#endif
#ifdef __ITargetFramePriv_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetFramePriv),
#endif
        STRING_RIID(IID_ITravelEntry),
        STRING_RIID(IID_ITravelLog),
        STRING_RIID(IID_IUniformResourceLocator),
        STRING_RIID(IID_IUnknown),
        STRING_RIID(IID_IViewObject),
        STRING_RIID(IID_IViewObject2),
        STRING_RIID(IID_IWebBrowser),
        STRING_RIID(IID_IWebBrowser2),
        STRING_RIID(IID_IWebBrowserApp),
        STRING_RIID(IID_IWinEventHandler),
};

struct 
{
    IID iid;
    TCHAR szGuid[GUIDSTR_MAX];
} s_guid[50] = {0};

LPCTSTR
Dbg_GetREFIIDName(
    REFIID riid)
{
    int i;

    // search the known list
    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return c_mpriid[i].psz;
        }

    // get a display name for the the first few unknown requests
    for (i = 0; i < ARRAYSIZE(s_guid); i++)
        {
        if (TEXT('{') /*}*/ == s_guid[i].szGuid[0])
            {
            if (IsEqualIID(riid, &s_guid[i].iid))
                return s_guid[i].szGuid;
            }
        else
            {
            s_guid[i].iid = *riid;
            SHStringFromGUID(riid, s_guid[i].szGuid, ARRAYSIZE(s_guid[0].szGuid));
            return s_guid[i].szGuid;
            }
        }

    return TEXT("Unknown REFIID");
}

//***
// NOTE
//  must be called *after* Dbg_GetREFIIDName (since that is what creates entry)
void *
Dbg_GetREFIIDAtom(
    REFIID riid)
{
    int i;

    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return (void *) c_mpriid[i].riid;
        }

    // get a display name for the the first few unknown requests
    for (i = 0; i < ARRAYSIZE(s_guid); i++)
        {
        if (TEXT('{') /*}*/ == s_guid[i].szGuid[0])
            {
            if (IsEqualIID(riid, &s_guid[i].iid))
                return (void *) &s_guid[i].iid;
            }
        else
            {
            return NULL;
            }
        }

    return NULL;
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\dpastuff.cpp ===
#include "priv.h"
#include "dpastuff.h"

//
//  The ORDERITEM structure is exposed via the IOrderList interface.
//  ORDERITEM2 contains our private hidden fields.
//
//  The extra fields contain information about the cached icon location.
//
//  ftModified is the modify-time on the pidl, which is used to detect
//  whether the cache needs to be refreshed.
//
//  If ftModified is nonzero, then { pwszIcon, iIconIndex, pidlTarget }
//  describe the icon that should be displayed for the item.
//
//  If pwszIcon is nonzero, then the item is a shortcut with a custom
//  icon.  pwszIcon points to the file name for the icon, iIconIndex
//  is the icon index within the pwszIcon file.
//
//  If pidlTarget is nonzero, then the item is a shortcut with a default
//  icon.  pidlTarget is the target pidl, whose icon we should use.
//

typedef struct ORDERITEM2 {
    ORDERITEM oi;               // part that clients see - must come first
    DWORD  dwFlags;             // User defined flags.
    LPWSTR pwszIcon;            // for cacheing the icon location
    int iIconIndex;             // for cacheing the icon location
    LPITEMIDLIST pidlTarget;    // use the icon for this pidl
} ORDERITEM2, *PORDERITEM2;

int CALLBACK OrderItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    PORDERITEM  poi1 = (PORDERITEM)pv1;
    PORDERITEM  poi2 = (PORDERITEM)pv2;
    PORDERINFO  poinfo = (PORDERINFO)lParam;
    int nRet;

    if (!poinfo)
    {   
        ASSERT(FALSE);
        return 0;
    }
    switch (poinfo->dwSortBy)
    {
    case OI_SORTBYNAME:
    {
        // Make sure they're both non-null
        //
        if ( poi1->pidl && poi2->pidl )
        {
            HRESULT hres = poinfo->psf->CompareIDs(0, poi1->pidl, poi2->pidl);
            nRet = (short)HRESULT_CODE(hres);
        }
        else
        {
            if ( poi1->pidl == poi2->pidl )
                nRet = 0;
            else
                nRet = ((UINT_PTR)poi1->pidl < (UINT_PTR)poi2->pidl ? -1 : 1);
        }

        break;
    }

    case OI_SORTBYORDINAL:
        if (poi1->nOrder == poi2->nOrder)
            nRet = 0;
        else
            // do unsigned compare so -1 goes to end of list
            nRet = ((UINT)poi1->nOrder < (UINT)poi2->nOrder ? -1 : 1);
        break;

    default:
        ASSERT_MSG(0, "Bad dwSortBy passed to OrderItem_Compare");
        nRet = 0;
        break;
    }

    return nRet;
}

void OrderItem_FreeIconInfo(PORDERITEM poi)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    if (poi2->pwszIcon)
    {
        LPWSTR pwszIcon = poi2->pwszIcon;
        poi2->pwszIcon = NULL;
        LocalFree(pwszIcon);
    }

    if (poi2->pidlTarget)
    {
        LPITEMIDLIST pidl = poi2->pidlTarget;
        poi2->pidlTarget = NULL;
        ILFree(pidl);
    }
}


LPVOID CALLBACK OrderItem_Merge(UINT uMsg, LPVOID pvDst, LPVOID pvSrc, LPARAM lParam)
{
    PORDERITEM2 poi2Dst = CONTAINING_RECORD(pvDst, ORDERITEM2, oi);
    PORDERITEM2 poi2Src = CONTAINING_RECORD(pvSrc, ORDERITEM2, oi);
    PORDERINFO  poinfo = (PORDERINFO)lParam;
    LPVOID pvRet = pvDst;

    switch (uMsg)
    {
    case DPAMM_MERGE:
        // Transfer the order field
        poi2Dst->oi.nOrder = poi2Src->oi.nOrder;

        // Propagate any cached icon information too...
        if (poi2Src->pwszIcon || poi2Src->pidlTarget)
        {
            // To avoid useless allocation, we transfer the cache across
            // instead of copying it.
            if (poinfo->psf2 &&
                poinfo->psf2->CompareIDs(SHCIDS_ALLFIELDS, poi2Dst->oi.pidl, poi2Src->oi.pidl) == S_OK)
            {
                OrderItem_FreeIconInfo(&poi2Dst->oi);
                CopyMemory((LPBYTE)poi2Dst + sizeof(ORDERITEM),
                           (LPBYTE)poi2Src  + sizeof(ORDERITEM),
                           sizeof(ORDERITEM2) - sizeof(ORDERITEM));
                ZeroMemory((LPBYTE)poi2Src  + sizeof(ORDERITEM),
                           sizeof(ORDERITEM2) - sizeof(ORDERITEM));
            }
        }
        break;

    case DPAMM_DELETE:
    case DPAMM_INSERT:
        // Don't need to implement this
        ASSERT(0);
        pvRet = NULL;
        break;
    }
    
    return pvRet;
}

int OrderItem_UpdatePos(LPVOID p, LPVOID pData)
{
    PORDERITEM poi = (PORDERITEM)p;

    if (-1 == poi->nOrder)
    {
        poi->nOrder = (int)(INT_PTR)pData;
    }
    else if ((int)(INT_PTR)pData >= poi->nOrder)
    {
        poi->nOrder++;
    }

    return 1;
}

// OrderList_Merge sorts hdpaNew to match hdpaOld order,
// putting any items in hdpaNew that were not in hdpaOld
// at position iInsertPos (-1 means end of list).
//
// Assumes hdpaOld is already sorted by sort order in lParam (OI_SORTBYNAME by default)
// (if hdpaOld is specified)
//
void OrderList_Merge(HDPA hdpaNew, HDPA hdpaOld, int iInsertPos, LPARAM lParam,
                     LPFNORDERMERGENOMATCH pfn, LPVOID pvParam)
{
    PORDERINFO poinfo = (PORDERINFO)lParam;

    BOOL fMergeOnly = FALSE;
    if (poinfo->dwSortBy == OI_MERGEBYNAME)
    {
        poinfo->dwSortBy = OI_SORTBYNAME;
        fMergeOnly = TRUE;
    }

    // hdpaNew has not been sorted, sort by name
    DPA_Sort(hdpaNew, OrderItem_Compare, lParam);
    BOOL fForceNoMatch = FALSE;

    if (FAILED(poinfo->psf->QueryInterface(IID_IShellFolder2, (LPVOID *)&poinfo->psf2))) {
        // 239390: Network Connections folder doesn't implement QI correctly.  Its psf 
        // fails QI for IID_IShellFolder2, but doesn't null out ppvObj.  So do it for them.
        poinfo->psf2 = NULL;
    }

    // Copy order preferences over from old list to new list
    if (hdpaOld)
    {
        DPA_Merge(hdpaNew, hdpaOld, DPAM_SORTED | DPAM_NORMAL, OrderItem_Compare, OrderItem_Merge, lParam);

        // If we're waiting for the notify from a drag&drop operation,
        // update the new items (they will have a -1) to the insert position.
        if (-1 != iInsertPos)
        {
            DPA_EnumCallback(hdpaNew, OrderItem_UpdatePos, (LPVOID)(INT_PTR)iInsertPos);
        }

        if (poinfo->dwSortBy != OI_SORTBYORDINAL && !fMergeOnly)
        {
            poinfo->dwSortBy = OI_SORTBYORDINAL;
            DPA_Sort(hdpaNew, OrderItem_Compare, lParam);
        }
    }
    else
        fForceNoMatch = TRUE;

    // If the caller passed a NoMatch callback, then call it with
    // each item that is not matched.
    if (pfn)
    {
        for (int i = DPA_GetPtrCount(hdpaNew)-1 ; i >= 0 ; i--)
        {
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpaNew, i);

            // Does this item have order information?
            if (iInsertPos == poi->nOrder ||
                -1 == poi->nOrder ||
                fForceNoMatch)
            {
                // No; Then pass to the "No Match" callback
                pfn(pvParam, poi->pidl);
            }
        }
    }

    ATOMICRELEASE(poinfo->psf2);

    OrderList_Reorder(hdpaNew);
}

// OrderList_Reorder refreshes the order info
void OrderList_Reorder(HDPA hdpa)
{
    int i;

    for (i = DPA_GetPtrCount(hdpa)-1 ; i >= 0 ; i--)
    {
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);

        poi->nOrder = i;
    }
}

BOOL OrderList_Append(HDPA hdpa, LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        if (-1 != DPA_AppendPtr(hdpa, poi))
            return TRUE;

        OrderItem_Free(poi);
    }
    return FALSE;
}

// This differes from DPA_Clone in that it allocates new items!
HDPA OrderList_Clone(HDPA hdpa)
{
    HDPA hdpaNew = NULL;

    if (EVAL(hdpa))
    {
        hdpaNew = DPA_Create(DPA_GetPtrCount(hdpa));
    
        if (hdpaNew)
        {
            int i;
    
            for (i = 0 ; i < DPA_GetPtrCount(hdpa) ; i++)
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);
                LPITEMIDLIST pidl = ILClone(poi->pidl);
                if (pidl)
                {
                    if (!OrderList_Append(hdpaNew, pidl, poi->nOrder))
                    {
                        ILFree(pidl);
                    }
                }
            }
        }
    }

    return hdpaNew;
}

// Does not clone the pidl but will free it.
// Does not addref the psf nor release it.
PORDERITEM OrderItem_Create(LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM2 poi = (PORDERITEM2)LocalAlloc(LPTR, SIZEOF(ORDERITEM2));

    if (poi)
    {
        poi->oi.pidl = pidl;
        poi->oi.nOrder = nOrder;
        return &poi->oi;
    }

    return NULL;
}

void OrderItem_Free(PORDERITEM poi, BOOL fKillPidls /* = TRUE */)
{
    if (fKillPidls)
        ILFree(poi->pidl);
    OrderItem_FreeIconInfo(poi);
    LocalFree(poi);
}

int OrderItem_FreeItem(LPVOID p, LPVOID pData)
{
    PORDERITEM poi = (PORDERITEM)p;

    OrderItem_Free(poi, (BOOL)(INT_PTR)pData);

    return 1;
}

void OrderList_Destroy(HDPA* phdpa, BOOL fKillPidls /* = fTrue */)
{
    if (*phdpa) {
        DPA_DestroyCallback(*phdpa, OrderItem_FreeItem, (LPVOID) (INT_PTR)fKillPidls);
        *phdpa = NULL;
    }
}

//
//  Return values:
//
//  S_OK    - icon obtained successfully
//  S_FALSE - icon not obtained, don't waste time trying
//  E_FAIL  - no cached icon, need to do more work
//
HRESULT OrderItem_GetSystemImageListIndexFromCache(PORDERITEM poi,
                                        IShellFolder *psf, int *piOut)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    IShellFolder *psfT;
    LPCITEMIDLIST pidlItem;
    HRESULT hr;

    // Do we have a cached icon location?
    if (poi2->pwszIcon)
    {
        *piOut = 0;
        // Validate Path existance.
        if (PathFileExistsW(poi2->pwszIcon))
        {
            *piOut = _WorA_Shell_GetCachedImageIndex(poi2->pwszIcon, poi2->iIconIndex, GIL_PERINSTANCE);
        }

        return (*piOut > 0)? S_OK : E_FAIL;
    }

    // Do we have a cached pidlTarget?
    if (poi2->pidlTarget)
    {
        hr = SHBindToIDListParent(poi2->pidlTarget, IID_IShellFolder, (void**)&psfT, &pidlItem);
        if (SUCCEEDED(hr))
        {
            // Make sure the pidl exsists before binding. because the bind does succeed if it does not exist.
            DWORD dwAttrib = SFGAO_VALIDATE;
            hr = psfT->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &dwAttrib);
            if (SUCCEEDED(hr))
            {
                *piOut = SHMapPIDLToSystemImageListIndex(psfT, pidlItem, NULL);
            }
            psfT->Release();
            return hr;
        }

        // Bind failed - shortcut target was deleted
        // Keep the cache valid because we don't want to whack the disk
        // all the time only to discover it's busted.
        return E_FAIL;
    }

    return E_FAIL;
}

DWORD OrderItem_GetFlags(PORDERITEM poi)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    return poi2->dwFlags;
}

void OrderItem_SetFlags(PORDERITEM poi, DWORD dwFlags)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    poi2->dwFlags = dwFlags;
}


int OrderItem_GetSystemImageListIndex(PORDERITEM poi, IShellFolder *psf, BOOL fUseCache)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    HRESULT hr;
    int iBitmap;
    DWORD dwAttr;

    if (fUseCache)
    {
        hr = OrderItem_GetSystemImageListIndexFromCache(poi, psf, &iBitmap);
        if (SUCCEEDED(hr))
        {
            return iBitmap;
        }
        else
        {
            goto Fallback;
        }
    }
    else
    {
        //
        // Free any pointers we cached previously
        //
        if (poi2->pidlTarget)
        {
            ILFree(poi2->pidlTarget);
            poi2->pidlTarget = NULL;
        }

        Str_SetPtr(&poi2->pwszIcon, NULL);
    }

    //
    //  Go find the icon.
    //
    ASSERT(poi2->pidlTarget == NULL);
    ASSERT(poi2->pwszIcon == NULL);

    //
    //  Is this item shortcutlike at all?
    //
    dwAttr = SFGAO_LINK;
    hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&poi->pidl, &dwAttr);
    if (FAILED(hr) || !(dwAttr & SFGAO_LINK))
        goto Fallback;                  // not a shortcut; use the fallback

    //
    // Must go for ANSI version first because client might not support
    // UNICODE.
    //
    // BUGBUG - should QI for IExtractIcon to see if we get GIL_DONTCACHE
    // back.

    IShellLinkA *pslA;
    hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&poi->pidl,
                            IID_IShellLinkA, 0, (LPVOID *)&pslA);

    if (FAILED(hr))
        goto Fallback;

    //
    //  If there's a UNICODE version, that's even better.
    //
    IShellLinkW *pslW;
    WCHAR wszIconPath[MAX_PATH];

    hr = pslA->QueryInterface(IID_IShellLinkW, (LPVOID *)&pslW);
    if (SUCCEEDED(hr))
    {
        hr = pslW->GetIconLocation(wszIconPath, ARRAYSIZE(wszIconPath), &poi2->iIconIndex);
        pslW->Release();
    }
    else
    {
        // Only IShellLinkA supported.  Thunk to UNICODE manually.
        CHAR szIconPath[ARRAYSIZE(wszIconPath)];
        hr = pslA->GetIconLocation(szIconPath, ARRAYSIZE(szIconPath), &poi2->iIconIndex);
        if (SUCCEEDED(hr))
            SHAnsiToUnicode(szIconPath, wszIconPath, ARRAYSIZE(wszIconPath));
    }

    // If we have a custom icon path, then save that
    if (SUCCEEDED(hr) && wszIconPath[0])
    {
        Str_SetPtr(&poi2->pwszIcon, wszIconPath);
    }
    else
    {
        // No icon path, get the target instead
        pslA->GetIDList(&poi2->pidlTarget);

        if (IsURLChild(poi2->pidlTarget, TRUE))
        {
            // If this is a url, we want to go to the "Fallback" case. The reason for this
            // is that the fallback case will go through 
            // where we will end up with the generic icon for .url files
            ILFree(poi2->pidlTarget);
            poi2->pidlTarget = NULL;

            pslA->Release();
            goto Fallback;
        }
    }

    pslA->Release();

    //
    //  Aw-right, the cache is all loaded up.  Let's try that again.
    //
    hr = OrderItem_GetSystemImageListIndexFromCache(poi, psf, &iBitmap);
    if (hr == S_OK)
    {
        return iBitmap;
    }

Fallback:
    return SHMapPIDLToSystemImageListIndex(psf, poi->pidl, NULL);
}


// Header for file menu streams
//
// The file menu stream consists of an IOSTREAMHEADER followed by
// a DPA_SaveStream of the order DPA.  Each item in the DPA consists
// of an OISTREAMITEM.
//
// To keep roaming profiles working between NT4 (IE4) and NT5 (IE5),
// the dwVersion used by NT5 must be the same as that used by NT4.
// I.e., it must be 2.

typedef struct tagOISTREAMHEADER
{
    DWORD cbSize;           // Size of header
    DWORD dwVersion;        // Version of header
} OISTREAMHEADER;

#define OISTREAMHEADER_VERSION  2

//
//  Each item in a persisted order DPA consists of an OISTREAMITEM
//  followed by additional goo.  All pidls stored include the
//  terminating (USHORT)0.
//
//  IE4:
//      OISTREAMITEM
//      pidl                    - the item itself
//
//  IE5 - shortcut has custom icon
//      OISTREAMITEM
//      pidl                    - the item itself (last-modify time implied)
//      <optional padding>      - for WCHAR alignment
//      dwFlags                 - User defined Flags
//      dwStringLen             - Length of the icon path 
//      UNICODEZ iconpath       - icon path
//      iIconIndex              - icon index
//
//  IE5 - shortcut takes its icon from another pidl
//      OISTREAMITEM
//      pidl                    - the item itself (last-modify time implied)
//      <optional padding>      - for WCHAR alignment
//      dwFlags                 - User defined Flags
//      (DWORD)0                - null string indicates "no custom icon"
//      pidlTarget              - use the icon for this pidl
//

typedef struct tagOISTREAMITEM
{
    DWORD cbSize;           // Size including trailing goo
    int   nOrder;           // User-specified order

    // variable-sized trailing goo comes here.
    //
    // See above for description of trailing goo.

} OISTREAMITEM;

#define CB_OISTREAMITEM     (sizeof(OISTREAMITEM))

//
//  Save a component of the orderitem to the stream.  If an error has
//  already occurred on the stream, *phrRc contains the old error code,
//  and we write nothing.
//
//  If pstm == NULL, then we are not actually writing anything.  We are
//  merely doing a dry run.
//
//  Otherwise, *phrRc accumulates the number of bytes actually written,
//  or receives an error code on failure.
//

void
OrderItem_SaveSubitemToStream(IStream *pstm, LPCVOID pvData, ULONG cb, HRESULT* phrRc)
{
    HRESULT hres;

    if (SUCCEEDED(*phrRc))
    {
        if (pstm)
        {
            hres = IStream_Write(pstm, (LPVOID)pvData, cb);
            if (SUCCEEDED(hres))
            {
                *phrRc += cb;           // successful write - accumulate
            }
            else
            {
                *phrRc = hres;          // error - return error code
            }
        }
        else
        {
            *phrRc += cb;               // no output stream - accumulate
        }
    }
}

//
//  This worker function (1) computes the numer of bytes we will actually
//  write out, and (2) actually writes it if pstm != NULL.
//
//  Return value is the number of bytes written (or would have been
//  written), or a COM error code on failure.
//

const BYTE c_Zeros[2] = { 0 };    // a bunch of zeros

HRESULT
OrderItem_SaveToStreamWorker(PORDERITEM2 poi2, OISTREAMITEM *posi,
                             IStream *pstm, IShellFolder2 *psf2)
{
    HRESULT hrRc = 0;           // no bytes, no error

    ASSERT(poi2->oi.pidl);

    //
    //  First comes the header.
    //
    OrderItem_SaveSubitemToStream(pstm, posi, CB_OISTREAMITEM, &hrRc);

    //
    //  Then the pidl.
    //

    // We're assuming this is an immediate child pidl.  If it's not,
    // the pidl is being truncated!
    ASSERT(0 == _ILNext(poi2->oi.pidl)->mkid.cb);

    OrderItem_SaveSubitemToStream(pstm, poi2->oi.pidl,
                                  poi2->oi.pidl->mkid.cb + sizeof(USHORT),
                                  &hrRc);
    // Insert padding to get back to WCHAR alignment.
    if (hrRc % sizeof(WCHAR)) 
    {
        OrderItem_SaveSubitemToStream(pstm, &c_Zeros, 1, &hrRc);
    }

    OrderItem_SaveSubitemToStream(pstm, &poi2->dwFlags, sizeof(DWORD), &hrRc);

    //
    //  If we haven't barfed yet and the IShellFolder supports identity
    //  and there is icon information, then save it.
    //
    if (SUCCEEDED(hrRc) && psf2 && (poi2->pwszIcon || poi2->pidlTarget))
    {
        // Optional icon is present. 

        if (poi2->pwszIcon)
        {
            // UNICODEZ path
            DWORD cbString = (lstrlenW(poi2->pwszIcon) + 1) * sizeof(WCHAR);

            // Save the String len
            OrderItem_SaveSubitemToStream(pstm, &cbString,
                      sizeof(DWORD) , &hrRc);

            OrderItem_SaveSubitemToStream(pstm, poi2->pwszIcon,
                      (lstrlenW(poi2->pwszIcon) + 1) * sizeof(WCHAR), &hrRc);

            // icon index
            OrderItem_SaveSubitemToStream(pstm, &poi2->iIconIndex,
                      sizeof(poi2->iIconIndex), &hrRc);
        }
        else
        {
            DWORD cbString = 0;
            OrderItem_SaveSubitemToStream(pstm, &cbString, sizeof(DWORD), &hrRc);

            // pidlTarget
            OrderItem_SaveSubitemToStream(pstm, poi2->pidlTarget,
                      ILGetSize(poi2->pidlTarget), &hrRc);
        }
    }
    return hrRc;
}

HRESULT 
CALLBACK 
OrderItem_SaveToStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    PORDERITEM2 poi2 = (PORDERITEM2)pinfo->pvItem;
    HRESULT hres = S_FALSE;
    IShellFolder2 *psf2 = (IShellFolder2 *)pvData;

    if (poi2->oi.pidl)
    {
        OISTREAMITEM osi;

        // First a dry run to compute the size of this item.
        hres = OrderItem_SaveToStreamWorker(poi2, NULL, NULL, psf2);

        // Nothing actually got written, so this should always succeed.
        ASSERT(SUCCEEDED(hres));

        osi.cbSize = hres;
        osi.nOrder = poi2->oi.nOrder;

        // Now write it out for real
        hres = OrderItem_SaveToStreamWorker(poi2, &osi, pstm, psf2);

        // On success, we must return exactly S_OK or DPA will blow us off
        if (SUCCEEDED(hres))
            hres = S_OK;
    }

    return hres;
}   

//
//  Check if a pidl we read out of a stream is a simple child pidl.
//  The pidl must be exactly cb bytes in length.
//  The pointer is known to be valid;
//  we just want to check that the contents are good, too.
//
BOOL
IsValidPersistedChildPidl(LPCITEMIDLIST pidl, UINT cb)
{
    // Must have at least room for one byte of pidl plus the terminating
    // zero.
    if (cb < 1 + sizeof(USHORT))
        return FALSE;

    // Make sure size is at least what it's supposed to be.
    if (pidl->mkid.cb + sizeof(USHORT) > cb)
        return FALSE;

    // Make sure there's a zero right after it.
    pidl = _ILNext(pidl);
    return pidl->mkid.cb == 0;
}

//
//  Just like ILGetSize, but returns (UINT)-1 if the pidl is corrupt.
//  We use (UINT)-1 as the return value because it will be bigger than
//  the buffer size we eventually compare it against.
UINT
SafeILGetSize(LPCITEMIDLIST pidl)
{
    _try {
        return ILGetSize(pidl);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
    }
    __endexcept
    return (UINT)-1;
}

HRESULT
CALLBACK 
OrderItem_LoadFromStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID /*pvData*/)
{
    HRESULT hres;
    OISTREAMITEM osi;

    hres = IStream_Read(pstm, &osi, CB_OISTREAMITEM);
    if (SUCCEEDED(hres))
    {
        ASSERT(CB_OISTREAMITEM < osi.cbSize);
        if (CB_OISTREAMITEM < osi.cbSize)
        {
            UINT cb = osi.cbSize - CB_OISTREAMITEM;
            LPITEMIDLIST pidl = IEILCreate(cb);
            if ( !pidl )
                hres = E_OUTOFMEMORY;
            else
            {
                hres = IStream_Read(pstm, pidl, cb);
                if (SUCCEEDED(hres) && IsValidPersistedChildPidl(pidl, cb))
                {
                    PORDERITEM poi = OrderItem_Create(pidl, osi.nOrder);

                    if (poi)
                    {
                        PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
                        pinfo->pvItem = poi;
                        // cbPos = offset to trailing gunk after pidl
                        UINT cbPos = pidl->mkid.cb + sizeof(USHORT);
                        cbPos = ROUNDUP(cbPos, sizeof(WCHAR));

                        // Do we have a DWORD hanging off the end of the pidl? This should be the flags.
                        if (cb >= cbPos + sizeof(DWORD))
                        {
                            poi2->dwFlags = *(UNALIGNED DWORD*)((LPBYTE)pidl + cbPos);
                        }

                        // Make sure there's at least a WCHAR to test against.
                        if (cb >= cbPos + sizeof(WCHAR) + 2 * sizeof(DWORD))
                        {
                            DWORD cbString = *(UNALIGNED DWORD*)((LPBYTE)pidl + cbPos + sizeof(DWORD));
                            LPWSTR pwszIcon = (LPWSTR)((LPBYTE)pidl + cbPos + 2 * sizeof(DWORD));

                            // Do we have a string lenght?
                            if (pwszIcon && cbString != 0)
                            {
                                // Yes, then this is a string not a pidl. We want to make sure this is a
                                // fully qualified path.
                                if (IS_VALID_STRING_PTRW(pwszIcon, cbString) &&
                                    !PathIsRelative(pwszIcon))
                                {
                                    poi2->pwszIcon = StrDup(pwszIcon);
                                    pwszIcon += lstrlenW(pwszIcon) + 1;
                                    poi2->iIconIndex = *(UNALIGNED int *)pwszIcon;
                                }
                            }
                            else
                            {
                                // A string length of zero is 
                                LPITEMIDLIST pidlTarget = (LPITEMIDLIST)(pwszIcon);
                                // We want to write
                                // cbPos + sizeof(WCHAR) + SafeILGetSize(pidlTarget) <= cb
                                // but SafeILGetSize returns (UINT)-1 on error, so we need
                                // to do some algebra to avoid overflows
                                if (SafeILGetSize(pidlTarget) <= cb - cbPos - 2 * sizeof(DWORD))
                                {
                                    poi2->pidlTarget = ILClone(pidlTarget);
                                }
                            }
                        }

                        hres = E_OUTOFMEMORY;

                        // pidl Contains extranious information. Take the hit of stripping it so that
                        // our working set doesn't bloat.
                        LPITEMIDLIST pidlNew = ILClone(poi2->oi.pidl);
                        if (pidlNew)
                        {
                            ILFree(poi2->oi.pidl);
                            poi2->oi.pidl = pidlNew;
                            hres = S_OK;
                        }
                    }
                    else
                        hres = E_OUTOFMEMORY;
                }
                else
                    hres = E_FAIL;

                // Cleanup
                if (FAILED(hres))
                    ILFree(pidl);
            }
        }
        else
            hres = E_FAIL;

    }

    ASSERT((S_OK == hres && pinfo->pvItem) || FAILED(hres));
    return hres;
}    

HRESULT OrderList_LoadFromStream(IStream* pstm, HDPA * phdpa, IShellFolder * psfParent)
{
    HDPA hdpa = NULL;
    OISTREAMHEADER oish;

    ASSERT(phdpa);
    ASSERT(pstm);

    // Read the header for more info
    if (SUCCEEDED(IStream_Read(pstm, &oish, sizeof(oish))) &&
        sizeof(oish) == oish.cbSize)
    {
        // Load the stream.  (Should be ordered by name.)
        DPA_LoadStream(&hdpa, OrderItem_LoadFromStream, pstm, psfParent);
        
        // if this is the wrong version, throw away the pidls.
        // we go through the load anyways to make suret he read pointer is set right
        if (OISTREAMHEADER_VERSION != oish.dwVersion)
            OrderList_Destroy(&hdpa, TRUE);
        
    }

    *phdpa = hdpa;

    return (NULL != hdpa) ? S_OK : E_FAIL;
}

HRESULT OrderList_SaveToStream(IStream* pstm, HDPA hdpaSave, IShellFolder *psf)
{
    HRESULT hres = E_OUTOFMEMORY;
    OISTREAMHEADER oish;
    HDPA hdpa;

    // Clone the array and sort by name for the purpose of persisting it
    hdpa = DPA_Clone(hdpaSave, NULL);
    if (hdpa)
    {
        ORDERINFO   oinfo = {0};
#ifdef DEBUG
        // use QI to help track down leaks
        if (psf)
            EVAL(SUCCEEDED(psf->QueryInterface(IID_IShellFolder, (LPVOID *)&oinfo.psf)));
#else
        oinfo.psf = psf;
        if (psf)
            oinfo.psf->AddRef();
#endif
        oinfo.dwSortBy = OI_SORTBYNAME;
        DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);

        // Save the header
        oish.cbSize = sizeof(oish);
        oish.dwVersion = OISTREAMHEADER_VERSION;

        hres = IStream_Write(pstm, &oish, sizeof(oish));
        if (SUCCEEDED(hres))
        {
            if (psf)
                oinfo.psf->QueryInterface(IID_IShellFolder2, (LPVOID *)&oinfo.psf2);
            hres = DPA_SaveStream(hdpa, OrderItem_SaveToStream, pstm, oinfo.psf2);
            ATOMICRELEASE(oinfo.psf2);
        }
        ATOMICRELEASE(oinfo.psf);
        DPA_Destroy(hdpa);
    }

    return hres;
}    

/////////////
//
// COrderList impl for export to channel installer
//

class COrderList  : public IPersistFolder, 
                    public IOrderList2
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IPersistFolder
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IOrderList
    virtual STDMETHODIMP GetOrderList(HDPA * phdpa);
    virtual STDMETHODIMP SetOrderList(HDPA hdpa, IShellFolder *psf);
    virtual STDMETHODIMP FreeOrderList(HDPA hdpa);

    virtual STDMETHODIMP SortOrderList(HDPA hdpa, DWORD dw);

    virtual STDMETHODIMP AllocOrderItem(PORDERITEM * ppoi, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP FreeOrderItem(PORDERITEM poi);

    // IOrderList 2
    virtual STDMETHODIMP LoadFromStream(IStream* pstm, HDPA* hdpa, IShellFolder* psf);
    virtual STDMETHODIMP SaveToStream(IStream* pstm, HDPA hdpa);

protected:
    COrderList(IUnknown* punkOuter, LPCOBJECTINFO poi);
    friend IUnknown * COrderList_Create();

    COrderList();
    ~COrderList();

    int _cRef;
    IShellFolder *_psf;
    LPITEMIDLIST  _pidl;
    LPITEMIDLIST  _pidlFavorites;
};

COrderList::COrderList()
{
    _cRef = 1;
    DllAddRef();
}

COrderList::~COrderList()
{
    ILFree(_pidl);
    ILFree(_pidlFavorites);
    ATOMICRELEASE(_psf);
    DllRelease();
}

IUnknown * COrderList_Create()
{
    COrderList * pcol = new COrderList;
    if (pcol)
    {
        return SAFECAST(pcol, IPersistFolder*);
    }
    return NULL;
}

STDAPI COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi)
{
    *punk = COrderList_Create();

    return *punk ? S_OK : E_OUTOFMEMORY;
}

ULONG COrderList::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG COrderList::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT COrderList::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(COrderList, IPersistFolder),
        QITABENT(COrderList, IOrderList),
        QITABENTMULTI(COrderList, IOrderList2, IOrderList),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT COrderList::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_OrderListExport;

    return S_OK;
}


// This is the directory setup wants to re-order
HRESULT COrderList::Initialize(LPCITEMIDLIST pidl)
{
    if (!_pidlFavorites)
    {
        SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &_pidlFavorites);
        if (!_pidlFavorites)
            return E_OUTOFMEMORY;
    }

    if (!pidl || !ILIsParent(_pidlFavorites, pidl, FALSE))
        return E_INVALIDARG;

    // Initialize can be called multiple times
    ATOMICRELEASE(_psf);

    Pidl_Set(&_pidl, pidl);

    if (_pidl)
        IEBindToObject(_pidl, &_psf);

    if (!_psf)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT COrderList_GetOrderList(HDPA * phdpa, LPCITEMIDLIST pidl, IShellFolder * psf)
{
    IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, STGM_READ);
    if (pstm)
    {
        HRESULT hres = OrderList_LoadFromStream(pstm, phdpa, psf);
        pstm->Release();
        return hres;
    }
    *phdpa = NULL;
    return E_OUTOFMEMORY;
}

HRESULT COrderList::GetOrderList(HDPA * phdpa)
{
    HRESULT hres = E_FAIL;

    *phdpa = NULL;

    if (_psf)
        hres = COrderList_GetOrderList(phdpa, _pidl, _psf);

    return hres;
}

HRESULT COrderList_SetOrderList(HDPA hdpa, LPCITEMIDLIST pidl, IShellFolder *psf)
{
    IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, STGM_WRITE);
    if (EVAL(pstm))
    {
        HRESULT hres = OrderList_SaveToStream(pstm, hdpa, psf);
        pstm->Release();
        return hres;
    }
    return E_OUTOFMEMORY;
}

HRESULT COrderList::SetOrderList(HDPA hdpa, IShellFolder *psf)
{
    if (!_psf)
        return E_FAIL;

    return COrderList_SetOrderList(hdpa, _pidl, psf);
}

HRESULT COrderList::FreeOrderList(HDPA hdpa)
{
    OrderList_Destroy(&hdpa);
    return S_OK;
}

HRESULT COrderList::SortOrderList(HDPA hdpa, DWORD dw)
{
    if (OI_SORTBYNAME != dw && OI_SORTBYORDINAL != dw)
        return E_INVALIDARG;

    if (!_psf)
        return E_FAIL;

    ORDERINFO oinfo;
    oinfo.dwSortBy = dw;
    oinfo.psf = _psf;
#ifdef DEBUG
    oinfo.psf2 = (IShellFolder2 *)INVALID_HANDLE_VALUE; // force fault if someone uses it
#endif

    DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);

    return S_OK;
}

HRESULT COrderList::AllocOrderItem(PORDERITEM * ppoi, LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlClone = ILClone(pidl);

    *ppoi = NULL;

    if (pidlClone)
    {
        *ppoi = OrderItem_Create(pidlClone, -1);
        if (*ppoi)
            return S_OK;

        ILFree(pidlClone);
    }

    return E_OUTOFMEMORY;
}



HRESULT COrderList::FreeOrderItem(PORDERITEM poi)
{
    OrderItem_Free(poi);

    return S_OK;
}

// IOrderList2::LoadFromStream
STDMETHODIMP COrderList::LoadFromStream(IStream* pstm, HDPA* phdpa, IShellFolder* psf)
{
    ASSERT(_psf == NULL);
    _psf = psf;
    if (_psf)
        _psf->AddRef();
    return OrderList_LoadFromStream(pstm, phdpa, _psf);
}

// IOrderList2::SaveToStream
STDMETHODIMP COrderList::SaveToStream(IStream* pstm, HDPA hdpa)
{
    return OrderList_SaveToStream(pstm, hdpa, _psf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\droptgt.cpp ===
#include "priv.h"
#include "droptgt.h"

#define TF_DRAGDROP TF_BAND


#define MAX_DROPTARGETS 3

class CDropTargetWrap : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CDropTargetWrap(IDropTarget** ppdtg, HWND hwnd);
protected:
    ~CDropTargetWrap();

private:
    int             _cRef;

    int             _count;
    IDropTarget*    _rgpdt[MAX_DROPTARGETS];
    DWORD           _rgdwEffect[MAX_DROPTARGETS];
    HWND            _hwnd;
};

CDropTargetWrap::CDropTargetWrap(IDropTarget** ppdt, HWND hwnd)
    : _hwnd(hwnd)
{
    _cRef = 1;

    for (int i = 0; i < MAX_DROPTARGETS; i++, ppdt++) {
        if (*ppdt) {
            _rgpdt[_count] = *ppdt;
            _rgpdt[_count]->AddRef();
            _count++;
        }
    }
}

CDropTargetWrap::~CDropTargetWrap()
{
    for (int i = 0 ; i < _count ; i++)
    {
        _rgpdt[i]->Release();
    }
}

HRESULT CDropTargetWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropTargetWrap, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDropTargetWrap::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CDropTargetWrap::Release(void)
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

         The *pdwEffect that is returned is the first valid value
         of all the drop targets' returned effects.

*/
HRESULT CDropTargetWrap::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;

    for (int i = 0 ; i < _count ; i++)
    {
        _rgdwEffect[i] = *pdwEffect;

        if (SUCCEEDED(_rgpdt[i]->DragEnter(pdtobj, grfKeyState, ptl, &_rgdwEffect[i])))
        {
            if (dwEffectOut == DROPEFFECT_NONE)
            {
                dwEffectOut = _rgdwEffect[i];
            }
        }
        else
        {
            _rgdwEffect[i] = DROPEFFECT_NONE;
        }
    }
    *pdwEffect = dwEffectOut;
    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
HRESULT CDropTargetWrap::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;
        
    for (int i = 0 ; i < _count ; i++)
    {
        _rgdwEffect[i] = *pdwEffect;

        if (SUCCEEDED(_rgpdt[i]->DragOver(grfKeyState, ptl, &_rgdwEffect[i])))
        {
            if (dwEffectOut == DROPEFFECT_NONE)
                dwEffectOut = _rgdwEffect[i];
        }
        else
        {
            _rgdwEffect[i] = DROPEFFECT_NONE;
        }
    }

    *pdwEffect = dwEffectOut;
    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
HRESULT CDropTargetWrap::DragLeave(void)
{
    for (int i = 0 ; i < _count ; i++)
    {
        _rgpdt[i]->DragLeave();
    }

    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
HRESULT CDropTargetWrap::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;
    int i;
    BOOL fDropTried = FALSE;

    for (i = 0 ; (DROPEFFECT_NONE == dwEffectOut) && i < _count ; i++)
    {
        if ((_rgdwEffect[i] && *pdwEffect) && !fDropTried)
        {
            dwEffectOut = *pdwEffect;
            _rgpdt[i]->Drop(pdtobj, grfKeyState, pt, &dwEffectOut);
            fDropTried = TRUE;
        }
        else
        {
            _rgpdt[i]->DragLeave();
        }
    }

    *pdwEffect = dwEffectOut;
    return(S_OK);
}


//=============================================================================
// CDelegateDropTarget
//
// This class implements IDropTarget given an IDelegateDropTargetCB interface.
// It handles all hit testing, caching, and scrolling for you.
//
//=============================================================================
#undef  CDropTargetWrap

CDelegateDropTarget::CDelegateDropTarget()
{
    TraceMsg(TF_SHDLIFE, "ctor CDelegateDropTarget %x", this);

}

CDelegateDropTarget::~CDelegateDropTarget()
{
    TraceMsg(TF_SHDLIFE, "dtor CDelegateDropTarget %x", this);

    ASSERT(!_pDataObj);
    ATOMICRELEASE(_pDataObj);
    ASSERT(!_pdtCur);
    ATOMICRELEASE(_pdtCur);
}

HRESULT CDelegateDropTarget::Init()
{
    HRESULT hres = GetWindowsDDT(&_hwndLock, &_hwndScroll);
    // We lock _hwndLock and do scrolling against _hwndScroll.
    // These can be different hwnds, but certain restrictions apply:
    if (_hwndLock != _hwndScroll)
    {
        BOOL fValid = IsChild(_hwndLock, _hwndScroll);
        if (!fValid)
        {
            TraceMsg(TF_DRAGDROP, "ctor CDelegateDropTarget: invalid windows %x and %x!", _hwndLock, _hwndScroll);
            _hwndLock = _hwndScroll = NULL;
        }
    }
    return hres;
}

void CDelegateDropTarget::_ReleaseCurrentDropTarget()
{
    if (_pdtCur)
    {
        _pdtCur->DragLeave();
        ATOMICRELEASE(_pdtCur);
    }
}

/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

*/
HRESULT CDelegateDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    // We can be re-entered due to ui on thread
    if (_pDataObj != NULL)       
    {
        TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragEnter called a second time!");
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragEnter with *pdwEffect=%x", *pdwEffect);

    ASSERT(!_pDataObj);
    _pDataObj = pdtobj;
    _pDataObj->AddRef();

    // cache state
    //
    // wait until first DragOver to get valid info
    //
    _fPrime = FALSE;
    _dwEffectOut = DROPEFFECT_NONE;

    // set up auto-scroll info
    //
    ASSERT(pdtobj);
    _DragEnter(_hwndLock, ptl, pdtobj);

    DAD_InitScrollData(&_asd);

    _ptLast.x = _ptLast.y = 0x7fffffff; // put bogus value to force redraw

    HitTestDDT(HTDDT_ENTER, NULL, NULL, NULL);

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
HRESULT CDelegateDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    HRESULT hres = S_OK;
    DWORD itemNew;
    POINT pt;
    DWORD dwEffectScroll = 0;
    DWORD dwEffectOut = 0;
    BOOL fSameImage = FALSE;
    DWORD   dwCustDropEffect = 0;

    if (_pDataObj == NULL)
    {
        ASSERT(0);      // DragEnter should be called before.
        return E_FAIL;
    }

    // convert to window coords
    pt.x = ptl.x;
    pt.y = ptl.y;
    ScreenToClient(_hwndScroll, &pt);

    if (DAD_AutoScroll(_hwndScroll, &_asd, &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;

    //
    //  If we are dragging over on a different item, get its IDropTarget
    // interface or adjust itemNew to -1.
    //
    if (SUCCEEDED(HitTestDDT(HTDDT_OVER, &pt, &itemNew, &dwCustDropEffect)) &&
        (itemNew != _itemOver || !_fPrime))
    {
        _fPrime = TRUE;

        _ReleaseCurrentDropTarget();

        _itemOver = itemNew;
        GetObjectDDT(_itemOver, IID_IDropTarget, (LPVOID*)&_pdtCur);

        if (_pdtCur)
        {
            // There's an IDropTarget for this hit, use it
            dwEffectOut = *pdwEffect;

            hres = _pdtCur->DragEnter(_pDataObj, grfKeyState, ptl, &dwEffectOut);
            if (FAILED(hres))
                dwEffectOut = DROPEFFECT_NONE;
        }
        else
        {
            // No IDropTarget, no effect
            dwEffectOut = DROPEFFECT_NONE;
        }
    }
    else
    {
        //
        // No change in the selection. We assume that *pdwEffect stays
        // the same during the same drag-loop as long as the key state doesn't change.
        //
        if ((_grfKeyState != grfKeyState) && _pdtCur)
        {
            dwEffectOut = *pdwEffect;

            hres = _pdtCur->DragOver(grfKeyState, ptl, &dwEffectOut);

            TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragOver DragOver()d id:%d dwEffect:%4x hres:%d", _itemOver, dwEffectOut, hres);
        }
        else
        {
            // Same item and same key state. Use the previous dwEffectOut.
            dwEffectOut = _dwEffectOut;
            fSameImage = TRUE;
        }
    }

    _grfKeyState = grfKeyState;    // store these for the next Drop
    _dwEffectOut = dwEffectOut;    // and DragOver

    // Is the Custdrop effect valid ?
    if (dwCustDropEffect != DROPEFFECT_NONE)    
    {
        //Yes then set the effect to Custdrop effect along with scroll effect
        *pdwEffect = dwCustDropEffect | dwEffectScroll;
    }
    else 
    {
        //No , set the effect to dwEffectOut along with scroll effect
        *pdwEffect = dwEffectOut | dwEffectScroll;
    }
        TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragOver (*pdwEffect=%x)", *pdwEffect);


    if (!(fSameImage && pt.x==_ptLast.x && pt.y==_ptLast.y))
    {
        _DragMove(_hwndLock, ptl);
        _ptLast.x = ptl.x;
        _ptLast.y = ptl.y;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
HRESULT CDelegateDropTarget::DragLeave()
{
    HitTestDDT(HTDDT_LEAVE, NULL, NULL, NULL);
    _ReleaseCurrentDropTarget();

    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragLeave");
    ATOMICRELEASE(_pDataObj);

    DAD_DragLeave();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
HRESULT CDelegateDropTarget::Drop(IDataObject *pdtobj,
                             DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    HRESULT hres = S_OK;
    BOOL bDropHandled = FALSE;

    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::Drop (*pdwEffect=%x)", *pdwEffect);

    //
    // According to AlexGo (OLE), this is by-design. We should make it sure
    // that we use pdtobj instead of pdtobj.
    //
    //ASSERT(pdtobj == _pDataObj);
    pdtobj->AddRef();
    _pDataObj->Release();
    _pDataObj = pdtobj;

    //
    // Note that we don't use the drop position intentionally,
    // so that it matches to the last destination feedback.
    //
    if (_pdtCur)
    {
        // use this local because if _pdtCur::Drop does a UnlockWindow
        // then hits an error and needs to put up a dialog,
        // we could get re-entered
        IDropTarget *pdtCur = _pdtCur;
        _pdtCur = NULL;

        // HACK ALERT!!!!
        //
        //  If we don't call LVUtil_DragEnd here, we'll be able to leave
        // dragged icons visible when the menu is displayed. However, because
        // we are calling IDropTarget::Drop() which may create some modeless
        // dialog box or something, we can not ensure the locked state of
        // the list view -- LockWindowUpdate() can lock only one window at
        // a time. Therefore, we skip this call only if the _pdtCur
        // is a subclass of CIDLDropTarget, assuming its Drop calls
        // CDefView::DragEnd (or CIDLDropTarget_DragDropMenu) appropriately.
        //
#if 0 // later
        if (!IsIDLDropTarget(pdtCur))
#endif
        {
            //
            // This will hide the dragged image.
            //
            DAD_DragLeave();

            //
            //  We need to reset the drag image list so that the user
            // can start another drag&drop while we are in this
            // Drop() member function call.
            //
            // NOTE: we don't have to worry about the DAD_DragLeave
            // (called from during the DragLeave call at the end of
            // this function) cancelling the potential above-mentioned
            // drag&drop loop. If such a beast is going on, it should
            // complete before pdtCur->Drop returns.
            //
            DAD_SetDragImage(NULL, NULL);
        }

        if (S_FALSE != OnDropDDT(pdtCur, _pDataObj, &grfKeyState, pt, pdwEffect))
            pdtCur->Drop(_pDataObj, grfKeyState, pt, pdwEffect);
        else
            pdtCur->DragLeave(); // should be okay even if OnDrop did this already

        pdtCur->Release();
    }
    else
    {
        //
        // We come here if Drop is called without DragMove (with DragEnter).
        //
        *pdwEffect = DROPEFFECT_NONE;
    }

    //
    // Clean up everything (OLE won't call DragLeave after Drop).
    //
    DragLeave();

    return hres;
}

// ******************************************************************
// dummy drop target to only call DAD_DragEnterEx() on DragEnter();
// ******************************************************************

HRESULT CDropDummy::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropDummy, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDropDummy::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CDropDummy::Release(void)
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

         simply call DAD_DragEnterEx2() to get custom drag cursor 
         drawing.

*/
HRESULT CDropDummy::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    _DragEnter(_hwndLock, ptl, pdtobj);
    *pdwEffect = DROPEFFECT_NONE;
    return(S_OK);
}

HRESULT CDropDummy::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _DragMove(_hwndLock, ptl);
    *pdwEffect = DROPEFFECT_NONE;
    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\fsmenu.cpp ===
//---------------------------------------------------------------------------
// Helper routines for an owner draw menu showing the contents of a directory.
//---------------------------------------------------------------------------

// BUGBUG (scotth): note this file is #included by SHELL32 and SHDOC401.
//                  We really want the bits in one place, but right now
//                  SHDOC401 needs some changes which SHELL32 on win95
//                  does not provide.
//
//                  The second best solution is to place this code in
//                  a static lib (stocklib).  However, shell32's default
//                  data segment is still shared, and since this file
//                  contains some globals, we'd have problems with that.
//                  If shell32 is fixed, we can add this file to stocklib.
//
//                  Our third best solution is to #include this file.
//                  That's better than maintaining two different source
//                  codes.
//

#include <limits.h>

#ifdef IN_SHDOCVW
extern "C" LPITEMIDLIST IEILCreate(UINT cbSize);
#define _ILCreate   IEILCreate
#endif
STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone

#define CXIMAGEGAP      6
// #define SRCSTENCIL           0x00B8074AL


typedef enum
{
    FMII_DEFAULT =      0x0000,
    FMII_BREAK =        0x0001
} FMIIFLAGS;


#define FMI_NULL            0x00000000
#define FMI_MARKER          0x00000001
#define FMI_FOLDER          0x00000002
#define FMI_EXPAND          0x00000004
#define FMI_EMPTY           0x00000008
#define FMI_SEPARATOR       0x00000010
#define FMI_DISABLED        0x00000020     // Enablingly Challenged ???
#define FMI_ON_MENU         0x00000040
#define FMI_IGNORE_PIDL     0x00000080     // Ignore the pidl as the display string
#define FMI_FILESYSTEM      0x00000100
#define FMI_MARGIN          0x00000200
#define FMI_MAXTIPWIDTH     0x00000400
#define FMI_TABSTOP         0x00000800
#define FMI_DRAWFLAGS       0x00001000
#define FMI_ALTITEM         0x00002000     // Item came from alternate pidl
#define FMI_CXMAX           0x00004000
#define FMI_CYMAX           0x00008000
#define FMI_CYSPACING       0x00010000
#define FMI_ASKEDFORTOOLTIP 0x00020000
#define FMI_USESTRING       0x00040000     // Use psz before pidl as display string


// One of these per file menu.
typedef struct
{
    IShellFolder *  psf;                // Shell Folder.
    IStream *       pstm;               // Optional stream
    HMENU           hmenu;              // Menu.
    LPITEMIDLIST    pidlFolder;         // Pidl for the folder.
    HDPA            hdpa;               // List of items (see below).
    UINT            idCmd;              // Command.
    DWORD           fmf;                // Header flags.
    UINT            fFSFilter;          // file system enum filter
    HBITMAP         hbmp;               // Background bitmap.
    UINT            cxBmp;              // Width of bitmap.
    UINT            cyBmp;              // Height of bitmap.
    UINT            cxBmpGap;           // Gap for bitmap.
    UINT            yBmp;               // Cached Y coord.
    COLORREF        clrBkg;             // Background color.
    UINT            cySel;              // Prefered height of selection.
    PFNFMCALLBACK   pfncb;              // Callback function.
    IShellFolder *  psfAlt;             // Alternate Shell Folder.
    LPITEMIDLIST    pidlAltFolder;      // Pidl for the alternate folder.
    HDPA            hdpaAlt;            // Alternate dpa
    int             cyMenuSizeSinceLastBreak;  // Size of menu (cy)
    UINT            cyMax;              // Max allowable height of entire menu in pixels
    UINT            cxMax;              // Max allowable width in pixels
    UINT            cySpacing;          // Spacing b/t menu items in pixels
    LPTSTR          pszFilterTypes;     // Multi-string list of extensions (e.g., "doc\0xls\0")
} FILEMENUHEADER, *PFILEMENUHEADER;


// One of these for each file menu item.
//
//  !!! Note: the testers have a test utility which grabs
//      the first 7 fields of this structure.  If you change
//      the order or meaning of these fields, make sure they
//      are notified so they can update their automated tests.
//
typedef struct
{
    PFILEMENUHEADER pfmh;               // The header.
    int             iImage;             // Image index to use.
    DWORD           Flags;              // Misc flags above.
    LPITEMIDLIST    pidl;               // IDlist for item.
    LPTSTR          psz;                // Text when not using pidls.
    UINT            cyItem;             // Custom height.
    LPTSTR          pszTooltip;         // Item tooltip.
    RECT            rcMargin;           // Margin around tooltip
    DWORD           dwMaxTipWidth;      // Maximum tooltip width
    DWORD           dwTabstop;
    UINT            uDrawFlags;
    LPARAM          lParam;             // Application data
    int             nOrder;             // Ordinal indicating user preference
    DWORD           dwEffect;           // Acceptable drop effects
} FILEMENUITEM, *PFILEMENUITEM;


#define X_TIPOFFSET         130      // an arbitrary number of pixels

class CFSMenuAgent
{
private:
    DWORD   _dwState;           // MAS_*
    HHOOK   _hhookMsg;

    PFILEMENUITEM _pfmiCur;     // Current item selected
    PFILEMENUITEM _pfmiDrag;    // Item being dragged
    PFILEMENUITEM _pfmiDrop;    // Target of drop

    DWORD   _dwStateSav;        // Saved state once menu goes away

    HWND    _hwndMenu;       
    HDC     _hdc;
    RECT    _rcCur;          // rect of current selection
    RECT    _rcCurScr;       // rect of current selection in screen coords
    RECT    _rcMenu;         // rect of whole menu in screen coords
    int     _yCenter;        // center of item (in screen coords)

    HCURSOR _hcurSav;
    HBRUSH  _hbr;

public:
    CFSMenuAgent(void);

    void    Init(void);
    void    Reset(void);
    void    EndMenu(void);

    void    UpdateInsertionCaret(void);

    void    SetEditMode(BOOL bEdit, DWORD dwEffect);
    void    SetCaretPos(LPPOINT ppt);
    HCURSOR SetCursor(DWORD dwEffect);
    void    SetCurrentRect(HDC hdc, LPRECT prcItem);

    void    SetItem(PFILEMENUITEM pfmi) { _pfmiCur = pfmi; }
    void    SetDragItem(void) { _pfmiDrag = _pfmiCur; }
    void    SetDropItem(void);

    DWORD   GetDragEffect(void);

    BOOL    ProcessCommand(HWND hwnd, HMENU hmenuBar, UINT idMenu, HMENU hmenu, UINT idCmd);

    friend  LRESULT CALLBACK CFSMenuAgent_MsgHook(int nCode, WPARAM wParam, LPARAM lParam);
    friend  LRESULT FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi);
};


// Menu agent state
#define MAS_EDITMODE            0x00000001
#define MAS_LBUTTONDOWN         0x00000002
#define MAS_LBUTTONUP           0x00000004
#define MAS_INSERTABOVE         0x00000008

// Edit mode states

#define MenuDD_IsButtonDown()   (g_fsmenuagent._dwState & MAS_LBUTTONDOWN)
#define MenuDD_InEditMode()     (g_fsmenuagent._dwState & MAS_EDITMODE)
#define MenuDD_InsertAbove()    (g_fsmenuagent._dwState & MAS_INSERTABOVE)
#define MenuDD_GetBrush()       (g_fsmenuagent._hbr)


//---------------------------------------------------------------------------

CFSMenuAgent g_fsmenuagent;

PFILEMENUITEM g_pfmiLastSel = NULL;
PFILEMENUITEM g_pfmiLastSelNonFolder = NULL;
// This saves us creating DC's all the time for the blits.
HDC g_hdcMem = NULL;
HFONT g_hfont = NULL;
BOOL g_fAbortInitMenu = FALSE;
// Tooltip stuff.
HWND g_hwndTip = NULL;
RECT g_rcItem = {0, 0, 0, 0};
HIMAGELIST g_himlIconsSmall = NULL;
HIMAGELIST g_himlIcons = NULL;


//---------------------------------------------------------------------------
// Validation functions


// IEUNIX -- these functions don't appear to be defined anywhere else, as the
// other def'n would imply
#if defined(DEBUG) || defined(UNIX)

BOOL IsValidPFILEMENUHEADER(PFILEMENUHEADER pfmh)
{
    return (IS_VALID_WRITE_PTR(pfmh, FILEMENUHEADER) &&
            ((NULL == pfmh->psf && 
              NULL == pfmh->pidlFolder) || 
             (IS_VALID_CODE_PTR(pfmh->psf, IShellFolder) && 
              IS_VALID_PIDL(pfmh->pidlFolder))) &&
            IS_VALID_HANDLE(pfmh->hmenu, MENU) &&
            IS_VALID_HANDLE(pfmh->hdpa, DPA) &&
            ((NULL == pfmh->psfAlt && 
              NULL == pfmh->pidlAltFolder) || 
             (IS_VALID_CODE_PTR(pfmh->psfAlt, IShellFolder) &&
              IS_VALID_PIDL(pfmh->pidlAltFolder))) &&
            (NULL == pfmh->hdpaAlt || IS_VALID_HANDLE(pfmh->hdpaAlt, DPA)) &&
            (NULL == pfmh->pszFilterTypes || IS_VALID_STRING_PTR(pfmh->pszFilterTypes, -1)));
}    

BOOL IsValidPFILEMENUITEM(PFILEMENUITEM pfmi)
{
    return (IS_VALID_WRITE_PTR(pfmi, FILEMENUITEM) &&
            IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER) &&
            (NULL == pfmi->pidl || IS_VALID_PIDL(pfmi->pidl)) &&
            (NULL == pfmi->psz || IS_VALID_STRING_PTR(pfmi->psz, -1)) &&
            (NULL == pfmi->pszTooltip || IS_VALID_STRING_PTR(pfmi->pszTooltip, -1)));
}    
#else

BOOL IsValidPFILEMENUHEADER(PFILEMENUHEADER pfmh);
BOOL IsValidPFILEMENUITEM(PFILEMENUITEM pfmi);

#endif


//---------------------------------------------------------------------------
// Helper functions


void FileList_Reorder(PFILEMENUHEADER pfmh);
BOOL FileMenuHeader_InsertItem(PFILEMENUHEADER pfmh, UINT iItem, FMIIFLAGS fFlags);
BOOL FileMenuItem_Destroy(PFILEMENUITEM pfmi);
BOOL FileMenuItem_Move(HWND hwnd, PFILEMENUITEM pfmiFrom, PFILEMENUHEADER pfmhTo, int iPosTo);
BOOL Tooltip_Create(HWND *phwndTip);


__inline static BOOL LAlloc(UINT cb, PVOID *ppv)
{
    ASSERT(ppv);

    *ppv = (PVOID*)LocalAlloc(LPTR, cb);
    return *ppv ? TRUE : FALSE;
}

__inline static BOOL LFree(PVOID pv)
{
    return LocalFree(pv) ? FALSE : TRUE;
}


/*----------------------------------------------------------
Purpose: Allocate a multi-string (double-null terminated)

Returns:
Cond:    --
*/
BOOL
MultiSz_AllocCopy(
    IN  LPCTSTR  pszSrc,
    OUT LPTSTR * ppszDst)
{
    BOOL fRet = FALSE;
    UINT cch;
    UINT cchMac = 0;
    LPCTSTR psz;
    LPTSTR pszDst;

    ASSERT(pszSrc && ppszDst);

    psz = pszSrc;
    while (*psz)
    {
        cch = lstrlen(psz) + 1;
        cchMac += cch;
        psz += cch;
    }
    cchMac++;       // extra null

    if (LAlloc(CbFromCch(cchMac), (PVOID *)ppszDst))
    {
        psz = pszSrc;
        pszDst = *ppszDst;
        while (*psz)
        {
            lstrcpy(pszDst, psz);
            cch = lstrlen(psz) + 1;
            psz += cch;
            pszDst += cch;
        }
        fRet = TRUE;
    }

    return fRet;
}


/*----------------------------------------------------------
Purpose: Allocate a string

Returns:
Cond:    --
*/
BOOL
Sz_AllocCopyA(
    IN  LPCSTR  pszSrc,
    OUT LPTSTR *ppszDst)
{
    BOOL fRet = FALSE;
    UINT cch;

    ASSERT(pszSrc && ppszDst);

    // NB We allocate an extra char in case we need to add an '&'.
    cch = lstrlenA(pszSrc) + 2;
    if (LAlloc(CbFromCchA(cch), (PVOID *)ppszDst))
    {
#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, 0, pszSrc, -1, *ppszDst, cch);
#else
        lstrcpy(*ppszDst, pszSrc);
#endif
        fRet = TRUE;
    }

    return fRet;
}


/*----------------------------------------------------------
Purpose: Allocate a string

Returns:
Cond:    --
*/
BOOL
Sz_AllocCopyW(
    IN  LPCWSTR pszSrc,
    OUT LPTSTR *ppszDst)
{
    BOOL fRet = FALSE;
    UINT cch;

    ASSERT(pszSrc && ppszDst);

    // NB We allocate an extra char in case we need to add an '&'.
    cch = lstrlenW(pszSrc) + 2;
    if (LAlloc(CbFromCchW(cch), (PVOID *)ppszDst))
    {
#ifdef UNICODE
        lstrcpy(*ppszDst, pszSrc);
#else
        WideCharToMultiByte(CP_ACP, 0, pszSrc, -1, *ppszDst, CbFromCchW(cch), NULL, NULL);
#endif
        fRet = TRUE;
    }

    return fRet;
}

#ifdef UNICODE
#define Sz_AllocCopy    Sz_AllocCopyW
#else
#define Sz_AllocCopy    Sz_AllocCopyA
#endif


HCURSOR LoadMenuCursor(UINT idCur)
{
#ifdef IN_SHDOCVW
    return LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(idCur));
#else
    HINSTANCE hinst = GetModuleHandle(TEXT("shdocvw.dll"));

    if (hinst)
        return LoadCursor(hinst, MAKEINTRESOURCE(idCur));

    return LoadCursor(NULL, IDC_ARROW);
#endif
}    


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------


#ifdef DEBUG
static void DumpMsg(MSG * pmsg)
{
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_MOUSEMOVE:
        break;

    case WM_TIMER:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = %#04lx        hwnd = %#04lx  x = %d  y = %d",
                 pmsg->message, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        break;
    }
}    
#endif


/*----------------------------------------------------------
Purpose: Message hook used to track drag and drop within the menu.

*/
LRESULT CALLBACK CFSMenuAgent_MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
#ifdef DEBUG
        if (IsFlagSet(g_dwDumpFlags, DF_HOOK))
            DumpMsg(pmsg);
#endif

        switch (pmsg->message)
        {
        case WM_LBUTTONUP:
            // We record the mouse up IFF it happened in the menu
            // and we had previously recorded the mouse down.
            if (IsFlagSet(g_fsmenuagent._dwState, MAS_EDITMODE | MAS_LBUTTONDOWN))
            {
                POINT pt;
                
                TraceMsg(TF_MENU, "MenuDD: getting mouse up");
                
                pt.x = LOWORD(pmsg->lParam);
                pt.y = HIWORD(pmsg->lParam);

                if (PtInRect(&g_fsmenuagent._rcMenu, pt))
                {
                    SetFlag(g_fsmenuagent._dwState, MAS_LBUTTONUP);
                    g_fsmenuagent.EndMenu();
                }
            }
            ClearFlag(g_fsmenuagent._dwState, MAS_LBUTTONDOWN);
            break;

        case WM_LBUTTONDOWN:
            if (g_fsmenuagent._pfmiCur && 
                (g_fsmenuagent._pfmiCur->dwEffect & DROPEFFECT_MOVE))
            {
                TraceMsg(TF_MENU, "MenuDD: getting mouse down");
                
                SetFlag(g_fsmenuagent._dwState, MAS_LBUTTONDOWN);
                g_fsmenuagent.SetDragItem();
            }
            break;

        case WM_MOUSEMOVE:
            if (g_fsmenuagent._dwState & MAS_EDITMODE)
            {
                POINT pt;
                BOOL bInMenu;

                pt.x = LOWORD(pmsg->lParam);
                pt.y = HIWORD(pmsg->lParam);

                g_fsmenuagent.SetCaretPos(&pt);

                bInMenu = PtInRect(&g_fsmenuagent._rcMenu, pt);
#if 0
                TraceMsg(TF_MENU, "MenuDD: %s (%d,%d) in [%d,%d,%d,%d]", 
                         bInMenu ? TEXT("in menu") : TEXT("not in menu"),
                         pt.x, pt.y, g_fsmenuagent._rcMenu.left, g_fsmenuagent._rcMenu.top,
                         g_fsmenuagent._rcMenu.right, g_fsmenuagent._rcMenu.bottom);
#endif

                // Determine which cursor to show
                if ( !bInMenu )
                    g_fsmenuagent.SetItem(NULL);

                g_fsmenuagent.SetCursor(g_fsmenuagent.GetDragEffect());
            }
            break;

        case WM_MENUSELECT:
            BLOCK
            {
                UINT uItem = GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam);
                HMENU hmenu = GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam);

                // Is the menu going away?
                if (0 == uItem && NULL == hmenu)
                {
                    // Yes; release menu drag/drop
                    TraceMsg(TF_MENU, "MenuDD: menu being cancelled");

                    // Since we're in the middle of the hook chain, call
                    // the next hook first, then remove ourselves
                    lRet = CallNextHookEx(g_fsmenuagent._hhookMsg, nCode, wParam, lParam);

                    // Was an item dropped?
                    if (g_fsmenuagent._dwState & MAS_LBUTTONUP)
                    {
                        // Yes; remember it
                        g_fsmenuagent.SetDropItem();
                    }
                    g_fsmenuagent.Reset();
                    return lRet;
                }
            }
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_fsmenuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_fsmenuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    


CFSMenuAgent::CFSMenuAgent(void)
{
    // This object is global, and not allocated.  We must explicitly
    // initialize the variables.

    _dwState = 0;
    _hhookMsg = 0;
    _dwStateSav = 0;

    _pfmiCur = NULL;
    _pfmiDrag = NULL;
    _pfmiDrop = NULL;

    _hwndMenu = NULL;
    _hdc = NULL;
    _hcurSav = NULL;
    _hbr = NULL;
}    


/*----------------------------------------------------------
Purpose: Initialize the menu drag/drop structure.  This must
         anticipate being called when it is already initialized.
         Also, this will get called whenever a cascaded menu 
         is opened.  Be sure to maintain state across these
         junctures.

*/
void CFSMenuAgent::Init(void)
{
    TraceMsg(TF_MENU, "Initialize menu drag/drop");

    // Do not init _pfmiDrag, since this function is called for every
    // cascaded menu, and _pfmiDrag must be remembered across these
    // menus.

    _pfmiDrop = NULL;
    _dwStateSav = 0;

    if (NULL == _hhookMsg)
    {
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, CFSMenuAgent_MsgHook, HINST_THISDLL, 0);
    }

    if (NULL == _hbr)
    {
        // Don't need to release this
        _hbr = GetSysColorBrush(COLOR_3DFACE);
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CFSMenuAgent::EndMenu(void)
{
    ASSERT(IsWindow(_hwndMenu));

    SendMessage(_hwndMenu, WM_CANCELMODE, 0, 0);
}    


/*----------------------------------------------------------
Purpose: Decides whether to position the caret above or below the
         menu item, based upon the given point (cursor position).

*/
void CFSMenuAgent::SetCaretPos(LPPOINT ppt)
{
    ASSERT(ppt);

    if (ppt->y < _yCenter)
    {
        // Change the caret position?
        if (IsFlagClear(_dwState, MAS_INSERTABOVE))
        {
            // Yes
            SetFlag(_dwState, MAS_INSERTABOVE);
            UpdateInsertionCaret();
        }
    }
    else
    {
        // Change the caret position?
        if (IsFlagSet(_dwState, MAS_INSERTABOVE))
        {
            // Yes
            ClearFlag(_dwState, MAS_INSERTABOVE);
            UpdateInsertionCaret();
        }
    }
}    


void CFSMenuAgent::UpdateInsertionCaret(void)
{
    if (_dwState & MAS_EDITMODE)    
    {
        InvalidateRect(_hwndMenu, &_rcCur, FALSE);
        UpdateWindow(_hwndMenu);
    }
}    


void CFSMenuAgent::SetDropItem(void) 
{ 
    // Only set the drop item if the drop effect is supported.
    ASSERT(_pfmiDrag);

    if (_pfmiCur && (_pfmiCur->dwEffect & _pfmiDrag->dwEffect))
        _pfmiDrop = _pfmiCur; 
    else
        _pfmiDrop = NULL;
}


/*----------------------------------------------------------
Purpose: Set the cursor based on the given flags

*/
HCURSOR CFSMenuAgent::SetCursor(DWORD dwEffect)
{
    HCURSOR hcur = NULL;

    ASSERT(_dwState & MAS_EDITMODE);

    // Does this item support the requested drop effect?
    if (_pfmiCur && (dwEffect & _pfmiCur->dwEffect))
    {
        // Yes
        UINT idCur;

        if (dwEffect & DROPEFFECT_MOVE)
            idCur = IDC_MENUMOVE;
        else if (dwEffect & DROPEFFECT_COPY)
            idCur = IDC_MENUCOPY;
        else
        {
            ASSERT_MSG(0, "Unknown drop effect!");
            idCur = IDC_MENUDENY;
        }

        hcur = ::SetCursor(LoadMenuCursor(idCur));
    }
    else
    {
        // No
        hcur = ::SetCursor(LoadMenuCursor(IDC_MENUDENY));
    }

    return hcur;
}    


DWORD CFSMenuAgent::GetDragEffect(void)
{
    if (_pfmiDrag)
        return _pfmiDrag->dwEffect;
    else
        return DROPEFFECT_NONE;
}    


void CFSMenuAgent::SetEditMode(BOOL bEdit, DWORD dwEffect)
{
    // Only update if the state has changed
    if (bEdit && IsFlagClear(_dwState, MAS_EDITMODE))
    {
        TraceMsg(TF_MENU, "MenuDD: entering edit mode");

        SetFlag(_dwState, MAS_EDITMODE);

        _hcurSav = SetCursor(dwEffect);
    }
    else if (!bEdit && IsFlagSet(_dwState, MAS_EDITMODE))
    {
        TraceMsg(TF_MENU, "MenuDD: leaving edit mode");

        ClearFlag(_dwState, MAS_EDITMODE);

        ASSERT(_hcurSav);

        if (_hcurSav)
        {
            ::SetCursor(_hcurSav);
            _hcurSav = NULL;
        }
    }
}    


void CFSMenuAgent::SetCurrentRect(HDC hdc, LPRECT prcItem)
{
    HWND hwnd = WindowFromDC(hdc);

    ASSERT(hdc);
    ASSERT(prcItem);

    _hwndMenu = hwnd;
    _hdc = hdc;
    _rcCur = *prcItem;
    _rcCurScr = *prcItem;
    GetWindowRect(hwnd, &_rcMenu);

    MapWindowPoints(hwnd, NULL, (LPPOINT)&_rcCurScr, 2);

    _yCenter = _rcCurScr.top + (_rcCurScr.bottom - _rcCurScr.top) / 2;
}


/*----------------------------------------------------------
Purpose: Reset the menu agent.  This is called when the menu goes
         away.  The ProcessCommand method still needs some state
         information so it knows what action had taken place.
         This info is moved to a post-action field.

*/
void CFSMenuAgent::Reset(void)
{
    TraceMsg(TF_MENU, "MenuDD: releasing edit mode resources");

    // Remember the state for FileMenu_ProcessCommand
    _dwStateSav = _dwState;

    SetEditMode(FALSE, DROPEFFECT_NONE);

    TraceMsg(TF_MENU, "MenuDD: Hook removed for menu drag/drop");

    if (_hhookMsg)
    {
        UnhookWindowsHookEx(_hhookMsg);
        _hhookMsg = NULL;
    }

    // Reset
    _pfmiCur = NULL;
    _hwndMenu = NULL;
    _hdc = NULL;
    _dwState = 0;
    _hbr = NULL;

    ASSERT(NULL == _hcurSav);
}    


/*----------------------------------------------------------
Purpose: Have a whack at the WM_COMMAND, in case it is the result
         of drag and drop within the menu.

Returns: TRUE if this function handled the command
*/
BOOL CFSMenuAgent::ProcessCommand(HWND hwnd, HMENU hmenuBar, UINT idMenu, HMENU hmenu, UINT idCmd)
{
    BOOL bRet = FALSE;

    if (hmenu && _pfmiDrag && (_dwStateSav & MAS_EDITMODE))
    {
        ASSERT(IS_VALID_STRUCT_PTR(_pfmiDrag, FILEMENUITEM));

        // Did the user move an item within the menu?
        if (_pfmiDrop)
        {
            // Yes
            ASSERT(IS_VALID_STRUCT_PTR(_pfmiDrop, FILEMENUITEM));

            int iPosTo = DPA_GetPtrIndex(_pfmiDrop->pfmh->hdpa, _pfmiDrop);

            if (IsFlagClear(_dwStateSav, MAS_INSERTABOVE))
                iPosTo++;

            IEPlaySound(TEXT("MoveMenuItem"), FALSE);

            bRet = FileMenuItem_Move(hwnd, _pfmiDrag, _pfmiDrop->pfmh, iPosTo);

            // Re-order the items
            FileList_Reorder(_pfmiDrop->pfmh);
        }

        _pfmiDrag = NULL;
        _pfmiDrop = NULL;

#if 0
        // Did we successfully handle this?
        if (bRet)
        {
            // Yes; bring the menu back up so the user can continue
            // editting.
            HiliteMenuItem(hwnd, hmenuBar, idMenu, MF_BYCOMMAND | MF_HILITE);
            DrawMenuBar(hwnd);
            
            TrackPopupMenu(hmenu, TPM_LEFTALIGN, _rcMenu.left,
                           _rcMenu.top, 0, hwnd, NULL);

            HiliteMenuItem(hwnd, hmenuBar, idMenu, MF_BYCOMMAND | MF_UNHILITE);
            DrawMenuBar(hwnd);
        }
#endif
        
        // Always return true because we handled it
        bRet = TRUE;        
    }

    return bRet;
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
void DeleteGlobalMemDCAndFont(void)
{
    if (g_hdcMem)
    {
        DeleteDC(g_hdcMem);
        g_hdcMem = NULL;
    }
    if (g_hfont)
    {
        DeleteObject(g_hfont);
        g_hfont = NULL;
    }
}




DWORD
GetItemTextExtent(
    IN HDC     hdc,
    IN LPCTSTR lpsz)
{
    SIZE sz;

    GetTextExtentPoint(hdc, lpsz, lstrlen(lpsz), &sz);
    // NB This is OK as long as an item's extend doesn't get very big.
    return MAKELONG((WORD)sz.cx, (WORD)sz.cy);
}


/*----------------------------------------------------------
Purpose: Validates pfmitem.  This also initializes pfmitemOut 
         given the mask and flags set in pfmitem.  This helper 
         function is useful for APIs to "cleanse" incoming 
         FMITEM structures.

Returns: TRUE if pfmitem is a valid structure
Cond:    --
*/
BOOL
IsValidFMItem(
    IN  FMITEM const * pfmitem,
    OUT PFMITEM        pfmitemOut)
{
    BOOL bRet = FALSE;

    ASSERT(pfmitem);
    ASSERT(pfmitemOut);

    if (IS_VALID_READ_PTR(pfmitem, FMITEM) &&
        SIZEOF(*pfmitem) == pfmitem->cbSize)
    {   
        ZeroInit(pfmitemOut, SIZEOF(*pfmitemOut));

        pfmitemOut->cbSize = SIZEOF(*pfmitemOut);
        pfmitemOut->dwMask = pfmitem->dwMask;

        if (pfmitemOut->dwMask & FMI_TYPE)
            pfmitemOut->dwType = pfmitem->dwType;

        if (pfmitemOut->dwMask & FMI_ID)
            pfmitemOut->uID = pfmitem->uID;

        if (pfmitemOut->dwMask & FMI_ITEM)
            pfmitemOut->uItem = pfmitem->uItem;

        if (pfmitemOut->dwMask & FMI_IMAGE)
            pfmitemOut->iImage = pfmitem->iImage;
        else
            pfmitemOut->iImage = -1;

        if (pfmitemOut->dwMask & FMI_DATA)
            pfmitemOut->pvData = pfmitem->pvData;

        if (pfmitemOut->dwMask & FMI_HMENU)
            pfmitemOut->hmenuSub = pfmitem->hmenuSub;

        if (pfmitemOut->dwMask & FMI_METRICS)
            pfmitemOut->cyItem = pfmitem->cyItem;

        if (pfmitemOut->dwMask & FMI_LPARAM)
            pfmitemOut->lParam = pfmitem->lParam;

        // The FMIT_STRING and FMIT_SEPARATOR are exclusive
        if (IsFlagSet(pfmitemOut->dwType, FMIT_STRING) &&
            IsFlagSet(pfmitemOut->dwType, FMIT_SEPARATOR))
        {
            bRet = FALSE;
        }
        else
            bRet = TRUE;
    }
    return bRet;
}


void
FileMenuItem_GetDisplayName(
    IN PFILEMENUITEM pfmi,
    IN LPTSTR        pszName,
    IN UINT          cchName)
{
    STRRET str;

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));
    ASSERT(IS_VALID_WRITE_BUFFER(pszName, TCHAR, cchName));

    // Is this a special empty item?
    if (pfmi->Flags & FMI_EMPTY)
    {
        // Yep, load the string from a resource.
        LoadString(HINST_THISDLL, IDS_NONE, pszName, cchName);
    }
    else
    {
        // Nope, ask the folder for the name of the item.
        PFILEMENUHEADER pfmh = pfmi->pfmh;
        LPSHELLFOLDER psfTemp;

        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        if (pfmi->Flags & FMI_ALTITEM) {
            psfTemp = pfmh->psfAlt;
        } else {
            psfTemp = pfmh->psf;
        }

        // If it's got a pidl use that, else just use the normal menu string.
        if (psfTemp && pfmi->pidl && 
            IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
        {
            if (SUCCEEDED(psfTemp->GetDisplayNameOf(pfmi->pidl, SHGDN_NORMAL, &str)))
            {
                StrRetToStrN(pszName, cchName, &str, pfmi->pidl);
            }
        }
        else if (pfmi->psz)
        {
            lstrcpyn(pszName, pfmi->psz, cchName);
        }
        else
        {
            *pszName = TEXT('\0');
        }
    }
}

#define FileMenuHeader_AllowAbort(pfmh) (!(pfmh->fmf & FMF_NOABORT))


/*----------------------------------------------------------
Purpose: Create a menu item structure to be stored in the hdpa

Returns: TRUE on success
Cond:    --
*/
BOOL
FileMenuItem_Create(
    IN  PFILEMENUHEADER pfmh,
    IN  LPCITEMIDLIST   pidl,       OPTIONAL
    IN  int             iImage,
    IN  DWORD           dwFlags,    // FMI_*
    OUT PFILEMENUITEM * ppfmi)
{
    PFILEMENUITEM pfmi = (PFILEMENUITEM)LocalAlloc(LPTR, SIZEOF(FILEMENUITEM));

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(ppfmi);
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (pfmi)
    {
        DWORD dwAttribs = SFGAO_FOLDER | SFGAO_FILESYSTEM;
        IShellFolder * psfTemp;
        BOOL bUseAlt = IsFlagSet(dwFlags, FMI_ALTITEM);

        pfmi->pfmh = pfmh;
        pfmi->pidl = (LPITEMIDLIST)pidl;
        pfmi->iImage = iImage;
        pfmi->Flags = dwFlags;
        pfmi->nOrder = INT_MAX;     // New items go to the bottom

        if (bUseAlt)
            psfTemp = pfmh->psfAlt;
        else 
            psfTemp = pfmh->psf;

        if (pidl &&
            SUCCEEDED(psfTemp->GetAttributesOf(1, &pidl, &dwAttribs)))
        {
            if (dwAttribs & SFGAO_FOLDER)
                pfmi->Flags |= FMI_FOLDER;

            if (dwAttribs & SFGAO_FILESYSTEM)
                pfmi->Flags |= FMI_FILESYSTEM;
        }
    }

    *ppfmi = pfmi;

    return (NULL != pfmi);
}


/*----------------------------------------------------------
Purpose: Move an item within the same menu or across menus

*/
BOOL FileMenuItem_Move(
    HWND            hwnd,
    PFILEMENUITEM   pfmiFrom, 
    PFILEMENUHEADER pfmhTo, 
    int             iPosTo)
{
    BOOL bRet = FALSE;
    TCHAR szFrom[MAX_PATH + 1];     // +1 for double null

    ASSERT(IS_VALID_STRUCT_PTR(pfmiFrom, FILEMENUITEM));
    ASSERT(IS_VALID_STRUCT_PTR(pfmhTo, FILEMENUHEADER));

    PFILEMENUHEADER pfmhFrom = pfmiFrom->pfmh;
    HDPA hdpaFrom = pfmhFrom->hdpa;
    HDPA hdpaTo = pfmhTo->hdpa;
    BOOL bSameMenu = (pfmhFrom == pfmhTo);

    ASSERT(IsFlagSet(pfmhFrom->fmf, FMF_CANORDER));

    // Is this item being moved within the same menu?
    if (bSameMenu)
    {
        // Yes; simply change the order of the menu below
        bRet = TRUE;
    }
    else
    {
        // No; need to move the actual file to the menu's associated
        // folder.  Also note the placement of the item in the menu.
        TCHAR szTo[MAX_PATH + 1];       // +1 for double null
        IShellFolder * psf = pfmhFrom->psf;
        STRRET str;

        SHGetPathFromIDList(pfmhTo->pidlFolder, szTo);
        szTo[lstrlen(szTo) + 1] = 0;   // double null

        if (SUCCEEDED(psf->GetDisplayNameOf(pfmiFrom->pidl, SHGDN_FORPARSING, &str)))
        {
            StrRetToStrN(szFrom, SIZECHARS(szFrom), &str, pfmiFrom->pidl);
            szFrom[lstrlen(szFrom) + 1] = 0;   // double null

            // WARNING: if you change this code to perform rename on
            // collision, be sure to update the pfmiFrom contents to
            // reflect that name change!

            SHFILEOPSTRUCT shop = {hwnd, FO_MOVE, szFrom, szTo, 0, };
            bRet = (NO_ERROR == SHFileOperation(&shop));

            if (bRet)
            {
                // Flush the notification so the menu is updated immediately.
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH | SHCNF_FLUSH, szFrom, NULL);
            }

            // The move operation will send a notification to the 
            // window, which will eventually invalidate this menu 
            // to have it rebuilt.  However, before that happens
            // we want to record the position of this dragged item
            // in the destination menu.  So change the order of 
            // the menu anyway.
        }
    }

    if (bRet)
    {
        // Change the order of the menu
        int iPosFrom = DPA_GetPtrIndex(hdpaFrom, pfmiFrom);

        bRet = FALSE;

        // Account for the fact we delete before we insert within the
        // same menu
        if (bSameMenu && iPosTo > iPosFrom)
            iPosTo--;

        DPA_DeletePtr(hdpaFrom, iPosFrom);
        iPosTo = DPA_InsertPtr(hdpaTo, iPosTo, pfmiFrom);
        if (-1 != iPosTo)
        {
            // Update the header of the item
            pfmiFrom->pfmh = pfmhTo;

            // Move the menu items
            MENUITEMINFO mii;

            mii.cbSize = SIZEOF(mii);
            mii.fMask = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
            
            if (GetMenuItemInfo(pfmhFrom->hmenu, iPosFrom, TRUE, &mii))
            {
                // Remove a submenu first so it doesn't get nuked
                if (GetSubMenu(pfmhFrom->hmenu, iPosFrom))
                    RemoveMenu(pfmhFrom->hmenu, iPosFrom, MF_BYPOSITION);

                DeleteMenu(pfmhFrom->hmenu, iPosFrom, MF_BYPOSITION);
                if ( !InsertMenuItem(pfmhTo->hmenu, iPosTo, TRUE, &mii) )
                {
                    TraceMsg(TF_ERROR, "Failed to move menu item");
                    DPA_DeletePtr(hdpaTo, iPosTo);
                }
                else
                {
                    SetFlag(pfmhFrom->fmf, FMF_DIRTY);
                    SetFlag(pfmhTo->fmf, FMF_DIRTY);
                    bRet = TRUE;
                }
            }
        }
        else
        {
            // Punt
            TraceMsg(TF_ERROR, "Menu: could not insert moved item in the DPA");
        }
    }
    return bRet;
}    


/*----------------------------------------------------------
Purpose: Enumerates the folder and adds the files to the DPA.

Returns: count of items in the list
*/
int
FileList_Build(
    IN PFILEMENUHEADER pfmh,
    IN int             cItems,
    IN BOOL            bUseAlt)
    {
#ifdef DEBUG
    TCHAR szName[MAX_PATH];
#endif
    HDPA hdpaTemp;
    HRESULT hres;
    LPITEMIDLIST pidlSkip = NULL;
    LPITEMIDLIST pidlProgs = NULL;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
        return -1;

    if (bUseAlt) {
        hdpaTemp = pfmh->hdpaAlt;
    } else {
        hdpaTemp = pfmh->hdpa;
    }


    if (hdpaTemp && pfmh->psf)
    {
        LPENUMIDLIST penum;
        LPSHELLFOLDER psfTemp;

        // Take care with Programs folder.
        // If this is the parent of the programs folder set pidlSkip to
        // the last bit of the programs pidl.
        if (pfmh->fmf & FMF_NOPROGRAMS)
            {
            pidlProgs = SHCloneSpecialIDList(NULL,
                                            (bUseAlt ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS),
                                             TRUE);

            if (ILIsParent((bUseAlt ? pfmh->pidlAltFolder : pfmh->pidlFolder),
                           pidlProgs, TRUE))
                {
                TraceMsg(TF_MENU, "FileList_Build: Programs parent.");
                pidlSkip = ILFindLastID(pidlProgs);
                }
            }

        // Decide which shell folder to enumerate.

        if (bUseAlt) {
            psfTemp = pfmh->psfAlt;
        } else {
            psfTemp = pfmh->psf;
        }

        // We now need to iterate over the children under this guy...
        hres = psfTemp->EnumObjects(NULL, pfmh->fFSFilter, &penum);
        if (SUCCEEDED(hres))
        {
            ULONG celt;
            LPITEMIDLIST pidl = NULL;

            // The pidl is stored away into the pfmi structure, so
            // don't free it here
            while (penum->Next(1, &pidl, &celt) == S_OK && celt == 1)
            {
                PFILEMENUITEM pfmi;

                // Abort.
                if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
                    break;

                if (pidlSkip && psfTemp->CompareIDs(0, pidlSkip, pidl) == 0)
                {
                   ILFree(pidl);    // Don't leak this one...
                   TraceMsg(DM_TRACE, "FileList_Build: Skipping Programs.");
                   continue;
                }

                // Is there a list of extensions on which we need to
                // filter?
                if (pfmh->pszFilterTypes)
                {
                    STRRET str;
                    DWORD dwAttribs = SFGAO_FOLDER | SFGAO_FILESYSTEM;

                    psfTemp->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &dwAttribs);

                    // only apply the filter to file system objects

                    if ((dwAttribs & SFGAO_FILESYSTEM) &&
                        SUCCEEDED(psfTemp->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
                    {
                        TCHAR szFile[MAX_PATH];
                        StrRetToStrN(szFile, SIZECHARS(szFile), &str, pidl);

                        if (!(dwAttribs & SFGAO_FOLDER))
                        {
                            LPTSTR psz = pfmh->pszFilterTypes;
                            LPTSTR pszExt = PathFindExtension(szFile);

                            if (TEXT('.') == *pszExt)
                                pszExt++;

                            while (*psz)
                            {
                                // Skip this file?
                                if (0 == lstrcmpi(pszExt, psz))
                                    break;          // No

                                psz += lstrlen(psz) + 1;
                            }

                            if ( !*psz )
                            {
                                ILFree(pidl);       // don't leak this
                                continue;
                            }
                        }
                    }
                }

                if (FileMenuItem_Create(pfmh, pidl, -1, bUseAlt ? FMI_ALTITEM : 0, &pfmi))
                {
                    int idpa;

                    if (!bUseAlt)
                    {
                        // Set the allowable drop effects (as a target).
                        // We don't allow common user items to be moved.
                        pfmi->dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;
                    }

                    idpa = DPA_AppendPtr(hdpaTemp, pfmi);

                    // NB We only callback for non-folders at the moment
                    //
                    // HACK don't callback for non file system things
                    // this callback is used to set hotkeys, and that tries
                    // to load the PIDL passed back as a file, and that doesn't
                    // work for non FS pidls
                    if (pfmh->pfncb && (pfmi->Flags & FMI_FILESYSTEM))
                    {
                        FMCBDATA fmcbdata;

                        fmcbdata.hmenu = pfmh->hmenu;
                        fmcbdata.iPos = idpa;
                        // Don't know the id because it hasn't been 
                        // added to the menu yet
                        fmcbdata.idCmd = (UINT)-1;
                        if (bUseAlt) {
                            fmcbdata.pidlFolder = pfmh->pidlAltFolder;
                        } else {
                            fmcbdata.pidlFolder = pfmh->pidlFolder;
                        }
                        fmcbdata.pidl = pidl;
                        fmcbdata.psf = psfTemp;
                        fmcbdata.pvHeader = pfmh;

                        pfmh->pfncb(FMM_ADD, &fmcbdata, 0);
                    }

#ifdef DEBUG
                    FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));
                    TraceMsg(TF_MENU, "FileList_Build: Non-folder %s", szName);
#endif

                    cItems++;
                }
            }
            penum->Release();
        }
        else
        {
            TraceMsg(TF_ERROR, "FileList_Build: Enumeration failed - leaving folder empty.");
        }

        ILFree(pidlProgs);
    }

    // Insert a special Empty item (unless the header flag says
    // not to).
    if (!cItems && hdpaTemp && !(pfmh->fmf & FMF_NOEMPTYITEM) && !bUseAlt)
    {
        PFILEMENUITEM pfmi;

        if (FileMenuItem_Create(pfmh, NULL, -1, FMI_EMPTY, &pfmi))
            {
            DPA_SetPtr(hdpaTemp, cItems, pfmi);
            cItems++;
            }
        }
    return cItems;
    }


#define FS_SORTBYNAME       0
#define FS_SORTBYORDINAL    1

//---------------------------------------------------------------------------
// Simplified version of the file info comparison function.
int CALLBACK FileMenuItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    PFILEMENUITEM pfmi1 = (PFILEMENUITEM)pv1;
    PFILEMENUITEM pfmi2 = (PFILEMENUITEM)pv2;
    int nRet;
    TCHAR szName1[MAX_PATH];
    TCHAR szName2[MAX_PATH];

    switch (lParam)
    {
    case FS_SORTBYNAME:
        // Directories come first, then files
        if ((pfmi1->Flags & FMI_FOLDER) > (pfmi2->Flags & FMI_FOLDER))
            return -1;
        else if ((pfmi1->Flags & FMI_FOLDER) < (pfmi2->Flags & FMI_FOLDER))
            return 1;

        FileMenuItem_GetDisplayName(pfmi1, szName1, ARRAYSIZE(szName1));
        FileMenuItem_GetDisplayName(pfmi2, szName2, ARRAYSIZE(szName2));
        nRet = lstrcmpi(szName1, szName2);
        break;

    case FS_SORTBYORDINAL:
        if (pfmi1->nOrder == pfmi2->nOrder)
            nRet = 0;
        else
            nRet = (pfmi1->nOrder < pfmi2->nOrder ? -1 : 1);
        break;

    default:
        ASSERT_MSG(0, "Bad lParam passed to FileMenuItem_Compare");
        nRet = 0;
        break;
    }

    return nRet;
}


LPVOID CALLBACK FileMenuItem_Merge(UINT uMsg, LPVOID pvDest, LPVOID pvSrc, LPARAM lParam)
{
    PFILEMENUITEM pfmiDest = (PFILEMENUITEM)pvDest;
    PFILEMENUITEM pfmiSrc = (PFILEMENUITEM)pvSrc;
    LPVOID pvRet = pfmiDest;

    switch (uMsg)
    {
    case DPAMM_MERGE:
        // We just care about the order field
        pfmiDest->nOrder = pfmiSrc->nOrder;
        break;

    case DPAMM_DELETE:
    case DPAMM_INSERT:
        // Don't need to implement this
        ASSERT(0);
        pvRet = NULL;
        break;
    }
    
    return pvRet;
}


// Header for file menu streams
typedef struct tagFMSTREAMHEADER
{
    DWORD cbSize;           // Size of header
    DWORD dwVersion;        // Version of header
} FMSTREAMHEADER;

#define FMSTREAMHEADER_VERSION  1

typedef struct tagFMSTREAMITEM
{
    DWORD cbSize;           // Size including pidl (not for versioning)
    int   nOrder;           // User-specified order
} FMSTREAMITEM;

#define CB_FMSTREAMITEM     (sizeof(FMSTREAMITEM))

HRESULT 
CALLBACK 
FileMenuItem_SaveStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    // We only write menu items with pidls
    PFILEMENUITEM pfmi = (PFILEMENUITEM)pinfo->pvItem;
    HRESULT hres = S_FALSE;

    if (pfmi->pidl)
    {
        FMSTREAMITEM fmsi;
        ULONG cbWrite;
        ULONG cbWritePidl;

        // Size of header, pidl, and ushort for pidl size.
        fmsi.cbSize = CB_FMSTREAMITEM + pfmi->pidl->mkid.cb + sizeof(USHORT);
        fmsi.nOrder = pfmi->nOrder;

        hres = pstm->Write(&fmsi, CB_FMSTREAMITEM, &cbWrite);
        if (SUCCEEDED(hres))
        {
            hres = pstm->Write(pfmi->pidl, pfmi->pidl->mkid.cb + sizeof(USHORT), &cbWritePidl);
            ASSERT(fmsi.cbSize == cbWrite + cbWritePidl);
        }
    }

    return hres;
}   

 
HRESULT 
CALLBACK 
FileMenuItem_LoadStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    HRESULT hres;
    FMSTREAMITEM fmsi;
    ULONG cbRead;
    PFILEMENUHEADER pfmh = (PFILEMENUHEADER)pvData;

    ASSERT(pfmh);

    hres = pstm->Read(&fmsi, CB_FMSTREAMITEM, &cbRead);
    if (SUCCEEDED(hres))
    {
        if (CB_FMSTREAMITEM != cbRead)
            hres = E_FAIL;
        else
        {
            ASSERT(CB_FMSTREAMITEM < fmsi.cbSize);
            if (CB_FMSTREAMITEM < fmsi.cbSize)
            {
                UINT cb = fmsi.cbSize - CB_FMSTREAMITEM;
                LPITEMIDLIST pidl = _ILCreate(cb);
                if ( !pidl )
                    hres = E_OUTOFMEMORY;
                else
                {
                    hres = pstm->Read(pidl, cb, &cbRead);
                    if (SUCCEEDED(hres) && cb == cbRead && 
                        IS_VALID_PIDL(pidl))
                    {
                        PFILEMENUITEM pfmi;

                        if (FileMenuItem_Create(pfmh, pidl, -1, 0, &pfmi))
                        {
                            pfmi->nOrder = fmsi.nOrder;
                            pinfo->pvItem = pfmi;
                            hres = S_OK;
                        }
                        else
                            hres = E_OUTOFMEMORY;
                    }
                    else
                        hres = E_FAIL;

                    // Cleanup
                    if (FAILED(hres))
                        ILFree(pidl);
                }
            }
            else
                hres = E_FAIL;
        }
    }

    ASSERT((S_OK == hres && pinfo->pvItem) || FAILED(hres));
    return hres;
}    


int
CALLBACK
FileMenuItem_DestroyCB(LPVOID pv, LPVOID pvData)
{
    return FileMenuItem_Destroy((PFILEMENUITEM)pv);
}    


BOOL 
FileList_Load(
    IN  PFILEMENUHEADER pfmh,
    OUT HDPA *    phdpa,
    IN  IStream * pstm)
{
    HDPA hdpa = NULL;
    FMSTREAMHEADER fmsh;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(phdpa);
    ASSERT(pstm);

    // Read the header for more info
    if (SUCCEEDED(pstm->Read(&fmsh, sizeof(fmsh), NULL)) &&
        sizeof(fmsh) == fmsh.cbSize &&
        FMSTREAMHEADER_VERSION == fmsh.dwVersion)
    {
        // Load the stream.  (Should be ordered by name.)
        DPA_LoadStream(&hdpa, FileMenuItem_LoadStream, pstm, pfmh);
    }

    *phdpa = hdpa;

    return (NULL != hdpa);
}    


HRESULT 
FileList_Save(
    IN  PFILEMENUHEADER pfmh,
    IN  IStream * pstm)
{
    HRESULT hres = E_OUTOFMEMORY;
    FMSTREAMHEADER fmsh;
    HDPA hdpa;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(pstm);

    // Clone the array and sort by name for the purpose of persisting it
    hdpa = DPA_Clone(pfmh->hdpa, NULL);
    if (hdpa)
    {
        DPA_Sort(hdpa, FileMenuItem_Compare, FS_SORTBYNAME);

        // Save the header
        fmsh.cbSize = sizeof(fmsh);
        fmsh.dwVersion = FMSTREAMHEADER_VERSION;

        hres = pstm->Write(&fmsh, sizeof(fmsh), NULL);
        if (SUCCEEDED(hres))
        {
            hres = DPA_SaveStream(hdpa, FileMenuItem_SaveStream, pstm, pfmh);
        }

        DPA_Destroy(hdpa);
    }

    return hres;
}    


void FileList_Reorder(PFILEMENUHEADER pfmh)
{
    int i;
    int cel;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    BOOL bCantOrder = (NULL == pfmh->pstm);

    // Update the order fields.  While we're at it, massage the 
    // dwEffect field so it reflects whether something can be
    // ordered based on the stream (no stream means no reorder).

    cel = DPA_GetPtrCount(pfmh->hdpa);
    for (i = 0; i < cel; i++)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_FastGetPtr(pfmh->hdpa, i);
        pfmi->nOrder = i;

        if (bCantOrder)
            pfmi->dwEffect = DROPEFFECT_NONE;
    }
}    


// Caller should release the stream after using it
BOOL FileList_GetStream(PFILEMENUHEADER pfmh, IStream ** ppstm)
{
    if (NULL == pfmh->pstm)
    {
        if (pfmh->pfncb)
        {
            FMGETSTREAM fmgs = { 0 };
            FMCBDATA fmcbdata;

            fmcbdata.hmenu = pfmh->hmenu;
            fmcbdata.idCmd = pfmh->idCmd;
            fmcbdata.iPos = -1;
            fmcbdata.pidlFolder = pfmh->pidlFolder;
            fmcbdata.pidl = NULL;
            fmcbdata.psf = pfmh->psf;
            fmcbdata.pvHeader = pfmh;

            if (S_OK == pfmh->pfncb(FMM_GETSTREAM, &fmcbdata, (LPARAM)&fmgs) &&
                fmgs.pstm)
            {
                // Cache this stream away
                pfmh->pstm = fmgs.pstm;
            }
        }
    }
    else
    {
        // Reset the seek pointer to beginning
        LARGE_INTEGER dlibMove = { 0 };
        pfmh->pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    }

    if (pfmh->pstm)
        pfmh->pstm->AddRef();
        
    *ppstm = pfmh->pstm;

    return (NULL != *ppstm);
}    


void  
FileList_Sort(
    PFILEMENUHEADER pfmh)
{
    IStream * pstm;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // First sort by name
    DPA_Sort(pfmh->hdpa, FileMenuItem_Compare, FS_SORTBYNAME);

    // Can this menu be sorted by the user?
    if ((pfmh->fmf & FMF_CANORDER) && FileList_GetStream(pfmh, &pstm))
    {
        // Yes; get the stream and try to load the order info
        HDPA hdpaOrder;

        // Read the order from the stream
        if (FileList_Load(pfmh, &hdpaOrder, pstm))
        {
            // Sort the menu according to this stream's order.

            // The persisted order is by name.  This reduces the number of
            // sorts to two at load-time, and 1 at save-time.  (Persisting
            // by ordinal number means we sort three times at load-time, and
            // none at save-time.  We want to speed up the initial menu
            // creation as much as possible.)

            // (Already sorted by name above)
            DPA_Merge(pfmh->hdpa, hdpaOrder, DPAM_SORTED, FileMenuItem_Compare, 
                      FileMenuItem_Merge, FS_SORTBYNAME);
            DPA_Sort(pfmh->hdpa, FileMenuItem_Compare, FS_SORTBYORDINAL);

            DPA_DestroyCallback(hdpaOrder, FileMenuItem_DestroyCB, NULL);
        }

        pstm->Release();
    }

    FileList_Reorder(pfmh);
}


//---------------------------------------------------------------------------
// Use the text extent of the given item and the size of the image to work
// what the full extent of the item will be.
DWORD
GetItemExtent(
    IN HDC           hdc,
    IN PFILEMENUITEM pfmi)
{
    WORD wHeight;
    WORD wWidth;
    DWORD dwExtent;
    TCHAR szName[MAX_PATH];
    PFILEMENUHEADER pfmh;
    BITMAP bmp;

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

    pfmh = pfmi->pfmh;
    ASSERT(pfmh);

    // Limit the width of the text?
    if (0 < pfmh->cxMax)
    {
        // Yes
        PathCompactPath(hdc, szName, pfmh->cxMax);
    }

    dwExtent = GetItemTextExtent(hdc, szName);

    wHeight = HIWORD(dwExtent);

    // If no custom height - calc it.
    if (!pfmi->cyItem)
    {
        if (pfmh->fmf & FMF_LARGEICONS)
            wHeight = max(wHeight, ((WORD)g_cyIcon)) + 2;
        else
            wHeight = max(wHeight, ((WORD)g_cySmIcon)) + pfmh->cySpacing;
    }
    else
    {
        wHeight = max(wHeight, pfmi->cyItem);
    }

    ASSERT(pfmi->pfmh);

    //    string, image, gap on either side of image, popup triangle
    //    and background bitmap if there is one.
    // BUGBUG popup triangle size needs to be real
    wWidth = LOWORD(dwExtent) + GetSystemMetrics(SM_CXMENUCHECK);

    // Keep track of the width and height of the bitmap.
    if (pfmh->hbmp && !pfmh->cxBmp && !pfmh->cyBmp)
    {
        GetObject(pfmh->hbmp, SIZEOF(bmp), &bmp);
        pfmh->cxBmp = bmp.bmWidth;
        pfmh->cyBmp = bmp.bmHeight;
    }

    // Gap for bitmap.
    wWidth += (WORD) pfmh->cxBmpGap;

    // Space for image if there is one.
    // NB We currently always allow room for the image even if there
    // isn't one so that imageless items line up properly.
    if (pfmh->fmf & FMF_LARGEICONS)
        wWidth += g_cxIcon + (2 * CXIMAGEGAP);
    else
        wWidth += g_cxSmIcon + (2 * CXIMAGEGAP);

    return MAKELONG(wWidth, wHeight);
}


/*----------------------------------------------------------
Purpose: Get the PFILEMENUITEM of this menu item

Returns: 
Cond:    --
*/
PFILEMENUITEM  
FileMenu_GetItemData(
    IN HMENU hmenu, 
    IN UINT iItem,
    IN BOOL bByPos)
{
    MENUITEMINFO mii;

    mii.cbSize = SIZEOF(MENUITEMINFO);
    mii.fMask = MIIM_DATA | MIIM_STATE;
    mii.cch = 0;     // just in case

    if (GetMenuItemInfo(hmenu, iItem, bByPos, &mii))
        return (PFILEMENUITEM)mii.dwItemData;

    return NULL;
}


PFILEMENUHEADER FileMenu_GetHeader(HMENU hmenu)
{
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    if (pfmi && 
        EVAL(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM)) &&
        EVAL(IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER)))
    {
        return pfmi->pfmh;
    }

    return NULL;
}


/*----------------------------------------------------------
Purpose: Create a file menu header.  This header is to be associated 
         with the given menu handle.

         If the menu handle already has header, simply return the
         existing header.

Returns: pointer to header
         NULL on failure
*/
PFILEMENUHEADER
FileMenuHeader_Create(
    IN HMENU        hmenu,
    IN HBITMAP      hbmp,
    IN int          cxBmpGap,
    IN COLORREF     clrBkg,
    IN int          cySel,
    IN const FMCOMPOSE * pfmc)      OPTIONAL
{
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    PFILEMENUHEADER pfmh;

    // Does this guy already have a header?
    if (pfmi)
    {
        // Yes; use it
        pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    }
    else
    {
        // Nope, create one now.
        pfmh = (PFILEMENUHEADER)LocalAlloc(LPTR, SIZEOF(FILEMENUHEADER));
        if (pfmh)
        {
            // Keep track of the header.
            TraceMsg(TF_MENU, "Creating filemenu header for %#08x (%x)", hmenu, pfmh);

            pfmh->hdpa = DPA_Create(0);
            if (pfmh->hdpa == NULL)
            {
                LocalFree((HLOCAL)pfmh);
                pfmh = NULL;
            }
            else
            {
                pfmh->hmenu = hmenu;
                pfmh->hbmp = hbmp;
                pfmh->cxBmpGap = cxBmpGap;
                pfmh->clrBkg = clrBkg;
                pfmh->cySel = cySel;
                pfmh->cySpacing = 6;        // default for small icons
            }
        }
    }

    if (pfmc && pfmh)
    {
        // Set additional values
        if (IsFlagSet(pfmc->dwMask, FMC_CALLBACK))
            pfmh->pfncb = pfmc->pfnCallback;

        if (IsFlagSet(pfmc->dwMask, FMC_CYMAX))
            pfmh->cyMax = pfmc->cyMax;

        if (IsFlagSet(pfmc->dwMask, FMC_CXMAX))
            pfmh->cxMax = pfmc->cxMax;

        if (IsFlagSet(pfmc->dwMask, FMC_CYSPACING))
            pfmh->cySpacing = pfmc->cySpacing;

        if (IsFlagSet(pfmc->dwMask, FMC_FILTERTYPES))
        {
            // This is a double-null terminated string
            MultiSz_AllocCopy(pfmc->pszFilterTypes, &pfmh->pszFilterTypes);
        }
    }

    return pfmh;
}


/*----------------------------------------------------------
Purpose: Set info specific to a folder.

Returns:
Cond:    --
*/
BOOL
FileMenuHeader_SetFolderInfo(
    IN PFILEMENUHEADER pfmh,
    IN const FMCOMPOSE * pfmc)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(pfmc);

    // Keep track of the header.
    pfmh->idCmd = pfmc->id;

    if (IsFlagSet(pfmc->dwMask, FMC_FILTER))
        pfmh->fFSFilter = pfmc->dwFSFilter;

    if (IsFlagSet(pfmc->dwMask, FMC_CYMAX))
        pfmh->cyMax = pfmc->cyMax;

    if (IsFlagSet(pfmc->dwMask, FMC_CXMAX))
        pfmh->cxMax = pfmc->cxMax;

    if (IsFlagSet(pfmc->dwMask, FMC_CYSPACING))
        pfmh->cySpacing = pfmc->cySpacing;

    if (IsFlagSet(pfmc->dwMask, FMC_FILTERTYPES))
        MultiSz_AllocCopy(pfmc->pszFilterTypes, &pfmh->pszFilterTypes);

    if (pfmc->pidlFolder)
    {
        pfmh->pidlFolder = ILClone(pfmc->pidlFolder);
        if (pfmh->pidlFolder)
        {
            LPSHELLFOLDER psfDesktop;
            if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
            {
                if (SUCCEEDED(psfDesktop->BindToObject(pfmh->pidlFolder, 
                    NULL, IID_IShellFolder, (PVOID *)&pfmh->psf)))
                {
                    return TRUE;
                }
            }
            ILFree(pfmh->pidlFolder);
        }
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Create the tooltip window

Returns:
Cond:    --
*/
BOOL
FileMenuHeader_CreateTooltipWindow(
    IN  PFILEMENUHEADER pfmh)
    {
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // Check if we need to create the main tooltip window
    if (g_hwndTip)
    {
        if (IsWindow(g_hwndTip))
        {
            TCHAR szClass[MAX_PATH];
            GetClassName(g_hwndTip, szClass, ARRAYSIZE(szClass));
            if (lstrcmpi(szClass, TOOLTIPS_CLASS) != 0)
                g_hwndTip = NULL;
        }
        else
            g_hwndTip = NULL;
    }

    if (!g_hwndTip)
        Tooltip_Create(&g_hwndTip);

    ASSERT(IS_VALID_HANDLE(g_hwndTip, WND));

    return NULL != g_hwndTip;
    }


//---------------------------------------------------------------------------
// Give the submenu a marker item so we can check it's a filemenu item
// at initpopupmenu time.
BOOL FileMenuHeader_InsertMarkerItem(PFILEMENUHEADER pfmh)
{
    PFILEMENUITEM pfmi;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (FileMenuItem_Create(pfmh, NULL, -1, FMI_MARKER | FMI_EXPAND, &pfmi))
    {
        DPA_SetPtr(pfmh->hdpa, 0, pfmi);
        FileMenuHeader_InsertItem(pfmh, 0, FMII_DEFAULT);
        return TRUE;
    }
    TraceMsg(TF_ERROR, "FileMenuHeader_InsertMarkerItem: Can't create marker item.");
    return FALSE;
}


/*----------------------------------------------------------
Purpose: This functions adds the given item (index into DPA)
         into the actual menu.

Returns:
Cond:    --
*/
BOOL
FileMenuHeader_InsertItem(
    IN PFILEMENUHEADER pfmh,
    IN UINT            iItem,
    IN FMIIFLAGS       fFlags)
{
    PFILEMENUITEM pfmi;
    UINT fMenu;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // Normal item.
    pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iItem);
    if (!pfmi)
        return FALSE;

    if (pfmi->Flags & FMI_ON_MENU)
        return FALSE;
    else
        pfmi->Flags |= FMI_ON_MENU;

    // The normal stuff.
    fMenu = MF_BYPOSITION|MF_OWNERDRAW;
    // Keep track of where it's going in the menu.

    // The special stuff...
    if (fFlags & FMII_BREAK)
    {
        fMenu |= MF_MENUBARBREAK;
    }

    // Is it a folder (that's not open yet)?
    if (pfmi->Flags & FMI_FOLDER)
    {
        // Yep. Create a submenu item.
        HMENU hmenuSub = CreatePopupMenu();
        if (hmenuSub)
        {
            MENUITEMINFO mii;
            LPITEMIDLIST pidlSub;
            PFILEMENUHEADER pfmhSub;
            FMCOMPOSE fmc;

            // Set the callback now so it can be called when adding items
            fmc.cbSize = SIZEOF(fmc);
            fmc.dwMask = FMC_CALLBACK;
            fmc.pfnCallback = pfmh->pfncb;

            // Insert it into the parent menu.
            fMenu |= MF_POPUP;
            InsertMenu(pfmh->hmenu, iItem, fMenu, (UINT_PTR)hmenuSub, (LPTSTR)pfmi);
            // Set it's ID.
            mii.cbSize = SIZEOF(mii);
            mii.fMask = MIIM_ID;
            mii.wID = pfmh->idCmd;
            SetMenuItemInfo(pfmh->hmenu, iItem, TRUE, &mii);
            pidlSub = ILCombine((pfmi->Flags & FMI_ALTITEM) ? pfmh->pidlAltFolder : pfmh->pidlFolder, pfmi->pidl);
            pfmhSub = FileMenuHeader_Create(hmenuSub, NULL, 0, (COLORREF)-1, 0, &fmc);
            ASSERT(pfmh);
            if (pfmh)
            {
                // Inherit settings from the parent filemenu
                fmc.dwMask     = FMC_PIDL | FMC_FILTER | FMC_CYMAX |
                                 FMC_CXMAX | FMC_CYSPACING;
                fmc.id         = pfmh->idCmd;
                fmc.pidlFolder = pidlSub;
                fmc.dwFSFilter = pfmh->fFSFilter;
                fmc.cyMax      = pfmh->cyMax;
                fmc.cxMax      = pfmh->cxMax;
                fmc.cySpacing  = pfmh->cySpacing;

                if (pfmh->pszFilterTypes)
                {
                    fmc.dwMask |= FMC_FILTERTYPES;
                    fmc.pszFilterTypes = pfmh->pszFilterTypes;
                }

                FileMenuHeader_SetFolderInfo(pfmhSub, &fmc);

                // Magically inherit certain flags
                // BUGBUG (scotth): can we inherit all the bits?
                pfmhSub->fmf = pfmh->fmf & FMF_INHERITMASK;

                // Build it a bit at a time.
                FileMenuHeader_InsertMarkerItem(pfmhSub);
            }
            ILFree(pidlSub);
        }
    }
    else
    {
        // Nope.
        if (pfmi->Flags & FMI_EMPTY)
            fMenu |= MF_DISABLED | MF_GRAYED;

        InsertMenu(pfmh->hmenu, iItem, fMenu, pfmh->idCmd, (LPTSTR)pfmi);
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Remove the rest of the items from the main list starting
         at the given index.

Returns: --
Cond:    --
*/
void
FileList_StripLeftOvers(
    IN PFILEMENUHEADER pfmh,
    IN int             idpaStart,
    IN BOOL            bUseAlt)
{
    int cItems;
    int i;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    cItems = DPA_GetPtrCount(pfmh->hdpa);

    // Do this backwards to stop things moving around as
    // we delete them.
    for (i = cItems - 1; i >= idpaStart; i--)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
        if (pfmi)
        {
            // Tell the callback we're removing this
            if (pfmh->pfncb && pfmi->pidl && 
                IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
            {
                FMCBDATA fmcbdata;

                fmcbdata.hmenu = pfmh->hmenu;
                fmcbdata.iPos = i;
                fmcbdata.idCmd = GetMenuItemID(pfmh->hmenu, i);
                if (bUseAlt)
                {
                    fmcbdata.pidlFolder = pfmh->pidlAltFolder;
                    fmcbdata.psf = pfmh->psfAlt;
                }
                else
                {
                    fmcbdata.pidlFolder = pfmh->pidlFolder;
                    fmcbdata.psf = pfmh->psf;
                }
                fmcbdata.pidl = pfmi->pidl;
                fmcbdata.pvHeader = pfmh;

                pfmh->pfncb(FMM_REMOVE, &fmcbdata, 0);
            }

            // (We don't need to worry about recursively deleting
            // subfolders because their contents haven't been added yet.)

            // Delete the item itself (note there is no menu item
            // to delete)
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
        }
    }
}


/*----------------------------------------------------------
Purpose: This function adds a "More Items..." menu item
         at the bottom of the menu.  It calls the callback
         to get the string.

Returns: 
Cond:    --
*/
void
FileMenuHeader_AddMoreItemsItem(
    IN PFILEMENUHEADER pfmh,
    IN UINT            iPos)
{
    PFILEMENUITEM pfmi;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (NULL == pfmh->pfncb)
    {
        // BUGBUG (scotth): this shouldn't be required, but we don't
        // have a default resource ID for this right now.

        TraceMsg(TF_ERROR, "Need a callback in order to add a More item.");
        ASSERT(0);
    }
    else if (FileMenuItem_Create(pfmh, NULL, -1, 0, &pfmi))
    {
        FMCBDATA fmcbdata;
        FMMORESTRING fmms = {0};

        // Make the pidl be the whole path to the folder
        pfmi->pidl = ILClone(pfmh->pidlFolder);
        pfmi->Flags |= FMI_IGNORE_PIDL;

        fmcbdata.hmenu = pfmh->hmenu;
        fmcbdata.iPos = -1;
        fmcbdata.idCmd = (UINT)-1;

        // BUGBUG (scotth): we don't ask for string for alternate lists
        fmcbdata.pidlFolder = NULL;
        fmcbdata.pidl = pfmi->pidl;
        fmcbdata.psf = pfmh->psf;

        // Was a string set?
        if (S_OK == pfmh->pfncb(FMM_GETMORESTRING, &fmcbdata, (LPARAM)&fmms))
        {
            Sz_AllocCopy(fmms.szMoreString, &(pfmi->psz));

            if (DPA_SetPtr(pfmh->hdpa, iPos, pfmi))
            {
                MENUITEMINFO mii;

                // Set the command ID
                mii.cbSize = SIZEOF(mii);
                mii.fMask  = MIIM_ID | MIIM_TYPE | MIIM_DATA;
                mii.wID    = fmms.uID;
                mii.fType  = MFT_OWNERDRAW;
                mii.dwItemData = (DWORD_PTR)pfmi;

                EVAL(InsertMenuItem(pfmh->hmenu, iPos, TRUE, &mii));
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Enumerates the DPA and adds each item into the
         menu.  Inserts vertical breaks if the menu becomes
         too long.

Returns: count of items added to menu
Cond:    --
*/
int
FileList_AddToMenu(
    IN PFILEMENUHEADER pfmh,
    IN BOOL            bUseAlt,
    IN BOOL            bAddSeparatorSpace)
{
    UINT i, cItems;
    int cItemMac;
    PFILEMENUITEM pfmi;
    int cyMenu, cyItem, cyMenuMax;
    HDC hdc;
    HFONT hfont, hfontOld;
    NONCLIENTMETRICS ncm;
    int idpa;
    HDPA hdpaT;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (bUseAlt)
        hdpaT = pfmh->hdpaAlt;
    else
        hdpaT = pfmh->hdpa;

    cItemMac = 0;
    cyItem = 0;
    cyMenu = pfmh->cyMenuSizeSinceLastBreak;

    if (0 < pfmh->cyMax)
        cyMenuMax = pfmh->cyMax;
    else
        cyMenuMax = GetSystemMetrics(SM_CYSCREEN);

    // Get the rough height of an item so we can work out when to break the
    // menu. User should really do this for us but that would be useful.
    hdc = GetDC(NULL);
    if (hdc)
    {
        ncm.cbSize = SIZEOF(NONCLIENTMETRICS);
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, SIZEOF(ncm), &ncm, FALSE))
        {
            hfont = CreateFontIndirect(&ncm.lfMenuFont);
            if (hfont)
            {
                hfontOld = SelectFont(hdc, hfont);
                cyItem = HIWORD(GetItemExtent(hdc, (PFILEMENUITEM)DPA_GetPtr(hdpaT, 0)));
                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
            }
        }
        ReleaseDC(NULL, hdc);
    }

    // If we are appending items to a menu, we need to account
    // for the separator.

    if (bAddSeparatorSpace) {
        cyMenu += cyItem;
    }

    cItems = DPA_GetPtrCount(hdpaT);

    for (i = 0; i < cItems; i++)
    {
        if (bUseAlt) {
            // Move the items from the alternate list to the main
            // list and use the new index.
            pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpaAlt, i);
            if (!pfmi)
                continue;

            idpa = DPA_AppendPtr(pfmh->hdpa, pfmi);

        } else {
            idpa = i;
        }

        // Keep a rough count of the height of the menu.
        cyMenu += cyItem;
        if (cyMenu > cyMenuMax)
        {
            // Add a vertical break?
            if ( !(pfmh->fmf & (FMF_NOBREAK | FMF_RESTRICTHEIGHT)) )
            {
                // Yes
                FileMenuHeader_InsertItem(pfmh, idpa, FMII_BREAK);
                cyMenu = cyItem;
            }
            // Restrict height?
            else if (IsFlagSet(pfmh->fmf, FMF_RESTRICTHEIGHT))
            {
                // Yes; remove the remaining items from the list
                FileList_StripLeftOvers(pfmh, idpa, bUseAlt);

                // (so cyMenuSizeSinceLastBreak is accurate)
                cyMenu -= cyItem;

                // Add a "more..." item at the end?
                if (pfmh->fmf & FMF_MOREITEMS)
                {
                    // Yes
                    FileMenuHeader_AddMoreItemsItem(pfmh, idpa);
                }

                // We won't go any further
                break;
            }
        }
        else
        {
            FileMenuHeader_InsertItem(pfmh, idpa, FMII_DEFAULT);
            cItemMac++;
        }
    }

    // Save the current cy size so we can use this again
    // if more items are appended to this menu.

    pfmh->cyMenuSizeSinceLastBreak = cyMenu;

    return cItemMac;
}


BOOL
FileList_AddImages(
    IN PFILEMENUHEADER pfmh,
    IN BOOL            bUseAlt)
{
    PFILEMENUITEM pfmi;
    int i, cItems;
    HDPA hdpaTemp;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (bUseAlt) {
        hdpaTemp = pfmh->hdpaAlt;
    } else {
        hdpaTemp = pfmh->hdpa;
    }

    cItems = DPA_GetPtrCount(hdpaTemp);
    for (i = 0; i < cItems; i++)
    {
        if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
        {
            TraceMsg(TF_MENU, "FileList_AddImages: Abort: Defering images till later.");
            break;
        }

        pfmi = (PFILEMENUITEM)DPA_GetPtr(hdpaTemp, i);
        if (pfmi && pfmi->pidl && (pfmi->iImage == -1) &&
            IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(
                                (bUseAlt ? pfmh->psfAlt : pfmh->psf),
                                pfmi->pidl, NULL);
        }
    }
    return TRUE;
}


//---------------------------------------------------------------------------
BOOL FileMenuItem_Destroy(PFILEMENUITEM pfmi)
{
    BOOL fRet = FALSE;

    ASSERT(NULL == pfmi || IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    if (pfmi)
    {
        if (pfmi->pidl)
            ILFree(pfmi->pidl);
        if (pfmi->psz)
            LFree(pfmi->psz);
        if (pfmi->pszTooltip)
            LFree(pfmi->pszTooltip);
        LocalFree(pfmi);
        fRet = TRUE;
    }

    return fRet;
}

//---------------------------------------------------------------------------
// Clean up the items created by FileList_Build;
void FileList_UnBuild(PFILEMENUHEADER pfmh)
{
    int cItems;
    int i;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    cItems = DPA_GetPtrCount(pfmh->hdpa);
    for (i=cItems-1; i>=0; i--)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
        if (FileMenuItem_Destroy(pfmi))
            DPA_DeletePtr(pfmh->hdpa, i);
    }
}


// Flags for FileMenuHeader_AddFiles
#define FMHAF_USEALT            0x0001
#define FMHAF_SEPARATOR         0x0002

/*----------------------------------------------------------
Purpose: Add files to a file menu header. This function goes thru
         the following steps:

         - enumerates the folder and fills the hdpa list with items
           (files and subfolders)
         - sorts the list
         - gets the images for the items in the list
         - adds the items from list into actual menu

         The last step also (optionally) caps the length of the
         menu to the specified height.  Ideally, this should
         happen at the enumeration time, except the required sort
         prevents this from happening.  So we end up adding a
         bunch of items to the list and then removing them if
         there are too many.

Returns: count of items added
         -1 if aborted
Cond:    --
*/
HRESULT
FileMenuHeader_AddFiles(
    IN  PFILEMENUHEADER pfmh,
    IN  int             iPos,
    IN  UINT            uFlags,                 // FMHAF_*
    OUT int *           pcItems)
{
    HRESULT hres;
    BOOL bUseAlt = IsFlagSet(uFlags, FMHAF_USEALT);

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    int cItems = FileList_Build(pfmh, iPos, bUseAlt);

    // If the build was aborted cleanup and early out.
    if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
    {
        // Cleanup.
        TraceMsg(TF_MENU, "FileList_Build aborted.");
        FileList_UnBuild(pfmh);
        hres = E_ABORT;
        *pcItems = -1;
    }
    else
    {
        *pcItems = cItems;

        if (cItems > 1)
            FileList_Sort(pfmh);

        if (cItems != 0)
        {
            BOOL bSeparator = IsFlagSet(uFlags, FMHAF_SEPARATOR);
            if (bSeparator)
            {
                // insert a line
                FileMenu_AppendItem(pfmh->hmenu, (LPTSTR)FMAI_SEPARATOR, 0, -1, NULL, 0);
            }

            // Add the images *after* adding to the menu, since the menu
            // may be capped to a maximum height, and we can then prevent
            // adding images we won't need.
            *pcItems = FileList_AddToMenu(pfmh, bUseAlt, bSeparator);
            FileList_AddImages(pfmh, bUseAlt);
        }

        hres = (*pcItems < cItems) ? S_FALSE : S_OK;
    }

    if (g_fAbortInitMenu)
        g_fAbortInitMenu = FALSE;

    TraceMsg(TF_MENU, "FileMenuHeader_AddFiles: Added %d filemenu items.", cItems);
    return hres;
}


//----------------------------------------------------------------------------
// Free up a header (you should delete all the items first).
void FileMenuHeader_Destroy(PFILEMENUHEADER pfmh)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    TraceMsg(TF_MENU, "Destroy filemenu for (%x)", pfmh);

    // Clean up the header.
    DPA_Destroy(pfmh->hdpa);
    if (pfmh->pidlFolder)
    {
        ILFree(pfmh->pidlFolder);
        pfmh->pidlFolder = NULL;
    }
    if (pfmh->psf)
    {
        pfmh->psf->Release();
        pfmh->psf = NULL;
    }

    if (pfmh->pstm)
    {
        pfmh->pstm->Release();
        pfmh->pstm = NULL;
    }

    if (pfmh->pidlAltFolder)
    {
        ILFree(pfmh->pidlAltFolder);
        pfmh->pidlAltFolder = NULL;
    }
    if (pfmh->psfAlt)
    {
        pfmh->psfAlt->Release();
        pfmh->psfAlt = NULL;
    }
    if (pfmh->pszFilterTypes)
    {
        LFree(pfmh->pszFilterTypes);
        pfmh->pszFilterTypes = NULL;
    }

    LocalFree((HLOCAL)pfmh);    // needed?
}

//---------------------------------------------------------------------------
// We create subemnu's with one marker item so we can check it's a file menu
// at init popup time but we need to delete it before adding new items.
BOOL FileMenuHeader_DeleteMarkerItem(PFILEMENUHEADER pfmh)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // It should just be the only one in the menu.
    if (GetMenuItemCount(pfmh->hmenu) == 1)
    {
        // It should have the right id.
        if (GetMenuItemID(pfmh->hmenu, 0) == pfmh->idCmd)
        {
            // With item data and the marker flag set.
            PFILEMENUITEM pfmi = FileMenu_GetItemData(pfmh->hmenu, 0, TRUE);
            if (pfmi && (pfmi->Flags & FMI_MARKER))
            {
                // Delete it.
                ASSERT(pfmh->hdpa);
                ASSERT(DPA_GetPtrCount(pfmh->hdpa) == 1);
                // NB The marker shouldn't have a pidl.
                ASSERT(!pfmi->pidl);

                LocalFree((HLOCAL)pfmi);

                DPA_DeletePtr(pfmh->hdpa, 0);
                DeleteMenu(pfmh->hmenu, 0, MF_BYPOSITION);
                // Cleanup OK.
                return TRUE;
            }
        }
    }

    TraceMsg(TF_MENU, "Can't find marker item.");
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Add files to this menu.

Returns: number of items added
Cond:    --
*/
HRESULT
FileMenu_AddFiles(
    IN     HMENU       hmenu,
    IN     UINT        iPos,
    IN OUT FMCOMPOSE * pfmc)
{
    HRESULT hres = E_OUTOFMEMORY;
    BOOL fMarker = FALSE;
    PFILEMENUHEADER pfmh;

    // NOTE:  this function takes in FMCOMPOSE, which can be A or W
    //        version depending on the platform.  Since the function 
    //        is internal, wrapped by FileMenu_ComposeA/W, it expects 
    //        the pidl to be valid, and will not use the pszFolder field.

    if (IsFlagClear(pfmc->dwMask, FMC_FILTER))
        pfmc->dwFSFilter = 0;

    if (IsFlagClear(pfmc->dwMask, FMC_FLAGS))
        pfmc->dwFlags = 0;

    // (FileMenuHeader_Create might return an existing header)
    pfmh = FileMenuHeader_Create(hmenu, NULL, 0, (COLORREF)-1, 0, pfmc);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
        if (pfmi)
        {
            // Clean up marker item if there is one.
            if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
            {
                // Nope, do it now.
                TraceMsg(TF_MENU, "Removing marker item.");
                FileMenuHeader_DeleteMarkerItem(pfmh);
                fMarker = TRUE;
                if (iPos)
                    iPos--;
            }
        }

        // Add the new stuff
        FileMenuHeader_SetFolderInfo(pfmh, pfmc);

        // Tack on more flags
        pfmh->fmf |= pfmc->dwFlags;

        SetFlag(pfmh->fmf, FMF_NOABORT);
        hres = FileMenuHeader_AddFiles(pfmh, iPos, 0, &pfmc->cItems);
        ClearFlag(pfmh->fmf, FMF_NOABORT);

        if ((E_ABORT == hres || 0 == pfmc->cItems) && fMarker)
        {
            // Aborted or no items. Put the marker back (if there used
            // to be one).
            FileMenuHeader_InsertMarkerItem(pfmh);
        }
    }

    return hres;
}


//---------------------------------------------------------------------------
// Returns the number of items added.
STDAPI_(UINT)
FileMenu_AppendFilesForPidl(
    HMENU hmenu,
    LPITEMIDLIST pidl,
    BOOL bInsertSeparator)
{
    int cItems = 0;
    BOOL fMarker = FALSE;
    PFILEMENUHEADER pfmh;
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    ASSERT(IS_VALID_PIDL(pidl));

    //
    // Get the filemenu header from the first filemenu item
    //

    if (!pfmi)
        return 0;

    pfmh = pfmi->pfmh;


    if (pfmh)
    {
        // Clean up marker item if there is one.
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            // Nope, do it now.
            // TraceMsg(DM_TRACE, "t.fm_ii: Removing marker item.");
            FileMenuHeader_DeleteMarkerItem(pfmh);
            fMarker = TRUE;
        }

        // Add the new stuff.
        if (pidl)
        {
            LPSHELLFOLDER psfDesktop;
            if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
            {
                pfmh->pidlAltFolder = ILClone(pidl);

                if (pfmh->pidlAltFolder) {

                    pfmh->hdpaAlt = DPA_Create(0);

                    if (pfmh->hdpaAlt) {

                        if (SUCCEEDED(psfDesktop->BindToObject(pfmh->pidlAltFolder, 
                            NULL, IID_IShellFolder, (LPVOID *)&pfmh->psfAlt)))
                        {
                            UINT uFlags = FMHAF_USEALT;

                            if (bInsertSeparator)
                                uFlags |= FMHAF_SEPARATOR;

                            pfmh->fmf |= FMF_NOABORT;
                            FileMenuHeader_AddFiles(pfmh, 0, uFlags, &cItems);
                            pfmh->fmf = pfmh->fmf & ~FMF_NOABORT;
                        }

                        DPA_Destroy (pfmh->hdpaAlt);
                        pfmh->hdpaAlt = NULL;
                    }
                }
                // we assume this is a static object... which it is.
                // psfDesktop->Release();
            }
        }

        if (cItems <= 0 && fMarker)
        {
            // Aborted or no item  s. Put the marker back (if there used
            // to be one).
            FileMenuHeader_InsertMarkerItem(pfmh);
        }
    }

    return cItems;
}


//---------------------------------------------------------------------------
// Delete all the menu items listed in the given header.
UINT
FileMenuHeader_DeleteAllItems(
    IN PFILEMENUHEADER pfmh)
{
    int i;
    int cItems = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER))
    {
        // Notify.
        if (pfmh->pfncb)
            {
            FMCBDATA fmcbdata;

            fmcbdata.hmenu = pfmh->hmenu;
            fmcbdata.iPos = 0;
            fmcbdata.idCmd = (UINT)-1;
            fmcbdata.pidlFolder = pfmh->pidlFolder;
            fmcbdata.pidl = NULL;
            fmcbdata.psf = pfmh->psf;
            fmcbdata.pvHeader = pfmh;

            pfmh->pfncb(FMM_DELETEALL, &fmcbdata, 0);
            }

        // Clean up the items.
        cItems = DPA_GetPtrCount(pfmh->hdpa);
        // Do this backwards to stop things moving around as
        // we delete them.
        for (i = cItems - 1; i >= 0; i--)
        {
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                // Does this item have a subfolder?
                if (pfmi->Flags & FMI_FOLDER)
                {
                    // Yep.
                    // Get the submenu for this item.
                    // Delete all it's items.
                    FileMenu_DeleteAllItems(GetSubMenu(pfmh->hmenu, i));
                }
                // Delete the item itself.
                DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
                FileMenuItem_Destroy(pfmi);
                DPA_DeletePtr(pfmh->hdpa, i);
            }
        }
    }
    return cItems;
}

//---------------------------------------------------------------------------
// NB The creator of the filemenu has to explicitly call FileMenu_DAI to free
// up FileMenu items because USER doesn't send WM_DELETEITEM for ownerdraw
// menu. Great eh?
// Returns the number of items deleted.
UINT  FileMenu_DeleteAllItems(HMENU hmenu)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return 0;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
        
        // Save the order if necessary
        if (IsFlagSet(pfmh->fmf, FMF_DIRTY | FMF_CANORDER))
        {
            FileMenu_SaveOrder(pfmh->hmenu);
            ClearFlag(pfmh->fmf, FMF_DIRTY);
        }

        UINT cItems = FileMenuHeader_DeleteAllItems(pfmh);
        FileMenuHeader_Destroy(pfmh);
        return cItems;
    }

    return 0;
}

//---------------------------------------------------------------------------
STDAPI_(void)
FileMenu_Destroy(HMENU hmenu)
{
    TraceMsg(TF_MENU, "Destroying filemenu for %#08x", hmenu);

    FileMenu_DeleteAllItems(hmenu);
    DestroyMenu(hmenu);

    // Reset the menu tracking agent
    g_fsmenuagent.Reset();

    //
    // Delete current global g_hdcMem and g_hfont so they'll be
    // refreshed with current font metrics next time the menu size
    // is calculated.  This is needed in case the menu is being destroyed
    // as part of a system metrics change.
    //
    DeleteGlobalMemDCAndFont();
}


//---------------------------------------------------------------------------
// Cause the given filemenu to be rebuilt.
STDAPI_(void)
FileMenu_Invalidate(HMENU hmenu)
{
    ASSERT(IS_VALID_HANDLE(hmenu, MENU));

    // Is this a filemenu?
    // NB First menu item must be a FileMenuItem.
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi)
    {
        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

        // Yep, Is there already a marker here?
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            TraceMsg(TF_MENU, "Menu is already invalid.");
        }
        else if (pfmi->pfmh)
        {
            PFILEMENUHEADER pfmhSave = pfmi->pfmh;

            FileMenuHeader_DeleteAllItems(pfmi->pfmh);

            ASSERT(IS_VALID_STRUCT_PTR(pfmhSave, FILEMENUHEADER));

            // above call freed pfmi
            FileMenuHeader_InsertMarkerItem(pfmhSave);
        }
    }
}


//---------------------------------------------------------------------------
// Cause the given filemenu to be marked invalid but don't delete any items
// yet.
void  FileMenu_DelayedInvalidate(HMENU hmenu)
{
    // Is this a filemenu?
    // NB First menu item must be a FileMenuItem.
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi && pfmi->pfmh)
        SetFlag(pfmi->pfmh->fmf, FMF_DELAY_INVALID);
}


BOOL  FileMenu_IsDelayedInvalid(HMENU hmenu)
{
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    return (pfmi && pfmi->pfmh &&
            IsFlagSet(pfmi->pfmh->fmf, FMF_DELAY_INVALID));
}


/*----------------------------------------------------------
Purpose: Compose a file menu.

         Ansi version

Returns: S_OK if all the files were added
         S_FALSE if some did not get added (reached cyMax)
         error on something bad
Cond:    --
*/
STDAPI
FileMenu_ComposeA(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN FMCOMPOSEA * pfmc)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(pfmc, FMCOMPOSEA) &&
        SIZEOF(*pfmc) == pfmc->cbSize)
    {
        FMCOMPOSEA fmc;

        fmc = *pfmc;

        if (IsFlagSet(fmc.dwMask, FMC_STRING))
        {
            // Convert string to pidl
            TCHAR szFolder[MAX_PATH];

#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, fmc.pszFolder, -1, szFolder,
                                SIZECHARS(szFolder));
#else
            lstrcpy(szFolder, fmc.pszFolder);
#endif
            fmc.pidlFolder = ILCreateFromPath(szFolder);
            if (NULL == fmc.pidlFolder)
            {
                hres = E_OUTOFMEMORY;
                goto Bail;
            }
        }
        else if (IsFlagClear(fmc.dwMask, FMC_PIDL))
        {
            // Either FMC_PIDL or FMC_STRING must be set
            hres = E_INVALIDARG;
            goto Bail;
        }

        switch (nMethod)
        {
        case FMCM_INSERT:
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        case FMCM_APPEND:
            hres = FileMenu_AddFiles(hmenu, GetMenuItemCount(hmenu),
                                     (FMCOMPOSE *)&fmc);
            break;

        case FMCM_REPLACE:
            FileMenu_DeleteAllItems(hmenu);
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        default:
            ASSERT(0);
            goto Bail;
        }

        pfmc->cItems = fmc.cItems;

Bail:
        // Cleanup
        if (IsFlagSet(fmc.dwMask, FMC_STRING) && fmc.pidlFolder)
            ILFree(fmc.pidlFolder);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Compose a file menu.

         Unicode version

Returns:
Cond:    --
*/
STDAPI
FileMenu_ComposeW(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN FMCOMPOSEW * pfmc)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(pfmc, FMCOMPOSEW) &&
        SIZEOF(*pfmc) == pfmc->cbSize)
    {
        FMCOMPOSEW fmc;

        fmc = *pfmc;

        if (IsFlagSet(fmc.dwMask, FMC_STRING))
        {
            // Convert string to pidl
            TCHAR szFolder[MAX_PATH];

#ifdef UNICODE
            lstrcpy(szFolder, fmc.pszFolder);
#else
            WideCharToMultiByte(CP_ACP, 0, fmc.pszFolder, -1, szFolder,
                                SIZECHARS(szFolder), NULL, NULL);
#endif
            fmc.pidlFolder = ILCreateFromPath(szFolder);
            if (NULL == fmc.pidlFolder)
            {
                hres = E_OUTOFMEMORY;
                goto Bail;
            }
        }
        else if (IsFlagClear(fmc.dwMask, FMC_PIDL))
        {
            // Either FMC_PIDL or FMC_STRING must be set
            hres = E_INVALIDARG;
            goto Bail;
        }

        switch (nMethod)
        {
        case FMCM_INSERT:
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        case FMCM_APPEND:
            hres = FileMenu_AddFiles(hmenu, GetMenuItemCount(hmenu),
                                     (FMCOMPOSE *)&fmc);
            break;

        case FMCM_REPLACE:
            FileMenu_DeleteAllItems(hmenu);
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        default:
            ASSERT(0);
            goto Bail;
        }

        pfmc->cItems = fmc.cItems;

Bail:
        // Cleanup
        if (IsFlagSet(fmc.dwMask, FMC_STRING) && fmc.pidlFolder)
            ILFree(fmc.pidlFolder);
    }

    return hres;
}


LRESULT FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi)
{
    int y, x;
    TCHAR szName[MAX_PATH];
    DWORD dwExtent;
    int cxIcon, cyIcon;
    RECT rcBkg;
    HBRUSH hbrOld = NULL;
    UINT cyItem, dyItem;
    HIMAGELIST himl;
    RECT rcClip;

    if ((pdi->itemAction & ODA_SELECT) || (pdi->itemAction & ODA_DRAWENTIRE))
    {
        PFILEMENUHEADER pfmh;
        PFILEMENUITEM pfmi = (PFILEMENUITEM)pdi->itemData;
        IShellFolder * psf;

#ifndef UNIX
        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));
#endif
        
        if (!pfmi)
        {
            TraceMsg(TF_ERROR, "FileMenu_DrawItem: Filemenu is invalid (no item data).");
            return FALSE;
        }

        pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        if (pfmi->Flags & FMI_ALTITEM)
            psf = pfmh->psfAlt;
        else
            psf = pfmh->psf;

        // Adjust for large/small icons.
        if (pfmh->fmf & FMF_LARGEICONS)
        {
            cxIcon = g_cxIcon;
            cyIcon = g_cyIcon;
        }
        else
        {
            cxIcon = g_cxSmIcon;
            cyIcon = g_cxSmIcon;
        }

        // Is the menu just starting to get drawn?
        if (pdi->itemAction & ODA_DRAWENTIRE)
        {
            if (pfmi == DPA_GetPtr(pfmh->hdpa, 0))
            {
                // Yes; reset the last selection item
                g_pfmiLastSelNonFolder = NULL;
                g_pfmiLastSel = NULL;

                // Initialize to handle drag and drop?
                if (pfmh->fmf & FMF_CANORDER)
                {
                    // Yes
                    g_fsmenuagent.Init();
                }
            }
        }


        if (pdi->itemState & ODS_SELECTED)
        {
            if (pfmh->fmf & FMF_CANORDER)
            {
                // Pass on the current hDC and selection rect so the 
                // drag/drop hook can actively draw

                RECT rc = pdi->rcItem;
                
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));

                // With no background image, the caret goes all the way 
                // across; otherwise it stops in line with the bitmap.
                if (pfmh->hbmp)
                    rc.left += pfmh->cxBmpGap;

                g_fsmenuagent.SetCurrentRect(pdi->hDC, &rc);
                g_fsmenuagent.SetItem(pfmi);

                // Are we in edit mode?
                if (MenuDD_IsButtonDown())
                {
                    // Yes
                    g_fsmenuagent.SetEditMode(TRUE, DROPEFFECT_MOVE);
                }
            }

            // Determine the selection colors
            //
            // Normal menu colors apply until we are in edit mode, in which
            // case the menu item is drawn unselected and an insertion caret 
            // is drawn above or below the current item.  The exception is 
            // if the item is a cascaded menu item, then we draw it 
            // normally, but also show the insertion caret.  (We do this
            // because Office does this, and also, USER draws the arrow
            // in the selected color always, so it looks kind of funny 
            // if we don't select the menu item.)
            //

            // Is the user dragging and dropping and we're not over
            // a cascaded menu item?
            if ((pfmh->fmf & FMF_CANORDER) && MenuDD_InEditMode() &&
                !(pfmi->Flags & FMI_FOLDER))
            {
                // Yes; show the item in the unselected colors
                // (dwRop = SRCAND)
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));
            }
            else
            {
                // No
                SetBkColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_HIGHLIGHTTEXT));
            }

            // REVIEW HACK NB - keep track of the last selected item.
            // NB The keyboard handler needs to know about all selections
            // but the WM_COMMAND stuff only cares about non-folders.
            g_pfmiLastSel = pfmi;
            if (!(pfmi->Flags & FMI_FOLDER))
                g_pfmiLastSelNonFolder = pfmi;
            // Get the rect of the item in screen coords.
            g_rcItem = pdi->rcItem;
            MapWindowPoints(WindowFromDC(pdi->hDC), NULL, (LPPOINT)&g_rcItem, 2);
        }
        else
        {
            // dwRop = SRCAND;
            hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));
        }

        // Initial start pos.
        x = pdi->rcItem.left+CXIMAGEGAP;

        // Draw the background image.
        if (pfmh->hbmp)
        {
            // Draw it the first time the first item paints.
            if (pfmi == DPA_GetPtr(pfmh->hdpa, 0) &&
                (pdi->itemAction & ODA_DRAWENTIRE))
            {
                if (!g_hdcMem)
                {
                    g_hdcMem = CreateCompatibleDC(pdi->hDC);
                    ASSERT(g_hdcMem);
                }
                if (g_hdcMem)
                {
                    HBITMAP hbmOld;

                    if (!pfmh->yBmp)
                    {
                        GetClipBox(pdi->hDC, &rcClip);
                        pfmh->yBmp = rcClip.bottom;
                    }
                    hbmOld = SelectBitmap(g_hdcMem, pfmh->hbmp);
                    BitBlt(pdi->hDC, 0, pfmh->yBmp-pfmh->cyBmp, pfmh->cxBmp, pfmh->cyBmp, g_hdcMem, 0, 0, SRCCOPY);
                    SelectBitmap(g_hdcMem, hbmOld);
                }
            }
            x += pfmh->cxBmpGap;
        }

        // Background color for when the bitmap runs out.
        if ((pfmh->clrBkg != (COLORREF)-1) &&
            (pfmi == DPA_GetPtr(pfmh->hdpa, 0)) &&
            (pdi->itemAction & ODA_DRAWENTIRE))
        {
            HBRUSH hbr;

            if (!pfmh->yBmp)
            {
                GetClipBox(pdi->hDC, &rcClip);
                pfmh->yBmp = rcClip.bottom;
            }
            rcBkg.top = 0;
            rcBkg.left = 0;
            rcBkg.bottom = pfmh->yBmp - pfmh->cyBmp;
            rcBkg.right = max(pfmh->cxBmp, pfmh->cxBmpGap);
            hbr = CreateSolidBrush(pfmh->clrBkg);
            FillRect(pdi->hDC, &rcBkg, hbr);
            DeleteObject(hbr);
        }

        // Special case the separator.
        if (pfmi->Flags & FMI_SEPARATOR)
        {
            // With no background image it goes all the way across otherwise
            // it stops in line with the bitmap.
            if (pfmh->hbmp)
                pdi->rcItem.left += pfmh->cxBmpGap;
            pdi->rcItem.bottom = (pdi->rcItem.top+pdi->rcItem.bottom)/2;
            DrawEdge(pdi->hDC, &pdi->rcItem, EDGE_ETCHED, BF_BOTTOM);
            // Early out.
            goto ExitProc;
        }

        // Have the selection not include the icon to speed up drawing while
        // tracking.
        pdi->rcItem.left += pfmh->cxBmpGap;

        // Get the name.
        FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

        // Limit the width of the text?
        if (0 < pfmh->cxMax)
        {
            // Yes
            PathCompactPath(pdi->hDC, szName, pfmh->cxMax);
        }

        // NB Keep a plain copy of the name for testing and accessibility.
        if (!pfmi->psz)
            Sz_AllocCopy(szName, &(pfmi->psz));

        dwExtent = GetItemTextExtent(pdi->hDC, szName);
        y = (pdi->rcItem.bottom+pdi->rcItem.top-HIWORD(dwExtent))/2;
        // Support custom heights for the selection rectangle.
        if (pfmh->cySel)
        {
            cyItem = pdi->rcItem.bottom-pdi->rcItem.top;
            // Is there room?
            if ((cyItem > pfmh->cySel) && (pfmh->cySel > HIWORD(dwExtent)))
            {
                dyItem = (cyItem-pfmh->cySel)/2;
                pdi->rcItem.top += dyItem ;
                pdi->rcItem.bottom -= dyItem;
            }
        }
        else if(!(pfmh->fmf & FMF_LARGEICONS))
        {
            // Shrink the selection rect for small icons a bit.
            pdi->rcItem.top += 1;
            pdi->rcItem.bottom -= 1;
        }


        // Draw the text.

        int fDSFlags;

        if (pfmi->Flags & FMI_IGNORE_PIDL)
        {
            //
            // If the string is not coming from a pidl,
            // we can format the menu text.
            //
            fDSFlags = DST_PREFIXTEXT;
        }
        else if ((pfmi->Flags & FMI_ON_MENU) == 0)
        {
            //
            // Norton Desktop Navigator 95 replaces the Start->&Run
            // menu item with a &Run pidl.  Even though the text is
            // from a pidl, we still want to format the "&R" correctly.
            //
            fDSFlags = DST_PREFIXTEXT;
        }
        else
        {
            //
            // All other strings coming from pidls are displayed
            // as is to preserve any & in their display name.
            //
            fDSFlags = DST_TEXT;
        }

        if ((pfmi->Flags & FMI_EMPTY) || (pfmi->Flags & FMI_DISABLED))
        {
            if (pdi->itemState & ODS_SELECTED)
            {
                if (GetSysColor(COLOR_GRAYTEXT) == GetSysColor(COLOR_HIGHLIGHTTEXT))
                {
                    fDSFlags |= DSS_UNION;
                }
                else
                {
                    SetTextColor(pdi->hDC, GetSysColor(COLOR_GRAYTEXT));
                }
            }
            else
            {
                fDSFlags |= DSS_DISABLED;
            }

            ExtTextOut(pdi->hDC, 0, 0, ETO_OPAQUE, &pdi->rcItem, NULL, 0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x+cxIcon+CXIMAGEGAP,
                y, 0, 0, fDSFlags);
        }
        else
        {
            ExtTextOut(pdi->hDC, x+cxIcon+CXIMAGEGAP, y, ETO_OPAQUE, &pdi->rcItem, NULL,
                0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x+cxIcon+CXIMAGEGAP,
                y, 0, 0, fDSFlags);
        }

        // Get the image if it needs it,
        if ((pfmi->iImage == -1) && pfmi->pidl && psf &&
            IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(psf, pfmi->pidl, NULL);
        }

        // Draw the image (if there is one).
        if (pfmi->iImage != -1)
        {
            int nDC = 0;

            // Try to center image.
            y = (pdi->rcItem.bottom+pdi->rcItem.top-cyIcon)/2;

            if (pfmh->fmf & FMF_LARGEICONS)
            {
                himl = g_himlIcons;
                // Handle minor drawing glitches that can occur with large icons.
                if ((pdi->itemState & ODS_SELECTED) && (y < pdi->rcItem.top))
                {
                    nDC = SaveDC(pdi->hDC);
                    IntersectClipRect(pdi->hDC, pdi->rcItem.left, pdi->rcItem.top,
                        pdi->rcItem.right, pdi->rcItem.bottom);
                }
            }
            else
            {
                himl = g_himlIconsSmall;
            }

            ImageList_DrawEx(himl, pfmi->iImage, pdi->hDC, x, y, 0, 0,
                GetBkColor(pdi->hDC), CLR_NONE, ILD_NORMAL);

            // Restore the clip rect if we were doing custom clipping.
            if (nDC)
                RestoreDC(pdi->hDC, nDC);
        }

        // Is the user dragging and dropping onto an item that accepts
        // a drop?
        if ((pfmh->fmf & FMF_CANORDER) && 
            (pdi->itemState & ODS_SELECTED) &&
            MenuDD_InEditMode() && 
            (pfmi->dwEffect & g_fsmenuagent.GetDragEffect()))
        {
            // Yes; draw the insertion caret 
            RECT rc = pdi->rcItem;
            POINT pt;

            // We actively draw the insertion caret on mouse moves.
            // When the cursor moves between menu items, the msg hook
            // does not get a mouse move until after this paint.  But
            // we need to update the caret position correctly, so do
            // it here too.
            GetCursorPos(&pt);
            g_fsmenuagent.SetCaretPos(&pt);

            rc.left += 4;
            rc.right -= 8;

            TraceMsg(TF_MENU, "MenuDD:  showing caret %s", MenuDD_InsertAbove() ? TEXT("above") : TEXT("below"));

            if (MenuDD_InsertAbove())
            {
                // Hide any existing caret
                HBRUSH hbrSav = SelectBrush(pdi->hDC, MenuDD_GetBrush());
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.bottom - 2, (rc.right - rc.left), 2, PATCOPY);
                SelectBrush(pdi->hDC, hbrSav);
                
                // Show caret in new position
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.top, (rc.right - rc.left), 2, BLACKNESS);
            }
            else
            {
                // Hide any existing caret
                HBRUSH hbrSav = SelectBrush(pdi->hDC, MenuDD_GetBrush());
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.top, (rc.right - rc.left), 2, PATCOPY);
                SelectBrush(pdi->hDC, hbrSav);
                
                // Show caret in new position
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.bottom - 2, (rc.right - rc.left), 2, BLACKNESS);
            }
        }
    }

ExitProc:
    // Cleanup.
    if (hbrOld)
        SelectObject(pdi->hDC, hbrOld);

    return TRUE;
}


DWORD FileMenuItem_GetExtent(PFILEMENUITEM pfmi)
{
    DWORD dwExtent = 0;

    if (pfmi)
    {
        if (pfmi->Flags & FMI_SEPARATOR)
        {
            dwExtent = MAKELONG(0, GetSystemMetrics(SM_CYMENUSIZE)/2);
        }
        else
        {
            PFILEMENUHEADER pfmh = pfmi->pfmh;

            ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

            if (!g_hdcMem)
            {
                g_hdcMem = CreateCompatibleDC(NULL);
                ASSERT(g_hdcMem);
            }
            if (g_hdcMem)
            {
                // Get the rough height of an item so we can work out when to break the
                // menu. User should really do this for us but that would be useful.
                if (!g_hfont)
                {
                    NONCLIENTMETRICS ncm;
                    ncm.cbSize = SIZEOF(ncm);
                    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, SIZEOF(ncm), &ncm, FALSE))
                    {
                        g_hfont = CreateFontIndirect(&ncm.lfMenuFont);
                        ASSERT(g_hfont);
                    }
                }

                if (g_hfont)
                {
                    HFONT hfontOld = SelectFont(g_hdcMem, g_hfont);
                    dwExtent = GetItemExtent(g_hdcMem, pfmi);
                    SelectFont(g_hdcMem, hfontOld);
                    // NB We hang on to the font, it'll get stomped by
                    // FM_TPME on the way out.
                }
                // NB We hang on to the DC, it'll get stomped by FM_TPME on the way out.
            }
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "FileMenu_GetExtent: Filemenu is invalid.");
    }

    return dwExtent;
}


LRESULT FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi)
{
    DWORD dwExtent = FileMenuItem_GetExtent((PFILEMENUITEM)lpmi->itemData);
    lpmi->itemHeight = HIWORD(dwExtent);
    lpmi->itemWidth = LOWORD(dwExtent);

    return TRUE;
}


STDAPI_(DWORD)
FileMenu_GetItemExtent(HMENU hmenu, UINT iItem)
{
    DWORD dwRet = 0;
    PFILEMENUHEADER pfmh = FileMenu_GetHeader(hmenu);

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (pfmh)
        dwRet = FileMenuItem_GetExtent((PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iItem));

    return dwRet;
}

//----------------------------------------------------------------------------
STDAPI_(HMENU)
FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidlFS)
{
    PFILEMENUHEADER pfmh;
    int i;

    if (!pidlFS)
    {
        ASSERT(0);
        return NULL;
    }
    if (ILIsEmpty(pidlFS))
        return hmenu;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        int cItems = DPA_GetPtrCount(pfmh->hdpa);
        for (i = cItems - 1 ; i >= 0; i--)
        {
            // HACK: We directly call this FS function to compare two pidls.
            // For all items, see if it's the one we're looking for.
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);

            if (pfmi && pfmi->pidl && IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL) &&
                0 == pfmh->psf->CompareIDs(0, pidlFS, pfmi->pidl))
            {
                HMENU hmenuSub;

                if ((pfmi->Flags & FMI_FOLDER) &&
                    (NULL != (hmenuSub = GetSubMenu(hmenu, i))))
                {
                    // recurse to find the next sub menu
                    return FileMenu_FindSubMenuByPidl(hmenuSub, (LPITEMIDLIST)ILGetNext(pidlFS));

                }
                else
                {
                    ASSERT(0); // we're screwed.
                    break;
                }
            }
        }
    }
    return NULL;
}


/*----------------------------------------------------------
Purpose: Fills the given filemenu with contents of the appropriate
         directory.

Returns: S_OK if all the files were added
         S_FALSE if some did not get added (reached cyMax)
         error on something bad
Cond:    --
*/
STDAPI
FileMenu_InitMenuPopupEx(
    IN     HMENU   hmenu,
    IN OUT PFMDATA pfmdata)
{
    HRESULT hres = E_INVALIDARG;
    PFILEMENUITEM pfmi;
    PFILEMENUHEADER pfmh;

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));

    if (IS_VALID_WRITE_PTR(pfmdata, FMDATA) &&
        SIZEOF(*pfmdata) == pfmdata->cbSize)
    {
        hres = E_FAIL;      // assume error

        g_fAbortInitMenu = FALSE;

        // Is this a filemenu?
        pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
        if (pfmi)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

            pfmh = pfmi->pfmh;
            if (pfmh)
            {
                // Yes
                if (IsFlagSet(pfmh->fmf, FMF_DELAY_INVALID))
                {
                    FileMenu_Invalidate(hmenu);
                    ClearFlag(pfmh->fmf, FMF_DELAY_INVALID);
                }
                
                // BUGBUG (scotth): this can return S_OK but not
                // set the cItems field if this menu has already
                // been filled out.

                hres = S_OK;

                // Have we already filled this thing out?
                if (IsFlagSet(pfmi->Flags, FMI_MARKER | FMI_EXPAND))
                {
                    // No, do it now.  Get the previously init'ed header.
                    FileMenuHeader_DeleteMarkerItem(pfmh);

                    // Fill it full of stuff.
                    hres = FileMenuHeader_AddFiles(pfmh, 0, 0, &pfmdata->cItems);
                    if (E_ABORT == hres)
                    {
                        // Aborted - put the marker back.
                        FileMenuHeader_InsertMarkerItem(pfmh);
                    }
                    else if (pfmh->pidlAltFolder) 
                    {
                        pfmh->hdpaAlt = DPA_Create(0);

                        if (pfmh->hdpaAlt) 
                        {
                            int cItems;

                            if (E_ABORT == FileMenuHeader_AddFiles(pfmh, 0,
                                           FMHAF_SEPARATOR | FMHAF_USEALT,
                                           &cItems))
                            {
                               // Aborted - put the marker back.
                               FileMenuHeader_InsertMarkerItem(pfmh);
                            }

                            DPA_Destroy (pfmh->hdpaAlt);
                            pfmh->hdpaAlt = NULL;
                        }
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Fills the given filemenu with contents of the appropriate
         directory.

Returns: FALSE if the given menu isn't a filemenu
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_InitMenuPopup(
    IN HMENU hmenu)
{
    FMDATA fmdata = {SIZEOF(fmdata)};   // zero init everything else

    return SUCCEEDED(FileMenu_InitMenuPopupEx(hmenu, &fmdata));
}


BOOL FileMenu_IsUnexpanded(HMENU hmenu)
{
    BOOL fRet = FALSE;
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    if (pfmi)
    {
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
            fRet = TRUE;
    }

    return fRet;
}


//---------------------------------------------------------------------------
// This sets whether to load all the images while creating the menu or to
// defer it until the menu is actually being drawn.
STDAPI_(void)
FileMenu_AbortInitMenu(void)
{
    g_fAbortInitMenu = TRUE;
}


/*----------------------------------------------------------
Purpose: Returns a clone of the last selected pidl

Returns: 
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_GetLastSelectedItemPidls(
    IN  HMENU          hmenu, 
    OUT LPITEMIDLIST * ppidlFolder,         OPTIONAL
    OUT LPITEMIDLIST * ppidlItem)           OPTIONAL
{
    BOOL bRet    = FALSE;
    LPITEMIDLIST pidlFolder = NULL;
    LPITEMIDLIST pidlItem = NULL;

    // BUGBUG (scotth): this global should be moved into the 
    //  instance data of the header.
    if (g_pfmiLastSelNonFolder)
    {
        // Get to the header.
        PFILEMENUHEADER pfmh = g_pfmiLastSelNonFolder->pfmh;
        if (pfmh)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
            
            bRet = TRUE;

            if (ppidlFolder)
            {
                if (g_pfmiLastSelNonFolder->Flags & FMI_ALTITEM)
                    pidlFolder = ILClone(pfmh->pidlAltFolder);
                else
                    pidlFolder = ILClone(pfmh->pidlFolder);
                bRet = (NULL != pidlFolder);
            }

            if (bRet && ppidlItem)
            {
                if (g_pfmiLastSelNonFolder->pidl)
                {
                    pidlItem = ILClone(g_pfmiLastSelNonFolder->pidl);
                    bRet = (NULL != pidlItem);
                }
                else
                    bRet = FALSE;
            }

            if (!bRet)
            {
                if (pidlFolder)
                {
                    // Failed; free the pidl we just allocated
                    ILFree(pidlFolder);
                    pidlFolder = NULL;
                }
            }
        }
    }

    // Init because callers get lazy and don't pay attention to the return
    // value.
    if (ppidlFolder)
        *ppidlFolder = pidlFolder;
    if (ppidlItem)
        *ppidlItem = pidlItem;
    
    if (!bRet)
        TraceMsg(TF_WARNING, "No previously selected item.");

    return bRet;
}


/*----------------------------------------------------------
Purpose: Returns the command ID and hmenu of the last selected
         menu item.  The given hmenuRoot is the parent hmenu
         that must be a FileMenu.

Returns: S_OK 
         S_FALSE if there was no last selected item
Cond:    --
*/
STDAPI
FileMenu_GetLastSelectedItem(
    IN  HMENU   hmenu, 
    OUT HMENU * phmenu,         OPTIONAL
    OUT UINT *  puItem)         OPTIONAL
{
    HRESULT hres = S_FALSE;

    if (phmenu)
        *phmenu = NULL;
    if (puItem)
        *puItem = 0;

    if (g_pfmiLastSelNonFolder)
    {
        // Get to the header.
        PFILEMENUHEADER pfmh = g_pfmiLastSelNonFolder->pfmh;
        if (pfmh)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

            if (phmenu)
                *phmenu = pfmh->hmenu;

            if (puItem)
            {
                // BUGBUG (scotth): this isn't stored right now
                ASSERT(0);
            }
            hres = S_OK;
        }
    }

    return hres;
}


#define AnsiUpperChar(c) ( (TCHAR)LOWORD((DWORD_PTR)CharUpper((LPTSTR)(DWORD)MAKELONG((DWORD) c, 0))) )


int FileMenuHeader_LastSelIndex(PFILEMENUHEADER pfmh)
{
    int i;
    PFILEMENUITEM pfmi;

    for (i = GetMenuItemCount(pfmh->hmenu)-1;i >= 0; i--)
    {
        pfmi = FileMenu_GetItemData(pfmh->hmenu, i, TRUE);
        if (pfmi && (pfmi == g_pfmiLastSel))
            return i;
    }
    return -1;
}


//---------------------------------------------------------------------------
// If the string contains &ch or begins with ch then return TRUE.
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand)
{
    LPTSTR pchAS;

    // Find the first ampersand.
    pchAS = StrChr(lpsz, TEXT('&'));
    if (pchAS && !fIgnoreAmpersand)
    {
        // Yep, is the next char the one we want.
        if (AnsiUpperChar(*CharNext(pchAS)) == AnsiUpperChar(ch))
        {
            // Yep.
            return TRUE;
        }
    }
    else if (AnsiUpperChar(*lpsz) == AnsiUpperChar(ch))
    {
        return TRUE;
    }

    return FALSE;
}


STDAPI_(LRESULT)
FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch)
{
    UINT iItem, cItems, iStep;
    PFILEMENUITEM pfmi;
    int iFoundOne;
    TCHAR szName[MAX_PATH];
    PFILEMENUHEADER pfmh;

    iFoundOne = -1;
    iStep = 0;
    iItem = 0;
    cItems = GetMenuItemCount(hmenu);

    // Start from the last place we looked from.
    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        iItem = FileMenuHeader_LastSelIndex(pfmh) + 1;
        if (iItem >= cItems)
            iItem = 0;
    }

    while (iStep < cItems)
    {
        pfmi = FileMenu_GetItemData(hmenu, iItem, TRUE);
        if (pfmi)
        {
            BOOL bIgnoreAmpersand = (pfmi->pidl && IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL));

            FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));
            if (_MenuCharMatch(szName, ch, bIgnoreAmpersand))
            {
                // Found (another) match.
                if (iFoundOne != -1)
                {
                    // More than one, select the first.
                    return MAKELRESULT(iFoundOne, MNC_SELECT);
                }
                else
                {
                    // Found at least one.
                    iFoundOne = iItem;
                }
            }

        }
        iItem++;
        iStep++;
        // Wrap.
        if (iItem >= cItems)
            iItem = 0;
    }

    // Did we find one?
    if (iFoundOne != -1)
    {
        // Just in case the user types ahead without the selection being drawn.
        pfmi = FileMenu_GetItemData(hmenu, iFoundOne, TRUE);
        if (!(pfmi->Flags & FMI_FOLDER))
            g_pfmiLastSelNonFolder = pfmi;

        return MAKELRESULT(iFoundOne, MNC_EXECUTE);
    }
    else
    {
        // Didn't find it.
        return MAKELRESULT(0, MNC_IGNORE);
    }
}


/*----------------------------------------------------------
Purpose: Create a filemenu from a given normal menu

Returns:
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_CreateFromMenu(
    IN HMENU    hmenu,
    IN COLORREF clr,
    IN int      cxBmpGap,
    IN HBITMAP  hbmp,
    IN int      cySel,
    IN DWORD    fmf)
{
    BOOL fRet = FALSE;

    if (hmenu)
    {
        PFILEMENUHEADER pfmh = FileMenuHeader_Create(hmenu, hbmp, cxBmpGap, clr, cySel, NULL);

        if (!g_himlIcons || !g_himlIconsSmall)
            Shell_GetImageLists(&g_himlIcons, &g_himlIconsSmall);

        if (pfmh)
        {
            // Default flags.
            pfmh->fmf = fmf;
            if (FileMenuHeader_InsertMarkerItem(pfmh))
                fRet = TRUE;
            else
            {
                // BUGBUG (scotth): FileMenuHeader_Create can return a pointer
                //  that is already stored in a filemenu item, in which case this
                //  destroy will stomp a data structure.
                TraceMsg(TF_ERROR, "Can't create file menu.");
                FileMenuHeader_Destroy(pfmh);
            }
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "Menu is null.");
    }

    return fRet;
}


HMENU  FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, DWORD fmf)
{
    HMENU hmenuRet = NULL;
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        if (FileMenu_CreateFromMenu(hmenu, clr, cxBmpGap, hbmp, cySel, fmf))
            hmenuRet = hmenu;
        else
            DestroyMenu(hmenu);
    }

    return hmenuRet;
}


/*----------------------------------------------------------
Purpose: Insert a generic item into a filemenu

Returns:
Cond:    --
*/
STDAPI
FileMenu_InsertItemEx(
    IN HMENU          hmenu,
    IN UINT           iPos,
    IN FMITEM const * pfmitem)
{
    HRESULT hres = E_INVALIDARG;
    PFILEMENUITEM pfmi;
    FMITEM fmitem;

    // Is this a filemenu?
    pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    if (IsValidFMItem(pfmitem, &fmitem) && pfmi)
    {
        // Yes
        PFILEMENUHEADER pfmh = pfmi->pfmh;

        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        // Have we cleaned up the marker item?
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            // Nope, do it now.
            FileMenuHeader_DeleteMarkerItem(pfmh);
        }

        hres = E_OUTOFMEMORY;

        // Add the new item.
        if (FileMenuItem_Create(pfmh, NULL, fmitem.iImage, 0, &pfmi))
        {
            if (fmitem.pvData && IsFlagSet(fmitem.dwType, FMIT_STRING))
            {
                if (!Sz_AllocCopy((LPTSTR)fmitem.pvData, &(pfmi->psz)))
                    TraceMsg(TF_ERROR, "Unable to allocate menu item text.");
                pfmi->Flags |= FMI_IGNORE_PIDL;
            }
            pfmi->cyItem = fmitem.cyItem;
            pfmi->lParam = fmitem.lParam;
            DPA_InsertPtr(pfmh->hdpa, iPos, pfmi);

            if (IsFlagSet(fmitem.dwType, FMIT_SEPARATOR))
            {
                // Override the setting made above, since separator and
                // text are mutually exclusive
                pfmi->Flags = FMI_SEPARATOR;
                InsertMenu(hmenu, iPos, MF_BYPOSITION|MF_OWNERDRAW|MF_DISABLED|MF_SEPARATOR, 
                           fmitem.uID, (LPTSTR)pfmi);
            }
            else if (fmitem.hmenuSub)
            {
                MENUITEMINFO mii;

                pfmi->Flags |= FMI_FOLDER;
                if ((iPos == 0xffff) || (iPos == 0xffffffff))
                    iPos = GetMenuItemCount(pfmh->hmenu);

                InsertMenu(pfmh->hmenu, iPos, MF_BYPOSITION|MF_OWNERDRAW|MF_POPUP, 
                           (UINT_PTR)fmitem.hmenuSub, (LPTSTR)pfmi);
                // Set it's ID.
                mii.cbSize = SIZEOF(mii);
                mii.fMask = MIIM_ID;
                // mii.wID = pfmh->idCmd;
                mii.wID = fmitem.uID;
                SetMenuItemInfo(pfmh->hmenu, iPos, TRUE, &mii);
            }
            else
            {
                InsertMenu(hmenu, iPos, MF_BYPOSITION|MF_OWNERDRAW, 
                           fmitem.uID, (LPTSTR)pfmi);
            }

            hres = S_OK;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Old function to insert a generic item onto a filemenu

Returns:
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_InsertItem(
    IN HMENU  hmenu,
    IN LPTSTR psz,
    IN UINT   id,
    IN int    iImage,
    IN HMENU  hmenuSub,
    IN UINT   cyItem,
    IN UINT   iPos)
{
    FMITEM fmitem;

    fmitem.cbSize = SIZEOF(fmitem);
    fmitem.dwMask = FMI_TYPE | FMI_ID | FMI_IMAGE | FMI_HMENU |
                    FMI_METRICS;

    if ((LPTSTR)FMAI_SEPARATOR == psz)
    {
        fmitem.dwType = FMIT_SEPARATOR;
    }
    else if (NULL == psz)
    {
        fmitem.dwType = 0;
    }
    else
    {
        fmitem.dwType = FMIT_STRING;
#ifdef UNICODE
        fmitem.dwType |= FMIT_UNICODE;
#endif

        fmitem.dwMask |= FMI_DATA;
        fmitem.pvData = psz;
    }

    fmitem.uID = id;
    fmitem.iImage = iImage;
    fmitem.hmenuSub = hmenuSub;
    fmitem.cyItem = cyItem;

    return SUCCEEDED(FileMenu_InsertItemEx(hmenu, iPos, &fmitem));
}


/*----------------------------------------------------------
Purpose: Get info about this filemenu item.

*/
STDAPI
FileMenu_GetItemInfo(
    IN  HMENU   hmenu,
    IN  UINT    uItem,
    IN  BOOL    bByPos,
    OUT PFMITEM pfmitem)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(pfmitem, FMITEM) &&
        SIZEOF(*pfmitem) == pfmitem->cbSize)
    {
        PFILEMENUITEM pfmi;

        hres = E_FAIL;

        pfmi = FileMenu_GetItemData(hmenu, uItem, bByPos);
        if (pfmi)
        {
            // BUGBUG (scotth): we don't fill in all the fields
            
            if (IsFlagSet(pfmitem->dwMask, FMI_LPARAM))
                pfmitem->lParam = pfmi->lParam;
            
            hres = S_OK;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Save the order of the menu to the given stream.

*/
STDAPI
FileMenu_SaveOrder(HMENU hmenu)
{
    HRESULT hres = E_FAIL;
    PFILEMENUITEM pfmi;
    IStream * pstm;

    pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi && FileList_GetStream(pfmi->pfmh, &pstm))
    {
        hres = FileList_Save(pfmi->pfmh, pstm);
        pstm->Release();
    }

    return hres;
}


STDAPI_(BOOL)
FileMenu_AppendItem(HMENU hmenu, LPTSTR psz, UINT id, int iImage,
    HMENU hmenuSub, UINT cyItem)
{
    return FileMenu_InsertItem(hmenu, psz, id, iImage, hmenuSub, cyItem, 0xffff);
}


STDAPI_(BOOL)
FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y,
    HWND hwndOwner, LPTPMPARAMS lpTpm)
{
    BOOL fRet = TrackPopupMenuEx(hmenu, Flags, x, y, hwndOwner, lpTpm);
    // Cleanup.

    DeleteGlobalMemDCAndFont();

    return fRet;
}


//----------------------------------------------------------------------------
// Like Users only this works on submenu's too.
// NB Returns 0 for seperators.
UINT FileMenu_GetMenuItemID(HMENU hmenu, UINT iItem)
{
    MENUITEMINFO mii;

    mii.cbSize = SIZEOF(MENUITEMINFO);
    mii.fMask = MIIM_ID;
    mii.cch = 0;     // just in case

    if (GetMenuItemInfo(hmenu, iItem, TRUE, &mii))
        return mii.wID;

    return 0;
}


PFILEMENUITEM  _FindItemByCmd(PFILEMENUHEADER pfmh, UINT id, int *piPos)
{
    if (pfmh)
    {
        int cItems, i;

        cItems = DPA_GetPtrCount(pfmh->hdpa);
        for (i = 0; i < cItems; i++)
        {
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                // Is this the right item?
                // NB This ignores menu items.
                if (id == GetMenuItemID(pfmh->hmenu, i))
                {
                    // Yep.
                    if (piPos)
                        *piPos = i;
                    return pfmi;
                }
            }
        }
    }
    return NULL;
}


PFILEMENUITEM  _FindMenuOrItemByCmd(PFILEMENUHEADER pfmh, UINT id, int *piPos)
{
    if (pfmh)
    {
        int cItems, i;

        cItems = DPA_GetPtrCount(pfmh->hdpa);
        for (i = 0; i < cItems; i++)
        {
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                // Is this the right item?
                // NB This includes menu items.
                if (id == FileMenu_GetMenuItemID(pfmh->hmenu, i))
                {
                    // Yep.
                    if (piPos)
                        *piPos = i;
                    return pfmi;
                }
            }
        }
    }
    return NULL;
}


//----------------------------------------------------------------------------
// NB This deletes regular items or submenus.
STDAPI_(BOOL)
FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    if (!id)
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        int i;
        PFILEMENUITEM pfmi = _FindMenuOrItemByCmd(pfmh, id, &i);
        if (pfmi)
        {
            // If it's a submenu, delete it's items first.
            HMENU hmenuSub = GetSubMenu(pfmh->hmenu, i);
            if (hmenuSub)
                FileMenu_DeleteAllItems(hmenuSub);
            // Delete the item itself.
            DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iItem);
        if (pfmi)
        {
            // Delete the item itself.
            DeleteMenu(pfmh->hmenu, iItem, MF_BYPOSITION);
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, iItem);
            return TRUE;
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Search for the first sub menu of the given menu, who's first item's ID
// is id. Returns NULL, if nothing is found.
HMENU _FindMenuItemByFirstID(HMENU hmenu, UINT id, int *pi)
{
    int cMax, c;
    MENUITEMINFO mii;

    ASSERT(hmenu);

    // Search all items.
    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_ID;
    mii.cch = 0;     // just in case

    cMax = GetMenuItemCount(hmenu);
    for (c=0; c<cMax; c++)
    {
        // Is this item a submenu?
        HMENU hmenuSub = GetSubMenu(hmenu, c);
        if (hmenuSub && GetMenuItemInfo(hmenuSub, 0, TRUE, &mii))
        {
            if (mii.wID == id)
            {
                // Found it!
                if (pi)
                    *pi = c;
                return hmenuSub;
            }
        }
    }

    return NULL;
}


STDAPI_(BOOL)
FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id)
{
    int i;
    PFILEMENUITEM pfmi;
    PFILEMENUHEADER pfmh;
    HMENU hmenuSub;

    if (!IsMenu(hmenu))
        return FALSE;

    if (!id)
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        hmenuSub = _FindMenuItemByFirstID(hmenu, id, &i);
        if (hmenuSub && i)
        {
            // Delete the submenu.
            FileMenu_DeleteAllItems(hmenuSub);
            // Delete the item itself.
            pfmi = FileMenu_GetItemData(hmenu, i, TRUE);
            DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_DeleteSeparator(HMENU hmenu)
{
    int i;
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = _FindItemByCmd(pfmh, 0, &i);
        if (pfmi)
        {
            // Yep.
            DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
            if (pfmi->pidl)
                ILFree(pfmi->pidl);
            LocalFree((HLOCAL)pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_InsertSeparator(HMENU hmenu, UINT iPos)
{
    return FileMenu_InsertItem(hmenu, (LPTSTR)FMAI_SEPARATOR, 0, -1, NULL, 0, iPos);
}


STDAPI_(BOOL)
FileMenu_IsFileMenu(HMENU hmenu)
{
    return FileMenu_GetHeader(hmenu) ? TRUE : FALSE;
}


STDAPI_(BOOL)
FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    if (!id)
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = _FindItemByCmd(pfmh, id, NULL);
        if (pfmi)
        {
            if (fEnable)
            {
                pfmi->Flags &= ~FMI_DISABLED;
                EnableMenuItem(pfmh->hmenu, id, MF_BYCOMMAND | MF_ENABLED);
            }
            else
            {
                pfmi->Flags |= FMI_DISABLED;
                EnableMenuItem(pfmh->hmenu, id, MF_BYCOMMAND | MF_GRAYED);
            }
            return TRUE;
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "Menu is not a filemenu.");
    }

    return FALSE;
}


STDAPI_(BOOL)
FileMenu_GetPidl(HMENU hmenu, UINT iPos, LPITEMIDLIST *ppidl)
{
    BOOL fRet = FALSE;
    PFILEMENUHEADER pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iPos);
        if (pfmi)
        {
            if (pfmh->pidlFolder && pfmi->pidl && 
                IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
            {
                *ppidl = ILCombine(pfmh->pidlFolder, pfmi->pidl);
                fRet = TRUE;
            }
        }
    }

    return fRet;
}


BOOL Tooltip_Create(HWND *phwndTip)
{
    BOOL fRet = FALSE;

    *phwndTip = CreateWindow(TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, HINST_THISDLL, NULL);
    if (*phwndTip)
    {
        TOOLINFO ti;

        ti.cbSize = SIZEOF(ti);
        ti.uFlags = TTF_TRACK;
        ti.hwnd = NULL;
        ti.uId = 0;
        ti.lpszText = NULL;
        ti.hinst = HINST_THISDLL;
        SetRectEmpty(&ti.rect);
        SendMessage(*phwndTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        fRet = TRUE;
    }

    return fRet;
}


void Tooltip_SetText(HWND hwndTip, LPCTSTR pszText)
{
    if (hwndTip)
    {
        TOOLINFO ti;
        ti.cbSize = SIZEOF(ti);
        ti.uFlags = 0;
        ti.hwnd = NULL;
        ti.uId = 0;
        ti.lpszText = (LPTSTR)pszText;
        ti.hinst = HINST_THISDLL;
        SendMessage(hwndTip, TTM_UPDATETIPTEXT, 0, (LPARAM)(LPTOOLINFO)&ti);
    }
}


void Tooltip_Hide(HWND hwndTip)
{
    if (hwndTip)
    {
        TOOLINFO ti;
        ti.cbSize = SIZEOF(ti);
        ti.hwnd = NULL;
        ti.uId = 0;
        SendMessage(hwndTip, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);
    }
}


void Tooltip_Show(HWND hwndTip)
{
    if (hwndTip)
    {
        TOOLINFO ti;
        ti.cbSize = SIZEOF(ti);
        ti.hwnd = NULL;
        ti.uId = 0;
        SendMessage(hwndTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);
        SetWindowPos(hwndTip, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
    }
}


void Tooltip_SetPos(HWND hwndTip, int x, int y)
{
    ASSERT(IsWindow(hwndTip));

    SendMessage(hwndTip, TTM_TRACKPOSITION, 0, MAKELPARAM(x, y));
}


/*----------------------------------------------------------
Purpose: Ask the callback for a tooltip.

Returns:
Cond:    --
*/
void
FileMenuItem_GetTooltip(
    IN PFILEMENUITEM pfmi)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    PFILEMENUHEADER pfmh = pfmi->pfmh;

    if (pfmh->pfncb)
    {
        FMCBDATA fmcbdata;
        FMTOOLTIP fmtt = {0};

        if (pfmi->pszTooltip)
        {
            // Free the previous tooltip
            LocalFree(pfmi->pszTooltip);
            pfmi->pszTooltip = NULL;
        }

        fmcbdata.hmenu = pfmh->hmenu;
        fmcbdata.iPos = -1;
        fmcbdata.idCmd = (UINT)-1;

        // BUGBUG (scotth): we don't ask for tooltips for alternate lists
        fmcbdata.pidlFolder = pfmh->pidlFolder;
        fmcbdata.pidl = pfmi->pidl;
        fmcbdata.psf = pfmh->psf;

        // Was a tooltip set?
        if (S_OK == pfmh->pfncb(FMM_GETTOOLTIP, &fmcbdata, (LPARAM)&fmtt))
        {
            Sz_AllocCopyW(fmtt.pszTip, &(pfmi->pszTooltip));
            SHFree(fmtt.pszTip);

            if (pfmi->pszTooltip)
            {
                // Set the other settings
                if (IsFlagSet(fmtt.dwMask, FMTT_MARGIN))
                {
                    pfmi->rcMargin = fmtt.rcMargin;
                    SetFlag(pfmi->Flags, FMI_MARGIN);
                }

                if (IsFlagSet(fmtt.dwMask, FMTT_MAXWIDTH))
                {
                    pfmi->dwMaxTipWidth = fmtt.dwMaxWidth;
                    SetFlag(pfmi->Flags, FMI_MAXTIPWIDTH);
                }

                if (IsFlagSet(fmtt.dwMask, FMTT_DRAWFLAGS))
                {
                    pfmi->uDrawFlags = fmtt.uDrawFlags;
                    SetFlag(pfmi->Flags, FMI_DRAWFLAGS);
                }

                if (IsFlagSet(fmtt.dwMask, FMTT_TABSTOP))
                {
                    pfmi->dwTabstop = fmtt.dwTabstop;
                    SetFlag(pfmi->Flags, FMI_TABSTOP);
                }
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Called on WM_MENUSELECT

*/
STDAPI_(BOOL)
FileMenu_HandleMenuSelect(
    IN HMENU  hmenu,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
    UINT id = LOWORD(wparam);
    BOOL fTip = FALSE;
    BOOL fRet = FALSE;
    PFILEMENUITEM pfmi = g_pfmiLastSelNonFolder;

    if (hmenu && pfmi)
    {
        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

        PFILEMENUHEADER pfmh = pfmi->pfmh;

        if (pfmh && IsFlagSet(pfmh->fmf, FMF_TOOLTIPS) &&
            FileMenuHeader_CreateTooltipWindow(pfmh))
        {
            // Have we asked for the tooltip?
            if (IsFlagClear(pfmi->Flags, FMI_ASKEDFORTOOLTIP))
            {
                // No; do it now
                FileMenuItem_GetTooltip(pfmi);

                SetFlag(pfmi->Flags, FMI_ASKEDFORTOOLTIP);
            }

            // Does this have a tooltip?
            if (pfmi->pszTooltip && FileMenu_GetHeader(hmenu) == pfmh)
            {
                // Yes
                Tooltip_Hide(g_hwndTip);
                Tooltip_SetPos(g_hwndTip, g_rcItem.left + X_TIPOFFSET, g_rcItem.bottom);
                Tooltip_SetText(g_hwndTip, pfmi->pszTooltip);

                if (IsFlagSet(pfmi->Flags, FMI_MAXTIPWIDTH))
                    SendMessage(g_hwndTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)pfmi->dwMaxTipWidth);

                if (IsFlagSet(pfmi->Flags, FMI_MARGIN))
                    SendMessage(g_hwndTip, TTM_SETMARGIN, 0, (LPARAM)&pfmi->rcMargin);

                Tooltip_Show(g_hwndTip);
                fTip = TRUE;
            }
        }
        fRet = TRUE;
    }

    if (!fTip && IsWindow(g_hwndTip))
        Tooltip_Hide(g_hwndTip);

    return fRet;
}


STDAPI_(void)
FileMenu_EditMode(BOOL bEdit)
{
    g_fsmenuagent.SetEditMode(bEdit, DROPEFFECT_MOVE);
}    


/*----------------------------------------------------------
Purpose: 

*/
STDAPI_(BOOL)
FileMenu_ProcessCommand(
    IN HWND   hwnd,
    IN HMENU  hmenuBar,
    IN UINT   idMenu,
    IN HMENU  hmenu,
    IN UINT   idCmd)
{
    return g_fsmenuagent.ProcessCommand(hwnd, hmenuBar, idMenu, hmenu, idCmd);
}


void FileMenuHeader_HandleUpdateImage(PFILEMENUHEADER pfmh, int iImage)
{
    int i;
    PFILEMENUITEM pfmi;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(-1 != iImage);

    // Look for any image indexes that are being changed
    
    for (i = GetMenuItemCount(pfmh->hmenu) - 1; i >= 0; i--)
    {
        pfmi = FileMenu_GetItemData(pfmh->hmenu, i, TRUE);
        if (pfmi)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

            if (pfmi->iImage == iImage)
            {
                // Invalidate this image.  It will be recalculated when
                // the menu item is redrawn.
                pfmi->iImage = -1;
            }

            HMENU hmenuSub = GetSubMenu(pfmh->hmenu, i);
            if (hmenuSub)
            {
                PFILEMENUHEADER pfmhT = FileMenu_GetHeader(hmenuSub);
                if (pfmhT)
                    FileMenuHeader_HandleUpdateImage(pfmhT, iImage);
            }    
        }
    }
}    


BOOL FileMenuHeader_HandleNotify(PFILEMENUHEADER pfmh, LPCITEMIDLIST * ppidl, LONG lEvent)
{
    BOOL bRet;
    int iImage;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    
    switch (lEvent)
    {
    case SHCNE_UPDATEIMAGE:
        if (EVAL(ppidl && ppidl[0]))
        {
            iImage = *(int UNALIGNED *)((BYTE *)ppidl[0] + 2);

            if (-1 != iImage)
                FileMenuHeader_HandleUpdateImage(pfmh, iImage);
        }
        bRet = TRUE;
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}    


STDAPI_(BOOL)
FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent)
{
    BOOL bRet = FALSE;
    PFILEMENUHEADER pfmh = FileMenu_GetHeader(hmenu);

    if (hmenu && pfmh)
    {
        bRet = FileMenuHeader_HandleNotify(pfmh, ppidl, lEvent);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\qistub.h ===
#ifndef _QISTUB_H_
#define _QISTUB_H_

#ifdef DEBUG
STDAPI_(BOOL) DBIsQIStub(void *);
STDAPI_(void) DBDumpQIStub(void *);
STDAPI_(BOOL) DBIsQIFunc(int ret, int delta);
#endif

#endif // _QISTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\qistub.cpp ===
//***   qistub.cpp -- QI helpers (retail and debug)
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/qistub.cpp"

#include "qistub.h"

#define DM_MISC2            0       // misc stuff (verbose)

// hack-o-rama: shlwapi/qistub.cpp does #undef DEBUG but its PCH was
// built DEBUG, so lots of bad stuff happens.  work-around it here.
#undef DBEXEC
#ifdef DEBUG
#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)
#else
#define DBEXEC(flg, expr)    /*NOTHING*/
#endif

#ifdef DEBUG // {
//***   CUniqueTab {
// DESCRIPTION
//  key/data table insert and lookup, w/ interlock.
class CUniqueTab
{
public:
    void * Add(int val);
    void * Find(int val, int delta);
    void Reset(void);

    // n.b. *not* protected
    CUniqueTab(int cbElt);
    virtual ~CUniqueTab();

protected:

private:
    void _Lock(void) { EnterCriticalSection(&_hLock); }
    void _Unlock(void) { LeaveCriticalSection(&_hLock); }

    CRITICAL_SECTION    _hLock;
// key + (arbitrary) limit of 4 int's of client data
#define CUT_CBELTMAX    (SIZEOF(int) + 4 * SIZEOF(int))
    int     _cbElt;                 // size of an entry (key + data)
// (arbitrary) limit to catch clients running amuck
#define CUT_CVALMAX 256         // actually, a LIM not a MAX
    HDSA    _hValTab;
};

CUniqueTab::CUniqueTab(int cbElt)
{
    InitializeCriticalSection(&_hLock);
    ASSERT(cbElt >= SIZEOF(DWORD));     // need at least a key; data optional
    _cbElt = cbElt;
    _hValTab = DSA_Create(_cbElt, 4);
    return;
}

CUniqueTab::~CUniqueTab()
{
    DSA_Destroy(_hValTab);
    DeleteCriticalSection(&_hLock);
    return;
}

struct cutent {
    int iKey;
    char bData[CUT_CBELTMAX - SIZEOF(int)];
};
struct cfinddata {
    int iKey;
    int dRange;
    void *pEntry;
};

int _UTFindCallback(void *pEnt, void *pData)
{
#define INFUNC(base, p, range) ((base) <= (p) && (p) <= (base) + (range))
    struct cfinddata *pcd = (struct cfinddata *)pData;
    if (INFUNC(*(int *)pEnt, pcd->iKey, pcd->dRange)) {
        pcd->pEntry = pEnt;
        return 0;
    }
    return 1;
#undef  INFUNC
}

//***   CUniqueTab::Add -- add entry if not already there
//
void * CUniqueTab::Add(int val)
{
    struct cfinddata cd = { val, 0, NULL };

    _Lock();

    DSA_EnumCallback(_hValTab, _UTFindCallback, &cd);
    if (!cd.pEntry) {
        int i;
        // lazy,lazy,lazy: alloc max size and let DSA_AppendItem sort it out
        struct cutent elt = { val, 0 /*,0,...,0*/ };

        TraceMsg(DM_MISC2, "cut.add: add %x", val);
        if (DSA_GetItemCount(_hValTab) <= CUT_CVALMAX) {
            i = DSA_AppendItem(_hValTab, &elt);
            cd.pEntry = DSA_GetItemPtr(_hValTab, i);
        }
    }

    _Unlock();

    return cd.pEntry;
}

//***   CUniqueTab::Find -- find entry
//
void * CUniqueTab::Find(int val, int delta)
{
    struct cfinddata cd = { val, delta, NULL };

    DSA_EnumCallback(_hValTab, _UTFindCallback, &cd);
    if (cd.pEntry) {
        // TODO: add p->data[0] dump
        TraceMsg(DM_MISC2, "cut.find: found %x+%d", val, delta);
    }
    return cd.pEntry;
}

//***   _UTResetCallback -- helper for CUniqueTab::Reset
int _UTResetCallback(void *pEnt, void *pData)
{
    struct cutent *pce = (struct cutent *)pEnt;
    int cbEnt = *(int *)pData;
    // perf: could move the SIZEOF(int) into caller, but seems safer here
    memset(pce->bData, 0, cbEnt - SIZEOF(int));
    return 1;
}

//***   Reset -- clear 'data' part of all entries
//
void CUniqueTab::Reset(void)
{
    if (EVAL(_cbElt > SIZEOF(int))) {
        _Lock();
        DSA_EnumCallback(_hValTab, _UTResetCallback, &_cbElt);
        _Unlock();
    }
    return;
}
// }
#endif // }

//***   QueryInterface helpers {

//***   FAST_IsEqualIID -- fast compare
// (cast to 'LONG_PTR' so don't get overloaded ==)
#define FAST_IsEqualIID(piid1, piid2)   ((LONG_PTR)(piid1) == (LONG_PTR)(piid2))

#ifdef DEBUG // {
//***   DBNoOp -- do nothing (but suppress compiler optimizations)
// NOTES
//  this won't fool compiler when it gets smarter, oh well...
void DBNoOp()
{
    return;
}

void DBBrkpt()
{
    DBNoOp();
    return;
}

//***   DBBreakGUID -- debug hook (gets readable name, allows brkpt on IID)
// DESCRIPTION
//  search for 'BRKPT' for various hooks.
//  patch 'DBQIiid' to brkpt on a specific iface
//  patch 'DBQIiSeq' to brkpt on Nth QI of specific iface
//  brkpt on interesting events noted below
// NOTES
//  warning: returns ptr to *static* buffer!

typedef enum {
    DBBRK_NIL   = 0,
    DBBRK_ENTER = 0x01,
    DBBRK_TRACE = 0x02,
    DBBRK_S_XXX = 0x04,
    DBBRK_E_XXX = 0x08,
    DBBRK_BRKPT = 0x10,
} DBBRK;

DBBRK DBQIuTrace = DBBRK_NIL;   // BRKPT patch to enable brkpt'ing
GUID *DBQIiid = NULL;           // BRKPT patch to brkpt on iface
int DBQIiSeq = -1;              // BRKPT patch to brkpt on Nth QI of DBQIiid
long DBQIfReset = FALSE;        // BRKPT patch to reset counters

TCHAR *DBBreakGUID(const GUID *piid, DBBRK brkCmd)
{
    static TCHAR szClass[GUIDSTR_MAX];

    SHStringFromGUID(*piid, szClass, ARRAYSIZE(szClass));

    // BUGBUG fold these 2 if's together
    if ((DBQIuTrace & brkCmd) &&
      (DBQIiid == NULL || IsEqualIID(*piid, *DBQIiid))) {
        TraceMsg(DM_TRACE, "util: DBBreakGUID brkCmd=%x clsid=%s (%s)", brkCmd, szClass, Dbg_GetREFIIDName(*piid));
        // BRKPT put brkpt here to brkpt on 'brkCmd' event
        DBBrkpt();
    }

    if (DBQIiid != NULL && IsEqualIID(*piid, *DBQIiid)) {
        //TraceMsg(DM_TRACE, "util: DBBreakGUID clsid=%s (%s)", szClass, Dbg_GetREFIIDName(*piid));
        if (brkCmd != DBBRK_TRACE) {
            // BRKPT put brkpt here to brkpt on 'DBQIiid' iface
            DBNoOp();
        }
    }

    // BRKPT put your brkpt(s) here for various events
    switch (brkCmd) {
    case DBBRK_ENTER:
        // QI called w/ this iface
        DBNoOp();
        break;
    case DBBRK_TRACE:
        // looped over this iface
        DBNoOp();
        break;
    case DBBRK_S_XXX:
        // successful QI for this iface
        DBNoOp();
        break;
    case DBBRK_E_XXX:
        // failed QI for this iface
        DBNoOp();
        break;
    case DBBRK_BRKPT:
        // various brkpt events, see backtrace to figure out which one
        DBNoOp();
        break;
    }

    return szClass;
}
#endif // }

#ifdef DEBUG
CUniqueTab *DBpQIFuncTab;

STDAPI_(BOOL) DBIsQIFunc(int ret, int delta)
{
    BOOL fRet = FALSE;

    if (DBpQIFuncTab)
        fRet = BOOLFROMPTR(DBpQIFuncTab->Find(ret, delta));

    return fRet;
}
#endif

//  perf: shell split means FAST_IsEqIID often fails, so QI_EASY is off.
#define QI_EASY     0       // w/ shell split, seems to be too rare

#ifdef DEBUG // {
int DBcQITot, DBcQIUnk, DBcQIErr, DBcQIEasy, DBcQIHard;

LPCQITAB DBpqitStats;           // BRKPT: patch to enable QITABENT profiling
#define DBSTAT_CNT      20
int DBcStats[DBSTAT_CNT + 3];   // 0..n, overflow, IUnknown, E_FAIL

#define DBSI_FAIL       (-1)
#define DBSI_IUNKNOWN   (-2)
#define DBSI_OVERFLOW   (-3)

#define DBSI_SPEC(i)    (DBSTAT_CNT - 1 + (-(i)))

//***
// DESCRIPTION
//  search for 'BRKPT' for various hooks.
//  patch 'DBpqitStats' to gather stats on that QITAB
//  then break into debugger (ctrl+C) and dumpa 'DBcStats l 24'
//  then sort high count guys to the front, and 0 count guys to the end
//
void DBQIStats(LPCQITAB pqitab, INT_PTR i)
{
    if (pqitab != DBpqitStats)
        return;

    if (i >= DBSTAT_CNT)
        i = DBSI_OVERFLOW;
    if (i < 0)
        i = DBSTAT_CNT - 1 + (-i);
    DBcStats[i]++;
    return;
}

void DBDumpQIStats()
{
    int i;
    TCHAR *p;
    TCHAR buf[256];

    TraceMsg(TF_QISTUB, "qi stats: tot=%d unk=%d err=%d easy(%d)=%d hard=%d",
        DBcQITot, DBcQIUnk, DBcQIErr, QI_EASY, DBcQIEasy, DBcQIHard);

    if (DBpqitStats == NULL)
        return;
    
    p = buf;
    for (i = 0; i < DBSTAT_CNT; i++) {
        p += wsprintf(p, TEXT(" %d"), DBcStats[i]);
    }
    p += wsprintf(p, TEXT(" o=%d u=%d e=%d"),
        DBcStats[DBSI_SPEC(DBSI_OVERFLOW)],
        DBcStats[DBSI_SPEC(DBSI_IUNKNOWN)],
        DBcStats[DBSI_SPEC(DBSI_FAIL)]);

    TraceMsg(TF_QISTUB, "qi stats: %s", buf);
    return;
}

#endif // }


//***   QISearch -- table-driven QI
// ENTRY/EXIT
//  this        IUnknown* of calling QI
//  pqit        QI table of IID,cast_offset pairs
//  ppv         the usual
//  hr          the usual S_OK/E_NOINTERFACE, plus other E_* for errors
// NOTES
//  perf: shell split means FAST_IsEqIID often fails, so QI_EASY is off.
//  perf: IUnknown v. rare, so goes last.
//  BUGBUG perf: explicit 'E_NOIFACE' entry in qitab for common miss(es)?
STDAPI_(void*) QIStub_CreateInstance(void* that, IUnknown* punk, REFIID riid);	// qistub.cpp

STDAPI QISearch(void* that, LPCQITAB pqitab, REFIID riid, LPVOID* ppv)
{
    // do *not* move this!!! (must be 1st on frame)
#ifdef DEBUG
#if (_X86_)
    int var0;       // *must* be 1st on frame
#endif
#endif

    LPCQITAB pqit;
#ifdef DEBUG
    TCHAR *pst;

    DBEXEC(TRUE, DBcQITot++);
#if ( _X86_) // QIStub only works for X86
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGQI)) {
        if (DBpQIFuncTab == NULL)
            DBpQIFuncTab = new CUniqueTab(SIZEOF(DWORD));   // LONG_PTR?
        if (DBpQIFuncTab) {
            int n;
            int fp = (int) (1 + (int *)&var0);
            struct DBstkback sbtab[1] = { 0 };
            n = DBGetStackBack(&fp, sbtab, ARRAYSIZE(sbtab));
            DBpQIFuncTab->Add(sbtab[n - 1].ret);
        }
    }
#endif

    if (DBQIuTrace)
        pst = DBBreakGUID(&riid, DBBRK_ENTER);
#endif

    if (ppv == NULL)
        return E_POINTER;

#if QI_EASY
    // 1st try the fast way
    for (pqit = pqitab; pqit->piid != NULL; pqit++) {
        DBEXEC(DBQIuTrace, (pst = DBBreakGUID(pqit->piid, DBBRK_TRACE)));
        if (FAST_IsEqualIID(&riid, pqit->piid)) {
            DBEXEC(TRUE, DBcQIEasy++);
            goto Lhit;
        }
    }
#endif

    // no luck, try the hard way
    for (pqit = pqitab; pqit->piid != NULL; pqit++) {
        DBEXEC(DBQIuTrace, (pst = DBBreakGUID(pqit->piid, DBBRK_TRACE)));
        if (IsEqualIID(riid, *(pqit->piid))) {
            DBEXEC(TRUE, DBcQIHard++);
#if QI_EASY
    Lhit:
#else
        // keep 'easy' stats anyway
        DBEXEC(FAST_IsEqualIID(&riid, pqit->piid), DBcQIEasy++);
#endif
#ifdef DEBUG
            DBEXEC(TRUE, DBQIStats(pqitab, pqit - pqitab));
#if ( _X86_) // QIStub only works for X86
            if (IsFlagSet(g_dwDumpFlags, DF_DEBUGQI)) {
                IUnknown* punk = (IUnknown*)((LONG_PTR)that + pqit->dwOffset);
                *ppv = QIStub_CreateInstance(that, punk, riid);
                if (*ppv) {
                    pst = DBBreakGUID(&riid, DBBRK_S_XXX);
                    return S_OK;
                }
            }
#endif
#endif
        Lcast:
            IUnknown* punk = (IUnknown*)((LONG_PTR)that + pqit->dwOffset);
            DBEXEC(TRUE, (pst = DBBreakGUID(&riid, DBBRK_S_XXX)));
            punk->AddRef();
            *ppv = punk;
            return S_OK;
        }
    }

    // no luck, try IUnknown (which is implicit in the table)
    // we try IUnknown last not 1st since stats show it's rare
    if (IsEqualIID(riid, IID_IUnknown)) {
        // just use 1st table entry
        pqit = pqitab;
        DBEXEC(TRUE, DBcQIUnk++);
        DBEXEC(TRUE, DBQIStats(pqitab, DBSI_IUNKNOWN));

        goto Lcast;
    }

    DBEXEC(DBQIuTrace, (pst = DBBreakGUID(&riid, DBBRK_E_XXX)));
    DBEXEC(TRUE, DBcQIErr++);
    DBEXEC(TRUE, DBQIStats(pqitab, DBSI_FAIL));
    *ppv = NULL;
    return E_NOINTERFACE;
}

// }

#ifdef DEBUG // {
#if ( _X86_) // { QIStub only works for X86

//***   QIStub helpers {

class CQIStub
{
public:
    virtual void thunk0();
    // BUGBUG should AddRef/Release up _iSeq?
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { _cRef++; return _cRef; }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { _cRef--; if (_cRef>0) return _cRef; delete this; return 0; }
    virtual void thunk3();
    virtual void thunk4();
    virtual void thunk5();
    virtual void thunk6();
    virtual void thunk7();
    virtual void thunk8();
    virtual void thunk9();
    virtual void thunk10();
    virtual void thunk11();
    virtual void thunk12();
    virtual void thunk13();
    virtual void thunk14();
    virtual void thunk15();
    virtual void thunk16();
    virtual void thunk17();
    virtual void thunk18();
    virtual void thunk19();
    virtual void thunk20();
    virtual void thunk21();
    virtual void thunk22();
    virtual void thunk23();
    virtual void thunk24();
    virtual void thunk25();
    virtual void thunk26();
    virtual void thunk27();
    virtual void thunk28();
    virtual void thunk29();
    virtual void thunk30();
    virtual void thunk31();
    virtual void thunk32();
    virtual void thunk33();
    virtual void thunk34();
    virtual void thunk35();
    virtual void thunk36();
    virtual void thunk37();
    virtual void thunk38();
    virtual void thunk39();
    virtual void thunk40();
    virtual void thunk41();
    virtual void thunk42();
    virtual void thunk43();
    virtual void thunk44();
    virtual void thunk45();
    virtual void thunk46();
    virtual void thunk47();
    virtual void thunk48();
    virtual void thunk49();
    virtual void thunk50();
    virtual void thunk51();
    virtual void thunk52();
    virtual void thunk53();
    virtual void thunk54();
    virtual void thunk55();
    virtual void thunk56();
    virtual void thunk57();
    virtual void thunk58();
    virtual void thunk59();
    virtual void thunk60();
    virtual void thunk61();
    virtual void thunk62();
    virtual void thunk63();
    virtual void thunk64();
    virtual void thunk65();
    virtual void thunk66();
    virtual void thunk67();
    virtual void thunk68();
    virtual void thunk69();
    virtual void thunk70();
    virtual void thunk71();
    virtual void thunk72();
    virtual void thunk73();
    virtual void thunk74();
    virtual void thunk75();
    virtual void thunk76();
    virtual void thunk77();
    virtual void thunk78();
    virtual void thunk79();
    virtual void thunk80();
    virtual void thunk81();
    virtual void thunk82();
    virtual void thunk83();
    virtual void thunk84();
    virtual void thunk85();
    virtual void thunk86();
    virtual void thunk87();
    virtual void thunk88();
    virtual void thunk89();
    virtual void thunk90();
    virtual void thunk91();
    virtual void thunk92();
    virtual void thunk93();
    virtual void thunk94();
    virtual void thunk95();
    virtual void thunk96();
    virtual void thunk97();
    virtual void thunk98();
    virtual void thunk99();

protected:
    CQIStub(void *that, IUnknown* punk, REFIID riid);
    friend void* QIStub_CreateInstance(void *that, IUnknown* punk, REFIID riid);
    friend BOOL __stdcall DBIsQIStub(void *that);
    friend void __stdcall DBDumpQIStub(void *that);
    friend TCHAR *DBGetQIStubSymbolic(void *that);

private:
    ~CQIStub();

    static void *_sar;              // C (not C++) ptr to CQIStub::AddRef

    int       _cRef;
    IUnknown* _punk;                // vtable we hand off to
    void*     _that;                // "this" pointer of object we stub (for reference)
    IUnknown* _punkRef;             // "punk" (for reference)
    REFIID    _riid;                // iid of interface (for reference)
    int       _iSeq;                // sequence #
    TCHAR     _szName[GUIDSTR_MAX]; // legible name of interface (for reference)
};

struct DBQISeq
{
    GUID *  pIid;
    int     iSeq;
};
//CASSERT(SIZEOF(GUID *) == SIZEOF(DWORD));   // CUniqueTab uses DWORD's

// BUGBUG todo: _declspec(thread)
CUniqueTab * DBpQISeqTab = NULL;

extern "C" void *Dbg_GetREFIIDAtom(REFIID riid);    // lib/dump.c (priv.h?)

//***
// NOTES
//  there's actually a race condition here -- another thread can come in
// and do seq++, then we do the reset, etc. -- but the assumption is that
// the developer has set the flag in a scenario where this isn't an issue.
void DBQIReset(void)
{
    ASSERT(!DBQIfReset);    // caller should do test-and-clear
    if (DBpQISeqTab)
        DBpQISeqTab->Reset();

    return;
}

void *DBGetVtblEnt(void *that, int i);
#define VFUNC_ADDREF  1     // AddRef is vtbl[1]

void * CQIStub::_sar = NULL;

CQIStub::CQIStub(void* that, IUnknown* punk, REFIID riid) : _cRef(1), _riid(riid)
{
    _that = that;

    _punk = punk;
    if (_punk)
        _punk->AddRef();

    _punkRef = _punk; // for reference, so don't AddRef it!

    // c++ won't let me get &CQIStub::AddRef as a 'real' ptr (!@#$),
    // so we need to get it the hard way, viz. new'ing an object which
    // we know inherits it.
    if (_sar == NULL) {
        _sar = DBGetVtblEnt((void *)this, VFUNC_ADDREF);
        ASSERT(_sar != NULL);
    }

    lstrcpyn(_szName, Dbg_GetREFIIDName(riid), ARRAYSIZE(_szName));

    // generate sequence #
    if (DBpQISeqTab == NULL)
        DBpQISeqTab = new CUniqueTab(SIZEOF(struct DBQISeq));
    if (DBpQISeqTab) {
        struct DBQISeq *pqiseq;

        if (InterlockedExchange(&DBQIfReset, FALSE))
            DBQIReset();

        pqiseq = (struct DBQISeq *) DBpQISeqTab->Add((DWORD) Dbg_GetREFIIDAtom(riid));
        if (EVAL(pqiseq))       // (might fail on table overflow)
            _iSeq = pqiseq->iSeq++;
    }

    TraceMsg(TF_QISTUB, "ctor QIStub %s seq=%d (that=%x punk=%x) %x", _szName, _iSeq, _that, _punk, this);
}

CQIStub::~CQIStub()
{
    TraceMsg(TF_QISTUB, "dtor QIStub %s (that=%x punk=%x) %x", _szName, _that, _punk, this);

    ATOMICRELEASE(_punk);
}

STDAPI_(void*) QIStub_CreateInstance(void* that, IUnknown* punk, REFIID riid)
{
    CQIStub* pThis = new CQIStub(that, punk, riid);

    if (DBQIiSeq == pThis->_iSeq && IsEqualIID(riid, *DBQIiid)) {
        TCHAR *pst;
        // BRKPT put brkpt here to brkpt on seq#'th call to 'DBQIiid' iface
        pst = DBBreakGUID(&riid, DBBRK_BRKPT);
    }

    return(pThis);
}

//***   DBGetVtblEnt -- get vtable entry
// NOTES
//  always uses 1st vtbl (so MI won't work...).
void *DBGetVtblEnt(void *that, int i)
{
    void **vptr;
    void *pfunc;

    __try {
        vptr = (void **) *(void **) that;
        pfunc = (vptr == 0) ? 0 : vptr[i];
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        // since we're called from the DebMemLeak, we're only *guessing*
        // that we have a vptr etc., so we might fault.
        TraceMsg(TF_ALWAYS, "gve: GPF");
        pfunc = 0;
    }

    return pfunc;
}

//***   DBIsQIStub -- is 'this' a ptr to a 'CQIStub' object?
// DESCRIPTION
//  we look at the vtbl and assume that if we have a ptr to CQIStub::AddRef,
// then it's us.
// NOTES
//  M00BUG we do a 'new' in here, which can cause pblms if we're in the middle
// of intelli-leak and we end up doing a ReAlloc which moves the heap (raymondc
// found such a case).
//  M00BUG in a release build (w/ identical COMDAT folding) we'll get false
// hits since most/all AddRefs are identical and folded.  if we ever need to
// be more exact we can add a signature and key off that.
//  M00BUG hack hack we actually return a void *, just in case you want to
// know the 'real' object.  if that turns out to be useful, we should change
// to return a void * instead of a BOOL.

BOOL DBIsQIStub(void* that)
{
    void *par;

#if 0
    if (_sar == NULL)
        TraceMsg(DM_TRACE, "qis: _sar == NULL");
#endif

    par = DBGetVtblEnt(that, VFUNC_ADDREF);

#if 0
    TraceMsg(TF_ALWAYS, "IsQIStub(%x): par=%x _sar=%x", that, _sar, par);
#endif

    return (CQIStub::_sar == par && CQIStub::_sar != NULL) ? (BOOL)((CQIStub *)that)->_punk : 0;
#undef  VFUNC_ADDREF
}

TCHAR *DBGetQIStubSymbolic(void* that)
{
    class CQIStub *pqis = (CQIStub *) that;
    return pqis->_szName;
}

//***   DBDumpQIStub -- pretty-print a 'CQIStub'
//
STDAPI_(void) DBDumpQIStub(void* that)
{
    class CQIStub *pqis = (CQIStub *) that;
    TraceMsg(TF_ALWAYS, "\tqistub(%x): cRef=0x%x iSeq=%x iid=%s", that, pqis->_cRef, pqis->_iSeq, pqis->_szName);
}

// Memory layout of CQIStub is:
//    lpVtbl  // offset 0
//    _cRef   // offset 4
//    _punk   // offset 8
//
// "this" pointer stored in stack
//
// mov eax, ss:4[esp]          ; get pThis
// mov ecx, 8[eax]             ; get real object (_punk)
// mov eax, [ecx]              ; load the real vtable (_punk->lpVtbl)
//                             ; the above will fault if referenced after we're freed
// mov ss:4[esp], ecx          ; fix up stack object (_punk)
// jmp dword ptr cs:(4*i)[eax] ; jump to the real function
//
#define QIStubThunk(i) \
void _declspec(naked) CQIStub::thunk##i() \
{ \
    _asm mov eax, ss:4[esp]          \
    _asm mov ecx, 8[eax]             \
    _asm mov eax, [ecx]              \
    _asm mov ss:4[esp], ecx          \
    _asm jmp dword ptr cs:(4*i)[eax] \
}

QIStubThunk(0);
QIStubThunk(3);
QIStubThunk(4);
QIStubThunk(5);
QIStubThunk(6);
QIStubThunk(7);
QIStubThunk(8);
QIStubThunk(9);
QIStubThunk(10);
QIStubThunk(11);
QIStubThunk(12);
QIStubThunk(13);
QIStubThunk(14);
QIStubThunk(15);
QIStubThunk(16);
QIStubThunk(17);
QIStubThunk(18);
QIStubThunk(19);
QIStubThunk(20);
QIStubThunk(21);
QIStubThunk(22);
QIStubThunk(23);
QIStubThunk(24);
QIStubThunk(25);
QIStubThunk(26);
QIStubThunk(27);
QIStubThunk(28);
QIStubThunk(29);
QIStubThunk(30);
QIStubThunk(31);
QIStubThunk(32);
QIStubThunk(33);
QIStubThunk(34);
QIStubThunk(35);
QIStubThunk(36);
QIStubThunk(37);
QIStubThunk(38);
QIStubThunk(39);
QIStubThunk(40);
QIStubThunk(41);
QIStubThunk(42);
QIStubThunk(43);
QIStubThunk(44);
QIStubThunk(45);
QIStubThunk(46);
QIStubThunk(47);
QIStubThunk(48);
QIStubThunk(49);
QIStubThunk(50);
QIStubThunk(51);
QIStubThunk(52);
QIStubThunk(53);
QIStubThunk(54);
QIStubThunk(55);
QIStubThunk(56);
QIStubThunk(57);
QIStubThunk(58);
QIStubThunk(59);
QIStubThunk(60);
QIStubThunk(61);
QIStubThunk(62);
QIStubThunk(63);
QIStubThunk(64);
QIStubThunk(65);
QIStubThunk(66);
QIStubThunk(67);
QIStubThunk(68);
QIStubThunk(69);
QIStubThunk(70);
QIStubThunk(71);
QIStubThunk(72);
QIStubThunk(73);
QIStubThunk(74);
QIStubThunk(75);
QIStubThunk(76);
QIStubThunk(77);
QIStubThunk(78);
QIStubThunk(79);
QIStubThunk(80);
QIStubThunk(81);
QIStubThunk(82);
QIStubThunk(83);
QIStubThunk(84);
QIStubThunk(85);
QIStubThunk(86);
QIStubThunk(87);
QIStubThunk(88);
QIStubThunk(89);
QIStubThunk(90);
QIStubThunk(91);
QIStubThunk(92);
QIStubThunk(93);
QIStubThunk(94);
QIStubThunk(95);
QIStubThunk(96);
QIStubThunk(97);
QIStubThunk(98);
QIStubThunk(99);

// }

#endif // }
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\nativew.cpp ===
#ifndef UNICODE 
#define UNICODE 
#endif 
//
//  native.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//

#include "proj.h"
#include <vdate.h>

// get the name and flags of an absolute IDlist
// in:
//      dwFlags     SHGDN_ flags as hints to the name space GetDisplayNameOf() function
//
// in/out:
//      *pdwAttribs (optional) return flags

STDAPI SHGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs)
{
    if (pszName)
    {
        VDATEINPUTBUF(pszName, TCHAR, cchName);
        *pszName = 0;
    }

    HRESULT hrInit = SHCoInitialize();

    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hres = SHBindToIDListParent(pidl, IID_IShellFolder, (void **)&psf, &pidlLast);
    if (SUCCEEDED(hres))
    {
        if (pszName)
        {
            STRRET str;
            hres = psf->GetDisplayNameOf(pidlLast, dwFlags, &str);
            if (SUCCEEDED(hres))
                hres = StrRetToBuf(&str, pidlLast, pszName, cchName);
        }

        if (SUCCEEDED(hres) && pdwAttribs)
        {
            RIP(*pdwAttribs);    // this is an in-out param
            hres = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlLast, pdwAttribs);
        }

        psf->Release();
    }

    SHCoUninitialize(hrInit);
    return hres;
}

STDAPI_(DWORD) GetUrlScheme(LPCTSTR pszUrl)
{
    if(pszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = SIZEOF(pu);
        if(SUCCEEDED(ParseURL(pszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\native.cpp ===
//
//  native.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//

#include "proj.h"
#include <vdate.h>

// get the name and flags of an absolute IDlist
// in:
//      dwFlags     SHGDN_ flags as hints to the name space GetDisplayNameOf() function
//
// in/out:
//      *pdwAttribs (optional) return flags

STDAPI SHGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs)
{
    if (pszName)
    {
        VDATEINPUTBUF(pszName, TCHAR, cchName);
        *pszName = 0;
    }

    HRESULT hrInit = SHCoInitialize();

    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hres = SHBindToIDListParent(pidl, IID_IShellFolder, (void **)&psf, &pidlLast);
    if (SUCCEEDED(hres))
    {
        if (pszName)
        {
            STRRET str;
            hres = psf->GetDisplayNameOf(pidlLast, dwFlags, &str);
            if (SUCCEEDED(hres))
                hres = StrRetToBuf(&str, pidlLast, pszName, cchName);
        }

        if (SUCCEEDED(hres) && pdwAttribs)
        {
            RIP(*pdwAttribs);    // this is an in-out param
            hres = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlLast, pdwAttribs);
        }

        psf->Release();
    }

    SHCoUninitialize(hrInit);
    return hres;
}

STDAPI_(DWORD) GetUrlScheme(LPCTSTR pszUrl)
{
    if(pszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = SIZEOF(pu);
        if(SUCCEEDED(ParseURL(pszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\proj.h ===
//
// proj.h:      Main header
//
//


#ifndef __PROJ_H__
#define __PROJ_H__

#ifndef STRICT
#define STRICT
#endif

#if defined(WINNT) || defined(WINNT_ENV)

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#endif  // WINNT

#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlguidp.h>
#include <debug.h>
#include <port32.h>
#include <ccstock.h>

#include <shsemip.h>        // for _ILNext

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone   

// Some files are compiled twice: once for unicode and once for ansi.
// There are some functions which do not want to be declared twice
// (the ones which don't use string parameters).  Otherwise we'd get
// duplicate redefinitions.
//
// These are wrapped with #ifdef DECLARE_ONCE.
#ifdef UNICODE
#define DECLARE_ONCE
#else
#undef DECLARE_ONCE
#endif


// Note that CharNext is not supported on win95.  Normally we would
// include w95wraps.h, but comctl does not link to shlwapi and
// we don't want to add this dependency.
#ifdef UNICODE
// Note that this will still break if we ever go back to non-unicode
__inline LPWSTR CharNextWrapW_(LPWSTR psz) {return ++psz;}
#undef CharNext
#define CharNext CharNextWrapW_
#endif


#endif // __PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\nativea.cpp ===
#ifdef UNICODE 
#undef UNICODE 
#endif 
//
//  native.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//

#include "proj.h"
#include <vdate.h>

// get the name and flags of an absolute IDlist
// in:
//      dwFlags     SHGDN_ flags as hints to the name space GetDisplayNameOf() function
//
// in/out:
//      *pdwAttribs (optional) return flags

STDAPI SHGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs)
{
    if (pszName)
    {
        VDATEINPUTBUF(pszName, TCHAR, cchName);
        *pszName = 0;
    }

    HRESULT hrInit = SHCoInitialize();

    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hres = SHBindToIDListParent(pidl, IID_IShellFolder, (void **)&psf, &pidlLast);
    if (SUCCEEDED(hres))
    {
        if (pszName)
        {
            STRRET str;
            hres = psf->GetDisplayNameOf(pidlLast, dwFlags, &str);
            if (SUCCEEDED(hres))
                hres = StrRetToBuf(&str, pidlLast, pszName, cchName);
        }

        if (SUCCEEDED(hres) && pdwAttribs)
        {
            RIP(*pdwAttribs);    // this is an in-out param
            hres = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlLast, pdwAttribs);
        }

        psf->Release();
    }

    SHCoUninitialize(hrInit);
    return hres;
}

STDAPI_(DWORD) GetUrlScheme(LPCTSTR pszUrl)
{
    if(pszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = SIZEOF(pu);
        if(SUCCEEDED(ParseURL(pszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\security.cpp ===
#include "proj.h"
#include <mshtml.h>

STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc)
{
    *ppHtmlDoc = NULL;

    if (!punk)
        return E_FAIL;
        
    *ppHtmlDoc = NULL;
    //  The window.external, jscript "new ActiveXObject" and the <OBJECT> tag
    //  don't take us down the same road.

    IOleClientSite *pClientSite;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IOleClientSite, &pClientSite));
    if (SUCCEEDED(hr))
    {
        //  <OBJECT> tag path

        IOleContainer *pContainer;
        hr = pClientSite->GetContainer(&pContainer);
        if (SUCCEEDED(hr))
        {
            hr = pContainer->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
            pContainer->Release();
        }
    
        if (FAILED(hr))
        {
            //  window.external path
            IWebBrowser2 *pWebBrowser2;
            hr = IUnknown_QueryService(pClientSite, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pWebBrowser2));
            if (SUCCEEDED(hr))
            {
                IDispatch *pDispatch;
                hr = pWebBrowser2->get_Document(&pDispatch);
                if (SUCCEEDED(hr))
                {
                    hr = pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
                    pDispatch->Release();
                }
                pWebBrowser2->Release();
            }
        }
        pClientSite->Release();
    }
    else
    {
        //  jscript path
        hr = IUnknown_QueryService(punk, SID_SContainerDispatch, IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
    }

    ASSERT(FAILED(hr) || (*ppHtmlDoc));

    return hr;
}

STDAPI LocalZoneCheckPath(LPCWSTR pszUrl)
{
    HRESULT hr = E_ACCESSDENIED;
    if (pszUrl) 
    {
        IInternetSecurityManager *pSecMgr;
        if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_IInternetSecurityManager, 
                                       (void **)&pSecMgr))) 
        {
            DWORD dwZoneID = URLZONE_UNTRUSTED;
            if (SUCCEEDED(pSecMgr->MapUrlToZone(pszUrl, &dwZoneID, 0))) 
            {
                if (dwZoneID == URLZONE_LOCAL_MACHINE)
                    hr = S_OK;
            }       
            pSecMgr->Release();
        }
    } 
    else 
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDAPI LocalZoneCheck(IUnknown *punkSite)
{
    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    HRESULT hr = E_ACCESSDENIED;
    BOOL fTriedBrowser = FALSE;

    // Try to find the original template path for zone checking
    IOleCommandTarget * pct;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_IOleCommandTarget, (void **)&pct)))
    {
        VARIANT vTemplatePath;
        vTemplatePath.vt = VT_EMPTY;
        if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vTemplatePath) == S_OK)
        {
            fTriedBrowser = TRUE;
            if (vTemplatePath.vt == VT_BSTR)
                hr = LocalZoneCheckPath(vTemplatePath.bstrVal);

            // We were able to talk to the browser, so don't fall back on Trident because they may be
            // less secure.
            fTriedBrowser = TRUE;
            VariantClear(&vTemplatePath);
        }
        pct->Release();
    }

    // If this is one of those cases where the browser doesn't exist (AOL, VB, ...) then
    // we will check the scripts security.  If we did ask the browser, don't ask trident
    // because the browser is often more restrictive in some cases.
    if (!fTriedBrowser && (hr != S_OK))
    {
        // Try to use the URL from the document to zone check 
        IHTMLDocument2 *pHtmlDoc;
        if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR bstrURL;
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrURL)))
            {
                // NOTE: the above URL is improperly escaped, this is
                // due to app compat. if you depend on this URL being valid
                // use another means to get this

                hr = LocalZoneCheckPath(bstrURL);
                SysFreeString(bstrURL);
            }
            pHtmlDoc->Release();
        }
    }
                            
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\runtask.cpp ===
#include "proj.h"

#include "runtask.h"

#define SUPERCLASS  

// #define TF_RUNTASK  TF_GENERAL
#define TF_RUNTASK  0
// #define TF_RUNTASKV TF_CUSTOM1     // verbose version
#define TF_RUNTASKV 0


// constructor
CRunnableTask::CRunnableTask(DWORD dwFlags)
{
    _lState = IRTIR_TASK_NOT_RUNNING;
    _dwFlags = dwFlags;

    ASSERT(NULL == _hDone);
    
    if (_dwFlags & RTF_SUPPORTKILLSUSPEND)
    {
        // we signal this on suspend or kill
        // Explicitly call the ANSI version so we don't need to worry
        // about whether we're being built UNICODE and have to switch
        // to a wrapper function...
        _hDone = CreateEventA(NULL, TRUE, FALSE, NULL);
    }

#ifdef DEBUG
    _dwTaskID = GetTickCount();

    TraceMsg(TF_RUNTASK, "CRunnableTask (%#lx): creating task", _dwTaskID);
#endif

    _cRef = 1;
}


// destructor
CRunnableTask::~CRunnableTask()
{
    DEBUG_CODE( TraceMsg(TF_RUNTASK, "CRunnableTask (%#lx): deleting task", _dwTaskID); )

    if (_hDone)
        CloseHandle(_hDone);
}


STDMETHODIMP CRunnableTask::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    if ( ppvObj == NULL )
    {
        return E_INVALIDARG;
    }
    if ( riid == IID_IRunnableTask )
    {
        *ppvObj = SAFECAST( this, IRunnableTask *);
        AddRef();
    }
    else
        return E_NOINTERFACE;


    return NOERROR;
}


STDMETHODIMP_(ULONG) CRunnableTask::AddRef()
{
    InterlockedIncrement(&_cRef);
    return _cRef;
}


STDMETHODIMP_ (ULONG) CRunnableTask::Release()
{
    if (0 == _cRef)
    {
        AssertMsg(0, TEXT("CRunnableTask::Release called too many times!"));
        return 0;
    }
    
    if ( InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Run method

         This does a lot of the state-related work, and then
         calls the derived-class's RunRT() method.
         
*/
STDMETHODIMP CRunnableTask::Run(void)
{
    HRESULT hr = E_FAIL;

    // Are we already running?
    if (_lState == IRTIR_TASK_RUNNING)
    {
        // Yes; nothing to do 
        hr = S_FALSE;
    }
    else if ( _lState == IRTIR_TASK_PENDING )
    {
        hr = E_FAIL;
    }
    else if ( _lState == IRTIR_TASK_NOT_RUNNING )
    {
        // Say we're running
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
        if ( lRes == IRTIR_TASK_PENDING )
        {
            _lState = IRTIR_TASK_FINISHED;
            return NOERROR;
        }

        if (_lState == IRTIR_TASK_RUNNING)
        {
            // Prepare to run 
            DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): initialize to run", _dwTaskID); )
            
            hr = RunInitRT();
            
            ASSERT(E_PENDING != hr);
        }

        if (SUCCEEDED(hr) && _lState == IRTIR_TASK_RUNNING)
        {
            // Continue to do the work
            hr = InternalResumeRT();
        }

        if (FAILED(hr) && E_PENDING != hr)
        {
            DEBUG_CODE( TraceMsg(TF_WARNING, "CRunnableTask (%#lx): task failed to run: %#lx", _dwTaskID, hr); )
        }            

        // Are we finished?
        if (_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            // Yes
            _lState = IRTIR_TASK_FINISHED;
        }
    }
    
    return hr;
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Kill method

*/
STDMETHODIMP CRunnableTask::Kill(BOOL fWait)
{
    if ( !(_dwFlags & RTF_SUPPORTKILLSUSPEND) )
        return E_NOTIMPL;
        
    if (_lState != IRTIR_TASK_RUNNING)
        return S_FALSE;

    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): killing task", _dwTaskID); )

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_PENDING);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): task already finished", _dwTaskID); )

        _lState = lRes;
    }
    else if (_hDone)
    {
        // signal the event it is likely to be waiting on
        SetEvent(_hDone);
    }

    return KillRT(fWait);
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Suspend method

*/
STDMETHODIMP CRunnableTask::Suspend( void )
{
    if ( !(_dwFlags & RTF_SUPPORTKILLSUSPEND) )
        return E_NOTIMPL;
        
    if (_lState != IRTIR_TASK_RUNNING)
        return E_FAIL;
    
    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): suspending task", _dwTaskID); )
    
    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_SUSPENDED);

    if (IRTIR_TASK_FINISHED == lRes)
    {
        // we finished before we could suspend
        DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): task already finished", _dwTaskID); )
        
        _lState = lRes;
        return NOERROR;
    }

    if (_hDone)
        SetEvent(_hDone);

    return SuspendRT();
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Resume method

*/
STDMETHODIMP CRunnableTask::Resume(void)
{
    if (_lState != IRTIR_TASK_SUSPENDED)
        return E_FAIL;

    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): resuming task", _dwTaskID); )

    _lState = IRTIR_TASK_RUNNING;

    return ResumeRT();
}


/*----------------------------------------------------------
Purpose: IRunnableTask::IsRunning method

*/
STDMETHODIMP_( ULONG ) CRunnableTask:: IsRunning ( void )
{
    return _lState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shguidp.c ===
#include <initguid.h>

#ifdef UNIX
#include <shldisp.h>
#include <docobj.h>
#include <shlobj.h>
#endif

#include <shlguidp.h>
#include <shguidp.h>
#include <shdguid.h>
#include <sfview.h>
#include <dvocx.h>
#include <msluguid.h>
#include <adoid.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shguid.c ===
#define INITGUID
#include <initguid.h>

#define GUID_DEFS_ONLY
#include <shlguid.h>
#include <shlguidp.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shco.c ===
#include "proj.h"

// Need to put into separate file because for some reason the /Gy compiler
// option doesn't work.

//
//  COM Initialization is weird due to multithreaded apartments.
//
//  If this thread has not called CoInitialize yet, but some other thread
//  in the process has called CoInitialize with the COINIT_MULTITHREADED,
//  then that infects our thread with the multithreaded virus, and a
//  COINIT_APARTMENTTHREADED will fail.
//
//  In this case, we must turn around and re-init ourselves as
//  COINIT_MULTITHREADED to increment the COM refcount on our thread.
//  If we didn't do that, and that other thread decided to do a
//  CoUninitialize, that >secretly< uninitializes COM on our own thread
//  and we fall over and die.
//
STDAPI SHCoInitialize(void)
{
    HRESULT hres;

    hres = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hres)) {
        hres = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shstr.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class Implementation

    shstr.cpp

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


 Abstract:

    this allows automatic resizing and stuff.

  NOTE: this class is specifically designed to be used as a stack variable


--*/

#include "proj.h"
#include <shstr.h>


#define MALLOC(c)       LocalAlloc(LPTR, (c))
#define FREE(p)         LocalFree(p)

//
//  ShStr Public Methods
//

//
//  Constructors
//

ShStr :: ShStr () 
{
    _szDefaultBuffer[0] = '\0';
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}


/**************
    StrStr SetStr() methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/

HRESULT 
ShStr :: SetStr (LPCSTR pszStr)
{
    Reset();
    
    return _SetStr(pszStr);

}

HRESULT 
ShStr :: SetStr (LPCSTR pszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pszStr, cchStr);

}

HRESULT 
ShStr :: SetStr (LPCWSTR pwszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pwszStr, cchStr);

}


HRESULT
ShStr :: Append(LPCTSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_OK;

    if(pszStr)
    {
        DWORD cchLen = GetLen();

        if(cchStr == (DWORD) -1)
            cchStr = lstrlen(pszStr);

        //
        //  StrCpyN automagically appends the null term, 
        //  so we need to give room for it
        //
        cchStr++;

        if(SUCCEEDED(SetSize(cchStr + cchLen)))
            StrCpyN(_pszStr + cchLen, pszStr, cchStr);
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

ShStr *
ShStr :: Clone()
{
    ShStr *pshstr = new ShStr;

    if (pshstr)
    {
        pshstr->SetStr(_pszStr);
    
        if(pshstr->IsValid())
            return pshstr;
    }

    if(pshstr)
        delete pshstr;

    return NULL;
}

LPSTR 
ShStr :: CloneStrA()
#ifdef UNICODE
{
    LPSTR pszStr = NULL;

    if(_pszStr)
    {
        DWORD cchStr;
    
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            _pszStr, -1,
            NULL, 0,
            NULL, NULL);

        ASSERT(cchStr);

        if(cchStr)
        {
            pszStr = (LPSTR) MALLOC (CbFromCch(cchStr +1));

            if(pszStr)
            {
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    _pszStr, -1,
                    pszStr, cchStr,
                    NULL, NULL);
                ASSERT (cchStr);
            }
        }
    }

    return pszStr;
}

#else //!UNICODE

    {return _pszStr ? StrDupA(_pszStr) : NULL;}
#endif //UNICODE


#ifdef UNICODE
  
#endif
LPWSTR 
ShStr :: CloneStrW()
#ifdef UNICODE
    {return _pszStr ? StrDupW(_pszStr) : NULL;}
#else //!UNICODE
{
    LPWSTR pwsz;
    DWORD cch = lstrlenA(_pszStr) +1;

    pwsz = (LPWSTR) MALLOC (sizeof(WCHAR) * cch);
    
    if(pwsz)
        MultiByteToWideChar(CP_ACP, 0,
            _pszStr, -1,
            pwsz, cch);

    return pwsz;
}
#endif //UNICODE


/**************
    ShStr Utility methods

**************/


/**************
    ShStr SetSize method

    Sets the size of the internal buffer if larger than default

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT
ShStr :: SetSize(DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD cchNewSize = _cchSize;

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    // so that we always allocate in increments
    while (cchSize > cchNewSize)
        cchNewSize <<= 2;
    
    if(cchNewSize != _cchSize)
    {
        if(cchNewSize > DEFAULT_SHSTR_LENGTH)
        {
            LPTSTR psz;

            psz = (LPTSTR) LocalAlloc(LPTR, CbFromCch(cchNewSize));
    
            if(psz)
            {
                StrCpyN(psz, _pszStr, cchSize);
                Reset();
                _cchSize = cchNewSize;
                _pszStr = psz;
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (_pszStr && _cchSize) 
                StrCpyN(_szDefaultBuffer, _pszStr, ARRAYSIZE(_szDefaultBuffer));

            Reset();

            _pszStr = _szDefaultBuffer;
        }
    }

    return hr;
}

#ifdef DEBUG
BOOL
ShStr :: IsValid()
{
    BOOL fRet = TRUE;

    if(!_pszStr)
        fRet = FALSE;

    ASSERT( ((_cchSize != ARRAYSIZE(_szDefaultBuffer)) && (_pszStr != _szDefaultBuffer)) ||
            ((_cchSize == ARRAYSIZE(_szDefaultBuffer)) && (_pszStr == _szDefaultBuffer)) );

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    return fRet;
}
#endif //DEBUG

VOID 
ShStr :: Reset()
{
    if (_pszStr && (_cchSize != ARRAYSIZE(_szDefaultBuffer))) 
        LocalFree(_pszStr);

    _szDefaultBuffer[0] = TEXT('\0');
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)
VOID
ShStr :: Trim()
{

    if(_pszStr)
    {
        // BUGBUG - NETSCAPE compatibility - zekel 29-JAN-97
        //  we want to leave one space in the string
        TCHAR chFirst = *_pszStr;

        //  first trim the backside
        TCHAR *pchLastWhite = NULL;
        LPTSTR pch = _pszStr;
        
        // the front side
        while (*pch && IsWhite(*pch))
            pch = CharNext(pch);

        if (pch > _pszStr)
        {
            LPTSTR pchDst = _pszStr;

            while (*pchDst = *pch)
            {
                pch = CharNext(pch);
                pchDst = CharNext(pchDst);
            }
        }

        // then the backside
        for (pch = _pszStr; *pch; pch = CharNext(pch))
        {
            if(pchLastWhite && !IsWhite(*pch))
                pchLastWhite = NULL;
            else if(!pchLastWhite && IsWhite(*pch))
                pchLastWhite = pch;
        }

        if(pchLastWhite)
            *pchLastWhite = TEXT('\0');

        if(TEXT(' ') == chFirst && !*_pszStr)
        {
            _pszStr[0] = TEXT(' ');
            _pszStr[1] = TEXT('\0');
        }
    }
}

    


//
//  ShStr Private Methods
//


/**************
    StrStr Set* methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT 
ShStr :: _SetStr(LPCSTR pszStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr)
    {
        DWORD cchStr;

        cchStr = lstrlenA(pszStr);
    
        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if (SUCCEEDED(hr))
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0,
                    pszStr, -1,
                    _pszStr, _cchSize);
#else //!UNICODE
                lstrcpyA(_pszStr, pszStr);
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr(LPCSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
            cchStr = lstrlenA(pszStr);

        hr = SetSize(cchStr +1);

        if(SUCCEEDED(hr))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0,
                pszStr, cchStr,
                _pszStr, _cchSize);
            _pszStr[cchStr] = TEXT('\0');

#else //!UNICODE
            StrCpyN(_pszStr, pszStr, (++cchStr < _cchSize ? cchStr : _cchSize) );
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr (LPCWSTR pwszStr, DWORD cchStrIn)
{
    DWORD cchStr = cchStrIn;
    HRESULT hr = S_FALSE;

    if(pwszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
#ifdef UNICODE
            cchStr = lstrlen(pwszStr);
#else //!UNICODE
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            pwszStr, cchStrIn,
            NULL, 0,
            NULL, NULL);
#endif //UNICODE

        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if(SUCCEEDED(hr))
            {
#ifdef UNICODE 
                StrCpyN(_pszStr, pwszStr, (cchStr + 1< _cchSize ? cchStr + 1: _cchSize));
#else //!UNICODE
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    pwszStr, cchStrIn,
                    _pszStr, _cchSize,
                    NULL, NULL);
                _pszStr[cchStr < _cchSize ? cchStr : _cchSize] = TEXT('\0');
                ASSERT (cchStr);
#endif //UNICODE
            }
        }
#ifdef DEBUG
        else
        {
            DWORD dw;
            dw = GetLastError();
        }
#endif //DEBUG

    }
#ifdef DEBUG
    else
    {
        DWORD dw;
        dw = GetLastError();
    }
#endif //DEBUG

    return hr;
}

#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96
//
//  UrlStr Methods
//
  
  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl)
{
    return SetUrl(pszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl)
{
    return SetUrl(pwszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pszUrl, cchUrl);
    return *this;
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pwszUrl, cchUrl);
    return *this;
}

 
UrlStr::operator LPCTSTR()
{
    return _strUrl.GetStr();
}

  
UrlStr::operator SHSTR()
{
    return _strUrl;
}




  HRESULT
UrlStr::Combine(LPCTSTR pszUrl, DWORD dwFlags)
{
    SHSTR strRel;
    SHSTR strOut;
    HRESULT hr;

    strRel.SetStr(pszUrl);

    hr = UrlCombine(_strUrl.GetStr(), 
    hr = SHUrlParse(&_strUrl, &strRel, &strOut, NULL, URL_PARSE_CREATE);

    if(SUCCEEDED(hr))
        _strUrl = strOut;

    return hr;
}

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);
    HRESULT Encode(DWORD dwFlags);
    HRESULT EncodeSpaces()
        {return Encode(URL_ENCODE_SPACES_ONLY)}
    HRESULT Decode(DWORD dwFlags)
*/
#endif  //DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shstra.cpp ===
#ifdef UNICODE 
#undef UNICODE 
#endif 
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class Implementation

    shstr.cpp

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


 Abstract:

    this allows automatic resizing and stuff.

  NOTE: this class is specifically designed to be used as a stack variable


--*/

#include "proj.h"
#include <shstr.h>


#define MALLOC(c)       LocalAlloc(LPTR, (c))
#define FREE(p)         LocalFree(p)

//
//  ShStr Public Methods
//

//
//  Constructors
//

ShStr :: ShStr () 
{
    _szDefaultBuffer[0] = '\0';
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}


/**************
    StrStr SetStr() methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/

HRESULT 
ShStr :: SetStr (LPCSTR pszStr)
{
    Reset();
    
    return _SetStr(pszStr);

}

HRESULT 
ShStr :: SetStr (LPCSTR pszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pszStr, cchStr);

}

HRESULT 
ShStr :: SetStr (LPCWSTR pwszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pwszStr, cchStr);

}


HRESULT
ShStr :: Append(LPCTSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_OK;

    if(pszStr)
    {
        DWORD cchLen = GetLen();

        if(cchStr == (DWORD) -1)
            cchStr = lstrlen(pszStr);

        //
        //  StrCpyN automagically appends the null term, 
        //  so we need to give room for it
        //
        cchStr++;

        if(SUCCEEDED(SetSize(cchStr + cchLen)))
            StrCpyN(_pszStr + cchLen, pszStr, cchStr);
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

ShStr *
ShStr :: Clone()
{
    ShStr *pshstr = new ShStr;

    if (pshstr)
    {
        pshstr->SetStr(_pszStr);
    
        if(pshstr->IsValid())
            return pshstr;
    }

    if(pshstr)
        delete pshstr;

    return NULL;
}

LPSTR 
ShStr :: CloneStrA()
#ifdef UNICODE
{
    LPSTR pszStr = NULL;

    if(_pszStr)
    {
        DWORD cchStr;
    
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            _pszStr, -1,
            NULL, 0,
            NULL, NULL);

        ASSERT(cchStr);

        if(cchStr)
        {
            pszStr = (LPSTR) MALLOC (CbFromCch(cchStr +1));

            if(pszStr)
            {
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    _pszStr, -1,
                    pszStr, cchStr,
                    NULL, NULL);
                ASSERT (cchStr);
            }
        }
    }

    return pszStr;
}

#else //!UNICODE

    {return _pszStr ? StrDupA(_pszStr) : NULL;}
#endif //UNICODE


#ifdef UNICODE
  
#endif
LPWSTR 
ShStr :: CloneStrW()
#ifdef UNICODE
    {return _pszStr ? StrDupW(_pszStr) : NULL;}
#else //!UNICODE
{
    LPWSTR pwsz;
    DWORD cch = lstrlenA(_pszStr) +1;

    pwsz = (LPWSTR) MALLOC (sizeof(WCHAR) * cch);
    
    if(pwsz)
        MultiByteToWideChar(CP_ACP, 0,
            _pszStr, -1,
            pwsz, cch);

    return pwsz;
}
#endif //UNICODE


/**************
    ShStr Utility methods

**************/


/**************
    ShStr SetSize method

    Sets the size of the internal buffer if larger than default

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT
ShStr :: SetSize(DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD cchNewSize = _cchSize;

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    // so that we always allocate in increments
    while (cchSize > cchNewSize)
        cchNewSize <<= 2;
    
    if(cchNewSize != _cchSize)
    {
        if(cchNewSize > DEFAULT_SHSTR_LENGTH)
        {
            LPTSTR psz;

            psz = (LPTSTR) LocalAlloc(LPTR, CbFromCch(cchNewSize));
    
            if(psz)
            {
                StrCpyN(psz, _pszStr, cchSize);
                Reset();
                _cchSize = cchNewSize;
                _pszStr = psz;
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (_pszStr && _cchSize) 
                StrCpyN(_szDefaultBuffer, _pszStr, ARRAYSIZE(_szDefaultBuffer));

            Reset();

            _pszStr = _szDefaultBuffer;
        }
    }

    return hr;
}

#ifdef DEBUG
BOOL
ShStr :: IsValid()
{
    BOOL fRet = TRUE;

    if(!_pszStr)
        fRet = FALSE;

    ASSERT( ((_cchSize != ARRAYSIZE(_szDefaultBuffer)) && (_pszStr != _szDefaultBuffer)) ||
            ((_cchSize == ARRAYSIZE(_szDefaultBuffer)) && (_pszStr == _szDefaultBuffer)) );

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    return fRet;
}
#endif //DEBUG

VOID 
ShStr :: Reset()
{
    if (_pszStr && (_cchSize != ARRAYSIZE(_szDefaultBuffer))) 
        LocalFree(_pszStr);

    _szDefaultBuffer[0] = TEXT('\0');
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)
VOID
ShStr :: Trim()
{

    if(_pszStr)
    {
        // BUGBUG - NETSCAPE compatibility - zekel 29-JAN-97
        //  we want to leave one space in the string
        TCHAR chFirst = *_pszStr;

        //  first trim the backside
        TCHAR *pchLastWhite = NULL;
        LPTSTR pch = _pszStr;
        
        // the front side
        while (*pch && IsWhite(*pch))
            pch = CharNext(pch);

        if (pch > _pszStr)
        {
            LPTSTR pchDst = _pszStr;

            while (*pchDst = *pch)
            {
                pch = CharNext(pch);
                pchDst = CharNext(pchDst);
            }
        }

        // then the backside
        for (pch = _pszStr; *pch; pch = CharNext(pch))
        {
            if(pchLastWhite && !IsWhite(*pch))
                pchLastWhite = NULL;
            else if(!pchLastWhite && IsWhite(*pch))
                pchLastWhite = pch;
        }

        if(pchLastWhite)
            *pchLastWhite = TEXT('\0');

        if(TEXT(' ') == chFirst && !*_pszStr)
        {
            _pszStr[0] = TEXT(' ');
            _pszStr[1] = TEXT('\0');
        }
    }
}

    


//
//  ShStr Private Methods
//


/**************
    StrStr Set* methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT 
ShStr :: _SetStr(LPCSTR pszStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr)
    {
        DWORD cchStr;

        cchStr = lstrlenA(pszStr);
    
        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if (SUCCEEDED(hr))
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0,
                    pszStr, -1,
                    _pszStr, _cchSize);
#else //!UNICODE
                lstrcpyA(_pszStr, pszStr);
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr(LPCSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
            cchStr = lstrlenA(pszStr);

        hr = SetSize(cchStr +1);

        if(SUCCEEDED(hr))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0,
                pszStr, cchStr,
                _pszStr, _cchSize);
            _pszStr[cchStr] = TEXT('\0');

#else //!UNICODE
            StrCpyN(_pszStr, pszStr, (++cchStr < _cchSize ? cchStr : _cchSize) );
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr (LPCWSTR pwszStr, DWORD cchStrIn)
{
    DWORD cchStr = cchStrIn;
    HRESULT hr = S_FALSE;

    if(pwszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
#ifdef UNICODE
            cchStr = lstrlen(pwszStr);
#else //!UNICODE
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            pwszStr, cchStrIn,
            NULL, 0,
            NULL, NULL);
#endif //UNICODE

        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if(SUCCEEDED(hr))
            {
#ifdef UNICODE 
                StrCpyN(_pszStr, pwszStr, (cchStr + 1< _cchSize ? cchStr + 1: _cchSize));
#else //!UNICODE
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    pwszStr, cchStrIn,
                    _pszStr, _cchSize,
                    NULL, NULL);
                _pszStr[cchStr < _cchSize ? cchStr : _cchSize] = TEXT('\0');
                ASSERT (cchStr);
#endif //UNICODE
            }
        }
#ifdef DEBUG
        else
        {
            DWORD dw;
            dw = GetLastError();
        }
#endif //DEBUG

    }
#ifdef DEBUG
    else
    {
        DWORD dw;
        dw = GetLastError();
    }
#endif //DEBUG

    return hr;
}

#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96
//
//  UrlStr Methods
//
  
  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl)
{
    return SetUrl(pszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl)
{
    return SetUrl(pwszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pszUrl, cchUrl);
    return *this;
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pwszUrl, cchUrl);
    return *this;
}

 
UrlStr::operator LPCTSTR()
{
    return _strUrl.GetStr();
}

  
UrlStr::operator SHSTR()
{
    return _strUrl;
}




  HRESULT
UrlStr::Combine(LPCTSTR pszUrl, DWORD dwFlags)
{
    SHSTR strRel;
    SHSTR strOut;
    HRESULT hr;

    strRel.SetStr(pszUrl);

    hr = UrlCombine(_strUrl.GetStr(), 
    hr = SHUrlParse(&_strUrl, &strRel, &strOut, NULL, URL_PARSE_CREATE);

    if(SUCCEEDED(hr))
        _strUrl = strOut;

    return hr;
}

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);
    HRESULT Encode(DWORD dwFlags);
    HRESULT EncodeSpaces()
        {return Encode(URL_ENCODE_SPACES_ONLY)}
    HRESULT Decode(DWORD dwFlags)
*/
#endif  //DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shstrw.cpp ===
#ifndef UNICODE 
#define UNICODE 
#endif 
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class Implementation

    shstr.cpp

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


 Abstract:

    this allows automatic resizing and stuff.

  NOTE: this class is specifically designed to be used as a stack variable


--*/

#include "proj.h"
#include <shstr.h>


#define MALLOC(c)       LocalAlloc(LPTR, (c))
#define FREE(p)         LocalFree(p)

//
//  ShStr Public Methods
//

//
//  Constructors
//

ShStr :: ShStr () 
{
    _szDefaultBuffer[0] = '\0';
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}


/**************
    StrStr SetStr() methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/

HRESULT 
ShStr :: SetStr (LPCSTR pszStr)
{
    Reset();
    
    return _SetStr(pszStr);

}

HRESULT 
ShStr :: SetStr (LPCSTR pszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pszStr, cchStr);

}

HRESULT 
ShStr :: SetStr (LPCWSTR pwszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pwszStr, cchStr);

}


HRESULT
ShStr :: Append(LPCTSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_OK;

    if(pszStr)
    {
        DWORD cchLen = GetLen();

        if(cchStr == (DWORD) -1)
            cchStr = lstrlen(pszStr);

        //
        //  StrCpyN automagically appends the null term, 
        //  so we need to give room for it
        //
        cchStr++;

        if(SUCCEEDED(SetSize(cchStr + cchLen)))
            StrCpyN(_pszStr + cchLen, pszStr, cchStr);
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

ShStr *
ShStr :: Clone()
{
    ShStr *pshstr = new ShStr;

    if (pshstr)
    {
        pshstr->SetStr(_pszStr);
    
        if(pshstr->IsValid())
            return pshstr;
    }

    if(pshstr)
        delete pshstr;

    return NULL;
}

LPSTR 
ShStr :: CloneStrA()
#ifdef UNICODE
{
    LPSTR pszStr = NULL;

    if(_pszStr)
    {
        DWORD cchStr;
    
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            _pszStr, -1,
            NULL, 0,
            NULL, NULL);

        ASSERT(cchStr);

        if(cchStr)
        {
            pszStr = (LPSTR) MALLOC (CbFromCch(cchStr +1));

            if(pszStr)
            {
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    _pszStr, -1,
                    pszStr, cchStr,
                    NULL, NULL);
                ASSERT (cchStr);
            }
        }
    }

    return pszStr;
}

#else //!UNICODE

    {return _pszStr ? StrDupA(_pszStr) : NULL;}
#endif //UNICODE


#ifdef UNICODE
  
#endif
LPWSTR 
ShStr :: CloneStrW()
#ifdef UNICODE
    {return _pszStr ? StrDupW(_pszStr) : NULL;}
#else //!UNICODE
{
    LPWSTR pwsz;
    DWORD cch = lstrlenA(_pszStr) +1;

    pwsz = (LPWSTR) MALLOC (sizeof(WCHAR) * cch);
    
    if(pwsz)
        MultiByteToWideChar(CP_ACP, 0,
            _pszStr, -1,
            pwsz, cch);

    return pwsz;
}
#endif //UNICODE


/**************
    ShStr Utility methods

**************/


/**************
    ShStr SetSize method

    Sets the size of the internal buffer if larger than default

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT
ShStr :: SetSize(DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD cchNewSize = _cchSize;

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    // so that we always allocate in increments
    while (cchSize > cchNewSize)
        cchNewSize <<= 2;
    
    if(cchNewSize != _cchSize)
    {
        if(cchNewSize > DEFAULT_SHSTR_LENGTH)
        {
            LPTSTR psz;

            psz = (LPTSTR) LocalAlloc(LPTR, CbFromCch(cchNewSize));
    
            if(psz)
            {
                StrCpyN(psz, _pszStr, cchSize);
                Reset();
                _cchSize = cchNewSize;
                _pszStr = psz;
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (_pszStr && _cchSize) 
                StrCpyN(_szDefaultBuffer, _pszStr, ARRAYSIZE(_szDefaultBuffer));

            Reset();

            _pszStr = _szDefaultBuffer;
        }
    }

    return hr;
}

#ifdef DEBUG
BOOL
ShStr :: IsValid()
{
    BOOL fRet = TRUE;

    if(!_pszStr)
        fRet = FALSE;

    ASSERT( ((_cchSize != ARRAYSIZE(_szDefaultBuffer)) && (_pszStr != _szDefaultBuffer)) ||
            ((_cchSize == ARRAYSIZE(_szDefaultBuffer)) && (_pszStr == _szDefaultBuffer)) );

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    return fRet;
}
#endif //DEBUG

VOID 
ShStr :: Reset()
{
    if (_pszStr && (_cchSize != ARRAYSIZE(_szDefaultBuffer))) 
        LocalFree(_pszStr);

    _szDefaultBuffer[0] = TEXT('\0');
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)
VOID
ShStr :: Trim()
{

    if(_pszStr)
    {
        // BUGBUG - NETSCAPE compatibility - zekel 29-JAN-97
        //  we want to leave one space in the string
        TCHAR chFirst = *_pszStr;

        //  first trim the backside
        TCHAR *pchLastWhite = NULL;
        LPTSTR pch = _pszStr;
        
        // the front side
        while (*pch && IsWhite(*pch))
            pch = CharNext(pch);

        if (pch > _pszStr)
        {
            LPTSTR pchDst = _pszStr;

            while (*pchDst = *pch)
            {
                pch = CharNext(pch);
                pchDst = CharNext(pchDst);
            }
        }

        // then the backside
        for (pch = _pszStr; *pch; pch = CharNext(pch))
        {
            if(pchLastWhite && !IsWhite(*pch))
                pchLastWhite = NULL;
            else if(!pchLastWhite && IsWhite(*pch))
                pchLastWhite = pch;
        }

        if(pchLastWhite)
            *pchLastWhite = TEXT('\0');

        if(TEXT(' ') == chFirst && !*_pszStr)
        {
            _pszStr[0] = TEXT(' ');
            _pszStr[1] = TEXT('\0');
        }
    }
}

    


//
//  ShStr Private Methods
//


/**************
    StrStr Set* methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT 
ShStr :: _SetStr(LPCSTR pszStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr)
    {
        DWORD cchStr;

        cchStr = lstrlenA(pszStr);
    
        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if (SUCCEEDED(hr))
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0,
                    pszStr, -1,
                    _pszStr, _cchSize);
#else //!UNICODE
                lstrcpyA(_pszStr, pszStr);
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr(LPCSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
            cchStr = lstrlenA(pszStr);

        hr = SetSize(cchStr +1);

        if(SUCCEEDED(hr))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0,
                pszStr, cchStr,
                _pszStr, _cchSize);
            _pszStr[cchStr] = TEXT('\0');

#else //!UNICODE
            StrCpyN(_pszStr, pszStr, (++cchStr < _cchSize ? cchStr : _cchSize) );
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr (LPCWSTR pwszStr, DWORD cchStrIn)
{
    DWORD cchStr = cchStrIn;
    HRESULT hr = S_FALSE;

    if(pwszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
#ifdef UNICODE
            cchStr = lstrlen(pwszStr);
#else //!UNICODE
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            pwszStr, cchStrIn,
            NULL, 0,
            NULL, NULL);
#endif //UNICODE

        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if(SUCCEEDED(hr))
            {
#ifdef UNICODE 
                StrCpyN(_pszStr, pwszStr, (cchStr + 1< _cchSize ? cchStr + 1: _cchSize));
#else //!UNICODE
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    pwszStr, cchStrIn,
                    _pszStr, _cchSize,
                    NULL, NULL);
                _pszStr[cchStr < _cchSize ? cchStr : _cchSize] = TEXT('\0');
                ASSERT (cchStr);
#endif //UNICODE
            }
        }
#ifdef DEBUG
        else
        {
            DWORD dw;
            dw = GetLastError();
        }
#endif //DEBUG

    }
#ifdef DEBUG
    else
    {
        DWORD dw;
        dw = GetLastError();
    }
#endif //DEBUG

    return hr;
}

#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96
//
//  UrlStr Methods
//
  
  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl)
{
    return SetUrl(pszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl)
{
    return SetUrl(pwszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pszUrl, cchUrl);
    return *this;
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pwszUrl, cchUrl);
    return *this;
}

 
UrlStr::operator LPCTSTR()
{
    return _strUrl.GetStr();
}

  
UrlStr::operator SHSTR()
{
    return _strUrl;
}




  HRESULT
UrlStr::Combine(LPCTSTR pszUrl, DWORD dwFlags)
{
    SHSTR strRel;
    SHSTR strOut;
    HRESULT hr;

    strRel.SetStr(pszUrl);

    hr = UrlCombine(_strUrl.GetStr(), 
    hr = SHUrlParse(&_strUrl, &strRel, &strOut, NULL, URL_PARSE_CREATE);

    if(SUCCEEDED(hr))
        _strUrl = strOut;

    return hr;
}

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);
    HRESULT Encode(DWORD dwFlags);
    HRESULT EncodeSpaces()
        {return Encode(URL_ENCODE_SPACES_ONLY)}
    HRESULT Decode(DWORD dwFlags)
*/
#endif  //DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\stream.cpp ===
//***   stream.cpp -- stream (IStream, IPropertyBag, registry, etc.) helpers
// DESCRIPTION
//  CRegStrPropBag  registry-based property bag
//  utils           various utils
//
#include "priv.h"
#include "stream.h"

// {
//***   CRegStrPropBag -- registry-based property bag implementation
// NOTES
//  could be better, but good enough for now

CRegStrPropBag *CRegStrPropBag_Create(HKEY hkey, DWORD grfMode)
{
    CRegStrPropBag *prspb = new CRegStrPropBag;
    if (prspb && FAILED(prspb->Initialize(hkey, grfMode))) {
        delete prspb;
        prspb = NULL;
    }
    return prspb;
}

HRESULT CRegStrPropBag::Initialize(HKEY hkey, DWORD grfMode)
{
    HRESULT hr;

    hr = SetRoot(hkey, grfMode);
    return hr;
}

CRegStrPropBag::~CRegStrPropBag()
{
    HRESULT hr = SetRoot(0, STGM_READ);         // close
    ASSERT(SUCCEEDED(hr) && !_hkey);
}

//***   CRegStrPropBag::IUnknown::* {

ULONG CRegStrPropBag::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CRegStrPropBag::Release()
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CRegStrPropBag::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CRegStrPropBag, IPropertyBag),     // IID_IPropertyBag
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

// }

//***   CRegStrPropBag::IPropertyBag::* {

//***   Read, Write --
// NOTES
//  BUGBUG perf: szName+szVal is big, but the chkstk call should still
// be faster than alloc/free i think...
HRESULT CRegStrPropBag::Read(/*[in]*/ LPCOLESTR pwzPropName,
        /*[inout]*/ VARIANT *pVar, /*[in]*/ IErrorLog *pErrorLog)
{
    ASSERT(pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR);

    HRESULT hr;

    // convert to ansi since we want REG_SZ and thus must use RegSetValueA
    TCHAR szName[MAX_PATH];
    TCHAR szVal[MAX_URL_STRING];
    DWORD cbTmp;

    SHUnicodeToTChar(pwzPropName, szName, ARRAYSIZE(szName));

    szVal[0] = 0;           // paranoia
    cbTmp = SIZEOF(szVal);
    hr = QueryValueStr(szName, szVal, &cbTmp);
    if (SUCCEEDED(hr)) {
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocStringLen(NULL, cbTmp); // n.b. cb->cch
        SHTCharToUnicode(szVal, pVar->bstrVal, cbTmp + 1);  // cbTmp does not include null
    }

    return hr;
}

#if 0   // currently unused (and untested)
HRESULT CRegStrPropBag::Write(/*[in]*/ LPCOLESTR pwzPropName,
        /*[in]*/ VARIANT *pVar)
{
    HRESULT hr;

    ASSERT(pVar->vt == VT_BSTR);

    // convert to ansi since we want REG_SZ and thus must use RegSetValueA
    char szName[MAX_PATH];
    char szVal[MAX_URL_STRING];

    SHUnicodeToAnsi(pwzPropName, szName, ARRAYSIZE(szName));
    SHUnicodeToAnsi(pVar->bstrVal, szVal, ARRAYSIZE(szVal));

    hr = SetValueStr(szName, szVal);

    return hr;
}
#endif

// }

//***   CRegStrPropBag::THISCLASS::* {

//***
//  hkey        e.g. HKLM
//  pszSubKey   e.g. "...\\Explorer\\Instance\\{...}"
//  grfMode     subset of STGM_* values
HRESULT CRegStrPropBag::SetRoot(HKEY hkeyNew, DWORD grfMode)
{
    ASSERT(grfMode == STGM_READ || grfMode == STGM_WRITE);
    if (_hkey) {
        RegCloseKey(_hkey);
        _grfMode = 0;
        _hkey = 0;
    }

    if (hkeyNew) {
        _grfMode = grfMode;
        _hkey = SHRegDuplicateHKey(hkeyNew);    // xfer ownership (and up khey refcnt)
        if (_hkey == NULL)
            return E_FAIL;
    }

    return S_OK;
}

HRESULT CRegStrPropBag::ChDir(LPCTSTR pszSubKey)
{
    HRESULT hr = E_FAIL;
    HKEY hkeyNew;

    ASSERT(_hkey);
    ASSERT(_grfMode == STGM_READ || _grfMode == STGM_WRITE);

    hkeyNew = Reg_CreateOpenKey(_hkey, pszSubKey, _grfMode);
    if (hkeyNew) {
        RegCloseKey(_hkey);
        _hkey = hkeyNew;
        hr = S_OK;
    }

    return hr;
}

HRESULT CRegStrPropBag::QueryValueStr(LPCTSTR pszName, LPTSTR pszVal, LPDWORD pcbVal)
{
    long i;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];
    CHAR szStrData[MAX_URL_STRING];
    DWORD cbSize = sizeof(szStrData);

    SHTCharToAnsi(pszName, szSubKey, ARRAYSIZE(szSubKey));
    i = SHQueryValueExA(_hkey, szSubKey, NULL, NULL, (BYTE*)szStrData, &cbSize);
    ASSERT((int)*pcbVal > lstrlenA(szStrData));    // I better be using a big enough buffer.
    SHAnsiToTChar(szStrData, pszVal, *pcbVal / sizeof(TCHAR));

    if (pcbVal)
        *pcbVal = lstrlen(pszVal);

    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CRegStrPropBag::SetValueStr(LPCTSTR pszName, LPCTSTR pszVal)
{
    return SetValueStrEx(pszName, REG_SZ, pszVal);
}

HRESULT CRegStrPropBag::SetValueStrEx(LPCTSTR pszName, DWORD dwType, LPCTSTR pszVal)
{
    long i;
    int cbTmp;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];
    CHAR szStrData[MAX_URL_STRING];

    SHTCharToAnsi(pszName, szSubKey, ARRAYSIZE(szSubKey));
    SHTCharToAnsi(pszVal, szStrData, ARRAYSIZE(szStrData));

    ASSERT(_grfMode == STGM_WRITE);
    cbTmp = (lstrlenA(szStrData) + 1);
    i = RegSetValueExA(_hkey, szSubKey, NULL, dwType, (BYTE*)szStrData, cbTmp);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

// }

// }

// {
//***   CRegStrFS -- file-system-like view of registry
// DESCRIPTION
//  basically keeps track of where we are and does 'relative' opens from
// there.  NYI: intent is to eventually support 'chdir' ops.
// NOTES
//  BUGBUG: can only 'chdir' down, not up (no '..').
//

CRegStrFS *CRegStrFS_Create(HKEY hk, DWORD grfMode)
{
    CRegStrFS *prsfs = new CRegStrFS;
    if (prsfs && FAILED(prsfs->Initialize(hk, grfMode))) {
        prsfs->Release();
        prsfs = NULL;
    }

    return prsfs;
}

//***   IsREG_XX_SZ -- see if ansi/unicode is an issue
//
#define IsREG_XX_SZ(dwTyp) \
    ((dwTyp) == REG_SZ || (dwTyp) == REG_MULTI_SZ || (dwTyp) == REG_EXPAND_SZ)

HRESULT CRegStrFS::QueryValue(LPCTSTR pszName, BYTE *pbData, LPDWORD pcbData)
{
    long i;
    DWORD dwType;
    CHAR szaTmp[MAX_URL_STRING];

    // we need to thunk since no RegXxxValueW on win95
    SHTCharToAnsi(pszName, szaTmp, ARRAYSIZE(szaTmp));

    i = SHQueryValueExA(_hkey, szaTmp, NULL, &dwType, pbData, pcbData);
    ASSERT(i != ERROR_SUCCESS || !IsREG_XX_SZ(dwType));
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CRegStrFS::SetValue(LPCTSTR pszName, DWORD dwType, const BYTE *pbData, DWORD cbData)
{
    long i;
    CHAR szaTmp[MAX_URL_STRING];

    ASSERT(_grfMode == STGM_WRITE);

    // we need to thunk since no RegXxxValueW on win95
    SHTCharToAnsi(pszName, szaTmp, ARRAYSIZE(szaTmp));
    ASSERT(!IsREG_XX_SZ(dwType));

    i = RegSetValueExA(_hkey, szaTmp, NULL, dwType, pbData, cbData);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CRegStrFS::DeleteValue(LPCTSTR pszName)
{
    long i;

    ASSERT(_grfMode == STGM_WRITE);
    i = SHDeleteValue(_hkey, NULL, pszName);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CRegStrFS::RmDir(LPCTSTR pszName, BOOL fRecurse)
{
    HRESULT hr = E_FAIL;
    DWORD i;

    CHAR szaTmp[MAX_URL_STRING];

    ASSERT(fRecurse);   // others NYI

    ASSERT(_grfMode == STGM_WRITE);

    SHTCharToAnsi(pszName, szaTmp, ARRAYSIZE(szaTmp));

    if (fRecurse) {
        i = SHDeleteKeyA(_hkey, szaTmp);
    }
    else {
        ASSERT(0);          // unused
        // not sure what to do, since we want a non-recursive delete
        // but we do want to handle presence of values (which shlwapi
        // doesn't support)
        //i = DeleteEmptyKey(_hkey, pszName);
        i = -1;
    }

    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}


// }

//***   utils {

//***   IPBag_ReadStr, WriteStr -- IPBag->Read/Write w/o the hassles
// NOTES
//  'hassles' means variant and OLESTR stuff
//  WARNING: pwzPropName is an OLESTR, buf is a TSTR (we use an OLESTR since
//  name is usually static so no sense doing extra runtime convert here).
HRESULT IPBag_ReadStr(IPropertyBag *pPBag, LPCOLESTR pwzPropName, LPTSTR buf, int cch)
{
    HRESULT hr;
    VARIANT va = { 0 };

    va.vt = VT_BSTR;
    hr = pPBag->Read(pwzPropName, &va, NULL);
    if (SUCCEEDED(hr))
    {    
#ifdef UNICODE
        StrCpyNW(buf, va.bstrVal, cch);
#else
        SHUnicodeToAnsi(va.bstrVal, buf, cch);
#endif
    }
    
    VariantClear(&va);

    return hr;
}

#if 0 // (currently) unused (but has been tested)
HRESULT IPBag_WriteStr(IPropertyBag *pPBag, LPCOLESTR pwzPropName, LPTSTR buf)
{
    HRESULT hr;
    VARIANT va = { 0 };

    va.vt = VT_BSTR;
    int cch = lstrlen(buf) + 1;
    va.bstrVal = SysAllocStringLen(NULL, cch);
#ifdef UNICODE
    StrCpyNW(va.bstrVal, buf, cch);
#else
    SHAnsiToUnicode(buf, va.bstrVal, cch);
#endif
    hr = pPBag->Write(pwzPropName, &va);

    VariantClear(&va);  // SysFreeString

    return hr;
}
#endif

//***   Reg_CreateOpenKey -- merged RegCreate/RegOpen
//
HKEY Reg_CreateOpenKey(HKEY hkey, LPCTSTR pszSubKey, DWORD grfMode)
{
    HKEY hkeyNew = 0;
    long i;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];

    SHTCharToAnsi(pszSubKey, szSubKey, ARRAYSIZE(szSubKey));
    ASSERT(grfMode == STGM_READ || grfMode == STGM_WRITE);

    ASSERT(pszSubKey != NULL);
    if (pszSubKey != NULL) {
        if (grfMode == STGM_READ) {
            i = RegOpenKeyA(hkey, szSubKey, &hkeyNew);
        }
        else {
            i = RegCreateKeyA(hkey, szSubKey, &hkeyNew);
        }
        // the following ASSERT is not req'd but is currently always true.
        // if you hit it, the bug is someplace in the caller.
        // i.e. do *not* remove this ASSERT to 'fix' your pblm.
        // a typical cause of failure is that CoCreateInst is failing because
        // something isn't properly regsvr32'ed.
        ASSERT(i == ERROR_SUCCESS || hkeyNew == 0);
    }

    return hkeyNew;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\shmenu.cpp ===
/*++

  shmenu.cpp

  this is for IShellMenu and related stuff.  eventually all
  of the fsmenu.c functionality should be in here

--*/




class CFMDropTarget : public IDropTarget 
{
public:

    CFMDropTarget();
    ~CFMDropTarget();

    HRESULT Init (
        HWND hwnd, 
        IShellFolder *psf, 
        LPITEMIDLIST pidl,
        DWORD dwFlags);

    // IUnknown methods

    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP DragEnter(
        IDataObject *pdata,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->DragEnter(pdata, grfKeyState, pt, pdwEffect);}
    
    STDMETHODIMP DragOver( 
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->DragOver(grfKeyState, pt, pdwEffect);}
    
    STDMETHODIMP DragLeave( void)
    {return _pdrop->DragLeave();}
    
    STDMETHODIMP  Drop( 
        IDataObject *pDataObj,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->Drop(pDataObj, grfKeyState, pt, pdwEffect);}

private:

    ULONG _cRef;
    IShellFolder *_psf;     //  the psf to use...
    LPITEMIDLIST _pidl;
    DWORD _dwFlags;
    IDropTarget *_pdrop;      //  the actual droptarget


}

CFMDropTarget :: CFMDropTarget ()
{
    _cRef = 1;
    DllAddRef();
}

CFMDropTarget :: ~CFMDropTarget ()
{
    SAFERELEASE(_psf);
    if(pidl)
        ILFree(pidl);
    SAFERELEASE(_pdrop);
    DllRelease();
}

HRESULT
CFMDropTarget :: QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IDropTarget*);
        hr = S_OK;

    }

    return hr;
}


ULONG
CFMDropTarget :: AddRef(void)
{

    _cRef++;

    return _cRef;

}

ULONG
CFMDropTarget :: Release(void)
{
    ASSERT (_cRef > 0);

    cRef--;

    if (!cRef)
    {
        //time to go bye bye
        delete this;
        return 0;
    }

    return cRef;

}

// BUGBUGZEKEL we are just using the psf here...we need to support more
HRESULT Init (
        HWND hwnd, 
        IShellFolder *psf, 
        LPITEMIDLIST pidl,
        DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if(psf)
        hr = psf->QueryInterface(IID_IShellFolder, (LPVOID *) &_psf);

    _pidl = ILClone(pidl);
    _dwFlags = dwFlags;

    if(SUCCEEDED(hr) && _psf && _pidl)
    {
        hr = _psf->CreateViewObject(hwnd, IID_IDropTarget, (LPVOID*) &_pdrop);
    }

    return hr;
}

//BUGBUGZEKEL right now this doesnt support ordering, and assumes that you 
//want to drop right onto the current menu.  this is just a start.
//pidl and dwFlags are just dummy params
HRESULT
CFMDropTarget_CreateAndInit(
                            HWND hwnd, 
                            IShellFolder *psf, 
                            LPITEMIDLIST pidl,
                            DWORD dwFlags,
                            LPVOID *ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFMDropTarget *pdt;

    ASSERT(ppvObj)
    if(ppvObj)
        *ppvObj = NULL;
    else
        return E_INVALIDARG;


    pdt = new CFMDropTargetNULL;

    if (pdt)
    {
        hr = pdt->Init(hwnd, psf, pidl, dwFlags);

        if (SUCCEEDED(hr))
            *ppvObj= SAFECAST(pdt, IDropTarget * );
        else
            pdt->Release();
    }
    
    return hr;
}

    if (psf)
    {


        hr = psf->QueryInterface(IID_IShellFolder, (LPVOID *) &psfMine);

        if(SUCCEEDED(hr) && psfMine)
        {


    }


#if 0  // BUGBUGZEKEL
    {
        if(pmgoi->dwFlags & (MNGO_TOPGAP | MNGO_BOTTOMGAP))
        {
            //then we need to use the current psf as the droptarget
            // and the pidl is just a marker
        }
        else
        {
            //  we need to use the pidl's psf as the droptarget if possible
                DWORD dwAttr = SFGAO_DROPTARGET;
                hr = psf->lpVtbl->GetAttributesOf(1, (LPCITEMIDLIST*)&pfmi->pidl, &dwAttr);
                if (SUCCEEDED(hres) && (dwAttr & SFGAO_DROPTARGET))
                {
                    hr = psf->lpVtbl->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pfmi->pidl,
                                              IID_IDropTarget, NULL, (LPVOID*)&_pdropgtCur);
                }
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\stream.h ===
//***   stream.h --
//
// NOTES
//  BUGBUG this inheritance is *backwards*! should have:
//      CRegStrPropBag : CRegStrFS, IPropertyBag
// fix this soon i hope...

class CRegStrPropBag : public IPropertyBag
{
public:
    //*** IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    //*** IPropertyBag
    virtual STDMETHODIMP Read(/*[in]*/ LPCOLESTR pwzPropName,
        /*[inout]*/ VARIANT *pVar, /*[in]*/ IErrorLog *pErrorLog);
    // currently unused (see #if 0 in stream.cpp)
    virtual STDMETHODIMP Write(/*[in]*/ LPCOLESTR pwzPropName,
        /*[in]*/ VARIANT *pVar) { ASSERT(0); return E_NOTIMPL; };

    //*** THISCLASS
    virtual HRESULT Initialize(HKEY hkey, DWORD grfMode);
    HRESULT SetRoot(HKEY hkey, DWORD grfMode);
    HRESULT ChDir(LPCTSTR pszSubKey);
    // fast versions, no OLESTR nonsense
    HRESULT QueryValueStr(LPCTSTR pszName, LPTSTR pszValue, LPDWORD pcbValue);
    HRESULT SetValueStr(LPCTSTR pszName, LPCTSTR pszValue);
    HRESULT SetValueStrEx(LPCTSTR pszName, DWORD dwType, LPCTSTR pszValue);

protected:
    CRegStrPropBag() { _cRef = 1; };
    virtual ~CRegStrPropBag();

    friend CRegStrPropBag *CRegStrPropBag_Create(HKEY hkey, DWORD grfMode);

    int     _cRef;
    HKEY    _hkey;
    int     _grfMode;   // read/write (subset of STGM_* values)
};

HRESULT IPBag_ReadStr(IPropertyBag *pPBag, LPCOLESTR pwzPropName, LPTSTR buf, int cch);
#if 0 // currently unused (see #if 0 in stream.cpp)
HRESULT IPBag_WriteStr(IPropertyBag *pPBag, LPCOLESTR pwzPropName, LPTSTR buf);
#endif
HKEY Reg_CreateOpenKey(HKEY hkey, LPCTSTR pszSubKey, DWORD grfMode);
HKEY Reg_DupKey(HKEY hkey);

class CRegStrFS : public CRegStrPropBag
{
public:
    /*virtual HRESULT Initialize(HKEY hk, DWORD grfMode);*/
    HRESULT QueryValue(LPCTSTR pszName, BYTE *pbData, LPDWORD pcbData);
    HRESULT SetValue(LPCTSTR pszName, DWORD dwType, const BYTE *pbData, DWORD cbData);
    HRESULT DeleteValue(LPCTSTR pszName);
    HRESULT RmDir(LPCTSTR pszName, BOOL fRecurse);

    HKEY GetHkey()  { return _hkey; }

protected:
    friend CRegStrFS *CRegStrFS_Create(HKEY hk, DWORD grfMode);

#if 0
    HKEY _hkeyRoot;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\util.cpp ===
#include "proj.h"
#include <idhidden.h>
#include <regitemp.h>
#include <shstr.h>
#include <shlobjp.h>

// Alpha platform doesn't need unicode thunks, seems like this
// should happen automatically in the headerfiles...
//
#if defined(_X86_) || defined(UNIX)
#else
#define NO_W95WRAPS_UNITHUNK
#endif

#include "wininet.h"
#include "w95wraps.h"

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//


// pbIsNamed is true if the i-th item in hm is a named separator
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed)
{
    MENUITEMINFO mii;
    BOOL         bLocal;

    if (!pbIsNamed)
        pbIsNamed = &bLocal;
        
    *pbIsNamed = FALSE;

    mii.cbSize = SIZEOF(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.cch = 0;    // WARNING: We MUST initialize it to 0!!!
    if (!GetMenuItemInfo(hm, i, TRUE, &mii))
    {
        return(FALSE);
    }

    if (mii.fType & MFT_SEPARATOR)
    {
        // NOTE that there is a bug in either 95 or NT user!!!
        // 95 returns 16 bit ID's and NT 32 bit therefore there is a
        // the following may fail, on win9x, to evaluate to false
        // without casting
        *pbIsNamed = ((WORD)mii.wID != (WORD)-1);
        return(TRUE);
    }

    return(FALSE);
}

STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i)
{
    return _SHIsMenuSeparator2(hm, i, NULL);
}

//
// _SHPrettyMenu -- make this menu look darn purty
//
// Prune the separators in this hmenu to ensure there isn't one in the first or last
// position and there aren't any runs of >1 separator.
//
// Named separators take precedence over regular separators.
//
STDAPI_(void) _SHPrettyMenu(HMENU hm)
{
    BOOL bSeparated = TRUE;
    BOOL bIsNamed;
    BOOL bWasNamed = TRUE;
    int i;

    for (i = GetMenuItemCount(hm) - 1; i > 0; --i)
    {
        if (_SHIsMenuSeparator2(hm, i, &bIsNamed))
        {
            if (bSeparated)
            {
                // if we have two separators in a row, only one of which is named
                // remove the non named one!
                if (bIsNamed && !bWasNamed)
                {
                    DeleteMenu(hm, i+1, MF_BYPOSITION);
                    bWasNamed = bIsNamed;
                }
                else
                {
                    DeleteMenu(hm, i, MF_BYPOSITION);
                }
            }
            else
            {
                bWasNamed = bIsNamed;
                bSeparated = TRUE;
            }
        }
        else
        {
            bSeparated = FALSE;
        }
    }

    // The above loop does not handle the case of many separators at
    // the beginning of the menu
    while (_SHIsMenuSeparator2(hm, 0, NULL))
    {
        DeleteMenu(hm, 0, MF_BYPOSITION);
    }
}

STDAPI_(DWORD) SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i)
{
    ASSERT(IsWindow(hwnd));
    ASSERT(i < SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0));

    DWORD dwEdge = 0;

    RECT rc, rcInt;
    SendMessage(hwnd, TB_GETITEMRECT, i, (LPARAM)&rc);

    if (!IntersectRect(&rcInt, prc, &rc))
    {
        dwEdge = EDGE_LEFT | EDGE_RIGHT | EDGE_TOP | EDGE_BOTTOM;
    }
    else
    {
        if (rc.top != rcInt.top)
            dwEdge |= EDGE_TOP;

        if (rc.bottom != rcInt.bottom)
            dwEdge |= EDGE_BOTTOM;

        if (rc.left != rcInt.left)
            dwEdge |= EDGE_LEFT;

        if (rc.right != rcInt.right)
            dwEdge |= EDGE_RIGHT;
    }

    return dwEdge;
}

STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState)
{
    if (dwRest == RESTOPT_BTN_STATE_VISIBLE)
        return (fsState & ~TBSTATE_HIDDEN);
    else if (dwRest == RESTOPT_BTN_STATE_HIDDEN)
        return (fsState | TBSTATE_HIDDEN);
    else {
#ifdef DEBUG
        if (dwRest != RESTOPT_BTN_STATE_DEFAULT)
            TraceMsg(TF_ERROR, "bad toolbar button state policy %x", dwRest);
#endif
        return fsState;
    }
}

//
// SHIsDisplayable
//
// Figure out if this unicode string can be displayed by the system
// (i.e., won't be turned into a string of question marks).
//
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5)
{
    BOOL fNotDisplayable = FALSE;

    if (pwszName)
    {
        if (!fRunOnNT5)
        {
            // if WCtoMB has to use default characters in mapping pwszName to multibyte,
            // it sets fNotDisplayable == TRUE, in which case we have to use something
            // else for the title string.
            WideCharToMultiByte(CP_ACP, 0, pwszName, -1, NULL, 0, NULL, &fNotDisplayable);
            if (fNotDisplayable)
            {
                if (fRunOnFE)
                {
                    WCHAR wzName[INTERNET_MAX_URL_LENGTH];

                    BOOL fReplaceNbsp = FALSE;

                    StrCpyNW(wzName, pwszName, ARRAYSIZE(wzName));
                    for (int i = 0; i < ARRAYSIZE(wzName); i++)
                    {
                        if (0x00A0 == wzName[i])    // if &nbsp
                        {
                            wzName[i] = 0x0020;     // replace to space
                            fReplaceNbsp = TRUE;
                        }
                        else if (0 == wzName[i])
                            break;
                    }
                    if (fReplaceNbsp)
                    {
                        pwszName = wzName;
                        WideCharToMultiByte(CP_ACP, 0, pwszName, -1, NULL, 0, NULL, &fNotDisplayable);
                    }
                }
            }
        }
    }

    return !fNotDisplayable;
}

// Trident will take URLs that don't indicate their source of
// origin (about:, javascript:, & vbscript:) and will append
// an URL turd and then the source URL.  The turd will indicate
// where the source URL begins and that source URL is needed
// when the action needs to be Zone Checked.
//
// This function will remove that URL turd and everything behind
// it so the URL is presentable for the user.

#define URL_TURD        ((TCHAR)0x01)

STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl)
{
    if (!pszUrl)
        return;

    while (TEXT('\0') != pszUrl[0])
    {
        if (URL_TURD == pszUrl[0])
        {
            pszUrl[0] = TEXT('\0');
            break;
        }

        pszUrl = CharNext(pszUrl);
    }
}

STDAPI_(BOOL) SetWindowZorder(HWND hwnd, HWND hwndInsertAfter)
{
    return SetWindowPos(hwnd, hwndInsertAfter, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
}

BOOL CALLBACK _FixZorderEnumProc(HWND hwnd, LPARAM lParam)
{
    HWND hwndTest = (HWND)lParam;
    HWND hwndOwner = hwnd;

    while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
    {
        if (hwndOwner == hwndTest)
        {
            TraceMsg(TF_WARNING, "_FixZorderEnumProc: Found topmost window %x owned by non-topmost window %x, fixing...", hwnd, hwndTest);
            SetWindowZorder(hwnd, HWND_NOTOPMOST);
#ifdef DEBUG
            if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
                TraceMsg(TF_ERROR, "_FixZorderEnumProc: window %x is still topmost", hwnd);
#endif
            break;
        }
    }

    return TRUE;
}

STDAPI_(BOOL) SHForceWindowZorder(HWND hwnd, HWND hwndInsertAfter)
{
    BOOL fRet = SetWindowZorder(hwnd, hwndInsertAfter);

    if (fRet && hwndInsertAfter == HWND_TOPMOST)
    {
        if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST))
        {
            //
            // Dammit, user didn't actually move the hwnd to topmost
            //
            // According to GerardoB, this can happen if the window has
            // an owned window that somehow has become topmost while the 
            // owner remains non-topmost, i.e., the two have become
            // separated in the z-order.  In this state, when the owner
            // window tries to make itself topmost, the call will
            // silently fail.
            //
            // TERRIBLE HORRIBLE NO GOOD VERY BAD HACK
            //
            // Hacky fix is to enumerate the toplevel windows, check to see
            // if any are topmost and owned by hwnd, and if so, make them
            // non-topmost.  Then, retry the SetWindowPos call.
            //

            TraceMsg(TF_WARNING, "SHForceWindowZorder: SetWindowPos(%x, HWND_TOPMOST) failed", hwnd);

            // Fix up the z-order
            EnumWindows(_FixZorderEnumProc, (LPARAM)hwnd);

            // Retry the set.  (This should make all owned windows topmost as well.)
            SetWindowZorder(hwnd, HWND_TOPMOST);

#ifdef DEBUG
            if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST))
                TraceMsg(TF_ERROR, "SHForceWindowZorder: window %x is still not topmost", hwnd);
#endif
        }
    }

    return fRet;
}

STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl)
{   
    LPITEMIDLIST pidlParent = ILClone(pidl);
    if (pidlParent)
        ILRemoveLastID(pidlParent);

    return pidlParent;
}

// in:
//      psf     OPTIONAL, if NULL assume psfDesktop
//      pidl    to bind to from psfParent
//

STDAPI SHBindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut)
{
    HRESULT hr;
    IShellFolder *psfRelease;

    if (!psf)
    {
        SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }
    else
    {
        psfRelease = NULL;
    }

    if (!pidl || ILIsEmpty(pidl))
    {
        hr = psf->QueryInterface(riid, ppvOut);
    }
    else
    {
        hr = psf->BindToObject(pidl, NULL, riid, ppvOut);
    }

    if (psfRelease)
    {
        psfRelease->Release();
    }

    if (SUCCEEDED(hr) && (*ppvOut == NULL))
    {
        // Some lame shell extensions (eg WS_FTP) will return success and a null out pointer
        TraceMsg(TF_WARNING, "SHBindToObject: BindToObject succeeded but returned null ppvOut!!");
        hr = E_FAIL;
    }

    return hr;
}

// psfRoot is the base of the bind.  If NULL, then we use the shell desktop.
// If you want to bind relative to the explorer root (e.g., CabView, MSN),
// then use SHBindToIDListParent.
STDAPI SHBindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hres;

    ASSERT(!ILIsRooted(pidl));
    
    // Old shell32 code in some cases simply whacked the pidl,
    // but this is unsafe.  Do what shdocvw does and clone/remove:
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent) 
    {
        hres = SHBindToObject(psfRoot, riid, pidlParent, ppv);
        ILFree(pidlParent);
    }
    else
        hres = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hres;
}

//
//  Warning!  brutil.cpp overrides this function
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    return SHBindToFolderIDListParent(NULL, pidl, riid, ppv, ppidlLast);
}



STDAPI SHGetIDListFromUnk(IUnknown *punk, LPITEMIDLIST *ppidl)
{
    HRESULT hres = E_NOINTERFACE;

    *ppidl = NULL;

    IPersistFolder2 *ppf;
    if (punk && SUCCEEDED(punk->QueryInterface(IID_IPersistFolder2, (void **)&ppf)))
    {
        hres = ppf->GetCurFolder(ppidl);
        ppf->Release();
    }
    return hres;
}

//
//  _ILResize isnt exported from shell32 so we make a cheap one that
//  do any preallocating
//
STDAPI_(LPITEMIDLIST) _MyILResize(LPITEMIDLIST pidl, UINT cbRequired)
{
    RIP(pidl);
    LPITEMIDLIST pidlNew = (LPITEMIDLIST)SHAlloc(cbRequired);
    if (pidlNew)
        MoveMemory(pidlNew, pidl, ILGetSize(pidl));

    SHFree(pidl);
    return pidlNew;
}

//  the last word of the pidl is where we store the hidden offset
#define _ILHiddenOffset(pidl)   (*((WORD UNALIGNED *)(((BYTE *)_ILNext(pidl)) - SIZEOF(WORD))))
#define _ILSetHiddenOffset(pidl, cb)   ((*((WORD UNALIGNED *)(((BYTE *)_ILNext(pidl)) - SIZEOF(WORD)))) = (WORD)cb)
#define _ILIsHidden(pidhid)     (HIWORD(pidhid->id) == HIWORD(IDLHID_EMPTY))

STDAPI_(PCIDHIDDEN) _ILNextHidden(PCIDHIDDEN pidhid, LPCITEMIDLIST pidlLimit)
{
    PCIDHIDDEN pidhidNext = (PCIDHIDDEN) _ILNext((LPCITEMIDLIST)pidhid);

    if ((BYTE *)pidhidNext < (BYTE *)pidlLimit && _ILIsHidden(pidhidNext))
    {
        return pidhidNext;
    }

    //  if we ever go past the limit,
    //  then this is not really a hidden id
    //  or we have screwed up on some calculation.
    ASSERT((BYTE *)pidhidNext == (BYTE *)pidlLimit);
    return NULL;
}

STDAPI_(PCIDHIDDEN) _ILFirstHidden(LPCITEMIDLIST pidl)
{
    WORD cbHidden = _ILHiddenOffset(pidl);

    if (cbHidden && cbHidden + SIZEOF(HIDDENITEMID) < pidl->mkid.cb)
    {
        //  this means it points to someplace inside the pidl
        //  maybe this has hidden ids
        PCIDHIDDEN pidhid = (PCIDHIDDEN) (((BYTE *)pidl) + cbHidden);

        if (_ILIsHidden(pidhid)
        && (pidhid->cb + cbHidden <= pidl->mkid.cb))
        {
            //  this is more than likely a hidden id
            //  we could walk the chain and verify
            //  that it adds up right...
            return pidhid;
        }
    }

    return NULL;
}
    
//
//  HIDDEN ids are sneakily hidden in the last ID in a pidl.
//  we append our data without changing the existing pidl,
//  (except it is now bigger)  this works because the pidls
//  that we will apply this to are flexible in handling different
//  sized pidls.  specifically this is used in FS pidls.
// 
//  WARNING - it is the callers responsibility to use hidden IDs
//  only on pidls that can handle it.  most shell pidls, and 
//  specifically FS pidls have no problem with this.  however
//  some shell extensions might have fixed length ids, 
//  which makes these unadvisable to append to everything.
//  possibly add an SFGAO_ bit to allow hidden, otherwise key
//  off FILESYSTEM bit.
//

STDAPI_(LPITEMIDLIST) ILAppendHiddenID(LPITEMIDLIST pidl, PCIDHIDDEN pidhid)
{
    //
    // BUGBUG - we dont handle collisions of multiple hidden ids
    //          maybe remove IDs of the same IDLHID?
    //
    // BUGBUG - we dont collapse IDLHID_EMPTY
    //          we should probably see about reusing IDLHID_EMPTY ids
    //
    
    //  we require a pidl to attach the hidden id to
    RIP(pidl);
    if (!ILIsEmpty(pidl))
    {
        UINT cbUsed = ILGetSize(pidl);
        UINT cbRequired = cbUsed + pidhid->cb + SIZEOF(pidhid->cb);

        pidl = _MyILResize(pidl, cbRequired);
        
        if (pidl)
        {
            LPITEMIDLIST pidlLast = ILFindLastID(pidl);
            WORD cbHidden = _ILFirstHidden(pidlLast) ? _ILHiddenOffset(pidlLast) : pidlLast->mkid.cb;
            PIDHIDDEN pidhidCopy = (PIDHIDDEN)_ILSkip(pidl, cbUsed - SIZEOF(pidl->mkid.cb));

            // Append it, overwriting the terminator
            MoveMemory(pidhidCopy, pidhid, pidhid->cb);

            //  grow the copy to allow the hidden offset.
            pidhidCopy->cb += SIZEOF(pidhid->cb);

            //  now we need to readjust pidlLast to encompass 
            //  the hidden bits and the hidden offset.
            pidlLast->mkid.cb += pidhidCopy->cb;

            //  set the hidden offset so that we can find our hidden IDs later
            _ILSetHiddenOffset((LPITEMIDLIST)pidhidCopy, cbHidden);

            // We must put zero-terminator because of LMEM_ZEROINIT.
            _ILSkip(pidl, cbRequired-SIZEOF(pidl->mkid.cb))->mkid.cb = 0;
            ASSERT(ILGetSize(pidl) == cbRequired);
        }
    }
    return pidl;
}

STDAPI_(PCIDHIDDEN) ILFindHiddenID(LPCITEMIDLIST pidl, IDLHID id)
{
    RIP(pidl);
    if (!ILIsEmpty(pidl))
    {
        pidl = ILFindLastID(pidl);
        
        PCIDHIDDEN pidhid = _ILFirstHidden(pidl);

        //  reuse pidl to become the limit.
        //  so that we cant ever walk out of 
        //  the pidl.
        pidl = _ILNext(pidl);

        while (pidhid)
        {
            if (pidhid->id == id)
                break;

            pidhid = _ILNextHidden(pidhid, pidl);
        }
        return pidhid;
    }

    return NULL;
}

STDAPI_(BOOL) ILRemoveHiddenID(LPITEMIDLIST pidl, IDLHID id)
{
    PIDHIDDEN pidhid = (PIDHIDDEN)ILFindHiddenID(pidl, id);

    if (pidhid)
    {
        pidhid->id = IDLHID_EMPTY;
        return TRUE;
    }
    return FALSE;
}

//
//  generically useful to hide.
//
typedef struct _HIDDENCLSID
{
    WORD    cb;
    IDLHID  id;
    CLSID   clsid;
} HIDDENCLSID;

typedef UNALIGNED HIDDENCLSID *PHIDDENCLSID;
typedef const UNALIGNED HIDDENCLSID *PCHIDDENCLSID;

STDAPI_(LPITEMIDLIST) ILAppendHiddenClsid(LPITEMIDLIST pidl, IDLHID id, CLSID *pclsid)
{
    HIDDENCLSID hc = {SIZEOF(hc), id};
    hc.clsid = *pclsid;

    return ILAppendHiddenID(pidl, (PIDHIDDEN)&hc);
}

STDAPI_(BOOL) ILGetHiddenClsid(LPCITEMIDLIST pidl, IDLHID id, CLSID *pclsid)
{
    PCHIDDENCLSID phc = (PCHIDDENCLSID) ILFindHiddenID(pidl, id);

    if (phc)
    {
        *pclsid = phc->clsid;
        return TRUE;
    }
    return FALSE;
}


typedef struct _HIDDENSTRINGA
{
    WORD    cb;
    IDLHID  id;
    WORD    type;
    CHAR    sz[1];   //  variable length string
} HIDDENSTRINGA;

typedef UNALIGNED HIDDENSTRINGA *PHIDDENSTRINGA;
typedef const UNALIGNED HIDDENSTRINGA *PCHIDDENSTRINGA;

typedef struct _HIDDENSTRINGW
{
    WORD    cb;
    IDLHID  id;
    WORD    type;
    WCHAR   sz[1];   //  canonical name to be passed to ISTRING
} HIDDENSTRINGW;

typedef UNALIGNED HIDDENSTRINGW *PHIDDENSTRINGW;
typedef const UNALIGNED HIDDENSTRINGW *PCHIDDENSTRINGW;

#define HIDSTRTYPE_ANSI        0x0001
#define HIDSTRTYPE_WIDE        0x0002

STDAPI_(LPITEMIDLIST) ILAppendHiddenStringW(LPITEMIDLIST pidl, IDLHID id, LPCWSTR psz)
{
    //  terminator is included in the ID definition
    USHORT cb = (USHORT)SIZEOF(HIDDENSTRINGW) + CbFromCchW(lstrlenW(psz));
    
    PHIDDENSTRINGW phs = (PHIDDENSTRINGW) LocalAlloc(LPTR, cb);

    if (phs)
    {
        phs->cb = cb;
        phs->id = id;
        phs->type = HIDSTRTYPE_WIDE;
        StrCpyW(phs->sz, psz);

        pidl = ILAppendHiddenID(pidl, (PIDHIDDEN)phs);
        LocalFree(phs);
        return pidl;
    }
    return NULL;
}
    
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringA(LPITEMIDLIST pidl, IDLHID id, LPCSTR psz)
{
    //  terminator is included in the ID definition
    USHORT cb = (USHORT)SIZEOF(HIDDENSTRINGA) + CbFromCchA(lstrlenA(psz));
    
    PHIDDENSTRINGA phs = (PHIDDENSTRINGA) LocalAlloc(LPTR, cb);

    if (phs)
    {
        phs->cb = cb;
        phs->id = id;
        phs->type = HIDSTRTYPE_ANSI;
        StrCpyA(phs->sz, psz);

        pidl = ILAppendHiddenID(pidl, (PIDHIDDEN)phs);
        LocalFree(phs);
        return pidl;
    }
    return NULL;
}

STDAPI_(void *) _MemDupe(const UNALIGNED void *pv, DWORD cb)
{
    void *pvRet = LocalAlloc(LPTR, cb);
    if (pvRet)
    {
        CopyMemory(pvRet, pv, cb);
    }

    return pvRet;
}

STDAPI_(BOOL) ILGetHiddenStringW(LPCITEMIDLIST pidl, IDLHID id, LPWSTR psz, DWORD cch)
{
    PCHIDDENSTRINGW phs = (PCHIDDENSTRINGW) ILFindHiddenID(pidl, id);

    RIP(psz);
    if (phs)
    {
        if (phs->type == HIDSTRTYPE_WIDE)
        {
            ualstrcpynW(psz, phs->sz, cch);
            return TRUE;
        }
        else 
        {
            ASSERT(phs->type == HIDSTRTYPE_ANSI);
            SHAnsiToUnicode((LPSTR)phs->sz, psz, cch);
            return TRUE;
        }
    }
    return FALSE;
}
        
STDAPI_(BOOL) ILGetHiddenStringA(LPCITEMIDLIST pidl, IDLHID id, LPSTR psz, DWORD cch)
{
    PCHIDDENSTRINGW phs = (PCHIDDENSTRINGW) ILFindHiddenID(pidl, id);

    RIP(psz);
    if (phs)
    {
        if (phs->type == HIDSTRTYPE_ANSI)
        {
            ualstrcpynA(psz, (LPSTR)phs->sz, cch);
            return TRUE;
        }
        else 
        {
            ASSERT(phs->type == HIDSTRTYPE_WIDE);
            //  we need to handle the unalignment here...
            LPWSTR pszT = (LPWSTR) _MemDupe(phs->sz, CbFromCch(lstrlenW(phs->sz) +1));

            if (pszT)
            {
                SHUnicodeToAnsi(pszT, psz, cch);
                LocalFree(pszT);
                return TRUE;
            }
        }
    }
    return FALSE;
}

STDAPI_(int) ILCompareHiddenString(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, IDLHID id)
{

    // if there are fragments in here, then they might
    // differentiate the two pidls
    PCHIDDENSTRINGW ps1 = (PCHIDDENSTRINGW)ILFindHiddenID(pidl1, id);
    PCHIDDENSTRINGW ps2 = (PCHIDDENSTRINGW)ILFindHiddenID(pidl2, id);

    if (ps1 && ps2)
    {
        if (ps1->type == ps2->type)
        {
            if (ps1->type == HIDSTRTYPE_WIDE)
                return ualstrcmpW(ps1->sz, ps2->sz);

            ASSERT(ps1->type == HIDSTRTYPE_ANSI);

            return lstrcmpA((LPCSTR)ps1->sz, (LPCSTR)ps2->sz);
        }
        else
        {
            SHSTRW str;

            if (ps1->type == HIDSTRTYPE_ANSI)
            {
                str.SetStr((LPCSTR)ps1->sz);
                return ualstrcmpW(str, ps2->sz);
            }
            else
            {
                ASSERT(ps2->type == HIDSTRTYPE_ANSI);
                str.SetStr((LPCSTR)ps2->sz);
                return ualstrcmpW(ps1->sz, str);
            }
        }
    }

    if (ps1)
        return 1;
    if (ps2)
        return -1;
    return 0;
}

// {9EAC43C0-53EC-11CE-8230-CA8A32CF5494}
//static const GUID GUID_WINAMP = 
//{ 0x9eac43c0, 0x53ec, 0x11ce, { 0x82, 0x30, 0xca, 0x8a, 0x32, 0xcf, 0x54, 0x94} };

// {E9779583-939D-11CE-8A77-444553540000}
static const GUID GUID_AECOZIPARCHIVE = 
{ 0xE9779583, 0x939D, 0x11ce, { 0x8a, 0x77, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };
// {49707377-6974-6368-2E4A-756E6F644A01}
static const GUID CLSID_WS_FTP_PRO_EXPLORER =
{ 0x49707377, 0x6974, 0x6368, {0x2E, 0x4A,0x75, 0x6E, 0x6F, 0x64, 0x4A, 0x01} };
// {49707377-6974-6368-2E4A-756E6F644A0A}
static const GUID CLSID_WS_FTP_PRO =
{ 0x49707377, 0x6974, 0x6368, {0x2E, 0x4A,0x75, 0x6E, 0x6F, 0x64, 0x4A, 0x0A} };
// {2bbbb600-3f0a-11d1-8aeb-00c04fd28d85}
static const GUID CLSID_KODAK_DC260_ZOOM_CAMERA =
{ 0x2bbbb600, 0x3f0a, 0x11d1, {0x8a, 0xeb, 0x00, 0xc0, 0x4f, 0xd2, 0x8d, 0x85} };
// {00F43EE0-EB46-11D1-8443-444553540000}
static const GUID GUID_MACINDOS =
{ 0x00F43EE0, 0xEB46, 0x11D1, { 0x84, 0x43, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };
static const GUID CLSID_EasyZIP = 
{ 0xD1069700, 0x932E, 0x11cf, { 0xAB, 0x59, 0x00, 0x60, 0x8C, 0xBF, 0x2C, 0xE0} };

static const GUID CLSID_PAGISPRO_FOLDER =
{ 0x7877C8E0, 0x8B13, 0x11D0, { 0x92, 0xC2, 0x00, 0xAA, 0x00, 0x4B, 0x25, 0x6F} };
// {61E285C0-DCF4-11cf-9FF4-444553540000}
static const GUID CLSID_FILENET_IDMDS_NEIGHBORHOOD =
{ 0x61e285c0, 0xdcf4, 0x11cf, { 0x9f, 0xf4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

static const GUID CLSID_PGP50_CONTEXTMENU =  //{969223C0-26AA-11D0-90EE-444553540000}
{ 0x969223C0, 0x26AA, 0x11D0, { 0x90, 0xEE, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} };

static const GUID CLSID_QUICKFINDER_CONTEXTMENU = //  {CD949A20-BDC8-11CE-8919-00608C39D066}
{ 0xCD949A20, 0xBDC8, 0x11CE, { 0x89, 0x19, 0x00, 0x60, 0x8C, 0x39, 0xD0, 0x66} };

static const GUID CLSID_HERCULES_HCTNT_V1001 = // {921BD320-8CB5-11CF-84CF-885835D9DC01}
{ 0x921BD320, 0x8CB5, 0x11CF, { 0x84, 0xCF, 0x88, 0x58, 0x35, 0xD9, 0xDC, 0x01} };

//
// NOTICE - DONT ADD ANYMORE HARDCODED CLSIDS
// add them to the ShellCompatibility key.  register in the client DLL
//

typedef struct {
    DWORD flag;
    LPCTSTR psz;
} FLAGMAP;

DWORD _GetMappedFlags(HKEY hk, const FLAGMAP *pmaps, DWORD cmaps)
{
    DWORD dwRet = 0;
    for (DWORD i = 0; i < cmaps; i++)
    {
        if (NOERROR == SHGetValue(hk, NULL, pmaps[i].psz, NULL, NULL, NULL))
            dwRet |= pmaps[i].flag;
    }

    return dwRet;
}

#define OCFMAPPING(ocf)     {OBJCOMPATF_##ocf, TEXT(#ocf)}

DWORD _GetRegistryCompatFlags(REFGUID clsid)
{
    DWORD dwRet = 0;
    TCHAR szGuid[GUIDSTR_MAX];
    TCHAR sz[MAX_PATH];
    HKEY hk;

    SHStringFromGUID(clsid, szGuid, ARRAYSIZE(szGuid));
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Objects\\%s"), szGuid);
    
    if (NOERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hk))
    {   
        static const FLAGMAP rgOcfMaps[] = {
            OCFMAPPING(OTNEEDSSFCACHE),
            OCFMAPPING(NO_WEBVIEW),
            OCFMAPPING(UNBINDABLE),
            OCFMAPPING(PINDLL),
            OCFMAPPING(NEEDSFILESYSANCESTOR),
            OCFMAPPING(NOTAFILESYSTEM),
            OCFMAPPING(CTXMENU_NOVERBS),
            OCFMAPPING(CTXMENU_LIMITEDQI),
            OCFMAPPING(COCREATESHELLFOLDERONLY),
            };

        dwRet = _GetMappedFlags(hk, rgOcfMaps, ARRAYSIZE(rgOcfMaps));
        RegCloseKey(hk);
    }

    return dwRet;
}

typedef struct _CLSIDCOMPAT
{
    const GUID *pclsid;
    //  LPCTSTR pszVersion;
    OBJCOMPATFLAGS flags;
}CLSIDCOMPAT, *PCLSIDCOMPAT;

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlags(IUnknown *punk, const CLSID *pclsid)
{
    HRESULT hr = E_INVALIDARG;
    OBJCOMPATFLAGS ocf = 0;
    CLSID clsid;
    if (punk)
        hr = IUnknown_GetClassID(punk, &clsid);
    else if (pclsid)
    {
        clsid = *pclsid;
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        static const CLSIDCOMPAT s_rgCompat[] =
        {
            {&CLSID_WS_FTP_PRO_EXPLORER,
                OBJCOMPATF_OTNEEDSSFCACHE},
            {&CLSID_WS_FTP_PRO,
                OBJCOMPATF_UNBINDABLE},
            {&GUID_AECOZIPARCHIVE,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_KODAK_DC260_ZOOM_CAMERA,
                OBJCOMPATF_OTNEEDSSFCACHE | OBJCOMPATF_PINDLL},
            {&GUID_MACINDOS,
                OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_EasyZIP,            
                OBJCOMPATF_NO_WEBVIEW},
            {&CLSID_PAGISPRO_FOLDER,
                OBJCOMPATF_NEEDSFILESYSANCESTOR},
            {&CLSID_FILENET_IDMDS_NEIGHBORHOOD,
                OBJCOMPATF_NOTAFILESYSTEM},
            {&CLSID_PGP50_CONTEXTMENU,
                OBJCOMPATF_CTXMENU_LIMITEDQI},
            {&CLSID_QUICKFINDER_CONTEXTMENU,
                OBJCOMPATF_CTXMENU_NOVERBS},
            {&CLSID_HERCULES_HCTNT_V1001,
                OBJCOMPATF_PINDLL},
            {NULL, 0}
        };

        for (int i = 0; s_rgCompat[i].pclsid; i++)
        {
            if (IsEqualGUID(clsid, *(s_rgCompat[i].pclsid)))
            {
                //  we could check version based
                //  on what is in under HKCR\CLSID\{clsid}
                ocf = s_rgCompat[i].flags;
                break;
            }
        }

        ocf |= _GetRegistryCompatFlags(clsid);

    }

    return ocf;
}

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlagsFromIDList(LPCITEMIDLIST pidl)
{
    OBJCOMPATFLAGS ocf = 0;
    CLSID clsid;

    //  APPCOMPAT: FileNet IDMDS (Panagon)'s shell folder extension returns
    //  E_NOTIMPL for IPersistFolder::GetClassID, so to detect the application,
    //  we have to crack the pidl.  (B#359464: tracysh)

    if (!ILIsEmpty(pidl)
    && pidl->mkid.cb >= SIZEOF(IDREGITEM)
    && pidl->mkid.abID[0] == SHID_ROOT_REGITEM)
    {
        clsid = ((LPCIDLREGITEM)pidl)->idri.clsid;
        ocf = SHGetObjectCompatFlags(NULL, &clsid);
    }

    return ocf;
}

LPCIDREGITEM _IsRooted(LPCITEMIDLIST pidl)
{
    LPCIDREGITEM pidlr = (LPCIDREGITEM)pidl;
    if (!ILIsEmpty(pidl)
    && pidlr->cb > SIZEOF(IDREGITEM)
    && pidlr->bFlags == SHID_ROOTEDREGITEM)
        return pidlr;

    return NULL;
}

STDAPI_(BOOL) ILIsRooted(LPCITEMIDLIST pidl)
{
    return (NULL != _IsRooted(pidl));
}

#define _ROOTEDPIDL(pidlr)      (LPITEMIDLIST)(((LPBYTE)pidlr)+SIZEOF(IDREGITEM))

STDAPI_(LPCITEMIDLIST) ILRootedFindIDList(LPCITEMIDLIST pidl)
{
    LPCIDREGITEM pidlr = _IsRooted(pidl);

    if (pidlr && pidlr->cb > SIZEOF(IDREGITEM))
    {
        //  then we have a rooted IDList in there
        return _ROOTEDPIDL(pidlr);
    }

    return NULL;
}

STDAPI_(BOOL) ILRootedGetClsid(LPCITEMIDLIST pidl, CLSID *pclsid)
{
    LPCIDREGITEM pidlr = _IsRooted(pidl);

    if (pidlr)
    {
        *pclsid = pidlr->clsid;
        return TRUE;
    }

    return FALSE;
}

STDAPI_(LPITEMIDLIST) ILRootedCreateIDList(CLSID *pclsid, LPCITEMIDLIST pidl)
{
    UINT cbPidl = ILGetSize(pidl);
    UINT cbTotal = SIZEOF(IDREGITEM) + cbPidl;

    LPIDREGITEM pidlr = (LPIDREGITEM) SHAlloc(cbTotal + SIZEOF(WORD));

    if (pidlr)
    {
        pidlr->cb = (WORD)cbTotal;

        pidlr->bFlags = SHID_ROOTEDREGITEM;
        pidlr->bOrder = 0;              // Nobody uses this (yet)

        if (pclsid)
            pidlr->clsid = *pclsid;
        else
            pidlr->clsid = CLSID_ShellDesktop;

        MoveMemory(_ROOTEDPIDL(pidlr), pidl, cbPidl);

        //  terminate
        _ILNext((LPITEMIDLIST)pidlr)->mkid.cb = 0;
    }

    return (LPITEMIDLIST) pidlr;
}

int CompareGUID(REFGUID guid1, REFGUID guid2)
{
    TCHAR sz1[GUIDSTR_MAX];
    TCHAR sz2[GUIDSTR_MAX];

    SHStringFromGUIDW(guid1, sz1, SIZECHARS(sz1));
    SHStringFromGUIDW(guid2, sz2, SIZECHARS(sz2));

    return lstrcmp(sz1, sz2);
}

STDAPI_(int) ILRootedCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;
    LPCIDREGITEM pidlr1 = _IsRooted(pidl1);
    LPCIDREGITEM pidlr2 = _IsRooted(pidl2);

    if (pidlr1 && pidlr2)
    {
        CLSID clsid1 = pidlr1->clsid;
        CLSID clsid2 = pidlr2->clsid;

        iRet = CompareGUID(clsid1, clsid2);
        if (0 == iRet)
        {
            if (!ILIsEqual(_ROOTEDPIDL(pidl1), _ROOTEDPIDL(pidl2)))
            {
                IShellFolder *psfDesktop;
                if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
                {
                    HRESULT hr = psfDesktop->CompareIDs(0, pidl1, pidl2);
                    psfDesktop->Release();
                    iRet = ShortFromResult(hr);
                }
            }
        }
    }
    else if (pidlr1)
    {
        iRet = -1;
    }
    else if (pidlr2)
    {
        iRet = 1;
    }
    else
    {
        //  if neither are rootes, then they share the desktop
        //  as the same root...
        iRet = 0;
    }

    return iRet;
}

LPITEMIDLIST ILRootedTranslate(LPCITEMIDLIST pidlRooted, LPCITEMIDLIST pidlTrans)
{
    LPCITEMIDLIST pidlChild = ILFindChild(ILRootedFindIDList(pidlRooted), pidlTrans);

    if (pidlChild)
    {
        LPITEMIDLIST pidlRoot = ILCloneFirst(pidlRooted);

        if (pidlRoot)
        {
            LPITEMIDLIST pidlRet = ILCombine(pidlRoot, pidlChild);
            ILFree(pidlRoot);
            return pidlRet;
        }
    }
    return NULL;
}

#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])
#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])

STDAPI_(LPITEMIDLIST) IDA_ILClone(LPIDA pida, UINT i)
{
    if (i < pida->cidl)
        return ILCombine(HIDA_GetPIDLFolder(pida), HIDA_GetPIDLItem(pida, i));
    return NULL;
}

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText)
{
    BOOL bNonEmpty;
    
    PathRemoveBlanks(pszText);   // REVIEW, should we not remove from the end of
    bNonEmpty = lstrlen(pszText); // Not a BOOL, but okay

    EnableWindow(GetDlgItem(hDlg, IDOK), bNonEmpty);
    if (bNonEmpty)
    {
        SendMessage(hDlg, DM_SETDEFID, IDOK, 0L);
    }
}

STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id)
{
    TCHAR szText[MAX_PATH];

    if (!GetDlgItemText(hDlg, id, szText, ARRAYSIZE(szText)))
    {
        szText[0] = 0;
    }

    EnableOKButtonFromString(hDlg, szText);
}

//
//  C-callable versions of the ATL string conversion functions.
//

STDAPI_(LPWSTR) SHA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

STDAPI_(LPSTR) SHW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

//
//  Helper functions for SHChangeMenuAsIDList
//
//  See comment in declaration of SHChangeMenuAsIDList for caveats about
//  the pSender member.
//
//  This is tricky because IE 5.0 shipped with a Win64-unfriendly version
//  of this notification, so we have to sniff the structure and see if
//  this is an IE 5.0 style notification or a new Win64 style notification.
//  If an IE 5.0 style notification, then it was not sent by us because
//  we send the new Win64-style notification.
//
STDAPI_(BOOL) SHChangeMenuWasSentByMe(LPVOID self, LPCITEMIDLIST pidlNotify)
{
    SHChangeMenuAsIDList UNALIGNED * pcmidl = (SHChangeMenuAsIDList UNALIGNED *)pidlNotify;
    return pcmidl->cb >= FIELD_OFFSET(SHChangeMenuAsIDList, cbZero) &&
           pcmidl->pSender == (INT64)self &&
           pcmidl->dwProcessID == GetCurrentProcessId();
}

//
//
//  Send out an extended event changenotify, using a SHChangeMenuAsIDList
//  as the pidl1 so recipients can identify whether they were the
//  sender or not.
//
//  It's okay to pass self==NULL here.  It means you don't care about
//  detecting whether it was sent by you or not.
//

STDAPI_(void) SHSendChangeMenuNotify(LPVOID self, DWORD shcnee, DWORD shcnf, LPCITEMIDLIST pidl2)
{
    SHChangeMenuAsIDList cmidl;

    cmidl.cb          = FIELD_OFFSET(SHChangeMenuAsIDList, cbZero);
    cmidl.dwItem1     = shcnee;
    cmidl.pSender     = (INT64)self;
    cmidl.dwProcessID = self ? GetCurrentProcessId() : 0;
    cmidl.cbZero      = 0;

    // Nobody had better have specified a type; the type must be
    // SHCNF_IDLIST.
    ASSERT((shcnf & SHCNF_TYPE) == 0);
    SHChangeNotify(SHCNE_EXTENDED_EVENT, shcnf | SHCNF_IDLIST, (LPCITEMIDLIST)&cmidl, pidl2);
}


//Return FALSE if out of memory
STDAPI_(BOOL) Pidl_Set(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl)
{
    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    ASSERT(NULL == *ppidl || IS_VALID_PIDL(*ppidl));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (*ppidl) {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    if (pidl)
        *ppidl = ILClone(pidl);

    return (NULL == pidl || NULL != *ppidl);
}

//  this needs to be the last thing in the file that uses ILClone, because everywhere
//  else, ILClone becomes SafeILClone
#undef ILClone

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl)
{
    //  the shell32 implementation of ILClone is different for win95 an ie4.
    //  it doesnt check for NULL in the old version, but it does in the new...
    //  so we need to always check
   return pidl ? ILClone(pidl) : NULL;
}

//
// retrieves the UIObject interface for the specified full pidl.
//
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf->GetUIObjectOf(hwnd, 1, &pidlChild, riid, NULL, ppv);
        psf->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\valid.c ===
//
//  Validation code
//

#include "proj.h"
#pragma  hdrstop

//
//  Validations
//

// Hack: size of the internal data structures, as defined in comctl32\da.c.
// We measure this by the number of DWORD-sized fields.
#ifdef DEBUG
#define CB_DSA      (6 * sizeof(DWORD))
#define CB_DPA      (6 * sizeof(DWORD))
#else
#define CB_DSA      (5 * sizeof(DWORD))
#define CB_DPA      (5 * sizeof(DWORD))
#endif

BOOL
IsValidHDSA(
    HDSA hdsa)
{
    return (IS_VALID_WRITE_BUFFER(hdsa, BYTE, CB_DSA));
}


BOOL
IsValidHDPA(
    HDPA hdpa)
{
    return (IS_VALID_WRITE_BUFFER(hdpa, BYTE, CB_DPA));
}

BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl)
{
    return (IS_VALID_READ_PTR(pidl, USHORT) &&
            IS_VALID_READ_BUFFER((LPBYTE)pidl+sizeof(USHORT), BYTE, pidl->mkid.cb) &&
            (0 == _ILNext(pidl)->mkid.cb || IS_VALID_PIDL(_ILNext(pidl))));
}


BOOL 
IsValidHWND(
    HWND hwnd)
{
    /* Ask User if this is a valid window. */

    return(IsWindow(hwnd));
}


BOOL
IsValidHMENU(
    HMENU hmenu)
{
    return IsMenu(hmenu);
}    


BOOL 
IsValidHANDLE(
    HANDLE hnd)
{
    return(NULL != hnd && INVALID_HANDLE_VALUE != hnd);
}


BOOL 
IsValidHANDLE2(
    HANDLE hnd)
{
    return(hnd != INVALID_HANDLE_VALUE);
}


BOOL 
IsValidShowCmd(
    int nShow)
{
    BOOL bResult;
 
    switch (nShow)
    {
       case SW_HIDE:
       case SW_SHOWNORMAL:
       case SW_SHOWMINIMIZED:
       case SW_SHOWMAXIMIZED:
       case SW_SHOWNOACTIVATE:
       case SW_SHOW:
       case SW_MINIMIZE:
       case SW_SHOWMINNOACTIVE:
       case SW_SHOWNA:
       case SW_RESTORE:
       case SW_SHOWDEFAULT:
          bResult = TRUE;
          break;
 
       default:
          bResult = FALSE;
          TraceMsg(TF_ERROR, "IsValidShowCmd(): Invalid show command %d.",
                     nShow);
          break;
    }
 
    return(bResult);
}


BOOL 
IsValidPathA(
    LPCSTR pcszPath)
{
    return(IS_VALID_STRING_PTRA(pcszPath, MAX_PATH) &&
           EVAL((UINT)lstrlenA(pcszPath) < MAX_PATH));
}

BOOL 
IsValidPathW(
    LPCWSTR pcszPath)
{
    return(IS_VALID_STRING_PTRW(pcszPath, MAX_PATH) &&
           EVAL((UINT)lstrlenW(pcszPath) < MAX_PATH));
}


BOOL 
IsValidPathResultA(
    HRESULT hr, 
    LPCSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            EVAL(IsValidPathA(pcszPath)) &&
            EVAL((UINT)lstrlenA(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            EVAL(! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}

BOOL 
IsValidPathResultW(
    HRESULT hr, 
    LPCWSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            EVAL(IsValidPathW(pcszPath)) &&
            EVAL((UINT)lstrlenW(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            EVAL(! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}


BOOL 
IsValidExtensionA(
    LPCSTR pcszExt)
{
    return(IS_VALID_STRING_PTRA(pcszExt, MAX_PATH) &&
           EVAL(lstrlenA(pcszExt) < MAX_PATH) &&
           EVAL(*pcszExt == '.'));
}

BOOL 
IsValidExtensionW(
    LPCWSTR pcszExt)
{
    return(IS_VALID_STRING_PTRW(pcszExt, MAX_PATH) &&
           EVAL(lstrlenW(pcszExt) < MAX_PATH) &&
           EVAL(*pcszExt == TEXTW('.')));
}


BOOL 
IsValidIconIndexA(
    HRESULT hr, 
    LPCSTR pcszIconFile,
    UINT cchIconFileBufLen, 
    int niIcon)
{
    return(EVAL(IsValidPathResultA(hr, pcszIconFile, cchIconFileBufLen)) &&
           EVAL(hr == S_OK ||
                ! niIcon));
}

BOOL 
IsValidIconIndexW(
    HRESULT hr, 
    LPCWSTR pcszIconFile,
    UINT cchIconFileBufLen, 
    int niIcon)
{
    return(EVAL(IsValidPathResultW(hr, pcszIconFile, cchIconFileBufLen)) &&
           EVAL(hr == S_OK ||
                ! niIcon));
}


BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszSuffix, -1));
    
    return (pcszSuffix >= pcszBigger && 
            pcszSuffix <= pcszBigger + lstrlenA(pcszBigger));
}


BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszSuffix, -1));
    
    return (pcszSuffix >= pcszBigger && 
            pcszSuffix <= pcszBigger + lstrlenW(pcszBigger));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\Optex.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Optex.cpp

Abstract:

    This module implements the COptex (optimized mutex) synchronization
    object.

Author:

    Jeffrey M. Richter (v-jeffrr) 01-Aug-1998

--*/

#pragma once

class COptex {
public:
   COptex(LPCSTR pszName,  DWORD dwSpinCount = 4000);
   COptex(LPCWSTR pszName, DWORD dwSpinCount = 4000);
   ~COptex();
   void SetSpinCount(DWORD dwSpinCount);
   void Enter();
   BOOL TryEnter();
   void Leave();

private:
   typedef struct {
      DWORD m_dwSpinCount;
      long  m_lLockCount;
      DWORD m_dwThreadId;
      long  m_lRecurseCount;
   } SHAREDINFO, *PSHAREDINFO;

   BOOL        m_fUniprocessorHost;
   HANDLE      m_hevt;
   HANDLE      m_hfm;
   PSHAREDINFO m_pSharedInfo;

private:
   BOOL CommonConstructor(PVOID pszName, BOOL fUnicode, DWORD dwSpinCount);
};

inline COptex::COptex(LPCSTR pszName, DWORD dwSpinCount)
{
   CommonConstructor((PVOID) pszName, FALSE, dwSpinCount);
}

inline COptex::COptex(LPCWSTR pszName, DWORD dwSpinCount)
{
   CommonConstructor((PVOID) pszName, TRUE, dwSpinCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\Optex.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Optex.cpp

Abstract:

    This module implements the COptex (optimized mutex) synchronization
    object.

Author:

    Jeffrey M. Richter (v-jeffrr) 01-Aug-1998

--*/

#include "xbprfmonp.h"

BOOL COptex::CommonConstructor(PVOID pszName, BOOL fUnicode, DWORD dwSpinCount)
{
    m_hevt = m_hfm = NULL;
    m_pSharedInfo = NULL;

    SYSTEM_INFO sinf;
    GetSystemInfo(&sinf);
    m_fUniprocessorHost = (sinf.dwNumberOfProcessors == 1);

    char szNameA[100];
    if (fUnicode) {   // Convert Unicode name to ANSI
        wsprintfA(szNameA, "%S", pszName);
        pszName = (PVOID)szNameA;
    }

    char sz[100];
    wsprintfA(sz, "JMR_Optex_Event_%s", pszName);
    m_hevt = CreateEventA(NULL, FALSE, FALSE, sz);
    chASSERT(m_hevt != NULL);

    if (m_hevt != NULL) {
        wsprintfA(sz, "JMR_Optex_MMF_%s", pszName);
        m_hfm = CreateFileMappingA((HANDLE) 0xFFFFFFFF, NULL,
                                   PAGE_READWRITE, 0,
                                   sizeof(*m_pSharedInfo), sz);
        chASSERT(m_hfm != NULL);

        if (m_hfm != NULL) {
            m_pSharedInfo = (PSHAREDINFO)MapViewOfFile(
                m_hfm, FILE_MAP_WRITE, 0, 0, 0);

            //
            // Note: SHAREDINFO's m_lLockCount, m_dwThreadId, and m_lRecurseCount
            // members need to be initialized to 0. Fortunately, a new pagefile
            // MMF sets all of its data to 0 when created. This saves use from
            // some thread synchronization work.
            //

            if (m_pSharedInfo != NULL) {
                SetSpinCount(dwSpinCount);
            }
        }
    }

    return ((m_hevt != NULL) && (m_hfm != NULL) && (m_pSharedInfo != NULL));
}

COptex::~COptex()
{
#ifdef _DEBUG
    if (m_pSharedInfo->m_dwThreadId == GetCurrentThreadId()) {
        DebugBreak();
    }
#endif
    UnmapViewOfFile(m_pSharedInfo);
    CloseHandle(m_hfm);
    CloseHandle(m_hevt);
}

void COptex::SetSpinCount(DWORD dwSpinCount)
{
    if (!m_fUniprocessorHost) {
        InterlockedExchange((PLONG)&m_pSharedInfo->m_dwSpinCount, dwSpinCount);
    }
}

void COptex::Enter(void)
{
    //
    // Spin, trying to get the Optex
    //
    if (TryEnter()) {
        return;
    }

    DWORD dwThreadId = GetCurrentThreadId();  // The calling thread's ID

    if (InterlockedIncrement(&m_pSharedInfo->m_lLockCount) == 1) {

        //
        // Optex is unowned, let this thread own it once
        //
        InterlockedExchange((PLONG) &m_pSharedInfo->m_dwThreadId, dwThreadId);
        m_pSharedInfo->m_lRecurseCount = 1;

    } else {

        //
        // Optex is owned by a thread
        //
        if (m_pSharedInfo->m_dwThreadId == dwThreadId) {

            //
            // Optex is owned by this thread, own it again
            //
            m_pSharedInfo->m_lRecurseCount++;

        } else {

            //
            // Optex is owned by another thread
            // Wait for the owning thread to release the Optex
            //
            WaitForSingleObject(m_hevt, INFINITE);

            //
            // We got ownership of the Optex
            //
            InterlockedExchange((PLONG) &m_pSharedInfo->m_dwThreadId, dwThreadId); // We own it now
            m_pSharedInfo->m_lRecurseCount = 1;       // We own it once
        }
    }
}

BOOL COptex::TryEnter(VOID)
{
    DWORD dwThreadId = GetCurrentThreadId();  // The calling thread's ID

    //
    // If the lock count is zero, the Optex is unowned and
    // this thread can become the owner of it now.
    //

    BOOL fThisThreadOwnsTheOptex = FALSE;
    DWORD dwSpinCount = m_pSharedInfo->m_dwSpinCount;
    do {
        fThisThreadOwnsTheOptex = (0 == (DWORD)
            InterlockedCompareExchangePointer(
                (PVOID*)&m_pSharedInfo->m_lLockCount, (PVOID)1, (PVOID)0));

        if (fThisThreadOwnsTheOptex) {

            //
            // We now own the Optex
            //
            InterlockedExchange((PLONG)&m_pSharedInfo->m_dwThreadId, dwThreadId); // We own it
            m_pSharedInfo->m_lRecurseCount = 1;     // We own it once

        } else {

            //
            // Some thread owns the Optex
            //
            if (m_pSharedInfo->m_dwThreadId == dwThreadId) {
                //
                // We already own the Optex
                //
                InterlockedIncrement(&m_pSharedInfo->m_lLockCount);
                m_pSharedInfo->m_lRecurseCount++;   // We own it again
                fThisThreadOwnsTheOptex = TRUE;     // Return that we own the Optex
            }
        }
    } while (!fThisThreadOwnsTheOptex && (dwSpinCount-- > 0));

    //
    // Return whether or not this thread owns the Optex
    //
    return fThisThreadOwnsTheOptex;
}

void COptex::Leave(void)
{
#ifdef _DEBUG
    if (m_pSharedInfo->m_dwThreadId != GetCurrentThreadId()) {
        DebugBreak();
    }
#endif

    if (--m_pSharedInfo->m_lRecurseCount > 0) {

        //
        // We still own the Optex
        //
        InterlockedDecrement(&m_pSharedInfo->m_lLockCount);

    } else {

        //
        // We don't own the Optex
        //
        InterlockedExchange((PLONG) &m_pSharedInfo->m_dwThreadId, 0);
        if (InterlockedDecrement(&m_pSharedInfo->m_lLockCount) > 0) {
            //
            // Other threads are waiting, wake one of them
            //
            SetEvent(m_hevt);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\uassist.cpp ===
//***   uassist.cpp -- User Assist helpers (retail and debug)
//
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.  NEEDED because of ENTERCRITICAL
// as stocklib.dll does not have a critical section in it.
//
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/uassist.cpp"
//
//  we cache the UAssist object and provide thunks for 'safe' access to it.

#include "uemapp.h"

#define DM_UASSIST             0

IUserAssist *g_uempUa;      // 0:uninit, -1:failed, o.w.:cached obj

//***   GetUserAssist -- get (and create) cached UAssist object
//
IUserAssist *GetUserAssist()
{
    HRESULT hr;
    IUserAssist *pua;

    if (g_uempUa == 0) {
        // re: CLSCTX_NO_CODE_DOWNLOAD
        // an ('impossible') failed CCI of UserAssist is horrendously slow.
        // e.g. click on the start menu, wait 10 seconds before it pops up.
        // we'd rather fail than hose perf like this, plus this class should
        // never be remote.
        // BUGBUG there must be a better way to tell if CLSCTX_NO_CODE_DOWNLOAD
        // is supported, i've sent mail to 'com' to find out...
        DWORD dwFlags = staticIsOS(OS_NT5) ? (CLSCTX_INPROC|CLSCTX_NO_CODE_DOWNLOAD) : CLSCTX_INPROC;
        hr = THR(CoCreateInstance(CLSID_UserAssist, NULL, dwFlags, IID_IUserAssist, (void**)&pua));
        ASSERT(SUCCEEDED(hr) || pua == 0);  // follow COM rules

        if (pua) {
            HINSTANCE hInst;

            hInst = SHPinDllOfCLSID(&CLSID_UserAssist); // cached across threads
            // we're toast if this fails!!! (but happily, that's 'impossible')
            // e.g. during logon when grpconv.exe is ShellExec'ed, we do
            // a GetUserAssist, which caches a ptr to browseui's singleton
            // object.  then when the ShellExec returns, we do CoUninit,
            // which would free up the (non-pinned) browseui.dll.  then
            // a later use of the cache would go off into space.
            ASSERT(hInst);          // 'impossible', since the CCI succeeded
        }

        ENTERCRITICAL;
        if (g_uempUa == 0) {
            g_uempUa = pua;     // xfer refcnt (if any)
            if (!pua) {
                // mark it failed so we won't try any more
                g_uempUa = (IUserAssist *)-1;
            }
            pua = NULL;
        }
        LEAVECRITICAL;
        if (pua)
            pua->Release();
        TraceMsg(DM_UASSIST, "sl.gua: pua=0x%x g_uempUa=%x", pua, g_uempUa);
    }

    return (g_uempUa == (IUserAssist *)-1) ? 0 : g_uempUa;
}

extern "C"
BOOL UEMIsLoaded()
{
    BOOL fRet;

    fRet = GetModuleHandle(TEXT("ole32.dll")) &&
        GetModuleHandle(TEXT("browseui.dll"));
    
    if (!fRet)
        TraceMsg(TF_WARNING, "uemil: UEMIsLoaded ret=0 (.dll not loaded)");
    
    return fRet;
}

//***   UEMFireEvent, QueryEvent, SetEvent -- 'safe' thunks
// DESCRIPTION
//  call these so don't have to worry about cache or whether Uassist object
// even was successfully created.
extern "C"
HRESULT UEMFireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->FireEvent(pguidGrp, eCmd, dwFlags, wParam, lParam);
    }
    return hr;
}

extern "C"
HRESULT UEMQueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->QueryEvent(pguidGrp, eCmd, wParam, lParam, pui);
    }
    return hr;
}

extern "C"
HRESULT UEMSetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->SetEvent(pguidGrp, eCmd, wParam, lParam, pui);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\PrfDataMap.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    prfdatamap.cpp

Abstract:

    This module implements PerfMon's plugin that polls various performance
    counters from Xbox using debug channel

--*/

#include "xbprfmonp.h"

CPrfData g_PrfData( L"Xbox PerfMon", 0 );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\lib\stock\makefile.inc ===
..\shstra.cpp: ..\shstr.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

..\shstrw.cpp: ..\shstr.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

..\dkaa.cpp: ..\dka.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

..\dkaw.cpp: ..\dka.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

..\nativea.cpp: ..\native.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

..\nativew.cpp: ..\native.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

LIBOBJ = ..\$O

clean:
    -del $(NTTARGETFILE0)
    -del $(NTTARGETFILES)

#
# Copy stocklib to lib\obj\*
#
$(LIBOBJ)\stocklib.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\stocklib.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@

## webcheck includes rpc headers. Not here as I dont think they
##  will affect guids that we need.
$(O)\shguid.obj: ..\shguid.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\..\shguid.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$(LIBOBJ)\shguid.lib: $(O)\shguid.obj
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@

$(O)\shguidp.obj: ..\shguidp.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\..\shguidp.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$(LIBOBJ)\shguidp.lib: $(O)\shguidp.obj
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\PrfData.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PrfData.cpp

Abstract:

    This module implements the C++ template classes for Performance
    Object data types.

Author:

    Jeffrey M. Richter (v-jeffrr) 01-Aug-1998

--*/

#include "xbprfmonp.h"

//
// Call this function to force a breakpoint in PerfMon.exe
//

#ifdef _DEBUG
void ForceDebugBreak()
{
    __try {
        DebugBreak();
    }
    __except(UnhandledExceptionFilter(GetExceptionInformation())) {
    }
}
#else
#define ForceDebugBreak()
#endif

//
// Helper function that finds a set of bytes in a memory block
//

PBYTE FindMemory(
    PBYTE pbBuf,
    DWORD cbBuf,
    PBYTE pbSearchBytes,
    DWORD cbSearchBytes
    )
{
    for (DWORD n = 0; n < (cbBuf - cbSearchBytes); n++) {
        if (pbBuf[n] == pbSearchBytes[0]) {
            for (DWORD x = 1; x < cbSearchBytes; x++) {
                if (pbBuf[n + x] != pbSearchBytes[x])
                    break; // Not a match
            }
            if (x == cbSearchBytes) {
                return(&pbBuf[n]); // Match!
            }
        }
    }

    return NULL;  // Not found at all
}

//
// Address of the ONE instance of this class (See Collect)
//

CPrfData* CPrfData::sm_pPrfData = NULL;

//
// Constructor: initializes member variables
//

CPrfData::CPrfData(LPCWSTR pszAppName, PPRFITM pPrfItms) :
    m_pszAppName(pszAppName),  m_pPrfItms(pPrfItms),
    m_nNumPrfItems(0),         m_nNumObjects(0),
    m_pPrfData(NULL),          m_hfm(NULL),
    m_dwFirstCounter(0),       m_dwLastCounter(0),
    m_dwFirstHelp(1),          m_dwLastHelp(1),
    m_Optex(pszAppName, 4000), m_hEvent(NULL)
{
    chASSERT(sm_pPrfData == NULL);  // Only one instance can exist

    sm_pPrfData = this;

    // Sanity check performance data object/counter map
    if ( m_pPrfItms ) {
        VerifyPrfItemTable();
    }

#ifndef PRFDATA_COLLECT_SUPPORTED
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
    m_hEvent = CreateEvent(&sa, FALSE, FALSE, NULL);
#endif
}

CPrfData::~CPrfData() {
    if (m_pPrfData != NULL) {
        UnmapViewOfFile(m_pPrfData);
    }

    if (m_hfm != NULL) {
        CloseHandle(m_hfm);
    }
}

//
// Installs performance object/counter map info into registry
//

void CPrfData::InstallPrfData(LPCWSTR pszDllPathname)
{
    DWORD dwLastCounter = 0, dwLastHelp = 1;

    //
    // Read the last counter/help global values from the registry
    //
    CRegSettings regPerfLib, regApp;

    chVERIFY( ERROR_SUCCESS == regPerfLib.OpenSubkey(
        FALSE, HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib") );

    regPerfLib.GetDWORD(L"Last Counter", &dwLastCounter);
    regPerfLib.GetDWORD(L"Last Help",    &dwLastHelp);

    //
    // Read the first/last counter/help app values from the registry
    //
    WCHAR szSubkey[100];
    wsprintfW(szSubkey, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance",
              m_pszAppName);

    chVERIFY( ERROR_SUCCESS == regApp.OpenSubkey(FALSE, HKEY_LOCAL_MACHINE, szSubkey));

    //
    // Advance to the next counter / help
    //
    m_dwFirstCounter = m_dwLastCounter = dwLastCounter + 2;
    m_dwFirstHelp    = m_dwLastHelp    = dwLastHelp + 2;

    //
    // Install our counters into the registry
    //
    AppendRegStrings(regPerfLib, TRUE,  &m_dwLastCounter);
    AppendRegStrings(regPerfLib, FALSE, &m_dwLastHelp);

    //
    // Tell the registry where the next set of counter can go
    //
    regPerfLib.SetDWORD(L"Last Counter", m_dwLastCounter);
    regPerfLib.SetDWORD(L"Last Help", m_dwLastHelp);

    //
    // Save the installation results for our app
    //
    regApp.SetString(L"Library",       pszDllPathname);
    regApp.SetString(L"Open",          L"PrfData_Open");
    regApp.SetString(L"Close",         L"PrfData_Close");
    regApp.SetString(L"Collect",       L"PrfData_Collect");
    regApp.SetDWORD (L"First Counter", m_dwFirstCounter);
    regApp.SetDWORD (L"First Help",    m_dwFirstHelp);
    regApp.SetDWORD (L"Last Counter",  m_dwLastCounter);
    regApp.SetDWORD (L"Last Help",     m_dwLastHelp);
}

//
// Takes this app's performance info out of the registry
//

void CPrfData::UninstallPrfData()
{
    //
    // Read the last counter/help global values from the registry
    //
    CRegSettings regPerfLib, regApp;

    chVERIFY( ERROR_SUCCESS == regPerfLib.OpenSubkey(FALSE, HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib") );

    DWORD dwLastCounter = 0, dwLastHelp = 1;
    regPerfLib.GetDWORD(L"Last Counter", &dwLastCounter);
    regPerfLib.GetDWORD(L"Last Help",    &dwLastHelp);

    //
    // Read the first/last counter/help app values from the registry
    //
    WCHAR szSubkey[100];
    wsprintfW(szSubkey, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance",
              m_pszAppName);

    chVERIFY( ERROR_SUCCESS == regApp.OpenSubkey(FALSE, HKEY_LOCAL_MACHINE, szSubkey) );

    regApp.GetDWORD(L"First Counter", &m_dwFirstCounter);
    regApp.GetDWORD(L"First Help",    &m_dwFirstHelp);
    regApp.GetDWORD(L"Last Counter",  &m_dwLastCounter);
    regApp.GetDWORD(L"Last Help",     &m_dwLastHelp);

    //
    // Our counters are in the registry, do sanity checks
    //
    chASSERT((DWORD)m_nNumPrfItems == (m_dwLastCounter - m_dwFirstCounter) / 2 + 1);
    chASSERT((DWORD)m_nNumPrfItems == (m_dwLastHelp - m_dwFirstHelp) / 2 + 1);
    chASSERT((m_dwFirstCounter <= m_dwLastCounter) && (m_dwFirstHelp <= m_dwLastHelp));
    chASSERT((m_dwLastCounter <= dwLastCounter) && (m_dwLastHelp <= dwLastHelp));

    //
    // Remove the strings from the registry
    //
    RemoveRegStrings(regPerfLib, TRUE,
    m_dwFirstCounter, m_dwLastCounter);
    RemoveRegStrings(regPerfLib, FALSE,
    m_dwFirstHelp, m_dwLastHelp);

    //
    // If these counters are the last in, truncate the end
    // otherwise we leave a gap in the performance counter numbers
    //
    if (m_dwLastCounter == dwLastCounter) {
        dwLastCounter -= (int) m_nNumPrfItems * 2;
        dwLastHelp    -= (int) m_nNumPrfItems * 2;
        regPerfLib.SetDWORD(L"Last Counter", dwLastCounter);
        regPerfLib.SetDWORD(L"Last Help", dwLastHelp);
    }

    //
    // Delete the app's registry key
    //
    regApp.CloseKey();
    ::RegDeleteKeyW(HKEY_LOCAL_MACHINE, szSubkey);
}

//
// Appends our performance object/counter text/help in the registry
//

void CPrfData::AppendRegStrings(
    CRegSettings& regPerfLib,BOOL fCounter, PDWORD pdwIndex)
{
    //
    // Calculate the number of required for the stuff we want to add
    //
    DWORD cbInc = 0;
    for (PIINDEX pii = 0; m_pPrfItms[pii].pit != PIT_END; pii++) {
        cbInc += (6 + 1) * sizeof(WCHAR); // 6 digit index plus 0-char
        cbInc += (lstrlenW(fCounter ? m_pPrfItms[pii].pwszName
           : m_pPrfItms[pii].pwszHelp) + 1) * sizeof(WCHAR);
    }

    //
    // Allocate buffer big enough for original + new data & read it in
    //

    WCHAR szLangID[16];
    LANGID LangID = (LANGID)PRIMARYLANGID(GetSystemDefaultUILanguage());
    wsprintf(szLangID, L"%03x", LangID);
    CRegSettings regLang(FALSE, regPerfLib, szLangID);
    LPCWSTR pszValue = fCounter ? L"Counter" : L"Help";
    DWORD cbOrig = 0;
    regLang.GetSize(pszValue, &cbOrig);
    LPWSTR psz = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, cbOrig + cbInc);
    regLang.GetMultiString(pszValue, psz, cbOrig);

    //
    // Append our new stuff to the end of the buffer
    // Subtract 1 for extra terminating 0 char
    //
    LPWSTR pszInc = (LPWSTR)((PBYTE) psz + cbOrig) - 1;

    //
    // Append our strings
    //
    for (pii = 0; m_pPrfItms[pii].pit != PIT_END; pii++) {
        LPCTSTR psz = fCounter ? m_pPrfItms[pii].pwszName
           : m_pPrfItms[pii].pwszHelp;
        lstrcpyW(pszInc +=
           wsprintfW(pszInc, L"%d", *pdwIndex) + 1, psz);
        pszInc += lstrlenW(psz) + 1;
        *pdwIndex += 2;   // Always increment the number by 2
    }

    *pdwIndex -= 2;

    *pszInc++ = 0;   // Append extra terminating 0-char
    regLang.SetMultiString(pszValue, psz);
    HeapFree(GetProcessHeap(), 0, psz);
}

//
// Remove the object/counter strings from the registry
//
void CPrfData::RemoveRegStrings(CRegSettings& regPerfLib,
    BOOL fCounter, DWORD dwIndexLo, DWORD dwIndexHi)
{
    //
    // Allocate buffer big enough for original data & read it in
    //
    WCHAR szLangID[16];
    LANGID LangID = (LANGID)PRIMARYLANGID(GetSystemDefaultUILanguage());
    wsprintf(szLangID, L"%03x", LangID);
    CRegSettings regLang(FALSE, regPerfLib, szLangID);
    LPCWSTR pszValue = fCounter ? L"Counter" : L"Help";
    DWORD cbOrig = 0;
    regLang.GetSize(pszValue, &cbOrig);
    LPWSTR psz = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, cbOrig);
    regLang.GetMultiString(pszValue, psz, cbOrig);

    //
    // Find the bounds of what we want to remove
    //
    WCHAR szNum[10] = { 0}; // Look for \0#\0
    wsprintfW(&szNum[1], L"%d", dwIndexLo);
    PBYTE pbLo = FindMemory((PBYTE)psz, cbOrig,
                    (PBYTE)szNum, sizeof(WCHAR) * (lstrlenW(&szNum[1]) + 2));
    pbLo += sizeof(WCHAR);  // 1st byte of stuff to remove
    wsprintfW(&szNum[1], L"%d", dwIndexHi);
    PBYTE pbHi = FindMemory((PBYTE)psz, cbOrig,
                    (PBYTE)szNum, sizeof(WCHAR) * (lstrlenW(&szNum[1]) + 2));
    pbHi += sizeof(WCHAR);  // 1st byte of last counter to remove

    //
    // Skip over number and text
    //
    pbHi += (lstrlenW((LPCWSTR) pbHi) + 1) * sizeof(WCHAR);
    pbHi += (lstrlenW((LPCWSTR) pbHi) + 1) * sizeof(WCHAR);

    //
    // Shift the strings to keep down over the stuff to delete
    //
    chASSERT(pbLo <= pbHi);
    MoveMemory(pbLo, pbHi, ((PBYTE) psz + cbOrig) - pbHi);

    //
    // Save the updated string information
    //
    regLang.SetMultiString(pszValue, psz);
    HeapFree(GetProcessHeap(), 0, psz);
}

//
// Creates the shared memory region for the performance information
//
DWORD CPrfData::ActivatePrfData()
{
    WCHAR szSubkey[100];

    //
    // Read the first/last object/counter text/help values
    //
    wsprintfW(szSubkey, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance",
              m_pszAppName);

    CRegSettings regApp(TRUE, HKEY_LOCAL_MACHINE, szSubkey);
    regApp.GetDWORD(L"First Counter", &m_dwFirstCounter);
    regApp.GetDWORD(L"First Help",    &m_dwFirstHelp);
    regApp.GetDWORD(L"Last Counter",  &m_dwLastCounter);
    regApp.GetDWORD(L"Last Help",     &m_dwLastHelp);

    //
    // Do sanity checks
    //

#ifndef PRFDATA_COLLECT_SUPPORTED
    chASSERT((DWORD) m_nNumPrfItems == (m_dwLastCounter - m_dwFirstCounter) / 2 + 1);
    chASSERT((DWORD) m_nNumPrfItems == (m_dwLastHelp - m_dwFirstHelp) / 2 + 1);
#else
    m_nNumPrfItems = (m_dwLastCounter - m_dwFirstCounter) / 2 + 1;
    chASSERT((DWORD) m_nNumPrfItems == (m_dwLastHelp - m_dwFirstHelp) / 2 + 1);
#endif

    chASSERT(m_pPrfData == NULL);   // This can only be done once

    //
    // Calculate how many bytes are needed for the shared memory
    //
    DWORD cbBytesNeededForAllObjs = 0;
    for (OBJORD ObjOrd = 0; ObjOrd < (OBJORD) m_nNumObjects; ObjOrd++) {
        PRFMETRICS pm;
        PPRFITM pPrfObj;
        CalcPrfMetrics(ObjOrd, 0, &pm, &pPrfObj);

        // No instances                   Instances
        // ---------------------------    ---------------------------
        // 1 PERF_OBJECT_TABLE            1 PERF_OBJECT_TABLE
        // 1 PERF_COUNTER_DEFINITION      1 PERF_COUNTER_DEFINITION
        // 0 PERF_INSTANCE_DEFINITION     x PERF_INSTANCE_DEFINITIONs
        // 1 PERF_COUNTER_BLOCK           x PERF_COUNTER_BLOCKs
        // 0 instance names               x instance names
        pPrfObj->cbOffsetToNextObj = pm.cbPOT + pm.cbPCD +
                                     pm.cbPID * (pm.fSupportsInstances ? pm.MaxInstances : 0) +
                                     pm.cbPCB * (pm.fSupportsInstances ? pm.MaxInstances : 1) +
                                     pm.cbPIN * (pm.fSupportsInstances ? pm.MaxInstances : 0);
        cbBytesNeededForAllObjs += pPrfObj->cbOffsetToNextObj;
    }

    //
    // Adjust size for event handle
    //
    cbBytesNeededForAllObjs += sizeof(HANDLE);

    //
    // Adjust size for PRFITMs
    //

    cbBytesNeededForAllObjs += ( (m_nNumPrfItems+1) * sizeof(PRFITM) );

    //
    // Attempt to allocate a MMF big enough for the data
    //
    m_hfm = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                               0, cbBytesNeededForAllObjs, m_pszAppName);

    //
    // If dwErr = ERROR_ALREADY_EXISTS, another app has created the
    // shared data area. This instance doesn't need to initialize it
    //

    DWORD dwErr = GetLastError();

    if (m_hfm == NULL) {
        return(dwErr);
    }

    m_pPrfData = (PBYTE)MapViewOfFile(m_hfm, FILE_MAP_WRITE, 0, 0, 0);
    if ( !m_pPrfData ) {
        return GetLastError();
    }

    if (dwErr == ERROR_ALREADY_EXISTS) {
#ifndef PRFDATA_COLLECT_SUPPORTED
        return ERROR_SERVICE_EXISTS;
#else
        m_hEvent = *(LPHANDLE)m_pPrfData;
        m_pPrfData += sizeof(HANDLE);
        m_pPrfItms = (PPRFITM)m_pPrfData;

        m_nNumPrfItems = 0;
        VerifyPrfItemTable();

        chASSERT((DWORD) m_nNumPrfItems == (m_dwLastCounter - m_dwFirstCounter) / 2 + 1);
        chASSERT((DWORD) m_nNumPrfItems == (m_dwLastHelp - m_dwFirstHelp) / 2 + 1);

        m_pPrfData += (m_nNumPrfItems+1) * sizeof(PRFITM);
        return ERROR_SUCCESS;
#endif
    } else {
        chASSERT( m_hEvent != NULL );
        *(LPHANDLE)m_pPrfData = m_hEvent;
        m_pPrfData += sizeof(HANDLE);

        chASSERT( m_pPrfItms != NULL );
        memcpy( m_pPrfData, m_pPrfItms, (m_nNumPrfItems+1) * sizeof(PRFITM) );
        m_pPrfData += (m_nNumPrfItems+1) * sizeof(PRFITM);
    }

    //
    // This instance actually allocated the shared data, initialize it
    //
    DWORD dwCounter = m_dwFirstCounter, dwHelp = m_dwFirstHelp;

    //
    // Set the PERF_OBJECT_TYPEs for each object
    //
    for (ObjOrd = 0; ObjOrd < m_nNumObjects; ObjOrd++) {
        PRFMETRICS pm;
        PPRFITM pPrfObj;
        CalcPrfMetrics(ObjOrd, 0, &pm, &pPrfObj);

        //
        // Set the PERF_OBJECT_TYPE members
        //
        pm.pPOT->TotalByteLength      = 0;   // Set in Collect function
        pm.pPOT->DefinitionLength     = sizeof(PERF_OBJECT_TYPE) +
                                        sizeof(PERF_COUNTER_DEFINITION) *
                                        (int) pPrfObj->NumCounters;
        pm.pPOT->HeaderLength         = sizeof(PERF_OBJECT_TYPE);
        pm.pPOT->ObjectNameTitleIndex = dwCounter;
        pm.pPOT->ObjectNameTitle      = NULL; // Set by PerfMon
        pm.pPOT->ObjectHelpTitleIndex = dwHelp;
        pm.pPOT->ObjectHelpTitle      = NULL; // Set by PerfMon
        pm.pPOT->DetailLevel          = pPrfObj->dwDetailLevel;
        pm.pPOT->NumCounters          = (DWORD) pPrfObj->NumCounters;

        if (pPrfObj->DefCounter == (CTRID) -1) {
            pm.pPOT->DefaultCounter = -1;
        } else {
            // If a default CTRID specified, convert it to index
            CvtCtrIdToPrfItmIndex(pPrfObj->DefCounter,
            (int*) &pm.pPOT->DefaultCounter);
        }

        pm.pPOT->NumInstances         = (int) pPrfObj->MaxInstances;
        pm.pPOT->CodePage             = NULL;
        pm.pPOT->PerfTime.QuadPart    = 0;
        pm.pPOT->PerfFreq.QuadPart    = 0;

        dwCounter += 2;
        dwHelp += 2;

        // Set the PERF_COUNTER_DEFINITIONs for each counter
        for (CTRORD CtrOrd = 0; CtrOrd < pPrfObj->NumCounters; CtrOrd++) {
            PPRFITM pPrfCtr = CvtCtrOrdToPrfItm(ObjOrd, CtrOrd);
            PPERF_COUNTER_DEFINITION pPCD = &pm.pPCD[(int) CtrOrd];
            pPCD->ByteLength            = sizeof(PERF_COUNTER_DEFINITION);
            pPCD->CounterNameTitleIndex = dwCounter;
            pPCD->CounterNameTitle      = NULL;
            pPCD->CounterHelpTitleIndex = dwHelp;
            pPCD->CounterHelpTitle      = NULL;
            pPCD->DefaultScale          = pPrfCtr->dwDefaultScale;
            pPCD->DetailLevel           = pPrfCtr->dwDetailLevel;
            pPCD->CounterType           = pPrfCtr->dwCounterType;
            pPCD->CounterSize           = kMaxCounterSize;
            pPCD->CounterOffset         = sizeof(PERF_COUNTER_BLOCK) +
                                          kMaxCounterSize * (int) CtrOrd;
            dwCounter += 2;
            dwHelp += 2;
        }

        // Set the PERF_COUNTER_BLOCKs for the 1 (or each) instance
        if (pPrfObj->MaxInstances == (INSTID) PERF_NO_INSTANCES) {
            pm.pPCB->ByteLength = pm.cbPCB;
        } else {
            for (INSTID InstId = 0; InstId < pPrfObj->MaxInstances; InstId++) {
                CalcPrfMetrics(ObjOrd, InstId, &pm);
                pm.pPCB->ByteLength = pm.cbPCB;
            }
        }
    }

    return dwErr;
}

//
// Finds an empty instance entry
//

CPrfData::INSTID CPrfData::FindFreeInstance(OBJORD ObjOrd) const
{
    //
    // Sanity check for valid object and that it support instances
    //
    chASSERT(IsValidObjOrd(ObjOrd));
    PRFMETRICS pm;
    CalcPrfMetrics(ObjOrd, 0, &pm);
    chASSERT(pm.fSupportsInstances);

    LockCtrs();

    //
    // Find an unused instance entry
    //
    INSTID InstId = 0;
    for (; InstId < (INSTID) pm.MaxInstances; InstId++) {
        CalcPrfMetrics(ObjOrd, InstId, &pm);
        if (pm.pPIN[0] == 0) {
            break;
        }
    }

    UnlockCtrs();

    //
    // -1 means all instances are in use
    //

    return (InstId == (INSTID) pm.MaxInstances) ? (INSTID) -1 : InstId;
}

//
// Adds an instance to an object
//

CPrfData::INSTID CPrfData::AddInstance(OBJID ObjId, LPCWSTR pszInstName,
    LONG lUniqueID, OBJID ObjIdParent,INSTID InstIdParent)
{
    //
    // Make sure that instance has a valid identity
    //
    chASSERT(((pszInstName == NULL) &&
        (lUniqueID != PERF_NO_UNIQUE_ID)) || ((pszInstName != NULL) &&
        (lUniqueID == PERF_NO_UNIQUE_ID)));

    //
    // Make sure the object is valid and supports instances
    //
    OBJORD ObjOrd = CvtObjIdToObjOrd(ObjId);
    PRFMETRICS pm;
    CalcPrfMetrics(ObjOrd, 0, &pm);
    chASSERT(pm.fSupportsInstances);

    //
    // Find a place to put this instance
    //
    INSTID InstId = FindFreeInstance(ObjOrd);

    if (InstId != (INSTID) -1) {
        CalcPrfMetrics(ObjOrd, InstId, &pm);

        //
        // Store the Parent Object's ID/Instance ID and Unique ID.
        // The Collect function converts IDs to the appropriate values.
        //
        pm.pPID->ParentObjectTitleIndex = (DWORD) ObjIdParent;
        pm.pPID->ParentObjectInstance = (DWORD) InstIdParent;
        pm.pPID->UniqueID = lUniqueID;

        if (pszInstName == NULL) { // Instance has a string name
            pm.pPIN[0] = 1;                  // Mark instance as in use
            pm.pPID->NameOffset = 0;
            pm.pPID->NameLength = 0;
        } else {                   // Instance has no string name
            chASSERT(lstrlenW(pszInstName) <
            (int) CvtObjOrdToPrfItm(ObjOrd)->cchMaxInstName);
            lstrcpyW(pm.pPIN, pszInstName);  // Mark instance as in use
            pm.pPID->NameOffset = pm.cbPID;
            pm.pPID->NameLength =
            (lstrlenW(pszInstName) + 1) * sizeof(WCHAR);
        }
    }

    return InstId;
}

//
// Removes an instance from an object
//

void CPrfData::RemoveInstance(OBJID ObjId, INSTID InstId)
{
    PRFMETRICS pm;
    CalcPrfMetrics(CvtObjIdToObjOrd(ObjId), InstId, &pm);
    chASSERT(pm.fSupportsInstances);
    chASSERT(pm.pPIN[0] != 0); // Can't remove an unassigned instance
    LockCtrs();
    pm.pPIN[0] = 0;   // Mark instance as NOT in use
    UnlockCtrs();
}

//
// Sanity checks the performance object/counter map
//

void CPrfData::VerifyPrfItemTable()
{
    PIINDEX piiCrntObj = (PIINDEX) -1;  // Object being processed

    // Loop through all entries in the object/counter map
    for (PIINDEX pii = 0; m_pPrfItms[pii].pit != PIT_END; pii++) {
        chASSERT(m_pPrfItms[pii].dwId != 0); // 0 is an invalid ID
        m_nNumPrfItems++;

        switch (m_pPrfItms[pii].pit) {
        case PIT_END:
            //
            // Make sure the current object is in a good state
            // i.e., object has at least one counter in it
            //
            chASSERT(!((piiCrntObj != -1) &&
                (m_pPrfItms[piiCrntObj].NumCounters < (CTRORD) 1)));
            break;

        case PIT_OBJECT:     // We found a new object
            //
            // Every Object ID in the table must be unique
            //
            chASSERT(CvtObjIdToPrfItmIndex((OBJID) m_pPrfItms[pii].dwId) == pii);

            //
            // Sanity check its parameters
            //
            chASSERT((m_pPrfItms[pii].DefCounter == (CTRID) -1) ||
                (CvtCtrIdToPrfItmIndex(m_pPrfItms[pii].DefCounter) != -1));
            chASSERT((m_pPrfItms[pii].MaxInstances ==
                (INSTID) PERF_NO_INSTANCES) ||
                (m_pPrfItms[pii].MaxInstances > 0));
            chASSERT(
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_NOVICE)   ||
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_ADVANCED) ||
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_EXPERT)   ||
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_WIZARD));

            m_nNumObjects++;

            //
            // Finish up the object that we were just working on
            //
            if (piiCrntObj != -1) {
                //
                // Make sure the current object is in a good state
                // i.e., object has at least one counter in it
                //
                chASSERT(m_pPrfItms[piiCrntObj].NumCounters > 0);

                //
                // The previous object must point to the current object
                //
                m_pPrfItms[piiCrntObj].IndexNextObj = pii;
            }

            piiCrntObj = pii; // Save new current object
            m_pPrfItms[piiCrntObj].NumCounters = 0;

            //
            // Assume that this is the last object in the list
            //
            m_pPrfItms[piiCrntObj].IndexNextObj = -1;
            break;

        case PIT_COUNTER:
            chASSERT(pii != 0); // First entry in map must be PIT_OBJECT

            //
            // Every Counter ID in the table must be unique
            //
            chASSERT(CvtCtrIdToPrfItmIndex(
                (CTRID) m_pPrfItms[pii].dwId) == pii);

            //
            // Sanity check its parameters
            //
            chASSERT(
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_NOVICE)   ||
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_ADVANCED) ||
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_EXPERT)   ||
                (m_pPrfItms[pii].dwDetailLevel == PERF_DETAIL_WIZARD));

            m_pPrfItms[piiCrntObj].NumCounters++;
            break;
        }
    }
}

//
// Calculates an object's performance info (addresses and sizes)
//

void CPrfData::CalcPrfMetrics(OBJORD ObjOrd, INSTID InstId,
    PPRFMETRICS pPM, PPRFITM* ppPrfItm) const
{
    chASSERT(IsValidInstId(ObjOrd, InstId));

    PPRFITM pPrfItm = CvtObjOrdToPrfItm(ObjOrd);
    if (ppPrfItm != NULL) {
        *ppPrfItm = pPrfItm;
    }

    ZeroMemory(pPM, sizeof(*pPM));
    pPM->fSupportsInstances = (pPrfItm->MaxInstances != (INSTID) PERF_NO_INSTANCES);
    pPM->MaxInstances = (long) pPrfItm->MaxInstances;

    //
    // Find the start of this object's performance data
    //
    DWORD cb = 0;
    PIINDEX pii = 0;

    for (; 0 != ObjOrd--; pii = m_pPrfItms[pii].IndexNextObj) {
        cb += m_pPrfItms[pii].cbOffsetToNextObj;
    }

    //
    // This object's PERF_OBJECT_TYPE structure & size
    //
    pPM->pPOT = (PPERF_OBJECT_TYPE) (m_pPrfData + cb);
    pPM->cbPOT = sizeof(PERF_OBJECT_TYPE);

    //
    // PERF_COUNTER_DEFINITIONs follow PERF_OBJECT_TYPE
    //
    pPM->pPCD = (PPERF_COUNTER_DEFINITION) (&pPM->pPOT[1]);
    pPM->cbPCD = (int) pPrfItm->NumCounters * sizeof(PERF_COUNTER_DEFINITION);

    if (pPrfItm->MaxInstances != (INSTID) PERF_NO_INSTANCES) {
        long MaxInstances = (long) pPrfItm->MaxInstances;
        PBYTE pbEndOfCtrDefs = (PBYTE) pPM->pPCD + pPM->cbPCD;

        //
        // PERF_INSTANCE_DEFINITIONs follow PERF_COUNTER_DEFINITIONs
        //
        pPM->pPID = (PPERF_INSTANCE_DEFINITION) pbEndOfCtrDefs;
        pPM->pPID = &pPM->pPID[(int) InstId];
        pPM->cbPID = sizeof(PERF_INSTANCE_DEFINITION);

        //
        // PERF_COUNTER_BLOCKs follow PERF_INSTANCE_DEFINITIONs
        //
        pPM->pPCB = (PPERF_COUNTER_BLOCK) (pbEndOfCtrDefs +
                    sizeof(PERF_INSTANCE_DEFINITION) * MaxInstances);
        pPM->cbPCB = sizeof(PERF_COUNTER_BLOCK) +
                     (long) pPrfItm->NumCounters * kMaxCounterSize;
        pPM->pPCB = (PPERF_COUNTER_BLOCK) ((PBYTE) pPM->pPCB +
                    (int) InstId * pPM->cbPCB);

        //
        // Instance names follow PERF_COUNTER_BLOCKs
        //
        pPM->pPIN = (LPWSTR) (pbEndOfCtrDefs +
                    (sizeof(PERF_INSTANCE_DEFINITION) + pPM->cbPCB) *
                    MaxInstances);
        pPM->cbPIN = pPrfItm->cchMaxInstName * sizeof(WCHAR);
        pPM->pPIN += pPrfItm->cchMaxInstName * (int) InstId;

    } else {
        //
        // PERF_COUNTER_BLOCK follows PERF_COUNTER_DEFINITION
        //
        pPM->pPCB = (PPERF_COUNTER_BLOCK) ((PBYTE) pPM->pPCD + pPM->cbPCD);
        pPM->cbPCB = sizeof(PERF_COUNTER_BLOCK) + (int) pPrfItm->NumCounters * kMaxCounterSize;
    }
}

//
// Returns the address of a counter in the shared data block
//

PBYTE CPrfData::GetCtr(CTRID CtrId, INSTID InstId) const
{
    int nCtrNum;

    OBJORD ObjOrd = CvtCtrIdToObjOrd(CtrId, &nCtrNum);
    PRFMETRICS pm;
    CalcPrfMetrics(ObjOrd, InstId, &pm);

    //
    // NOTE: for convenience, all counters are 64-bit values
    //
    return (PBYTE)pm.pPCB + sizeof(PERF_COUNTER_BLOCK) + nCtrNum*kMaxCounterSize;
}

//
// Converts an object/counter ID to its map index
//

CPrfData::PIINDEX CPrfData::CvtIdToPrfItmIndex(BOOL fObjectId, DWORD dwId) const
{
    for (PIINDEX pii = 0; m_pPrfItms[pii].pit != PIT_END; pii++) {

        if (fObjectId && (m_pPrfItms[pii].pit == PIT_OBJECT) &&
                (m_pPrfItms[pii].dwId == dwId)) {
            return(pii);
        }

        if (!fObjectId && (m_pPrfItms[pii].pit == PIT_COUNTER) &&
                (m_pPrfItms[pii].dwId == dwId)) {
            return(pii);
        }
    }

    return -1; // Not found
}

//
// Converts an object ID to its map ordinal
//

CPrfData::OBJORD CPrfData::CvtObjIdToObjOrd(OBJID ObjId) const
{
    for (OBJORD ObjOrd = 0; ObjOrd < m_nNumObjects; ObjOrd++) {
        if (CvtObjOrdToPrfItm(ObjOrd)->dwId == (DWORD) ObjId)
            return ObjOrd;
    }

    chASSERTFAIL(__FILE__, __LINE__, "Object ID Not in list");
    return (OBJORD)-1;
}

//
// Converts an objeict ordinal to its map index
//

CPrfData::PIINDEX CPrfData::CvtObjOrdToPrfItmIndex(OBJORD ObjOrd) const
{
    chASSERT(IsValidObjOrd(ObjOrd));
    PIINDEX pii = 0;

    for (; 0 != ObjOrd--; pii = m_pPrfItms[pii].IndexNextObj) {
        NULL;
    }

    return pii;
}

//
// Converts an object's ordinal to the address of its map info
//

CPrfData::PPRFITM CPrfData::CvtObjOrdToPrfItm(OBJORD ObjOrd) const
{
    return &m_pPrfItms[CvtObjOrdToPrfItmIndex(ObjOrd)];
}

//
// Converts a counter's ID to its map index
//

CPrfData::PIINDEX CPrfData::CvtCtrIdToPrfItmIndex(CTRID CtrId, int* pnCtrIndexInObj) const
{
    int nCtrIndexInObj = 0;
    PIINDEX pii = CvtIdToPrfItmIndex(FALSE, (DWORD) CtrId);

    if (pii != -1) {
        PIINDEX piiT = pii;
        while (m_pPrfItms[--piiT].pit != PIT_OBJECT) {
            nCtrIndexInObj++;
        }
    }

    if (pnCtrIndexInObj != NULL) {
        *pnCtrIndexInObj = nCtrIndexInObj;
    }

    return pii; // -1 if not found
}

//
// Converts a counter's ordinal to the address of its map info
//

CPrfData::PPRFITM CPrfData::CvtCtrOrdToPrfItm(OBJORD ObjOrd, CTRORD CtrOrd) const
{
    PPRFITM pPrfItm = CvtObjOrdToPrfItm(ObjOrd);
    return &pPrfItm[(int) CtrOrd + 1];
}

//
// Converts a counter's ID its owning object's ordinal
//

CPrfData::OBJORD  CPrfData::CvtCtrIdToObjOrd(CTRID CtrId, int* pnCtrIndexInObj) const
{
    PIINDEX pii = CvtCtrIdToPrfItmIndex(CtrId, pnCtrIndexInObj);
    OBJORD ObjOrd = 0;

    while (--pii > 0) {
        if (m_pPrfItms[pii].pit == PIT_OBJECT) ObjOrd++;
    }

    return ObjOrd;
}

//
// The following functions are only necessary in the collection DLL
// They are not needed by an app that simply updates the counters
//

#ifdef PRFDATA_COLLECT_SUPPORTED

extern "C" {

DWORD WINAPI PrfData_Open(LPWSTR /*lpDevNames*/)
{
    return ERROR_SUCCESS;
}

DWORD WINAPI PrfData_Close(void)
{
    return ERROR_SUCCESS;
}

DWORD WINAPI PrfData_Collect(LPWSTR lpValueName, LPVOID* lppData,
    LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes)
{
    //
    // Call the class's static Collect function to populate the passed
    // memory block with our performance info
    //
    return CPrfData::Collect(lpValueName, (PBYTE*)lppData,
        lpcbTotalBytes, lpNumObjectTypes);
}

}  // extern "C"

//
// This is a help class used to return only the requested objects
//

class CWhichCtrs {
public:
   CWhichCtrs(LPCWSTR pszObjNums = NULL);
   ~CWhichCtrs();
   BOOL IsNumInList(int nNum);

private:
   LPWSTR m_pszObjNums;
};

CWhichCtrs::CWhichCtrs(LPCWSTR pszObjNums)
{
    //
    // Save the list of requested object numbers
    //

    if ((lstrcmpiW(L"Global", pszObjNums) == 0)) {
        m_pszObjNums = NULL;
    } else {
        m_pszObjNums = (LPWSTR)HeapAlloc(GetProcessHeap(), 0,
                            (lstrlenW(pszObjNums) + 3) * sizeof(WCHAR));
        //
        // Put spaces around all the numbers
        //
        wsprintfW(m_pszObjNums, L" %s ", pszObjNums);
    }
}

CWhichCtrs::~CWhichCtrs()
{
    if (m_pszObjNums != NULL) {
        HeapFree(GetProcessHeap(), 0, m_pszObjNums);
    }
}

BOOL CWhichCtrs::IsNumInList(int nNum)
{
    BOOL fIsNumInList = TRUE;

    if (m_pszObjNums != NULL) {
        //
        // Put spaces around this number and see if it's in the list
        //
        WCHAR szNum[10];
        wsprintfW(szNum, L" %d ", nNum);
        fIsNumInList = (wcsstr(m_pszObjNums, szNum) != NULL);
    }
    return fIsNumInList;
}

//
// Determine which parent objects need to be collected
//

void CPrfData::DetermineObjsToCollect(OBJORD ObjOrd) const
{
    PPRFITM pPrfItm = CvtObjOrdToPrfItm(ObjOrd);

    //
    // Assume this object is being collected
    //
    chASSERT(pPrfItm->fCollectThisObj);

    if (pPrfItm->MaxInstances != (INSTID) PERF_NO_INSTANCES) {

        //
        // If this counter supports instances, collect the
        // counters that any instances refer to (recursively).
        //

        INSTID InstId = 0;

        for (; InstId < (INSTID) pPrfItm->MaxInstances; InstId++) {
            PRFMETRICS pm;
            CalcPrfMetrics(ObjOrd, InstId, &pm);

            if ( (pm.pPIN[0] != 0) && (pm.pPID->ParentObjectTitleIndex != 0)) {
                //
                // Instance is in use and refers to a parent object
                // Collect the parent object
                //
                PPRFITM pPrfItmParent = \
                    CvtObjIdToPrfItm((OBJID)pm.pPID->ParentObjectTitleIndex);

                if (pPrfItmParent->fCollectThisObj == FALSE) {
                    pPrfItmParent->fCollectThisObj = TRUE;
                    DetermineObjsToCollect(CvtObjIdToObjOrd((OBJID)pm.pPID->ParentObjectTitleIndex));
                }
            }
        }
    }
}

DWORD CPrfData::Collect(LPWSTR lpValueName, PBYTE* ppbData,
    LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes)
{
    DWORD dwErr = ERROR_SUCCESS;  // Assume success
    PBYTE ppbOriginalStartOfBuffer = *ppbData;

    //
    // Signal update event
    //
    chASSERT( sm_pPrfData->m_hEvent != NULL );
    SetEvent( sm_pPrfData->m_hEvent );

    //
    // Wrap everything inside an SEH frame so that we NEVER bring
    // down an app that is trying to collect our performance info
    //

    __try {
        //
        // While we do all this work, lock out other threads so that
        // our data structures do not become corrupted.
        //
        sm_pPrfData->LockCtrs();

        dwErr = sm_pPrfData->CollectAllObjs(lpValueName, ppbData,
                lpcbTotalBytes, lpNumObjectTypes);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        *ppbData = ppbOriginalStartOfBuffer;
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
    }

    sm_pPrfData->UnlockCtrs();
    return dwErr;
}

//
// Collects all of the requested objects
//

DWORD CPrfData::CollectAllObjs(LPWSTR lpValueName, PBYTE *ppbData,
    LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes) const
{
    //
    // lpValueName:      [in]  Set of object numbers requested
    // lppData:          [in]  Buffer where object info goes
    //                   [out] Address after our data
    // lpcbTotalBytes:   [in]  Size of buffer
    //                   [out] Bytes we put in buffer
    // lpNumObjectTypes: [in]  Ignore
    //                   [out] Number of objects we put in the buffer
    // Return Value:     ERROR_MORE_DATA or ERROR_SUCCESS
    //

    DWORD dwErr = ERROR_SUCCESS;
    CWhichCtrs CtrList(lpValueName);

    *lpNumObjectTypes = 0;

    //
    // Default to collecting none of our objects
    //
    for (OBJORD ObjOrd = 0; ObjOrd < m_nNumObjects; ObjOrd++) {
        CvtObjOrdToPrfItm(ObjOrd)->fCollectThisObj = FALSE;
    }

    //
    // Collect only the objects explicitly specified
    // and any instances' parent objects
    //
    for (ObjOrd = 0; ObjOrd < m_nNumObjects; ObjOrd++) {
        //
        // Should this object's counters be returned?
        //
        if (CtrList.IsNumInList(CvtObjOrdToPrfItmIndex(ObjOrd) * 2 + m_dwFirstCounter)) {
            CvtObjOrdToPrfItm(ObjOrd)->fCollectThisObj = TRUE;
            DetermineObjsToCollect(ObjOrd);
        }
    }

    //
    // Calculcate the bytes required for the desired objects
    //
    DWORD cbBytesForAllObjs = 0;
    for (ObjOrd = 0; ObjOrd < m_nNumObjects; ObjOrd++) {
        if (CvtObjOrdToPrfItm(ObjOrd)->fCollectThisObj)
            cbBytesForAllObjs += CalcBytesForPrfObj(ObjOrd);
    }

    if (*lpcbTotalBytes < cbBytesForAllObjs) {
        //
        // If buffer too small for desired objects, return failure
        //
        *lpcbTotalBytes = 0;
        dwErr = ERROR_MORE_DATA;
    } else {
        //
        // Buffer is big enough, append objects' data to buffer
        //
        *lpcbTotalBytes = 0;

        for (ObjOrd = 0; ObjOrd < m_nNumObjects; ObjOrd++) {
            if (CvtObjOrdToPrfItm(ObjOrd)->fCollectThisObj) {
                CollectAnObj(ObjOrd, ppbData);
                *lpcbTotalBytes += CalcBytesForPrfObj(ObjOrd);
                (*lpNumObjectTypes)++;
            }
        }
    }

    return dwErr;
}

DWORD CPrfData::CollectAnObj(OBJORD ObjOrd, PBYTE *ppbData) const
{
    chASSERT(IsValidObjOrd(ObjOrd));

    PRFMETRICS pm;
    CalcPrfMetrics(ObjOrd, 0, &pm);

    //
    // Append PERF_OBJECT_TYPE
    //
    CopyMemory(*ppbData, pm.pPOT, pm.cbPOT);
    PPERF_OBJECT_TYPE pPOT = (PPERF_OBJECT_TYPE) *ppbData;
    pPOT->TotalByteLength = CalcBytesForPrfObj(ObjOrd);
    pPOT->NumInstances = (pm.MaxInstances == PERF_NO_INSTANCES) ? \
        PERF_NO_INSTANCES : HowManyInstancesInUse(ObjOrd);
    *ppbData += pm.cbPOT;

    //
    // Append array of PERF_COUNTER_DEFINITIONs
    //
    CopyMemory(*ppbData, pm.pPCD, pm.cbPCD);
    *ppbData += pm.cbPCD;

    if (!pm.fSupportsInstances) {
        //
        // Append 1 PERF_COUNTER_BLOCK
        //
        CopyMemory(*ppbData, pm.pPCB, pm.cbPCB);
        *ppbData += pm.cbPCB;
    } else {
        //
        // Append PERF_INSTANCE_DEFINITION/PERF_COUNTER_BLOCKs
        //
        INSTID InstId = 0;
        for (; InstId < (INSTID) pm.MaxInstances; InstId++) {
            CalcPrfMetrics(ObjOrd, InstId, &pm);

            if (pm.pPIN[0] != 0) {  // This instance is in use

                //
                // Append PERF_INSTANCE_DEFINITIONs
                //
                CopyMemory(*ppbData, pm.pPID, pm.cbPID);
                PPERF_INSTANCE_DEFINITION pPID =
                (PPERF_INSTANCE_DEFINITION) *ppbData;
                *ppbData += pm.cbPID;

                pPID->ByteLength = sizeof(PERF_INSTANCE_DEFINITION);

                //
                // The ParentObjectTitleIndex contains the parent
                // object's ID. If this is not 0 (an invalid object ID),
                // convert the ID to the Performance Object number
                //
                if (pPID->ParentObjectTitleIndex != 0) {
                    PIINDEX pii = CvtObjIdToPrfItmIndex((OBJID) pm.pPID->ParentObjectTitleIndex);
                    pPID->ParentObjectTitleIndex =
                    m_dwFirstCounter + 2 * pii;

                    //
                    // Convert Instance ID to In-Use Instance number.
                    //
                    pPID->ParentObjectInstance =
                    CvtInstIdToInUseInstId(CvtObjIdToObjOrd(
                        (OBJID)pm.pPID->ParentObjectTitleIndex),
                        (INSTID)pm.pPID->ParentObjectInstance
                        );
                }

                //
                // Append instance name after PERF_INSTANCE_DEFINITION
                //
                if (pPID->UniqueID == PERF_NO_UNIQUE_ID) {
                    DWORD cchName = lstrlenW(pm.pPIN) + 1;
                    DWORD cbName = cchName * sizeof(WCHAR);
                    CopyMemory(*ppbData, pm.pPIN, cbName);

                    //
                    // If an odd number of characters, add 2 bytes so
                    // that next structure starts on 32-bit boundary
                    //
                    if ((cchName & 1) == 1) {
                        cbName += 2;
                    }

                    *ppbData += cbName;
                    pPID->ByteLength += cbName;
                }

                //
                // Append PERF_COUNTER_BLOCK to the buffer
                //
                CopyMemory(*ppbData, pm.pPCB, pm.cbPCB);
                *ppbData += pm.cbPCB;
            }
        }
    }

    return ERROR_SUCCESS;
}

DWORD CPrfData::CalcBytesForPrfObj(OBJORD ObjOrd) const
{
    chASSERT(IsValidObjOrd(ObjOrd));
    PRFMETRICS pm;
    CalcPrfMetrics(ObjOrd, 0, &pm);
    DWORD cbBytesNeeded = pm.cbPOT + pm.cbPCD;

    if (!pm.fSupportsInstances) {
        cbBytesNeeded += pm.cbPCB;
    } else {
        cbBytesNeeded += (pm.cbPID + pm.cbPCB) * HowManyInstancesInUse(ObjOrd);

        INSTID InstId = 0;
        for (; InstId < (INSTID) pm.MaxInstances; InstId++) {
            CalcPrfMetrics(ObjOrd, InstId, &pm);
            if (pm.pPIN[0] != 0) {
                DWORD cch = lstrlenW(pm.pPIN) + 1;  // For 0 character

                if ((cch & 1) == 1) {
                    cch++;
                }

                //
                // If an odd number of characters, add 2 bytes so
                // that next structure starts on 32-bit boundary
                //
                cbBytesNeeded += sizeof(WCHAR) * cch;
            }
        }
    }

    return cbBytesNeeded;
}

int CPrfData::HowManyInstancesInUse(OBJORD ObjOrd) const
{
    chASSERT(IsValidObjOrd(ObjOrd));
    PRFMETRICS pm;
    CalcPrfMetrics(ObjOrd, 0, &pm);
    chASSERT(pm.fSupportsInstances);

    int nNumInstancesInUse = 0;
    INSTID InstId = 0;

    for (; InstId < (INSTID) pm.MaxInstances; InstId++) {
        if (pm.pPIN[0] != 0) nNumInstancesInUse++;
        pm.pPIN += pm.cbPIN / sizeof(pm.pPIN[0]);
    }

    return nNumInstancesInUse;
}

int CPrfData::CvtInstIdToInUseInstId(OBJORD ObjOrd, INSTID InstId) const
{
    chASSERT(IsValidInstId(ObjOrd, InstId));
    int nIndexInstInUse = 0;

    for (; InstId > 0; InstId--) {
        PRFMETRICS pm;
        CalcPrfMetrics(ObjOrd, InstId, &pm);
        if (pm.pPIN[0] != 0) {
            nIndexInstInUse++;
        }
    }

    return nIndexInstInUse;
}

#endif // PRFDATA_COLLECT_SUPPORTED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\PrfData.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PrfData.cpp

Abstract:

    This module implements the C++ template classes for Performance
    Object data types.

Author:

    Jeffrey M. Richter (v-jeffrr) 01-Aug-1998

--*/

#pragma once

#include <WinPerf.H>       // Not included by "Windows.H"
#include "Optex.h"         // High-speed, cross-process, critical section
#include "RegSettings.h"   // Class to make it easy to work with the registry

//
// I use this to declare type-safe values
//

#define DECLARE_VALUE(name)          \
   struct name##__ { BYTE unused; }; typedef struct name##__ *name

class CPrfData {

public:     // Static member functions for install/uninstall
   // Installs the performance DLL info into the registry
   static void Install(LPCWSTR pszDllPathname);

   // Removes the performance DLL info from the registry
   static void Uninstall();


public:     // Static member function to activate counter information
   // Creates and initializes the shared counter data block
   static DWORD Activate(); // Returns last error


public:
   // The following should not be used directly. They are public because
   // of the BEGIN_PRFITEM_MAP/PRFOBJ/PRFCTR/END_PRFITEM_MAP macros (below)

   // The types of record that can be in a PRFITEM map
   typedef enum { PIT_END, PIT_OBJECT, PIT_COUNTER } PRFITMTYPE;

   // Data types to make the code more readable
   typedef int PIINDEX;
   DECLARE_VALUE(OBJORD);
   DECLARE_VALUE(CTRORD);
   DECLARE_VALUE(OBJID);
   DECLARE_VALUE(CTRID);
   DECLARE_VALUE(INSTID);

   // Each object/counter is identified with this information
   typedef struct _PRFITM {
      PRFITMTYPE pit;
      // The following fields apply to both PIT_OBJECT & PIT_COUNTER
      DWORD    dwId;
      LPCWSTR  pwszName;
      LPCWSTR  pwszHelp;
      DWORD    dwDetailLevel;

      // The following fields apply to PIT_OBJECT only
      CTRID    DefCounter;
      INSTID   MaxInstances;
      DWORD    cchMaxInstName;
      CTRORD   NumCounters;
      PIINDEX  IndexNextObj;
      DWORD    cbOffsetToNextObj;
      BOOL     fCollectThisObj;

      // The following fields apply to PIT_COUNTER only
      DWORD    dwDefaultScale;
      DWORD    dwCounterType;

      // The actual DM counter information
      DM_COUNTINFO  dmci;
   } PRFITM, *PPRFITM;


public:  // Public member functions
   // Constructs a CPrfData
   CPrfData(LPCWSTR pszAppName, PPRFITM pPrfItms);

   // Destructs a CPrfData
   ~CPrfData();

   // Functions to allow mutual exclusive access to counter data
   void LockCtrs() const;
   BOOL TryLockCtrs() const;
   void UnlockCtrs() const;

   // Adds an instance to an object (returns InstId)
   INSTID AddInstance(OBJID ObjId, LONG lUniqueId,
      OBJID ObjIdParent = 0, INSTID InstIdParent = 0);
   INSTID AddInstance(OBJID ObjId, LPCWSTR pszInstName,
      OBJID ObjIdParent = 0, INSTID InstIdParent = 0);

   // Removes an instance from an object
   void RemoveInstance(OBJID ObjId, INSTID InstId);

   // Returns 32-bit address of counter in shared data block
   LONG& GetCtr32(CTRID CtrId, INSTID InstId = 0) const;

   // Returns 64-bit address of counter in shared data block
   __int64& GetCtr64(CTRID CtrId, INSTID InstId = 0) const;

   // Returns pointer to DM_COUNTINFO of the counter
   const DM_COUNTINFO* GetDmCtr(CTRID CtrId) const;

   // Assigns dynamic PRFITM
   void AssignDynamicPerfItems(PPRFITM pPrfItms);

private: // For debugging
   BOOL     IsValidObjOrd(OBJORD ObjOrd) const;
   BOOL     IsValidInstId(OBJORD ObjOrd, INSTID InstId) const;


private: // Fuctions for install/remove
   void     VerifyPrfItemTable();
   void     InstallPrfData(LPCWSTR pszDllPathname);
   void     UninstallPrfData();
   void     AppendRegStrings(CRegSettings& regPerfLib,
                             BOOL fCounter, PDWORD pdwIndex);
   void     RemoveRegStrings(CRegSettings& regPerfLib,
                             BOOL fCounter,DWORD dwIndexLo, DWORD dwIndexHi);


private: // Data types used internally by the class
   enum { kMaxCounterSize = sizeof(__int64) };
   enum {
      PERF_MASK_SIZE_FLD      = 0x00000300,
      PERF_MASK_CTR_TYPE      = 0x00000C00,
      PERF_MASK_CTR_SUBTYPE   = 0x000F0000,
      PERF_MASK_TIME_BASE     = 0x00300000,
      PERF_MASK_CALC_MODS     = 0x0FC00000,
      PERF_MASK_DISPLAY_FLAGS = 0xF0000000
   };
   typedef struct {
      BOOL                      fSupportsInstances;
      long                      MaxInstances;
      PPERF_OBJECT_TYPE         pPOT;
      int                       cbPOT;
      PPERF_COUNTER_DEFINITION  pPCD;
      int                       cbPCD;
      PPERF_INSTANCE_DEFINITION pPID;
      int                       cbPID;
      PPERF_COUNTER_BLOCK       pPCB;
      int                       cbPCB;
      LPWSTR                    pPIN;
      int                       cbPIN;
   } PRFMETRICS, *PPRFMETRICS;


private: // Functions to convert betwen value types
   DWORD   ActivatePrfData(); // Returns last error

   void    CalcPrfMetrics(OBJORD ObjOrd, INSTID InstId,
      PPRFMETRICS pPM, PPRFITM* ppPrfItm = NULL) const;

   PIINDEX CvtIdToPrfItmIndex(BOOL fObjectId, DWORD dwId) const;

   PIINDEX CvtObjIdToPrfItmIndex(OBJID ObjId) const;
   OBJORD  CvtObjIdToObjOrd(OBJID ObjId) const;
   PIINDEX CvtObjOrdToPrfItmIndex(OBJORD ObjOrd) const;
   PPRFITM CvtObjOrdToPrfItm(OBJORD ObjOrd) const;
   PPRFITM CvtObjIdToPrfItm(OBJID ObjId) const;

   PIINDEX CvtCtrIdToPrfItmIndex(CTRID CtrId, int* pnCtrIndexInObj = NULL) const;
   PPRFITM CvtCtrOrdToPrfItm(OBJORD ObjOrd, CTRORD CtrOrd) const;
   OBJORD  CvtCtrIdToObjOrd(CTRID CtrId, int* pnCtrIndexInObj = NULL) const;
   PPRFITM CvtCtrIdToPrfItm(CTRID CtrId) const;

   PBYTE   GetCtr(CTRID CtrId, INSTID InstId) const;
   INSTID  FindFreeInstance(OBJORD ObjOrd) const;
   INSTID  AddInstance(OBJID ObjId, LPCWSTR pszInstName,
      LONG lUniqueId, OBJID ObjIdParent, INSTID InstIdParent);


#ifdef PRFDATA_COLLECT_SUPPORTED
public:  // Static function required to support PrfData collection
   static DWORD Collect(LPWSTR lpValueName, PBYTE* ppbData,
      LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes);

private: // Functions required to support PrfData collection
   void     DetermineObjsToCollect(OBJORD ObjOrd) const;
   DWORD    CollectAllObjs(LPWSTR lpValueName, PBYTE *ppbData,
      LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes) const;
   DWORD    CollectAnObj(OBJORD ObjOrd, PBYTE *ppbData) const;
   DWORD    CalcBytesForPrfObj(OBJORD ObjOrd) const;
   int      HowManyInstancesInUse(OBJORD ObjOrd) const;
   int      CvtInstIdToInUseInstId(OBJORD ObjOrd, INSTID InstId) const;
#endif


private: // static member that points to the 1 instance of this class
   static CPrfData* sm_pPrfData;


private: // Internal data members to support the class
   LPCWSTR  m_pszAppName;     // App name for registry
   DWORD    m_dwFirstCounter; // 1st object/counter index
   DWORD    m_dwFirstHelp;    // 1st object/counter help index
   DWORD    m_dwLastCounter;  // Last object/counter index
   DWORD    m_dwLastHelp;     // Last object/counter help index

   PPRFITM  m_pPrfItms;       // Array of object/counter structures
   PIINDEX  m_nNumPrfItems;   // Number of items in the array
   OBJORD   m_nNumObjects;    // Num objects in array

   HANDLE   m_hfm;            // File mapping for shared data
   PBYTE    m_pPrfData;       // Mapped view of shared data
   mutable  COptex m_Optex;   // Protects access to shared data

private:
   HANDLE   m_hEvent;
public:
   HANDLE   GetUpdateEventHandle() { return m_hEvent; }
};

///////////////////////////////////////////////////////////////////////////////
// Inline functions.  See above for descriptions

inline void CPrfData::Install(LPCWSTR pszDllPathname)
{
   sm_pPrfData->InstallPrfData(pszDllPathname);
}

inline void CPrfData::Uninstall()
{
   sm_pPrfData->UninstallPrfData();
}

inline DWORD CPrfData::Activate()
{
   return(sm_pPrfData->ActivatePrfData());
}

inline BOOL CPrfData::IsValidObjOrd(OBJORD ObjOrd) const
{
   return(chINRANGE(0, ObjOrd, m_nNumObjects - 1));
}

inline BOOL CPrfData::IsValidInstId(OBJORD ObjOrd, INSTID InstId) const
{
   return(IsValidObjOrd(ObjOrd) && chINRANGE(0, InstId,
      (CvtObjOrdToPrfItm(ObjOrd)->MaxInstances ==
         (INSTID) PERF_NO_INSTANCES) ? 0 :
         CvtObjOrdToPrfItm(ObjOrd)->MaxInstances - 1));
}

inline void CPrfData::LockCtrs() const
{
    m_Optex.Enter();
}

inline BOOL CPrfData::TryLockCtrs() const
{
    return(m_Optex.TryEnter());
}

inline void CPrfData::UnlockCtrs() const
{
    m_Optex.Leave();
}

inline CPrfData::INSTID CPrfData::AddInstance(OBJID ObjId,
    LONG lUniqueId, OBJID ObjIdParent, INSTID InstIdParent)
{
   return(AddInstance((OBJID) ObjId, NULL,
      lUniqueId, ObjIdParent, InstIdParent));
}

inline CPrfData::INSTID CPrfData::AddInstance(OBJID ObjId,
   LPCWSTR pszInstName, OBJID ObjIdParent, INSTID InstIdParent) {
   return(AddInstance((OBJID) ObjId, pszInstName,
      PERF_NO_UNIQUE_ID, ObjIdParent, InstIdParent));
}

inline LONG& CPrfData::GetCtr32(CTRID CtrId, INSTID InstId) const
{
   // Make sure the caller wants the right-size for this counter
   chASSERT((CvtCtrIdToPrfItm(CtrId)->dwCounterType & PERF_MASK_SIZE_FLD)
      == PERF_SIZE_DWORD);
   return(* (PLONG) GetCtr(CtrId, InstId));
}

inline __int64& CPrfData::GetCtr64(CTRID CtrId, INSTID InstId) const
{
   // Make sure the caller wants the right-size for this counter
   chASSERT((CvtCtrIdToPrfItm(CtrId)->dwCounterType & PERF_MASK_SIZE_FLD)
      == PERF_SIZE_LARGE);
   return(* (__int64*) GetCtr(CtrId, InstId));
}

inline const DM_COUNTINFO* CPrfData::GetDmCtr(CTRID CtrId) const
{
    return &CvtCtrIdToPrfItm(CtrId)->dmci;
}

inline CPrfData::PIINDEX CPrfData::CvtObjIdToPrfItmIndex(OBJID ObjId) const
{
   return((CPrfData::PIINDEX) CvtIdToPrfItmIndex(TRUE, (DWORD) ObjId));
}

inline CPrfData::PPRFITM CPrfData::CvtObjIdToPrfItm(OBJID ObjId) const
{
   return(&m_pPrfItms[(int) CvtObjIdToPrfItmIndex(ObjId)]);
}

inline CPrfData::PPRFITM CPrfData::CvtCtrIdToPrfItm(CTRID CtrId) const
{
   return(&m_pPrfItms[(int) CvtCtrIdToPrfItmIndex(CtrId)]);
}

inline void CPrfData::AssignDynamicPerfItems(PPRFITM pPrfItms)
{
   m_pPrfItms = pPrfItms;
   VerifyPrfItemTable();
}

extern CPrfData g_PrfData;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\PrfDataMap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    prfdatamap.h

Abstract:

    This module implements PerfMon's plugin that polls various performance
    counters from Xbox using debug channel

--*/

#include "PrfData.h"

//
// ID of string resource
//

#define IDS_USAGE       0x100
#define IDS_PER_SECOND  0x101

//
// ID of dialog
//

#define IDD_CONNECTING  0x200
#define IDC_STATIC_TEXT 0x201
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\xbprfmonp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbprfmonp.h

Abstract:

    This is a pre-compiled header file for Xbox PerfMon

--*/

#include <stdio.h>
#include <windows.h>
#include <shellapi.h>
#include <xboxdbg.h>
#include <tchar.h>
#include <stdlib.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof((a)[0]))

#define chINRANGE(low, Num, High) (((low) <= (Num)) && ((Num) <= (High)))

#define chFAIL(szMSG) {                                                   \
      MessageBox(GetActiveWindow(), szMSG,                                \
         __TEXT("Assertion Failed"), MB_OK | MB_ICONERROR);               \
      DebugBreak();                                                       \
   }

//
// Put up an assertion failure message box.
//

#define chASSERTFAIL(file,line,expr) {                                    \
      TCHAR __sz[128];                                                      \
      wsprintf(__sz, __TEXT("File %hs, line %d : %hs"), file, line, expr);  \
      chFAIL(__sz);                                                         \
   }

//
// Put up a message box if an assertion fails in a debug build.
//

#ifdef _DEBUG
#define chASSERT(x) if (!(x)) chASSERTFAIL(__FILE__, __LINE__, #x)
#else
#define chASSERT(x)
#endif

//
// Assert in debug builds, but don't remove the code in retail builds.
//

#ifdef _DEBUG
#define chVERIFY(x)         chASSERT(x)
#else
#define chVERIFY(x)         (x)
#endif

#define XBPRFMON_UUID_STR   _T("e0b8131e-091c-4f6b-914e-353a0b09996c")

#include "Optex.h"
#include "PrfData.h"
#include "PrfDataMap.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\plugin\xbprfdll.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbprfdll.cpp

Abstract:

    This module implements PerfMon's plugin that polls various performance
    counters from Xbox using debug channel

--*/

#include "xbprfmonp.h"

#if !defined(PRFDATA_COLLECT_SUPPORTED)
#error PRFDATA_COLLECT_SUPPORTED must be defined for this project
#endif

BOOL
WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    /*lpReserved*/
    )
{
    if ( dwReason == DLL_PROCESS_ATTACH ) {
        DisableThreadLibraryCalls( hInstance );
        return CPrfData::Activate() == ERROR_SUCCESS;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\setup\common\common.h ===
//  COMMON.H
//
//  Created 24-Mar-2001 [JonT]

#ifndef _COMMON_H_
#define _COMMON_H_

#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>

#endif // #ifndef _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbprfmon\stub\xbprfmon.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbprfmon.cpp

Abstract:

    This module implements custom PerfMon DLL for Xbox performance
    monitoring.  It polls various performance counters from Xbox using
    debug channel.

--*/

#include "xbprfmonp.h"

SIZE_T g_TotalCounters;
ULONG  g_FirstCounterId;
HINSTANCE g_hInstance;
DWORD g_ConnectionTimeout = 2000;

VOID
WINAPI
EstablishConnection(
    BOOL* fConnectionLost
    )
{
    HRESULT hr;

    DmUseSharedConnection( FALSE );

    for (;;) {
        hr = DmUseSharedConnection( TRUE );
        if ( SUCCEEDED(hr) ) {
            *fConnectionLost = FALSE;
            DmSetConnectionTimeout(g_ConnectionTimeout, g_ConnectionTimeout);
            break;
        }
    }
}

VOID
WINAPI
PollPerformanceData(
    VOID
    )
/*++

Routine Description:

    This routine polls various performance counters from Xbox using debug
    channel (DM APIs) and update into shared memory area for reading by
    xbprfdll.dll

Arguments:

    None

Return Value:

    None

--*/
{
    SIZE_T count;
    HRESULT hr;
    INT64 Value;
    HANDLE hThread;
    BOOL fConnectionLost = FALSE;

    for (;;) {

        WaitForSingleObject( g_PrfData.GetUpdateEventHandle(), INFINITE );

        //
        // BUGBUG: right now this is ugly, client shouldn't have to keep track
        // of number of PO/CO, CPrfData should expose interface to do so
        //

        for ( count=0; count<g_TotalCounters; count++ ) {

            const DM_COUNTINFO* pdmci = g_PrfData.GetDmCtr(
                (CPrfData::CTRID)count+g_FirstCounterId );
            DWORD dwType = pdmci->Type;
            DWORD dwQuery = dwType & DMCOUNT_COUNTTYPE;
            DM_COUNTDATA dmcd;

            if ( dwQuery & DMCOUNT_EVENT || dwQuery & DMCOUNT_PRATIO ) {
                dwQuery |= DMCOUNT_PERSEC;
            }

            if ( !fConnectionLost ) {
                hr = DmQueryPerformanceCounter( pdmci->Name, dwQuery, &dmcd );
            } else {
                ZeroMemory( &dmcd, sizeof(dmcd) );
                hr = E_UNEXPECTED;
            }

            if ( FAILED(hr) ) {
                Value = 0;
                if ( hr == XBDM_CONNECTIONLOST ) {
                    hThread = CreateThread( 0, 0, (LPTHREAD_START_ROUTINE)EstablishConnection,
                                            (LPVOID)&fConnectionLost, 0, 0 );
                    if ( hThread ) {
                        fConnectionLost = TRUE;
                        CloseHandle( hThread );
                    }
                }
            } else {
                if ( dwQuery & DMCOUNT_PRATIO ) {
                    Value = (INT64)(100.0 * (double)dmcd.CountValue.QuadPart/(double)dmcd.RateValue.QuadPart);
                } else if ( dwQuery & DMCOUNT_EVENT ) {
                    Value = (INT64)((double)dmcd.CountValue.QuadPart/(double)dmcd.RateValue.QuadPart);
                } else {
                    Value = dmcd.CountValue.QuadPart;
                }
            }
            g_PrfData.GetCtr64( (CPrfData::CTRID)count+g_FirstCounterId ) = Value;
        }
    }
}

VOID
XbPrfMonTranslateDmError(
    IN HRESULT Hr
    )
/*++

Routine Description:

    This routine translates HRESULT from DM APIs, displays the results
    using MessageBox API

Arguments:

    Hr - HRESULT returned vt various DM APIs

Return Value:

    None

--*/
{
    CHAR Buffer[512];

    DmTranslateErrorA( Hr, Buffer, ARRAYSIZE(Buffer) );
    MessageBoxA( 0, Buffer, "XbPerfMon",
                 MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
}

VOID
XbPrfMonReportError(
    DWORD Error,
    LPCTSTR Format = NULL,
    ...
    )
/*++

Routine Description:

    This routine translates Win32 error code into human-readable text and
    displays it using MessageBox API

Arguments:

    Error - Win32 error code

Return Value:

    None

--*/
{
    LPTSTR p;
    va_list argptr;
    LPVOID lpMsgBuf;
    TCHAR Buffer[512];

    va_start( argptr, Format );

    Buffer[0] = '\n';

    if ( Format ) {
        wvsprintf( &Buffer[1], Format, argptr );
    } else {
        Buffer[0] = _T('\0');
    }

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Error,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR)&lpMsgBuf,
        0,
        NULL
        );

    p = (LPTSTR)LocalReAlloc( lpMsgBuf,
            (lstrlen((LPTSTR)lpMsgBuf)+lstrlen(Buffer)+3) * sizeof(TCHAR), 0 );

    if ( p ) {
        lpMsgBuf = p;
        lstrcat( p, Buffer );
    }

    MessageBox( NULL, (LPCTSTR)lpMsgBuf, _T("XbPerfMon"),
                MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL );
    LocalFree( lpMsgBuf );
    va_end( argptr );
}

HANDLE
ExecutePerfMon(
    IN int nCmdShow,
    IN PCWSTR pwszClientName OPTIONAL
    )
/*++

Routine Description:

    This routines invokes perfmon.exe from default search path, waits until
    perfmon terminated and returns

Arguments:

    nCmdShow - Flags that specify how perfmon is to be displayed when it
        is opened. It can be one of the SW_XXX flags

Return Value:

    Process handle of PerfMon.exe

--*/
{
    BOOL b;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR CmdLine[256];
    HANDLE hThread;

    ZeroMemory( &pi, sizeof(pi) );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = (WORD)nCmdShow;

    if ( pwszClientName ) {
        ExpandEnvironmentStrings(
            pwszClientName, CmdLine, ARRAYSIZE(CmdLine) );
    } else {
        ExpandEnvironmentStrings(
            _T("mmc.exe %windir%\\system32\\perfmon.msc"), CmdLine,
            ARRAYSIZE(CmdLine) );
    }

    b = CreateProcess( 0, CmdLine, 0, 0, TRUE, NORMAL_PRIORITY_CLASS,
                       0, 0, &si, &pi );

    if ( b ) {

        CloseHandle( pi.hThread );
        hThread = CreateThread( 0, 0, (LPTHREAD_START_ROUTINE)PollPerformanceData, 0, 0, 0 );

        if ( hThread ) {
            CloseHandle( hThread );
            return pi.hProcess;
        }

        CloseHandle( pi.hProcess );
    }

    XbPrfMonReportError( GetLastError(), CmdLine );
    return NULL;
}

BOOL
XbPrfMonDisplayUsage(
    VOID
    )
/*++

Routine Description:

    This routine desplay program's command line usage using MessageBox API.
    The command line usage text is stored in string resource so that it
    can be localized.

Arguments:

    None

Return Value:

    Always TRUE (not used)

--*/
{
    TCHAR szText[512];

    LoadString( NULL, IDS_USAGE, szText, ARRAYSIZE(szText) );
    MessageBox( NULL, szText, _T("XbPerfMon"), MB_OK | MB_ICONINFORMATION );
    return TRUE;
}

VOID
InitializePerformanceObject(
    OUT CPrfData::PPRFITM p,
    IN  DWORD  dwId,
    IN  LPCWSTR  pszName,
    IN  LPCWSTR  pszHelp,
    IN  DWORD  CtrIdDefCounter,
    IN  LONG   lMaxInstances,
    IN  DWORD  cchMaxInstName
    )
{
    ZeroMemory( p, sizeof(*p) );
    p->pit = CPrfData::PIT_OBJECT;
    p->dwId = dwId;
    p->pwszName = pszName;
    p->pwszHelp = pszHelp;
    p->dwDetailLevel = PERF_DETAIL_NOVICE;
    p->DefCounter = (CPrfData::CTRID)CtrIdDefCounter;
    p->MaxInstances = (CPrfData::INSTID)lMaxInstances;
    p->cchMaxInstName = cchMaxInstName;
    p->fCollectThisObj = FALSE;
}

HRESULT
InitializeCounterObject(
    OUT CPrfData::PPRFITM p,
    IN DWORD  dwId,
    IN PDM_COUNTINFO pdmci,
    IN BOOL  Sentinel = FALSE
    )
{
    PWSTR pw;
    SIZE_T AllocSize;

    ZeroMemory( p, sizeof(*p) );

    p->pit = Sentinel ? CPrfData::PIT_END : CPrfData::PIT_COUNTER;
    p->dwId = dwId;
    p->dwDetailLevel = PERF_DETAIL_NOVICE;
    p->DefCounter = (CPrfData::CTRID)-1;

    if ( !pdmci ) {
        return NOERROR;
    }

    memcpy( &p->dmci, 