return FALSE;
}

IUnknown *CIPCompDoc::GetTrackSelection()
{
	ASSERT(NULL != m_pIpCompSlob);
	if(NULL == m_pIpCompSlob)
		return NULL;
	else
		return m_pIpCompSlob->GetTrackSelection();
}

IUnknown *CIPCompDoc::GetUndoActionManager()
{
	return m_srpUndoMgr;
}

IMsoCommandTarget * CIPCompDoc::GetSupportingTarget(GUID * pguid,
		DWORD cmdid, DWORD rgf)
{
	if (m_pItem == NULL)
		return NULL;

	CIPCompFrameHook *pFrameHook = (CIPCompFrameHook *)(m_pItem->m_pInPlaceFrame);

	return (pFrameHook != NULL) ?
				pFrameHook->GetSupportingTarget(pguid, cmdid, rgf) :
				NULL;
}

void CIPCompDoc::SetIPCComboEditText(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf)
{
	if (m_pItem == NULL)
		return;

	CIPCompFrameHook *pFrameHook = (CIPCompFrameHook *)(m_pItem->m_pInPlaceFrame);

	if (pFrameHook != NULL)
	{
		pFrameHook->SetIPCComboEditText(pcombo, pguid, cmdid, rgf);
	}
}

void CIPCompDoc::FillIPCCombo(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf)
{
	if (m_pItem == NULL)
		return;

	CIPCompFrameHook *pFrameHook = (CIPCompFrameHook *)(m_pItem->m_pInPlaceFrame);

	if (pFrameHook != NULL)
	{
		pFrameHook->FillIPCCombo(pcombo, pguid, cmdid, rgf);
	}
}

void CIPCompDoc::OnIPCComboSelect(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf)
{
	if (m_pItem == NULL)
		return;

	CIPCompFrameHook *pFrameHook = (CIPCompFrameHook *)(m_pItem->m_pInPlaceFrame);

	if (pFrameHook != NULL)
	{
		pFrameHook->OnIPCComboSelect(pcombo, pguid, cmdid, rgf);
	}
}

void CIPCompDoc::OnIPCComboEnter(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf)
{
	if (m_pItem == NULL)
		return;

	CIPCompFrameHook *pFrameHook = (CIPCompFrameHook *)(m_pItem->m_pInPlaceFrame);

	if (pFrameHook != NULL)
	{
		pFrameHook->OnIPCComboEnter(pcombo, pguid, cmdid, rgf);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CIPCompDoc serialization

void CIPCompDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class CPartDoc enables serialization
	//  of the container document's COleClientItem objects.
	CPartDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CIPCompDoc diagnostics

#ifdef _DEBUG
void CIPCompDoc::AssertValid() const
{
	CPartDoc::AssertValid();
}

void CIPCompDoc::Dump(CDumpContext& dc) const
{
	CPartDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CIPCompDoc commands
VOID
CIPCompDoc::OnEditUndo()
{
	if (m_srpUndoMgr == NULL)
		return;

	int cReps = max(1, theApp.GetCmdArg());

	for (int i = 0; i < cReps && !m_srpUndoMgr->IsUndoEmpty(); i++)
	{
		m_srpUndoMgr->UndoTo(NULL);
	}
	theApp.ClearRepCount();
}

VOID
CIPCompDoc::OnEditRedo()
{
	if (m_srpUndoMgr == NULL)
		return;

	int cReps = max(1, theApp.GetCmdArg());

	for (int i = 0; i < cReps && !m_srpUndoMgr->IsRedoEmpty(); i++)
	{
		m_srpUndoMgr->RedoTo(NULL);
	}
	theApp.ClearRepCount();
}

void CIPCompDoc::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
	// Enable/disable the entry
	pCmdUI->Enable(m_srpUndoMgr != NULL	&& !m_srpUndoMgr->IsUndoEmpty());
}

void CIPCompDoc::OnUpdateEditRedo(CCmdUI* pCmdUI)
{
	// Enable/disable the entry
	pCmdUI->Enable(m_srpUndoMgr != NULL && !m_srpUndoMgr->IsRedoEmpty());
}

LRESULT
CIPCompDoc::GetUndoRedoString(WPARAM nLevel, LPARAM lpstr,
		UINT cchBuf, BOOL fUndo)
{
	USES_CONVERSION;
	HRESULT hr;

	if (m_srpUndoMgr == NULL)
		return FALSE;

	COleRef<IEnumOleUndoUnits> srpEnum;
	COleRef<IOleUndoUnit> srpUndoAction;

	if (fUndo)
	{
		hr = m_srpUndoMgr->EnumUndoable(&srpEnum);
	}
	else
	{
		hr = m_srpUndoMgr->EnumRedoable(&srpEnum);
	}

	if (!SUCCEEDED(hr) || srpEnum == NULL)
		return FALSE;

	//nLevel is zero based.
	//
	hr = srpEnum->Skip(nLevel);
	if (!SUCCEEDED(hr))
		return FALSE;

	hr = srpEnum->Next(1, &srpUndoAction, NULL);

	if (!SUCCEEDED(hr) || hr == S_FALSE || srpUndoAction == NULL)
		return FALSE;

	BSTR bstr;
	hr = srpUndoAction->GetDescription(&bstr);

	if (!SUCCEEDED(hr))
		return FALSE;

	// convert the bstr into an lpstr and copy it into lpstr
	//
	lstrcpyn((LPSTR)lpstr, OLE2T((WCHAR *)bstr), cchBuf);
	SysFreeString(bstr);

	return (lstrlen((LPSTR)lpstr) != 0);
}

IOleObject * CIPCompDoc::GetOleObject()
{
	return (m_pItem ? m_pItem->m_lpObject : NULL);
}

IStorage * CIPCompDoc::GetStorage()
{
	return (m_pItem ? m_pItem->m_lpStorage : NULL);
}

CSlob *	CIPCompDoc::GetSlob()
{
	return m_pIpCompSlob;
}

void CIPCompDoc::BeginUndo(LPCTSTR szDescription)
{
	USES_CONVERSION;

	ASSERT(szDescription);
	ASSERT(m_srpUndoMgr);

	COleParentUndoUnit * pCUA = 
		new COleParentUndoUnit(atUndoAction, T2OLE(szDescription));
	pCUA->AddRef();
	m_UndoStack.AddHead(pCUA);
	m_srpUndoMgr->Open(pCUA);
	pCUA->Release();
}

BOOL CIPCompDoc::SetUndoStringMgr(IPropertyPageUndoString *pPPUS)
{
	ASSERT(NULL != pPPUS);
	ASSERT(m_srpUndoStrMgr == NULL);
	if(NULL == pPPUS || m_srpUndoStrMgr != NULL)
		return FALSE;

	pPPUS->AddRef();
	m_srpUndoStrMgr = pPPUS;
	return TRUE;
}

void CIPCompDoc::EndUndo(BOOL bAbort /*= FALSE*/)
{
	ASSERT(m_srpUndoMgr);
	ASSERT(!m_UndoStack.IsEmpty());

	LPOLESTR pStr = NULL;
	COleParentUndoUnit *pCUA = m_UndoStack.RemoveHead();
	ASSERT(NULL !=pCUA);
	if(!pCUA->IsUndoActionListEmpty() && !bAbort)
	{
		if(m_srpUndoStrMgr != NULL && SUCCEEDED(m_srpUndoStrMgr->GetUndoString(&pStr)))
		{
 			USES_CONVERSION;
			ASSERT(NULL != pStr);
			pCUA->SetUndoDesc(OLE2T(pStr));
			AfxFreeTaskMem(pStr);
		}
		m_srpUndoMgr->Close(pCUA, !bAbort);
	}
	else
		m_srpUndoMgr->Close(pCUA, FALSE /*don't commit*/);

	m_srpUndoStrMgr.SRelease();
}

HRESULT	CIPCompDoc::GetService(REFGUID guidService, REFIID riid, void **ppvObj)
{
	IUnknown *punk = NULL;

	if(NULL == ppvObj)
		return E_INVALIDARG;

	*ppvObj = NULL;

	if(SID_STrackSelection == guidService)
	{
		// this is an non-addref'ed pointer
		punk = GetTrackSelection();
	}
	// the Service ID for the Undo Action Manager is the same
	// as the Interface ID for IOleUndoManager.
	else if(IID_IOleUndoManager == guidService)
	{
		// this is an non-addref'ed pointer
		punk = m_srpUndoMgr;
	}

	if(NULL != punk)
		return punk->QueryInterface(riid, ppvObj);
	else
		return E_NOINTERFACE;
}

HRESULT CIPCompDoc::ShowIPCHelp(DWORD dwCompRole, REFCLSID rclsidComp,
		POINT posMouse, DWORD dwHelpCmd, LPOLESTR pwszHelpFile, DWORD dwData)
{
	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
// CDocObjectTemplate commands

CIPCompDocTemplate::CIPCompDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CPackage* pPackage, CPacket* pPacket, REFCLSID clsid)
	: CPartTemplate(nIDResource,
		pDocClass,
		RUNTIME_CLASS(CDocObjectFrame),
		RUNTIME_CLASS(CIPCompView),
		pPackage,
		pPacket,
		clsid)
{
}

void CIPCompDocTemplate::InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible)
{
	ASSERT_VALID(pFrame);

	// if the frame does not have an active view, set to first pane
	if (pFrame->GetActiveView() == NULL)
	{
		CWnd* pWnd = pFrame->GetDescendantWindow(AFX_IDW_PANE_FIRST);
		if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		{
			pFrame->SetActiveView((CView*)pWnd,
				!CPartFrame::s_bLockFrame && !CPartFrame::IsWorkspaceLocked());
		}
	}

	CIPCompView * pView = (CIPCompView *)pFrame->GetActiveView();
	ASSERT(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CIPCompView)));
	
	HRESULT hr = NOERROR;
	if (SUCCEEDED(hr = pView->OnActivateDocObjectView()))
		CPartTemplate::InitialUpdateFrame(pFrame, pDoc, bMakeVisible);
	else
	{
		if (hr != OLE_E_PROMPTSAVECANCELLED)
			::AfxMessageBox(IDS_ERROR_CANT_CREATE_IPCMPDOC);
			
		::PostMessage(pFrame->m_hWnd, WM_CLOSE, NULL, NULL);
	}
}


/////////////////////////////////////////////////////////////////////////////
// LoadErrorInfo diagnostics
void LoadErrorInfo(IErrorInfo * pei, CString& strDescription, CString& strHelpFile, DWORD * pdwHelpContext)
{
	ASSERT(pei != NULL);

	BSTR bstr = NULL;
	if (SUCCEEDED(pei->GetDescription(&bstr) && bstr))
	{
		strDescription = bstr;
		::SysFreeString(bstr);
		bstr = NULL; 
	}

	if (SUCCEEDED(pei->GetHelpFile(&bstr) && bstr))
	{
		strHelpFile = bstr;
		::SysFreeString(bstr);
		bstr = NULL; 
	}
	
	pei->GetHelpContext(pdwHelpContext);
}


void ShowErrorForInterface(REFIID riid, IUnknown * pUnk, HRESULT hr)
{
	ASSERT(pUnk);

	if (hr == OLE_E_PROMPTSAVECANCELLED)
		return;
		
	COleRef<ISupportErrorInfo> srpSupportErrInfo;
	
	if (pUnk->QueryInterface(IID_ISupportErrorInfo, (void**)&srpSupportErrInfo) == S_OK)
	{
		if (srpSupportErrInfo->InterfaceSupportsErrorInfo(riid) == S_OK)
		{
			COleRef<IErrorInfo> srpErrInfo;
			
			::GetErrorInfo(0, &srpErrInfo);

			if (srpErrInfo != NULL)
			{
				CString strDesc;
				CString strHelpFile;
				DWORD   dwContextId;

				::LoadErrorInfo(srpErrInfo, strDesc, strHelpFile, &dwContextId);
				::AfxMessageBox(strDesc);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcmpvw.h ===
// ipcmpvw.h : interface of the CIPCompView class
//

#ifndef __IPCMPVW_H__
#define __IPCMPVW_H__

#include <docobvw.h>

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
// CIPCompView

class CIPCompView : public CDocObjectView
{
	DECLARE_DYNCREATE(CIPCompView)

public:
	CIPCompView();
	CIPCompDoc *GetDocument();

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnInitialUpdate(); // called first time after construct
	
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	CSlob* GetSelection();
	HRESULT OnActivateDocObjectView();
	virtual void ShowContextPopupMenu(CPoint pt);
	// we don't want to defer activation for inplace activation
	// 
	virtual BOOL DeferActivation()
	{
		return FALSE;
	}
protected:

	DECLARE_MESSAGE_MAP()
	
	afx_msg LRESULT OnGetUndoString(WPARAM, LPARAM);
	afx_msg LRESULT OnGetRedoString(WPARAM, LPARAM);
	afx_msg LRESULT OnWmHelp(WPARAM, LPARAM);
	afx_msg LRESULT OnResetCommandTarget(WPARAM, LPARAM);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnHelp();
};

#ifndef _DEBUG	// debug version in ipcmpvw.cpp
inline CIPCompDoc * CIPCompView::GetDocument()
   { return (CIPCompDoc *) m_pDocument; }
#endif

#undef AFX_DATA
#define AFX_DATA NEAR

#endif	// __IPCMPVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcmpctr.h ===
// ipcmpctr.h : interface of the CIPCompContainerItem class
//

#ifndef __IPCMPCTR_H__
#define __IPCMPCTR_H__

#include <objext.h>
#include <ocdesign.h>

#ifndef __DOCOBCTR_H__
#include "docobctr.h"
#endif

#include "ipcfrmhk.h"

class CIPCompDoc;

//special value to mark undefined UI mode.	Detects when component
//fails to call SetUIMode before calling UIActivateForMe.
//
#define GRPID_UNDEFINED ((DWORD)(-1))

/////////////////////////////////////////////////////////////////////////////
// CIPCompContainerItem 

class CIPCompContainerItem : public CDocObjectContainerItem 
{
	friend CIPCompDoc;
	DECLARE_SERIAL(CIPCompContainerItem )

// Constructors
public:
	CIPCompContainerItem(COleDocument *pContainer = NULL);
	~CIPCompContainerItem();
	
	virtual BOOL OnCompCmdMsg(GUID * pguid, DWORD cmdid, DWORD rgf,
		int nCode, void* pExtra);
	virtual void OnActivateMe();

protected:
	DWORD m_fmodeComponentUI;	// the UI mode that the component is in
	COleRef<IOleComponentUIManager> m_srpCompUIMgr;
	COleRef<IBuilderWizardManager>  m_srpBuilderWizardManager;
	
	DECLARE_INTERFACE_MAP()

	// in addition, we need to implement IOleInPlaceComponentSite and IDispatch
	BEGIN_INTERFACE_PART(OleIPComponentSite, IOleInPlaceComponentSite)
		STDMETHOD(SetUIMode)(DWORD dwUIMode);
	END_INTERFACE_PART(OleIPComponentSite)
	
	BEGIN_INTERFACE_PART(AmbientDispatch, IDispatch)
		STDMETHOD(GetTypeInfoCount)(unsigned int * pctinfo);
		STDMETHOD(GetTypeInfo)(unsigned int itinfo,LCID lcid,ITypeInfo **pptinfo);
		STDMETHOD(GetIDsOfNames)(REFIID riid,LPOLESTR *rgszNames,
	      						unsigned int cNames,LCID lcid,
	      						DISPID *rgdispid);
		STDMETHOD(Invoke)(DISPID dispidMember,REFIID riid,LCID lcid,
	      				  unsigned short wFlags,DISPPARAMS *pdispparams,
	      				  VARIANT *pvarResult,EXCEPINFO *pexcepinfo,
	      				  unsigned int *puArgErr);
	END_INTERFACE_PART(AmbientDispatch)

	BEGIN_INTERFACE_PART(MyOleClientSite, IOleClientSite)
		INIT_INTERFACE_PART(CIPCompContainerItem, OleClientSite)
		STDMETHOD(SaveObject)();
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(GetContainer)(LPOLECONTAINER*);
		STDMETHOD(ShowObject)();
		STDMETHOD(OnShowWindow)(BOOL);
		STDMETHOD(RequestNewObjectLayout)();
	END_INTERFACE_PART(MyOleClientSite)

	// the following won't be necessary when the MFC team uses a virtual function in the 
	// IOleInPlaceSite::GetWindowContext method to allow one to use a derived class of 
	// COleFrameHook.
	BEGIN_INTERFACE_PART(MyOleIPSite, IOleInPlaceSite)
		INIT_INTERFACE_PART(CIPCompContainerItem, OleIPSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);
	END_INTERFACE_PART(MyOleIPSite)

	virtual void OnGetItemPosition(CRect& rPosition);

public:
	CIPCompDoc *GetDocument()
		{ return (CIPCompDoc *)CDocObjectContainerItem::GetDocument(); }
		
	IDispatch * CIPCompContainerItem::GetIDispatch();
	IOleInPlaceComponentSite * CIPCompContainerItem::GetIOleInPlaceComponentSite();
	IOleInPlaceSite* CIPCompContainerItem::GetIOleInPlaceSite();
	virtual HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObj);
	
	virtual HRESULT ActivateDocObjectView(CView *pView);
	virtual void OnDeactivate();
	virtual void DoClose();
	virtual BOOL CanClose();
	
	BOOL CreateNewFromClsid(CLSID clsid, IStorage * pStg);
	
//	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __IPCMPCTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcmpctr.cpp ===
// ipcmpctr.cpp : implementation of the CIPCompContainerItem class
//

#include "stdafx.h"
#pragma hdrstop

#include "docobvw.h"
#include "shldocs_.h"
#include "ipcmpctr.h"
#include "ipcfrmhk.h"
#include "ipcundo.h"
#include "resource.h"

#include <oleipcid.h>
#include "bwizmgr.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIPCompContainerItem implementation

IMPLEMENT_SERIAL(CIPCompContainerItem, CDocObjectContainerItem, 0)

BEGIN_INTERFACE_MAP(CIPCompContainerItem, CDocObjectContainerItem)
	INTERFACE_PART(CIPCompContainerItem, IID_IOleInPlaceComponentSite, OleIPComponentSite)
	INTERFACE_PART(CIPCompContainerItem, IID_IDispatch, AmbientDispatch)
	INTERFACE_PART(CIPCompContainerItem, IID_IOleClientSite, MyOleClientSite)
	INTERFACE_PART(CIPCompContainerItem, IID_IOleInPlaceSite, MyOleIPSite)
END_INTERFACE_MAP()

CIPCompContainerItem::CIPCompContainerItem(COleDocument * pContainer)
	: CDocObjectContainerItem(pContainer)
{
	m_fmodeComponentUI = GRPID_UNDEFINED;
}

CIPCompContainerItem::~CIPCompContainerItem()
{
}

BOOL CIPCompContainerItem::OnCompCmdMsg(GUID *pguid, DWORD cmdid, DWORD rgf,
		int nCode, void* pExtra)
{
	if (m_pInPlaceFrame)
	{
		return ((CIPCompFrameHook*)m_pInPlaceFrame)->
						   OnCompCmdMsg(pguid, cmdid, rgf, nCode, pExtra);
	}
	return FALSE;
}

IDispatch * CIPCompContainerItem::GetIDispatch()
{
	return &m_xAmbientDispatch;
}

IOleInPlaceComponentSite * CIPCompContainerItem::GetIOleInPlaceComponentSite()
{
	return &m_xOleIPComponentSite;
}

IOleInPlaceSite* CIPCompContainerItem::GetIOleInPlaceSite()
{
	return &m_xMyOleIPSite;
}

VOID CIPCompContainerItem::OnActivateMe()
{
	ASSERT(m_pOleDocumentView != NULL);
	ASSERT(m_pInPlaceFrame != NULL);
	((CIPCompFrameHook * )m_pInPlaceFrame)->SetInPlaceComponent(m_pOleDocumentView);
}

HRESULT CIPCompContainerItem::GetService(REFGUID guidService, REFIID riid, void **ppvObj)
{
	if(NULL == ppvObj)
		return E_INVALIDARG;

	*ppvObj = NULL;

	// get the doc and see if it wants to allow the
	// component to have the service it is asking for
	CIPCompDoc *pDoc = GetDocument();
	// the doc is null if we are in our shutdown sequence
	if(NULL == pDoc)
		return E_NOINTERFACE;

	ASSERT(NULL != pDoc && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)));
	// give the doc a shot at disallowing the request
	// S_OK or any E_* cause us to veto the service
	if(S_FALSE != pDoc->VetoService(guidService, riid))
		return E_NOINTERFACE;

	// give the container/site a shot at honoring the service request
	if(SID_OleComponentUIManager == guidService)
	{
		IUnknown *punk = NULL;
		if(m_srpCompUIMgr != NULL)
			punk = m_srpCompUIMgr;
		else
			punk = m_pInPlaceFrame->GetInterface(&IID_IOleComponentUIManager);

		if(NULL != punk)
			return punk->QueryInterface(riid, ppvObj);
	}
	else if(SID_SBuilderWizardManager == guidService)
	{
		if(m_srpBuilderWizardManager == NULL)
		{
			CIPCompBuilderWizardManager *pBWM = new CIPCompBuilderWizardManager(this);
			HRESULT hr = pBWM->ExternalQueryInterface(&IID_IBuilderWizardManager, 
					(void**)&m_srpBuilderWizardManager);

			if(FAILED(hr))
			{
				// its an ole interface, so delete it
				// this way, not by using delete
				pBWM->ExternalRelease();
				return hr;
			}
			// MFC starts ref counting at 1
			m_srpBuilderWizardManager->Release();
		}
		ASSERT(m_srpBuilderWizardManager != NULL);
		return m_srpBuilderWizardManager->QueryInterface(riid, ppvObj);
	}

	// give the document a shot at honoring the service request
	// the doc is null if we are in our shutdown sequence
	if(NULL == pDoc)
		return E_NOINTERFACE;
	ASSERT(NULL != pDoc && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)));
	HRESULT hr = pDoc->GetService(guidService, riid, ppvObj);
	if(SUCCEEDED(hr))
		return hr;

	// call the base call which performs all the necessary routing
	return CDocObjectContainerItem::GetService(guidService, riid, ppvObj);
}
/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleInplaceComponentSite 

HRESULT CIPCompContainerItem::XOleIPComponentSite::SetUIMode(DWORD dwUIMode)
{
	METHOD_PROLOGUE(CIPCompContainerItem, OleIPComponentSite)

#ifdef UNDONE
		GetToolMgr()->OnNotify(m_iguidMain, m_hWnd, tmNotifyActivate);
#endif

	if (pThis->m_fmodeComponentUI != dwUIMode)
	{
		pThis->m_fmodeComponentUI = dwUIMode;

	//$UNDONE, put up the new toolbars and menus according to the new mode
	}
	
	return NOERROR;
}

IMPLEMENT_ADDREF		(CIPCompContainerItem, OleIPComponentSite)
IMPLEMENT_RELEASE		(CIPCompContainerItem, OleIPComponentSite)
IMPLEMENT_QUERYINTERFACE(CIPCompContainerItem, OleIPComponentSite)

/////////////////////////////////////////////////////////////////////////////
// Implementation of IDispatch

HRESULT CIPCompContainerItem::XAmbientDispatch::GetTypeInfoCount(unsigned int * pctinfo)
{
	METHOD_PROLOGUE(CIPCompContainerItem, AmbientDispatch)
	if (pctinfo == NULL	)
		return E_INVALIDARG;

	*pctinfo = 0;
	return S_OK;
}
HRESULT CIPCompContainerItem::XAmbientDispatch::GetTypeInfo(unsigned int itinfo,
			LCID lcid,ITypeInfo **pptinfo)
{
	METHOD_PROLOGUE(CIPCompContainerItem, AmbientDispatch)
	*pptinfo = NULL;
	return E_NOTIMPL;
}

HRESULT CIPCompContainerItem::XAmbientDispatch::GetIDsOfNames(REFIID riid,
			LPOLESTR *rgszNames, unsigned int cNames,LCID lcid,
	      	DISPID *rgdispid)
{
	METHOD_PROLOGUE(CIPCompContainerItem, AmbientDispatch)
	if (rgszNames == NULL || rgdispid == NULL)
		return E_INVALIDARG;

	for (unsigned int i = 0; i < cNames; i++)
		rgdispid[i] = DISPID_UNKNOWN;

	return E_NOTIMPL;
}

HRESULT CIPCompContainerItem::XAmbientDispatch::Invoke(DISPID dispidMember, 
			REFIID riid,LCID lcid, unsigned short wFlags,
			DISPPARAMS *pdispparams, VARIANT *pvarResult,
			EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
	METHOD_PROLOGUE(CIPCompContainerItem, AmbientDispatch)
	
	HRESULT hr	= S_OK;

	if (puArgErr)
		*puArgErr = 0;

	if (pexcepinfo)
		memset(pexcepinfo, 0, sizeof(*pexcepinfo));

	if (!pdispparams)
		return(E_INVALIDARG);

	if (!pvarResult)
		return(E_INVALIDARG);

	ASSERT(pThis->GetDocument() != NULL);
	return pThis->GetDocument()->OnAmbientInvoke(dispidMember, riid, lcid, wFlags, 
				pdispparams, pvarResult, pexcepinfo, puArgErr);
}

IMPLEMENT_ADDREF		(CIPCompContainerItem, AmbientDispatch)
IMPLEMENT_RELEASE		(CIPCompContainerItem, AmbientDispatch)
IMPLEMENT_QUERYINTERFACE(CIPCompContainerItem, AmbientDispatch)

/////////////////////////////////////////////////////////////////////////////
// CIPCompContainerItem::XMyOleClientSite implementation

IMPLEMENT_ADDREF		(CIPCompContainerItem, MyOleClientSite)
IMPLEMENT_RELEASE		(CIPCompContainerItem, MyOleClientSite)
IMPLEMENT_QUERYINTERFACE(CIPCompContainerItem, MyOleClientSite)


STDMETHODIMP CIPCompContainerItem::XMyOleClientSite::SaveObject()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleClientSite)

	return pThis->m_xOleClientSite.SaveObject();
}

STDMETHODIMP CIPCompContainerItem::XMyOleClientSite::GetMoniker(
	DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppMoniker)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleClientSite)

	if (NULL == ppMoniker)
		return E_INVALIDARG;

	*ppMoniker = NULL;

	// Documents that derive from CIPCompDoc are top level documents and
	// their container (the shell) only contributes a viewport to display that
	// document. Thus, the object full moniker logically is a concatenation
	// of a NULL container moniker and an absolute object relative moniker.
	// Thus we consider it an error to ask for the container moniker.
	if (dwWhichMoniker == OLEWHICHMK_CONTAINER)
		return E_UNEXPECTED;

	if (dwWhichMoniker == OLEWHICHMK_OBJFULL ||
		dwWhichMoniker == OLEWHICHMK_OBJREL)
	{
		CIPCompDoc *pDoc = pThis->GetDocument();
		if (NULL == pDoc)
			return E_OUTOFMEMORY;

		*ppMoniker = pDoc->GetMoniker((OLEGETMONIKER)dwAssign);
		if (NULL == *ppMoniker)
			return E_OUTOFMEMORY;

		return S_OK;
	}

	return E_INVALIDARG;
}

STDMETHODIMP CIPCompContainerItem::XMyOleClientSite::GetContainer(LPOLECONTAINER* ppContainer)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleClientSite)

	return pThis->m_xOleClientSite.GetContainer(ppContainer);
}

STDMETHODIMP CIPCompContainerItem::XMyOleClientSite::ShowObject()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleClientSite)

	return pThis->m_xOleClientSite.ShowObject();
}

STDMETHODIMP CIPCompContainerItem::XMyOleClientSite::OnShowWindow(BOOL fShow)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleClientSite)

	return pThis->m_xOleClientSite.OnShowWindow(fShow);
}

STDMETHODIMP CIPCompContainerItem::XMyOleClientSite::RequestNewObjectLayout()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleClientSite)

	return pThis->m_xOleClientSite.RequestNewObjectLayout();
}

/////////////////////////////////////////////////////////////////////////////
// CIPCompContainerItem::XMyOleIPSite implementation

IMPLEMENT_ADDREF		(CIPCompContainerItem, MyOleIPSite)
IMPLEMENT_RELEASE		(CIPCompContainerItem, MyOleIPSite)
IMPLEMENT_QUERYINTERFACE(CIPCompContainerItem, MyOleIPSite)


STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::GetWindow(HWND* lphwnd)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.GetWindow(lphwnd);
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::ContextSensitiveHelp(
	BOOL fEnterMode)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.ContextSensitiveHelp(fEnterMode);
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::CanInPlaceActivate()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.CanInPlaceActivate();
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::OnInPlaceActivate()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.OnInPlaceActivate();
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::OnUIActivate()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.OnUIActivate();
}

// the following won't be necessary when the MFC team uses a virtual function in the 
// IOleInPlaceSite::GetWindowContext method to allow one to use a derived class of 
// COleFrameHook.
STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::GetWindowContext(
	LPOLEINPLACEFRAME* lplpFrame,
	LPOLEINPLACEUIWINDOW* lplpDoc,
	LPRECT lpPosRect, LPRECT lpClipRect,
	LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)
	ASSERT_VALID(pThis);

	*lplpFrame = NULL;  // init these in-case of mem-alloc failure
	*lplpDoc = NULL;

	CFrameWnd* pMainFrame = NULL;
	CFrameWnd* pDocFrame = NULL;

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// get position of the item relative to activation view
		CRect rect;
		pThis->OnGetItemPosition(rect);
		::CopyRect(lpPosRect, &rect);
		pThis->OnGetClipRect(rect);
		::CopyRect(lpClipRect, &rect);

		// get the window context information
		if (pThis->OnGetWindowContext(&pMainFrame, &pDocFrame, lpFrameInfo))
		{
			// hook IOleInPlaceFrame interface to pMainFrame, and pDocFrame
			ASSERT(pDocFrame != NULL);
			
			if (pThis->m_pInPlaceFrame == NULL)
			{
				pThis->m_pInPlaceFrame = new CIPCompFrameHook(pMainFrame, pDocFrame, pThis);
				// this data member will hold CIPCompFrameHook alive until CIPCompContainerItem is destroyed	
				pThis->m_srpCompUIMgr = ((CIPCompFrameHook *)pThis->m_pInPlaceFrame)->GetIOleComponentUIManager();
				pThis->m_srpCompUIMgr->AddRef();
			
			}
			pThis->m_pInPlaceFrame->InternalAddRef();
			*lplpFrame = (LPOLEINPLACEFRAME)pThis->m_pInPlaceFrame->
				GetInterface(&IID_IOleInPlaceFrame);

			if (pDocFrame != NULL)
			{
				if (pThis->m_pInPlaceDoc == NULL)
					pThis->m_pInPlaceDoc = pThis->m_pInPlaceFrame;

				pThis->m_pInPlaceDoc->InternalAddRef(); // holds onto the CIPCompFrameHook
				*lplpDoc = NULL;
			}
			
			// save accel table for IOleInPlaceFrame::TranslateAccelerators
			pThis->m_pInPlaceFrame->m_hAccelTable = lpFrameInfo->haccel;

			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		// cleanup memory that may be partially allocated
		delete *lplpFrame;
		ASSERT(*lplpDoc == NULL);
		do { e->Delete(); } while (0);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::Scroll(SIZE scrollExtent)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.Scroll(scrollExtent);
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::OnUIDeactivate(BOOL fUndoable)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.OnUIDeactivate(fUndoable);
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::OnInPlaceDeactivate()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.OnInPlaceDeactivate();
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::DiscardUndoState()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.DiscardUndoState();
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::DeactivateAndUndo()
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)

	return pThis->m_xOleIPSite.DeactivateAndUndo();
}

STDMETHODIMP CIPCompContainerItem::XMyOleIPSite::OnPosRectChange(
	LPCRECT lpPosRect)
{
	METHOD_PROLOGUE(CIPCompContainerItem, MyOleIPSite)
	ASSERT(lpPosRect != NULL);
	
	// Give the document a chance to resize itself
	ASSERT(pThis->GetDocument() != NULL);
	ASSERT_KINDOF(CIPCompDoc, pThis->GetDocument());
	HRESULT hr = pThis->GetDocument()->OnPosRectChange((RECT*)lpPosRect);
	if(FAILED(hr))
		return hr;
		
	// Now resize the in place object	
	return pThis->m_xOleIPSite.OnPosRectChange(lpPosRect);
}
/////////////////////////////////////////////////////////////////////////////

BOOL CIPCompContainerItem::CreateNewFromClsid(CLSID clsid, IStorage * pStg)
{
	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(clsid != GUID_NULL);
	// pStg can be NULL (htm package requires this)
	// ASSERT(pStg != NULL);
	m_dwItemNumber = GetNewItemNumber();

	// Try to create a new storage file.
	//
	USES_CONVERSION; 
	DWORD dwStatus = 0;
	COleRef<IPersistStorage> srpPersistStorage;

	if (FAILED(::CoCreateInstance(clsid, NULL /*punkOuter*/,
		CLSCTX_INPROC_SERVER, IID_IOleObject, (void **)&m_lpObject)))
		goto ErrRtn;
		
	ASSERT(m_lpObject != NULL);
		
	// Retrieve the misc status bits for the object.
	if (FAILED(m_lpObject->GetMiscStatus(DVASPECT_CONTENT, &dwStatus)))
		goto ErrRtn;
		
	// Set the client site first, if we're supposed to.
	//
	if (dwStatus & OLEMISC_SETCLIENTSITEFIRST)
		{
		if (FAILED(m_lpObject->SetClientSite(&m_xMyOleClientSite)))
			goto ErrRtn;
		}

	::OleSetContainedObject(m_lpObject, TRUE);	
	m_lpObject->SetHostNames(T2COLE(theApp.m_pszAppName), NULL);

//	m_lpStorage = pStg;
//	m_lpStorage->AddRef();
	return TRUE;

ErrRtn:
	if(m_lpObject != NULL)
	{
		m_lpObject->Release();
		m_lpObject = NULL;
	}
	return FALSE;
}

HRESULT CIPCompContainerItem::ActivateDocObjectView(CView *pView)
{
	//$UNDONE, this should really take a IMsoView, and if the view already exist, we just need
	// to Activate the view.
	
	ASSERT(HeapValidate(GetProcessHeap(), 0, NULL));
	ASSERT(m_pOleDocumentView == NULL);	// this operation should only be done once
	VERIFY(GetOleDocument());			// make sure we're connected to a doc object

	// Quietly hook up our view to the COleClientItem.  This is normally done by its ::Activate()
	// method, but we can't do that because we don't want to DoVerb() it.
	//
	m_pView = pView;

	// Create a view connected to our IOleInPlaceSite.
	HRESULT hresult = NOERROR;
	if (FAILED(hresult = m_pOleDocument->CreateView(GetIOleInPlaceSite(), NULL, 0, &m_pOleDocumentView)))
	{
		::ShowErrorForInterface(IID_IMsoDocument, m_pOleDocument, hresult);

		// Since we've displayed error information, set hresult to suppress
		// further error messages:
		//
		hresult = OLE_E_PROMPTSAVECANCELLED;
		goto ErrExit;
	}
	
	if (FAILED(hresult = m_pOleDocumentView->Show(TRUE)))
		goto ErrExit;

	if (FAILED(hresult = ((CIPCompFrameHook * )m_pInPlaceFrame)->SetInPlaceComponent(m_pOleDocumentView)))
		goto ErrExit;
	
	// Activate the server UI and get the view window created.
	//
	if (FAILED(hresult = m_pOleDocumentView->UIActivate(TRUE)))
		goto ErrExit;

	OnSizeChange();		// setup initial rectangle for view window

ErrExit:
	ASSERT(HeapValidate(GetProcessHeap(), 0, NULL));	// check whether we're toast
	return hresult;
}

void CIPCompContainerItem::OnDeactivate()
{
	ASSERT_VALID(this);

	ASSERT(m_pInPlaceFrame != NULL);
	((CIPCompFrameHook * )m_pInPlaceFrame)->DoClose();

	// cleanup document interfaces allocated in GetWindowContext
	if (m_pInPlaceDoc != NULL)
	{
		// release in place document
		ASSERT (((CIPCompFrameHook *)m_pInPlaceDoc)->m_pDocFrameWnd->m_pNotifyHook == m_pInPlaceDoc);
		((CIPCompFrameHook *)m_pInPlaceDoc)->m_pDocFrameWnd->m_pNotifyHook = NULL;
		m_pInPlaceDoc->InternalRelease();
		m_pInPlaceDoc = NULL;
	}
	
	CDocObjectContainerItem::OnDeactivate();
	
}

void CIPCompContainerItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CDocObjectContainerItem::OnGetItemPosition
	//  will be called to determine the location of this item.  Usually, this 
	//  rectangle would reflect the current position of the item relative to the 
	//  view used for activation.
	//  You can obtain the view by calling CDocObjectContainerItem::GetActiveView.

	CView * pView = GetActiveView();
	if (pView)
		pView->GetClientRect(&rPosition);
}


BOOL CIPCompContainerItem::CanClose()
{
	COleRef<IOleInPlaceObject> srpInPlaceObject;

	BOOL fRet = TRUE; // failed the QI is considered success on CanClose
	if (SUCCEEDED(m_lpObject->QueryInterface(IID_IOleInPlaceObject, (void **)&srpInPlaceObject)))
	{
		fRet = FALSE;
		ASSERT(srpInPlaceObject != NULL);
		if (SUCCEEDED(srpInPlaceObject->UIDeactivate()) && 
			SUCCEEDED(srpInPlaceObject->InPlaceDeactivate()))
		    fRet = TRUE;
	}
	return fRet;
}

void CIPCompContainerItem::DoClose()
{
	if (m_pDocument != NULL)
		((CIPCompDoc *)m_pDocument)->SetDocObjViewActivate(FALSE);
		
	// remove external lock placed on item during in-place activation
	if (m_bLocked)  //COleClientItem::OnActivate calls OleLockRunning TRUE.
	{
		OleLockRunning(m_lpObject, FALSE, TRUE);
		m_bLocked = FALSE;
	}

	if (m_pOleDocumentView != NULL)
	{
		m_pOleDocumentView->CloseView(0);
		OleRelease(m_pOleDocumentView);
	}
	if (m_pOleDocument != NULL)
		OleRelease(m_pOleDocument);

	Release(OLECLOSE_NOSAVE); 

	// need to Remove ourselves from the Document's item collection, otherwise,
	// we will get deleted in COleDocument destructor.
	if (m_pDocument != NULL)
		m_pDocument->RemoveItem(this);

	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetInterface(&IID_IUnknown);
	ASSERT(lpUnknown != NULL);

	// disconnect the object
	::CoDisconnectObject(lpUnknown, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcslob.cpp ===
#include "stdafx.h"

#include "shldocs_.h"
#include "ipcslob.h"
#include "proppage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(COleTrackSelection, CCmdTarget)

BEGIN_INTERFACE_MAP(COleTrackSelection, CCmdTarget)
	INTERFACE_PART(COleTrackSelection, IID_ITrackSelection, TrackSelection)
END_INTERFACE_MAP()

// This GUID is defined in fm20uuid.lib, which we don't want to use because there
// do not exist RISC builds and the IDE needs to be built for some RISC platforms.
// Also see guids.cpp
DEFINE_GUID(IID_IElement,	0x3050f1ff, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

///////////////////////////////////////////////////////////////////////////////
// COleTrackSelection
//
COleTrackSelection::COleTrackSelection(CIPCompSlob *pIpCompSlob)
{
	ASSERT(NULL != pIpCompSlob);
	ASSERT(pIpCompSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)));
	m_pIpCompSlob = pIpCompSlob;
}

COleTrackSelection::~COleTrackSelection()
{
	m_pIpCompSlob = NULL;
}

HRESULT COleTrackSelection::OnSelectionContainerChange(ISelectionContainer *pSelectionCntr)
{
	if(NULL != m_pIpCompSlob)
		return m_pIpCompSlob->OnSelectionContainerChange(pSelectionCntr);
	else
		return E_UNEXPECTED;
}

STDMETHODIMP COleTrackSelection::XTrackSelection::OnSelectChange(
	ISelectionContainer * pSelectionCntr)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(COleTrackSelection, TrackSelection)
	ASSERT_VALID(pThis);

	pThis->OnSelectionContainerChange(pSelectionCntr);
	return NOERROR;
}

STDMETHODIMP_(ULONG) COleTrackSelection::XTrackSelection::AddRef()
{
	// Delegate to our exported AddRef.

	METHOD_PROLOGUE_EX(COleTrackSelection, TrackSelection)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleTrackSelection::XTrackSelection::Release()
{
	// Delegate to our exported Release.

	METHOD_PROLOGUE_EX(COleTrackSelection, TrackSelection)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleTrackSelection::XTrackSelection::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.

	METHOD_PROLOGUE_EX(COleTrackSelection, TrackSelection)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
//	CInternalTrackSelection

IMPLEMENT_DYNAMIC(CInternalTrackSelection, CCmdTarget)

BEGIN_INTERFACE_MAP(CInternalTrackSelection, CCmdTarget)
	INTERFACE_PART(CInternalTrackSelection, IID_IInternalTrackSelection, InternalTrackSelection)
END_INTERFACE_MAP()

CInternalTrackSelection::CInternalTrackSelection(
	CIPCompSlob*	pIpCompSlob)
{
	ASSERT(NULL != pIpCompSlob);
	ASSERT(pIpCompSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)));
	m_pIpCompSlob = pIpCompSlob;
}

CInternalTrackSelection::~CInternalTrackSelection()
{
	m_pIpCompSlob = NULL;
}

STDMETHODIMP_(ULONG) CInternalTrackSelection::XInternalTrackSelection::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CInternalTrackSelection, InternalTrackSelection)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CInternalTrackSelection::XInternalTrackSelection::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CInternalTrackSelection, InternalTrackSelection)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CInternalTrackSelection::XInternalTrackSelection::QueryInterface(
	REFIID riid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CInternalTrackSelection, InternalTrackSelection)
	return (HRESULT)pThis->ExternalQueryInterface(&riid, ppvObj);
}

STDMETHODIMP CInternalTrackSelection::XInternalTrackSelection::IsExternalSelectChange(
	VARIANT_BOOL* pbReturn)
{
	METHOD_PROLOGUE_EX(CInternalTrackSelection, InternalTrackSelection)
	ASSERT(NULL != pbReturn);
	if (NULL == pbReturn)
		return E_INVALIDARG;

	return pThis->IsExternalSelectChange(pbReturn);
}

STDMETHODIMP CInternalTrackSelection::XInternalTrackSelection::OnInternalSelectChange(
	DWORD dwCookie)
{
	METHOD_PROLOGUE_EX(CInternalTrackSelection, InternalTrackSelection)
	ASSERT(dwCookie);
	if (0 == dwCookie)
		return E_INVALIDARG;

	return pThis->OnInternalSelectChange(dwCookie);
}

STDMETHODIMP CInternalTrackSelection::XInternalTrackSelection::GetInternalSelectList(
	CALPOLESTR*	pcaStringsOut,
	CADWORD*	pcaCookiesOut)
{
	METHOD_PROLOGUE_EX(CInternalTrackSelection, InternalTrackSelection)

	ASSERT(pcaStringsOut);
	ASSERT(pcaCookiesOut);
	if (NULL != pcaStringsOut)
	{
		pcaStringsOut->cElems = 0;
		pcaStringsOut->pElems = NULL;
	}

	if (NULL != pcaCookiesOut)
	{
		pcaCookiesOut->cElems = 0;
		pcaCookiesOut->pElems = NULL;
	}

	if (NULL == pcaStringsOut || NULL == pcaCookiesOut)
		return E_INVALIDARG;

	return pThis->GetInternalSelectList(pcaStringsOut, pcaCookiesOut);
}

HRESULT CInternalTrackSelection::IsExternalSelectChange(
	VARIANT_BOOL* pbReturn)
{
	ASSERT(NULL != m_pIpCompSlob);
	if (NULL == m_pIpCompSlob)
		return E_UNEXPECTED;

	ASSERT(NULL != pbReturn);
	if (NULL == pbReturn)
		return E_INVALIDARG;

	if (m_pIpCompSlob->GetSelectChangeFlag())
		*pbReturn = VARIANT_TRUE;
	else
		*pbReturn = VARIANT_FALSE;

	return NOERROR;
}

HRESULT CInternalTrackSelection::OnInternalSelectChange(
	DWORD dwCookie)
{
	ASSERT(NULL != m_pIpCompSlob);
	if (NULL == m_pIpCompSlob)
		return E_UNEXPECTED;

	ASSERT(dwCookie);
	if (0 == dwCookie)
		return E_INVALIDARG;

	// do the other things to make the CIPCompSlob push itself using
	// SetPropertyBrowserSelection so that during IdleUpdate, the proper
	// thing happens (for loading appropriate pages)
	m_pIpCompSlob->OnInternalSelectChange((IUnknown*)dwCookie);

	return NOERROR;
}

HRESULT CInternalTrackSelection::GetInternalSelectList(
	CALPOLESTR*	pcaStringsOut,
	CADWORD*	pcaCookiesOut)

{
	ASSERT(NULL != m_pIpCompSlob);
	ASSERT(pcaStringsOut);
	ASSERT(pcaCookiesOut);
	// be a good citizen, initialize out params
	if (NULL != pcaStringsOut)
	{
		pcaStringsOut->cElems = 0;
		pcaStringsOut->pElems = NULL;
	}

	if (NULL != pcaCookiesOut)
	{
		pcaCookiesOut->cElems = 0;
		pcaCookiesOut->pElems = NULL;
	}

	if (NULL == pcaStringsOut || NULL == pcaCookiesOut)
		return E_INVALIDARG;

	if (NULL == m_pIpCompSlob)
		return E_UNEXPECTED;

	pcaCookiesOut->cElems = 0;
	pcaCookiesOut->pElems = NULL;

	// delegate the call to CIPCompSlob
	return m_pIpCompSlob->GetInternalSelectList(pcaStringsOut, pcaCookiesOut);
}

///////////////////////////////////////////////////////////////////////////////
// CIPCompSlob
//
IMPLEMENT_DYNAMIC(CIPCompSlob, CObject)

CIPCompSlob::CIPCompSlob(CIPCompDoc *pDoc)
{
	ASSERT(NULL != pDoc);
	m_pOleTrackSelection	= NULL;
	m_pDoc					= pDoc;
	m_pSingleObject			= NULL;
	m_rgpCachedObjects		= NULL;
	m_nCachedObjectCnt		= 0;
	m_pInternalTrackSelection = NULL;
	m_bSelectChange			= TRUE;
	m_bShowLevelCombo		= FALSE;
}

CIPCompSlob::~CIPCompSlob()
{
	if(NULL != m_pOleTrackSelection)
	{
		m_pOleTrackSelection->Zombie();
		m_pOleTrackSelection = NULL;
	}

	if(NULL != m_pInternalTrackSelection)
	{
		m_pInternalTrackSelection->Zombie();
		m_pInternalTrackSelection = NULL;
	}

	// clean up the cache by release selection
	// objects and freeing up heap if necessary
	ReleaseCachedObjects();
}

BOOL CIPCompSlob::Create()
{
	m_pOleTrackSelection = new COleTrackSelection(this);

	if(FAILED(m_pOleTrackSelection->ExternalQueryInterface(&IID_ITrackSelection, 
				(void**)&m_srpTrackSelection)))
	{
		delete m_pOleTrackSelection;
		m_pOleTrackSelection = NULL;
		return FALSE;
	}
	else
	{
		// mfc starts ref counting at 1, so let's compensate
		m_srpTrackSelection->Release();
		return TRUE;
	}
}

BOOL CIPCompSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	if(m_srpSelectionCntr == NULL)
		return TRUE;

	ReleaseCachedObjects();

	ULONG nUnkCnt = 0;
	if(FAILED(m_srpSelectionCntr->CountObjects(GETOBJS_SELECTED, &nUnkCnt)) || 0 == nUnkCnt)
		return TRUE;

	if(!COlePage::GetShowAllPage())
		COlePage::SetShowAllPage(TRUE);

	UINT cPages = 0;
	HRESULT		hr;
	IUnknown*	pUnkTemp;
	IElement*	pElement;
	IElement*	pParentElement;
	int			iSize;
	ULONG		i;
	ULONG		j;
	ULONG		nCntElements;

	if(1 == nUnkCnt) 
	{
		IUnknown *pUnk = NULL;
		if (GetSelectChangeFlag())
		{
			// external select change
			if(FAILED(m_srpSelectionCntr->GetObjects(GETOBJS_SELECTED, nUnkCnt, &pUnk)))
				return NULL;

			m_pSingleObject = pUnk;
			m_rgpCachedObjects = &m_pSingleObject;
			m_nCachedObjectCnt = 1;
			cPages = COlePage::LoadPages(nUnkCnt, &pUnk);
			// we don't release the objects returned from GetObjects here
			// they get released in ITrackSelection::OnSelectChanged or when
			// the we get destroyed (our destructor)
			//		pUnk->Release();

			// find out how many levels exist in the ancestry including the current one
			// and collect the strings and cookies
			BOOL	fRet;

			fRet = GetElementsIntoArray(pUnk, &m_ElementsArray);
			// if we have a hierarchy, show the level combo box
			m_bShowLevelCombo = (m_ElementsArray.GetSize() > 0);
		}
		else
		{
			// internal select change
			ASSERT(m_pUnkInternalSelectChange != NULL);

			// addref this since in ReleaseCachedObjects, we are going to
			// release this pUnk
			m_pUnkInternalSelectChange->AddRef();

			m_pSingleObject = m_pUnkInternalSelectChange;
			m_rgpCachedObjects = &m_pSingleObject;
			m_nCachedObjectCnt = 1;
			cPages = COlePage::LoadPages(nUnkCnt, &m_pUnkInternalSelectChange);
		}
	}			    
	else
	{
		if (GetSelectChangeFlag())
		{
			// the COlePage object is responsible for freeing up this heap
			// if the array if larger than one, then it knows it is 
			// repsonsible for the memory
			IUnknown **ppUnk = (IUnknown **)AfxAllocTaskMem(sizeof(IUnknown *) * nUnkCnt);
			ASSERT(ppUnk);
			if(NULL == ppUnk)
				return NULL;
			if(FAILED(m_srpSelectionCntr->GetObjects(GETOBJS_SELECTED, nUnkCnt, ppUnk)))
			{
				AfxFreeTaskMem(ppUnk);
				return NULL;
			}
			m_pSingleObject = NULL;
			m_rgpCachedObjects = ppUnk;
			m_nCachedObjectCnt = nUnkCnt;
			cPages = COlePage::LoadPages(nUnkCnt, ppUnk);
			// we don't release the objects returned from GetObjects here
			// they get released in ITrackSelection::OnSelectChanged or when
			// we get destroyed (our destructor)
			//		for(ULONG nCnt = 0; nCnt < nUnkCnt; ++nCnt)
			//			ppUnk[nCnt]->Release();

			// find out how many levels exist in the ancestry including the current one
			// and store the element interfaces

			for (i = 0; i < nUnkCnt; ++i)
			{
				if (!IntersectElements(m_rgpCachedObjects[i]) ||
					m_ElementsArray.GetSize() <= 0)
					i = nUnkCnt;	// break out of loop
			}

			// if we have a hierarchy, show the level combo box
			m_bShowLevelCombo = (m_ElementsArray.GetSize() > 0);
		}
		else
		{
			// internal select change
			ASSERT(m_pUnkInternalSelectChange != NULL);

			// addref this since in ReleaseCachedObjects, we are going to
			// release this pUnk
			if ((IUnknown*)MULTI_SELECT_COOKIE == m_pUnkInternalSelectChange)
			{
				// since we released all the pUnks of selected items in 
				// ReleaseCachedObjects, get them again
				IUnknown **ppUnk = (IUnknown **)AfxAllocTaskMem(sizeof(IUnknown *) * nUnkCnt);
				ASSERT(ppUnk);
				if(NULL == ppUnk)
					return NULL;
				if(FAILED(m_srpSelectionCntr->GetObjects(GETOBJS_SELECTED, nUnkCnt, ppUnk)))
				{
					AfxFreeTaskMem(ppUnk);
					return NULL;
				}

				m_pSingleObject = NULL;
				m_rgpCachedObjects = ppUnk;
				m_nCachedObjectCnt = nUnkCnt;

				cPages = COlePage::LoadPages(nUnkCnt, ppUnk);
			}
			else
			{
				m_pUnkInternalSelectChange->AddRef();
				m_pSingleObject = m_pUnkInternalSelectChange;
				m_rgpCachedObjects = &m_pSingleObject;
				m_nCachedObjectCnt = 1;

				cPages = COlePage::LoadPages(m_nCachedObjectCnt, &m_pUnkInternalSelectChange);
			}
		}
	}

	for( UINT nPage = 0; nPage < cPages; nPage++ )
	{
		ASSERT_VALID(COlePage::GetPropPage(nPage));
		AddPropertyPage(COlePage::GetPropPage(nPage), this);
	}

	CSlob::SetupPropertyPages(pNewSel, bSetCaption);

	// no caption

	return TRUE;
}

BOOL CIPCompSlob::IntersectElements(
	IUnknown*		pUnk)
{
	ASSERT(NULL != pUnk);
	if (NULL == pUnk)
		return FALSE;

	BOOL	fRet;

	// if this is the first element, use the m_ElementsArray
	// to get all the elements into this.
	// else, get the elements into a temporary array and
	// intersect the common elements and keep them and delete
	// the uncommon ones from m_ElementsArray
	if (m_ElementsArray.GetSize() > 0)
	{
		CPtrArray	ElementsArrayLocal;

		fRet = GetElementsIntoArray(pUnk, &ElementsArrayLocal);

		int		iSize = m_ElementsArray.GetSize();
		int		iSize2 = ElementsArrayLocal.GetSize();
		BOOL	bFound;
		int		j;
		HRESULT	hr;

		IUnknown*	pCurr;
		IUnknown*	pUnk;
		
		// make sure that all the elements in pdwa also exists in
		// the new array -- otherwise, remove all the elements that do not
		// exist in the new array
		for (int i = iSize - 1; i >= 0; --i)
		{
			bFound = FALSE;
			pCurr = (IUnknown*)m_ElementsArray.GetAt(i);
			for (j = iSize2 - 1; j >= 0; --j)
			{
				if (pCurr == (IUnknown*)ElementsArrayLocal.GetAt(j))
				{
					bFound = TRUE;
					break;
				}
				else
				{
					if ((pCurr != (IUnknown*)MULTI_SELECT_COOKIE) &&
						(ElementsArrayLocal.GetAt(j) != (IUnknown*)MULTI_SELECT_COOKIE))
					{
						COleRef<IUnknown>	srpUnk1;
						COleRef<IUnknown>	srpUnk2;
						
						// get the IUnknown of both and compare them
						pUnk = pCurr;
						hr = pUnk->QueryInterface(IID_IUnknown, (void**)&srpUnk1);
						if (S_OK == hr)
						{
							pUnk = (IUnknown*)ElementsArrayLocal.GetAt(j);
							hr = pUnk->QueryInterface(IID_IUnknown,
								(void**)&srpUnk2);
							if ((S_OK == hr) && (srpUnk1 == srpUnk2))
							{
								bFound = TRUE;
								break;
							}
						}
					}
				}
			}

			if (!bFound)
				m_ElementsArray.RemoveAt(i);
		}
	}
	else
	{
		fRet = GetElementsIntoArray(pUnk, &m_ElementsArray);
	}

	return fRet;
}

BOOL CIPCompSlob::GetElementsIntoArray(
	IUnknown*	pUnk,
	CPtrArray*	pElementsArray)
{
	ASSERT(pUnk);
	ASSERT(pElementsArray);

	HRESULT			hr;
	IElement*		pElement;
	IElement*		pParentElement;

	// the pElement and all its parents are freed by ReleaseCachedObjects
	pElement = NULL;
#if defined(_M_ALPHA) || defined(_M_PPC)
#pragma message(__FILE__ " commented out to avoid dependancy of IID_IElement on fm30uuid.lib - need to fix later!!! v-ibmmb")
	hr = FALSE;
#else
	hr = pUnk->QueryInterface(IID_IElement, (void**)&pElement);
#endif
	if (!((S_OK == hr) && (NULL != pElement)))
		return FALSE;

	// add the control itself
	if (m_nCachedObjectCnt == 1)
	{
		// single select
		pUnk->AddRef();
		pElementsArray->Add(pUnk);
	}
	else
	{
		// special case:
		// add a special number, the first time to separate this element
		// as a multi-selection where you can find the interfaces
		// for the selected controls in m_rgpCachedObjects.
		pElementsArray->Add((IUnknown*)MULTI_SELECT_COOKIE);
	}

	// traverse the parent chain until you get no parent
	// while you are at it, store the pUnks and the tag names
	while (pElement)
	{
		pParentElement = NULL;
		hr = pElement->get_parentElement(&pParentElement);
		if (NOERROR == hr)
			pElementsArray->Add(pParentElement);

		pElement->Release();
		pElement = NULL;

		if (pParentElement && NOERROR == hr)
#if defined(_M_ALPHA) || defined(_M_PPC)
#pragma message(__FILE__ " commented out to avoid dependancy of IID_IElement on fm30uuid.lib - need to fix later!!! v-ibmmb")
			hr = FALSE;
#else
			hr = pParentElement->QueryInterface(IID_IElement, (void**)&pElement);
#endif
	}

	return TRUE;
}

HRESULT CIPCompSlob::OnSelectionContainerChange(ISelectionContainer *pSelectionCntr)
{
	SetSelectChangeFlag(TRUE);	// set flag to indicate that an external change happened

	// release all cached objects and free up
	// heap if necessary
	ReleaseCachedObjects();

	if(m_srpSelectionCntr != NULL)
	{
		m_srpSelectionCntr.SRelease();
	}

	if(pSelectionCntr != NULL)
	{
		m_srpSelectionCntr = pSelectionCntr;
		m_srpSelectionCntr->AddRef();
		SetPropertyBrowserSelection(this);
	}
	else 
		SetPropertyBrowserSelection(NULL);

	return NOERROR;
}

void CIPCompSlob::OnInternalSelectChange(IUnknown* pUnkInternalSelectChange)
{
	SetSelectChangeFlag(FALSE);	// set flag to indicate that an internal change happened

	ReleaseCachedObjects();

	ASSERT(pUnkInternalSelectChange != NULL);
	m_pUnkInternalSelectChange = pUnkInternalSelectChange;

	SetPropertyBrowserSelection(this);
}

IUnknown *CIPCompSlob::GetTrackSelection()
{
	ASSERT(m_srpTrackSelection != NULL);
	if(m_srpTrackSelection == NULL)
		return NULL;
	else
		return (IUnknown *)m_srpTrackSelection;
}

HRESULT	CIPCompSlob::GetInternalTrackSelection(
	IInternalTrackSelection**	ppITS)
{
	ASSERT(ppITS != NULL);

	HRESULT	hr = E_NOINTERFACE;
	
	*ppITS = NULL;
	if (m_srpInternalTrackSelection == NULL)
	{
		DWORD	grfSupport = 0;

		// ask the m_pDoc if it supports internal track selection
		ASSERT(m_pDoc);
		m_pDoc->DoesSupportInternalSelect(&grfSupport);
		if((grfSupport & ITS_STANDARD_SUPPORT) ||
			(grfSupport & ITS_CUSTOM_SUPPORT))
		{
			m_pInternalTrackSelection = new CInternalTrackSelection(this);

			hr = m_pInternalTrackSelection->ExternalQueryInterface(
				&IID_IInternalTrackSelection, (void**)&m_srpInternalTrackSelection);
			if (FAILED(hr))
			{
				// its an ole interface, so delete it
				// this way, not by using delete
				m_pInternalTrackSelection->ExternalRelease();
				m_pInternalTrackSelection =	NULL;
				return hr;
			}

			if (m_srpInternalTrackSelection)
			{
				// set the return ptr and return
				// we don't addref this because mfc objects
				// start out with a ref count of 1
				*ppITS = m_srpInternalTrackSelection;

 				hr = NOERROR;
			}
		}
	}
	else
	{
		// since we have already created this before, just return it
		*ppITS = m_srpInternalTrackSelection;

		// since we are passing it to the caller, just addref this
		m_srpInternalTrackSelection->AddRef();
		hr = NOERROR;
	}

	return hr;
}

HRESULT CIPCompSlob::GetInternalSelectList(
	CALPOLESTR*	pcaStringsOut,
	CADWORD*	pcaCookiesOut)
{
	ASSERT(pcaStringsOut);
	ASSERT(pcaCookiesOut);
	// be a good citizen, initialize out params
	if (NULL != pcaStringsOut)
	{
		pcaStringsOut->cElems = 0;
		pcaStringsOut->pElems = NULL;
	}

	if (NULL != pcaCookiesOut)
	{
		pcaCookiesOut->cElems = 0;
		pcaCookiesOut->pElems = NULL;
	}

	if (NULL == pcaStringsOut || NULL == pcaCookiesOut)
		return E_INVALIDARG;

	if(m_srpSelectionCntr == NULL)
		return E_UNEXPECTED;

	DWORD	grfSupport = 0;
	// ask the m_pDoc if it supports internal track selection
	ASSERT(m_pDoc);
	m_pDoc->DoesSupportInternalSelect(&grfSupport);
	if(grfSupport & ITS_STANDARD_SUPPORT)
	{
		// QI for IElement interface and then get the tag name
		// for HTML Level objects.
		// special case:
		// if the interfacepointer we get is a special cookie
		// (the MULTI_SELECT_COOKIE), use _T("Multi-Select")
		// string for the time being and later change this to
		// an appropriate string suggested by UE
		// $TODO
		ULONG	ulElems = m_ElementsArray.GetSize();
		if (ulElems > 0)
		{
			HRESULT			hr;
			IElement*		pElement;
			BSTR			bstrTagName;
			ULONG			i;
			LPOLESTR		pszPtr;

			USES_CONVERSION;

			pcaStringsOut->pElems = (LPOLESTR*)AfxAllocTaskMem(sizeof(LPOLESTR)* ulElems);
			if (NULL == pcaStringsOut->pElems)
				return E_OUTOFMEMORY;

			pcaCookiesOut->pElems = (DWORD*)AfxAllocTaskMem(sizeof(DWORD* )* ulElems);
			if (NULL == pcaCookiesOut->pElems)
			{
				::AfxFreeTaskMem(pcaStringsOut->pElems);
				return E_OUTOFMEMORY;
			}

			pcaStringsOut->cElems = ulElems;
			pcaCookiesOut->cElems = ulElems;

			int		iSize;
			CString	strOut;

			for (i = 0; i < ulElems; ++i)
			{
				pElement = NULL;

				if ((IUnknown*)MULTI_SELECT_COOKIE ==
					(IUnknown*)m_ElementsArray.GetAt(i))
				{
					// for multiple selection, make up a tag name,
					// since we have a "Cookie" instead of a interface ptr
					// in the first element
					// $TODO put this in the string table
					strOut = _T("Multi-Select");
				}
				else
				{
#if defined(_M_ALPHA) || defined(_M_PPC)
#pragma message(__FILE__ " commented out to avoid dependancy of IID_IElement on fm30uuid.lib - need to fix later!!! v-ibmmb")
					hr = FALSE;
#else
					hr = ((IUnknown*)m_ElementsArray.GetAt(i))->QueryInterface(
						IID_IElement, (void**)&pElement);
#endif
					if (NOERROR == hr)
					{
						hr = pElement->get_tagName(&bstrTagName);
						if (NOERROR == hr)
						{
							strOut = OLE2T(bstrTagName);
							::SysFreeString(bstrTagName);
						}
						else
						{
							hr = E_FAIL;
							goto errorexit;
						}

						pElement->Release();
					}
					else
					{
						hr = E_FAIL;
						goto errorexit;
					}
				}

				iSize = _tcslen(LPCTSTR(strOut)) + 1;
				pszPtr = NULL;

				if ((pszPtr = (LPOLESTR)AfxAllocTaskMem(iSize * sizeof(OLECHAR))) != NULL)
				{
#ifdef _UNICODE
					wcscpy(pszPtr, LPCTSTR(strOut));
#elif !defined(OLE2ANSI)
					MultiByteToWideChar(CP_ACP, 0, LPCTSTR(strOut), -1, pszPtr, iSize);
#else
					lstrcpy(pszPtr, LPCTSTR(strOut));
#endif
				}

				if (NULL == pszPtr)
				{
					hr = E_OUTOFMEMORY;
errorexit:
					// clean up everything allocated so far
					while (--i)
						::AfxFreeTaskMem(pcaStringsOut->pElems[i]);

					::AfxFreeTaskMem(pcaStringsOut->pElems);
					::AfxFreeTaskMem(pcaCookiesOut->pElems);

					return hr;
				}

				pcaStringsOut->pElems[i] = pszPtr;
				pcaCookiesOut->pElems[i] = (DWORD)(IUnknown*)m_ElementsArray.GetAt(i);
			}

			return NOERROR;
		}
		else
		{
			// no items to send
			return E_FAIL;
		}
	}
	else if (grfSupport & ITS_CUSTOM_SUPPORT)
	{
		if (m_srpSelectionCntr == NULL)
			return E_UNEXPECTED;

		return m_pDoc->GetInternalSelectList(m_srpSelectionCntr,
			pcaStringsOut, pcaCookiesOut);
	}

	return E_UNEXPECTED;
}

void CIPCompSlob::BeginUndo(UINT nID)
{
	CString str;

	ASSERT(nID);
	ASSERT(m_pDoc);
	if(NULL == m_pDoc || !str.LoadString(nID))
		return;

	m_pDoc->BeginUndo(str);
}

BOOL CIPCompSlob::SetUndoStringMgr(IPropertyPageUndoString *pPPUS)
{
	ASSERT(m_pDoc);
	ASSERT(NULL != pPPUS);
	if(NULL == m_pDoc || NULL == pPPUS)
		return FALSE;

	return m_pDoc->SetUndoStringMgr(pPPUS);
}

void CIPCompSlob::EndUndo(BOOL bAbort /*= FALSE*/)
{
	ASSERT(m_pDoc);
	if(NULL == m_pDoc)
		return;

	m_pDoc->EndUndo(bAbort);
}

void CIPCompSlob::ReleaseCachedObjects()
{
	for(ULONG nCnt = 0; nCnt < m_nCachedObjectCnt; ++nCnt)
	{
		if(NULL != m_rgpCachedObjects[nCnt])
			::OleRelease(m_rgpCachedObjects[nCnt]);
	}
	// if we have more than one object we would have
	// allocated heap, so free it up.
	if(m_nCachedObjectCnt > 1)
		AfxFreeTaskMem(m_rgpCachedObjects);

	m_pSingleObject		= NULL;
	m_rgpCachedObjects	= NULL;
	m_nCachedObjectCnt	= 0;

	// if we have an Elements array and the select change is external
	// then release the elements and free the array
	ULONG	ulSize = m_ElementsArray.GetSize();
	if (GetSelectChangeFlag() && (ulSize > 0))
	{
		IUnknown*	pUnk;
		for (nCnt = 0; nCnt < ulSize; ++nCnt)
		{
			pUnk = (IUnknown*)m_ElementsArray.GetAt(nCnt);
			ASSERT(pUnk);
			if ((IUnknown*)MULTI_SELECT_COOKIE != pUnk)
				::OleRelease(pUnk);
		}

		m_ElementsArray.RemoveAll();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcslob.h ===
/////////////////////////////////////////////////////////////////////////////
//	IPCSLOB.H
//		Defines classes which inherits from CSlob and also provides an
//		ITrackSelection interface to manage an ISelectionContainer object
//		This class works in conjunction with COlePropertyPageSite to allow
//		components that support IPropertyPage, ISelectionContainer to be 
//		used within the package framework

#ifndef __IPCSLOB_H__
#define __IPCSLOB_H__
#include <objext.h>
#include "ipcits.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CIPCompSlob;
class COleTrackSelection;
class CIPCompDoc;
interface IPropertyPageUndoString;
interface IInternalTrackSelection;

/////////////////////////////////////////////////////////////////////////////
//	COleTrackSelection

class COleTrackSelection : public CCmdTarget
{
public:
	DECLARE_DYNAMIC(COleTrackSelection)

public:
	COleTrackSelection(CIPCompSlob *pIpCompSlob);
	virtual ~COleTrackSelection();
	void Zombie() { m_pIpCompSlob = NULL; };

// Attributes
protected:
	// called when ITrackSelection::OnSelectChange is called
	HRESULT OnSelectionContainerChange(ISelectionContainer *pSelectionCntr);

	CIPCompSlob *m_pIpCompSlob;

// Interface Maps   
protected:
	// ITrackSelection
	BEGIN_INTERFACE_PART(TrackSelection, ITrackSelection)
		INIT_INTERFACE_PART(COleTrackSelection, TrackSelection)
		STDMETHOD(OnSelectChange)(ISelectionContainer *pSelectionCntr);
	END_INTERFACE_PART(TrackSelection)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//	CInternalTrackSelection

class CInternalTrackSelection : public CCmdTarget
{
public:
	DECLARE_DYNAMIC(CInternalTrackSelection)

public:
	CInternalTrackSelection(CIPCompSlob* pIpCompSlob);
	virtual ~CInternalTrackSelection();
	void Zombie() { m_pIpCompSlob = NULL; };

// Attributes
protected:
	HRESULT	IsExternalSelectChange(
				VARIANT_BOOL* pbReturn);
	HRESULT	OnInternalSelectChange(
				DWORD dwCookie);
	HRESULT	GetInternalSelectList(
				CALPOLESTR* pcaStringsOut,
				CADWORD* pcaCookiesOut);

	CIPCompSlob *m_pIpCompSlob;

// Interface Maps   
protected:
	// ITrackSelection
	BEGIN_INTERFACE_PART(InternalTrackSelection, IInternalTrackSelection)
		INIT_INTERFACE_PART(CInternalTrackSelection, InternalTrackSelection)
		STDMETHOD(IsExternalSelectChange)(VARIANT_BOOL* pbReturn);
		STDMETHOD(OnInternalSelectChange)(DWORD dwCookie);
		STDMETHOD(GetInternalSelectList)(CALPOLESTR* pcaStringsOut, CADWORD* pcaCookiesOut);
	END_INTERFACE_PART(InternalTrackSelection)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//	CIPCompSlob
//
class CIPCompSlob : public CSlob
{
public:
	DECLARE_DYNAMIC(CIPCompSlob)

	CIPCompSlob(CIPCompDoc *pDoc);
	virtual ~CIPCompSlob();

public:
	virtual BOOL Create();	// 2nd phase construction
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);
//	C3dPropertyPage* GetPropPage(UINT nPage);

	// called when ITrackSelection::OnSelectChange is called
	virtual HRESULT OnSelectionContainerChange(ISelectionContainer *pSelectionCntr);
	IUnknown *GetTrackSelection();

	virtual void BeginUndo(UINT nID);
	virtual BOOL SetUndoStringMgr(IPropertyPageUndoString *pPPUS);
	virtual void EndUndo(BOOL bAbort = FALSE);

	HRESULT	GetInternalTrackSelection(IInternalTrackSelection** ppITS);
	HRESULT	GetInternalSelectList(CALPOLESTR* pcaStringsOut, CADWORD* pcaCookiesOut);

	void	SetSelectChangeFlag(BOOL bFlag)
			{
				m_bSelectChange = bFlag;
			}
	BOOL	GetSelectChangeFlag()
			{
				return m_bSelectChange;
			}
	BOOL	ShowLevelCombo()
			{
				return m_bShowLevelCombo;
			}

	void	OnInternalSelectChange(IUnknown* pUnkInternalSelectChange);

// Attributes
protected:
	COleTrackSelection				 *m_pOleTrackSelection;
	COleRef<ITrackSelection>		  m_srpTrackSelection;
	COleRef<ISelectionContainer>	  m_srpSelectionCntr;
	CInternalTrackSelection*			m_pInternalTrackSelection;
	COleRef<IInternalTrackSelection>	m_srpInternalTrackSelection;

	// NOTE:
	// the following interface pointer is not addref'ed, so do not
	// release it at any time, this interface pointer is released
	// by the owner (CSheetWnd) when appropriate.
	// Also, that is the reason, this is not a smart ref
	IUnknown*	m_pUnkInternalSelectChange;	// for trident
	
	void	ReleaseCachedObjects();
	BOOL	IntersectElements(IUnknown* pUnk);
	BOOL	GetElementsIntoArray(IUnknown* pUnk, CPtrArray* pElementsArray);

private:
	CIPCompDoc*	m_pDoc;
	IUnknown*	m_pSingleObject;
	IUnknown**	m_rgpCachedObjects;
	ULONG		m_nCachedObjectCnt;
	BOOL		m_bSelectChange;		// true for external select change and
										// false for internal select change
	CPtrArray	m_ElementsArray;
	BOOL		m_bShowLevelCombo;
};

#endif	// __IPCSLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcundo.cpp ===
// ipcundo.cpp : implementation of the COleUndoManager and
// CEnumOleUndoUnit classes.
//

#include "stdafx.h"
#pragma hdrstop

#include "ipcundo.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//$UNDONE -- these Guids are defined in ocx96.lib; once we have
// versions of that library for all packages, we can link to it
// and remove these definitions.
//
DEFINE_GUID(IID_IOleUndoManager,	0xd001f200, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);
DEFINE_GUID(IID_IOleUndoUnit, 	0x894ad3b0, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);
DEFINE_GUID(IID_IOleParentUndoUnit, 0xa1faf330, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);
DEFINE_GUID(IID_IEnumOleUndoUnits,	0xb3e7c340, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);

// Macros ---------------------------------------------------------------------
inline HRESULT MapAbortResult(HRESULT hr)
	{ return ((hr == E_ABORT) ? E_FAIL : hr); }

/////////////////////////////////////////////////////////////////////////////
// COleUndoManager implementation
//

// Note that the constructor sets the reference count to one.
//
COleUndoManager::COleUndoManager() :
m_cRef(1),
m_cRollbackCtr(0),
m_fEnable(TRUE),
m_fUndoStackIsEmpty(TRUE),
m_fRedoStackIsEmpty(TRUE),
m_usManagerState(usBaseState),
m_pOpenUndoAction(NULL),
m_pOpenRedoAction(NULL)

{
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::~COleUndoManager

Description: Destructor for COleUndoManager Object

Return Values: None

-----------------------------------------------------------------------------*/
COleUndoManager::~COleUndoManager()
{
DiscardFrom(NULL); // Release everything in the Undo/Redo stacks
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::QueryInterface

Description:
	Query the object for an OLE interface.

Return Values:
	NO_ERROR to indicate the interface is supported, in which case
	*ppvObj is filled in; otherwise, *ppvObj is set to NULL.
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::QueryInterface (REFIID riid,
		void ** ppvObj)
{
	if (ppvObj == NULL)
		return E_INVALIDARG;
		
	*ppvObj = NULL;

	if (riid==IID_IUnknown)
		*ppvObj = (void *)(IUnknown *)this;
	else if (riid==IID_IOleUndoManager)
		*ppvObj = (void *)(IOleUndoManager *)this;
	else
		return E_NOINTERFACE;

	((IUnknown *)*ppvObj)->AddRef();
	return NOERROR;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::AddRef

Description:
	Add a reference to this object.

Return Values:
	The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) COleUndoManager::AddRef()
{
	return( ++m_cRef );
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::Release

Description:
	Release a reference to this object.

Return Values:
	The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) COleUndoManager::Release()
{
	ASSERT( m_cRef > 0 );
	int cRef = --m_cRef;
	if (cRef==0)
		delete this;
	return cRef;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::Open

Description: Open a new empty compound action onto the Undo/Redo stack

Return Values:	S_OK, if OK
				E_UNEXPECTED, if not enabled
				E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::Open
(
IOleParentUndoUnit *pCUA // Pointer to Compound Undo Action
)
{
	HRESULT hr = S_OK;

	TRY

	if(!pCUA)
		{
		ASSERT(FALSE);
		return E_INVALIDARG;
		}
	if(!m_fEnable)
		return S_OK;

	POSITION posUndo;

	if(m_pOpenUndoAction||m_pOpenRedoAction)
		{
		switch(m_usManagerState)
			{
			  case usBaseState:
			  case usRedoState:
					ASSERT(m_pOpenUndoAction);
					if(m_usManagerState==usBaseState)
						m_pOpenUndoAction->OnNextAdd();
					return m_pOpenUndoAction->Open(pCUA);
					break;
			  case usUndoState:
					ASSERT(m_pOpenRedoAction);
					return m_pOpenRedoAction->Open(pCUA);
					break;
			  default:
					ASSERT(FALSE);
					return E_FAIL;
					break;
			}
		}
	switch(m_usManagerState)
		{
		  case usBaseState:				
				// Call OnNextAdd on the top of stack
				posUndo = m_UndoStack.GetHeadPosition();
				if(posUndo != NULL)
					m_UndoStack.GetAt(posUndo)->OnNextAdd();
				m_pOpenUndoAction=pCUA;
				break;
		  case usRedoState:
				m_pOpenUndoAction=pCUA;
				break;
		  case usUndoState:
				m_pOpenRedoAction=pCUA;
				break;
		  default:
				ASSERT(FALSE);
				return E_FAIL;
				break;
		}
	// We're keeping the interface pointer pUA so AddRef it!
	pCUA->AddRef();

	CATCH_ALL(pe)
	{
		hr = COleException::Process(pe);
		pe->Delete();
	}
	END_CATCH_ALL

	return hr;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::Close

Description: Close the currently open compound undo action list

Return Values: S_OK, if ok or disabled
			   E_FALSE, if no open child
			   E_INVALIDARG, if pCUA is not the currently open object
			   E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::Close
(
IOleParentUndoUnit *pCUA, // Pointer to Compound Undo Action
BOOL fCommit // Flag to keep or discard the completed compound undo action list
)
{
	HRESULT hr = S_OK;

	if(!m_fEnable)
		return S_OK;

	TRY

		if(m_pOpenUndoAction||m_pOpenRedoAction)
		{
			switch(m_usManagerState)
			{
			case usBaseState:
			case usRedoState:
				ASSERT(m_pOpenUndoAction);
				hr=m_pOpenUndoAction->Close(pCUA, fCommit);
				if(hr!=S_FALSE)
					return hr;
				if(pCUA!=m_pOpenUndoAction)
					return E_INVALIDARG;
				if(!fCommit)
				{
					m_pOpenUndoAction->Release();
					m_pOpenUndoAction=NULL;
					return S_OK;
				}
#ifdef _DEBUG
				if(m_usManagerState==usBaseState)
				{
					BSTR bstrDesc;
					m_pOpenUndoAction->GetDescription(&bstrDesc);
					ASSERT(wcslen(bstrDesc) > 0);
					SysFreeString(bstrDesc);
				}
#endif
				// If we're in the base state, committing a new
				// Undo unit wipes out the Redo stack.
				//
				if (m_usManagerState==usBaseState)
				{
					// Clear out the Redo Stack
					if(m_pOpenRedoAction)
					{
						m_pOpenRedoAction->Release();
						m_pOpenRedoAction=NULL;
					}
					POSITION posRedo = m_RedoStack.GetHeadPosition();
					while(posRedo != NULL)
					{
						m_RedoStack.GetNext(posRedo)->Release();
					}
					m_RedoStack.RemoveAll();
				}

				m_UndoStack.AddHead(m_pOpenUndoAction);
				m_pOpenUndoAction=NULL;
				if(m_usManagerState==usRedoState)
					m_cRollbackCtr++;
				OnStackChange();
				return S_OK;
				break;
			case usUndoState:
				ASSERT(m_pOpenRedoAction);
				hr=m_pOpenRedoAction->Close(pCUA, fCommit);
				if(hr!=S_FALSE)
					return hr;
				if(pCUA!=m_pOpenRedoAction)
					return E_INVALIDARG;
				if(!fCommit)
				{
					m_pOpenRedoAction->Release();
					m_pOpenRedoAction=NULL;
					return S_OK;
				}
				m_RedoStack.AddHead(m_pOpenRedoAction);
				m_pOpenRedoAction=NULL;
				m_cRollbackCtr++;
				OnStackChange();
				return S_OK;
				break;
			default:
				ASSERT(FALSE);
				return E_FAIL;
				break;
			}
		}
		else
			return S_FALSE;

	CATCH_ALL(pe)
	{
		hr = COleException::Process(pe);
		pe->Delete();
	}
	END_CATCH_ALL

	return hr;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::Add

Description:
		Add a simple undo action to the Undo/Redo stack
		AddAtomic can be called with a compound action via Add()

Return Values:	S_OK
				E_UNEXPECTED, The Manager is not enabled
				E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::Add
(
IOleUndoUnit *pUA // Pointer to Undo Action
)
{
	if(!pUA)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	if(!m_fEnable)
		return S_OK;

	//Case I:  There is an open Compound action on the stack
	if(m_pOpenUndoAction||m_pOpenRedoAction)
		{
		switch(m_usManagerState)
			{
			  case usBaseState:
			  case usRedoState:
					ASSERT(m_pOpenUndoAction);
					if(m_usManagerState==usBaseState)
						m_pOpenUndoAction->OnNextAdd();
					return m_pOpenUndoAction->Add(pUA);
					break;
			  case usUndoState:
					ASSERT(m_pOpenRedoAction);
					return m_pOpenRedoAction->Add(pUA);
					break;
			  default:
					ASSERT(FALSE);
					return E_FAIL;
					break;
			}
		}

	HRESULT hr = S_OK;
	POSITION posUndo, posRedo;

	TRY
		//Case II:	There is no open Compound action on the stack
		switch(m_usManagerState)
		{
		case usBaseState:
			// Clear out the Redo Stack
			if(m_pOpenRedoAction)
			{
				m_pOpenRedoAction->Release();
				m_pOpenRedoAction=NULL;
			}
			posRedo = m_RedoStack.GetHeadPosition();
			while(posRedo != NULL)
			{
				m_RedoStack.GetNext(posRedo)->Release();
			}
			m_RedoStack.RemoveAll();
			// Call OnNextAdd on the top of stack
			posUndo = m_UndoStack.GetHeadPosition();
			if(posUndo != NULL)
				m_UndoStack.GetAt(posUndo)->OnNextAdd();
			m_UndoStack.AddHead(pUA);
#ifdef _DEBUG
			BSTR bstrDesc;
			pUA->GetDescription(&bstrDesc);
			ASSERT(wcslen(bstrDesc) > 0);
			SysFreeString(bstrDesc);
#endif
			break;
		case usUndoState:
			m_RedoStack.AddHead(pUA);
			m_cRollbackCtr++;
			break;
		case usRedoState:
			m_UndoStack.AddHead(pUA);
			m_cRollbackCtr++;
			break;
		default:
			ASSERT(FALSE);
			return E_FAIL;
			break;
		}

		// We're keeping the interface pointer pUA so AddRef it!
		pUA->AddRef();
		OnStackChange();

	CATCH_ALL(pe)
	{
		hr = COleException::Process(pe);
		pe->Delete();
	}
	END_CATCH_ALL

	return hr;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::DiscardFrom

Description: Discard all Undo stack entries prior to a given entry

Return Values:	S_OK
				E_INVALIDARG, if Action not found in stack
				E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::DiscardFrom
(
IOleUndoUnit *pUA // Pointer to Undo Action
)
{
	POSITION posUndo, posRedo, posTemp;

	if(pUA==NULL) // if pUA NULL, discard both Undo/Redo Stacks entirely
	{
		// Traverse UndoStack from Head to Tail, releasing each member, then delete stack
		posUndo = m_UndoStack.GetHeadPosition();
		while(posUndo != NULL)
		{
			m_UndoStack.GetNext(posUndo)->Release();
		}
		m_UndoStack.RemoveAll();
		if(m_pOpenUndoAction)
		{
			m_pOpenUndoAction->Release();
			m_pOpenUndoAction=NULL;
		}
		// Traverse RedoStack from Head to Tail, releasing each member, then delete stack
		posRedo = m_RedoStack.GetHeadPosition();
		while(posRedo != NULL)
		{
			m_RedoStack.GetNext(posRedo)->Release();
		}
		m_RedoStack.RemoveAll();
		if(m_pOpenRedoAction)
		{
			m_pOpenRedoAction->Release();
			m_pOpenRedoAction=NULL;
		}
		OnStackChange();
		return S_OK;
	}

	// Caller wishes to discard from a particular item to the end.
	// Traverse UndoStack from Head to Tail, searching for the particular Action
	for(posUndo = m_UndoStack.GetHeadPosition();
		(posUndo != NULL) && m_UndoStack.GetAt(posUndo)!=pUA;
		m_UndoStack.GetNext(posUndo));

	if(!posUndo)
		return E_INVALIDARG; // if Action not found, return E_INVALIDARG

	// Remove this item and everything after it.
	//
	while (posUndo != NULL)
	{
		posTemp = posUndo;
		m_UndoStack.GetNext(posUndo)->Release();
		m_UndoStack.RemoveAt(posTemp);
	}

	OnStackChange();
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::UndoTo

Description: Perform undo actions back thru the Undo Stack up to & including
the specified object

Return Values:
		S_OK,	 OK
		E_UNEXPECTED, if disabled
		E_INVALIDARG,	 The specified object is not in the stack
		E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::UndoTo
(
IOleUndoUnit *pUA // Pointer to Undo Action
)
{
	IOleUndoUnit *pUA1;
	HRESULT	hr;

	ASSERT(m_usManagerState==usBaseState);

	if(!m_fEnable)
		return E_UNEXPECTED;

	if(m_pOpenUndoAction||m_pOpenRedoAction) // Operation not allowed if open child object
		return E_UNEXPECTED;

	POSITION pos;
	if(pUA==NULL)
	{
		// No target object specified; undo the last action on the stack.
		//
		pos = m_UndoStack.GetHeadPosition();
		if(pos != NULL)
			pUA=m_UndoStack.GetAt(pos);
		else
			return E_UNEXPECTED;
	}
	else
	{
		// Make sure that the specified action is in the stack.
		//
		for(pos = m_UndoStack.GetHeadPosition();
			pos != NULL && m_UndoStack.GetAt(pos) != pUA;
			m_UndoStack.GetNext(pos));

		// If not found, return error
		if(pos == NULL)
			return E_INVALIDARG;
	}

	// Put Undo Manager into Undo State
	m_usManagerState=usUndoState;

	// Traverse stack, call Do methods, release Iface ptrs, remove from stack
	// Knowns: Stack is non-empty and element has been found in stack
	do
	{
		m_cRollbackCtr=0;
		pUA1 = m_UndoStack.RemoveHead();
		hr = pUA1->Do(this);
		pUA1->Release();
	}
	while(m_UndoStack.GetHeadPosition() != NULL	&& (pUA1!=pUA) && SUCCEEDED(hr));

	// Put Undo Manager into Base State
	m_usManagerState=usBaseState;

	if(SUCCEEDED(hr))
	{
		OnStackChange();
		return S_OK;
	}
	else
	{
		//This handles the rollback case where an Undo action fails
		//If Undo fails & nothing added to Redo stack, only return error code & map E_ABORT to E_FAIL
		if(m_cRollbackCtr<=0)
		{
			DiscardFrom(NULL);
			OnStackChange();
			return MapAbortResult(hr);
		}
		if(m_pOpenRedoAction) // Operation not allowed if open child object
		{
			ASSERT(FALSE);
			goto Abort;
		}

		POSITION posRedo;
		posRedo = m_RedoStack.GetHeadPosition();
		if(posRedo == NULL)
		{
			DiscardFrom(NULL);
			OnStackChange();
			return MapAbortResult(hr);
		}
		// Put Undo Manager into Redo State
		m_usManagerState=usRedoState;

		//Preserve the error code & rollback the top of the redo stack
		HRESULT hr1=hr;
		pUA1=m_RedoStack.GetAt(posRedo);
		m_RedoStack.RemoveAt(posRedo);
		hr=pUA1->Do(NULL);
		pUA1->Release();

		// Put Undo Manager back into Base State
		m_usManagerState=usBaseState;

		if(FAILED(hr))
			goto Abort;
		else
		{
			// Rollback succeeded!
			DiscardFrom(NULL);
			OnStackChange();
			return MapAbortResult(hr1);
		}
	}

Abort:
	DiscardFrom(NULL);
	OnStackChange();
	return E_ABORT;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::RedoTo

Description: Perform redo actions back thru the Redo Stack up to & including
the specified object

Return Values:
		S_OK,	 OK
		E_UNEXPECTED, if disabled
		E_INVALIDARG,	 The specified object is not in the stack
		E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::RedoTo
(
IOleUndoUnit *pUA // Pointer to Undo Action
)
{
	IOleUndoUnit *pUA1;
	HRESULT	hr;

	ASSERT(m_usManagerState==usBaseState);

	if(!m_fEnable)
		return E_UNEXPECTED;

	if(m_pOpenUndoAction||m_pOpenRedoAction) // Operation not allowed if open child object
		return E_UNEXPECTED;

	POSITION pos;
	if(pUA==NULL)
	{
		pos = m_RedoStack.GetHeadPosition();
		if(pos != NULL)
			pUA=m_RedoStack.GetAt(pos);
		else
			return E_UNEXPECTED;
	}
	else
	{
		// Search for input Action in Redo stack
		for(pos = m_RedoStack.GetHeadPosition();
			pos != NULL && m_RedoStack.GetAt(pos) != pUA;
			m_RedoStack.GetNext(pos)
		);
		// If not found, return error
		if(pos == NULL)
			return E_INVALIDARG;
	}
	// Put Undo Manager into Redo State
	m_usManagerState=usRedoState;

	// Traverse stack, call Do methods, release Iface ptrs, remove from stack
	// Knowns: Stack is non-empty and element has been found in stack
	//
	pos = m_RedoStack.GetHeadPosition();
	do
	{
		// Zero Rollback counter to count actions added to Redo stack
		m_cRollbackCtr=0;
		pUA1 = m_RedoStack.GetAt(pos);
		m_RedoStack.RemoveAt(pos);
		hr=pUA1->Do(this);
		pUA1->Release();
		pos = m_RedoStack.GetHeadPosition();
	}
	while(pos != NULL && (pUA1!=pUA)&&SUCCEEDED(hr));

	// Put Undo Manager into Base State
	m_usManagerState=usBaseState;

	if(SUCCEEDED(hr))
	{
		OnStackChange();
		return S_OK;
	}
	else
	{
		//This handles the rollback case where a Redo action fails
		//If Redo fails & nothing added to Undo stack, only return error code & map E_ABORT to E_FAIL
		if(m_cRollbackCtr<=0)
		{
			DiscardFrom(NULL);
			OnStackChange();
			return MapAbortResult(hr);
		}
		if(m_pOpenUndoAction) // Operation not allowed if open child object
		{
			ASSERT(FALSE);
			goto Abort;
		}

		POSITION posUndo;
		posUndo = m_UndoStack.GetHeadPosition();
		if(posUndo == NULL)
		{
			DiscardFrom(NULL);
			OnStackChange();
			return MapAbortResult(hr);
		}
		// Put Undo Manager into Undo State
		m_usManagerState=usUndoState;

		//Preserve the error code & rollback the top of the undo stack
		HRESULT hr1=hr;
		pUA1 = m_UndoStack.GetAt(posUndo);
		m_UndoStack.RemoveAt(posUndo);
		hr=pUA1->Do(NULL);
		pUA1->Release();

		// Put Undo Manager back into Base State
		m_usManagerState=usBaseState;

		if(FAILED(hr))
			goto Abort;
		else
		{
			// Rollback succeeded!
			DiscardFrom(NULL);
			OnStackChange();
			return MapAbortResult(hr1);
		}
	}

Abort:
	DiscardFrom(NULL);
	OnStackChange();
	return E_ABORT;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::EnumUndoable

Description: Make an enumeration list of the top-level undoable actions

Return Values: S_OK
			   E_UNEXPECTED, if no open child object
			   E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::EnumUndoable
(
IEnumOleUndoUnits **ppEnum // Pointer to Enumeration Interface to return
)
{
	if(!ppEnum)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	*ppEnum=NULL;
	if(m_pOpenUndoAction||m_pOpenRedoAction) // Operation not allowed if open child object
		return E_UNEXPECTED;

	*ppEnum=(IEnumOleUndoUnits *) new CEnumOleUndoUnit(this, &m_UndoStack);
	if (*ppEnum != NULL)
	{
		// Note that CEnumOleUndoUnit's constructor sets the reference
		// count to 1.
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::EnumRedoable

Description: Make an enumeration list of the top-level redoable actions

Return Values: S_OK
			   E_UNEXPECTED, if no open child object
			   E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::EnumRedoable
(
IEnumOleUndoUnits **ppEnum // Pointer to Enumeration Interface to return
)
{
	if(!ppEnum)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	*ppEnum=NULL;
	if(m_pOpenUndoAction||m_pOpenRedoAction) // Operation not allowed if open child object
		return E_UNEXPECTED;

	*ppEnum=(IEnumOleUndoUnits *) new CEnumOleUndoUnit(this, &m_RedoStack);
	if (*ppEnum != NULL)
	{
		// Note that CEnumOleUndoUnit's constructor sets the reference
		// count to 1.
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::GetLastUndoDescription

Description: Get description of top-level Action object on top of Undo Stack

Return Values:
		S_OK, if, OK
		E_FAIL, Error:	Stack is Empty
		E_UNEXPECTED,	Error:	open child action
		pstr points to the description string
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::GetLastUndoDescription
(
BSTR *pbstr  // Pointer to string buffer to return description
)
{
	if(!pbstr)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	*pbstr=NULL;
	if(m_pOpenUndoAction||m_pOpenRedoAction||!m_fEnable) // Operation not allowed if open child object
		return E_UNEXPECTED;

	POSITION pos;
	pos = m_UndoStack.GetHeadPosition();
	if(pos == NULL)
		return E_FAIL;
	else
		return m_UndoStack.GetAt(pos)->GetDescription(pbstr);
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::GetLastRedoDescription

Description: Get description of top-level Action object on top of Redo Stack

Return Values:
		S_OK, if, OK
		E_FAIL, Error:	Stack is Empty
		E_UNEXPECTED,	Error:	open child action
		pstr points to the description string
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::GetLastRedoDescription
(
BSTR *pbstr  // Pointer to string buffer to return description
)
{
	if(!pbstr)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	*pbstr=NULL;
	if(m_pOpenUndoAction||m_pOpenRedoAction||!m_fEnable) // Operation not allowed if open child object
		return E_UNEXPECTED;

	POSITION pos;
	pos = m_RedoStack.GetHeadPosition();
	if(pos == NULL)
		return E_FAIL;
	else
		return m_RedoStack.GetAt(pos)->GetDescription(pbstr);
}


/*-----------------------------------------------------------------------------
Name: COleUndoManager::Enable

Description: Enables/Disables the Undo/Redo Manager

Return Values:	S_OK

-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::Enable
(
BOOL fEnable // Enable or Disable the UndoManager
)
{
	//Disallow enable processing during UndoTo/RedoTo operation
	if(m_usManagerState!=usBaseState)
		return E_UNEXPECTED;
	//Disallow enable processing if any open child object
	if(m_pOpenUndoAction||m_pOpenRedoAction)
		return E_UNEXPECTED;
	m_fEnable=fEnable;
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::GetOpenParentState

Description: Get State of Open Compound Undo Action

Return Values:	S_OK, if there is an open action
				S_FALSE, if no open action

-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoManager::GetOpenParentState
(
DWORD *pdwState // Pointer to State Flags to return
)
{
	*pdwState=NULL;

	switch(m_usManagerState)
	{
		case usBaseState:
		case usRedoState:
			if(m_pOpenUndoAction)
			{
				m_pOpenUndoAction->GetParentState(pdwState);
				return S_OK;
			}
			else
				return S_FALSE;

		  case usUndoState:
			if(m_pOpenRedoAction)
			{
				m_pOpenRedoAction->GetParentState(pdwState);
				return S_OK;
			}
			else
				return S_FALSE;

		  default:
				ASSERT(FALSE);
				return E_FAIL;
	}
}

/*-----------------------------------------------------------------------------
Name: COleUndoManager::OnStackChange

Description: Processes notification that stack has changed

Return Values:	none

-----------------------------------------------------------------------------*/
void COleUndoManager::OnStackChange
(
)
{
	int cUndoStackCount=m_UndoStack.GetCount(),
		cRedoStackCount=m_RedoStack.GetCount();

	// If either stack changes from empty to non-empty or vice-versa, dirty
	// The menus to make the undo/redo dropdown controls enable/disable themselves
	if((m_fUndoStackIsEmpty&&(cUndoStackCount>0)) ||
	   (!m_fUndoStackIsEmpty&&(cUndoStackCount==0)) ||
	   (m_fRedoStackIsEmpty&&(cRedoStackCount>0)) ||
	   (!m_fRedoStackIsEmpty&&(cRedoStackCount==0)))
	{
		// Dirty the menus
		theApp.m_bMenuDirty = TRUE;
		m_fUndoStackIsEmpty=(cUndoStackCount==0);
		m_fRedoStackIsEmpty=(cRedoStackCount==0);
	}
}


///////////////////////////////////////////////////////////////////////////////
// CEnumOleUndoUnit
/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::CEnumOleUndoUnit

Description: Constructor for CEnumOleUndoUnit Object

Return Values:  None

-----------------------------------------------------------------------------*/
CEnumOleUndoUnit::CEnumOleUndoUnit
(
IOleUndoManager * pUndoMgr,
CTypedPtrList<CPtrList, IOleUndoUnit *>  *pActionList // Undo/Redo stack to enumerate
) :
m_cRef(1),
m_cPos(0),
m_pActionList(pActionList)
{
	m_srpUndoMgr = pUndoMgr;
	if (m_srpUndoMgr)
		m_srpUndoMgr->AddRef();
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::CEnumOleUndoUnit

Description: Overloaded Constructor for CEnumOleUndoUnit Object

Return Values:  None

-----------------------------------------------------------------------------*/
CEnumOleUndoUnit::CEnumOleUndoUnit
(
IOleUndoManager * pUndoMgr,
CTypedPtrList<CPtrList, IOleUndoUnit *>  *pActionList, // Undo/Redo stack to enumerate
ULONG cPos //  Position of current Action in enumeration object
) :
m_cRef(1),
m_cPos(cPos),
m_pActionList(pActionList)
{
	m_srpUndoMgr = pUndoMgr;
	if (m_srpUndoMgr)
		m_srpUndoMgr->AddRef();
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::QueryInterface

Description:
    Query the object for an OLE interface.

Return Values:	 
    NO_ERROR to indicate the interface is supported, in which case
    *ppvObj is filled in; otherwise, *ppvObj is set to NULL.
-----------------------------------------------------------------------------*/
STDMETHODIMP CEnumOleUndoUnit::QueryInterface
(
REFIID riid,        // requested interface
void ** ppvObj  // receives pointer to interface
)
{
	if (ppvObj == NULL)
		return E_INVALIDARG;
		
	*ppvObj = NULL;

	if (riid==IID_IUnknown)
		*ppvObj = (void *)(IUnknown *)this;
	else if (riid==IID_IEnumOleUndoUnits)
		*ppvObj = (void *)(IEnumOleUndoUnits *)this;
	else
		return E_NOINTERFACE;

	((IUnknown *)*ppvObj)->AddRef();
	return NOERROR;
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::AddRef

Description:
    Add a reference to this object.

Return Values:
    The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CEnumOleUndoUnit::AddRef()
{
	return( ++m_cRef );
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::Release

Description:
    Release a reference to this object.

Return Values:
    The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CEnumOleUndoUnit::Release()
{
	ASSERT( m_cRef > 0 );
	int cRef = --m_cRef;
	if (cRef==0)
		delete this;
	return cRef;
}


/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::Next

Description: Returns next item in Action enumeration list

Return Values:
        S_OK       OK, the number of elements returned is celt
		S_FALSE    The number of elements returned is less than celt
		E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP CEnumOleUndoUnit::Next
(
ULONG celt, // Number of Undo/Redo Actions requested from enumeration object
IOleUndoUnit **rgelt, // Array to put Undo Actions that were fetched
ULONG *pceltFetched // Actual number of Actions returned from enumeration object
)
{
	DWORD i;
	ULONG cFetched;

	// NULL output parameters.	Note that the specification for IEnumX
	// states that unused slots in the rgelt array are not set to NULL.
	//
	if (pceltFetched != NULL)
	{
		*pceltFetched = 0;
	}

	if (rgelt == NULL || (celt > 1 && pceltFetched == NULL))
	{
		return E_INVALIDARG;
	}

	POSITION pos = m_pActionList->GetHeadPosition();
	for (i = 0; pos != NULL && i < m_cPos; i++)
	{
		m_pActionList->GetNext(pos);
	}

	for (cFetched = 0; pos != NULL && cFetched < celt; cFetched++)
	{
		rgelt[cFetched] = m_pActionList->GetNext(pos);
		rgelt[cFetched]->AddRef();
	}

	m_cPos += cFetched;

	if (pceltFetched != NULL)
	{
		*pceltFetched = cFetched;
	}

	// If we fetched as many as requested, return S_OK; if
	// we fetched fewer than requested, return S_FALSE.  (Note
	// that if we fetched zero items, possibly because we're
	// at the end of the list, we return S_FALSE.)
	//
	return (cFetched == celt) ? S_OK : S_FALSE;
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::Skip

Description: Returns Skip item in Action enumeration list

Return Values:
        S_OK       OK, the number of elements returned is celt
		S_FALSE    The number of elements returned is less than celt

-----------------------------------------------------------------------------*/
STDMETHODIMP CEnumOleUndoUnit::Skip
(
ULONG celt //  Number of Undo/Redo Actions requested from enumeration object
)
{
	if(((unsigned)m_pActionList->GetCount())<=m_cPos+celt)
		return E_INVALIDARG;
	m_cPos+=celt;
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::Reset

Description: Returns Reset item in Action enumeration list

Return Values:  S_OK

-----------------------------------------------------------------------------*/
STDMETHODIMP CEnumOleUndoUnit::Reset()
{
	m_cPos=0;
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: CEnumOleUndoUnit::Clone

Description: Returns Clone item in Action enumeration list

Return Values:
        S_OK       OK, the number of elements returned is celt
		S_FALSE    The number of elements returned is less than celt

-----------------------------------------------------------------------------*/
STDMETHODIMP CEnumOleUndoUnit::Clone
(
IEnumOleUndoUnits** ppEnum // Pointer to cloned Enumeration Interface to return
)
{
	if(!ppEnum)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	*ppEnum=NULL;
	
	*ppEnum=(IEnumOleUndoUnits *) new CEnumOleUndoUnit(m_srpUndoMgr, m_pActionList, m_cPos);
	if (*ppEnum != NULL)
	{
		// Note that CEnumOleUndoUnit's constructor sets the reference
		// count to 1.
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Class COleUndoUnit
///////////////////////////////////////////////////////////////////////////////
// This Class is Sample Code for Undo Implementators and is used for testing

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::COleUndoUnit

Description: Constructor for COleUndoUnit Object

Return Values:  None

-----------------------------------------------------------------------------*/
COleUndoUnit::COleUndoUnit
(
LPOLESTR strDescription, // String to initialize the UndoAction description
BOOL fUndoFail, // Flag to force Undo action to fail
BOOL fRedoFail // Flag to force Redo action to fail
) :
m_cRef(0),
m_atActionType(atUndoAction),
m_fUndoFail(fUndoFail),
m_fRedoFail(fRedoFail)
{
	USES_CONVERSION;
	m_strDesc = OLE2T(strDescription);
}

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::Do

Description:  Perform this Undo Action and put on the other Undo/Redo Stack

Return Values:  S_OK

-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoUnit::Do
(
IOleUndoManager *pUndoActionManager // Pointer to containing Undo Manager
)
{
	BOOL fFail=FALSE;

	if(m_atActionType==atUndoAction)
	{
		m_atActionType=atRedoAction;
		fFail=m_fUndoFail;
	}
	else
	{
		m_atActionType=atUndoAction;
		fFail=m_fRedoFail;
	}

	if(fFail)
		return E_FAIL;
	if(pUndoActionManager) // if NULL, pretend to do it, i.e. only return S_OK
		pUndoActionManager->Add((IOleUndoUnit *)this);
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::GetDescription

Description:  Get description of the UndoAction Object

Return Values:  S_OK
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoUnit::GetDescription
(
BSTR *pbstr  // Pointer to string buffer to return description
)
{
	USES_CONVERSION;

	*pbstr=::SysAllocString(T2OLE(m_strDesc));
	if(*pbstr==NULL)
		return E_OUTOFMEMORY;
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::GetUnitType

Description: Returns a Class ID and Type ID for this object

Return Values:  S_OK
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoUnit::GetUnitType
(
CLSID *pclsid,
LONG *pnID
)
{
	//$COMMENT Implementers should put in their own GUIDs here
	*pclsid=CLSID_NULL;
	*pnID=0;
    return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::OnNextAdd

Description:  Sends notification to its creating object to not continue
              inserting data through private interfaces to it

Return Values:	None
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoUnit::OnNextAdd()
{
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::QueryInterface

Description:
    Query the object for an OLE interface.

Return Values:	 
    NOERROR, to indicate the interface is supported, in which case
        *ppvObj is filled in; otherwise, *ppvObj is set to NULL.
    E_NOINTERFACE to indicate the interface is not supported
-----------------------------------------------------------------------------*/
STDMETHODIMP COleUndoUnit::QueryInterface
(
REFIID riid,        // requested interface
void ** ppvObj  // receives pointer to interface
)
{
	if (ppvObj == NULL)
		return E_INVALIDARG;
		
	*ppvObj = NULL;

	if (riid==IID_IUnknown)
        *ppvObj = (void *)(IUnknown *)(IUnknown *)this;
    else if (riid==IID_IOleUndoUnit)
        *ppvObj = (void *)(IOleUndoUnit *)this;
	else
        return E_NOINTERFACE;

    ((IUnknown *)*ppvObj)->AddRef();
    return NOERROR;
}


/*-----------------------------------------------------------------------------
Name: COleUndoUnit::AddRef

Description:
    Add a reference to this object.

Return Values:
    The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) COleUndoUnit::AddRef()
{
	return( ++m_cRef );
}

/*-----------------------------------------------------------------------------
Name: COleUndoUnit::Release

Description:
    Release a reference to this object.

Return Values:
    The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) COleUndoUnit::Release()
{
	ASSERT( m_cRef > 0 );
	int cRef = --m_cRef;
	if (cRef==0)
		delete this;
	return cRef;
}

///////////////////////////////////////////////////////////////////////////////
// Class COleParentUndoUnit
///////////////////////////////////////////////////////////////////////////////
// This Class is Sample Code for Undo Implementators and is used for testing

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::COleParentUndoUnit

Description: Constructor for COleParentUndoUnit Object

Return Values:  None

-----------------------------------------------------------------------------*/
COleParentUndoUnit::COleParentUndoUnit
(
UNDOACTIONTYPE atActionType, // Type of compound action (Undo or Redo)
LPOLESTR strDescription // String to initialize the UndoAction description
) :
m_cRef(0),
m_fActionBlocked(FALSE),
m_atActionType(atActionType),
m_pOpenAction(NULL)
{
	USES_CONVERSION;
	m_strDesc = OLE2T(strDescription);
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::Open

Description: Open a new empty compound action to the top of this compound action

Return Values:
    S_OK, OK
	E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::Open
(
IOleParentUndoUnit *pCUA // Pointer to Compound Undo Action
)
{
	if(!pCUA)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	if(m_fActionBlocked) // if blocked, return S_OK
		return S_OK;

	if(m_pOpenAction)
		return m_pOpenAction->Open(pCUA);
	else
	{
		m_pOpenAction=pCUA;
		m_pOpenAction->AddRef();
		return S_OK;
	}
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::Close

Description: Close the currently open compound undo action list

Return Values: S_OK, if ok
			   S_FALSE, if no open child
			   E_INVALIDARG, if pCUA is not the last currently open object
			   E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::Close
(
IOleParentUndoUnit *pCUA, // Pointer to Compound Undo Action
BOOL fCommit // Flag to keep or discard the completed compound undo action list
)
{
	HRESULT hr;

	if(m_fActionBlocked)
	{
		if(pCUA!=(IOleParentUndoUnit *)this)
			return S_OK;
		else
		{
			ASSERT(m_pOpenAction==NULL);
			m_fActionBlocked=FALSE;
			return FALSE;
		}
	}	
	else if(m_pOpenAction)
	{
		hr=m_pOpenAction->Close(pCUA, fCommit);
		if(hr!=S_FALSE)
			return hr;
		if(pCUA!=m_pOpenAction)
			return E_INVALIDARG;
		if(!fCommit)
		{
			m_pOpenAction->Release();
			m_pOpenAction=NULL;
			return S_OK;
		}
		m_culCompoundActionList.AddHead(m_pOpenAction);
		m_pOpenAction=NULL;
		return S_OK;
	}
	else
	{
		m_fActionBlocked=FALSE;
		return S_FALSE;
	}
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::Add

Description: Add a simple undo action to this compound action

Return Values:  S_OK, if ok
                E_FAIL, Thrown Error

-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::Add
(
IOleUndoUnit *pUA // Pointer to Undo Action
)
{
	if(!pUA)
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}
	if(m_fActionBlocked) // if blocked, return S_OK
		return S_OK;

	if(m_pOpenAction)
		return m_pOpenAction->Add(pUA);
	m_culCompoundActionList.AddHead(pUA);
	    // We're keeping the interface pointer pUA so AddRef it!
    pUA->AddRef();
    return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::FindUnit

Description: Not Implemented yet!

Return Values:

-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::FindUnit
(
IOleUndoUnit *pUA // Pointer to Undo Action to find
)
{
	IOleUndoUnit *pUA1;
	void * pvDummy;

	if(pUA==(IOleUndoUnit *)this)
		return S_OK;

	for(POSITION Pos = m_culCompoundActionList.GetHeadPosition();
		NULL != Pos;   )
	{		
		pUA1 = m_culCompoundActionList.GetNext(Pos);
		if(pUA1 == pUA)
			return S_OK;
		if((pUA1->QueryInterface(IID_IOleParentUndoUnit, &pvDummy)!=
			E_NOINTERFACE) &&
		   ((IOleParentUndoUnit *)pUA1)->FindUnit(pUA)==S_OK)
			return S_OK;
	}
    return S_FALSE;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::GetParentState

Description: Get State of Open Compound Undo Action

Return Values:

-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::GetParentState
(
DWORD *pdwState // Pointer to State Flags to return
)
{
	if(m_fActionBlocked)
		*pdwState=UAS_BLOCKED;
	else if(m_pOpenAction)
		m_pOpenAction->GetParentState(pdwState);
	else
		*pdwState=UAS_NORMAL;
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::Do

Description:  Perform this Undo Action and put on the other Undo/Redo Stack

Return Values:  S_OK, if OK
                E_FAIL, Thrown Error
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::Do
(
IOleUndoManager *pUndoActionManager // Pointer to containing Undo Manager
)
{
	USES_CONVERSION;

	COleParentUndoUnit *cuaCAction;
	IOleUndoUnit *pUA;
	HRESULT hr = NOERROR;

	ASSERT(m_pOpenAction==NULL);
	ASSERT(!m_fActionBlocked);

	if(m_atActionType==atUndoAction)
	{
		// For debugging only write a debug string out to the debug window
		m_atActionType=atRedoAction;
	}
	else
	{
		// For debugging only write a debug string out to the debug window
		m_atActionType=atUndoAction;
	}

	if(pUndoActionManager)
	{
		cuaCAction=new COleParentUndoUnit(m_atActionType, T2OLE(m_strDesc));
		hr=pUndoActionManager->Open(cuaCAction);
		ASSERT(SUCCEEDED(hr));
	}


	POSITION Pos;
	// Traverse stack, call Do methods, release Iface ptrs, remove from stack
	int cStateChange=0;
	while(!m_culCompoundActionList.IsEmpty() && SUCCEEDED(hr))
	{
		pUA = m_culCompoundActionList.RemoveHead();
		ASSERT(NULL != pUA);
		hr = pUA->Do(pUndoActionManager);
		//Note:  this also applies to RedoTo below!
		if(SUCCEEDED(hr))
			cStateChange++;
		pUA->Release();
	}

	if(!pUndoActionManager)
	{
		if(SUCCEEDED(hr))
			return S_OK;
		else
			return hr;
	}

	if(SUCCEEDED(hr))
	{
		pUndoActionManager->Close(cuaCAction, TRUE);
		return S_OK;
	}
	else if(cStateChange>0)
	{
		pUndoActionManager->Close(cuaCAction, TRUE);
		return hr;
	}
	else
	{
		pUndoActionManager->Close(cuaCAction, FALSE);
		return hr;
	}
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::GetDescription

Description: Get description of the UndoAction Object

Return Values:  S_OK
                pstr points to the description string
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::GetDescription
(
BSTR *pbstr  // Pointer to string buffer to return description
)
{
	USES_CONVERSION;

	*pbstr=::SysAllocString(T2OLE(m_strDesc));
	if(*pbstr==NULL)
		return E_OUTOFMEMORY;
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::GetUnitType

Description: Returns a Class ID and Type ID for this object

Return Values:  S_OK
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::GetUnitType
(
CLSID *pclsid,
LONG *pnID
)
{
	//$COMMENT Implementers should put in their own GUIDs here
	*pclsid=CLSID_NULL;
	*pnID=0;
    return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::OnNextAdd

Description:  Sends notification to its creating object to not continue
              inserting data through private interfaces to it

Return Values:	None
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::OnNextAdd()
{
	//$CONSIDER I don't think the spec is clear on what this should do for blocked Actions!
	if(m_pOpenAction)
		m_pOpenAction->OnNextAdd();
	return S_OK;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::QueryInterface

Description:
    Query the object for an OLE interface.

Return Values:	 
    NO_ERROR to indicate the interface is supported, in which case
    *ppvObj is filled in; otherwise, *ppvObj is set to NULL.
-----------------------------------------------------------------------------*/
STDMETHODIMP COleParentUndoUnit::QueryInterface
(
REFIID riid,        // requested interface
void ** ppvObj  // receives pointer to interface
)
{
	if (ppvObj == NULL)
		return E_INVALIDARG;
		
	*ppvObj = NULL;

	if (riid==IID_IUnknown)
		//$CONSIDER Should I give out the IUnknown of the CCompDocHost here instead?
        *ppvObj = (void *)(IUnknown *)(IUnknown *)this;
    else if (riid==IID_IOleParentUndoUnit)
        *ppvObj = (void *)(IOleParentUndoUnit *)this;
	else
        return E_NOINTERFACE ;

    ((IUnknown *)*ppvObj)->AddRef();
    return NOERROR;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::AddRef

Description:
    Add a reference to this object.

Return Values:
    The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) COleParentUndoUnit::AddRef()
{
	return( ++m_cRef );
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::Release

Description:
    Release a reference to this object.

Return Values:
    The number of outstanding references.
-----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) COleParentUndoUnit::Release()
{
	ASSERT( m_cRef > 0 );
    int cRef = --m_cRef;
    if (cRef==0)
	{
		// Traverse Compound Stack from Head to Tail, releasing each member, then delete stack
		POSITION Pos = m_culCompoundActionList.GetHeadPosition();
		IOleUndoUnit *pUA;
		while(NULL != Pos)
		{
			pUA = m_culCompoundActionList.GetNext(Pos);
			pUA->Release();
		}
		m_culCompoundActionList.RemoveAll();
		delete this;
	}
	return cRef;
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::IsEmpty

Description:
    Determine if the undo action list is empty

Return Values:
    TRUE == empty, FALSE == not empty
-----------------------------------------------------------------------------*/
BOOL COleParentUndoUnit::IsUndoActionListEmpty()
{ 
	return ((m_culCompoundActionList.GetCount() == 0) ? TRUE : FALSE);
}

/*-----------------------------------------------------------------------------
Name: COleParentUndoUnit::IsEmpty

Description:
    Allow the undo description to be modified

Return Values:
-----------------------------------------------------------------------------*/
void COleParentUndoUnit::SetUndoDesc(LPCTSTR szDesc)
{ 
	ASSERT(NULL != szDesc); 
	m_strDesc = szDesc; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\keycust.h ===
// keycust.h : header file
//

#include "tap.h"
#include "resource.h"
#include "customiz.h"

#define FILL_NO_SEL		-2		// SetCurSel(-1) deselects everything.
								// This says don't even call SetCurSel()

#define NUM_ACC_RES_TABLES	4

struct AccResTable
{
	LPSTR lpstrResID;
	const char* name;
};

typedef struct tagAccCmd
{
	UINT id;
	const char* name;
} AccCmd;

typedef struct tagAccGrp
{
	const char* name;
	const UINT* list;
} AccGrp;

typedef struct tagAccTable
{
	HACCEL hAcc;
	const char* name;
} AccTable;

extern AccResTable AccResTables[];
extern AccCmd AccCommands[];
extern AccGrp AccGroups[];

/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg dialog

class CKeyListBox : public CListBox
{
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
};

class CKeyCustDlg : public CCommandTab
{
// Construction
public:
	CKeyCustDlg(AccTable* pAccTable, int nAccTables);
	~CKeyCustDlg();

// Dialog Data
	//{{AFX_DATA(CKeyCustDlg)
	enum { IDD = IDDP_CUSTOMIZE_KEYBOARD };
	CComboBox	m_ScopeList;
	CListBox	m_CmdList;
	CComboBox	m_CatList;
	//}}AFX_DATA

	CTap m_Tap;

	int m_nAccelTables;
	CKeymap* m_pKeymap;
	int m_iCurScope;

	CKeyListBox m_keyList;
	CAppToolGroups* m_pAppToolGroups;

// Operations
protected:
	virtual int InitScopeList(int nSel = 0);
	virtual int FillCategoriesList(int nSel = 0);
	virtual int FillCommandsList(int nCat = -1, int nSel = 0);
	virtual int FillKeysList(UINT nID = -1, int nSel = -1);
	void AddKeymapToListBox(CKeymap* pKeymap, CListBox* pList, UINT nID, 
		const char* szPrefix, WORD kcPrefix, BOOL bInherited = FALSE);

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	//REVIEW: Support for a dirty command cache
	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);

	// Generated message map functions
	//{{AFX_MSG(CKeyCustDlg)
	virtual BOOL OnInitDialog();
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);
	afx_msg void OnSelChangeCatList();
	afx_msg void OnSelChangeCmdList();
	afx_msg void OnClickedAssign();
	afx_msg void OnClickedRemove();
	afx_msg void OnClickedResetAll();
	afx_msg void OnSelChangeScopeList();
	afx_msg void OnSelChangeKeyList();
	//}}AFX_MSG
	afx_msg void OnChangeTap();

	DECLARE_MESSAGE_MAP()

// Helper functions
public:
	int MaintainListSel(CListBox* pList, DWORD dwData);
	DWORD AccelToDWord(ACCEL& accel);
	ACCEL DWordToAccel(DWORD dw);
	BOOL GetCurrentAssignment(CKeymap* pKeymap, CString& str);
	BOOL IsMenuAccel( WORD kc );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\keycust.cpp ===
/////////////////////////////////////////////////////////////////////////////
//      KEYCUST.CPP
//              Keyboard customization dialog.

#include "stdafx.h"
#include "main.h"
#include "keycust.h"
#include "imeutil.h"
#include "bardockx.h"
#include "barglob.h"
#include "customiz.h"

#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define KCF_INHERITED 0x0400 // FUTURE: move to main.h

// Parameter to InitScopeList to cause init to current packet
#define FILL_SEL_CURRENT -3
// CATEGORY in the category list that contains all commands
#define CATEGORY_ALL_COMMANDS -1

void GetCmdDescription(UINT nCmdID, CString& str)
{
	LPCTSTR szPrompt;
	if (theCmdCache.GetCommandString(nCmdID, STRING_PROMPT, &szPrompt))
		str = szPrompt;
	else
		VERIFY( str.LoadString( IDS_UNDESCRIBED ) );
}

WORD KcFromAccel(const ACCEL& accel)
{
	WORD kc = accel.key;
	ASSERT((kc & 0xff) == kc);
	if ((accel.fVirt & FVIRTKEY) == 0)
		kc |= KCF_ASCII;
	if ((accel.fVirt & FSHIFT) != 0)
		kc |= KCF_SHIFT;
	if ((accel.fVirt & FCONTROL) != 0)
		kc |= KCF_CONTROL;
	if ((accel.fVirt & FALT) != 0)
		kc |= KCF_ALT;
	return kc;
}

void AccelFromKc(ACCEL& acc, WORD kc, UINT nCmdID = 0)
{
	acc.fVirt = 0;
	if ((kc & KCF_ASCII) == 0)
		acc.fVirt |= FVIRTKEY;
	if ((kc & KCF_SHIFT) != 0)
		acc.fVirt |= FSHIFT;
	if ((kc & KCF_CONTROL) != 0)
		acc.fVirt |= FCONTROL;
	if ((kc & KCF_ALT) != 0)
		acc.fVirt |= FALT;
	acc.key = kc & 0xff;
	acc.cmd = (WORD)nCmdID;
}

/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg dialog

CKeyCustDlg::CKeyCustDlg(AccTable* pAccTable, int nAccTables)
	: CCommandTab(CKeyCustDlg::IDD, IDS_KEYBOARD)
{
	m_iCurScope = -1;
	m_pKeymap = NULL;
	m_pAppToolGroups = NULL;

	//{{AFX_DATA_INIT(CKeyCustDlg)
	//}}AFX_DATA_INIT
}

CKeyCustDlg::~CKeyCustDlg()
{
	if (m_pAppToolGroups != NULL)
		CAppToolGroups::ReleaseAppToolGroups();
}

void CKeyCustDlg::DoDataExchange(CDataExchange* pDX)
{
	CCommandTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyCustDlg)
	DDX_Control(pDX, IDC_SCOPE_LIST, m_ScopeList);
	DDX_Control(pDX, IDC_CMD_LIST, m_CmdList);
	DDX_Control(pDX, IDC_CAT_COMBO, m_CatList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CKeyCustDlg, CCommandTab)
	//{{AFX_MSG_MAP(CKeyCustDlg)
	ON_WM_VKEYTOITEM()
	ON_CBN_SELCHANGE(IDC_CAT_COMBO, OnSelChangeCatList)
	ON_LBN_SELCHANGE(IDC_CMD_LIST, OnSelChangeCmdList)
	ON_BN_CLICKED(IDC_ASSIGN, OnClickedAssign)
	ON_BN_CLICKED(IDC_REMOVE, OnClickedRemove)
	ON_BN_CLICKED(IDC_RESET_ALL, OnClickedResetAll)
	ON_CBN_SELCHANGE(IDC_SCOPE_LIST, OnSelChangeScopeList)
	ON_LBN_SELCHANGE(IDC_KEY_LIST, OnSelChangeKeyList)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
	ON_CONTROL(TAPN_CHANGE, IDC_TAP, OnChangeTap)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg operations

int CKeyCustDlg::InitScopeList(int nSel)
{
	CComboBox* pList = (CComboBox*)GetDlgItem(IDC_SCOPE_LIST);
	ASSERT(pList != NULL);
	pList->ResetContent();

	// use these to work out which list entry corresponds to the current editor window
	CPacket *pActivePacket=theApp.m_pActivePacket;
	int nCurrentIndex=-1;
	
	POSITION pos = CKeymap::c_keymaps.GetHeadPosition();
	while (pos != NULL)
	{
		CKeymap* pKeymap = (CKeymap*)(void*)CKeymap::c_keymaps.GetNext(pos);
		if (!pKeymap->m_strName.IsEmpty())
		{
			int index = pList->AddString(pKeymap->m_strName);
			pList->SetItemData(index, (DWORD)pKeymap);

			if(pKeymap->m_pPacket==pActivePacket && nCurrentIndex==-1)
			{
				nCurrentIndex=index;
			}
		}
	}

	if(nSel != FILL_NO_SEL)
	{
		if(	nSel==FILL_SEL_CURRENT)
		{
			if(nCurrentIndex!=-1)
			{
				nSel=nCurrentIndex;
			}
			else
			{
				nSel=0;
			}
		}
		pList->SetCurSel(nSel);
		OnSelChangeScopeList();
	}
	return pList->GetCurSel();
}

int CKeyCustDlg::FillCategoriesList(int nSel)
{
	CComboBox* pList = (CComboBox*)GetDlgItem(IDC_CAT_COMBO);
	ASSERT(pList != NULL);
	pList->ResetContent();

	m_pAppToolGroups->FillGroupList( pList );

	// add all commands at the end of the list
	CString strFilter;
	strFilter.LoadString(IDS_ALLCOMMANDS);
	int nIndex=pList->AddString(strFilter);
	if(nIndex!=LB_ERR)
	{
		pList->SetItemData(nIndex, CATEGORY_ALL_COMMANDS);
	}

	if(nSel != FILL_NO_SEL)
	{
		pList->SetCurSel(nSel);
		OnSelChangeCatList();
	}
	return pList->GetCurSel();
}

int CKeyCustDlg::FillCommandsList(int nCat, int nSel)
{
	ASSERT(nCat >= 0 || nCat==CATEGORY_ALL_COMMANDS); 
	
	CListBox* pList = (CListBox*)GetDlgItem(IDC_CMD_LIST);
	ASSERT(pList != NULL);
	pList->SetRedraw(FALSE);
	pList->ResetContent();

	if(nCat!=CATEGORY_ALL_COMMANDS)
	{
		m_pAppToolGroups->FillCommandList( nCat, pList );
	}
	else
	{
		theCmdCache.FillAllCommandsList(pList);
	}
	
	if(nSel != FILL_NO_SEL)
	{
		pList->SetCurSel(nSel);
		OnSelChangeCmdList();
	}
	pList->SetRedraw(TRUE);
	pList->Invalidate();
	
	return pList->GetCurSel();
}

void CKeyCustDlg::AddKeymapToListBox(CKeymap* pKeymap, CListBox* pList, UINT nID, 
	const char* szPrefix, WORD kcPrefix, BOOL bInherited /* = FALSE */)
{
	POSITION pos = m_pKeymap->GetStartPosition();
	while (pos != NULL)
	{
		WORD kc;
		UINT nCmdID;
		CKeymap* pSubKeymap;
		pKeymap->GetNextKey(pos, kc, nCmdID, pSubKeymap);
		
		ACCEL acc;
		AccelFromKc(acc, kc, nCmdID);
		
		WORD kc2 = kc | (bInherited ? KCF_INHERITED : 0);
		if (nCmdID == nID)
		{
			int index = pList->AddString(CString(szPrefix) + CTap::MakeAccelName(acc));
			pList->SetItemData(index, kcPrefix == 0 ? MAKELONG(kc2, 0) : MAKELONG(kcPrefix, kc2));
		}
		else if (pSubKeymap != NULL)
		{
			AddKeymapToListBox(pSubKeymap, pList, nID, CTap::MakeAccelName(acc) + ", ", kc2);
		}
	}
}

int CKeyCustDlg::FillKeysList(UINT nID, int nSel)
{
	CListBox* pList = (CListBox*)GetDlgItem(IDC_KEY_LIST);
	ASSERT(pList != NULL);
	pList->ResetContent();
	if (m_iCurScope != 0)
	{
		CComboBox* plstScope = (CComboBox*)GetDlgItem(IDC_SCOPE_LIST);
		AddKeymapToListBox((CKeymap*)plstScope->GetItemData(0), pList, nID, "", 0, TRUE);
	}
	AddKeymapToListBox(m_pKeymap, pList, nID, "", 0);

	if(nSel != FILL_NO_SEL)
	{
		if (pList->GetCount() > 0)
			pList->SetCurSel(nSel);
		OnSelChangeKeyList();
	}

	// If the list contains no elements, it should be disabled.
//      pList->EnableWindow(pList->GetCount() > 0);

	return pList->GetCurSel();
}


/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg message handlers

BOOL CKeyCustDlg::OnInitDialog()
{
	CCommandTab::OnInitDialog();
	
	ReloadMacros();
	m_pAppToolGroups = CAppToolGroups::GetAppToolGroups(TRUE);

	// Create Tap control in place of the placeholder
	// This control must be dynamically created to get all the features I want.

	CWnd* pWnd = GetDlgItem(IDC_PLACEHOLDER);
	if(pWnd == NULL)
		return TRUE;

	CRect rc;
	pWnd->GetWindowRect(&rc);
	ScreenToClient(&rc);
	CString str = "";       // STUB: generate the name of the accelerator that is initially to be listed

	VERIFY(m_Tap.Create(str, rc, this, IDC_TAP));

	// Copy the help id from the placeholder
	DWORD dwHelpID=pWnd->GetWindowContextHelpId();

	// Move the tap control into the correct place in the tab order
	m_Tap.SetWindowPos( pWnd, 0, 0, 0, 0, 
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOSIZE );
	pWnd->DestroyWindow();

	m_Tap.SetWindowContextHelpId(dwHelpID);
	
	// Fill the various list boxes

	InitScopeList(FILL_SEL_CURRENT);
	FillCategoriesList(0);
	int nCmdsList = 0;

	// If we're supposed to auto-select a command (launched from
	//  Tools.Macro), then do it now.
	if (!m_strInitialCommand.IsEmpty())
	{
		CToolGroup* pToolGroup = m_pAppToolGroups->GroupFromCommandName(m_strInitialCommand);
		if (pToolGroup == NULL)
 		{
			ASSERT(FALSE);
			m_strInitialCommand.Empty();
		}
		else
		{
			// We've got the right group, so find its index in the categories list
			nCmdsList = m_CatList.FindStringExact(-1, pToolGroup->m_strGroup);
			if (nCmdsList == CB_ERR)
			{
				// The command's category isn't in the combo.  Can't be!
				ASSERT(FALSE);
				m_strInitialCommand.Empty();
				nCmdsList = 0;
			}
		}
	}

	m_CatList.SetCurSel(nCmdsList);
	OnSelChangeCatList();
	DWORD dwCat = m_CatList.GetItemData(nCmdsList);
	FillCommandsList(dwCat);

	if (!m_strInitialCommand.IsEmpty())
	{
		// Select the command passed in
		m_CmdList.SelectString(-1, m_strInitialCommand);
		OnSelChangeCmdList();

		// Done with m_strInitialCommand, so empty it out
		m_strInitialCommand.Empty();
	}

	pWnd = GetDlgItem(IDC_USEDBY_CAP);
	pWnd->ShowWindow(SW_HIDE);
	
	CFont* pFont = GetStdFont(FALSE);
	GetDlgItem(IDC_USEDBY)->SetFont(pFont);
	GetDlgItem(IDC_DESCRIPTION_KEYBOARD)->SetFont(pFont);

	m_keyList.SubclassDlgItem(IDC_KEY_LIST, this);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

//REVIEW: Support for a dirty command cache
BOOL CKeyCustDlg::Activate (CTabbedDialog* pParentWnd, CPoint position)
{
	if (m_pAppToolGroups != NULL)
	{
		if (m_pAppToolGroups->ScanCommandCache())
		{
			CComboBox* pList = (CComboBox*)GetDlgItem(IDC_CAT_COMBO);
			FillCategoriesList(pList->GetCurSel());
			OnSelChangeCatList();
		}
	}

	return CCommandTab::Activate(pParentWnd, position);
}

/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg's Listboxes' LBN_SELCHANGE handlers

void CKeyCustDlg::OnSelChangeScopeList()
{
	CComboBox* plstScope = (CComboBox*)GetDlgItem(IDC_SCOPE_LIST);

	m_iCurScope = plstScope->GetCurSel();
	ASSERT(m_iCurScope >= 0);
	m_pKeymap = (CKeymap*)plstScope->GetItemData(m_iCurScope);

	OnSelChangeCmdList();           // will update Keys list
	OnChangeTap();
}

void CKeyCustDlg::OnSelChangeCatList()
{
	CComboBox* plstCat = (CComboBox*)GetDlgItem(IDC_CAT_COMBO);
	int indCat = plstCat->GetCurSel();
	DWORD dwCat = plstCat->GetItemData(indCat);

	CListBox* plstCmd = (CListBox*)GetDlgItem(IDC_CMD_LIST);
	int indCmd = plstCmd->GetCurSel();
	DWORD dwCmd = plstCmd->GetItemData(indCmd);

	FillCommandsList((int)dwCat, FILL_NO_SEL);
	plstCmd->SetCurSel(MaintainListSel(plstCmd, dwCmd));
	OnSelChangeCmdList();
}

void CKeyCustDlg::OnSelChangeCmdList()
{
	CListBox* plstCmd = (CListBox*)GetDlgItem(IDC_CMD_LIST);
	int indCmd = plstCmd->GetCurSel();
	DWORD dwCmd;
	if(indCmd == -1)
	{
		dwCmd = DWORD(-1L);
		m_Tap.EnableWindow(FALSE);              // no command to assign accels to
		EnableButton(GetDlgItem(IDC_ASSIGN), FALSE);
		GetDlgItem(IDC_DESCRIPTION_KEYBOARD)->SetWindowText(""); // clear description
	}
	else
	{
		dwCmd = plstCmd->GetItemData(indCmd);
		m_Tap.EnableWindow(TRUE);               // now valid command to assign new accels to
		BOOL bLegal = m_Tap.IsAccelLegal() && m_Tap.GetAccel().key;

		EnableButton(GetDlgItem(IDC_ASSIGN),bLegal);

		CString str;
		GetCmdDescription((UINT) dwCmd, str);
		GetDlgItem(IDC_DESCRIPTION_KEYBOARD)->SetWindowText(str);
	}

	FillKeysList((int)dwCmd);
}

void CKeyCustDlg::OnSelChangeKeyList()
{
	CListBox* plstKey = (CListBox*)GetDlgItem(IDC_KEY_LIST);
	int indKey = plstKey->GetCurSel();
	DWORD kcPair = plstKey->GetItemData(indKey);
	EnableButton(GetDlgItem(IDC_REMOVE), indKey >= 0 && 
		(kcPair & MAKELONG(KCF_INHERITED, KCF_INHERITED)) == 0);
}

int CKeyCustDlg::OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex)
{
	if(pListBox->GetDlgCtrlID() == IDC_KEY_LIST)
	{
		// FUTURE: key mapping should map to Accel's nChar, not the listbox string
	}
	
	return CCommandTab::OnVKeyToItem(nKey, pListBox, nIndex);
}

BOOL CKeyCustDlg::GetCurrentAssignment(CKeymap* pKeymap, CString& str)
{
	ACCEL accel = m_Tap.GetAccel();
	WORD kc = KcFromAccel(accel);

	if (m_Tap.IsKeySet() && m_Tap.IsAccelLegal())
	{
		UINT nCmdID;

		if (pKeymap->LookupKey(kc, nCmdID, pKeymap))
		{
			if (nCmdID == 0)
			{
				ASSERT(pKeymap != NULL);

				// Lookup second key if we have one...
				if (m_Tap.IsChordSet() && m_Tap.IsChordLegal())
				{
					accel = m_Tap.GetChord();
					kc = KcFromAccel(accel);

					if (pKeymap->LookupKey(kc, nCmdID, pKeymap))
					{
						ASSERT(pKeymap == NULL);
						ASSERT(nCmdID != NULL);
						m_pAppToolGroups->GetCommandName(nCmdID, str);
						return TRUE;
					}
					else
					{
						VERIFY( str.LoadString( IDS_UNASSIGNED ) );
						return FALSE;
					}
				}
				else
				{
					VERIFY( str.LoadString( IDS_PREFIXKEY ) );
					return TRUE;
				}
			}
			else
			{
				m_pAppToolGroups->GetCommandName(nCmdID, str);
				return TRUE;
			}
		}
		else if ( IsMenuAccel(kc) )
		{
			VERIFY( str.LoadString( IDS_MENUACCESS ) );
			return TRUE;
		}
		else
		{
			VERIFY( str.LoadString( IDS_UNASSIGNED ) );
			return FALSE;
		}
	}
	else
	{
		// Leave the string empty...
		return FALSE;
	}

	ASSERT(FALSE); // NOT REACHED
}

// This function used to cache the accelerators. Because of customisation, it can't do that now. This could be
// a speed problem; we shall have to see. If so we'd need to find a way to know if the menu bar had changed.

// The code is further complicated by the need to allow for command bar and menu bar modes. In command bar mode,
// menu accelerators include accelerators for textual toolbar buttons placed on the menu bar, so we must scan the
// real menu bar. In menu bar mode, the menu bar is defined by its current state, since no other representation
// of the menu bar exists any longer

// If we have to do this too often, a menu bar proxy will be in order.
BOOL CKeyCustDlg::IsMenuAccel( WORD kc )
{
	BOOL bFound=FALSE;

	if(Menu::IsShowingCmdBars())
	{
		CASBar *pBar=CASBar::s_pMenuBar;
		ASSERT(pBar);
		if(pBar)
		{
			for (int iMenu=0; iMenu<pBar->GetCount(); iMenu++)
			{
				// if it's not a text button, it can't have an accelerator
				UINT nStyle=pBar->GetButtonStyle(iMenu);
				if ((nStyle & TBBS_TEXTUAL)==0)
				{
					continue;
				}

				// if it's textual, it must have button extra info and a label
				TCHAR chAccel=GLOBAL_DATA::ExtractAccelerator(pBar->GetButtonExtra(iMenu)->GetLabel());
				if(chAccel)
				{
					chAccel=(TCHAR)toupper(chAccel);

					if((chAccel | KCF_ALT)==kc)
					{
						bFound=TRUE;
						break;
					}
				}
			}
		}
	}
	else
	{
		CWnd *pMainFrame=AfxGetMainWnd();
		ASSERT(pMainFrame);
		CMenu *pMenu=pMainFrame->GetMenu();
		ASSERT(pMenu);
		int nCount=pMenu->GetMenuItemCount();

		CString strLabel;

		for (int iMenu=0; iMenu<nCount; iMenu++)
		{
			if(pMenu->GetMenuString(iMenu, strLabel, MF_BYPOSITION)==0)
			{
				continue;
			}

			TCHAR chAccel=GLOBAL_DATA::ExtractAccelerator(strLabel);
			if(chAccel)
			{
				chAccel=(TCHAR)toupper(chAccel);

				if((chAccel | KCF_ALT)==kc)
				{
					bFound=TRUE;
					break;
				}
			}
		}
	}

	return bFound;
}

void CKeyCustDlg::OnChangeTap()
{
	BOOL bLegal = m_Tap.IsAccelLegal() && m_Tap.GetAccel().key;

	EnableButton(GetDlgItem(IDC_ASSIGN),bLegal);

	CString strAssignedTo;
	if (!GetCurrentAssignment(m_pKeymap, strAssignedTo) && m_iCurScope > 0)
	{
		CKeymap* pBaseKeymap = (CKeymap*)m_ScopeList.GetItemData(0);
		ASSERT(pBaseKeymap != NULL);
		GetCurrentAssignment(pBaseKeymap, strAssignedTo);
	}

	CWnd* pUsedBy = GetDlgItem(IDC_USEDBY);
	CString str;
	pUsedBy->GetWindowText(str);
	if (str != strAssignedTo)
	{
		pUsedBy->SetWindowText(strAssignedTo);

		GetDlgItem(IDC_USEDBY_CAP)->ShowWindow(strAssignedTo.IsEmpty() ? SW_HIDE : SW_SHOWNA);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg's Buttons' BN_CLICKED handlers

void CKeyCustDlg::OnClickedAssign()
{
	if (!m_Tap.IsAccelLegal())
	{
		MessageBeep(UINT(-1));
		return;
	}

	CListBox* plstCmd = (CListBox*)GetDlgItem(IDC_CMD_LIST);
	int indCmd = plstCmd->GetCurSel();
	if(indCmd < 0)
		return; // no command to bind to

	ACCEL accel = m_Tap.GetAccel();                         // pull accel key from tap,
	ACCEL chord = m_Tap.GetChord();

	accel.cmd = (WORD)plstCmd->GetItemData(indCmd); // and bind it to selected command

	WORD kc = KcFromAccel(accel);

	if (m_Tap.IsChordSet())
	{
		WORD kc2 = KcFromAccel(chord);
		
		m_pKeymap->SetKey(kc, kc2, accel.cmd);
	}
	else
	{
		m_pKeymap->SetKey(kc, accel.cmd);
	}
	
	m_pKeymap->m_bDirty = TRUE;
	
	FillKeysList(accel.cmd);
	m_Tap.ResetAll();
	OnChangeTap();

	// we just got disabled - set focus to the cat list
	CComboBox *plstCat = (CComboBox *)GetDlgItem(IDC_CAT_COMBO);
	plstCat->SetFocus();

	theApp.m_bMenuDirty = TRUE;
}

void CKeyCustDlg::OnClickedRemove()
{
	CListBox* plstKey = (CListBox*)GetDlgItem(IDC_KEY_LIST);
	int indKey = plstKey->GetCurSel();
	ASSERT(indKey >= 0);

	DWORD kcPair = plstKey->GetItemData(indKey) & ~MAKELONG(KCF_INHERITED, KCF_INHERITED);
	m_pKeymap->RemoveKey(LOWORD(kcPair), HIWORD(kcPair));
	m_pKeymap->m_bDirty = TRUE;
	
	CListBox* plstCmd = (CListBox*)GetDlgItem(IDC_CMD_LIST);
	int indCmd = plstCmd->GetCurSel();
	ASSERT(indCmd >= 0);
	FillKeysList((WORD)plstCmd->GetItemData(indCmd));
	OnChangeTap();

	if (plstKey->GetCount())
	{
		plstKey->SetFocus();
	}
	else
	{
		CComboBox *plstCat = (CComboBox *)GetDlgItem(IDC_CAT_COMBO);
		plstCat->SetFocus();
	}
	theApp.m_bMenuDirty = TRUE;
}

void ResetMainKeymap()
{
	((CMainFrame*)theApp.m_pMainWnd)->m_keymap.RemoveAll();

	POSITION pos = theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
		pPackage->LoadGlobalAccelerators();
	}

	((CMainFrame*)theApp.m_pMainWnd)->m_keymap.m_bDirty = TRUE;
	theApp.m_bMenuDirty = TRUE;
}

void CKeyCustDlg::OnClickedResetAll()
{
	CString strPrompt, strEditor;

	m_ScopeList.GetWindowText( strEditor );
	AfxFormatString1( strPrompt, IDS_RESETALLKEYS, strEditor );
	if (AfxMessageBox(strPrompt, MB_YESNO, 0) == IDYES)
	{
		m_pKeymap->RemoveAll();

		if (m_iCurScope == 0)
		{
			// Global
			ResetMainKeymap();
		}
		else
		{
			// Editor specific
			m_pKeymap->LoadEditorAccelerators();
			m_pKeymap->m_bDirty = TRUE;
			theApp.m_bMenuDirty = TRUE;
		}

		// Update the dialog fields...
		OnSelChangeCmdList();
		OnChangeTap();

	}
}

/////////////////////////////////////////////////////////////////////////////
// CKeyCustDlg helper functions

int CKeyCustDlg::MaintainListSel(CListBox* pList, DWORD dwData)
{
	int count = pList->GetCount();
	for(int index = 0; index < count; index++)
	{
		DWORD dw = pList->GetItemData(index);
		if(dw == dwData)
			return index;
	}
	return -1;              // item no longer in list, so deselect all
}

class CHackFrame : public CFrameWnd
{
public:
	void SetAccelTable(HACCEL hAccelTable)
	{
		if (m_hAccelTable != NULL)
			DestroyAcceleratorTable(m_hAccelTable);
		m_hAccelTable = hAccelTable;
	}
};


DWORD CKeyCustDlg::AccelToDWord(ACCEL& accel)
{
	return (DWORD)(accel.cmd << 16) | (accel.fVirt << 8) | (BYTE)accel.key ;
}

ACCEL CKeyCustDlg::DWordToAccel(DWORD dw)
{
	ACCEL a;
	a.key   = (WORD)LOBYTE(LOWORD(dw));
	a.fVirt = (BYTE)HIBYTE(LOWORD(dw));
	a.cmd   = (WORD)HIWORD(dw);
	return a;
}


void CKeyListBox::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	
	if ((lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) != 0)
	{
		BOOL fDisabled = lpDrawItemStruct->itemID >= 0 && 
			(GetItemData(lpDrawItemStruct->itemID) & MAKELONG(KCF_INHERITED, KCF_INHERITED)) != 0;

		COLORREF newTextColor = fDisabled ? RGB(0x80, 0x80, 0x80) : GetSysColor(COLOR_WINDOWTEXT);      // dark gray
		COLORREF oldTextColor = pDC->SetTextColor(newTextColor);

		COLORREF newBkColor = GetSysColor(COLOR_WINDOW);
		COLORREF oldBkColor = pDC->SetBkColor(newBkColor);

		// Make sure grayed text will show up...
		if (newTextColor == newBkColor)
			pDC->SetTextColor(RGB(0xC0, 0xC0, 0xC0));       // light gray
		
		if (!fDisabled && ((lpDrawItemStruct->itemState & ODS_SELECTED) != 0))
		{
			pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}

		CString strText;
		if (lpDrawItemStruct->itemID >= 0)
			GetText(lpDrawItemStruct->itemID, strText);
		pDC->ExtTextOut(lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, 
			ETO_OPAQUE, &lpDrawItemStruct->rcItem, strText, strText.GetLength(), NULL);
		
		pDC->SetTextColor(oldTextColor);
		pDC->SetBkColor(oldBkColor);
	}
	
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
	{
		// When the list is empty, so is rcItem...  This sucks, so we hack in a height
		// so the list box looks normal here...
		if (lpDrawItemStruct->rcItem.top == lpDrawItemStruct->rcItem.bottom)
			lpDrawItemStruct->rcItem.bottom += pDC->GetTextExtent("M", 1).cy;

		pDC->DrawFocusRect(&lpDrawItemStruct->rcItem);
	}
}

void CKeyListBox::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(GetStdFont(font_Bold));
	lpMeasureItemStruct->itemHeight = dc.GetTextExtent("M", 1).cy;
	dc.SelectObject(pOldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\keymap.cpp ===
#include "stdafx.h"
#include "imeutil.h"
#include "cmduiena.h"
#include "cmdcache.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


CObList CKeymap::c_keymaps;
CKeymap* CKeymap::c_pChordKeymap = NULL;
WORD CKeymap::c_kcChordPrefix = 0;
BOOL CKeymap::c_bDisableIME = FALSE;
BOOL CKeymap::c_bEscIsAltPrefix = FALSE;
BOOL CKeymap::c_bImplyAltForNextKey = FALSE;

// These strings are not localized...
const TCHAR CKeymap::c_szCtrl [] = "Ctrl+";
const TCHAR CKeymap::c_szAlt [] = "Alt+";
const TCHAR CKeymap::c_szShift [] = "Shift+";


CKeymap::CKeymap()
	: CMapWordToPtr()
{
	m_pPacket = NULL;
	m_bDirty = FALSE;

	c_keymaps.AddTail(this);
}

CKeymap::~CKeymap()
{
	POSITION pos = c_keymaps.Find(this);
	ASSERT(pos != NULL);
	c_keymaps.RemoveAt(pos);

	if (this == c_pChordKeymap)
		c_pChordKeymap = NULL;
	
	RemoveAll();
}

void CKeymap::RemoveAll()
{
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		WORD kc;
		UINT nCmdID;
		CKeymap* pKeymap;
		GetNextKey(pos, kc, nCmdID, pKeymap);

		if ((kc & KCF_CHORD) != 0)
			delete pKeymap;
	}
	
	CMapWordToPtr::RemoveAll();
}

void CKeymap::LoadAccelerators(HINSTANCE hInstance, LPCTSTR lpResourceID)
{
	HACCEL hAccelTable = ::LoadAccelerators(hInstance, lpResourceID);
	ASSERT(hAccelTable != NULL);
	LoadAccelerators(hAccelTable);
	DestroyAcceleratorTable(hAccelTable);
}

void CKeymap::LoadAccelerators(HACCEL hAccelTable)
{
	int nAccels = CopyAcceleratorTable(hAccelTable, NULL, 0); // get size
	ACCEL* pAccelTable = new ACCEL[nAccels];
	CopyAcceleratorTable(hAccelTable, pAccelTable, nAccels);

	for (int i = 0; i < nAccels; i += 1)
	{
		WORD kc = pAccelTable[i].key;
		ASSERT((kc & 0xff) == kc);
		if ((pAccelTable[i].fVirt & FVIRTKEY) == 0)
			kc |= KCF_ASCII;
		if ((pAccelTable[i].fVirt & FSHIFT) != 0)
			kc |= KCF_SHIFT;
		if ((pAccelTable[i].fVirt & FCONTROL) != 0)
			kc |= KCF_CONTROL;
		if ((pAccelTable[i].fVirt & FALT) != 0)
			kc |= KCF_ALT;

#ifdef _DEBUG
		{
			CKeymap* pKeymap;
			UINT nCmdID;

			CTE *pCTE=theCmdCache.GetCommandEntry(pAccelTable[i].cmd);

			if(pCTE && pCTE->flags & CT_NOKEY)
			{
				TRACE("CKeymap::LoadAccelerators: Questionable: Accelerator attached to NOKEY command: kc=0x%04x cmd=0x%04x,%s\n", kc, nCmdID, pCTE->szCommand);
			}

			if(pCTE && _tcslen(pCTE->szCommand)==0)
			{
				TRACE("CKeymap::LoadAccelerators: Error: Accelerator attached to command without command name: kc=0x%04x cmd=0x%04x\n", kc, nCmdID);
				ASSERT(FALSE);
			}

			if (LookupKey(kc, nCmdID, pKeymap))
			{
				// only report clashes
				if(nCmdID != pAccelTable[i].cmd)
				{
					CTE *pExistingCTE=theCmdCache.GetCommandEntry(nCmdID);
					LPCTSTR pszExistingCommand=pExistingCTE ? pExistingCTE->szCommand : "";
					LPCTSTR pszNewCommand=pCTE ? pCTE->szCommand : "";

					TRACE("CKeymap::LoadAccelerators: Accelerator collision: kc=0x%04x existingcmd=0x%04x,%s newcmd=0x%04x,%s \n", kc, nCmdID, pszExistingCommand, pAccelTable[i].cmd, pszNewCommand);
				}
			}

		}
#endif

		SetKey(kc, pAccelTable[i].cmd);
	}

	delete [] pAccelTable;
}

void CKeymap::LoadEditorAccelerators()
{
	CPacket* pPacket = m_pPacket;
	ASSERT(pPacket != NULL);
	ASSERT(pPacket->m_lpAccelID != NULL);

	LoadAccelerators(pPacket->HInstance(), pPacket->m_lpAccelID);
}

void CKeymap::GetKeyName(WORD kc1, WORD kc2, CString& str)
{
	const char* GetNameFromVK(WORD n);

	CString str2;
	if (kc2 != 0)
	{
		GetKeyName(kc2, 0, str2);
		str2 = ',' + str2;
	}

	if ((kc1 & KCF_ASCII) != 0)
	{
		if (LOBYTE(kc1) < ' ')
		{
			str += c_szCtrl;
			str += (char)(LOBYTE(kc1) + '@');
		}
		else
		{
			str += (char)LOBYTE(kc1);
		}
	}
	else
	{
		if ((kc1 & KCF_CONTROL) != 0)
			str += c_szCtrl;
		if ((kc1 & KCF_ALT) != 0)
			str += c_szAlt;
		if ((kc1 & KCF_SHIFT) != 0)
			str += c_szShift;
		
		const char* szVK = GetNameFromVK(LOBYTE(kc1));
		if (szVK != NULL)
			str += szVK;
		else
			str += (char)LOBYTE(kc1);
	}

	str += str2;
}

void CKeymap::GetNextKey(POSITION& pos, WORD& kc, UINT& nCmdID, CKeymap*& pKeymap)
{
	void* pv;
	GetNextAssoc(pos, kc, pv);

	if ((kc & KCF_CHORD) != 0)
	{
		pKeymap = (CKeymap*)pv;
		nCmdID = 0;
	}
	else
	{
		pKeymap = NULL;
		nCmdID = (UINT)pv;
	}
}

void CKeymap::SetKey(WORD kc, UINT nCmdID)
{
	kc &= ~KCF_CHORD;
	SetAt(kc, (void*)nCmdID);

	CKeymap* pKeymap;
	if (Lookup(kc | KCF_CHORD, (void*&)pKeymap))
	{
		// If it was a chord before...
		CMapWordToPtr::RemoveKey(kc | KCF_CHORD);
		delete pKeymap;
	}
}

void CKeymap::SetKey(WORD kc1, WORD kc2, UINT nCmdID)
{
	kc1 |= KCF_CHORD;

	CMapWordToPtr::RemoveKey(kc1 & ~KCF_CHORD);

	CKeymap* pKeymap;
	if (!Lookup(kc1, (void*&)pKeymap))
	{
		pKeymap = new CKeymap;
		SetAt(kc1, pKeymap);
	}

	pKeymap->SetKey(kc2, nCmdID);
}

void CKeymap::SetKey(WORD kc, CKeymap* pKeymap)
{
	kc |= KCF_CHORD;

	CMapWordToPtr::RemoveKey(kc & ~KCF_CHORD);

	SetAt(kc, pKeymap);
}

void CKeymap::RemoveKey(WORD kc1, WORD kc2 /* = 0*/)
{
	CMapWordToPtr::RemoveKey(kc1 & ~KCF_CHORD);

	CKeymap* pKeymap;
	if (Lookup(kc1 | KCF_CHORD, (void*&)pKeymap))
	{
		// If it was a chord before...

		if (kc2 != 0)
		{
			pKeymap->RemoveKey(kc2);
			if (pKeymap->IsEmpty())
				kc2 = 0; // delete keymap below...
		}

		if (kc2 == 0)
		{
			CMapWordToPtr::RemoveKey(kc1 | KCF_CHORD);
			delete pKeymap;
		}
	}
}

BOOL CKeymap::LookupKey(WORD kc, UINT& nCmdID, CKeymap*& pKeymap)
{
	void* pv;
	if (Lookup(kc & ~KCF_CHORD, pv))
	{
		nCmdID = (UINT)pv;
		pKeymap = NULL;
		return TRUE;
	}

	if (Lookup(kc | KCF_CHORD, pv))
	{
		nCmdID = 0;
		pKeymap = (CKeymap*)pv;
		return TRUE;
	}

	return FALSE;
}

// This hack is to try to keep the old-style key bindings off of the
// menu...  Bindings found in the following table will only appear on
// the menu if the command has no other binding.
//
struct OLDKEY
{
	UINT nCmdID;
	WORD kc;
};

OLDKEY oldkeys [] =
{
	ID_FILE_OPEN,	VK_F12 | KCF_CONTROL,
	ID_FILE_SAVE,	VK_F12 | KCF_SHIFT,
	ID_FILE_SAVE_AS,VK_F12,
	ID_FILE_PRINT,	VK_F12 | KCF_SHIFT | KCF_CONTROL,
	ID_EDIT_CUT,	VK_DELETE | KCF_SHIFT,
	ID_EDIT_COPY,	VK_INSERT | KCF_CONTROL,
	ID_EDIT_PASTE,	VK_INSERT | KCF_SHIFT,
	ID_EDIT_UNDO,	VK_BACK | KCF_ALT,
	ID_EDIT_FIND_DLG, VK_F3 | KCF_ALT,
};

BOOL CKeymap::LookupCommand(UINT nCmdID, WORD& kcOne, WORD& kcTwo, CKeymap* pOverride)
{
	WORD kcFound = 0;
	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		WORD kc;
		void* pv;
		GetNextAssoc(pos, kc, pv);

		if ((kc & KCF_CHORD) != 0)
		{
			WORD kcOneTry, kcTwoTry;
			if (((CKeymap*)pv)->LookupCommand(nCmdID, kcOneTry, kcTwoTry))
			{
				UINT nFoo;
				CKeymap* pFoo;
				// we're looking for before ignoring the binding here...
				if (pOverride != NULL && pOverride->LookupKey(kc, nFoo, pFoo))
					continue;

				ASSERT(kcTwoTry == 0);
				kcTwo = kcOneTry;
				kcOne = kc;
				return TRUE;
			}
		}
		else
		{
			if ((UINT)pv == nCmdID)
			{
				if (pOverride != NULL)
				{
					// Found a match, now make sure it's not being overriden...
					UINT nFoo;
					CKeymap* pFoo;
					if (pOverride != NULL && pOverride->LookupKey(kc, nFoo, pFoo) && nFoo != nCmdID)
						continue;
				}
				
				// Make sure we don't use any of the old (CUA-style) key
				// bindings unless we have to...
				for (int i = 0; i < sizeof (oldkeys) / sizeof (OLDKEY); i += 1)
				{
					if (oldkeys[i].nCmdID == nCmdID && oldkeys[i].kc == kc ||
						(kc & KCF_ALT) != 0 && ((kc & 0x00ff) == VK_F1 || (kc & 0x00ff) == VK_F2))
					{
						kcFound = kc;
						kc = 0;
						break;
					}
				}
				
				if (kc != 0)
				{
					kcOne = kc;
					kcTwo = 0;
					return TRUE;
				}
			}
		}
	}
	
	if (kcFound != 0)
	{
		kcOne = kcFound;
		kcTwo = 0;
		return TRUE;
	}

	return FALSE;
}

BOOL CKeymap::TranslateMessage(CWnd* pWnd, MSG* pMsg)
{
	static CKeymap* pChordSource;
	if (c_pChordKeymap != NULL && c_pChordKeymap != this)
	{
		pChordSource = this;
		return c_pChordKeymap->TranslateMessage(pWnd, pMsg);
	}

	WORD kc;

	if (!pWnd->IsWindowEnabled() || !pWnd->IsWindowVisible() || pWnd->IsIconic())
		return FALSE;

	switch (pMsg->message)
	{
	default:
		return FALSE;

	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		if (pMsg->wParam == VK_MENU ||
			pMsg->wParam == VK_CONTROL ||
			pMsg->wParam == VK_SHIFT)
		{
			return FALSE;
		}

		kc = (WORD)pMsg->wParam;
		ASSERT((kc & 0xff) == kc);
		if (GetKeyState(VK_SHIFT) < 0)
			kc |= KCF_SHIFT;
		if (GetKeyState(VK_CONTROL) < 0)
			kc |= KCF_CONTROL;
		if (GetKeyState(VK_MENU) < 0)
			kc |= KCF_ALT;
		break;

	case WM_CHAR:
	case WM_SYSCHAR:
		kc = (WORD)pMsg->wParam;
		ASSERT((kc & 0xff) == kc);
		kc |= KCF_ASCII;
		if (pMsg->message == WM_SYSCHAR)
			kc |= KCF_ALT;
		break;
	}

	if (c_bEscIsAltPrefix && kc == VK_ESCAPE) // Epsilon emulation...
	{
		if (c_bImplyAltForNextKey)
		{
			CancelChord();
		}
		else
		{
			((CMainFrame*)theApp.m_pMainWnd)->SetTimer(200, 1000 * 1, NULL);
			c_bImplyAltForNextKey = TRUE;
		}
		return TRUE;
	}

	if (c_bImplyAltForNextKey)
	{
		kc |= KCF_ALT;
		CancelChord();
	}

	UINT nCmdID;
	CKeymap* pKeymap;
	if (!LookupKey(kc, nCmdID, pKeymap))
	{
		if (this == c_pChordKeymap)
		{
			if (kc != VK_ESCAPE)
			{
				CMainFrame *pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
				if (pChordSource == &pMainFrame->m_keymap)
				{
					MessageBeep(0);
				}
				else
				{
					// Try the same chord in the main keymap
					if (!pMainFrame->m_keymap.LookupKey(c_kcChordPrefix, nCmdID, pKeymap))
					{
						MessageBeep(0);
					}
					else
					{
						pChordSource = &pMainFrame->m_keymap;
						c_pChordKeymap = pKeymap;
						return c_pChordKeymap->TranslateMessage(pWnd, pMsg);
					}
				}
			}
			CancelChord();
			return TRUE;
		}

		return FALSE;
	}

	if (nCmdID != 0)
	{
		CancelChord();

		// Check to see if the command has been disabled before calling its update handler
		CTE* pCTE = theCmdCache.GetCommandEntry(nCmdID);
		BOOL bEnabled = (pCTE == NULL || (pCTE->flags & CT_NOUI) == 0);
		
		if (bEnabled)
		{
			CCmdUIEnable state;
			state.m_nID = nCmdID;
			state.DoUpdate(AfxGetApp()->m_pMainWnd, TRUE);
			
			bEnabled = state.m_bEnabled;
		}

		if (bEnabled)
		{
			AfxGetApp()->m_pMainWnd->SendMessage(WM_COMMAND,
				MAKEWPARAM((WORD)nCmdID, 1));
		}
		else
		{
			MessageBeep(0);
		}
	}
	else
	{
		ASSERT(pKeymap != NULL);
		c_pChordKeymap = pKeymap;
		c_kcChordPrefix = kc;

		((CMainFrame*)theApp.m_pMainWnd)->SetTimer(200, 1000 * 1, NULL);

		// Disable the IME so it doesn't eat the last half of the chord
		if (theIME.IsOpen() && theIME.IsEnabled())
		{
			imeEnableIME( NULL, FALSE );
			c_bDisableIME = TRUE;
		}
	}

	return TRUE;
}

void CKeymap::CancelChord()
{
	if (!c_bImplyAltForNextKey && c_pChordKeymap == NULL)
		return;

	c_bImplyAltForNextKey = FALSE;
	c_pChordKeymap = NULL;
	((CMainFrame*)theApp.m_pMainWnd)->KillTimer(200);
	((CMainFrame*)theApp.m_pMainWnd)->KillTimer(201);
	SetPrompt();

	// If we disabled the IME when we started this chord, enable it.
	if (c_bDisableIME)
	{
		imeEnableIME( NULL, TRUE );
		c_bDisableIME = FALSE;
	}
}

void AddGlobalAcceleratorTable(HACCEL hAccel, WORD kcPrefix /*= 0*/)
{
	if (kcPrefix == 0)
	{
		((CMainFrame*)theApp.m_pMainWnd)->m_keymap.LoadAccelerators(hAccel);
	}
	else
	{
		// Chords
		CKeymap* pKeymap = new CKeymap;

		pKeymap->LoadAccelerators(hAccel);
		((CMainFrame*)theApp.m_pMainWnd)->m_keymap.SetKey(kcPrefix, pKeymap);
	}
}

void AddGlobalAcceleratorTable(LPCTSTR lpAccelID, WORD kcPrefix /*= 0*/)
{
	HINSTANCE hInst = AfxFindResourceHandle(lpAccelID, RT_ACCELERATOR);
	ASSERT(hInst != NULL);

	HACCEL hAccelTable = LoadAccelerators(hInst, lpAccelID);
	ASSERT(hAccelTable != NULL);

	AddGlobalAcceleratorTable(hAccelTable, kcPrefix);
	DestroyAcceleratorTable(hAccelTable);
}


BOOL LookupGlobalCommand(UINT nCmdID, WORD& kcOne, WORD& kcTwo)
{
	return ((CMainFrame*)theApp.m_pMainWnd)->m_keymap.LookupCommand(
		nCmdID, kcOne, kcTwo);
}

////////////////////////////////////////////////////////////////////////////
// In the registry, a keymap is represented by a WORD count of bytes
// followed by as many REGKEYMAPPING structures as will fit.

struct REGKEYMAPPING
{
	WORD kc1, kc2;
	UINT nCmdID;
};

const TCHAR szRegKeyboard [] = _T("Keyboard");

void CKeymap::WriteReg(const TCHAR* szKey)
{
	if (!m_bDirty)
		return;
	
	if (szKey == NULL)
		szKey = m_strName;

	CMemFile memRegData;

	// save 2 bytes for size ... will fill in later
	USHORT wZero = 0;
	memRegData.Write(&wZero, sizeof(wZero));

	POSITION pos = GetStartPosition();
	while (pos != NULL)
	{
		WORD kc;
		UINT nCmdID = 0;
		CKeymap* pChordKeymap = NULL;
		GetNextKey(pos, kc, nCmdID, pChordKeymap);

		if ((kc & KCF_CHORD) != 0)
		{
			ASSERT(pChordKeymap != NULL);

			POSITION pos2 = pChordKeymap->GetStartPosition();
			while (pos2 != NULL)
			{
				WORD kc2;
				CKeymap* pFoo;
				pChordKeymap->GetNextKey(pos2, kc2, nCmdID, pFoo);

				REGKEYMAPPING key;
				key.kc1 = kc;
				key.kc2 = kc2;
				key.nCmdID = nCmdID;
				memRegData.Write(&key, sizeof(key));
			}
		}
		else
		{
			REGKEYMAPPING key;
			key.kc1 = kc;
			key.kc2 = 0;
			key.nCmdID = nCmdID;
			memRegData.Write(&key, sizeof(key));
		}
	}

	HGLOBAL hGlob = GlobalAlloc(GMEM_MOVEABLE, memRegData.GetLength());
	LPVOID pGlob = GlobalLock(hGlob);

	{
		// get a pointer to memRegData contents and copy to pGlob.
		void *pvRegData, *pvRegDataLim;
		VERIFY(memRegData.GetBufferPtr(CMemFile::bufferCheck, 0, NULL, NULL));	// confirm supported
		memRegData.Seek(0, CFile::begin);
		VERIFY(memRegData.GetBufferPtr(CMemFile::bufferRead, memRegData.GetLength(),
									   &pvRegData, &pvRegDataLim));
		memcpy(pGlob, pvRegData, memRegData.GetLength());
		// no need to release buffer pointers
	}
	ASSERT(memRegData.GetLength() <= 0xffff);		// will never happen -- limited # of keys
	*(WORD *)pGlob = (WORD)memRegData.GetLength();	// fill in size which we left as 0 earlier

	WriteRegData(szRegKeyboard, szKey, hGlob);

	GlobalUnlock(hGlob);
	GlobalFree(hGlob);
}

BOOL CKeymap::GetReg(const TCHAR* szKey)
{
	if (szKey == NULL)
		szKey = m_strName;
	
	HGLOBAL hGlob = GetRegData(szRegKeyboard, szKey, NULL);
	if (hGlob == NULL)
		return FALSE;
	
	// Delete all the old entries...
	RemoveAll();
	
	LPVOID pGlob = GlobalLock(hGlob);
	UNALIGNED REGKEYMAPPING FAR* pKey = (REGKEYMAPPING*)((CHAR*)pGlob + sizeof (WORD));
	UNALIGNED REGKEYMAPPING FAR* pKeyEnd = (REGKEYMAPPING *)((CHAR *)pGlob + *(WORD FAR*)pGlob);
	while (pKey < pKeyEnd)
	{
		UNALIGNED REGKEYMAPPING FAR* pKeyNew;

		pKeyNew = pKey + 1;

		if (pKey->kc2 == 0)
			SetKey(pKey->kc1, pKey->nCmdID);
		else
			SetKey(pKey->kc1, pKey->kc2, pKey->nCmdID);
		
		pKey = pKeyNew;
	}
	GlobalUnlock(hGlob);
	GlobalFree(hGlob);
	return TRUE;
}

void CKeymap::SetEscIsAltPrefix(BOOL bSetEscIsAltPrefix)
{
	c_bEscIsAltPrefix = bSetEscIsAltPrefix;
}


// Active key string for the command
BOOL GetCmdKeyString(UINT nCmdID, CString& str)
{
	WORD kc1, kc2;

	CPartView* pView = (CPartView*)CWnd::FromHandle(theApp.GetActiveView());
	CKeymap* pViewKeymap = NULL;
	if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)))
	{
		pViewKeymap = pView->GetKeymap();
		if (pViewKeymap != NULL && pViewKeymap->LookupCommand(nCmdID, kc1, kc2))
		{
			CKeymap::GetKeyName(kc1, kc2, str);
			return TRUE;
		}
	}

	if (((CMainFrame*)theApp.m_pMainWnd)->m_keymap.LookupCommand(nCmdID, kc1, kc2, pViewKeymap))
	{
		CKeymap::GetKeyName(kc1, kc2, str);
		return TRUE;
	}

	return FALSE;
}

// Any key string for the command (for use in Tips)
// Gets the first one found, which may not be active at any given time.
BOOL GetCmdKeyStringAll(UINT nCmdID, CString& str)
{
	CKeymap *pkm;
	POSITION pos;
	pos = CKeymap::c_keymaps.GetHeadPosition();
	while (pos)
	{
		if ((pkm = (CKeymap*)CKeymap::c_keymaps.GetNext(pos)) != NULL)
		{
			WORD kcOne, kcTwo;
			if (pkm->LookupCommand(nCmdID, kcOne, kcTwo, 0))
			{
				CKeymap::GetKeyName(kcOne, kcTwo, str);
				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL COverridingKeymap::LookupKey(WORD kc, UINT& nCmdID, CKeymap*& pKeymap)
{
	if (m_fOverrideActive && CKeymap::LookupKey(kc, nCmdID, pKeymap))
		return TRUE;
	else
		return m_pkeymapBase->LookupKey(kc, nCmdID, pKeymap);
}

BOOL COverridingKeymap::LookupCommand(UINT nCmdID, WORD& kcOne, WORD& kcTwo, CKeymap* pOverride)
{	
	if (m_fOverrideActive && CKeymap::LookupCommand(nCmdID, kcOne, kcTwo, pOverride))
		return TRUE;
	else
		return m_pkeymapBase->LookupCommand(nCmdID, kcOne, kcTwo, pOverride);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcundo.h ===
// ipcundo.h : interface of the COleUndoManager and
// CEnumOleUndoUnit classes.
//

#ifndef __IPCUNDO_H__
#define __IPCUNDO_H__

enum UNDOSTATE
{
	usBaseState,
	usUndoState,
	usRedoState
};

enum UNDOACTIONTYPE
{
	atUndoAction,
	atRedoAction,
};

/////////////////////////////////////////////////////////////////////////////
// COleUndoManager
// Implementation of the IOleUndoManager class, which manages
// Undo actions on behalf of in-place components.
//
class COleUndoManager : public IOleUndoManager
{
public:
	COleUndoManager();
	~COleUndoManager();

	//=================================================
	// IUnknown/CCom methods
	//=================================================
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	//=================================================
	// IOleUndoManager methods
	//=================================================

	STDMETHOD(Open) (IOleParentUndoUnit *pCUA);
	STDMETHOD(Close) (IOleParentUndoUnit *pCUA, BOOL fCommit);
	STDMETHOD(Add) (IOleUndoUnit *pUA);
	STDMETHOD(DiscardFrom)(IOleUndoUnit *pUA);
	STDMETHOD(UndoTo)(IOleUndoUnit *pUA);
	STDMETHOD(RedoTo)(IOleUndoUnit *pUA);
	STDMETHOD(EnumUndoable)(IEnumOleUndoUnits **ppEnum);
	STDMETHOD(EnumRedoable)(IEnumOleUndoUnits **ppEnum);
	STDMETHOD(GetLastUndoDescription) (BSTR *pbstr);
	STDMETHOD(GetLastRedoDescription) (BSTR *pbstr);
	STDMETHOD(Enable)(BOOL fEnable);
	STDMETHOD(GetOpenParentState) (DWORD *pdwState);

	// Non-OLE methods specific to this implementation
	BOOL IsUndoEmpty() {return m_fUndoStackIsEmpty;};
	BOOL IsRedoEmpty() {return m_fRedoStackIsEmpty;};;

protected:
	void OnStackChange();

	DWORD m_cRef;
	DWORD m_cRollbackCtr;
	//$CONSIDER -- these booleans could be combined into bit flags.
	BOOL m_fEnable;
	BOOL m_fUndoStackIsEmpty;
	BOOL m_fRedoStackIsEmpty;
	UNDOSTATE m_usManagerState;
	IOleParentUndoUnit *m_pOpenUndoAction;
	IOleParentUndoUnit *m_pOpenRedoAction;
	CTypedPtrList<CPtrList, IOleUndoUnit *> m_UndoStack, m_RedoStack;
};

/////////////////////////////////////////////////////////////////////////////
// CEnumOleUndoUnit
//
// Description: Implementation of the IEnumOleUndoUnits Manager
// interface that goes with the implement of IOleUndoManager
// above.
//
class CEnumOleUndoUnit : public IEnumOleUndoUnits
{
public:
	CEnumOleUndoUnit(IOleUndoManager * pUndoMgr,
					   CTypedPtrList<CPtrList, IOleUndoUnit *> *pActionList);
	CEnumOleUndoUnit(IOleUndoManager * pUndoMgr,
					   CTypedPtrList<CPtrList, IOleUndoUnit *> *pActionList,
					   ULONG cPos);

	//=================================================
	// IUnknown/CCom methods
	//=================================================
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	//=================================================
	// IEnumOleUndoUnits
	//=================================================

	STDMETHOD(Next)(ULONG celt, IOleUndoUnit **rgelt, ULONG *pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumOleUndoUnits** ppenum);

private:
	DWORD m_cRef;
	DWORD m_cPos;
	COleRef<IOleUndoManager> m_srpUndoMgr;
	CTypedPtrList<CPtrList, IOleUndoUnit *>  *m_pActionList;
};


/*-----------------------------------------------------------------------------
Class: COleUndoUnit

Description: Implements the Action Manager Interface
-----------------------------------------------------------------------------*/
class COleUndoUnit : public IOleUndoUnit
{
public:
	COleUndoUnit(LPOLESTR strDescription,
				   BOOL fUndoFail=FALSE,
				   BOOL fRedoFail=FALSE);

	//=================================================
	// IUnknown/CCom methods
	//=================================================
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	//=================================================
	// end of inherited methods
	//=================================================

	STDMETHOD(Do) (IOleUndoManager *pUndoActionManager);
	STDMETHOD(GetDescription) (BSTR *pbstr);
	STDMETHOD(GetUnitType)(CLSID *pclsid, LONG *pnID);
	STDMETHOD(OnNextAdd) (void);
private:
	DWORD m_cRef;
	CString m_strDesc;
	UNDOACTIONTYPE m_atActionType;
	BOOL m_fUndoFail;
	BOOL m_fRedoFail;
};

/*-----------------------------------------------------------------------------
Class: COleParentUndoUnit

Description: Implements the IOleParentUndoUnit Interface
-----------------------------------------------------------------------------*/
class COleParentUndoUnit : public IOleParentUndoUnit
{
public:
	COleParentUndoUnit(UNDOACTIONTYPE atActionType, LPOLESTR strDescription);

	//=================================================
	// IUnknown/CCom methods
	//=================================================
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
	STDMETHOD_(ULONG,AddRef)(void);
	STDMETHOD_(ULONG,Release)(void);

	//=================================================
	// IOleUndoUnit methods
	//=================================================
	STDMETHOD(Do) (IOleUndoManager *pUndoActionManager);
	STDMETHOD(GetDescription) (BSTR *pbstr);
	STDMETHOD(GetUnitType)(CLSID *pclsid, LONG *pnID);
	STDMETHOD(OnNextAdd) (void);

	//=================================================
	// end of inherited methods
	//=================================================
	STDMETHOD(Open) (IOleParentUndoUnit *pCUA);
	STDMETHOD(Close) (IOleParentUndoUnit *pCUA, BOOL fCommit);
	STDMETHOD(Add) (IOleUndoUnit *pUA);
	STDMETHOD(FindUnit) (IOleUndoUnit *pUA);
	STDMETHOD(GetParentState) (DWORD *pdwState);

	//=================================================
	// Non OLE methods
	//=================================================
	virtual BOOL IsUndoActionListEmpty();
	virtual void SetUndoDesc(LPCTSTR szDesc);

private:
	DWORD m_cRef;
	BOOL m_fActionBlocked;
	UNDOACTIONTYPE m_atActionType;
	CString m_strDesc;
	IOleParentUndoUnit *m_pOpenAction;
	CTypedPtrList<CPtrList, IOleUndoUnit *> m_culCompoundActionList;
};

#endif	// __IPCUNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\keywords.h ===
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#ifndef KEYWORDS_H
#define KEYWORDS_H

// The index file consists of a header, followed by the index entries.
// The header is made up of 26 longs that contain the position within
// the file of the index entries for the first index begining with an 
// 'a' thru the first index begining with a 'z'. The indices are not
// case-sensitive. Index entries that begin with a symbol immediately
// follow the header.
// 
// When a keyword is checked against the index file, the entire block
// of indices that contain the first letter of the keyword is read in,
// and a newline character is prepended. That block is searched for 
// "\n[Keyword]". So any occurance of an index that begins with the 
// same character sequence as the keyword triggers a hit.
// 
// As a simple optimization, I won't reload a block of indices that
// was loaded on the last search.

class CKeywords
{	
	private:
		char *m_pszFilename;
		long  m_nFileSize;
		char *m_pszIndexBuf;
		long  m_nIndexBufSize;
		long  m_nHeader[26];
	public:
		CKeywords(const char *pszFilename);
		~CKeywords();
		int IsKeyword(const char *pszKeyword);
};

#endif // KEYWORDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\keywords.cpp ===
#include "stdafx.h"
#include "keywords.h"

CKeywords::CKeywords(const char *pszFilename):m_pszFilename(0),m_nFileSize(0),m_pszIndexBuf(0),m_nIndexBufSize(0)
{
	// Set filename
	m_pszFilename = (char *)malloc(strlen(pszFilename)+1);
	strcpy(m_pszFilename,pszFilename);
	
	// Init index buffer
	m_pszIndexBuf = (char *)malloc(2);
	strcpy(m_pszIndexBuf,"\n");
	m_nIndexBufSize = 2;
	
	// Init header
	memset(m_nHeader,0,sizeof(m_nHeader));
	FILE *file = fopen(m_pszFilename,"rb");

	if(file)
	{
		if(fread(m_nHeader,sizeof(long),26,file)!=26)
		{
			strcpy(m_pszFilename,""); // force IsKeyword() to always return FALSE
		}
		else
		{
			fseek(file,0,SEEK_END);
			m_nFileSize = ftell(file);
		}
		
		fclose(file);
	}
	else
	{
		strcpy(m_pszFilename,""); // force IsKeyword() to always return FALSE
	}
}

CKeywords::~CKeywords()
{
	if(m_pszFilename)
	{
		free(m_pszFilename);
		m_pszFilename = 0;
	}
	if(m_pszIndexBuf)
	{
		free(m_pszIndexBuf);
		m_pszIndexBuf   = 0;
		m_nIndexBufSize = 0;
	}
}

int CKeywords::IsKeyword(const char *pszKeyword)
{
	int bFound = 0;
	
	// Valid filename?
	if(!m_pszFilename || strlen(m_pszFilename)<1) 
	{
		return 0;
	}
	
	// Valid keyword?
	if(!pszKeyword || strlen(pszKeyword)<1) 
	{
		return 0;
	}
	
	// prepend "\n" and make lowercase
	char *keyword = (char *)malloc(strlen(pszKeyword)+2);
	strcpy(keyword,"\n");
	strcat(keyword,pszKeyword);
	_strlwr(keyword);
	
	// do we need to load a new block of indices?
	if(m_nIndexBufSize<3 || keyword[1]!=m_pszIndexBuf[1])
	{
		// Assume number or symbol (anything that occurs before an 'a')
		long nBlockStart = sizeof(m_nHeader); 
		long nBlockSize  = m_nHeader[0] - sizeof(m_nHeader);
		
		if(keyword[1]>='a' && keyword[1]<'z') // 'a'-'y'
		{
			nBlockStart = m_nHeader[keyword[1]-'a']; 
			nBlockSize  = m_nHeader[keyword[1]-'a'+1] - nBlockStart;
		}
		else if(keyword[1]>='z') // 'z' or symbol that occurs after 'z'
		{
			nBlockStart = m_nHeader[25]; // 'z'
			nBlockSize  = m_nFileSize - nBlockStart;
		}
		
		// need to resize the buffer?
		if(nBlockSize>m_nIndexBufSize-2) // sub 1 for the '\n' and '\0'
		{
			m_pszIndexBuf = (char *)realloc(m_pszIndexBuf,nBlockSize+2);
			m_nIndexBufSize = nBlockSize+2;
			strcpy(m_pszIndexBuf,"\n");
		}
		
		// load index block
		FILE *file = fopen(m_pszFilename,"rb");
		fseek(file,nBlockStart,SEEK_SET);
		if(fread(&(m_pszIndexBuf[1]),1,nBlockSize,file)==(size_t)nBlockSize)
		{
			m_pszIndexBuf[m_nIndexBufSize-1]='\0';
			_strlwr(m_pszIndexBuf);
		}
		else
		{
			// something went wrong. Force IsKeyword() to return FASLE.
			strcpy(m_pszIndexBuf,"\n");
		}
		fclose(file);
	}

	// search
	if(strstr(m_pszIndexBuf,keyword))
	{
		bFound = 1;
	}
	
	return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include <afximpl.h>
#include <dde.h>
#include "main.h"

#include "about.h"
#include "shell.h"
#include "bardockx.h"
#include "bardlgs.h"
#include "barbdr.h"
#include "barglob.h"
#include "undoctl.h"
#include "msgboxes.h"
#include "tools.h"
#include "imeutil.h"
#include "totd.h"
#include "resource.h"
#include "opendocs.h"
#include "ipchost.h"
#include "prxycust.h"
#include "toolexpt.h"

#ifndef _IPC_DOCUMENTS_DISABLED
#include <objext.h>
#include "ipcfrmhk.h"
#endif

#include <utilauto.h>
#include <cmguids.h>
#include <aut1api.h>
#include <aut1guid.h>
#include <aut1api_.h>
#include <aut1gui_.h>
#include "shellrec.h"
#include "autostat.h"  // for g_AutomationState

#include "shlmenu.h"
#include "cmdcache.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _TEST
#ifdef _DEBUG
#ifdef _WIN32
UINT NEAR WM_CMDPERFCHECK = RegisterMessage("CmdPerfCheck");
#endif   // _WIN32
#endif   // _DEBUG
UINT NEAR WM_SETPROP      = RegisterMessage("SetProp");
UINT NEAR WM_GETPROP      = RegisterMessage("GetProp");
UINT NEAR WM_HEAPUSE      = RegisterMessage("HeapUse");
UINT NEAR WM_TESTDOCKABLE = RegisterMessage("TestDockable");

// Project state
UINT NEAR WM_SETITEMPROP  = RegisterMessage("SetItemProp");
UINT NEAR WM_GETITEMPROP  = RegisterMessage("GetItemProp");
UINT NEAR WM_GETPROJPATH  = RegisterMessage("GetProjPath") ;

// Build state
UINT NEAR WM_CANWEBUILD   = RegisterMessage("CanWeBuild");
UINT NEAR WM_GETERRCOUNT  = RegisterMessage("GetErrCount");
UINT NEAR WM_GETWARNCOUNT = RegisterMessage("GetWarnCount");
#endif   // _TEST
#ifdef _DEBUG
UINT NEAR WM_FATALEXIT = RegisterMessage("FatalExit");
#endif

UINT NEAR WM_SETAPPVALIDATE = RegisterMessage("SetAppValidate");
UINT NEAR WM_ISERROR = RegisterMessage("IsError");

UINT NEAR WM_POST_ENABLE_IME = RegisterMessage("PostEnableIME");
UINT DSM_TESTMENU = RegisterMessage("DevStudioTestMenu");

UINT MSG_MOUSEWHEEL = RegisterMessage(MSH_MOUSEWHEEL);

extern UINT DSM_DROPMENU;
// const values shared with mstwrap.cpp
static const int cMenuMenu=0;
static const int cMenuExists=1;
// static const int cMenuGrayed=2; // for some reason, these two aren't implemented.
// static const int cMenuChecked=3;
static const int cMenuEnabled=4;
static const int cMenuCount=5;
static const int cMenuText=6;
static const int cMenuEnd=7;
static const int cMenuRealChecked=8;

CDocTemplate* AFX_EXT_DATADEF g_pProjectTemplate;

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
   //{{AFX_MSG_MAP(CMainFrame)
   ON_WM_CREATE()
   ON_WM_SIZE()
   ON_WM_MOVE()
   ON_WM_CLOSE()
   ON_WM_INITMENU()
   ON_WM_INITMENUPOPUP()
   ON_WM_MENUSELECT()
   ON_WM_ENABLE()
   ON_WM_LBUTTONDOWN()
   ON_WM_LBUTTONUP()
   ON_WM_RBUTTONDOWN()
   ON_WM_RBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_WM_NCLBUTTONDOWN()
   ON_WM_LBUTTONDBLCLK()
   ON_WM_NCLBUTTONDBLCLK()
   ON_WM_SYSCOMMAND()
   ON_WM_WININICHANGE()
   ON_WM_FONTCHANGE()
   ON_WM_SETFOCUS()
   ON_WM_ACTIVATE()
   ON_WM_TIMER()
   ON_WM_SYSCOLORCHANGE()
    ON_WM_ENDSESSION() // Profile
   ON_WM_ACTIVATEAPP()
   ON_WM_NCACTIVATE()
   ON_WM_MOUSEACTIVATE()
   ON_WM_QUERYNEWPALETTE()
   ON_WM_PALETTECHANGED()
   ON_WM_DROPFILES()
   ON_WM_GETMINMAXINFO()
        ON_WM_SETCURSOR()
        //}}AFX_MSG_MAP

   // status bar indicators
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_LNCOL, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_OVR, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_ZOOM, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_CLOCK, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_SIZE, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POSITION, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_OFFSET, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_EXTENT, OnUpdateIndicator)
   ON_UPDATE_COMMAND_UI(ID_SEPARATOR, OnUpdateIndicator)

#ifdef _DEBUG
   ON_COMMAND(IDM_OPENLAYOUT, OnOpenLayout)
#endif
   ON_COMMAND(ID_WINDOW_CLOSE_ALL, OnWindowCloseAll)
   ON_COMMAND(IDM_WINDOW_CLOSE, OnWindowClose)
   ON_COMMAND(IDM_WINDOW_NEXT, OnWindowNext)
   ON_COMMAND(IDM_WINDOW_PREVIOUS, OnWindowPrevious)
   ON_UPDATE_COMMAND_UI(IDM_WINDOW_CLOSE, OnUpdateWindowCommand)
   ON_UPDATE_COMMAND_UI(IDM_WINDOW_NEXT, OnUpdateWindowCommand)
   ON_UPDATE_COMMAND_UI(IDM_WINDOW_PREVIOUS, OnUpdateWindowCommand)
   ON_COMMAND(ID_WINDOW_FULLSCREEN, OnWindowFullScreen)
   ON_UPDATE_COMMAND_UI(ID_WINDOW_FULLSCREEN, OnUpdateFullScreen)
   ON_COMMAND(ID_WINDOW_LIST_DOCS, OnWindowListDocs)
   ON_COMMAND(ID_WINDOW_NEW, OnNewWindow)
   ON_UPDATE_COMMAND_UI(ID_WINDOW_NEW, OnUpdateNewWindow)

   ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
   ON_COMMAND(ID_FASTHELP, OnFastHelp)
   ON_COMMAND(IDM_HELP_CONTENTS, OnHelpContents)
   ON_COMMAND(ID_IV_SEARCH, OnHelpSearch)
#ifdef __DEVHELP98__ 
   ON_COMMAND(ID_HELP98_KEYWORDS, OnHelpKeywords)
#endif
   ON_COMMAND(ID_HELP_KEYBOARD, OnHelpKeyboard)

   ON_COMMAND(ID_DRAG_MOVE, OnDragMove)
   ON_COMMAND(ID_DRAG_COPY, OnDragCopy)
   ON_COMMAND(ID_DRAG_CANCEL, OnDragCancel)

   ON_COMMAND(ID_CANCEL, OnCancel)
   ON_COMMAND(IDM_GOTO_LINE, CmdGoto)


   ON_COMMAND_EX_RANGE(IDM_DOCKSHOW_BASE, IDM_DOCKSHOW_LAST, OnDockWindowShow)

   ON_COMMAND_RANGE(IDM_MENU_FIRSTMAIN, IDM_MENU_LASTMAIN, OnMenuCommand)
   ON_COMMAND_RANGE(IDM_WINDOWS_BASE, IDM_WINDOWS_LAST, OnWindows)
   ON_UPDATE_COMMAND_UI_RANGE(IDM_MENU_FIRSTMAIN, IDM_MENU_LASTMAIN, OnUpdateMenuCommand)
   ON_UPDATE_COMMAND_UI_RANGE(IDM_CUSTOMMENU_BASE, IDM_CUSTOMMENU_LAST, OnUpdateCustomMenuCommand)
   ON_UPDATE_COMMAND_UI_RANGE(IDM_WINDOWS_BASE, IDM_WINDOWS_LAST, OnUpdateWindows)

   ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xffff, OnToolTipText)
   ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xffff, OnToolTipText)

   ON_REGISTERED_MESSAGE(WM_SETAPPVALIDATE, OnSetAppValidate)
#ifdef _DEBUG
   ON_REGISTERED_MESSAGE(WM_FATALEXIT, OnFatalExit)
#endif
#ifdef _TEST
    ON_REGISTERED_MESSAGE(WM_SETPROP, OnSetProp)
    ON_REGISTERED_MESSAGE(WM_GETPROP, OnGetProp)
   ON_REGISTERED_MESSAGE(WM_HEAPUSE, OnHeapUse)
    ON_REGISTERED_MESSAGE(WM_TESTDOCKABLE, OnTestDockable)

   // Project state
   ON_REGISTERED_MESSAGE(WM_SETITEMPROP, OnSetItemProp)
    ON_REGISTERED_MESSAGE(WM_GETITEMPROP, OnGetItemProp)
   ON_REGISTERED_MESSAGE(WM_GETPROJPATH, OnGetProjPath)

   // Build state
   ON_REGISTERED_MESSAGE(WM_CANWEBUILD, OnIsBuildPossible)
   ON_REGISTERED_MESSAGE(WM_GETERRCOUNT , OnGetErrorCount)
   ON_REGISTERED_MESSAGE(WM_GETWARNCOUNT, OnGetWarningCount)
#endif
   ON_REGISTERED_MESSAGE(WM_POST_ENABLE_IME, OnPostEnableIME)
   ON_REGISTERED_MESSAGE(DSM_BARSIZECHANGING, OnBarSizeChanging)
   ON_REGISTERED_MESSAGE(DSM_TESTMENU, OnTestMenu)

   ON_REGISTERED_MESSAGE(MSG_MOUSEWHEEL, OnRegMouseWheel)

   ON_MESSAGE(WU_FILECHANGE, OnFileChange)
END_MESSAGE_MAP()

#ifdef _DEBUG
BOOL bQuitting = FALSE;
#endif

void CMainFrame::OnDirChange()
{
   for (CPartFrame* pMDIChild = (CPartFrame*) MDIGetActive(); pMDIChild != NULL;
      pMDIChild = (CPartFrame*) pMDIChild->GetWindow(GW_HWNDNEXT))
   {
      if(!IsValidMDICycleMember(pMDIChild))
         continue;

      ASSERT(pMDIChild->IsKindOf(RUNTIME_CLASS(CPartFrame)));
      pMDIChild->OnUpdateFrameTitle(TRUE);
   }
}

void SetModeName(UINT nModeNameStringID)
{
   CString str;
   if (nModeNameStringID != 0)
      str.LoadString(nModeNameStringID);
   SetModeName(str);
}

void SetModeName(LPCTSTR szModeName)
{
   if (theApp.m_pMainWnd)
   {
      if (((CMainFrame*)theApp.m_pMainWnd)->m_strModeName == szModeName)
         return;

      ((CMainFrame*)theApp.m_pMainWnd)->m_strModeName = szModeName;
      ((CMainFrame*)theApp.m_pMainWnd)->OnUpdateFrameTitle(TRUE);
   }
}

void SetSubTitle(LPCTSTR szSubTitle)
{
   if (theApp.m_pMainWnd)
   {
      if (((CMainFrame*)theApp.m_pMainWnd)->m_strSubTitle == szSubTitle)
         return;

      ((CMainFrame*)theApp.m_pMainWnd)->m_strSubTitle = szSubTitle;
      ((CMainFrame*)theApp.m_pMainWnd)->OnUpdateFrameTitle(TRUE);
   }
}

void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	// Don't update the title if we are loading a workspace.
	if (CPartFrame::IsWorkspaceLocked())
		return;

	CString strTitleBar;
	strTitleBar.Empty();

	// if a workspace is open, its name goes first in the title
	LPPROJECTWORKSPACE lpWorkspaceWnd = g_IdeInterface.GetProjectWorkspace();
	if (lpWorkspaceWnd != NULL)
	{
		CString strDocTitle;
		LPCSTR pszDocTitle;
		if (SUCCEEDED(lpWorkspaceWnd->GetWorkspaceDocTitle(&pszDocTitle)))
		{
			CPath path;
			path.Create(pszDocTitle);
			path.GetBaseNameString(strDocTitle);
			strTitleBar += strDocTitle;
		}
	}

	// now add the first part of title loaded at time of frame creation
	if (!strTitleBar.IsEmpty())
		strTitleBar += _T(" - ");
	strTitleBar += m_strTitle;

	if (!m_strSubTitle.IsEmpty())
	{
		ASSERT(!strTitleBar.IsEmpty());
		strTitleBar += _T(" - ");
		strTitleBar += m_strSubTitle;
	}

	if (!m_strModeName.IsEmpty())
	{
		ASSERT(!strTitleBar.IsEmpty());
		strTitleBar += _T(" [");
		strTitleBar += m_strModeName;
		strTitleBar += _T("]");
	}

	if (strTitleBar.CompareNoCase(m_strAppTitle) != 0)
	{
		m_strAppTitle = strTitleBar;
		SetWindowText(strTitleBar);
	}
}

void CMainFrame::RecalcLayout(BOOL bNotify /*=TRUE*/)
{
    if (m_bLockLayout)
                return;

        if (m_bInRecalcLayout)
                return;

        m_bInRecalcLayout = TRUE;
        // clear idle flags for recalc layout if called elsewhere
        if (m_nIdleFlags & idleNotify)
                bNotify = TRUE;
        m_nIdleFlags &= ~(idleLayout|idleNotify);

        // call the layout hook -- OLE support uses this hook
        if (bNotify && m_pNotifyHook != NULL)
                m_pNotifyHook->OnRecalcLayout();

        // reposition all the child windows (regardless of ID)
        if (GetStyle() & FWS_SNAPTOBARS)
        {
                CRect rect(0, 0, 32767, 32767);
                RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposQuery,
                        &rect, &rect, FALSE);
                RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposExtra,
                        &m_rectBorder, &rect, TRUE);
                CalcWindowRect(&rect);
                SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(),
                        SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
        }
        else
        {
                CRect rect, empty;
                empty.SetRectEmpty();
                GetClientRect(&rect);
                // If in doc object mode, we want the status bar
                // at the bottom of the screen...
                if(m_pManager && m_pManager->IsInDocObjectMode())
                {
                        AFX_SIZEPARENTPARAMS layout;
                        layout.bStretch = TRUE;
                        layout.sizeTotal.cx = layout.sizeTotal.cy = 0;
                        layout.rect = rect;
                        layout.hDWP = ::BeginDeferWindowPos(1);
                        ::SendMessage(m_statusBar.m_hWnd, WM_SIZEPARENT, NULL, (LPARAM)&layout);
                        ::EndDeferWindowPos(layout.hDWP);
                        rect = layout.rect;
                }
                rect.left += m_rectBorder.left;
                rect.top += m_rectBorder.top;
                rect.right -= m_rectBorder.right;
                rect.bottom -= m_rectBorder.bottom;
                RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposExtra, &empty, &rect);
        }
        m_bInRecalcLayout = FALSE;

}

BOOL CMainFrame::NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder)
{
        switch(nBorderCmd)
        {
        case borderGet:
                ASSERT(lpRectBorder != NULL);
                DkShowManager(FALSE, updDelay);
                RepositionBars(0, 0xffff, AFX_IDW_PANE_FIRST, reposQuery,
                        lpRectBorder);  
                DkShowManager(TRUE, updDelay);
                break;
        case borderRequest:
                return TRUE;
                // Disallow the bottom border (causes problems with the status bar)
                if(lpRectBorder->bottom != 0)
                        return FALSE;
                break;

        default:
                return CFrameWnd::NegotiateBorderSpace(nBorderCmd, lpRectBorder);
        }

        return TRUE;
}


BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra,
   AFX_CMDHANDLERINFO* pHandlerInfo)
{
   BOOL bHandled = FALSE;

   // test for active browser popup...
   CWnd * pWndActiveView = GetActiveWindow();
   BOOL fBrowseWindow = pWndActiveView && pWndActiveView->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd));

   // If there's not an active dockworker or browser window, we can let the normal thing happen.
   if (CDockWorker::s_pActiveDocker == NULL && !fBrowseWindow)
      bHandled = CMDIFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
   else
   {
      // Otherwise, we need some special routing.

      // establish pWndActiveView if necessary...
      if (!fBrowseWindow)
         pWndActiveView = CWnd::FromHandlePermanent(theApp.GetActiveView());

      // then try to handle the command message
      if (pWndActiveView && pWndActiveView->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
            bHandled = TRUE;

      if (!bHandled)
         bHandled = CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
   }

   // If we have a toolbar customizer, then disable all commands, but not
   // status bar indicators.  We do this last to allow the normal routing
   // to SetText, SetCheck, etc.

   // Additionally, during customisation we allow the customizer to provide commands. 
   // This is done to support the right button menu on the toolbar or menu for button 
   // actions. martynl 25Mar96, revised 23Jun96

   if (CASBar::s_pCustomizer != NULL) 
   {
                if(nID >= IDM_BUTTON_BASE && nID <= IDM_BUTTON_LAST)
                {
                        // allow button commands to handled by the selected toolbar
                        ASSERT(CASBar::s_pCustomizer->m_pSelectBar!=NULL);
                        
                        bHandled = CASBar::s_pCustomizer->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
                }
                else
                {
                        if (nCode == CN_UPDATE_COMMAND_UI &&
                                (nID < IDM_DOCKSHOW_BASE || nID > IDM_DOCKSHOW_LAST) &&
                                nID != ID_HELP && !IsStatusBarIndicator(nID))
                        {
                                CCmdUI* pCmdUI = (CCmdUI*) pExtra;

								// Menus control their own destiny, even in customisation mode
								CTE *pCTE=theCmdCache.GetCommandEntry(nID);
								if(pCTE && (pCTE->flags & CT_MENU)!=0)
								{
									return TRUE;
								}

                                if (nID != ID_FILE_MRU_FILE1 && nID != ID_PROJ_MRU_FILE1)
                                        pCmdUI->Enable(FALSE);
                                else
                                {
                                        // MFC MRU handled on one CmdMsg.
                                        for (int iMRU = 0; iMRU < _AFX_MRU_COUNT; iMRU++)
                                        {
                                                BOOL bDone=FALSE;
                                                if(CBMenuPopup::IsCBMenuCmdUI(pCmdUI))
                                                {
                                                        CBMenuPopup* pMenu = (CBMenuPopup*)pCmdUI->m_pOther ;
                                                        if(pMenu)
                                                        {
                                                                pMenu->EnableMenuItem(nID + iMRU, MF_GRAYED | MF_BYCOMMAND);
                                                                bDone=TRUE;
                                                        }
                                                }
                                                
                                                if(!bDone)
                                                {
                                                        if(pCmdUI->m_pMenu)
                                                        {
                                                                pCmdUI->m_pMenu->EnableMenuItem(nID + iMRU,     MF_GRAYED | MF_BYCOMMAND);
                                                        }
                                                }
                                        }
                                }
                                return TRUE;
                        }
                }
   }
   return bHandled;
}

static BOOL bControlMenuSelected = FALSE;

void CMainFrame::OnMenuSelect( UINT nItemID, UINT nFlags, HMENU hSysMenu )
{
   // HACKS: We save this time for DBC property page activation, and
   // our own maximized MDI child close on double-click.  For the MDI child
   // closing, we also set a flag that tells us if the last popup menu
   // selected was the control menu of maximized MDI child.

   theApp.m_dwMenuSelectTime = GetCurrentMessage()->time;

   BOOL bMax = FALSE;
   MDIGetActive(&bMax);

   if (bMax && hSysMenu == ::GetMenu(m_hWnd) && nItemID == 0)
      bControlMenuSelected = TRUE;
   else if (hSysMenu != NULL && (nFlags & MF_POPUP) != 0)
      bControlMenuSelected = FALSE;

   // The shell now supports up to 32 windows in the Windows menu.
   // This means that we can no longer use AFX_IDM_FIRST_MDICHILD to
   // AFX_IDM_FIRST_MDICHILD+10 as the menu ids. One consequence is
   // that we no longer display the status bar text. This little bit 
   // of code here translates one of our windows menu items into 
   // a system windows menu so that we can get the status bar text.
   if (( nFlags != 0xFFFF) && // Menu is not closing.
           !(nFlags & (MF_SEPARATOR|MF_POPUP)) && // not a separator or popup.
           (nItemID >= IDM_WINDOWS_BASE) && (nItemID <= IDM_WINDOWS_LAST)) // Its one of the Windows menu items.
   {
                nItemID = AFX_IDM_FIRST_MDICHILD ;
   }

   CMDIFrameWnd::OnMenuSelect( nItemID, nFlags, hSysMenu );
}

void CMainFrame::OnDropFiles(HDROP hDropInfo)
{
   // If the IDE is iconized then we had better restore it.

   if (IsIconic())
   {
      if (theApp.m_bMaximizeApp)
         ShowWindow(SW_SHOWMAXIMIZED);
      else
         ::OpenIcon(GetSafeHwnd());
   }

   // This code was copied from the base class implementation (CFrameWnd::OnDropFiles).
   // The first line of the base class version (SetActiveWindow) was removed, because it appears
   // to be a bug in MFC.
   // SetActiveWindow causes windows to place our window into a partially active state, and hence
   // we don't get the focus correctly when the user switches to us later on.
   // Once MFC gets fixed, we should go back to calling the base class. martynl 20Mar96
        UINT nFiles = ::DragQueryFile(hDropInfo, (UINT)-1, NULL, 0);

        CWinApp* pApp = AfxGetApp();
        for (UINT iFile = 0; iFile < nFiles; iFile++)
        {
                TCHAR szFileName[_MAX_PATH];
                ::DragQueryFile(hDropInfo, iFile, szFileName, _MAX_PATH);
                // set a flag so that we can find out if we were opened using drag-drop or not
                theApp.m_bOpenedFromDrop = TRUE;
                pApp->OpenDocumentFile(szFileName);
                // reset the flag
                theApp.m_bOpenedFromDrop = FALSE;
        }
        ::DragFinish(hDropInfo);
}


/////////////////////////////////////////////////////////////////////////////
// CFullScreenState construction/destruction

_TCHAR CFullScreenState::szKeyName[] = "FullScreen";

CFullScreenState::CFullScreenState ()
{
   m_bFirstTime   = TRUE;
   m_bFullScreen  = FALSE;
   m_bFSWasZoomed = FALSE;
   m_bFSWasIconic = FALSE;
   m_bStatusBar   = (BYTE)theApp.m_bStatusbar;
   m_bFSStatusBar = FALSE;
   m_bFSVertScroll   = FALSE;
   m_bFSHorzScroll   = FALSE;

   ::GetWindowRect (::GetDesktopWindow (), &m_FullScreenWindowRect);
   m_wpFSPrevWinState.length = sizeof m_wpFSPrevWinState;
}

void CFullScreenState::LoadFromReg (LPCTSTR szSection)
{
   HGLOBAL hGlobalDefault = ::GlobalAlloc(GMEM_MOVEABLE, sizeof *this + sizeof WORD);

   if (hGlobalDefault != NULL)
   {
      WORD * pw = (WORD *) ::GlobalLock(hGlobalDefault);
      *pw = sizeof *this;
      operator>> ((BYTE*)(pw + 1));
      ::GlobalUnlock (hGlobalDefault);

      HGLOBAL hGlobalReg = GetRegData (szSection, szKeyName, hGlobalDefault);

      if (hGlobalReg != hGlobalDefault)
      {
         ::GlobalFree (hGlobalDefault);

         pw = (WORD *) ::GlobalLock(hGlobalReg);
         ASSERT (*pw == sizeof *this);
         operator<< ((BYTE *)(pw + 1));
         ::GlobalUnlock (hGlobalReg);
      }

      ::GlobalFree (hGlobalReg);
   }

}

void CFullScreenState::SaveToReg (LPCTSTR szSection)
{
   HGLOBAL hGlobalReg = ::GlobalAlloc(GMEM_MOVEABLE, sizeof *this + sizeof WORD);

   if (hGlobalReg != NULL)
   {
      WORD * pw = (WORD *) ::GlobalLock(hGlobalReg);
      *pw = sizeof *this;
      operator>> ((BYTE*)(pw + 1));
      ::GlobalUnlock (hGlobalReg);

      (void)WriteRegData (szSection, szKeyName, hGlobalReg);

      ::GlobalFree (hGlobalReg);
   }

}

const CFullScreenState& CFullScreenState::operator<< (BYTE * pbSrc)
{
   m_bFullScreen  = *pbSrc;
   m_bFSWasZoomed = (*pbSrc >> 1);
   m_bFSWasIconic = (*pbSrc >> 2);
   m_bStatusBar   = (*pbSrc >> 3);
   m_bFSStatusBar = (*pbSrc >> 4);
   m_bFSVertScroll   = (*pbSrc >> 5);
   m_bFSHorzScroll   = (*pbSrc >> 6);
   m_bFirstTime   = (*pbSrc >> 7);

   memcpy (&m_FullScreenWindowRect, ++pbSrc, sizeof m_FullScreenWindowRect);
   pbSrc += sizeof m_FullScreenWindowRect;

   memcpy (&m_wpFSPrevWinState, pbSrc, sizeof m_wpFSPrevWinState);
   return *this;
}

const CFullScreenState& CFullScreenState::operator>> (BYTE * pbDest)
{
   // Never save as full screen mode.  This has proven to be
   // really frustrating to users who can not figure out how
   // to get out of full screen mode, but can at least shut down
   // the application.  If we save the state, then they are back
   // to the same confusion when they restart the application.

   *pbDest++ =    FALSE /*m_bFullScreen*/
            |  (m_bFSWasZoomed << 1)
            |  (m_bFSWasIconic << 2)
            |  (m_bStatusBar << 3)
            |  (m_bFSStatusBar << 4)
            |  (m_bFSVertScroll << 5)
            |  (m_bFSHorzScroll << 6)
            |  (m_bFirstTime << 7);

   memcpy (pbDest, &m_FullScreenWindowRect, sizeof m_FullScreenWindowRect);
   pbDest += sizeof m_FullScreenWindowRect;

   memcpy (pbDest, &m_wpFSPrevWinState, sizeof m_wpFSPrevWinState);

   return *this;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction


CMainFrame::CMainFrame()
{
   m_bInMenuMode = FALSE;
   m_pManager = NULL;
    m_lastWindowRect = rectDefault;

   m_bLockLayout = FALSE;
   m_bLockManager = FALSE;

   m_nManagerState = 0;
   m_nManagerStateSave = 0;
   for (int i = 0; i < MANAGER_STATES; i++)
      m_ahManagerStates[i] = NULL;
   m_dragDrop = NULL;
   m_hwndAppWiz = NULL;
        m_pIPCmpMainFrm = new CIPCompMainFrame; 

   m_pMacroRecorder = NULL;
   m_pRecorderForShell = NULL;
   m_fInOnEnterState = FALSE;
}


CMainFrame::~CMainFrame()
{
   for (int i = 0; i < MANAGER_STATES; i++)
   {
      if (m_ahManagerStates[i] != NULL)
         ::GlobalFree(m_ahManagerStates[i]);
   }
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG

void CMainFrame::AssertValid() const
{
   CMDIFrameWnd::AssertValid();
}


void CMainFrame::Dump(CDumpContext& dc) const
{
   CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

int CMainFrame::OnCreate(LPCREATESTRUCT lpcs)
{
    if (CMDIFrameWnd::OnCreate(lpcs) == -1)
        return -1;

   m_pWndMDIClient = new CMDIClientValidator;
   VERIFY(m_pWndMDIClient->SubclassWindow(m_hWndMDIClient));

   if (!m_statusBar.Create(this) ||
      !m_statusBar.SetIndicators())
   {
      TRACE("Failed to create status bar\n");
      return -1;     // fail to create
   }

   // Put MDIClient on the bottom.
   m_pWndMDIClient->SetWindowPos(&m_statusBar, 0, 0, 0, 0,
      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

   return 0;
}

void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
        if (!IsFullScreen())
        {
        switch (nType)
        {
        case SIZE_RESTORED:
            GetWindowRect(&m_lastWindowRect);
            theApp.m_bMaximizeApp = FALSE;
            break;

        case SIZE_MINIMIZED:
         if (theApp.m_fOEM_MBCS)
            imeMoveConvertWin(m_hWnd, cx, cy);
            break;

        case SIZE_MAXIMIZED:
            theApp.m_bMaximizeApp = TRUE;
            break;
        }
        }

        CMDIFrameWnd::OnSize(nType, cx, cy);
    imeFlush( m_hWnd );

        CWnd *pView = CWnd::FromHandle(theApp.GetActiveView());
    if (pView && pView->IsKindOf( RUNTIME_CLASS(CPartView) ))
    {
                ((CPartView *)pView)->RecalculateIME();
    }
}

void CMainFrame::OnMove(int x, int y)
{
    CMDIFrameWnd::OnMove(x, y);
    if (!IsZoomed() && !IsIconic() && !IsFullScreen())
        GetWindowRect(&m_lastWindowRect);

    imeFlush( m_hWnd );

      CWnd *pView = CWnd::FromHandle(theApp.GetActiveView());
      if (pView && pView->IsKindOf( RUNTIME_CLASS(CPartView) ))
      {
         ((CPartView *)pView)->RecalculateIME();
      }
}

void CMainFrame::OnClose()
{
   // If we are in customize mode, don't close.
   if (CASBar::s_pCustomizer != NULL)
      return;

   // Note: only queries the active document
   CDocument* pDocument = GetActiveDocument();
   if (pDocument != NULL && !pDocument->CanCloseFrame(this))
   {
      // document can't close right now -- don't close it
      return;
   }

   // Give each package a chance to veto the exit...
   POSITION pos = theApp.m_packages.GetHeadPosition();
   while (pos != NULL)
   {
      CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
      if ((pPackage->m_flags & PKS_QUERYEXIT) != 0 && !pPackage->CanExit())
         return;
   }

   // try to save all documents
   if (pDocument == NULL && !AfxGetApp()->SaveAllModified())
      return;     // don't close it

   // Any code added after here must quit. All chances to abort the exit must go before here
   // inform any event subscribers that we are definitely going away.
   theApp.m_pAutoApp->FireBeforeApplicationShutDown();

   // All this needs to happen before OnDestroy, because popups
   // get destroyed before their owners.
   if (IsFullScreen())
   {
      OnWindowFullScreen();
      m_FS.m_bFullScreen = TRUE; // HACK!
   }

   if (!theApp.m_bInvokedCommandLine)
   {
		SaveLayout();
		theApp.SavePrivateProfileSettings();

	   // BLOCK: Save all the keymaps...
	   {
		  POSITION pos = CKeymap::c_keymaps.GetHeadPosition();
		  while (pos != NULL)
		  {
			 CKeymap* pKeymap = (CKeymap*)(void*)CKeymap::c_keymaps.GetNext(pos);
			 pKeymap->WriteReg();
		  }
	   }
   }

   CDockWorker::s_pActiveDocker = NULL;   // Make sure we don't try to activate.

   // hide the application's windows before closing all the documents
   ShowOwnedPopups(FALSE); // And the popup windows. (MFC should do this)
   AfxGetApp()->HideApplication();

   // [dolphin #9854 7/5/94 mikemo]
   // This mysteriously fixes the problem where, when you shut down
   // the IDE and the IDE's window disappears, the app behind the
   // IDE gets focus for a moment, and then for some reason loses
   // focus again.  This seems to be caused by the SetFocus in
   // CView::OnActivateView.  That doesn't make sense to me, because
   // in this scenario SetFocus is called when the IDE is invisible;
   // and besides that, I didn't think SetFocus was supposed to bring
   // an app to the foreground.  But in any case, disabling the main
   // frame causes the later SetFocus to fail, and thus the focus
   // problem goes away.
   m_pWndMDIClient->EnableWindow(FALSE);

   DestroyPropertyBrowser();

   // destroy the dock manager to close its documents.
    delete m_pManager;
    m_pManager = NULL;

#ifdef _DEBUG
   bQuitting = TRUE;
#endif

   // close all documents first
   AfxGetApp()->CloseAllDocuments(FALSE);

   // [dolphin #9854 7/5/94 mikemo]
   // To prevent a memory leak in MFC, we now have to re-enable the window
   //EnableWindow(TRUE);

   // Release all package interfaces
   if (m_pMacroRecorder != NULL)
                m_pMacroRecorder->Release();
   m_pMacroRecorder = NULL;
   if (m_pRecorderForShell != NULL)
                m_pRecorderForShell->Release();
   m_pRecorderForShell = NULL;

   // Packages which hold on to OLE objects that lock the app
   //  need to be told that we're exiting now, so they
   //  can release those objects, and MFC's CMDIFrameWnd::OnClose()
   //  will correctly destroy the window, thus calling our CMainFrame::
   //  DestroyWindow() which unloads the packages and calls their
   //  CPackage::OnExit().
   pos = theApp.m_packages.GetHeadPosition();
   while (pos != NULL)
   {
      CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
      if ((pPackage->m_flags & PKS_PREEXIT) != 0)
                pPackage->OnPreExit();
   }

   // We zombify the Application's OLE Automation object here, so that
   //  it will do an AfxOleUnlockApp.  If we don't, MFC will not call
   //  our CMainFrame::DestroyWindow(), and we'll never exit.
   theApp.m_pAutoApp->Zombify();
   theApp.m_pAutoApp->Destroy();
   theApp.m_bQuitting = TRUE;

   CMDIFrameWnd::OnClose();
}

BOOL CMainFrame::DestroyWindow()
{
   // Make absolutely certain the Application's OLE Automation object is
   //  zombified by now, in case we get here without an intervening
   //  CMainFrame::OnClose call.  Zombifying does an AfxOleUnlockApp.
   if (theApp.m_pAutoApp != NULL)
                theApp.m_pAutoApp->Zombify();

   // Release all package interfaces (if there was an intervening CMainFrame::
   //  OnClose call, this was already done).
   if (m_pMacroRecorder != NULL)
                m_pMacroRecorder->Release();
   m_pMacroRecorder = NULL;
   if (m_pRecorderForShell != NULL)
                m_pRecorderForShell->Release();
   m_pRecorderForShell = NULL;

   // Close the packages...
   // Packages may supply popups owned by the main frame (Prop Browser).
   //
   POSITION pos = theApp.m_packages.GetHeadPosition();
   while (pos != NULL)
   {
      CPackage *pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
      pPackage->OnExit();
   }

   /*if (theApp.m_pAutoApp != NULL)
   {
      theApp.m_pAutoApp->Destroy();
      theApp.m_pAutoApp = NULL;
   }*/

        // shut down Component manager
        theApp.TermStdCompMgr();
        m_pIPCmpMainFrm->InternalRelease();
                
        return CMDIFrameWnd::DestroyWindow();
}

void CMainFrame::RecordDefaultTextIfNecessary(WORD nID)
{
	// This should only be called if we're currently recording,
	//  which should only happen if devaut1.pkg is loaded,
	//  which implies we have these interfaces.
	ASSERT (m_pRecorderForShell != NULL && m_pMacroRecorder != NULL);
	
	BOOL bWasTextRecorded = TRUE;
	m_pRecorderForShell->EndListenForRecord(&bWasTextRecorded);
	if (!bWasTextRecorded)
	{
		// Nothing was recorded, so try to record default text
		LPCTSTR szCommand = NULL;
		if (ID_PROJ_MRU_FIRST <= nID && nID <= ID_PROJ_MRU_LAST)
		{
			// SPECIAL CASE: Opening a project off of the MRU list results
			//  in a bogus command name from the CTE, so handle that
			//  case manually.  Instead of hard-coding the command string,
			//  we just find the CTE for WorkspaceOpen and use its cmd string
			CTE* pCTE = theCmdCache.GetCommandEntry(IDM_OPEN_WORKSPACE);
			if (pCTE == NULL)
			{
				// Someone recorded opening a workspace from the MRU, but
				//  the OpenWorkspace CTE isn't around?!
				ASSERT(FALSE);
				return;
			}
			else
				szCommand = pCTE->szCommand;
		}
		else
		{
			// No special case here.  Just record the text in the
			//  CTE we get from the cmd ID.
			CTE* pCTE = theCmdCache.GetCommandEntry(nID);
			if (pCTE != NULL)
				szCommand = pCTE->szCommand;
			else
				return;
		}
		ASSERT (szCommand != NULL && *szCommand != '\0');
  		CString strText;
		strText.Format("ExecuteCommand \"%s\"", szCommand);
		m_pMacroRecorder->RecordText(strText, "Shl");
	}
}

BOOL CMainFrame::OnCommand(WPARAM wParam, LPARAM lParam)
{
   // test for active browser popup...
   CWnd * pWndActiveView = GetActiveWindow();
   BOOL fBrowseWindow = pWndActiveView && pWndActiveView->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd));
   void *pv;
   UINT cRep = 1;
   BOOL bRet = FALSE;

   BOOL bShouldRecordText = theApp.ShouldRecordText();

   if (theApp.m_RepeatableCmds.Lookup(LOWORD(wParam), pv))
      cRep = max(1, theApp.GetRepCount());

   for (UINT i = 0; i < cRep; i++)
   {
      if (bShouldRecordText)
          {
                 // Shouldn't be in a recording session if devaut1.pkg isn't loaded
                 ASSERT (m_pRecorderForShell != NULL);
         m_pRecorderForShell->BeginListenForRecord();
          }

      if (fBrowseWindow)
      {
         // dispatch the command message to the browser popup first...
         if (AfxWndProc(pWndActiveView->m_hWnd, WM_COMMAND, wParam, lParam))
            bRet = TRUE;
      }
      else if (CDockWorker::s_pActiveDocker != NULL)
      {
         HWND hWndActiveView = theApp.GetActiveView();

         if (CWnd::FromHandlePermanent(hWndActiveView) != NULL &&
            AfxWndProc(hWndActiveView, WM_COMMAND, wParam, lParam) != 0)
               bRet = TRUE;
      }
      else
      {
         // send to MDI child first - will be re-sent through OnCmdMsg later
         CMDIChildWnd* pActiveChild = MDIGetActive();
         if (pActiveChild != NULL && AfxWndProc(pActiveChild->m_hWnd,
           WM_COMMAND, wParam, lParam) != 0)
            bRet = TRUE; // handled by child
      }

          if (bShouldRecordText && bRet == TRUE)
          {
                  // We're recording and the command was handled.  Did the
                  //  package record anything?
                  RecordDefaultTextIfNecessary(LOWORD(wParam));
          }
   }

   if (LOWORD(wParam) < MIN_ID_REPEAT_CMD || LOWORD(wParam) > MAX_ID_REPEAT_CMD)
      theApp.ClearRepCount();

   if (bRet)
      return TRUE;

   if (bShouldRecordText)
   {
          ASSERT (m_pRecorderForShell != NULL);
          m_pRecorderForShell->BeginListenForRecord();
   }

   if (LOWORD(wParam) == ID_HELP)
   {
      if (IsTracking())
         return TRUE; // disable menu help

      // Delegate all help requests to AppWizard if it's around
      if (m_hwndAppWiz != NULL && HIWORD(wParam) == BN_CLICKED)
      {
         ::SendMessage(m_hwndAppWiz, WM_COMMAND, wParam, lParam);

                  if (bShouldRecordText)
                          RecordDefaultTextIfNecessary(LOWORD(wParam));

         return TRUE;
      }
   }

   if (CFrameWnd::OnCommand(wParam, lParam))
   {
      if (bShouldRecordText)
                  RecordDefaultTextIfNecessary(LOWORD(wParam));

      return TRUE; // handled through normal mechanism (MDI child or frame)
   }

   HWND hWndCtrl = (HWND)lParam;

   ASSERT(AFX_IDM_FIRST_MDICHILD == 0xFF00);
   if (hWndCtrl == NULL && (LOWORD(wParam) & 0xf000) == 0xf000)
   {
      // menu or accelerator within range of MDI children
      // default frame proc will handle it
      DefWindowProc(WM_COMMAND, wParam, lParam);

      // DefWindowProc doesn't expect dockable windows, so make sure
      // one is not still active.
      if (CDockWorker::s_pActiveDocker != NULL)
         SetFocus();

      if (bShouldRecordText)
             RecordDefaultTextIfNecessary(LOWORD(wParam));

          return TRUE;
   }

   if (bShouldRecordText)
   {
           // Nothing recorded, so reset macro recorder for shell
           BOOL bDummy;
           m_pRecorderForShell->EndListenForRecord(&bDummy);
   }

   return FALSE;   // not handled
}

// CTestUI
//
// A miniature CCmdUI class which is used to determine whether a
// given submenu should be enabled or disabled (i.e. whether there
// are any enabled commands on the submenu).
//
class CTestUI : public CCmdUI
{
public:
   CTestUI();

   virtual void Enable(BOOL bEnabled = TRUE);
   virtual void SetCheck(int nCheck = 1);   // 0, 1 or 2 (indeterminate)
   virtual void SetRadio(BOOL bOn = TRUE);
   virtual void SetText(LPCSTR lpszText);

   BOOL m_bEnabled;
};

CTestUI::CTestUI()
{
   m_bEnabled = FALSE;
}

void CTestUI::Enable(BOOL bEnabled)
{
   m_bEnabled = m_bEnabled || bEnabled;
}

void CTestUI::SetCheck(int nCheck)
{ }

void CTestUI::SetRadio(BOOL bOn)
{ }

void CTestUI::SetText(LPCSTR lpszText)
{
   m_bEnabled = TRUE;
}

void CMainFrame::OnInitMenu(CMenu* pMenu)
{
   EnsureViewActive();  // Don't let toolbars stay active.

   CMDIFrameWnd::OnInitMenu(pMenu);
}

void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT, BOOL bSysMenu)
{
   // If this is a system menu, do the default thing.  In order to
   // determine whether it's a SysMenu, however, we also have to check
   // the id of the first item, since maximized MDI child windows will
   // not have bSysMenu set for their system menus.
   // (-1 for menuitem means sub popup) -bm
   int nItem = pPopupMenu->GetMenuItemID(0);
   if (bSysMenu || (nItem != -1 && nItem > 0xf000 && nItem < 0xff00))
   {
      pPopupMenu->EnableMenuItem(SC_CLOSE,
         (CASBar::s_pCustomizer == NULL) ? MF_ENABLED : MF_GRAYED);

      if (IsFullScreen())
      {
         pPopupMenu->EnableMenuItem(SC_MAXIMIZE, MF_GRAYED);
         pPopupMenu->EnableMenuItem(SC_MOVE, MF_GRAYED);
         pPopupMenu->EnableMenuItem(SC_SIZE, MF_GRAYED);
      }
      else
         ;  // Let the system enable/disable it.

      return;
   }

        CWnd* pWnd = CWnd::FromHandle(theApp.GetActiveView());
        int cItems = pPopupMenu->GetMenuItemCount();
        // also determine if this is the Window menu
        // and if the MDI window list is on the menu
        BOOL bWndMenu = FALSE;
        BOOL bMDIList = FALSE;
        for (int iItem = 0 ; iItem < cItems ; iItem++)
        {
                int nID = pPopupMenu->GetMenuItemID(iItem);
                // is this the Windows menu?
                // use ID_WINDOW_CASCADE to determine this
                if (nID == ID_WINDOW_CASCADE) {
                        bWndMenu = TRUE;
                }
                // is the MDI window list on the menu?
                // 0xff00 is the ID of the first MDI child window menu item
                if (nID == 0xff00) {
                        bMDIList = TRUE;
                }
        }

   // if this is the Window menu, remove More Windows...
   if (bWndMenu) {
      // (More Windows... has an ID of 0xff09)
      pPopupMenu->RemoveMenu(0xff09, MF_BYCOMMAND);
      pPopupMenu->RemoveMenu(ID_WINDOW_LIST_DOCS, MF_BYCOMMAND);
      // only add a separator if there's no MDI window list
      // and a separator hasn't already been added
      if (!bMDIList && pPopupMenu->GetMenuItemID(pPopupMenu->GetMenuItemCount()-1) != ID_SEPARATOR) {
         pPopupMenu->AppendMenu(MF_SEPARATOR);
      }
      // add the Doc List menu item to the end of the menu
      LPCTSTR lpszCommand;

      theCmdCache.GetCommandString(ID_WINDOW_LIST_DOCS, STRING_MENUTEXT,
         &lpszCommand);
      CString strMenuItem = lpszCommand;

      // get the accelerator for this item
      CString strKey;
      if (GetCmdKeyString(ID_WINDOW_LIST_DOCS, strKey)) {
         strMenuItem += CString(_T("\t")) + strKey;
      }
      // add the menu item to the menu
      pPopupMenu->AppendMenu(MF_ENABLED, ID_WINDOW_LIST_DOCS, strMenuItem);
   }

   // Default processing to send UPDATE_COMMAND_UI messages.
   CMDIFrameWnd::OnInitMenuPopup(pPopupMenu, 0, bSysMenu);
}

int CMainFrame::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
   ASSERT(!bQuitting);

   if (theApp.m_hwndValidate != NULL &&
      ::SendMessage(theApp.m_hwndValidate, WM_ISERROR, TRUE, 0L))
   {
      return MA_NOACTIVATEANDEAT;
   }

   CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
   if (pDocker != NULL && pDocker->GetDock() == dpNil)
   {
      ASSERT(pDocker->m_pWnd != NULL);

      if (nHitTest == HTMENU)
         CDockWorker::LockWorker();
      else if (CDockWorker::s_bLockDocker)
         pDocker->m_pWnd->SetFocus();
   }

   if (CASBar::s_pCustomizer != NULL)
   {
      if (theApp.m_bDeactByOtherApp)
      {
         EnsureCustomizerActive();
         return MA_NOACTIVATEANDEAT;
      }
      else if (nHitTest != HTSYSMENU && nHitTest != HTMENU)
      {
         return MA_NOACTIVATE;
      }
   }

   // Fix for Dolphin #626.  We want to make sure that clicking on the
   // caption/menu bar will activate Dolphin.  [w-amilt]
   switch (nHitTest)
   {
   case HTCAPTION:
      return MA_ACTIVATE;

   case HTMENU:
      return MA_ACTIVATE;

   default:
      break;
   }

   return CMDIFrameWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

void CMainFrame::OnUpdateIndicator(CCmdUI* pCmdUI)
{
   switch (pCmdUI->m_nID)
   {
      case ID_SEPARATOR:
         pCmdUI->ContinueRouting();
         break;

      case ID_INDICATOR_OVR:
         pCmdUI->Enable(m_statusBar.GetOverStrike());
         break;

      default:
         {
            CString str;
            m_statusBar.GetText(pCmdUI->m_nID, str);
            // CStatusBar::SetPaneText has a 'feature' wherein it doesn't
            // recognize that successive calls with an empty string are the
            // same, so it continues to paint the empty string.
            //
            // So if we're about to set an empty string, make it a single
            // space character instead.
            pCmdUI->SetText(str.IsEmpty() ? " " : (LPCTSTR) str);
            pCmdUI->Enable(TRUE);
         }
         break;
   }
}

#ifdef _DEBUG
void CMainFrame::OnOpenLayout()
{
   SetDockState((m_nManagerState + 1) % MANAGER_STATES);
}
#endif

LRESULT CMainFrame::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef _DEBUG
#ifdef _WIN32
   if (message == WM_CMDPERFCHECK)
   {
      if (wParam == 0 || LOWORD(wParam) == 0xFFFF)
         return 0L;     // ignore invalid IDs

      CWnd* pWnd = this;

      __int64 liBegin, liEnd;
      //LARGE_INTEGER liBegin, liEnd;
      QueryPerformanceCounter((LARGE_INTEGER*)&liBegin);

      for (int i = 0; i < 1000; i++)
      {
         CTestUI testUI;
         testUI.m_nID = wParam;

         if (pWnd->OnCmdMsg(testUI.m_nID, CN_UPDATE_COMMAND_UI, &testUI, NULL))
            ASSERT(!testUI.m_bEnableChanged); // not routed

         if (!testUI.m_bEnableChanged)
         {
            AFX_CMDHANDLERINFO info;
            info.pTarget = NULL;

            BOOL bHndler = pWnd->OnCmdMsg(testUI.m_nID, CN_COMMAND, &testUI, &info);
         }
      }

      QueryPerformanceCounter((LARGE_INTEGER*)&liEnd);
      liEnd = liEnd - liBegin;
      return LRESULT(liEnd);
      //liEnd = LargeIntegerSubtract(liEnd, liBegin);
      //return liEnd.LowPart;
   }
#endif
#endif

#ifdef _CMDLOG
   if (theApp.m_bCmdLog && (message == WM_COMMAND))
   {
      theApp.m_cmdTable.Update(LOWORD((DWORD)wParam));
   }
#endif // _CMDLOG

   return CMDIFrameWnd::WindowProc(message, wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////

void SushiCancelModes(HWND hWndRcvr)
{
   extern void PASCAL AfxCancelModes(HWND hWndRcvr);

   // This is the sole reason for having CDropControl be dynamic
   CWnd* pWnd = CWnd::GetFocus();
   if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CDropControl)))
      ((CDropControl*)pWnd)->CancelModes();

   AfxCancelModes(hWndRcvr);
}


BOOL CMainFrame::PreTranslateMessage(MSG* pMsg)
{
	// steal toolbar navigation keys during bar navigation mode
	if(CASBar::EarlyStealMenuMessage(pMsg))
	{
		return TRUE;
	}

   // check for special cancel modes for ComboBoxes
   CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);
   if ((pMsg->message == WM_LBUTTONDOWN ||   pMsg->message == WM_NCLBUTTONDOWN) &&
      !(pWnd->IsKindOf(RUNTIME_CLASS(CDropControl)) && GetFocus() == pWnd) &&
      !pWnd->IsKindOf(RUNTIME_CLASS(CGhostListBox)))
   {
      SushiCancelModes(pMsg->hwnd);    // filter clicks
   }

   // test for active browser popup...
   CWnd* pWndActiveView = GetActiveWindow();
   BOOL fBrowseWindow = pWndActiveView != NULL &&
      pWndActiveView->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd));

   // If there's not an active dock worker or browser, we can let the normal thing happen.
   if (CDockWorker::s_pActiveDocker == NULL && !fBrowseWindow)
   {
		//if (CMDIFrameWnd::PreTranslateMessage(pMsg))
		if (MDIFrameWnd_PreTranslateMessage(pMsg))
		{
			return TRUE;
		}
   }
   else
   {
      // Otherwise, we need some special routing.

      // establish current active view if necessary
      if (!fBrowseWindow)
	  {
		pWndActiveView = CWnd::FromHandlePermanent(theApp.GetActiveView());
	  }

      // If any window in the parent chain is disabled, then we do not
      // handle the message.  In case a dialog is active.

      for (CWnd* pWnd = pWndActiveView; pWnd != NULL; pWnd = pWnd->GetParent())
      {
		if (!pWnd->IsWindowEnabled())
			pWndActiveView = NULL;

		if (pWndActiveView == NULL || (pWnd->GetStyle() & WS_POPUP) != 0)
			break;
      }

      if (pWndActiveView != NULL && pWndActiveView->PreTranslateMessage(pMsg))
         return TRUE;

      if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
      {
			// the MDICLIENT window may translate it			
			if (::TranslateMDISysAccel(m_hWndMDIClient, pMsg))
			{
				return TRUE;
			}
      }
   }

   if (m_keymap.TranslateMessage(this, pMsg))
      return TRUE;


   // Are we entering a repeat count?
   if (theApp.FSettingRepeatCount(pMsg) && theApp.FCmdRepeatPretranslate(pMsg))
      return TRUE; // Handled

	// steal alt key combinations before anyone else gets a look in for the use of the menu bar
	if(CASBar::StealMenuMessage(pMsg))
	{
		return TRUE;
	}

	// Orion 96 Bug # 14688 
	// Fixes ALT-F4 when the mouse pointer is over a button.
	if (pMsg->message == WM_SYSCOMMAND && 
		pMsg->wParam == SC_CLOSE &&
		pMsg->hwnd == m_hWnd)
	{
		// The user is attempting to close the app possibly using ALT-F4.
		// If the menubar has the capture set, turn it off. Otherwise, windows
		// will not close the application. 
		// See the SC_CLOSE case in xxxSysCommand in syscmd.c.
		CWnd* pWndWithCapture = GetCapture() ;
		if (pWndWithCapture && pWndWithCapture->IsKindOf(RUNTIME_CLASS(CASBar)))
		{
			// Turn capture off.
			::ReleaseCapture() ;
		}
	}

   return FALSE;
}

///////////////////////////////////////////////////////////
//
// MDIFrameWnd_PreTranslateMessage
//
// This function was stolen directly from MFC. See the
// comment below about the Orion 96 Bug 14688.
//
BOOL CMainFrame::MDIFrameWnd_PreTranslateMessage(MSG* pMsg)
{
	// check for special cancel modes for ComboBoxes
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_NCLBUTTONDOWN)
		AfxCancelModes(pMsg->hwnd);    // filter clicks

	// allow tooltip messages to be filtered
	if (CWnd::PreTranslateMessage(pMsg))
		return TRUE;

#ifndef _AFX_NO_OLE_SUPPORT
	// allow hook to consume message
	if (m_pNotifyHook != NULL && m_pNotifyHook->OnPreTranslateMessage(pMsg))
		return TRUE;
#endif

	CMDIChildWnd* pActiveChild = MDIGetActive();

	// current active child gets first crack at it
	if (pActiveChild != NULL && pActiveChild->PreTranslateMessage(pMsg))
		return TRUE;

	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
	{
		// translate accelerators for frame and any children
		if (m_hAccelTable != NULL &&
			::TranslateAccelerator(m_hWnd, m_hAccelTable, pMsg))
		{
			return TRUE;
		}

		// special processing for MDI accelerators last
		// and only if it is not in SDI mode (print preview)
		if (GetActiveView() == NULL)
		{
			if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
			{
				// the MDICLIENT window may translate it

				// Orion 96 Bug 14688: TranslateMDISysAccel will not close a window (CTRL-F4)
				// if another window has captured the mouse. Fool it by turning capture off then
				// back on.
				// 
				BOOL bReDoCapture = FALSE ;
				CWnd* pWndWithCapture = GetCapture() ;
				if (pWndWithCapture && pWndWithCapture->IsKindOf(RUNTIME_CLASS(CASBar)))
				{
					// Turn capture off.
					bReDoCapture = TRUE;
					::ReleaseCapture() ;
				}
				BOOL b = ::TranslateMDISysAccel(m_hWndMDIClient, pMsg) ;				
				if (bReDoCapture)
				{
					// Turn capture on.
					pWndWithCapture->SetCapture() ;
				}
				if (b)
				{
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}

//
//
//
BOOL CMainFrame::OnNcActivate(BOOL bActive)
{
   if (CASBar::s_pCustomizer != NULL)
      bActive = FALSE;
   // NOTE: This doesn't work Alt-Tabbing back when a palette has the focus.
   //
   else if (!theApp.m_bDeactByOtherApp && IsWindowEnabled())
      bActive = TRUE;

   // CMDIFrameWnd just calls Default(), but we may have changed bActive.
   return (BOOL) DefWindowProc(WM_NCACTIVATE, bActive, 0L);
}

void CMainFrame::OnActivateApp(BOOL bActive, HTASK hTask)
{
#ifdef _DEBUG
   ASSERT(!bQuitting || !bActive);
   bQuitting = FALSE;   // Stop us from showing continuous stream of asserts.
#endif

   theApp.m_fVCPPIsActive = bActive;
   theApp.m_bDeactByOtherApp = !bActive;

   CMDIFrameWnd::OnActivateApp(bActive, hTask);

   if (bActive)
      EnsurePopupActive();
   else
      CDockWorker::LockWorker();

   SendMessage(WM_NCACTIVATE);
   if (IsWindowVisible())
   {
      // Blows m_lastWindowRect so window comes up in the wrong position
      // if this happens before window is visible.
      SetWindowPos(NULL, 0, 0, 0, 0, SWP_DRAWFRAME |
         SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE);
   }

   if (IsWindowEnabled() && m_pManager != NULL)
      m_pManager->ActivatePalettes(bActive);

   // signal to other packages for OnIdle processing
   if (bActive)
      theApp.m_bActivated = TRUE;

   if(!bActive)
   {
	   if(!theApp.IsCustomizing())
	   {
		   // tell the first visible menu that it is done
			POSITION pos=CBMenuPopup::s_listMenus.GetHeadPosition();
			if(pos)
			{
                CBMenuPopup *pMenu=CBMenuPopup::s_listMenus.GetNext(pos);

				// Don't do anything if the menu is already in the process of shutting down
                if(pMenu && pMenu->ContinueModal())
                {
				   pMenu->Done();
				}
			}
	   }
   }
}

void CMainFrame::OnEnable(BOOL bEnable)
{
   CMDIFrameWnd::OnEnable(bEnable);

   // Make sure we show the right caption color, since DefWindowProc
   // will not do this for us, if a dockable window is active.
   // If the caller is entering a modal state through the Component Mgr,
   // we don't want to do this....
   if (!bEnable && !m_fInOnEnterState)
      SendMessage(WM_NCACTIVATE);

   if (m_pManager != NULL)
      m_pManager->ActivatePalettes(bEnable);

   PostMessage(WM_POST_ENABLE_IME, bEnable);
}

/* OnPostEnableIME
 * We want to turn the IME on when you open a modal dialog or a proppage/browser
 * but because we get disabled inside of the DoModal call, MFC's creation hook
 * is getting sidetracked by the creation of the IME.
 * The solution is to postpone enabling of the IME, using a PostMessage.
 * wParam is bEnable from OnEnable (i.e. FALSE == disable app == enable IME)
 */
LRESULT CMainFrame::OnPostEnableIME(WPARAM wParam, LPARAM lParam)
{
   // This bit of code turns the IME on when you open a modal dialog or a proppage/browser
   static BOOL bDisableIME;
   if( !wParam )
   {
      bDisableIME = !theIME.IsEnabled();
      theIME.EnableIME(TRUE);
   }
   else
   {
      if (bDisableIME)
         theIME.EnableIME(FALSE);
   }
   return 0;
}

/* OnRegMouseWheel
 * craigc
 * this message is the mouse wheel notification for win95
 * which does not support WM_MOUSEWHEEL.
 * we forward this to the guy with the focus
 */

LRESULT CMainFrame::OnRegMouseWheel(WPARAM wParam, LPARAM lParam)
{
    CWnd * pWnd;

    if (pWnd = CWnd::FromHandlePermanent(theApp.GetActiveView()))
    {
        return pWnd->SendMessage(MSG_MOUSEWHEEL,wParam,lParam);
    }
    else
        return 0;
}

void CMainFrame::OnWindowCloseAll()
{
   // First see if the user wants to cancel out of saving.
   // Filter project RC files, since closing their editors will not
   // close the file.
   if (!theApp.SaveAll(TRUE, FILTER_PROJECT | FILTER_PROJ_RC))
      return;

   // Next see if all windows can close.
   CPartFrame* pMDIChild = theApp.MDITypedGetActive(FILTER_PROJECT);
   while (pMDIChild != NULL)
   {
      CPartView* pView = (CPartView*)pMDIChild->GetActiveView();
      if (pView != NULL)
      {
         ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
         if (!pView->CanClose())
            return;
      }

      pMDIChild = theApp.MDITypedGetNext(pMDIChild, FILTER_PROJECT);
   }

   CWaitCursor wc;

   // Close everything.
   CloseWindows(FILTER_PROJECT);
}

void CMainFrame::OnWindowClose()
{
        CMDIChildWnd *pActive=MDIGetActive();
        if(pActive)
        {
                pActive->SendMessage(WM_CLOSE,0,0);
        }
}

void CMainFrame::OnWindowNext()
{
        CPartFrame *pActive=(CPartFrame *)MDIGetActive();
        if(pActive)
        {
                pActive->MDINextWindow(TRUE, TRUE);
        }
}

void CMainFrame::OnWindowPrevious()
{
        CPartFrame *pActive=(CPartFrame *)MDIGetActive();
        if(pActive)
        {
                pActive->MDINextWindow(FALSE, TRUE);
        }
}

void CMainFrame::OnUpdateWindowCommand(CCmdUI* pCmdUI)
{
        if(MDIGetActive())
        {
                pCmdUI->Enable(TRUE);
        }
        else
        {
                pCmdUI->Enable(FALSE);
        }
}

///    CMainFrame::OnWindowFullScreen()
//
// "Window.Full Screen" menu option.
//
// Toggles full-screen mode.  FS mode means that the MDI client area is enlarged to
//  fill the whole screen.  This is accomplished by resizing the frame window to be larger
// than the screen.  Most of the work below serves to calculate what that size should be.
/////
void CMainFrame::OnWindowFullScreen ()
{
   if (IsFullScreen())
   {
      m_FS.m_bFullScreen = FALSE;

      m_FS.m_bFSStatusBar = (BYTE)theApp.m_bStatusbar;
      ShowStatusBar (theApp.m_bStatusbar = m_FS.m_bStatusBar);

      // If we are returning the app to the Maximized state, SetWindowPlacement()
      // draws the entire app twice - once to its "Normal" state, then once to
      // the maximized state.  The LockWindowUpdate() calls suppress the extra
      // redraw.

      ::LockWindowUpdate(m_hWnd);
      SetWindowPlacement ( &m_FS.m_wpFSPrevWinState );
      CFullScreenState::Notify ntfy;
      theApp.NotifyPackages (PN_FULL_SCREEN_END, NULL, &ntfy);
      SetDockState(~STATE_FULLSCREEN, MASK_FULLSCREEN);
      ::LockWindowUpdate(NULL);

      m_FS.m_bFSVertScroll = (BYTE)ntfy.bVert;
      m_FS.m_bFSHorzScroll = (BYTE)ntfy.bHorz;
   }
   else
   {
      m_FS.m_bFullScreen = TRUE;

      // We'll need these to restore the original state.
      GetWindowPlacement ( &m_FS.m_wpFSPrevWinState );

      // BOGUS! NT 3.51 sets the length field wrong sometimes.
      m_FS.m_wpFSPrevWinState.length = sizeof m_FS.m_wpFSPrevWinState;

      // "Full Screen" means that our client area is the same
      // size as the desktop.
#define SPI_GETWORKAREA            48

      RECT rectDesktop;
      if (!::SystemParametersInfo (SPI_GETWORKAREA, 0, &rectDesktop, 0))
      {
         ::GetWindowRect ( ::GetDesktopWindow(), &rectDesktop );
      }
      else
      {
         // In Win95, when the Task Bar is not in AutoHide mode, the
         // "screen" excludes the Task Bar.  When the Task Bar is at the left
         // or top, this means that our origin must be adjusted in the negative
         // direction by the size of the Task Bar.  SPI_GETWORKAREA provides us
         // with the rectangle for the the physical screen not occupied by the
         // Task Bar.
         rectDesktop.right = ::GetSystemMetrics (SM_CXSCREEN);
         rectDesktop.bottom = ::GetSystemMetrics (SM_CYSCREEN);
         rectDesktop.right -= rectDesktop.left;
         rectDesktop.bottom -= rectDesktop.top;
         rectDesktop.left = -rectDesktop.left;
         rectDesktop.top = -rectDesktop.top;
      }
      ::AdjustWindowRect (&rectDesktop, GetStyle(), !Menu::IsShowingCmdBars());

      rectDesktop.bottom += ::GetSystemMetrics (SM_CYBORDER);   // See "Ask Dr. GUI #10"

      // AdjustWindowRect() cannot adjust for the status bar, so we remove
      // it ourselves.
      //CRect rectStatusBar;
      //m_statusBar.GetWindowRect (&rectStatusBar);
      //rectDesktop.bottom += rectStatusBar.Height();
      m_FS.m_bStatusBar = (BYTE)theApp.m_bStatusbar;
      ShowStatusBar (theApp.m_bStatusbar = m_FS.m_bFSStatusBar);

      // Remember this so that OnGetMinMaxInfo() can set the correct
      // window max sizes.
      m_FS.m_FullScreenWindowRect = rectDesktop;

      // Now we make the change.
      WINDOWPLACEMENT wpNew = m_FS.m_wpFSPrevWinState;
      wpNew.showCmd =  SW_SHOWNORMAL;
      wpNew.rcNormalPosition = rectDesktop;
      ::LockWindowUpdate(m_hWnd);
      SetWindowPlacement ( &wpNew );

      CFullScreenState::Notify ntfy;
      ntfy.rectFullScreen = m_FS.m_FullScreenWindowRect;
      ntfy.bVert        = m_FS.m_bFSVertScroll;
      ntfy.bHorz        = m_FS.m_bFSHorzScroll;
      ntfy.bFirstTime      = m_FS.m_bFirstTime;
      theApp.NotifyPackages (PN_FULL_SCREEN, &ntfy);
      m_FS.m_bFirstTime = FALSE;
      // New layout.
      SetDockState(STATE_FULLSCREEN, MASK_FULLSCREEN);
      ::LockWindowUpdate(NULL);
   }
}


void CMainFrame::OnUpdateFullScreen(CCmdUI* pCmdUI)
{
   // This function handles the UI for both the "Windows.Full Screen"
   // menu item and the Full Screen button.  m_pMenu == NULL detects the
   // button.
#ifndef NO_CMDBARS
        if (CBMenuPopup::IsCBMenuCmdUI(pCmdUI))
        {
                //CBMenuPopup* pMenu = (CBMenuPopup*)pCmdUI->m_pOther ;
                pCmdUI->SetCheck (m_FS.m_bFullScreen);
        }
#else                                           
   if (pCmdUI->m_pMenu)
      pCmdUI->SetCheck (m_FS.m_bFullScreen);
#endif
}


/// CMainFrame::OnGetMinMaxInfo()
//
// When a window gets moved or resized, Windows queries the app via WM_GETMINMAXINFO
// about the max window size.  Since Full Screen mode needs a larger than normal
//  window size, we catch the query here.
/////
void CMainFrame::OnGetMinMaxInfo (MINMAXINFO * pMinMaxInfo)
{
   if (IsFullScreen()) {
      pMinMaxInfo->ptMaxSize.y = m_FS.m_FullScreenWindowRect.Height();
      pMinMaxInfo->ptMaxTrackSize.y = pMinMaxInfo->ptMaxSize.y;
      pMinMaxInfo->ptMaxSize.x = m_FS.m_FullScreenWindowRect.Width();
      pMinMaxInfo->ptMaxTrackSize.x = pMinMaxInfo->ptMaxSize.x;
      }
}

BOOL CMainFrame::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
        static HCURSOR hcRecord = NULL;
        if (theApp.GetRecordState() == CTheApp::RecordOn)
        {
                // If we're recording, show the record cursor.  For better
                //  performance, cache the record cursor in hcRecord
                if (hcRecord == NULL)
                        hcRecord = AfxLoadCursor(IDC_CURSOR_RECORD);
                if (hcRecord != NULL)
                {
                        ::SetCursor(hcRecord);
                        return TRUE;
                }
                else
                        // Can't get record cursor, but we're recording?!
                        ASSERT(FALSE);
        }
        
        // Not recording, so we don't care
        return CMDIFrameWnd::OnSetCursor(pWnd, nHitTest, message);
}


void CMainFrame::CloseWindows( UINT nFilter /*= FILTER_NONE*/ )
{
   // The MDI client is hidden while windows are closed down to prevent
   // lots of ugly redrawing...  The whole area will be repainted when
   // the window is shown again, but that's just one blit.

        m_pWndMDIClient->ShowWindow(SW_HIDE);

        g_AutomationState.SetSaveChanges(FALSE);
        BOOL bUI = g_AutomationState.DisplayUI();
        g_AutomationState.DisableUI();

        // Don't close the project.
        CMDIChildWnd* pMDIChild;
        while ((pMDIChild = theApp.MDITypedGetActive(nFilter)) != NULL)
        {
                // Also close dock manager handled MDI windows, or the dock manager will
                // be out of synch.  These window should do nothing in SaveModified,
                // so we do not risk repeating the save? message box.
                pMDIChild->SendMessage(WM_CLOSE);
        }
        g_AutomationState.Reset() ;

        if( !bUI ) {
			g_AutomationState.DisableUI();
		}
        m_pWndMDIClient->ShowWindow(SW_SHOWNA);
}

void CMainFrame::LockDockState(BOOL bLock)
{
   if ((m_bLockManager && bLock) || (!m_bLockManager && !bLock))
      return;

   m_bLockManager = bLock;
   if (!m_bLockManager)
      SetDockState(m_nManagerStateSave);
}

void CMainFrame::SetDockState(int nState, int nMask /* = 1 */)
{
        // The mask defines which bits are to affected in the state change.
        // A 1 in the mask means take the new state from the nState parameter
        // A 0 in the mask means take the new state from the old state
        //
        nState = (nMask & nState) | (~nMask & m_nManagerState);

        // If the dock state is locked, just save the requested state.
        m_nManagerStateSave = nState;
        if (m_bLockManager)
                return;

        if (m_nManagerState == nState)
                return;

        SaveManager();
        m_nManagerState = nState;

        // Cancel modes before the switch.
        SendMessage(WM_CANCELMODE);
        SushiCancelModes(m_hWnd);

        LockLayout(TRUE); // Don't allow recalc layout during LoadManager.
        LoadManager();
        LockLayout(FALSE);
        m_pManager->ShowManager(TRUE);

        RebuildMenus();

        // The menu bar can be hidden in full screen mode, but not otherwise; special case code here to sort out its
        // close box. Not the ideal place to put this.
        CDockWorker *pWorker=m_pManager->WorkerFromID(MAKEDOCKID(PACKAGE_SUSHI, IDTB_MENUBAR));
        if(     pWorker &&
                pWorker->GetDock()==dpNil && // if it's floating
                pWorker->m_pWnd)                         // defensive coding - should never fail.
        {
                // parent of the worker, when floating, is the CPaletteWnd that is the floating frame.
                CWnd *pWndParent=pWorker->m_pWnd->GetParent();
                if(pWndParent)
                {
                        CMenu*pMenu=pWndParent->GetSystemMenu(FALSE);

                        if(pMenu)
                        {
                                // disable or enable close box
                                if(!IS_STATE_FULLSCREEN(DkGetDockState()))
                                {
                                        pMenu->EnableMenuItem(SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
                                }
                                else
                                {
                                        pMenu->EnableMenuItem(SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
                                }
                        }
                }
        }
}

void CMainFrame::MapDockingCmd(UINT nID, UINT nCmd)
{
   int nNext = m_aDockCmds.GetSize();
   m_aDockCmds.SetAtGrow(nNext++, nCmd);
   m_aDockCmds.SetAtGrow(nNext, nID);
   if (m_pManager != NULL)
      m_pManager->MapCmdToWorker(nCmd, nID);
}

void CMainFrame::MapDockingCmds()
{
   ASSERT_VALID(m_pManager);

   int nCount = m_aDockCmds.GetSize();
   UINT nCmd, nIDWnd;
   for (int i = 0;  i < nCount;)
   {
      nCmd = m_aDockCmds[i++];
      nIDWnd = m_aDockCmds[i++];
      m_pManager->MapCmdToWorker(nCmd, nIDWnd);
   }
}

static char BASED_CODE szLayoutSection[] = "Layout";

BOOL CMainFrame::InitAfterRegistration()
{
   // This function is called once during startup.  It will be called
   // after all packages have registered.

   if (m_lastWindowRect != rectDefault)
   {
      SetWindowPos(NULL, m_lastWindowRect.left, m_lastWindowRect.top,
         m_lastWindowRect.Width(), m_lastWindowRect.Height(),
         SWP_NOACTIVATE | SWP_NOZORDER);
   }

   CVshellPackage* pPackage = (CVshellPackage*) theApp.GetPackage(PACKAGE_SUSHI);
   if (theApp.GetTemplate(CLSID_WorkspaceDocument) != NULL)
      pPackage->SetVisibleMenuItem(ID_PROJ_MRU_FILE1, TRUE);

        // must init this before we rebuild the menus for the very first time
        CDockWorker::s_lpszLayoutSection = szLayoutSection;
    // Initialize menus.
        RebuildMenus();
        InitializeToolsMenu(pPackage);
        InitializeHelpMenu(pPackage);

   // Initialize dock manager info.
   LoadLayout();

   if (!LoadManager())
   {
       m_pManager = new CDockManager;
      if (!m_pManager->Create(this, m_pWndMDIClient))
      {
         delete m_pManager;
         m_pManager = NULL;
         return FALSE;
      }
      MapDockingCmds();

   }

        // Try to get macro recording interfaces
        if (FAILED(theApp.FindInterface(IID_IMacroRecorder, (LPVOID*) &m_pMacroRecorder)) ||
                FAILED(theApp.FindInterface(IID_IRecorderForShell, (LPVOID*) &m_pRecorderForShell)) ||
                m_pMacroRecorder == NULL || m_pRecorderForShell == NULL)
        {
                // All or nothing.  If any recorder interfaces failed to be retrieved,
                //  then act as if recording isn't supported
                m_pMacroRecorder = NULL;
                m_pRecorderForShell = NULL;
        }


   ASSERT(m_pManager != NULL);

   // Set status bar visibility.
   if (!theApp.m_bStatusbar)
      m_statusBar.ShowWindow(SW_HIDE);

    // Create the property sheet.  We need this to load the workspace.
   if (!CreatePropertyBrowser())
      return FALSE;

   // Show everything.
   ShowWindow(theApp.m_nCmdShow);
   if (IsFullScreen())
   {
      m_FS.m_bFullScreen = FALSE;   // Hack!
      OnWindowFullScreen();
   }
   //REVIEW: This needs to be TRUE even if we are hiding the window. 
   // It seems to perform some required initialization.
   m_pManager->ShowManager(TRUE);
   UpdateWindow();

   GetPropertyBrowser()->InitialUpdate(theApp.m_ptPropPage);
   return TRUE;
}

void CMainFrame::InitializeToolsMenu(CVshellPackage* pPackage)
{
   for (int nID = IDM_USERTOOLS_BASE ; nID < IDM_USERTOOLS_LAST ; nID++)
   {
      // To initialize the tools menu at startup, just use the
      // following code for each item:
      //
      //    pPackage->SetVisibleMenuItem(nID, TRUE, "&User tool");
      //
      // The boolean parameter specifies whether the item should appear
      // on the menu bar, while the string parameter is the menu text.
      //
      // You can use the same call anytime after initialization to modify
      // the set of displayed menu items (like when the user brings up the
      // "Tools" dialog to change the available tool commands).
      //
      // The default state is for all IDM_USERTOOLS items to be hidden,
      // so you only need to call SetVisibleMenuItem for the ones which
      // you want to be shown.
      CTool * curTool ;
      if ((curTool = toolList.GetTool(nID-IDM_USERTOOLS_BASE)) != NULL)
         pPackage->SetVisibleMenuItem (nID, TRUE) ;
   }
}

void CMainFrame::InitializeHelpMenu (CVshellPackage* pPackage)
{
   BOOL bState;

   // Tip of the Day
   bState = isTipAvailable();
   ((CPackage*)pPackage)->SetVisibleMenuItem(IDM_HELP_TIPOFTHEDAY, bState);

   // Help.Technical Support
   CString strHelp;
   bState = GetPSSHelpFile(strHelp);
   ((CPackage*)pPackage)->SetVisibleMenuItem(IDM_HELP_MSPROD, bState);

   // Ext Help
   bState = ShowExtHelp() && GetExtHelpFile(strHelp);
   ((CPackage*)pPackage)->SetVisibleMenuItem(IDM_HELP_EXTHELP, bState);
}

void CMainFrame::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
   switch( nHitTest )
   {
      case HTMENU:
         // Make sure the menu is valid.
         if( theApp.m_bMenuDirty )
            RebuildMenus();
         break;
      case HTCAPTION:
      case HTLEFT:
      case HTTOP:
      case HTRIGHT:
      case HTBOTTOM:
      case HTTOPLEFT:
      case HTTOPRIGHT:
      case HTBOTTOMLEFT:
      case HTBOTTOMRIGHT:
      {
         CSlobWnd* pView = (CSlobWnd*)GetActiveFrame()->GetActiveView();
         if( (pView != NULL) && pView->IsKindOf(RUNTIME_CLASS(CSlobWnd)) )
            pView->ObscureSprites();
         break;
      }
   }

   CMDIFrameWnd::OnNcLButtonDown(nHitTest, point);

   EnsureCustomizerActive();
   EnsurePopupActive();
}

void CMainFrame::OnNcLButtonDblClk(UINT nHitTest, CPoint point)
{
   // HACK: We do our own closing of MDI child windows, since Windows
   // only does this if the MDIClient window is the first child in
   // z-order, and our dock painting is uggly if we wait until after
   // the MDIClient.

   if (bControlMenuSelected && nHitTest == HTMENU &&
      theApp.m_dwMenuSelectTime == GetCurrentMessage()->time)
   {
      BOOL bMax = FALSE;
      CMDIChildWnd* pWnd = MDIGetActive(&bMax);
      ASSERT(bMax && pWnd != NULL);

      CMenu* pMenu = pWnd->GetSystemMenu(FALSE);
      if (pMenu != NULL)
      {
         UINT nMenuState = pMenu->GetMenuState(SC_CLOSE, MF_BYCOMMAND);
         if ((nMenuState & (MF_DISABLED | MF_GRAYED)) == 0)
         {
            pWnd->SendMessage(WM_SYSCOMMAND, SC_CLOSE);
            return;
         }
      }
   }

   CMDIFrameWnd::OnNcLButtonDblClk(nHitTest, point);

   EnsureCustomizerActive();
   EnsurePopupActive();
}

void CMainFrame::OnSysCommand(UINT nID, LPARAM lParam)
{
   switch (nID)
   {
      case SC_PREVWINDOW:
      case SC_NEXTWINDOW:
         // Break windows Alt+F6 behavior so as not to give floating toolbars
         // the focus.  This is an obscure feature anyway.

         if (LOWORD(lParam) == VK_F6)
         {
            // Add special handling for modeless dialogs hear if desired.
            return;
         }
         break;

      case SC_MINIMIZE:
         if (m_pManager != NULL)
            m_pManager->ShowPalettes(FALSE);
         SetActiveWindow();   // Take activation from customizer dialog.
         break;

      case SC_KEYMENU:
         // Make sure the menu is valid.
         if (theApp.m_bMenuDirty)
            RebuildMenus();
         break;
      case SC_MOVE:
      case SC_SIZE:
      {
         CSlobWnd* pView = (CSlobWnd*)GetActiveFrame()->GetActiveView();
         if( (pView != NULL) && pView->IsKindOf(RUNTIME_CLASS(CSlobWnd)) )
            pView->ObscureSprites();
         break;
      }
   }

   CMDIFrameWnd::OnSysCommand(nID, lParam);

   switch (nID)
   {
   case SC_RESTORE:
   case SC_MAXIMIZE:
      if (m_pManager != NULL)
         m_pManager->ShowPalettes(TRUE);
      EnsureCustomizerActive();
      break;
   }
}

void CMainFrame::EnsureCustomizerActive()
{
   if (CASBar::s_pCustomizer != NULL && !IsIconic())
   {
      ASSERT(CASBar::s_pCustomizer->m_pDialog != NULL);
      CASBar::s_pCustomizer->m_pDialog->SetActiveWindow();
   }
}

void CMainFrame::EnsurePopupActive()
{
   CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
   if (pDocker != NULL && pDocker->GetDock() == dpNil && !IsIconic())
   {
      ASSERT(pDocker->m_pWnd != NULL);
      pDocker->m_pWnd->SetFocus();
   }
}

void CMainFrame::EnsureViewActive()
{
   // Make sure the focus is in the active view.
   HWND hwndView = theApp.GetActiveView();
   HWND hwndFocus = ::GetFocus();

   if (hwndView != NULL && hwndView != hwndFocus &&
         !::IsChild(hwndView, hwndFocus))
   {
      // Only do this if the view is not a floating window.
      CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
      if (pDocker == NULL || pDocker->GetDock() != dpNil)
         ::SetFocus(hwndView);
   }
}

void CMainFrame::OnWinIniChange(LPCSTR lpszSection)
{
   InitMetrics();
   theApp.m_CPLReg.Update();
   globalData.UpdateSysMetrics();

   CMDIFrameWnd::OnWinIniChange(lpszSection);

   // Can't do this inside UpdateSysMetrics
   theCmdCache.FlushMenuSizes();

        CASBar *pBar=CASBar::s_pMenuBar;
        if(pBar)
        {
                pBar->RecalcLayout();
        }

}

void CMainFrame::OnFontChange ()
{
   POSITION pos = theApp.m_packages.GetHeadPosition();
   while (pos != NULL)
      ((CPackage*)theApp.m_packages.GetNext(pos))->OnFontChange();
}

#ifdef _DEBUG
LRESULT CMainFrame::OnFatalExit(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
   ASSERT(FALSE);
#else
   extern CATCHBUF fatalExitBuf;
   TRACE("VSHELL: fatal exit request received from package %d\n", wParam);
   Throw(fatalExitBuf, 1); // NEVER PASS 0!
#endif
   return 0;
}
#endif

BOOL CMainFrame::OnDockWindowShow(UINT nID)
{
   CObArray aWorkers;
   m_pManager->ArrayOfType(dtEmbeddedToolbar, &aWorkers, TRUE, TRUE);

   int nIndex = nID - IDM_DOCKSHOW_BASE;
   ASSERT(nIndex < aWorkers.GetSize());

   CDockWorker* pDocker = (CDockWorker*) aWorkers[nIndex];
   pDocker->ShowWindow(!pDocker->IsVisible());

   return TRUE;
}

// Now that we have the command cache, we can no longer rely on MFC to 
// sort out the prompt strings for MRU menus for us. martynl 13May96
void CMainFrame::GetMessageString(UINT nID, CString& rMessage) const
{
   LPCTSTR szCommand;
   if (nID >= ID_FILE_MRU_FIRST && nID <= ID_FILE_MRU_LAST)
   {
           nID = ID_FILE_MRU_FIRST;
   }

   if (nID >= ID_PROJ_MRU_FIRST && nID <= ID_PROJ_MRU_LAST)
   {
           nID = ID_PROJ_MRU_FIRST;
   }

   if (theCmdCache.GetCommandString(nID, STRING_PROMPT, &szCommand))
   {
      rMessage = szCommand;
   }
   else
           CFrameWnd::GetMessageString(nID, rMessage);
}

void CTheApp::SetEmptyToolTip(NMHDR* pNMHDR)
{
   if (pNMHDR->code == TTN_NEEDTEXTA)
      ((TOOLTIPTEXTA*) pNMHDR)->szText[0] = '\0';
   else
   {
      ASSERT(pNMHDR->code == TTN_NEEDTEXTW);
      ((TOOLTIPTEXTW*) pNMHDR)->szText[0] = L'\0';
   }
}

void CTheApp::AddKeyToToolTip(CString& rstrTextCmd, UINT nID, WORD flagsCmdCache, LPCTSTR szKeyIn)
{
   if (!theApp.m_bToolTipKeys)
      return;

   CString strKey;
   if (szKeyIn == NULL)
   {
          UINT nIDKey = nID;
          if (flagsCmdCache & CT_DYNAMIC_CMD_STRING)
          {
                  // get possible alternate ID for key string from package (useful for toolbar hwnds like findctrl bobz)
                        CTE* pCTE = theCmdCache.GetCommandEntry(nID);
                        ASSERT(pCTE->flags & CT_DYNAMIC_CMD_STRING); 
                        ASSERT(pCTE->GetPack() != NULL);
                        ASSERT(pCTE->GetPack()->PacketID() != PACKET_SHARED);
                        CPackage *pPackage = pCTE->GetPack()->GetPackage();
                        ASSERT(pPackage != NULL);

                        nIDKey = pPackage->CmdIDForToolTipKey(nID);
          }

      if (!GetCmdKeyString(nIDKey, strKey))
         return;
   }
   else
      strKey = szKeyIn;

   rstrTextCmd += " (";
   rstrTextCmd += strKey;
   rstrTextCmd += ")";
}

// this extracts the tooltip text from the resource id

// When this routine was modified to use the command cache, a subtle error
// was introduced. Specifically, the new code assumed that, if szKeyIn was NULL, 
// then the command being 'tipped' was from the command table rather than from
// a loaded resource string. This caused Orion bug #1538, as the grid window
// contains one control which is tipped using this function, but which has no
// keyboard shortcut (new)

// To fix this, we allow szKeyIn to take a third value:
// NULL - as before, implies no key, so look in cmd cache
// nonnull:
//              ptr to empty string: no key, but don't look in cmd cache
//      ptr to non-empty string: use cmd cache, but add the specified key to it.

// martynl 09Apr96

BOOL CTheApp::HandleToolTipText(UINT, NMHDR* pNMHDR, LRESULT* pResult, LPCTSTR szKeyIn)
{
   ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);

   // suppress tip if disabled
   if (!theApp.m_bToolTips)
   {
      SetEmptyToolTip(pNMHDR);
        
      *pResult = 0;
      return TRUE;
   }

   WORD wFlagsCmdCache = CT_NONE;  // used to pass flags from cmdcache to AddKeyToToolTip

   // ASSUMEs top level routing frame already called with GetRoutingFrame to handle the message, if desired

   // need to handle both ANSI and UNICODE versions of the message
   TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
   TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;
   TCHAR szFullText[256];
   CString strTipText;
   UINT nIDFrom = pNMHDR->idFrom;
   if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
      pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
   {
      // idFrom is actually the HWND of the tool
      nIDFrom = ((UINT)(WORD)::GetDlgCtrlID((HWND)nIDFrom));
   }

        if (nIDFrom == 0) // will be zero on a separator
        {
                CTheApp::SetEmptyToolTip(pNMHDR);
                *pResult = 0;
                return TRUE;
        }
        else
        {
                if (szKeyIn == NULL)
                {
                        LPCTSTR szCommand;

                        // Note: do not hold onto the return string of GetCommandString, copy immediately.
                        if (theCmdCache.GetCommandString(nIDFrom, STRING_TIP, &szCommand, &wFlagsCmdCache) &&
                                szCommand != NULL && *szCommand != '\0')
                        {
                                strTipText = szCommand;
                        }
                        else
                        {
                                if (theCmdCache.GetCommandString(nIDFrom, STRING_COMMAND, &szCommand, &wFlagsCmdCache))
                                {
                                   TRACE0("Using menu help text in place of missing tooltip text");
                                   strTipText = szCommand;
                                }
                                else
                                {
                                        CTheApp::SetEmptyToolTip(pNMHDR);
                                        *pResult = 0;
                                        return TRUE;
                                }
                        }
                }
                else
                {
                         AfxLoadString(nIDFrom, szFullText);
                                // this is the command id, not the button index
                         AfxExtractSubString(strTipText, szFullText, 1, '\n');
                }
        }

      // never pass on the empty string special value
   LPCTSTR szPassKey = szKeyIn;
   if (szPassKey != NULL &&  *szPassKey == '\0')
   {
           szPassKey=NULL;
   }

   AddKeyToToolTip(strTipText, nIDFrom, wFlagsCmdCache, szPassKey);


#ifndef _UNICODE
   if (pNMHDR->code == TTN_NEEDTEXTA)
      lstrcpyn(pTTTA->szText, strTipText, _countof(pTTTA->szText));
   else
      _mbstowcsz(pTTTW->szText, strTipText, _countof(pTTTW->szText));
#else
   if (pNMHDR->code == TTN_NEEDTEXTA)
      _wcstombsz(pTTTA->szText, strTipText, _countof(pTTTA->szText));
   else
      lstrcpyn(pTTTW->szText, strTipText, _countof(pTTTW->szText));
#endif

   *pResult = 0;

   return TRUE;    // message was handled
}


BOOL CMainFrame::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);
	CASBar::ForceReleaseCapture();
	return CTheApp::HandleToolTipText(nID, pNMHDR, pResult);
}

void CMainFrame::OnWindowListDocs()
{
	CHaltRecording haltrec; // DS96 #14956 [CFlaat]: we'll just turn off recording here, as there are too many gremlins

	COpenDocsDlg dlg;
	dlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// Application Palette Management

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)
{
   SendMessageToDescendants(WM_PALETTECHANGED,
      (WPARAM)pFocusWnd->GetSafeHwnd(), 0, TRUE, TRUE);
}

BOOL CMainFrame::OnQueryNewPalette()
{
// BOOL bRet = FALSE;
   CMDIChildWnd* pFrame = MDIGetActive();
   if (pFrame != NULL)
   {
      /*bRet =*/ pFrame->SendMessageToDescendants(WM_QUERYNEWPALETTE, 0, 0,
         TRUE, TRUE);

      OnPaletteChanged(pFrame);
   }

// return bRet;
   return TRUE;
}

////////////////////////////////////////////////////////////////////////////


void CMainFrame::OnEndSession(BOOL bEnding)
{
    if (bEnding)
	{
		// We need to save all settings here, this is our last chance.
		OnClose();
	}
}

void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
   CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
   if (pDocker == NULL)
      CMDIFrameWnd::OnSetFocus(pOldWnd);
   else if (pDocker->GetDock() != dpNil)
      pDocker->m_pWnd->SetFocus();
}

void CMainFrame::OnActivate(UINT nState, CWnd* pOtherWnd, BOOL bMinimized)
{
#ifdef _DEBUG
   ASSERT(!bQuitting || nState == WA_INACTIVE);
   bQuitting = FALSE;   // Stop us from showing continuous stream of asserts.
#endif

   CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
   CSheetWnd * pPropSheet = GetPropertyBrowser();

    if (nState != WA_INACTIVE && pPropSheet != NULL && pPropSheet->IsActive())
        pPropSheet->SetActive(FALSE);

        if (pDocker == NULL || nState == WA_INACTIVE || bMinimized)
          CMDIFrameWnd::OnActivate(nState, pOtherWnd, bMinimized);
        else if (pDocker->GetDock() != dpNil)
        {
          // CMDIFrameWnd::OnActivate sets focus to a view.
          CWnd::OnActivate(nState, pOtherWnd, bMinimized);
          pDocker->m_pWnd->SetFocus();
        }

        ASSERT(GetComponentMgr() != NULL);
        if (GetComponentMgr() != NULL && nState != WA_INACTIVE)
                GetComponentMgr()->FOnComponentActivate(GetComponentID());
}

void CMainFrame::OnTimer(UINT nTimerID)
{
   switch(nTimerID)
   {
#ifdef _AUTOSAVE
   case IDT_AUTOSAVE:
      //BLOCK:
      {
         POSITION pos;

         // Don't start a new tick cycle if we're still in one.
         if (gAutosaver.InTick())
            return;
         // Send and autosave tick message to each package
         gAutosaver.EnterTick();
         pos = theApp.m_packages.GetHeadPosition();
         while (pos != NULL)
         {
            CPackage* pGroup = (CPackage*)theApp.m_packages.GetNext(pos);
// If this is ever enabled we need to use a CPackage virtual and PKS_ flag instead.
//          pGroup->SendMessage(WM_ONAUTOSAVETICK, 0, (LPARAM) &gAutosaver);
         }
         gAutosaver.ExitTick();
      }
      break;
#endif

   case IDT_WINDOW_FLASH:
      FlashWindow(TRUE);
      break;

   // Keyboard-chord timers
   case 200: // First timer, 1 sec after keyboard chord initiated
      {
         CString strKey;
         if (CKeymap::c_bImplyAltForNextKey)
            strKey = CKeymap::c_szAlt;
         else
            CKeymap::GetKeyName(CKeymap::c_kcChordPrefix, 0, strKey);
         SetPrompt(strKey);
         KillTimer(200);
         SetTimer(201, 4 * 1000, NULL);
      }
      break;

   case 201: // Second timer, we're giving up on the chord
      CKeymap::CancelChord();
      break;

   case IDT_FILE_CHANGE:
      if( IsWindowEnabled() && theApp.m_fVCPPIsActive && !IsIconic() )
      {
         while( m_plFileChange.GetCount() > 0 )
         {
            FCItem* pFCItem = (FCItem*)m_plFileChange.RemoveHead();
            POSITION posTemplate = theApp.GetFirstDocTemplatePosition();
            while( posTemplate != NULL )
            {
               CPartTemplate* pTemplate = (CPartTemplate*)theApp.GetNextDocTemplate(posTemplate);
               POSITION posDoc = pTemplate->GetFirstDocPosition();
               while( posDoc != NULL )
               {
                  CPartDoc* pDoc = (CPartDoc*)pTemplate->GetNextDoc(posDoc);
                  // the wPackage parameter has been stored in _pbUser1
                  pDoc->OnFileChange((int)pFCItem->_pvUser1, pFCItem);
               }
            }
            delete pFCItem;   // created by original FileChange callback
         }
         KillTimer(IDT_FILE_CHANGE);
      }
      break;

   default:
      CMDIFrameWnd::OnTimer(nTimerID);
   }
   return;
}

void CMainFrame::OnSysColorChange()
{
        extern BOOL bEnable3dControls;
        
        globalData.UpdateSysColors();
        
        POSITION pos = theApp.m_packages.GetHeadPosition();
        while (pos != NULL)
                ((CPackage*)theApp.m_packages.GetNext(pos))->OnColorChange();
        
    ResetSysBrushes();
        
        // So toolbars will update correctly, we unload all the package's existing bitmaps. New ones will be demand loaded
        // as appropriate.
        theApp.UnloadPackageBitmaps();   

        if (!bEnable3dControls)
                theApp.SetDialogBkColor();
        
        CMDIFrameWnd::OnSysColorChange();
        
        m_pManager->SysColorChange(); // Dock managed floating windows.

        CBMenuPopup::SysColorChange();
}

void CMainFrame::InitKeymap()
{
   ASSERT(m_hAccelTable != NULL);
   m_keymap.LoadAccelerators(m_hAccelTable);
   DestroyAcceleratorTable(m_hAccelTable);
   m_hAccelTable = NULL;
   VERIFY( m_keymap.m_strName.LoadString( IDS_MAIN ) );
}

void CMainFrame::OnUpdateNewWindow(CCmdUI* pCmdUI)
{
   // Default is to leave this disabled...  If you want your MDI child
   // to be clone-able, override this in that class...

   pCmdUI->Enable(FALSE);
}

void CMainFrame::OnNewWindow(void)
{
        // we override this only to hook in for recording purposes

        // record it
        GetShellRec().EmitMethodCall(seNewWin);

        // and delegate to our base class
        CMDIFrameWnd::OnWindowNew();
}

///////////////////////////////////////////////////////////////////////////////
// Window validation handling.
//

LRESULT CMainFrame::OnSetAppValidate(WPARAM wParam, LPARAM)
{
   theApp.m_hwndValidate = (HWND) wParam;

   return 0L;
}

static int cyIconBase;

CMDIClientValidator::CMDIClientValidator()
{
   m_cyLast = 0;

   cyIconBase = theApp.m_bWin4 ? 0 : 42;
}

WNDPROC* CMDIClientValidator::GetSuperWndProcAddr()
{
   static WNDPROC NEAR pfnSuper;
   return &pfnSuper;
}

void CMDIClientValidator::PostNcDestroy()
{
   delete this;
}

BEGIN_MESSAGE_MAP(CMDIClientValidator, CWnd)
   ON_WM_PARENTNOTIFY()
   ON_WM_SIZE()
   ON_WM_RBUTTONUP()
END_MESSAGE_MAP()


void CMDIClientValidator::OnParentNotify(UINT message, LPARAM lParam)
{
        if (theApp.m_hwndValidate != NULL &&
                ::SendMessage(theApp.m_hwndValidate, WM_ISERROR, 0, 0L))
        {
                return;
        }
        else if (GetCapture() == NULL &&
                (message == WM_LBUTTONDOWN || message == WM_RBUTTONDOWN))
        {
                CPoint pt(::GetMessagePos());
                CWnd* pWndActive = ((CMDIFrameWnd*) GetParent())->MDIGetActive();
                CWnd* pWndNotify = WindowFromPoint(pt);  
                // Note that in some stress cases pWndNotify can be NULL!
                if(pWndNotify != NULL)
                {
                        if (pWndActive != NULL &&
                                (pWndActive == pWndNotify || pWndActive->IsChild(pWndNotify)))
                        {
                                if (!pWndActive->IsChild(GetFocus()))
                                pWndActive->SetFocus();
                        }
                        else if (message == WM_RBUTTONDOWN)
                        {
                                while (	pWndNotify!=NULL &&
										pWndNotify != this &&
										!pWndNotify->IsKindOf(RUNTIME_CLASS(CPartFrame)))
                                pWndNotify = pWndNotify->GetParent();

                                if (pWndNotify!=NULL && 
									pWndNotify != this)
                                        ((CPartFrame*) pWndNotify)->MDIActivate();
                        }
                }
        }

        Default();
}

void CMDIClientValidator::OnSize(UINT nType, int, int cy)
{
   Default();

   if (nType != SIZE_RESTORED || cy == m_cyLast)
      return;

   // Move all the icons to try to keep them on screen.

   CRect rectIcon;
   CSize sizeBaseOffset(0, cy - m_cyLast);
   int cyIcon;

   for (CWnd* pWndNext = ((CMDIFrameWnd*) GetParent())->MDIGetActive();
      pWndNext != NULL; pWndNext = pWndNext->GetWindow(GW_HWNDNEXT))
   {
      if(!IsValidMDICycleMember(pWndNext) || !pWndNext->IsIconic())
         continue;

      pWndNext->GetWindowRect(rectIcon);
      ScreenToClient(rectIcon);

      cyIcon = cy - (rectIcon.bottom + cyIconBase);     // magic number.
      CSize sizeOffset = sizeBaseOffset;
      sizeOffset.cy = max(sizeOffset.cy, -rectIcon.top);        // restrict above.
      sizeOffset.cy = min(sizeOffset.cy, cyIcon);       // retrict below.
      rectIcon.OffsetRect(sizeOffset);

      pWndNext->MoveWindow(rectIcon);
      pWndNext->ShowWindow(SW_SHOWNA); // causes text to move.
   }

   m_cyLast = cy;
}

void CMDIClientValidator::OnRButtonUp(UINT nFlags, CPoint pt)
{
	// cause the dock manager to show its menu
	CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();
	if(pFrame)
	{
		if(pFrame->m_pManager)
		{
			ClientToScreen(&pt);
			pFrame->m_pManager->ShowMenu(pt);
		}
	}
}

BOOL DkEnsureHidden(UINT nID)
{
   CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
   if (pManager == NULL)
      return FALSE;

   CDockWorker* pWorker = pManager->WorkerFromID(nID);
   if (pWorker == NULL)
      return FALSE;

   if (!pWorker->IsVisible())
      return FALSE;

   pWorker->ShowWindow(FALSE);
   return TRUE;
}

void CMainFrame::OnCancel()
{
   // Hide the property window
   if (IsPropertyBrowserVisible())
   {
      ClosePropertyBrowser();
      return;
   }
   
   // Hide the book window
   if (DkEnsureHidden(MAKEDOCKID(PACKAGE_IV, IDDW_IV)))
      return;

   // Hide the output window
   if (DkEnsureHidden(MAKEDOCKID(PACKAGE_VCPP, IDDW_OUTPUT)))
      return;

   // End full screen mode
   if (IsFullScreen())
   {
      OnWindowFullScreen();
      return;
   }

   MessageBeep(0);
}

void CMainFrame::CmdGoto()
{
   DoGoToDialog(IDD_GOTODIALOG, NULL);
}

/* OnFileChange
 * Called when a FileChange callback does a PostMessage (because the callback
 * is in a different thread).
 * wPackage is a convenient way to narrow down the search, based on which callback called us.
 * lpFCItem is a copy of the FCItem that was passed to the original callback.
 * Note that none of the actual work is done here.  Rather a list of files is
 * built up, and handled when a timer is reached.
 */
LRESULT CMainFrame::OnFileChange(WPARAM wPackage, LPARAM lpFCItem)
{
   ASSERT( lpFCItem != NULL );

   // put off any notifications until our app is active again
   ((FCItem*)lpFCItem)->_pvUser1 = (void*)wPackage;     // HACK! have to store this somewhere
   m_plFileChange.AddTail((FCItem*)lpFCItem);

   if( theApp.m_fVCPPIsActive && !IsIconic() )
      SetTimer(IDT_FILE_CHANGE, 100, NULL);  // set/reset timer for very soon
   else
      SetTimer(IDT_FILE_CHANGE, 1000, NULL); // set/reset timer for a second

   // the FCItem will be deleted in OnTimer
   return 0;
}

// ensure that everyone gets a chance to adapt to a change in toolbar size
LRESULT CMainFrame::OnBarSizeChanging(WPARAM wParam, LPARAM lParam)
{
        SendMessageToDescendants(DSM_BARSIZECHANGING,wParam, lParam, TRUE, FALSE); 

        return 0;
}

void CMainFrame::AddIPCompFrameHook(CIPCompFrameHook * pHook)
{
        ASSERT(pHook != NULL);
        m_plIPCompFrameHook.AddHead(pHook);
}

void CMainFrame::RemoveIPCompFrameHook(CIPCompFrameHook * pHook)
{
        ASSERT(pHook != NULL);
        POSITION pos = m_plIPCompFrameHook.Find(pHook);

        if (pos != NULL)
        {
                m_plIPCompFrameHook.RemoveAt(pos);
        }
}

BOOL CMainFrame::SetComponentManager(IMsoComponentManager * pCmpMgr)
{
        ASSERT(m_pIPCmpMainFrm); 
        return m_pIPCmpMainFrm->SetComponentManager(pCmpMgr); 
}

IMsoComponentManager * CMainFrame::GetComponentMgr()
{
        if (m_pIPCmpMainFrm != NULL)
        {
                return  m_pIPCmpMainFrm->m_srpMsoCompMgr ;
        }
        else
        {
                return NULL ;
        }
        // INTEGRATED BUILD FIX: The new compiler is very picky about the comparison operator.
        // The constructor for the OleRef was getting called and so was the destructor, so this
        // wasn't working. 29 Jul 96 DaleRo
        //return (m_pIPCmpMainFrm ? m_pIPCmpMainFrm->m_srpMsoCompMgr : (IMsoComponentManager *)NULL);
}
   
DWORD CMainFrame::GetComponentID() 
{
        return (m_pIPCmpMainFrm ? m_pIPCmpMainFrm->m_dwComponentID : 0);
}       
        
void CMainFrame::BeginModalState() 
{
        // if we are registered with the component manager and we are the one
        // initiating the modal state (i.e. we are not being currently called back
        // by the ComponentManager via IMsoComponent::OnEnterState -- 
        // m_fInOnEnterState is used as a guard for OnEnterState method) then inform
        // the ComponentManager of the modality change. the ComponentManger
        // will NOT call us back via IMsoComponent::OnEnterState implemented
        // on our CMainFrame because we are the component making the call. thus we
        // need to continue and call CMDIFrameWnd::BeginModalState ourselves.
        if (!m_fInOnEnterState && m_pIPCmpMainFrm && m_pIPCmpMainFrm->m_srpMsoCompMgr)
        {
                m_pIPCmpMainFrm->m_srpMsoCompMgr->OnComponentEnterState(
                                m_pIPCmpMainFrm->m_dwComponentID, msocstateModal,
                                msoccontextAll, 0, NULL, NULL);
        } 

        CMDIFrameWnd::BeginModalState();
}    
   
void CMainFrame::EndModalState() 
{
        // if we are registered with the component manager and we are the one
        // initiating the modal state (i.e. we are not being currently called back
        // by the ComponentManager via IMsoComponent::OnEnterState -- 
        // m_fInOnEnterState is used as a guard for OnEnterState method) then inform
        // the ComponentManager of the modality change. the ComponentManger
        // will NOT call us back via IMsoComponent::OnEnterState implemented
        // on our CMainFrame because we are the component making the call. thus we
        // need to continue and call CMDIFrameWnd::BeginModalState ourselves.
        if (!m_fInOnEnterState && m_pIPCmpMainFrm && m_pIPCmpMainFrm->m_srpMsoCompMgr)
        {
                m_pIPCmpMainFrm->m_srpMsoCompMgr->FOnComponentExitState(
                                m_pIPCmpMainFrm->m_dwComponentID, msocstateModal,
                                msoccontextAll, 0, NULL);
        }

        CMDIFrameWnd::EndModalState();
}       

/////////////////////////////////////////////////////////////////////////////
// Implementation of IMsoComponent

BEGIN_INTERFACE_MAP(CIPCompMainFrame, CCmdTarget)
        INTERFACE_PART(CIPCompMainFrame, IID_IMsoComponent, MsoComponent)
END_INTERFACE_MAP()

CIPCompMainFrame::CIPCompMainFrame()
{
        m_dwComponentID = 0;
}

STDMETHODIMP_(BOOL) CIPCompMainFrame::XMsoComponent::FPreTranslateMessage(MSG *pMsg)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        return theApp.PreTranslateMessage(pMsg);
}

STDMETHODIMP_(void) CIPCompMainFrame::XMsoComponent::OnEnterState(ULONG uStateId, BOOL fEnter)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        CMainFrame * pMainFrm = (CMainFrame *)AfxGetMainWnd();
        ASSERT(pMainFrm->IsKindOf(RUNTIME_CLASS(CMainFrame)));
        if (uStateId == msocstateModal)
        {
                // All the action for modality management happens when our MainFrame window
                // received a WM_ENABLE message (or CMainFrame::OnEnable is called).
                // if the modality change is initiated by another component in our 
                // process, then our MainFrame's IMsoComponent::OnEnterState method 
                // is called. in this situation we do not want to call back to the 
                // ComponentManager in CMainFrame::BeginModalState which is called by
				// CFrameWnd::OnEnable. the m_fInOnEnterState flag is used to guard this call.
				//
				// Note that we need to check the actual modal state, since we get
				// notified when any component leaves the modal state, but should
				// not re-enable our window until all components have left the modal
				// state.

			BOOL fEnable = !fEnter;

			if (pThis->m_srpMsoCompMgr != NULL)
			{
				// Dont enable the window unless all components have left the Modal state.
				fEnable = fEnable && !pThis->m_srpMsoCompMgr->FInState(msocstateModal, NULL);
			}

            pMainFrm->m_fInOnEnterState = TRUE; // guard against calling ComponentManager
				pMainFrm->EnableWindow(fEnable);
            pMainFrm->m_fInOnEnterState = FALSE;
        }

#ifndef _IPC_DOCUMENTS_DISABLED
        if (!pMainFrm->m_plIPCompFrameHook.IsEmpty())
        {
                CIPCompFrameHook * pHook = (CIPCompFrameHook *)pMainFrm->m_plIPCompFrameHook.GetHead();
                if (pHook != NULL)
                {
                        ASSERT(pHook->m_pActiveItem != NULL);
                        CView * pHookView = pHook->m_pActiveItem->GetActiveView();
                        // notify the active Frame hook, which is associated with the active child window, 
                        // in order to notify the current UI active object within that child window.
                        if (pHookView != NULL && ((HWND)pMainFrm->GetActiveFrame() == (HWND)pHookView->GetParentFrame()))
                                pHook->OnActiveEnableModelss(uStateId, fEnter);

                        if (uStateId != msocstateModal)
                        {
                                // walk thru the list, and notify all inplace components
                                POSITION pos = pMainFrm->m_plIPCompFrameHook.GetHeadPosition();
                                while (pos != NULL)
                                {
                                        // since the active frame hook is always at the head of the list, it will get the 
                                        // the first crack
                                        pHook = (CIPCompFrameHook *)pMainFrm->m_plIPCompFrameHook.GetNext(pos);
                                        pHook->OnEnterState(uStateId, fEnter);
                                }
                        }
                }
        }
#endif
}               

STDMETHODIMP_(void) CIPCompMainFrame::XMsoComponent::OnAppActivate(BOOL fActivate, DWORD dwOtherThreadID)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        CMainFrame * pMainFrm = (CMainFrame *)AfxGetMainWnd();
        ASSERT(pMainFrm->IsKindOf(RUNTIME_CLASS(CMainFrame)));

#ifndef _IPC_DOCUMENTS_DISABLED
        // notify the active Frame hook only (which should be associated with the active child window)
        if (!pMainFrm->m_plIPCompFrameHook.IsEmpty())
        {
                CIPCompFrameHook * pHook = (CIPCompFrameHook *)pMainFrm->m_plIPCompFrameHook.GetHead();
                ASSERT(pHook);
                ASSERT(pHook->m_pActiveItem != NULL);
                CView * pHookView = pHook->m_pActiveItem->GetActiveView();
                if (pHookView != NULL && ((HWND)pMainFrm->GetActiveFrame() == (HWND)pHookView->GetParentFrame()))
                        pHook->OnFrameActivate(fActivate);
        }
#endif
}

STDMETHODIMP_(void) CIPCompMainFrame::XMsoComponent::OnLoseActivation()
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
    // we don't have anything to do here.
}

STDMETHODIMP_(void) CIPCompMainFrame::XMsoComponent::OnActivationChange(IMsoComponent *pic, BOOL fSameComponent,
                                                const MSOCRINFO *pcrinfo, BOOL fHostIsActivating,
                                                const MSOCHOSTINFO *pchostinfo, DWORD dwReserved)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
    // we don't have anything to do here.
}

#ifdef METER_IDLE_TIME
// Let's gather some interesting statistics on idle time processing
extern BOOL s_bIdleTime;
extern CStringList g_strlstPkgsLoaded;
DWORD g_dwIdlePackageTime[40];
DWORD g_IdleProcessingTime;
int g_idxIdlePackage;

BOOL MeteredOnIdle(LONG lIdleCount)
{
        BOOL fRetVal;
        static FILE *outfile = NULL;
        static int iPkgCount = 0;               // Count of packages which want idle time
        DWORD dwTotalTime;

        // Fastest in/out if not requesting logging
        if (!s_bIdleTime)
                return (theApp.OnIdle(lIdleCount));

        g_idxIdlePackage = 0;

        dwTotalTime = ::GetTickCount();
        fRetVal = theApp.OnIdle(lIdleCount);
        dwTotalTime = ::GetTickCount() - dwTotalTime;

        if (!outfile)
        {
                if (!(outfile = fopen("idletime.log", "w")))
                {                       // Should never happen - but don't blow up
                        s_bIdleTime = 0;
                        return fRetVal;
                }
                // Write a header
                fprintf(outfile, "Count");

                POSITION pos = theApp.m_packages.GetHeadPosition();
                int iPkgIndex = 0;
                while (pos != NULL)
                {
                        CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
                        if ((pPackage->m_flags & PKS_IDLE)!= 0)
                        {
                                ++iPkgCount;
                                fprintf(outfile, "\t%s",
                                        (LPCTSTR)g_strlstPkgsLoaded.GetAt(g_strlstPkgsLoaded.FindIndex(iPkgIndex-1)));
                        }
                        iPkgIndex++;
                }
                fprintf(outfile, "\tShell\tTotal\n");
        }
        if (dwTotalTime)
        {       // Only output records which show some nonzero data points
                fprintf(outfile, "%d", lIdleCount);
                for (int idx = 0; idx < iPkgCount; idx++)
                        fprintf(outfile, "\t%d", g_dwIdlePackageTime[idx]);
                fprintf(outfile, "\t%d\t%d\n", g_IdleProcessingTime, dwTotalTime);
        }
        return fRetVal;
}
#else   // !METER_IDLE_TIME
#define MeteredOnIdle(x) (theApp.OnIdle(x))
#endif  // !METER_IDLE_TIME

STDMETHODIMP_(BOOL) CIPCompMainFrame::XMsoComponent::FDoIdle(DWORD grfidlef)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        ASSERT(pThis->m_srpMsoCompMgr != NULL);
        
        BOOL fMore = FALSE;
        
        LONG lIdleCount = 0;
        CMainFrame * pMainFrm = (CMainFrame *)AfxGetMainWnd();
        ASSERT(pMainFrm->IsKindOf(RUNTIME_CLASS(CMainFrame)));

        if (grfidlef == msoidlefNonPeriodic || grfidlef == msoidlefPriority)
        {
                while (lIdleCount <= PRE_MFC_IDLE_PROCESSING_COUNT)
                {
                        MeteredOnIdle(lIdleCount++);
                        if (!pThis->m_srpMsoCompMgr->FContinueIdle())
                                return TRUE;
                }
        }
        
#ifndef _IPC_DOCUMENTS_DISABLED
        // go thru all the components
        POSITION pos = pMainFrm->m_plIPCompFrameHook.GetHeadPosition();
        CIPCompFrameHook * pHook = NULL;
        while (pos != NULL)
        {
                pHook = (CIPCompFrameHook *)pMainFrm->m_plIPCompFrameHook.GetNext(pos);
                fMore |= pHook->FDoIdle(grfidlef);
                if (!pThis->m_srpMsoCompMgr->FContinueIdle())
                        return TRUE;
        }
#endif

        if (grfidlef == msoidlefNonPeriodic || grfidlef == msoidlefPriority)
        {
                while (fMore |= MeteredOnIdle(lIdleCount))
                {
                        if (!pThis->m_srpMsoCompMgr->FContinueIdle())
                                return TRUE;
                                
                        lIdleCount++;
                }
        }
        
        return fMore;
}
                                                        

STDMETHODIMP_(BOOL) CIPCompMainFrame::XMsoComponent::FContinueMessageLoop(
                                                                                                                ULONG /*uReason*/,
                                                                                                                void* /*pvLoopData*/,
                                                                                                                MSG* /*pMsgPeeked*/)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
    // The MDI frame window never pushes a message loop.
    //
    return TRUE;
}

STDMETHODIMP_(BOOL) CIPCompMainFrame::XMsoComponent::FQueryTerminate(BOOL fPromptUser)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        BOOL fRet = TRUE;
        CIPCompFrameHook * pHook = NULL;
        
        CMainFrame * pMainFrm = (CMainFrame *)AfxGetMainWnd();
        ASSERT(pMainFrm->IsKindOf(RUNTIME_CLASS(CMainFrame)));
        
#ifndef _IPC_DOCUMENTS_DISABLED
        POSITION pos = pMainFrm->m_plIPCompFrameHook.GetHeadPosition();
        while (pos != NULL && fRet)
        {
                // since the active frame hook is always at the head of the list, it will get the 
                // the first crack
                pHook = (CIPCompFrameHook *)pMainFrm->m_plIPCompFrameHook.GetNext(pos);
                fRet = pHook->FQueryClose(fPromptUser);
        }
#endif
        
        return fRet;
}

STDMETHODIMP_(void) CIPCompMainFrame::XMsoComponent::Terminate()
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        pThis->ReleaseComponentManager();
        ASSERT(pThis->m_srpMsoCompMgr == NULL);
}

STDMETHODIMP_(HWND) CIPCompMainFrame::XMsoComponent::HwndGetWindow(DWORD dwWhich, DWORD dwReserved)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)

        HWND    hwnd = NULL;

        switch (dwWhich)
        {
                /* MDI Apps should return the MDI frame (not MDI client) or App frame
                        window, and SDI Apps should return the frame window which hosts the
                        component. Basically it should be the topmost window which owns the
                        component. For a toolbar set this will be the toplevel owner of
                        TBS::m_hwnd. */
                case msocWindowFrameToplevel:
                        // fall thru
                        
                /* This is the window which owns the component. It could be same as
                        the window obtained by msocWindowFrameTopLevel or be an owned window
                        of that window. For a toolbar set this will be TBS::m_hwnd. */
                case msocWindowFrameOwner:
                        // fall thru
                        
                /* This is the "main" window of the component (if it has one). */
                case msocWindowComponent:
                        // fall thru
                
                /* Caller wishes to display a dialog to be parented by the component.
                        Component should return a window suitable for use as the dialog's
                        owner window. */  
                case msocWindowDlgOwner:
                {
                        CMainFrame * pMainFrm = (CMainFrame *)AfxGetMainWnd();
                        ASSERT(pMainFrm->IsKindOf(RUNTIME_CLASS(CMainFrame)));
                        hwnd = pMainFrm->GetSafeHwnd();
                        break;
                }

                // no default case (NULL is default behavior which is already handled)
        }

        return hwnd;
}

STDMETHODIMP_(BOOL) CIPCompMainFrame::XMsoComponent::FDebugMessage(HMSOINST hinst, UINT message,
                                                                                        WPARAM wParam, LPARAM lParam)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        return TRUE;
}

STDMETHODIMP_(ULONG) CIPCompMainFrame::XMsoComponent::AddRef()
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CIPCompMainFrame::XMsoComponent::Release()
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        return pThis->ExternalRelease();
}

STDMETHODIMP CIPCompMainFrame::XMsoComponent::QueryInterface(REFIID riid, void **ppvObj)
{
        METHOD_PROLOGUE(CIPCompMainFrame, MsoComponent)
        return pThis->ExternalQueryInterface(&riid, ppvObj);
}

BOOL CIPCompMainFrame::SetComponentManager(IMsoComponentManager * pMsoCompMgr)
{
    MSOCRINFO crinfo;

        ReleaseComponentManager();
        ASSERT(m_srpMsoCompMgr == NULL);
        BOOL fSuccess = TRUE;
        
        if (pMsoCompMgr)
        {
                m_srpMsoCompMgr = pMsoCompMgr;
                m_srpMsoCompMgr->AddRef();

                crinfo.cbSize = sizeof( crinfo );
        crinfo.grfcrf = msocrfNeedIdleTime         |
                                                msocrfNeedPeriodicIdleTime |
                                                msocrfPreTranslateAll;
        crinfo.grfcadvf = msocadvfModal         |
                          msocadvfRedrawOff     |
                          msocadvfWarningsOff;
        crinfo.uIdleTimeInterval = 1000;

                if(!m_srpMsoCompMgr->FRegisterComponent(&m_xMsoComponent,
                                                                                                &crinfo,
                                                                                                &m_dwComponentID))
                {
                        fSuccess = FALSE;
                }
        }

        return fSuccess;
}

void CIPCompMainFrame::ReleaseComponentManager()
{
        if(m_srpMsoCompMgr)
        {
                m_srpMsoCompMgr->FRevokeComponent(m_dwComponentID);
                m_srpMsoCompMgr.SRelease();
        }
}
/*
        NO HMENU SUPPORT.
        OnCreateClient and LoadFrame are responsible for not loading a menu in
        command bar mode.
*/

BOOL CMainFrame::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext) 
{
        // only do this once
        ASSERT_VALID_IDR(nIDResource);
        ASSERT(m_nIDHelp == 0 || m_nIDHelp == nIDResource);

        m_nIDHelp = nIDResource;    // ID for help context (+HID_BASE_RESOURCE)

        CString strFullString;
        if (strFullString.LoadString(nIDResource))
                AfxExtractSubString(m_strTitle, strFullString, 0);    // first sub-string

        if (!AfxDeferRegisterClass(AFX_WNDFRAMEORVIEW_REG))
                return FALSE;

        // attempt to create the window
        LPCTSTR lpszClass = GetIconWndClass(dwDefaultStyle, nIDResource);
        LPCTSTR lpszTitle = m_strTitle;
        if (!Create(lpszClass, lpszTitle, dwDefaultStyle, rectDefault,
                                pParentWnd, 
                                Menu::IsShowingCmdBars() ? NULL : MAKEINTRESOURCE(nIDResource), //OLD_MENU Backwards compatibility hmenu mode
                                0L, pContext))
        {
                return FALSE;   // will self destruct on failure normally
        }

        // save the default menu handle
        ASSERT(m_hWnd != NULL);
        m_hMenuDefault = NULL ; // ::GetMenu(m_hWnd);

        // load accelerator resource
        LoadAccelTable(MAKEINTRESOURCE(nIDResource));

        if (pContext == NULL)   // send initial update
                SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE, TRUE);

        return TRUE;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{
        if (Menu::IsShowingCmdBars()) 
        {
                CMenu* pMenu = NULL;
                return CreateClient(lpcs, pMenu);
        }

        //OLD_MENU Support
        return CMDIFrameWnd::OnCreateClient(lpcs, pContext) ;
}

void CMainFrame::OnUpdateMenuCommand(CCmdUI* pCmdUI)
{
	::UpdateMenuCommand(pCmdUI);
}

void CMainFrame::OnUpdateCustomMenuCommand(CCmdUI* pCmdUI)
{
	::UpdateMenuCommand(pCmdUI);
}

// open the menu as a popup
void CMainFrame::OnMenuCommand(UINT nID)
{
        const MSG *pMsg=GetCurrentMessage();

        CBMenuPopup *pPopup=theCmdCache.GetMenu(nID);

        if(pPopup)
        {
                pPopup->TrackPopupMenu( 0, pMsg->pt.x, pMsg->pt.y, this);
        }
}

void CMainFrame::OnUpdateWindows(CCmdUI* pCmdUI)
{
        pCmdUI->Enable(TRUE);
}

// open the window
void CMainFrame::OnWindows(UINT nID)
{
        int nFilter = FILTER_PROJECT;
        CPartFrame* pMDIChild = theApp.MDITypedGetActive(nFilter, theApp.m_bWindowMenuSorted);

        BOOL bWasZoomed=pMDIChild && pMDIChild->IsZoomed();

        CString buf ;
        CString strTitle ;
        int iMenuId = IDM_WINDOWS_BASE;
        while (pMDIChild != NULL && iMenuId < nID)
        {
                // get the next MDI window
                pMDIChild = theApp.MDITypedGetNext(pMDIChild, nFilter, theApp.m_bWindowMenuSorted);
                iMenuId++;
        }

        if(pMDIChild)
        {
                if(pMDIChild->IsIconic())
                {
                        if(bWasZoomed)
                        {
                                pMDIChild->MDIMaximize();
                        }
                        else
                        {
                                pMDIChild->MDIRestore();
                        }
                }
                pMDIChild->MDIActivate();
                pMDIChild->SetFocus();
        }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is test harness code, not used for in the shipping app, but still built into it to allow sniffs to run
// on retail builds

// This code is used by testing harnesses, such as the sniffs, to gain access to the command bar menus. The harness sends a custom
// message (DSM_TESTMENU) to DevStudio, including as a parameter an atom id. The atom contains the string of a menu reference. 


// Given an item string and an already found pMenu, this returns a pointer to the menu item.
// The item string should either be in the form He&adline, or alternatively %A. The string must precisely match (ignoring case) 
// the desired item, while the % notation allows matching by mnemonic alone. Submenus or items are not supported here; the pMenu 
// must have already found the right submenu.
// BUG: Mnemonic checking requires the incoming mnemonic to be in upper case. Easy fix, postponed till next cycle.
static BOOL FindItem(CString strItem, CBMenuPopup *pMenu, CBMenuItem **ppItem)
{
		// case insensitive
        strItem.MakeUpper();

		// no submenu support
        ASSERT(strItem.Find('\\')==-1);

		// If we're looking for a mnemonic, extract it. Note: Doesn't support MBCS at the moment. MBCS can't happen in menus, AFAIK.
        BOOL bMnemonic=FALSE;
        TCHAR chMnemonic=' ';
        if(strItem[0]=='%')
        {
                bMnemonic=TRUE;
                chMnemonic=strItem[1];
        }

        BOOL bFound=FALSE;

		// seach all menu  items
        CBMenuItem *pItem=NULL;

        for(int j=0; j<pMenu->GetMenuItemCount(); ++j)
        {
				// extract name
                pItem=pMenu->GetMenuItem(j);
                CString name=pItem->GetName();
                name.MakeUpper();

                TCHAR chCheckMnemonic='-';
                if(bMnemonic)
                {
                        chCheckMnemonic=GLOBAL_DATA::ExtractAccelerator(name);
                }

				// is it the same?
                if(     (!bMnemonic && name==strItem) ||
                        (bMnemonic && chCheckMnemonic==chMnemonic))
                {
                        bFound=TRUE;
                        break;
                }
        }

        if(bFound)
        {
				// return the item
                *ppItem=pItem;
                return TRUE;
        }
        else
        {
                return FALSE;
        }
}

// Given a menu string, possibly including an item string, this returns pointer to the menu and the item within it, plus an index
// into the main menu bar if appropriate.
// The item string should either be in the form F&ind\He&adline, or alternatively %I\%A. The string must precisely match (ignoring case) 
// the desired menu and item, while the % notation allows matching by mnemonic alone.
// BUG: Mnemonic checking requires the incoming mnemonic to be in upper case. Easy fix, postponed till next cycle.
static BOOL FindMenu(const CString &buffer, CBMenuPopup **ppMenu, CBMenuItem **ppItem, int *pMainItem)
{
        CASBar *pBar=CASBar::s_pMenuBar;

		// Is this a menu\item deal?
        int iBS=buffer.Find('\\');
        
		// extract menu 
        CString strMenu;
        if(iBS==-1)
        {
                strMenu=buffer;
        }
        else
        {
                strMenu=buffer.Left(iBS);
        }
        strMenu.MakeUpper();

        BOOL bFound=FALSE;

		// this tracks where the menu is inside the menubar
        *pMainItem=-1;

        // first search all open and visible menus. This gives us submenu support, but only if the submenu has been opened already
        POSITION pos=CBMenuPopup::s_listMenus.GetTailPosition();
        while(pos)
        {
                CBMenuPopup *pMenu=CBMenuPopup::s_listMenus.GetPrev(pos);

                if(pMenu)
                {
						// Check if this menu is a submenu in any existing menu
                        CBMenuItem *pItem=NULL;

                        if(FindItem(strMenu, pMenu, &pItem))
                        {
                                *ppMenu=pMenu;
                                *ppItem=pItem;
                                return TRUE;
                        }
                }
        }

		// Now check the menu bar
        BOOL bMnemonic=FALSE;
        TCHAR chMnemonic=' ';
        if(strMenu[0]=='%')
        {
                bMnemonic=TRUE;
                chMnemonic=strMenu[1];
        }
        int i=0;
        for(i=0; i<pBar->m_nCount; ++i)
        {
				// check all visible menus that aren't already pressed (to allow finding of x\x)
                UINT nStyle=pBar->GetButtonStyle(i);
                if( (nStyle & TBBS_MENU)!=0 &&
                        (nStyle & TBBS_TEXTUAL)!=0 &&
                        (nStyle & TBBS_PRESSED)==0) 
                {
                        CString menu=pBar->GetButtonExtra(i)->GetLabel();

                        menu.MakeUpper();

                        TCHAR chCheckMnemonic='-';
                        if(bMnemonic)
                        {
                                chCheckMnemonic=GLOBAL_DATA::ExtractAccelerator(menu);
                        }

                        if(     (!bMnemonic && menu==strMenu) ||
                                (bMnemonic && chCheckMnemonic==chMnemonic))
                        {
                                *pMainItem=i;
                                bFound=TRUE;
                                break;
                        }
                }
        }

        if(bFound)
        {
                *ppMenu=theCmdCache.GetMenu(pBar->GetItemID(i));
                if(iBS==-1)
                {
                        return TRUE;
                }
                else
                {
                        // now search the items
                        CString strItem=buffer.Right(buffer.GetLength()-iBS-1);

                        return FindItem(strItem, *ppMenu, ppItem);
                }
        }               
        else
        {
                return FALSE;
        }


}

#define MAXMENUNAMELEN 512

// message sent by test harness
LRESULT CMainFrame::OnTestMenu(WPARAM wParam, LPARAM lParam)
{
        LRESULT rv=0;
        ATOM a=(ATOM)lParam;
        CString buffer;
        CBMenuPopup *pMenu=NULL;
        CBMenuItem*pItem=NULL;
        CASBar *pBar=CASBar::s_pMenuBar;
        int nMainItem;
        switch(wParam)
        {
				// This does the relevant menu item
                case cMenuMenu:
                        if(GlobalGetAtomName(a, buffer.GetBuffer(MAXMENUNAMELEN), MAXMENUNAMELEN))
                        {
                                buffer.ReleaseBuffer();
                                if(FindMenu(buffer, &pMenu, &pItem, &nMainItem))
                                {
                                        if(pItem!=NULL)
                                        {
                                                pMenu->Done(pItem->GetCmdID());
                                        }
                                        else
                                        {
                                                ASSERT(nMainItem!=-1);
                                                if(nMainItem>=0)
                                                {
                                                        pBar->PostMessage(DSM_DROPMENU, nMainItem, FALSE);
                                                }
                                        }
                                }
                        }
                        break;

				// check if the item exists
                case cMenuExists:
                        if(GlobalGetAtomName(a, buffer.GetBuffer(MAXMENUNAMELEN), MAXMENUNAMELEN))
                        {
                                buffer.ReleaseBuffer();
                                if(FindMenu(buffer, &pMenu, &pItem, &nMainItem))
                                {
                                        rv=1;
                                }
                        }

                        break;

				// check if item is enabled
                case cMenuEnabled:
                        if(GlobalGetAtomName(a, buffer.GetBuffer(MAXMENUNAMELEN), MAXMENUNAMELEN))
                        {
                                buffer.ReleaseBuffer();
                                if(FindMenu(buffer, &pMenu, &pItem, &nMainItem))
                                {
                                        if(pItem!=NULL)
                                        {
                                                rv=!pItem->m_bGrayed;
                                        }
                                        else
                                        {
                                                ASSERT(nMainItem!=-1);
                                                UINT nStyle=pBar->GetButtonStyle(nMainItem);
                                                rv=((nStyle & TBBS_DISABLED)==0);
                                        }
                                }
                        }
                        break;

				// is item checked?
                case cMenuRealChecked:
                        if(GlobalGetAtomName(a, buffer.GetBuffer(MAXMENUNAMELEN), MAXMENUNAMELEN))
                        {
                                buffer.ReleaseBuffer();
                                if(FindMenu(buffer, &pMenu, &pItem, &nMainItem))
                                {
                                        if(pItem!=NULL)
                                        {
                                                rv=pItem->m_bChecked;
                                        }
                                        else
                                        {
                                                ASSERT(nMainItem!=-1);
                                                UINT nStyle=pBar->GetButtonStyle(nMainItem);
                                                rv=(nStyle & TBBS_CHECKED)!=0;
                                        }
                                }
                        }
                        break;
				
				// items in menu?
                case cMenuCount:
                        if(CASBar::s_pDroppedBar!=NULL &&
                                CASBar::s_nDroppedItem!=-1)
                        {
                                pMenu=CASBar::s_pDroppedBar->GetItemMenu(CASBar::s_nDroppedItem);
                                if(pMenu)
                                {
                                        pMenu=pMenu->FindLastChild();

                                        int nCount=0;

                                        for(int j=0; j<pMenu->GetMenuItemCount(); ++j)
                                        {
                                                pItem=pMenu->GetMenuItem(j);

                                                if(pItem->GetItemType()!=CBMenuItem::MIT_Separator)
                                                {
                                                        ++nCount;
                                                }
                                        }
                                        rv=nCount;
                                }
                                else
                                {
                                        rv=0;
                                }
                        }
                        break;
				
				// unimplemented, unused.
                case cMenuText:
                        // this is nasty to implement, so I'm leaving it until it's used.
                        ASSERT(FALSE);
                        break;

				// close an active menu
                case cMenuEnd:
                        if(CASBar::s_pDroppedBar!=NULL &&
                                CASBar::s_nDroppedItem!=-1)
                        {
                                pMenu=CASBar::s_pDroppedBar->GetItemMenu(CASBar::s_nDroppedItem);
                                if(pMenu)
                                {
                                        pMenu->Done(0);
                                }
                        }
                        break;
                default:
                        ASSERT(FALSE);
                        break;
        }

        return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\main.cpp ===
// main.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include <malloc.h>
#include <mbctype.h>
#include "about.h"
#include "string.h"
#include "bardockx.h"
#include "bardlgs.h"
#include "undoctl.h"
#include "tools.h"
#include "msgboxes.h"
#include "totd.h"
#include "findctrl.h"
#include "docobtpl.h"
#include "ipchost.h"
#include "utilauto.h"
#include "autostat.h"
#include "shell.h"
#include "fnwiztpl.h"
#include "commapi.h"
#include <ocdevo.h>
#include "toolexpt.h"
#include <ObjModel\appdefs.h>
#include "prxycust.h"
#include "shlsrvc.h"

#include "resource.h"

#ifdef _CMDLOG
IMPLEMENT_SERIAL(CCmdMap, CMapWordToOb, 1)
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#include "errno.h"
#endif

#include "toolexpt.h"

#include <bldapi.h>
#include <clvwapi.h>

// #include <initguid.h>
#include <clvwguid.h>
#include <ObjModel\appguid.h> //Shell Automation Guids
#include <aut1guid.h>
#include <srcguid.h>
#include <cmguids.h>    // component manager guids
#include <multinfo.h>
#include "bwizmgr.h"
#include <shlobj.h>
#include <shlapi_.h>
#include <shlguid_.h>


#define DEVSTUDIO_FOLDER_ICON_INDEX 6


// { 0c539790-12e4-11cf-b661-00aa004cd6d8 }
DEFINE_GUID(SID_SApplicationObject, 
0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8);

/////////////////////////////////////////////////////////////////////////////
// CTheApp

BOOL bEnableIdleToolbarUpdate = TRUE;
BOOL fForceIdleCycle = FALSE;

CInternalApp theInternalApp;

#define theClass CAppSlob
BEGIN_SLOBPROP_MAP(CAppSlob, CSlob)
	BOOL_PROP(PoppingProperties)
END_SLOBPROP_MAP()
#undef theClass

BEGIN_MESSAGE_MAP(CTheApp, CWinApp)
	//{{AFX_MSG_MAP(CTheApp)
	ON_UPDATE_COMMAND_UI(ID_PROJ_MRU_FILE1, OnUpdateRecentProjMenu)
	ON_COMMAND_EX_RANGE(ID_PROJ_MRU_FIRST, ID_PROJ_MRU_LAST, OnOpenRecentFile)
	ON_COMMAND_EX_RANGE(ID_FILE_MRU_FIRST, ID_FILE_MRU_LAST, OnOpenRecentFile)
//      ON_COMMAND(ID_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CAppSlob::CAppSlob()
{
    m_bPoppingProperties = TRUE;
    m_pCurrentSlob = NULL;
}

CAppSlob::~CAppSlob()
{
    if (m_pCurrentSlob != NULL)
		m_pCurrentSlob->RemoveDependant(this);
}

BOOL CAppSlob::SetSlobProp(UINT nID, CSlob* val)
{
    if (nID == P_CurrentSlob && val != m_pCurrentSlob)
	{
		if (m_pCurrentSlob != NULL)
			m_pCurrentSlob->RemoveDependant(this);

		if (val != NULL)
			val->AddDependant(this);

		TRACE1("CAppSlob::SetSlobProp: Selecting 0x%08lx\n", val);
		m_pCurrentSlob = val;

		SetPropertyBrowserSelection(val);

		InformDependants(nID);
		return TRUE;
    }

    return CSlob::SetSlobProp(nID, val);
}

void CAppSlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
    if (idChange == SN_DESTROY)
    {
		if (m_pCurrentSlob == pChangedSlob)
		{
			if (GetPropertyBrowser() != NULL)
			{
				// Update the prop sheet right away so we don't have
				// dangling slob pointers...

				TRACE("Current slob was destroyed; selecting NULL\n");
						GetPropertyBrowser()->CurrentSlobDestroyed();
			}

			m_pCurrentSlob = NULL;
			InformDependants(SN_ALL);
		}
    }
    else if (idChange == SN_ALL)
    {
		if (GetPropertyBrowser() != NULL)
		{
			SetPropertyBrowserSelection(m_pCurrentSlob, -1,
				CSheetWnd::editorupdate);
		}
    }
    else
    {
		// Otherwise, tell our dependants that a property we reflect changed.
		InformDependants(idChange);
    }

    CSlob::OnInform(pChangedSlob, idChange, dwHint);
}

BEGIN_MESSAGE_MAP(CVshellPackage, CPackage)
	//{{AFX_MSG_MAP(CVshellPackage)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_COMMAND(IDM_HELP_MSPROD, OnHelpPSS)
	ON_COMMAND(IDM_HELP_EXTHELP, OnHelpExtHelp)
	ON_COMMAND(IDM_HELP_TIPOFTHEDAY, OnHelpTip)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	ON_COMMAND(IDM_FILE_NEW_IN_PROJ, OnFileNewInProject)
	ON_COMMAND(IDM_FILE_SAVE_ALL, OnFileSaveAll)
	ON_COMMAND(ID_FILE_SAVE_ALL_EXIT, OnFileSaveAllExit)
	ON_COMMAND(IDM_TOOLBAR_EDIT, OnToolbarOptions)
	ON_COMMAND(IDM_TOGGLE_MDI, OnToggleMDI)
	ON_COMMAND(ID_REPEAT_CMD, OnCmdRepeat)
	ON_COMMAND(ID_REPEAT_CMD0, OnCmdRepeat0)
	ON_COMMAND(ID_REPEAT_CMD1, OnCmdRepeat1)
	ON_COMMAND(ID_REPEAT_CMD2, OnCmdRepeat2)
	ON_COMMAND(ID_REPEAT_CMD3, OnCmdRepeat3)
	ON_COMMAND(ID_REPEAT_CMD4, OnCmdRepeat4)
	ON_COMMAND(ID_REPEAT_CMD5, OnCmdRepeat5)
	ON_COMMAND(ID_REPEAT_CMD6, OnCmdRepeat6)
	ON_COMMAND(ID_REPEAT_CMD7, OnCmdRepeat7)
	ON_COMMAND(ID_REPEAT_CMD8, OnCmdRepeat8)
	ON_COMMAND(ID_REPEAT_CMD9, OnCmdRepeat9)
	ON_COMMAND(IDM_CUSTOMIZE, OnCustomize)
	ON_COMMAND(IDM_TOOLBAR_CUSTOMIZE, OnToolbarCustomize)
	ON_COMMAND(IDM_OPTIONS, OnOptions)
	ON_COMMAND(IDM_INSERT_FILES, OnInsertFiles)
	ON_COMMAND(ID_WINDOW_HIDE, OnWindowHide)
	ON_COMMAND(ID_WINDOW_POPUP_HIDE, OnWindowHide)

	ON_COMMAND_RANGE(IDM_HELP_MOW_FIRST, IDM_HELP_MOW_LAST, OnHelpMSOnTheWeb)

	ON_UPDATE_COMMAND_UI(ID_APP_ABOUT,      OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_HELP_TIPOFTHEDAY, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_HELP_EXTHELP, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_OPEN,      OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_NEW,       OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_FILE_NEW_IN_PROJ, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_CLOSE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_FILE_SAVE_ALL, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_FILE_SEND, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_TOOLBAR_EDIT, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_CUSTOMIZE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_TOOLBAR_CUSTOMIZE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_OPTIONS, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_INSERT_FILES, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(IDM_TOGGLE_MDI, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_CASCADE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_TILE_HORZ, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_TILE_VERT, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_CLOSE_ALL, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_HIDE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_WINDOW_POPUP_HIDE, OnUpdateCommandUI)
	ON_UPDATE_COMMAND_UI(ID_APP_EXIT, OnUpdateCommandUI)

	ON_UPDATE_COMMAND_UI_RANGE(IDM_USERTOOLS_BASE, IDM_USERTOOLS_BASE + 15, OnUpdateCommandUI_Tools)
	ON_UPDATE_COMMAND_UI_RANGE(IDM_HELP_MOW_FIRST, IDM_HELP_MOW_LAST, OnUpdateCommandUI_MSOnTheWeb)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CVshellPackage, CPackage)
	INTERFACE_PART(CVshellPackage, IID_IAutomationItems, AutomationItems)
	INTERFACE_PART(CVshellPackage, IID_IRecordNotifyShell, RecordNotifyShell)
END_INTERFACE_MAP()

void CVshellPackage::OnAppAbout()
{
	theApp.OnAppAbout();
}

BOOL CVshellPackage::OnInit()
{
	USES_CONVERSION;

	CPackage::OnInit();

	if (theApp.m_bInvokedCommandLine && theApp.m_bRunInvisibly)
		return TRUE; // skip all this


	// enumerate all doc objects in the registry ... create a template for each kind.
	CRegistryKeyEnum rke(HKEY_CLASSES_ROOT, __T("DocObject"));
	while (rke.Next())
	{
		CLSID clsid;
		if (CLSIDFromProgID(A2W(LPCTSTR(rke.m_strKeyName)), &clsid) != ERROR_SUCCESS)
			continue;       // might be the CLSID key or some other non-ProgID

		// don't create doctemplate for DocObjects with no default extension
		if (rke.m_strDefaultExtension.IsEmpty())
			continue;

		// fix by martynl to be more tolerant of bad registry entries; specifically those missing a dot at the front, which some appwizards generate in some circumstances
		if(rke.m_strDefaultExtension[0]!='.')
		{
			rke.m_strDefaultExtension="."+rke.m_strDefaultExtension;
		}

		CDocObjectTemplate *ptemp = new CDocObjectTemplate(this, clsid,
			rke.m_strDefaultExtension, rke.m_strDescName, rke.m_strDocNameBase, rke.m_hIcon);

		theApp.AddDocTemplate(ptemp);
	}

	///////////////////////////////////
	// must build this key ourselves.  we can not use theApp.GetRegistryKeyName()
	// as this builds a key that takes into account the /i switch.  since these
	// settings are in HKLM and /i is an HKCU setting, we would end up with 
	// a bogus HKLM path.
	CString         strKey;
	strKey = g_szKeyRoot;
	strKey += _T("\\");
	strKey += g_szCompanyName;
	strKey += _T("\\");
	strKey += theApp.GetExeString(DefaultRegKeyName);
	strKey += _T("\\Component Categories");
	CString         strDef = _T("Default Component");
	CString         strDesc = _T("Description");
	HKEY            hKeyFileNewBuilder;
	LPOLESTR        szCategoryID = NULL;
	CString         strFileNewBuilderID;

	// convert the category id for FileNewBuilder from guid to a string
	// concatenate it to the key above and open the reg key
	::StringFromCLSID(CATID_NewFileBuilder, &szCategoryID);
	strFileNewBuilderID = OLE2T(szCategoryID);
	AfxFreeTaskMem(szCategoryID);
	szCategoryID = NULL;

	strKey += _T("\\");
	strKey += strFileNewBuilderID;

	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, LPCTSTR(strKey), 0,
		KEY_READ, &hKeyFileNewBuilder))
	{

		DWORD   dwNumOfKeys = 0;
		DWORD   dwMaxKeyLen = 0;

		// get the number of sub keys under this category in the registry
		if(ERROR_SUCCESS == ::RegQueryInfoKey(hKeyFileNewBuilder, NULL, NULL,
			NULL, &dwNumOfKeys, &dwMaxKeyLen, NULL, NULL, NULL, NULL, NULL,
			NULL))
		{

			DWORD   dwSize;
			DWORD   dwDescSize;
			DWORD   dwType;
			DWORD   dwMaxDescLen = 0;
			TCHAR*  pszKey = new TCHAR[++dwMaxKeyLen];
			CLSID   clsid;
			CString strDescOut;
			CString strIcon;
			LPTSTR  pszDescOut;
			HKEY    hSubKey = NULL;

			CFileNewWizardTemplate* pFNWizTpl;

			// classes used for FileNewWizard ExtractIcon
			CString strDefaultIconKey;
			CString strIconPath;
	 
			// now that we have the number of subkeys, in a loop, get the
			// description of each one and add it to application as new templates
			for(DWORD i = 0; i < dwNumOfKeys; i++)
			{
				dwSize = dwMaxKeyLen;

				// assumption:
				// when any regkey operations fail, just continue.
				// don't know how else to handle the error if we can't get
				// the key, for now, just continue

				if (ERROR_SUCCESS != ::RegEnumKeyEx(hKeyFileNewBuilder, i,
					pszKey, &dwSize, NULL, NULL, NULL, NULL))
					continue;

				// We do not want the "Default Component" sub key
				if(0 == _tcscmp(LPCTSTR(strDef), pszKey))
					continue;

				if(SUCCEEDED(::CLSIDFromString(T2OLE(pszKey), &clsid)))
				{
					CString strDescKey = _T("CLSID\\");
					strDescKey += pszKey;
					// Open clsid key. Value of key is the description
					if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, strDescKey, 0, KEY_READ, &hSubKey))
						continue;

					// Alloc mem for description and read it in
					DWORD dwLength = 1024;
					LPTSTR pszDesc = strDesc.GetBuffer(dwLength);
					DWORD regErr = ::RegQueryValueEx(hSubKey, NULL, 0, &dwType, (LPBYTE)pszDesc, &dwLength);
					strDesc.ReleaseBuffer();
					::RegCloseKey(hSubKey);
					hSubKey = NULL;

					if(regErr != ERROR_SUCCESS)
						continue;

					ASSERT(REG_SZ == dwType);
					ASSERT(dwLength);

					// Now extract the Icon 
					strDefaultIconKey = _T("CLSID\\");
					strDefaultIconKey += pszKey;
					strDefaultIconKey += _T("\\DefaultIcon");
					// Open Default Icon Key
					HICON hIcon = NULL;
					if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, strDefaultIconKey, 0, KEY_READ, &hSubKey))
						continue;
												
					// Alloc mem for icon path, and read it in
					dwLength = 1024;
					LPTSTR pszIcon = strIcon.GetBuffer(dwLength);
					regErr = ::RegQueryValueEx(hSubKey, NULL, 0, &dwType, (LPBYTE)pszIcon, &dwLength);
					::RegCloseKey(hSubKey);
					hSubKey = NULL;
					if(regErr != ERROR_SUCCESS)
					{
						strIcon.ReleaseBuffer();
						continue;
					}
					ASSERT(REG_SZ == dwType);
					ASSERT(dwLength);

					// Get Icon Index
					TCHAR *pch = _tcsrchr(pszIcon, _T(','));
					int nOffset = 0;
					if(pch)
					{
						pch[0] = _T('\0');
						nOffset = _ttoi(&pch[1]);
					}
					// Get small (16x16) icon
					::ExtractIconEx(pszIcon, nOffset, NULL, &hIcon, 1);
					ASSERT(hIcon);

					// if they didn't specify an icon, or gave us a bogus offset
					// let's give them one of ours
					if(NULL == hIcon)
						hIcon = ::LoadIcon(m_hInstance, MAKEINTRESOURCE(IDI_FILENEWWIZDEFAULT));

					strIcon.ReleaseBuffer();

					// Finally create new FileNewWizardTemplate
					pFNWizTpl = new CFileNewWizardTemplate(this, clsid,
						strDesc, hIcon);

					// register the template with the app
					theApp.AddDocTemplate(pFNWizTpl);
				}
			}
			delete [] pszKey;
		}
		::RegCloseKey(hKeyFileNewBuilder);
	}

	return TRUE;
}

HRESULT DevStudioLoadStreamFromRegistry(LPCTSTR szSection, LPCTSTR szKey, const CLSID &rclsid,
										REFIID riid, LPVOID *ppvUnknown,
										IUnknown *pIUnknownOuter, CLSCTX clsctx)
{
	HRESULT hr = NOERROR;

	*ppvUnknown = NULL;

	IStream *pIStream = ::GetRegIStream(szSection, szKey);
	if (pIStream != NULL)
	{
		LPVOID pvTemp = NULL;

		hr = ::CoCreateInstance(rclsid, pIUnknownOuter, clsctx, IID_IPersistStream, &pvTemp);
		if (SUCCEEDED(hr))
		{
			IPersistStream *pIPersistStream = reinterpret_cast<IPersistStream *>(pvTemp);

			hr = pIPersistStream->Load(pIStream);
			if (SUCCEEDED(hr))
				hr = pIPersistStream->QueryInterface(riid, ppvUnknown);

			pIPersistStream->Release();
			pIPersistStream = NULL;
		}
	
		if (pIStream != NULL)
		{
			pIStream->Release();
			pIStream = NULL;
		}
	}

	return hr;
}

HRESULT DevStudioPersistStreamToRegistry(IUnknown *pIUnknown, LPCTSTR pctstrKey, LPCTSTR pctstrValue)
{
	HRESULT hr;
	IStream *pIStream = NULL;
	hr = ::CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
	if (FAILED(hr))
		return hr;

	IPersistStream *pIPersistStream = NULL;
	LPVOID pvTemp = NULL;
	hr = pIUnknown->QueryInterface(IID_IPersistStream, &pvTemp);

	if (FAILED(hr))
	{
		pIStream->Release();
		return hr;
	}

	pIPersistStream = reinterpret_cast<IPersistStream *>(pvTemp);

	hr = pIPersistStream->Save(pIStream, TRUE);
	if (FAILED(hr))
	{
		pIStream->Release();
		pIPersistStream->Release();
		return hr;
	}

	::WriteRegIStream(pctstrKey, pctstrValue, pIStream);

	pIPersistStream->Release();
	pIStream->Release();

	return NOERROR;
}

BOOL CVshellPackage::CanExit()
{
	for (int i = 0; i < toolList.NumTools(); i++)
	{
		CTool *pTool = toolList.GetTool(i);
		if (pTool->m_pSpawner != NULL)
		{
			MsgBox(Error, IDS_ERR_TOOL_RUNNING);
			return FALSE;
		}
	}
	return TRUE;
}

void CVshellPackage::OnPreExit()
{
	ReleaseHelpInterface();
}

void CVshellPackage::OnToolbarOptions()
{
	// !!!
}

void CVshellPackage::OnWindowHide()
{
	CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
	if (pDocker == NULL)
	{
		CMDIChildDock* pMDIChild = (CMDIChildDock*)
			((CMDIFrameWnd*) theApp.m_pMainWnd)->MDIGetActive();
		if (pMDIChild != NULL && pMDIChild->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
			pDocker = pMDIChild->GetWorker();
	}

	if (pDocker != NULL)
		pDocker->ShowWindow(FALSE);
}

void CVshellPackage::OnToggleMDI()
{
	CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
	if (pDocker == NULL)
	{
		CMDIChildDock* pMDIChild = (CMDIChildDock*)
			((CMDIFrameWnd*) theApp.m_pMainWnd)->MDIGetActive();
		if (pMDIChild != NULL && pMDIChild->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
			pDocker = pMDIChild->GetWorker();
	}

	if (pDocker != NULL)
		pDocker->ToggleMDIState();
}

// this array should contain enough slots for all doc object
// description strings, plus an extra for NULL termination.

// third field in SRankedStringID structure is CLSID of project type
// for which the filter should be ranked first if ranks are identical

// REVIEW [fabriced]: this array should be sized dynamically
extern const int nMaxArsiFilters = 16;
SRankedStringID arsiOpenFilters[] =
{
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE,
	NULL,   1000,   &CLSID_NULL,  FALSE
};

void CVshellPackage::GetOpenDialogInfo(SRankedStringID** ppFilters, 
	SRankedStringID** ppEditors, int nOpenDialog)
{
	ASSERT (ppEditors != NULL);
	ASSERT (ppFilters != NULL);
	*ppEditors = NULL;

	switch (nOpenDialog)
	{
		case GODI_FILEOPEN:
		case GODI_ADDFILE:
			*ppFilters = arsiOpenFilters;
			return;
		case GODI_FINDINFILES:
		case GODI_RESIMPORT:
			*ppFilters = NULL;
			return;
	}
}

void CTheApp::BeginSetRepeatCount(INT cRpt, BOOL fReplacable /* = FALSE */)
{
	// The negative arg indicates that we're augmenting the repeat count
	// by invoking the command again
	if (cRpt < 0)
		SetRepCount(max(GetRepCount(), 4 * GetRepCount()));
	else
		SetRepCount(cRpt);

	m_SettingRepeatCount = FinishedNot;
	m_fReplaceRepeatCount = fReplacable;

	UpdateRepeatStatus();
}

void CTheApp::EndSetRepeatCount(REPEAT_COUNT_STATE rcs)
{
	m_SettingRepeatCount = rcs;
	UpdateRepeatStatus();
}

void CTheApp::UpdateRepCount(INT i)
{
	// If we've just begun a new repeat count, this number
	// should replace the existing count
	if (m_fReplaceRepeatCount)
	{
		SetRepCount(i);
		m_fReplaceRepeatCount = FALSE;
	}
	else
	{
		// Otherwise, it should augment the existing count
		SetRepCount(max(GetRepCount(), 10 * GetRepCount() + i));
	}
}

void CTheApp::UpdateRepeatStatus()
{
	static CString  strRepeat;
	static BOOL             fInitd = FALSE;

	if (!fInitd)
	{
		strRepeat.LoadString(IDS_RepeatCount);
		fInitd = TRUE;
	}

	if (m_SettingRepeatCount != FinishedAbsolute)
	{
		CString strStatus;
		strStatus.Format("%s%d", strRepeat, GetRepCount());

		// Make sure this is reflected in the status bar
		SetIdlePrompt(strStatus, TRUE);
		SetPrompt(strStatus, TRUE);
	}
	else if (m_SettingRepeatCount == FinishedAbsolute)
	{
		SetIdlePrompt(AFX_IDS_IDLEMESSAGE, TRUE);
		SetPrompt(AFX_IDS_IDLEMESSAGE, TRUE);
		m_SettingRepeatCount = DoneRepeating;
	}
}

BOOL CTheApp::FCmdRepeatPretranslate(MSG *pMsg)
{
	BOOL    fRet = FALSE;
	WPARAM  wParam = pMsg->wParam;
	TCHAR   tch = (TCHAR)wParam;

	switch (pMsg->message)
	{
		case WM_CHAR:

			if (tch >= _T('0') && tch <= _T('9'))
				break;
			else if (tch == '-')
			{
				SetRepCount(-GetRepCount());
				fRet = TRUE;
			}
			else
				EndSetRepeatCount(FinishedAbsolute);
			break;

		case WM_KEYDOWN:

			if (tch >= _T('0') && tch <= _T('9'))
			{
				UpdateRepCount(_ttoi(&tch));
				fRet = TRUE;
			}
			else if (wParam == VK_SUBTRACT)
				fRet = TRUE;
			else
			{
				// We don't absolutely know if we're finished yet.  If the next
				// thing we get is a wm_char that's a digit or '-', we're not done.
				EndSetRepeatCount(FinishedMaybe);
			}

			break;

		default:
			break;
	}

	UpdateRepeatStatus();

	return fRet;
}


void CVshellPackage::OnCmdRepeat()
{
	theApp.BeginSetRepeatCount(-1, TRUE);
}

void CVshellPackage::OnCmdRepeat0()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(0);
	else
		theApp.BeginSetRepeatCount(0);
}

void CVshellPackage::OnCmdRepeat1()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(1);
	else
		theApp.BeginSetRepeatCount(1);
}

void CVshellPackage::OnCmdRepeat2()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(2);
	else
		theApp.BeginSetRepeatCount(2);
}

void CVshellPackage::OnCmdRepeat3()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(3);
	else
		theApp.BeginSetRepeatCount(3);
}

void CVshellPackage::OnCmdRepeat4()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(4);
	else
		theApp.BeginSetRepeatCount(4);
}

void CVshellPackage::OnCmdRepeat5()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(5);
	else
		theApp.BeginSetRepeatCount(5);
}

void CVshellPackage::OnCmdRepeat6()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(6);
	else
		theApp.BeginSetRepeatCount(6);
}

void CVshellPackage::OnCmdRepeat7()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(7);
	else
		theApp.BeginSetRepeatCount(7);
}

void CVshellPackage::OnCmdRepeat8()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(8);
	else
		theApp.BeginSetRepeatCount(8);
}

void CVshellPackage::OnCmdRepeat9()
{
	if (theApp.FSettingRepeatCount())
		theApp.UpdateRepCount(9);
	else
		theApp.BeginSetRepeatCount(9);
}

void CVshellPackage::OnUpdateCommandUI(CCmdUI* pCmdUI)
{
	switch (pCmdUI->m_nID)
	{
	case IDM_FILE_SAVE_ALL:
		pCmdUI->Enable(CPartDoc::CanSaveAll());
		break;

	case ID_FILE_SAVE:
	case ID_FILE_CLOSE:
	case ID_WINDOW_CASCADE:
	case ID_WINDOW_TILE_HORZ:
	case ID_WINDOW_TILE_VERT:
	case ID_WINDOW_CLOSE_ALL:
		pCmdUI->Enable(((CMainFrame*) theApp.m_pMainWnd)->MDIGetActive() != NULL);
		break;

	case ID_WINDOW_POPUP_HIDE:
		if (CDockWorker::s_pActiveDocker == NULL)
		{
			CString str;
			VERIFY(str.LoadString(IDS_POPUP_CLOSE));

			pCmdUI->SetText(str);
		}
		pCmdUI->Enable(TRUE);
		break;

	case ID_WINDOW_HIDE:
		pCmdUI->Enable(CDockWorker::s_pActiveDocker != NULL);
		break;

	case IDM_TOGGLE_MDI:
		{
			CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
			if (pDocker == NULL)
			{
				CMDIChildDock* pMDIChild = (CMDIChildDock*)
					((CMDIFrameWnd*) theApp.m_pMainWnd)->MDIGetActive();
				if (pMDIChild != NULL && pMDIChild->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
					pDocker = pMDIChild->GetWorker();
			}

			pCmdUI->Enable(pDocker!=NULL);

			if(pDocker)
			{
				pCmdUI->SetCheck(CDockWorker::s_pActiveDocker != NULL);
			}
		}
		break;

	case IDM_FILE_NEW_IN_PROJ:
	case IDM_INSERT_FILES:
	{
		IProjectWorkspace *pInterface;
		pInterface = g_IdeInterface.GetProjectWorkspace();
		if(pInterface)
		{
			BOOL fTempWorkspace = (pInterface->IsWorkspaceTemporary() == S_OK);
			if (fTempWorkspace)
			{
				pCmdUI->Enable(FALSE);
				break;
			}
			else
			{
				IPkgProject *pProject;
				pInterface->GetActiveProject(&pProject);
				pCmdUI->Enable(pProject != NULL);
				if (pProject)
				{
					if(pCmdUI->m_nID==IDM_INSERT_FILES)
					{

					}
					pProject->Release();
				}
				break;
			}
		}
		else
		{
			pCmdUI->Enable(FALSE);
			break;
		}
	}

	case ID_APP_ABOUT:
		if(IsPackageLoaded(PACKAGE_LANGFOR) || IsPackageLoaded(PACKAGE_LANGMST))
		{
			CString str;
			str.LoadString(IDS_ABOUT_DEVSTUD);
			pCmdUI->SetText(str);
		}
		pCmdUI->Enable(TRUE);

		break;

	case ID_FILE_OPEN:
	case ID_FILE_NEW:
	case IDM_HELP_TIPOFTHEDAY:
	case ID_APP_EXIT:
	case IDM_TOOLBAR_EDIT:
	case IDM_CUSTOMIZE:
	case IDM_TOOLBAR_CUSTOMIZE:
	case IDM_OPTIONS:
		pCmdUI->Enable(TRUE);
		break;

	case IDM_HELP_EXTHELP:
		pCmdUI->Enable(TRUE);
		pCmdUI->SetCheck(UseExtHelp());
		break;

	default:
		pCmdUI->Enable(FALSE);
		break;
	}
}


////////////////////////////////////////////////////////////////////////////
// Microsoft on the Web
//
void CVshellPackage::OnUpdateCommandUI_MSOnTheWeb(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(TRUE);
}

////////////////////////////////////////////////////////////////////////////
// Tools menu custom item handling
//

static UINT nRunningTool = 0;

void CVshellPackage::OnUpdateCommandUI_Tools(CCmdUI* pCmdUI)
{
	ASSERT(pCmdUI->m_nID >= IDM_USERTOOLS_BASE);
	ASSERT(pCmdUI->m_nID <= IDM_USERTOOLS_LAST);

	CTool *pTool = toolList.GetTool(pCmdUI->m_nID - IDM_USERTOOLS_BASE);
	if (pTool != NULL)
	{
		BOOL bToolRunning = !(pTool->CanSpawn());

		if (bToolRunning)
		{
			static CString strPrefix;

			if (strPrefix.IsEmpty())
				strPrefix.LoadString(IDS_STOP_TOOL_PREFIX);
			// REVIEW [patbr]
			// used to add Ctrl+Break to menu; still possible to handle?

			CString str = strPrefix;
			str += pTool->m_strMenuName;
			pCmdUI->SetText(str);
		}
		else
		{
			extern BOOL GetCmdKeyString(UINT nCmdID, CString& str);  // from keymap.cpp
			CString strAccel;
			GetCmdKeyString(pCmdUI->m_nID, strAccel);
			pCmdUI->SetText(pTool->m_strMenuName + '\t' + strAccel);
		}
		pCmdUI->Enable(TRUE);
	}
	else
	{
		pCmdUI->Enable(FALSE);
	}
}

void CVshellPackage::OnCommand_Tools(UINT nID)
{
	ASSERT(nID >= IDM_USERTOOLS_BASE);
	ASSERT(nID <= IDM_USERTOOLS_LAST);

	CTool *pTool = toolList.GetTool(nID - IDM_USERTOOLS_BASE);
	if (pTool->CanSpawn())
		pTool->Spawn();
	else
		pTool->CancelSpawn();
}

////////////////////////////////////////////////////////////////////////////

BOOL CVshellPackage::OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		if (nID >= IDM_USERTOOLS_BASE && nID <= IDM_USERTOOLS_LAST)
		{
			OnCommand_Tools(nID);
			return TRUE;
		}
	}

	return CPackage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

/* Implement only if different than EXE
LPCTSTR CVshellPackage::GetHelpFileName(HELPFILE_TYPE helpfileType)
{
	switch (helpfileType)
	{
		case APPLICATION_HELP:
			return _TEXT("xxx");

		case REFERENCE_HELP:
			return _TEXT("xxx");

		default:
			ASSERT(FALSE);
	}

	return CPackage::GetHelpFileName(helpfileType);
}
*/

HGLOBAL CVshellPackage::GetDockInfo()
{
	// When adding enties to rgdi[] make sure to add corresponding entries in
	// rgCaptionID[].
	static UINT rgCaptionID[] = {
		IDS_MENUBAR,
		IDS_STANDARD,
		IDS_FULLSCREEN
	};

    static DOCKINIT BASED_CODE rgdi[] = {
		{IDTB_MENUBAR,
	PACKAGE_SUSHI,
		PACKET_NIL,
	"",     // IDS_MENUBAR
	INIT_VISIBLE | INIT_CANHORZ | INIT_CANVERT | INIT_POSITION | INIT_ASKAVAILABLE | INIT_AVAILABLE,
	dtToolbar,
	dpTop,
	dpNil,
	{0,0,0,0}},

		{IDTB_STANDARD,
	PACKAGE_SUSHI,
		PACKET_NIL,
	"",     // IDS_STANDARD
	INIT_VISIBLE | INIT_CANHORZ | INIT_CANVERT | INIT_POSITION,
	dtToolbar,
	dpTop,
	dpNil,
	{0,0,0,0}},

		{IDTB_FULLSCREEN,
	PACKAGE_SUSHI,
		PACKET_NIL,
	"",     // IDS_FULLSCREEEN
	INIT_CANHORZ | INIT_CANVERT | INIT_POSITION | INIT_ASKAVAILABLE,
	dtToolbar,
	dpNil,
	dpNil,
	{0,0,0,0}},
	};

	CString str;
	for (int i = 0; i < sizeof(rgCaptionID) / sizeof(UINT); i++)
	{
		VERIFY(str.LoadString(rgCaptionID[i]));
		ASSERT(str.GetLength() <= _MAX_DOCK_CAPTION);
		lstrcpy(rgdi[i].szCaption, str);
	}

	return DkInfoData(sizeof(rgdi) / sizeof(DOCKINIT), rgdi);
}

HWND CVshellPackage::GetDockableWindow(UINT nID, HGLOBAL hglob)
{
	switch (nID)
	{
	case ID_EDIT_UNDO:
	case ID_EDIT_REDO:
		//BLOCK:
		{
			// Create off screen to avoid flashing with SetParent().
			CRect rect;

			// account for different possible sizes of the impending control
			rect.SetRect(-CDropControl::GetExpectedWidth(), -CDropControl::GetExpectedHeight(), 0, 0);

			CDropControl* pDropControl;
			if (nID == ID_EDIT_UNDO)
				pDropControl = new CUndoControl;
			else
				pDropControl = new CRedoControl;

			if (!pDropControl->Create(WS_CHILD | WS_VISIBLE,
					rect, AfxGetMainWnd(), nID))
			{
				delete pDropControl;
				return NULL;
			}

			return pDropControl->GetSafeHwnd();
	    }
	case ID_EDIT_FIND:
		//BLOCK:
		{
			// The find combo is smaller when we have a small screen
		   int cxScreen = ::GetSystemMetrics(SM_CXSCREEN) ;
				
			CRect rect(-208, -120, 0, 0);   // Off screen.
			if (UseWin4Look())
				rect.left += 9;

			// 750 is a somewhat arbitrary value, intended to allow for 800x600 screens where some clever utility has stolen some
			// realestate.
			if(cxScreen<750)
			{
				rect.left=-100;
			}

			return CreateFindCombo(
				WS_CHILD | WS_VSCROLL | CBS_AUTOHSCROLL | CBS_DROPDOWN,
				&rect, AfxGetMainWnd()->GetSafeHwnd(), ID_EDIT_FIND);
		}
	case ID_PROJECT_COMBO:
		{
			CPackage* pPackage = theApp.GetPackage(PACKAGE_PRJSYS);
			return pPackage->GetDockableWindow(nID, hglob);
		}
	}

	return CPackage::GetDockableWindow(nID, hglob);
}

HGLOBAL CVshellPackage::GetToolbarData(UINT nID)
{
	// Custom bars have no default.
	if(nID>= IDTB_CUSTOM_BASE)
	{
		return NULL;
	}

	static UINT BASED_CODE full_buttons[] =
	{
		ID_WINDOW_FULLSCREEN
	};

	TOOLBARINIT tbi;
	tbi.nIDWnd = nID;

	switch(nID)
	{
	case IDTB_STANDARD:
		return theApp.GetStandardToolbarData();

	case IDTB_FULLSCREEN:
	    tbi.nIDCount = sizeof(full_buttons)/sizeof(UINT);
	    return DkToolbarData(&tbi, full_buttons);


	case IDTB_MENUBAR:
		{
			// translate the main menu into a toolbar
			// The menu bar is copied from the popup menu bar. This is by design, I think.
			CBMenuPopup *pMenu=theCmdCache.GetMenu(IDM_MENU_BAR);

			// must have already built menus by this point, I hope.
			ASSERT(pMenu!=NULL);

			// iterate over menu, extracting command ids
			int nItems=pMenu->GetMenuItemCount();
			UINT *pIds=new UINT[nItems];

			int iDest=0;
			for(int iItem=0; iItem<nItems; ++iItem)
			{
				CBMenuItem *pItem=pMenu->GetMenuItem(iItem);
				if(pItem->GetItemType()!=CBMenuItem::MIT_Separator)
				{
					pIds[iDest++]=pItem->GetCmdID();
				}
			}

			// set up for docking
			tbi.nIDCount = iDest;
			HGLOBAL hGlob=DkToolbarData(&tbi, pIds);

			// don't keep ids around
			delete pIds;

			return hGlob;
		}
	}

	return CPackage::GetToolbarData(nID);
}

BOOL CVshellPackage::AskAvailable(UINT nIDWnd)
{
	if (nIDWnd == IDTB_FULLSCREEN)
		return ((CMainFrame*) theApp.m_pMainWnd)->IsFullScreen();

	if(nIDWnd==IDTB_MENUBAR)
	{
		return Menu::IsShowingCmdBars();
	}

	return TRUE;
}

UINT CVshellPackage::CmdIDForToolTipKey(UINT nIDCmdOriginal)
{
	// Limited use virtual (bobz)
	// This can be called for a command with the CT_DYNAMIC_CMD_STRING flag set.
	// It allows the caller to specify a different command id to use to get the
	// key assignment for a tool tip. It exists primarily for commands that are
	// toolbar HWND controls that have a different sidedocked command, like the
	// Find control or Wizard Bar combos that otherwise lose their tooltips


	switch (nIDCmdOriginal)
	{
	default:
		break;  // fall thru to default handler
	case ID_EDIT_FIND:
		return ID_EDIT_FIND_COMBO;
	}

	return nIDCmdOriginal;
}



/////////////////////////////////////////////////////////////////////////////
// Interfaces implemented by CVshellPackage

/////////////////////////////////////////////////////////////////////////////
// IAutomationItems interface

// IUnknown methods

STDMETHODIMP_(ULONG) CVshellPackage::XAutomationItems::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CVshellPackage, AutomationItems)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CVshellPackage::XAutomationItems::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CVshellPackage, AutomationItems)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CVshellPackage::XAutomationItems::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CVshellPackage, AutomationItems)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

// IAutomationItems methods

STDMETHODIMP CVshellPackage::XAutomationItems::GetAutomationItems (CAutomationItem* pAutomationItems,
															   DWORD* pdwNumItems)
{
	METHOD_PROLOGUE_EX(CVshellPackage, AutomationItems)

	// Make sure automation items list is filled up
	pThis->RegisterTypeLibsIfNecessary();

	if (pAutomationItems == NULL)
	{
		// If caller gives us a NULL array, then just return how many
		//  named items we have
		*pdwNumItems = pThis->m_ptrlAutomationItems.GetCount();
		return S_OK;
	}

	// An allocated array has been passed.  Fill in as many entries as
	//  we can with the named items we collected on startup
	POSITION pos = pThis->m_ptrlAutomationItems.GetHeadPosition();
	DWORD i=0;
	while (pos != NULL && i < *pdwNumItems)
	{
		// Get next named item in our list, and copy it to caller's array
		CAutomationItem* pAutomationItem = pThis->m_ptrlAutomationItems.GetNext(pos);
		_tcscpy(pAutomationItems[i].m_szName, pAutomationItem->m_szName);
		memcpy(&(pAutomationItems[i].m_tlid), &(pAutomationItem->m_tlid), sizeof(GUID));
		memcpy(&(pAutomationItems[i].m_clsid), &(pAutomationItem->m_clsid), sizeof(GUID));
		pAutomationItems[i].m_wMajorVersion = pAutomationItem->m_wMajorVersion;
		pAutomationItems[i].m_wMinorVersion = pAutomationItem->m_wMinorVersion;
		i++;
	}
	*pdwNumItems = i;
	return S_OK;
}

STDMETHODIMP CVshellPackage::XAutomationItems::GetIDispatch (LPCTSTR szItemName,
															  IDispatch** ppDispatch)
{
	METHOD_PROLOGUE_EX(CVshellPackage, AutomationItems)
	*ppDispatch = theApp.GetPackageExtension(szItemName);
	if (*ppDispatch == NULL)
		return E_FAIL;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IRecordNotifyShell interface

// IUnknown methods

STDMETHODIMP_(ULONG) CVshellPackage::XRecordNotifyShell::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CVshellPackage::XRecordNotifyShell::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CVshellPackage::XRecordNotifyShell::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

// IRecordNotifyShell methods

// Everything turned to YES (recording session, recording cursor, recrod text)
STDMETHODIMP CVshellPackage::XRecordNotifyShell::OnStartRecord()
{
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	CMainFrame* pMainFrame = (CMainFrame*) AfxGetMainWnd();
	ASSERT (pMainFrame != NULL);
	ASSERT_KINDOF(CMainFrame, pMainFrame);

	pThis->SetShouldRecordText(TRUE);
	pThis->SetRecordState(CTheApp::RecordOn);
	return S_OK;
}

// Everything turned to NO (recording session, recording cursor, recrod text)
STDMETHODIMP CVshellPackage::XRecordNotifyShell::OnStopRecord()
{
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	CMainFrame* pMainFrame = (CMainFrame*) AfxGetMainWnd();
	ASSERT (pMainFrame != NULL);
	ASSERT_KINDOF(CMainFrame, pMainFrame);

	pThis->SetShouldRecordText(FALSE);
	pThis->SetRecordState(CTheApp::RecordOff);
	return S_OK;
}

// The user has paused recording a macro
//  In Recording Session (REC in statusbar)?            YES
//  Show Record Cursor?                                                         NO
//  Packages Record Text?                                                       NO
STDMETHODIMP CVshellPackage::XRecordNotifyShell::OnPauseRecord()
{
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	CMainFrame* pMainFrame = (CMainFrame*) AfxGetMainWnd();
	ASSERT (pMainFrame != NULL);
	ASSERT_KINDOF(CMainFrame, pMainFrame);

	pThis->SetShouldRecordText(FALSE);
	pThis->SetRecordState(CTheApp::RecordPaused);
	return S_OK;
}

// The user has unpaused recording a macro
//  For now, the semantics are the same as beginning a recording session
//  (as far as the shell is concerned).
//  In Recording Session (REC in statusbar)?            YES
//  Show Record Cursor?                                                         YES
//  Packages Record Text?                                                       YES
STDMETHODIMP CVshellPackage::XRecordNotifyShell::OnResumeRecord()
{
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	return OnStartRecord();
}

// This is called because a macro is being run while another is recorded.
//  In Recording Session (REC in statusbar)?            YES
//  Show Record Cursor?                                                         YES
//  Packages Record Text?                                                       NO
STDMETHODIMP CVshellPackage::XRecordNotifyShell::SetShouldRecordText(BOOL bShouldRecordText)
{
	METHOD_PROLOGUE_EX(CVshellPackage, RecordNotifyShell)
	pThis->SetShouldRecordText(bShouldRecordText);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

BEGIN_COMMAND_MENU_(EmptyBar, 0)
END_POPUP_MENU()
 
POPDESC *CVshellPackage::GetMenuDescriptor(UINT nId)
{
	if(nId>=IDM_CUSTOMMENU_BASE && nId<=IDM_CUSTOMMENU_LAST)
	{
		(*(MENU_CONTEXT_POPUP(EmptyBar))).cmdID=nId;
		return MENU_CONTEXT_POPUP(EmptyBar);
	}
	else
	{
		return theApp.GetMenuDescriptor(nId);
	}
}

BOOL CVshellPackage::IsMenuVisible(UINT nId)
{
	if( nId==IDM_MENU_BUILD ||
		nId==IDM_MENU_DEBUG)
	{
		CMainFrame* pMainFrame = (CMainFrame*)theApp.m_pMainWnd;
		BOOL bDesignMenu=(nId==IDM_MENU_BUILD);
		BOOL bDesignMode=(pMainFrame->m_nManagerState & 1) == 0;

		if(bDesignMenu!=bDesignMode)
		{
			return FALSE;
		}
		else
		{
			return TRUE;
		}
	}
	else if(nId==IDM_MENU_HELP_MSONTHEWEB)
	{
		return !theApp.m_bHideMicrosoftWebMenu;
	}
	else
	{
		return TRUE;
	}
}

BOOL CTheApp::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	CPackage*       pPackage = NULL;

	if (nID < 0xf000) // System menu.
	{
		// We haven't yet found the destination package
		POSITION pos = m_packages.GetHeadPosition();
		while (pos != NULL)
		{
			pPackage = (CPackage*)m_packages.GetNext(pos);
			if ((pPackage->m_flags & PKS_COMMANDS) != 0 &&
				pPackage->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
			{
				return TRUE;
			}
		}
	}
	
	return CWinApp::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CTheApp::OnDirChange()
{
	((CMainFrame*) m_pMainWnd)->OnDirChange();
}

////////////////////////////////////////////////////////////////////////////


#ifdef PERF_MEASUREMENTS
/////////////////// Testing code for V4.X Perf release  /////////////////////////
//////////////// 8/25/95        fabriced
static HANDLE hBuildSynch;
static BOOL fBuildStarted = FALSE;
static char *(* OutputWindowGetLine)(ULONG iline, ULONG *pcb);
#define SLEEP_TIME      2500
//////////////// 11/21/95       konradt
static DWORD (* GetCurrentWorkingSet)(void);
static void QACurrentWorkingSet(LPCTSTR str = NULL);
static BOOL QATrimWorkingSet();

static void QARunUnderShell(char *Command)
{
  static STARTUPINFO SUInfo = 
	{sizeof(STARTUPINFO),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  static PROCESS_INFORMATION PInfo;
  static char buf[300], acCPBuf[100];

  int v = GetVersion();

  switch(LOBYTE(LOWORD(v)))    // examine high bit for major version #
  { 
    case 3:
		  sprintf(buf, "cmd.exe /c \"%s\"", Command );
		  break;
	case 4: //TODO: axe this mega-hack when CreateProcess works properly on Chicago
		  GetEnvironmentVariable("COMSPEC", acCPBuf, 100);
		  sprintf(buf, "%s /c %s", acCPBuf, Command);
			break;
  }

  if (CreateProcess(
	0,
	buf, 
	0,     // process sec. attr.
	    0,     // thread sec. attr.
	0,
	    0,
	    NULL,     // env.
	    NULL,     // dir.
	&SUInfo,
	    &PInfo))
	{
	  WaitForSingleObject(PInfo.hProcess, INFINITE);
	}
}

static void QAPump( CTheApp *pApp )
{
	Sleep(SLEEP_TIME);
	while(::PeekMessage(&pApp->m_msgCur, NULL, NULL, NULL, PM_NOREMOVE) )
		pApp->PumpMessage();
	LONG lCount=0;
	while(pApp->OnIdle(lCount++));
	Sleep(SLEEP_TIME);
	while(::PeekMessage(&pApp->m_msgCur, NULL, NULL, NULL, PM_NOREMOVE) )
		pApp->PumpMessage();
    lCount=0;
    while(pApp->OnIdle(lCount++));
	while(::PeekMessage(&pApp->m_msgCur, NULL, NULL, NULL, PM_NOREMOVE) )
		pApp->PumpMessage();
}

static void QADumpOutputWindow( const char *logfile )
{
	FILE *outFile;
	char *szLine;
	ULONG cbLine;
	Sleep(SLEEP_TIME);
	outFile = fopen( logfile, "wt" );
	for (int i=0; szLine = (*OutputWindowGetLine)(i, &cbLine); i++ )
		fprintf( outFile, szLine );
	fclose(outFile);
}

#ifdef _DEBUG
static const char *szIdeModuleName = "MSVCSRCD";
#else
static const char *szIdeModuleName = "MSVCSRC";
#endif

static BOOL QADoBuild(CTheApp *pApp, const char *szOutputLog)
{
	QAPump( pApp );
	if (pApp->m_bPerfQA_WorkSet) 
		QATrimWorkingSet();
	pApp->OnCmdMsg( IDM_PROJITEM_BUILD,0,0,0);
	QAPump( pApp );
	Sleep(SLEEP_TIME);
	if(fBuildStarted)
	{
		WaitForSingleObject( hBuildSynch, INFINITE );
		fBuildStarted = FALSE;
	}
	else // Build error!
	{
		FILE *outFile;
		outFile = fopen( szOutputLog, "wt" );
		fprintf( outFile, "Error trying to spawn the build!\n" );
		fclose(outFile);
		return( FALSE );
	}
	QAPump( pApp );
	QADumpOutputWindow(szOutputLog);
	return( TRUE );
}

static void QADoDebug(CTheApp *pApp, const char *szOutputLog)
{
	QAPump( pApp );
	if (pApp->m_bPerfQA_WorkSet) 
	{
		QATrimWorkingSet();
		pApp->OnCmdMsg( IDM_RUN_TRACEINTO,0,0,0);
		QACurrentWorkingSet("after debug startup");
	}
	else
	{
		pApp->OnCmdMsg( IDM_RUN_TRACEINTO,0,0,0);
	}
	QAPump( pApp );
	pApp->OnCmdMsg( IDM_RUN_TRACEINTO,0,0,0);
	QAPump( pApp );
	pApp->OnCmdMsg( IDM_RUN_STOPDEBUGGING,0,0,0);
	QAPump( pApp );
	QADumpOutputWindow(szOutputLog);
}

static void QARunAutomation(CTheApp *pApp)
{
	HMODULE hIDEModule;
	hIDEModule = GetModuleHandle (szIdeModuleName);
	OutputWindowGetLine = (char *(*)(ULONG , ULONG *))GetProcAddress ( 
												hIDEModule, "OutputWindowGetLine");
	GetCurrentWorkingSet = (DWORD(*)(void))GetProcAddress (
												hIDEModule, "GetCurrentWorkingSet");
	ASSERT(GetCurrentWorkingSet != NULL);
	if (pApp->m_bPerfQA_WorkSet) 
		QACurrentWorkingSet("startup");
	hBuildSynch = CreateSemaphore( NULL, 0, 1, NULL);
	if (pApp->m_szPerfQA_Project == NULL)
		return;
	else
	{
		IProjectWorkspace *pInterface;
		pInterface = g_IdeInterface.GetProjectWorkspace();
		ASSERT(pInterface != NULL);
	    CDocument *pDoc;
		if (pApp->m_bPerfQA_WorkSet) 
		{
			QATrimWorkingSet();
			VERIFY(SUCCEEDED(pInterface->OpenWorkspace(&pDoc, pApp->m_szPerfQA_Project, FALSE);
			QACurrentWorkingSet("after project load");
		}
		else
		{
			VERIFY(SUCCEEDED(pInterface->OpenWorkspace(&pDoc, pApp->m_szPerfQA_Project, FALSE);
		}
		delete pApp->m_szPerfQA_Project;
	}
	QAPump( pApp );
	pApp->OnCmdMsg( ID_FILE_NEW_SOURCE,0,0,0);
	if(!QADoBuild(pApp, "buildfull.log"))
		return;
	QADoDebug(pApp, "debugfull.log");
	QARunUnderShell("minor.bat");
	if(!QADoBuild(pApp, "buildminor.log"))
		return;
	QADoDebug(pApp, "debugminor.log");
	QARunUnderShell("major.bat");
	if(!QADoBuild(pApp, "buildmajor.log"))
		return;
	QADoDebug(pApp, "debugmajor.log");
}


static void QACurrentWorkingSet(LPCTSTR str /* = NULL */)
{
	static LONG lCount = 0;
	FILE *outFile;
	DWORD current;
	current = (*GetCurrentWorkingSet)();
	current>>=10;
	switch(lCount++)
	{
	case 0:  /* startup.log in startup directory */
		outFile = fopen( "startup.log", "wt" );
		break;
	case 1:  /* workset.log in loaded project directory */
		outFile = fopen( "workset.log", "wt" );
		break;
	default: /* workset.log in loaded project directory */
		outFile = fopen( "workset.log", "at" );
		break;
	}
	if (!outFile) return;
	fprintf(outFile, "IDE working set size %s: %dKB\n", (str? str : "current"), current);
	fclose(outFile);
}

static BOOL QATrimWorkingSet()
{
	return SetProcessWorkingSetSize(
		GetCurrentProcess(),
		(DWORD)-1,
		(DWORD)-1
		);
}

///////////////////// End of testing code //////////////////////////////////
#endif  // PERF_MEASUREMENTS


void SushiRestoreKey(HKEY hKey, const CString& str)
{
#ifdef _WIN32
	if (!str.IsEmpty())
	{
	HANDLE hToken;
	TOKEN_PRIVILEGES tkp;

	if (!OpenProcessToken(GetCurrentProcess(),
			TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
			return;

	// Get the LUID for restore privilege
	if (!LookupPrivilegeValue(NULL, SE_RESTORE_NAME,
		&tkp.Privileges[0].Luid))
			return;

	tkp.PrivilegeCount = 1;  // one privilege to set
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		// Get restore privilege for this process.
	if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
		(PTOKEN_PRIVILEGES)NULL, 0))
			return;

		RegRestoreKey(hKey, str, 0);

		// Reset privilege.
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
	AdjustTokenPrivileges(hToken, FALSE, &tkp, 0,
		(PTOKEN_PRIVILEGES)NULL, 0);
	}
#endif
}

#ifdef _DEBUG

BOOL g_bFatalExit = FALSE;

#ifndef _WIN32
CATCHBUF fatalExitBuf;

int CTheApp::Run()
{
	ShowSplashScreen(FALSE);

	int nRet;
	if ((nRet = Catch(fatalExitBuf)) != 0)
	{
		g_bFatalExit = TRUE;
		m_pMainWnd->DestroyWindow();
		return nRet;
	}
	TipOfTheDay(TRUE);
	return CWinApp::Run();

}
#endif  /* !_WIN32 */
#endif  /* _DEBUG */


#ifdef _WIN32

#define WM_NCCARETBLINK 0x118   /* special message that causes problems */

extern BOOL g_bInvokedHelp;	// defined in initexit.cpp

int CTheApp::Run()
{
	if (!(m_bInvokedCommandLine && m_bRunInvisibly))
	{
		ShowSplashScreen(FALSE);
		((CMainFrame *)m_pMainWnd)->RebuildMenus();
		if (!m_jit.GetActive() && !m_fRunningMacro)
			TipOfTheDay(TRUE);
	}

	// Acquire and dispatch messages until a WM_QUIT message is received.
//      LONG lIdleCount = 0;
//      BOOL bMoreIdle = TRUE;
	HANDLE hDummyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	ASSERT(hDummyEvent);

	bEnableIdleToolbarUpdate = TRUE;


	// need to exit if invoked /make and no workspace loaded
	if (m_bInvokedCommandLine)
	{
		LPPROJECTWORKSPACE pProjSysIFace = g_IdeInterface.GetProjectWorkspace();
		BOOL bWorkspaceInit = ((pProjSysIFace != NULL) && (pProjSysIFace->IsWorkspaceInitialised() == S_OK));
        // if (pProjSysIFace != NULL) pProjSysIFace->Release();
		// can't release here

		if (g_bInvokedHelp)
		{
			WriteLog(NULL); // close stdout
			AfxGetMainWnd()->PostMessage(WM_CLOSE, 0L, 0);
		}
		else if (!bWorkspaceInit)
		{
			CString strOut;
			strOut.LoadString(IDS_ERR_NO_PROJECT_LOADED);
			WriteLog(strOut);
			WriteLog(NULL); // close stdout
			AfxGetMainWnd()->PostMessage(WM_CLOSE, 0L, 1);
		}
	}

#ifdef PERF_MEASUREMENTS
///////////////// Testing code for V4 perf release (fabriced)
	else if(m_bPerfQA_AutoRun)
	{
		QARunAutomation(this);
		QAPump(this);
		OnAppExit();
		PostQuitMessage(0);
	}
/////////////////////////////////////////////////////////////
#endif  // PERF_MEASUREMENTS

	MainLoop(hDummyEvent, FALSE, 0);

	// this should never have been set in this case.
	ASSERT(WaitForSingleObject(hDummyEvent, 0) == WAIT_TIMEOUT);

	CloseHandle(hDummyEvent);

	return ExitInstance();
}

#endif  /* _WIN32 */


#ifdef _DEBUG
int HeapTestCheck()
{
	return _heapchk();
}

static void HeapUseCheck()
{
	// Heap use diagnostics.
	static BOOL bHeapUseCheck = TRUE;
	static CMemoryState msCheck;
	static LPBYTE lpDummyData = NULL;       // ensure allocation dump stops

	// Adjust nCount in debugger to control debug output.
	static int nCount = 0;

	if (((CMainFrame*) theApp.m_pMainWnd)->MDIGetActive() != NULL)
		bHeapUseCheck = TRUE;
	else if (bHeapUseCheck)
	{
		bHeapUseCheck = FALSE;

		if (nCount > 1)
			msCheck.DumpAllObjectsSince();
		if (nCount > 0)
		{
			CMemoryState msNow, msDiff;
			msNow.Checkpoint();
			msDiff.Difference(msCheck, msNow);
			msDiff.DumpStatistics();

			delete lpDummyData;
			lpDummyData = new BYTE; // This will leak.
			msCheck.Checkpoint();
		}


#ifdef _TEST
		extern BOOL FillBufHeapUse(TCHAR *szBuf);

		TCHAR szBuf[256];
		FillBufHeapUse(szBuf);
		TRACE(szBuf);
#endif

	}
}
#endif
#ifdef METER_IDLE_TIME
#define STARTIDLETIMING	if (s_bIdleTime) g_IdleProcessingTime = ::GetTickCount();
#define STOPIDLETIMING	if (s_bIdleTime) g_IdleProcessingTime = ::GetTickCount() - g_IdleProcessingTime;
extern DWORD g_dwIdlePackageTime[];
extern DWORD g_IdleProcessingTime;
extern int g_idxIdlePackage;
extern BOOL s_bIdleTime;
BOOL TIMEDIDLE(CPackage *pPackage, LONG lCount)
{
	BOOL fRet;

	if (!s_bIdleTime)		// Fast in/out when not actually working
		return pPackage->OnIdle(lCount);

	g_dwIdlePackageTime[g_idxIdlePackage] = ::GetTickCount();
	fRet = pPackage->OnIdle(lCount);
	g_dwIdlePackageTime[g_idxIdlePackage] =
		::GetTickCount() - g_dwIdlePackageTime[g_idxIdlePackage];
	g_idxIdlePackage++;

	return fRet;
}
#else	//!METER_IDLE_TIME
#define TIMEDIDLE(pPackage, lCount) (pPackage->OnIdle(lCount))
#define STARTIDLETIMING
#define STOPIDLETIMING
#endif	//!METER_IDLE_TIME

BOOL CTheApp::OnIdle(long lCount)
{
#ifdef _DEBUG
#if 0 // display idle count
	{
		HWND hWnd = ((CMainFrame*)m_pMainWnd)->m_hWndMDIClient;
		HDC hDC = GetDC(hWnd);
		char szBuf [16];
		TextOut(hDC, 0, 0, szBuf, sprintf(szBuf, "%ld  ", lCount));
		ReleaseDC(hWnd, hDC);
	}
#endif
#endif

	// If a manager show is pending and a drag operation is in process,
	// idle processing may cause screen dirt.

	ASSERT(m_pMainWnd);
	if (((CMainFrame*) m_pMainWnd)->m_pManager != NULL &&
		((CMainFrame*) m_pMainWnd)->m_pManager->IsShowDelayed() &&
		::GetCapture() != NULL)
		return FALSE;

#if 1
	// don't allow idle processing for command-line builds
	if (m_bInvokedCommandLine && m_bRunInvisibly)
		return FALSE;
#endif

	BOOL bMore = FALSE;
	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*)m_packages.GetNext(pos);
		bMore |= ((pPackage->m_flags & PKS_IDLE)!= 0 &&
			TIMEDIDLE(pPackage, lCount));
	}

	m_bActivated = FALSE; // reset for next time

	STARTIDLETIMING
	switch(lCount)
	{
	case 0:
		if (m_bMenuDirty)
			((CMainFrame*) m_pMainWnd)->RebuildMenus();
		if (((CMainFrame*) m_pMainWnd)->m_pManager != NULL &&
			  ((CMainFrame*) m_pMainWnd)->m_pManager->NeedIdle())
			((CMainFrame*) m_pMainWnd)->m_pManager->IdleUpdateAvailableWnds();
		STOPIDLETIMING
		return TRUE;

	case 1:
		ASSERT_VALID(m_pMainWnd);
	    if (!m_pMainWnd->IsIconic())
	    {
			// Handle property sheet visibility.
			//
			PropPageIdle();
	    }
		StatusOnIdle();
		STOPIDLETIMING
		return TRUE;

	case 2:
		if (((CMainFrame*)m_pMainWnd)->m_dragDrop != NULL)
		{
			// if either the capture has been stolen
			// or we aren't the top app anymore, or the user has
			// the escape key pressed then abort
			// the drag and drop
			CWnd *capWnd = CWnd::GetCapture();
			CWnd *actWnd = CWnd::GetActiveWindow();

			// might be a floating window.
			while (actWnd != m_pMainWnd && actWnd != NULL)
				actWnd = actWnd->GetParent();

			if ((actWnd != m_pMainWnd) || (capWnd != m_pMainWnd) ||
				(GetAsyncKeyState(VK_ESCAPE) & 0x8000))
			{
				((CMainFrame*)m_pMainWnd)->m_dragDrop->AbortDrop();
				delete ((CMainFrame*)m_pMainWnd)->m_dragDrop;
				((CMainFrame*)m_pMainWnd)->m_dragDrop =  NULL;
			}
			else
				((CMainFrame*)m_pMainWnd)->m_dragDrop->IdleUpdate();
		}
		STOPIDLETIMING
		return TRUE;

	default:
		// Obviously you will need to increment the PRE_MFC_IDLE_PROCESSING_COUNT number
		// below if you add any additional idle time processing here.
		if (bMore | CWinApp::OnIdle(lCount - PRE_MFC_IDLE_PROCESSING_COUNT))
		{
			STOPIDLETIMING
			return TRUE;
		}
		// Update floating toolbar commands last.
		ASSERT(m_pMainWnd);
		if (bEnableIdleToolbarUpdate && ((CMainFrame*) m_pMainWnd)->m_pManager != NULL)
		{
			((CMainFrame*) m_pMainWnd)->m_pManager->IdleUpdate();
		}

#ifdef _DEBUG
		HeapUseCheck();
#endif
		STOPIDLETIMING
		return FALSE;
	}
}

BOOL CTheApp::MainLoop(HANDLE hEventEarlyOut, BOOL fPushed, ULONG uReason)
{
	if (!fPushed)
	{
		// This is the application's main loop.  Process messages until
		// WM_QUIT is found and then return.
		//
		return IdleAndPump(hEventEarlyOut);
	}
	else
	{
		// Process messages until we hit WM_QUIT or the component
		// manager tells us to stop.  Changed 12/11/96 by Mgrier
		// for bug 18092 in DevStudio '96 wherein the infoview was
		// executing embedded VB5 controls very slowly; evidently
		// someone is mistakenly doing work when the FContinueMessageLoop()
		// is called, so we make sure to call it before trying to
		// pump messages. -mgrier 12/11/96
		while ((m_pMsoStdCompMgr == NULL) || (m_pMsoStdCompMgr->FContinueMessageLoop(NULL)))
		{
			if (!IdleAndPump(0))
				return FALSE;
		}

		return TRUE;
	}
}

// Process a single message from the message queue or perform idle-time
// processing.  This function is a worker for MainLoop.
BOOL CTheApp::CmpMgrDoIdle()
{
    BOOL fMore = FALSE;

	if (m_pMsoStdCompMgr == NULL)
		return FALSE;
		
	// Disable OLE message filter dialogs while in idle
	//                      (VOID)m_crpMessageFilter->FEnableDialogs(FALSE);
	
    // give the components a chance to do periodic
    // idle processing.
    //
    ASSERT(m_pAppCmpHost != NULL);
    
    IMsoComponentHost * pCompHost = m_pAppCmpHost->GetIMsoComponentHost();
    ASSERT(pCompHost != NULL);
    
    if (m_pMsoStdCompMgr->FDoIdle(msoidlefPeriodic))
	fMore = TRUE;
    else if(!pCompHost->FContinueIdle())
	fMore = TRUE;

    // Let the high priority component have some time:
    else if (m_pMsoStdCompMgr->FDoIdle(msoidlefPriority))
	fMore = TRUE;
    else if(!pCompHost->FContinueIdle())
	fMore = TRUE;

    // And give everybody else a shot:
    else if (m_pMsoStdCompMgr->FDoIdle(msoidlefNonPeriodic))
		fMore = TRUE;

//                      (VOID)m_crpMessageFilter->FEnableDialogs(TRUE);
	
    return fMore;
}

// this is basically stolen from MFC with the changes ifndef'd.
BOOL CTheApp::PumpMessage()
{
	ASSERT_VALID(this);

#ifndef NOIPCOMP
	if (m_pMsoStdCompMgr != NULL)
		m_pMsoStdCompMgr->OnWaitForMessage();
#endif

	if (!::GetMessage(&m_msgCur, NULL, NULL, NULL))
	{
#ifdef _DEBUG
		if (afxTraceFlags & traceAppMsg)
			TRACE0("CTheApp::PumpMessage - Received WM_QUIT.\n");
		m_nDisablePumpCount++; // application must die
			// Note: prevents calling message loop things in 'ExitInstance'
			// will never be decremented
#endif
		return FALSE;
	}

#ifdef _DEBUG
	if (m_nDisablePumpCount != 0)
	{
		TRACE0("Error: CTheApp::PumpMessage called when not permitted.\n");
		ASSERT(FALSE);
	}
#endif

	// process this message, and give component manager to handle it.
	// Note: Our CMainFrame is managed as a IMsoComponent, and registered with the component manager.
	// The implementation of CTheApp::PreTranslateMessage will be called when  
	// the component manager calls back to our IMsoComponent::FPreTranslateMessage.  
	// CIPCompMainFrame which the CMainFrame holds an AddRef pointer to, implements IMsoComponent.
	if (m_msgCur.message != WM_KICKIDLE 
#ifndef NOIPCOMP
		&& (m_pMsoStdCompMgr == NULL || 
			(m_pMsoStdCompMgr && !m_pMsoStdCompMgr->FPreTranslateMessage(&m_msgCur))))
#else
		&& !PreTranslateMessage(&m_msgCur))
#endif
	{
		::TranslateMessage(&m_msgCur);
		::DispatchMessage(&m_msgCur);
	}
	return TRUE;
}

// extern HANDLE g_hStdIn; // defined in initexit.cpp

BOOL CTheApp::IdleAndPump(HANDLE hEventEarlyOut /* =0 */)
{
	if ( hEventEarlyOut == 0 )
	{
		// do a one shot message
		LONG lIdleCount = 0;
		// check to see if we can do idle work
		while (m_msgCur.message != WM_NCCARETBLINK &&
			!::PeekMessage(&m_msgCur, NULL, NULL, NULL, PM_NOREMOVE) &&
#ifndef NOIPCOMP
			CmpMgrDoIdle())
#else
			OnIdle(lIdleCount))
#endif
		{
			// more work to do
			lIdleCount++;
		}

		// either we have a message, or OnIdle returned false

		return PumpMessage();
	}
	else
	{
		// loop until someone resets our early out flag or we receive WM_QUIT

		// it is important to start bMoreIdle at FALSE so that we don't
		// get an idle cycle whenever someone pushes a pump.  This happens
		// during builds after each spawn in particular [rm]

		LONG lIdleCount = 0;
		BOOL bMoreIdle = FALSE;
		for ( ; WaitForSingleObject(hEventEarlyOut, 0) == WAIT_TIMEOUT; )
		{
			if (bMoreIdle)
			{
				// check to see if we can do idle work
				while (!::PeekMessage(&m_msgCur, NULL, NULL, NULL, PM_NOREMOVE) &&
#ifndef NOIPCOMP
			(bMoreIdle = CmpMgrDoIdle())) 
#else
			(bMoreIdle = OnIdle(lIdleCount)))
#endif
				{
					// more work to do
					lIdleCount++;
				}
			}

#if 0
			if (m_bInvokedCommandLine /* && bSpawnActive */ /* UNDONE */)
			{
				// poll stdin for a ctrl-c
				char buffer[80];
				DWORD i, nBytesRead, nBytesAvail, nBytesLeft;
				if ((g_hStdIn != NULL) && (::PeekNamedPipe(g_hStdIn, buffer, 1, &nBytesRead, &nBytesAvail, &nBytesLeft)) && (nBytesRead > 0))

				{
					if (nBytesAvail > 80)
						nBytesAvail = 80;

					if (::ReadFile(g_hStdIn, buffer, nBytesAvail, &nBytesRead, NULL))
					{
						for (i = 0; i < nBytesRead; i++)

						{

							if (buffer[i] == '')
							{
								AfxGetMainWnd()->PostMessage(WM_COMMAND, IDM_PROJECT_STOP_BUILD);
								break;
							}
						}
					}
				}
			}
#endif
			// either we have a message, or OnIdle returned false

			if (!PumpMessage()) // this will block if no messages
				break;

			bEnableIdleToolbarUpdate = TRUE;
			if ( IsIdleMessage(&m_msgCur) )
			{
				bMoreIdle = TRUE;
				lIdleCount = 0;
			}
		}
	}
	return TRUE;
}

BOOL CTheApp::IsIdleMessage(MSG * pMsg)
{
	BOOL    fRet = TRUE;    // default return value is to kick idle into gear

	switch (pMsg->message)
	{
	// These messages DO NOT reset the idler..
	case WM_NCCARETBLINK:
	case WM_PAINT:
	case WM_TIMER:
	case WM_MOUSEMOVE:
	case WM_NCMOUSEMOVE:
	case WM_NULL:
		fRet = FALSE;
		break;

	case WM_KEYDOWN:
		if ((m_msgCur.lParam & 0x40000000L) )
		{
			//Don't reset for repeated keydown messages
			fRet = FALSE;
		}
		break;

	default:
		// Indicate messages that reset the idler
		break;

	}
	if(fForceIdleCycle)
	{
		fRet = TRUE;
		fForceIdleCycle = FALSE;
	}
	return fRet;
}

// Like CWinApp::OpenDocumentFile, but has option to open file via ShellExecute
CDocument* CTheApp::OpenDocumentFileEx(LPCSTR lpszFilename, BOOL bTryShellToo)
{
//      if( !bTryShellToo )
//              return OpenDocumentFile(lpszFilename);

	// NOTE: The following code is mostly copied directly from appui.cpp in
	// the MFC sources (some version a while ago).
    // The only difference is that after iterating through all the templates,
    // if the confidence level is not perfect (CDocTemplate::yesAttemptNative)
	// then we try to use ShellExecute to open the file.

	// find the highest confidence
	POSITION pos = GetFirstDocTemplatePosition();
	CDocTemplate::Confidence bestMatch = CDocTemplate::noAttempt;
	CDocument* pOpenDocument = NULL;

	// Fully qualify the path, if possible
	CPath path;

    LPCTSTR pszPath = NULL;
	if (path.Create(lpszFilename))
	    pszPath = path.GetFullPath();
    if (NULL == pszPath || !*pszPath)
	pszPath = lpszFilename;
	while (pos)
	{
		CDocTemplate* pTemplate = GetNextDocTemplate(pos);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

		CDocTemplate::Confidence match;
		ASSERT(pOpenDocument == NULL);
		match = pTemplate->MatchDocType(pszPath, pOpenDocument);
		if (match > bestMatch)
			bestMatch = match;
		if (match == CDocTemplate::yesAlreadyOpen)
		{
			// Dolphin #1946 [mannyv] need to go through OpenDocumentFile
			// to handle activation of open window
			return OpenDocumentFile(pszPath);
		}
	}

	// if the match confidence is not perfect, try ShellExecute
	if( bTryShellToo && bestMatch <= CDocTemplate::maybeAttemptForeign /*&& *path.GetExtension()*/ )
	{
		int iRet;

		iRet = (int) ShellExecute( m_pMainWnd->m_hWnd, NULL, pszPath, NULL, NULL, SW_SHOWNORMAL);
		if( iRet != SE_ERR_NOASSOC )
		{
			if (iRet == ERROR_FILE_NOT_FOUND ||
				iRet == ERROR_PATH_NOT_FOUND) {
				CString strError;
				CPath path;

				path.Create (pszPath);

				CString strErrMsg;
				VERIFY( strErrMsg.LoadString( IDS_CANNOTOPEN ) );
				MsgBox (Error, MsgText (strError, path, strErrMsg, &CFileException(iRet== ERROR_FILE_NOT_FOUND ? CFileException::fileNotFound : CFileException::badPath)));
				}
			// It either worked or failed for some funky reason.  In either case, we don't
			// try the templates again.
			return NULL;
		}
	}

	// try old OpenDocumentFile
	//return OpenDocumentFile(pszPath);
    return OpenDocumentFile(lpszFilename);
}

CPartFrame* CTheApp::GetOpenFrame(LPCSTR lpszFilename,
	CDocTemplate*& pTemplate, CDocument*& pDoc)
{
	CDocument* pOpenDoc;
	CDocTemplate* pOpenTemplate = GetOpenTemplate(lpszFilename, pOpenDoc);
	if (pOpenTemplate == NULL)
		return NULL;

	POSITION pos = pOpenDoc->GetFirstViewPosition();
	if (pos == NULL)
		return NULL;

	CView* pView = pOpenDoc->GetNextView(pos);
	if (pView == NULL)
		return NULL;

	CPartFrame* pFrame = (CPartFrame*) pView->GetParentFrame();
	if (pFrame == NULL || !pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
		return NULL;

	pTemplate = pOpenTemplate;
	pDoc = pOpenDoc;

	return pFrame;
}

HWND CTheApp::GetActiveView()
{
	if (CDockWorker::s_pActiveDocker != NULL)
	{
		CView* pView = CDockWorker::s_pActiveDocker->GetView();

		return pView->GetSafeHwnd();
	}
	else
	{
		CPartFrame *pFrame = (CPartFrame*)((CMDIFrameWnd *)m_pMainWnd)->MDIGetActive();

		if (pFrame == NULL || !pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
			return (HWND) NULL;

		CPartView *pSView = (CPartView *)pFrame->GetActiveView();
		if(pSView)
		{
			ASSERT_VALID (pSView);
			ASSERT (pSView->IsKindOf(RUNTIME_CLASS(CPartView)));
		}

		return pSView->GetSafeHwnd();
	}
}

void CTheApp::SetActiveView(HWND hwndView)
{
	CWnd* pWnd = CWnd::FromHandle(hwndView);
	CWnd* pWndParent = pWnd->GetParentFrame();

	if (pWndParent == NULL)
		return;

	if (pWndParent->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)))
	{
		CMDIChildWnd* pFrame = (CMDIChildWnd*) pWndParent;
		pFrame->ActivateFrame();

		if (pWnd->IsKindOf(RUNTIME_CLASS(CView)))
			pFrame->SetActiveView((CView*) pWnd, !CPartFrame::s_bLockFrame);
	}
	else if (pWndParent->IsKindOf(RUNTIME_CLASS(CPaletteWnd)))
	{
		// Bring the palette to the top of palette z-order, and set focus.
		((CPaletteWnd*) pWndParent)->ActivateNoFocus();

		pWnd->SetFocus();
	}
	else
	{
		// This must be a docked view.
		pWnd->SetFocus();
	}
}

void CTheApp::ReactivateView()
{
	if (CDockWorker::s_bLockDocker)
	{
		ASSERT(CDockWorker::s_pActiveDocker != NULL &&
			CDockWorker::s_pActiveDocker->m_pWnd != NULL);
		CDockWorker::s_pActiveDocker->m_pWnd->SetFocus();
	}
	else
	{
		m_pMainWnd->SetFocus();
	}
}

//      CTheApp::GetTemplate
//              Return the template given its CLSID
CPartTemplate* CTheApp::GetTemplate(REFCLSID clsid)
{
	POSITION pos = GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		CPartTemplate* pTemplate = (CPartTemplate*)GetNextDocTemplate(pos);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
		// REVIEW: this is very, very bad performance-wise
		if (IsEqualGUID(pTemplate->GetTemplateClsid(), clsid))
			return pTemplate;
	}

	return NULL;
}

//      CTheApp::GetTemplate
//              Return the template given its automation type string
//   This is used in the implementation of Documents::Add.
CPartTemplate* CTheApp::GetTemplate(LPCTSTR szType)
{
	if (szType == NULL || !*szType)
		return NULL;

	POSITION pos = GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		CPartTemplate* pTemplate = (CPartTemplate*)GetNextDocTemplate(pos);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
		// REVIEW: this is very, very bad performance-wise
		if (!_tcsicmp(pTemplate->GetTemplateAutomationType(), szType))
			return pTemplate;
	}

	return NULL;
}


//      CTheApp::GetOpenTemplate
//              Give the path name, return the template and document for the open
//              file with this path name, if it is open.
CPartTemplate* CTheApp::GetOpenTemplate(LPCTSTR lpszPathName, CDocument*& pDoc)
{
	// Fully qualify path
	CPath path;
	if (!path.Create(lpszPathName))
		return NULL;

	LPCTSTR lpszFullPath = path.GetFullPath();

	CDocument* pOpenDoc;
	CPartTemplate* pOpenTemplate;

	POSITION pos = GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		pOpenTemplate = (CPartTemplate*)GetNextDocTemplate(pos);
		if (!pOpenTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)))
			continue;

		// We use the base CDocTemplate::MatchDocType because we are only interested
		// in whether the file is open.  Otherwise we would run through a lot of
		// file reading code that we don't care about.

		if (pOpenTemplate->CDocTemplate::MatchDocType(lpszFullPath, pOpenDoc)
			== CDocTemplate::yesAlreadyOpen)
		{
			pDoc = pOpenDoc;

			// When we use proxy templates, the template that opened and owns
			// the document might not be the one that truly reflects its type.
			CPartTemplate* pProxyTemplate = (CPartTemplate*)
				((CPartDoc*)pDoc)->GetDocLong(GDL_PROXYTEMPLATE);

			if(pProxyTemplate == NULL)
				return pOpenTemplate;
			else
				return pProxyTemplate;
		}
	}

	return NULL;
}

BOOL CTheApp::PreTranslateMessage(MSG* pMsg)
{
	// these messages don't get pre-translated because it helps
	// keep our working set down during a build [rm]
	switch (pMsg->message) {
		case WM_TIMER:
		case WM_NULL:
		case WM_NCCARETBLINK:
				return FALSE;
	}

#ifdef _DEBUG
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F12 &&
		(GetKeyState(VK_CONTROL) & ~1) != 0 &&
		(GetKeyState(VK_MENU) & ~1) != 0)
	{
		// Break on Ctrl+Alt+F12 so we can JIT Debug.
		AfxDebugBreak();
	}
#endif

	CPackage* pActiveUI = NULL;
	if (CDockWorker::s_pActiveDocker != NULL)
	{
		pActiveUI = GetPackage(CDockWorker::s_pActiveDocker->m_nIDPackage);
		ASSERT(pActiveUI != NULL);
	}
	else
	{
		// Give each package a chance to PreTranslate the message, but the
		// "active" package gets first crack...
		CMDIChildWnd* pActiveFrame;
		ASSERT(m_pMainWnd != NULL);
		if (m_pMainWnd != NULL && (pActiveFrame = ((CMDIFrameWnd*)m_pMainWnd)->MDIGetActive()) != NULL)
		{
			CDocument* pActiveDoc = pActiveFrame->GetActiveDocument();
			if (pActiveDoc != NULL &&
				pActiveDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)))
			{
				pActiveUI = ((CPartDoc*)pActiveDoc)->GetPackage();
			}
		}
	}

	if (pActiveUI != NULL && pActiveUI->PreTranslateMessage(pMsg))
		return TRUE;

	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*)m_packages.GetNext(pos);
		if (pPackage != pActiveUI &&
			(pPackage->m_flags & PKS_PRETRANSLATE) != 0 &&
			pPackage->PreTranslateMessage(pMsg))
		{
			return TRUE;
		}
	}

	if (CWinApp::PreTranslateMessage(pMsg))
		return TRUE;

	return FALSE;
}

CPacket* CTheApp::GetPacket(UINT idPackage, UINT idPacket, BOOL bActivate /* =FALSE */)
{
	// Search the Packet list to find the specified one.  If the user
	// requested bActivate, then we will activate the packet (by
	// bringing it to the front of the list) if we find it.
	CPacket* pPacket;
	POSITION pos = m_packets.GetHeadPosition();
	while (pos != NULL)
	{
		pPacket = (CPacket*) m_packets.GetNext(pos);
		if ((pPacket->PacketID() == idPacket) && (pPacket->PackageID() == idPackage))
		{
			// found the right one
			if (bActivate)
				SetActivePacket(pPacket);

			return pPacket;
		}
	}

	if (bActivate)
		SetActivePacket(NULL);

	return NULL;
}

BOOL CTheApp::DeactivatePacket()
{
	SetActivePacket(NULL);
	return TRUE;
};

void CTheApp::SetActivePacket(CPacket* pPacket)
{
	TRACE("CTheApp::SetActivePacket: 0x%08x\n", pPacket);
	if (m_pActivePacket == pPacket)
	{
		// If the packet menu is not currently being used, then it needs
		// to be rebuilt and made the active menu.  (switch from OLE UI active).

		if (GetMenu(m_pMainWnd->GetSafeHwnd()) != ((CMainFrame*)m_pMainWnd)->m_hMenuDefault)
			m_bMenuDirty = TRUE;

		return;
	}

	m_pActivePacket = pPacket;
	m_bMenuDirty = TRUE;

	DkUpdateAvailableWnds();        // Delayed

	ASSERT_VALID(m_pMainWnd);
	if (pPacket)
		((CMainFrame*) m_pMainWnd)->m_statusBar.SetIndicators(pPacket->m_pSushiBarInfo);
	else
		((CMainFrame*) m_pMainWnd)->m_statusBar.SetIndicators();

}

void CTheApp::UnloadPackageBitmaps()
{
	CPackage* pPackage;

	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*) m_packages.GetNext(pos);
		pPackage->UnloadBitmap();
	}
}

#ifdef _DEBUG
void CTheApp::PrintCommandTables()
{
	theCmdCache.PrintCommandTable();
}
#endif

UINT CTheApp::GetCommandBtnInfo(UINT nCommand, CPackage** ppPackage)
{
	*ppPackage = NULL;
	if (nCommand == ID_SEPARATOR)
		return TBBS_SEPARATOR;

	CTE* pCTE = theCmdCache.GetCommandEntry(nCommand);
	// package is missing
	if (pCTE == NULL)
	{
		return TBBS_INVISIBLE;
	}

	// package is present, but has disabled command
	if((pCTE->flags & CT_NOUI) != 0)
	{
		return TBBS_INVISIBLE;
	}

	ASSERT(pCTE->GetFirstPack() != NULL);
	*ppPackage = pCTE->GetFirstPack()->GetPackage();
	if ((pCTE->flags & CT_HWND) == 0)
	{
		if(pCTE->flags & CT_MENU)
		{
			return TBBS_TEXTUAL | TBBS_MENU;
		}

		if(pCTE->flags & CT_TEXTBUTTON)
		{
			return TBBS_BUTTON | TBBS_TEXTUAL;
		}

		BOOL bHasGlyph=HasCommandBitmap(nCommand);

		if(bHasGlyph)
		{
			return TBBS_BUTTON | TBBS_GLYPH;
		}
		else
		{
			return TBBS_BUTTON | TBBS_TEXTUAL;
		}
	}

	UINT nFlags = TBBS_HWND;

	if (pCTE->flags & CT_HWNDSIZE)
	{
		nFlags |= TBBS_SIZABLE;
	}

	if (pCTE->flags & CT_HWNDENABLE)
	{
		nFlags |= TBBS_ENABLEWND;
	}

	if(pCTE->flags & CT_TEXTBUTTON)
	{
		nFlags |= TBBS_TEXTUAL;
	}
	else
	{
		nFlags |= TBBS_GLYPH;
	}

	return nFlags;
}

// This function is used to find the bitmap and glyph index for a given command (nID),
// It returns true if the command could be found. If pCTE is non-null, it should point to the
// the CTE of nID; this is a simple optimisation.
BOOL CTheApp::GetCommandBitmap(UINT nID, /* OUT */ HBITMAP *phbmWell, /* OUT */ int *pnGlyph, /* IN */ BOOL bLarge, /* IN */ CTE *pCTE)
{
	// If we don't already know the cte, then find it
	if(pCTE==NULL)
	{
		pCTE=theCmdCache.GetCommandEntry(nID);
	}
	else
	{
		// otherwise, verify it.
		ASSERT(pCTE->id==nID);
	}

	HBITMAP hbmWell=NULL;
	int nGlyph=-1;
	CPackage *pPackage=NULL;

	if(     pCTE &&
		pCTE->GetFirstPack() &&                                                                 // should never fail 
		(pPackage=pCTE->GetFirstPack()->GetPackage())!=NULL)    // nor should this. All commands must have at least one pack, which must have a package.
	{
		ICommandProvider *pCP=pPackage->GetCommandProvider();
		if(pCP)
		{
			DWORD nLongGlyph;
			hbmWell=pCP->GetBitmap((WORD)nID, bLarge, &nLongGlyph);

			ASSERT(sizeof(long)==sizeof(int));

			// GetBitmap doesn't setup nLongGlyph except when it returns a bitmap, so we only copy it then
			if(hbmWell)
			{
				nGlyph=nLongGlyph;
			}

			pCP->Release();
		}

		if(nGlyph==-1)
		{
			if(phbmWell)
			{
				hbmWell=pPackage->GetBitmap(bLarge);
			}
			nGlyph = (int)(short)pCTE->glyph; // WORD to INT...fix -1 case.
		}

#ifdef _DEBUG
		// ensure that the glyph number isn't outside the valid range for the package
		BITMAP bmpInfo;
		if(hbmWell!=NULL)
		{
			CSize sizeGlyph=CCustomBar::GetDefaultBitmapSize(bLarge);

			::GetObject(hbmWell,sizeof(BITMAP), &bmpInfo);

			int nGlyphs=bmpInfo.bmWidth/sizeGlyph.cx;

			// If this fails then the button hasn't been correctly added to the bar, or
			// the .cmd file has the wrong glyph index.
			ASSERT(nGlyph<nGlyphs);
		}
#endif

	}

	BOOL bHasGlyph=(nGlyph!=-1);
	if(phbmWell)
	{
		*phbmWell=hbmWell;
	}
	if(pnGlyph)
	{
		*pnGlyph=nGlyph;
	}

	return bHasGlyph;
}

LPDISPATCH CTheApp::GetPackageExtension(LPCTSTR szExtensionName)
{
	LPDISPATCH pDispReturn = NULL;
	CPackage* pPackage;
	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*) m_packages.GetNext(pos);
		if ((pPackage->m_flags & PKS_AUTOMATION) == 0)
			continue;

		if ((pDispReturn = pPackage->GetPackageExtension(szExtensionName))
				!= NULL)
		{
			return pDispReturn;
		}
	}
	return NULL;
}

HRESULT CTheApp::FindInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	CPackage* pPackage;
	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*) m_packages.GetNext(pos);
		if ((pPackage->m_flags & PKS_INTERFACES) == 0)
			continue;

		HRESULT hr = pPackage->ExternalQueryInterface(&riid, ppvObj);
		if (SUCCEEDED(hr))
			return hr;
	}

	*ppvObj = NULL;
	return ResultFromScode(E_NOTIMPL);
}

HRESULT CTheApp::GetService(REFGUID guidService, REFIID riid, void **ppvObj)
{
	if(NULL == ppvObj)
		return E_INVALIDARG;

	*ppvObj = NULL;

	// if the guid is NULL, then pass it off to
	// find interface
	if(CLSID_NULL == guidService)
		return FindInterface(riid, ppvObj);
	else if(SID_SMsoComponentManager == guidService)
	{
		IUnknown *punk = ((CMainFrame *)AfxGetMainWnd())->GetComponentMgr();
		ASSERT(NULL != punk);
		return punk->QueryInterface(riid, ppvObj);
	}
	else if(SID_SBuilderWizardManager == guidService)
	{
		// theInternalApp is a global object
		// GetBuilderWizardManager returns a non addref'ed pointer
		CBuilderWizardManager *pBWM = theInternalApp.GetBuilderWizardManager();
		ASSERT(NULL != pBWM);
		return pBWM->ExternalQueryInterface(&riid, ppvObj); 
	}
	else if(SID_SApplicationObject == guidService)
	{
		ASSERT(NULL != theApp.m_pAutoApp);
		return theApp.m_pAutoApp->ExternalQueryInterface(
						&riid, (void**)ppvObj);
	}

	// walk through each package and see if one supports the service
	CPackage* pPackage;
	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*) m_packages.GetNext(pos);
		if ((pPackage->m_flags & PKS_INTERFACES) == 0)
			continue;

		HRESULT hr = pPackage->GetService(guidService, riid, ppvObj);
		if(SUCCEEDED(hr))
			return hr;
	}

	return E_NOINTERFACE;
}

HRESULT CTheApp::DoesIntrinsicBuilderExist(REFGUID rguidBuilder)
{
	// validate parameters
	ASSERT(CLSID_NULL != rguidBuilder);
	if(CLSID_NULL == rguidBuilder)
		return E_INVALIDARG;
	
	// walk through each package and see if one supports the service
	COleRef<IBuilderWizardManager> srpBWM;
	HRESULT hr;
	CPackage* pPackage;
	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*) m_packages.GetNext(pos);
		if ((pPackage->m_flags & PKS_INTERFACES) == 0)
			continue;

		hr = pPackage->GetService(SID_SIntrinsicBuilderWizardManager, 
								IID_IBuilderWizardManager, (void**)&srpBWM);
		if(SUCCEEDED(hr))
		{
			hr = srpBWM->DoesBuilderExist(rguidBuilder);
			srpBWM.SRelease();
			if(S_OK == hr)
				return hr;
		}
	}
	return S_FALSE;
}

HRESULT CTheApp::GetIntrinsicBuilder(
	REFGUID rguidBuilder, 
	DWORD grfGetOpt, 
	HWND hwndPromptOwner, 
	IDispatch **ppdispApp,
	HWND *pwndBuilderOwner, 
	REFIID riidBuilder, 
	IUnknown **ppunkBuilder)
{
	ASSERT(CLSID_NULL != rguidBuilder);
	ASSERT(NULL != ppunkBuilder);
	if(CLSID_NULL == rguidBuilder || NULL == ppunkBuilder)
		return E_INVALIDARG;

	if(NULL != ppdispApp)
		*ppdispApp = NULL;
	if(NULL != pwndBuilderOwner)
		*pwndBuilderOwner = NULL;
	*ppunkBuilder = NULL;

	// walk through each package and see if one supports the service
	COleRef<IBuilderWizardManager> srpBWM;
	HRESULT hr;
	CPackage* pPackage;
	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*) m_packages.GetNext(pos);
		if ((pPackage->m_flags & PKS_INTERFACES) == 0)
			continue;

		hr = pPackage->GetService(SID_SIntrinsicBuilderWizardManager, 
								IID_IBuilderWizardManager, (void**)&srpBWM);
		if(SUCCEEDED(hr))
		{
			hr = srpBWM->GetBuilder(rguidBuilder, grfGetOpt, 
							hwndPromptOwner, ppdispApp, pwndBuilderOwner, 
							riidBuilder, ppunkBuilder);
			srpBWM.SRelease();
			if(SUCCEEDED(hr))
				return hr;
		}
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

UINT SushiRegisterWindowMessage(const char* szMsg)
{
	UINT nMsg = RegisterWindowMessage(szMsg);
#if 0
	TRACE("::SushiRegisterWindowMessage: Message '%s' is 0x%04x (WM_USER+%d)\n",
		szMsg, nMsg, nMsg - WM_USER);
#endif
	return nMsg;
}

#endif

///////////////////////////////////////////////////////////////////////////////

BOOL CTheApp::OnDDECommand(TCHAR *pszCommand)
{
	while (_istspace(*pszCommand))
		pszCommand = _tcsinc(pszCommand);

	BOOL bBracketed;
	if (bBracketed = (*pszCommand == '['))
		pszCommand = _tcsinc(pszCommand);

	while (_istspace(*pszCommand))
		pszCommand = _tcsinc(pszCommand);

	char* pchOpcode = pszCommand;
	char ch;
	while ((ch = *pszCommand) != '\0')
	{
		if (_istspace(ch) || ch == ',' || ch == '(' || ch == ')' || ch == '"')
			break;

		pszCommand = _tcsinc(pszCommand);
	}

	CString strOpcode(pchOpcode, (int)(pszCommand - pchOpcode));

	while (_istspace(*pszCommand))
		pszCommand = _tcsinc(pszCommand);

	CStringArray parameters;
	while (*pszCommand == ((parameters.GetSize() == 0) ? '(' : ','))
	{
		pszCommand = _tcsinc(pszCommand);

		while (_istspace(*pszCommand))
			pszCommand = _tcsinc(pszCommand);

		if (*pszCommand == '\0')
		{
			TRACE("Unexpected end of DDE_EXECUTE string\n");
			return FALSE;
		}

		if (*pszCommand == ')')
		{
			pszCommand = _tcsinc(pszCommand);
			break;
		}

		BOOL bQuoted;
		if (bQuoted = (*pszCommand == '"'))
			pszCommand = _tcsinc(pszCommand);

		char* pchParameter = pszCommand;
		while ((ch = *pszCommand) != '\0')
		{
			if (ch == '"')
				break;

			if (ch == ',' || ch == '(' || ch == ')' || ch == '[' || ch == ']')
			{
				if (!bQuoted)
					break;

				if (ch != ',')
				{
					// Within quotes, parentheses and brackets must be doubled
					if (*(pszCommand + 1) != ch)
						break;
					pszCommand = _tcsinc(pszCommand);
				}
			}

			pszCommand = _tcsinc(pszCommand);
		}

		CString strParam(pchParameter, (int)(pszCommand - pchParameter));

		if (bQuoted != (ch == '"'))
		{
			TRACE("Mismatched quote in DDE_EXECUTE string\n");
			return FALSE;
		}

		if (ch == '"')
		{
			pszCommand = _tcsinc(pszCommand);
			while (_istspace(*pszCommand))
				pszCommand = _tcsinc(pszCommand);
		}

		parameters.Add(strParam);
	}

	///////////////////////////////////

#ifdef _DEBUG
	TRACE("DDE_EXECUTE: op-code = '%s'\n", (const char*)strOpcode);
	for (int i = 0; i < parameters.GetSize(); i += 1)
		TRACE("\t%d:%s\n", i + 1, (const char*)parameters[i]);
#endif

	///////////////////////////////////

	// DDE 'open' command?
	if (strOpcode.CompareNoCase("open") == 0)
	{
		if (parameters.GetSize() != 1)
		{
			TRACE("Illegal parameters for DDE_EXECUTE 'open' command\n");
			return FALSE;
		}

		// only open the document from DDE 'open' if it 
		// isn't already open
		CPath path;
		if (!path.Create(parameters[0]))
		{
			TRACE("Illegal pathname '%s' for DDE_EXECUTE 'open' command\n", (const char*)parameters[0]);
			return FALSE;
		}

		m_pMainWnd->OpenIcon();
		m_pMainWnd->SetForegroundWindow();
		OpenDocumentFile((const TCHAR *)path);
		return TRUE;
	}

	TRACE("Unknown DDE_EXECUTE op-code: '%s'\n", (const char*)strOpcode);
	return FALSE;
}

UINT g_cPendingMessages = 0;

void CTheApp::FlashStatePump()
{
	ASSERT(!theApp.m_fVCPPIsActive || m_pMainWnd->IsIconic());
	static BOOL fFlashTimerDead;
	CMainFrame* pMainWnd = (CMainFrame *) m_pMainWnd;  // For casting only

	// If we're not flashing, start.

	if (m_cActiveFlashPumps == 0)
	{
		pMainWnd->FlashWindow(FALSE);
		m_nTimerID = pMainWnd->SetTimer(IDT_WINDOW_FLASH, 500, NULL);
		fFlashTimerDead = FALSE;
	}
	m_cActiveFlashPumps++;

	// Pump the message queue from here until we become active
	BOOL    fIconic;

	while((fIconic = pMainWnd->IsIconic()) || !theApp.m_fVCPPIsActive)
	{
		// only do idle processing if we are visible
		// dolphin:#4435, msgbox while we are loading an last project and we are
		//      minimized, thereby starting a flashpump, but the project is not yet
		//      fully loaded, leading to problems in the idle processing.
		if (fIconic)
		{
			if (!PumpMessage())
			{
				// repost the quit so we get it in the underlying msg pump
				PostQuitMessage(m_msgCur.message == WM_QUIT ? m_msgCur.wParam : 0);
				break;
			}
		}
		else
			IdleAndPump();
	}

	// Kill the window flash timer on the first message box

	if (!fFlashTimerDead)
	{
		VERIFY(pMainWnd->KillTimer(m_nTimerID));
		pMainWnd->FlashWindow(TRUE);
		fFlashTimerDead = TRUE;
	}

	m_cActiveFlashPumps--;
	return;
}

// get parent window for modal dialogs and message boxes.
// never uses floating window.
HWND PASCAL _SushiGetSafeOwner(CWnd* pParent)
{
	if (pParent != NULL)
	{
		ASSERT_VALID(pParent);
		return pParent->m_hWnd;
	}
	HWND hWnd = AfxGetApp()->m_pMainWnd->GetSafeHwnd();
	if (hWnd != NULL)
	{
		HWND hWndParent;
		while ((hWndParent = ::GetParent(hWnd)) != NULL)
			hWnd = hWndParent;
		hWnd = ::GetLastActivePopup(hWnd);

		// If it is a floating window, use the main window
		// unless it's the property sheet.
		// N.B.  The two kind of floating windows that we
		// detect here are the mini frame windows (dockables) [bm]
		// and the browser window popup which is a CFloatingFrameWnd
		// derived class [rm]
		//
		CWnd* pWnd = CWnd::FromHandle(hWnd);
		if (pWnd != (CWnd *)GetPropertyBrowser() &&
			(pWnd->IsKindOf(RUNTIME_CLASS(CMiniFrameWnd)) ||
			 pWnd->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd)) ||
			 pWnd == PwndSplashScreen()))
			hWnd = AfxGetApp()->m_pMainWnd->GetSafeHwnd();
	}
	return hWnd;
}

// Ripped from MFC so we can do our own GetSafeOwner that excludes
// Dockable windows, return focus to dockable windows.
int CTheApp::DoMessageBox(LPCSTR lpszPrompt, UINT nType, UINT nIDPrompt)
{
	HWND hWnd = _SushiGetSafeOwner(NULL);

	DWORD dwOldPromptContext = m_dwPromptContext;
	if (nIDPrompt != 0)
		m_dwPromptContext = HID_BASE_PROMPT+nIDPrompt;

	if ((nType & MB_ICONMASK) == 0)
	{
		switch (nType & MB_TYPEMASK)
		{
		case MB_OK:
		case MB_OKCANCEL:
		case MB_YESNO:
		case MB_YESNOCANCEL:
			nType |= MB_ICONEXCLAMATION;
			break;

		case MB_ABORTRETRYIGNORE:
		case MB_RETRYCANCEL:
			// No default icon for these types, since they are rarely used.
			// The caller should specify the icon.
			break;
		}
	}

#ifdef _DEBUG
	if ((nType & MB_ICONMASK) == 0)
		TRACE0("Warning: no icon specified for message box.\n");
#endif

	PreModalWindow();
	EnableModeless(FALSE);
	int nRet = ::MessageBox(hWnd, lpszPrompt, m_pszAppName, nType);
	EnableModeless(TRUE);
	PostModalWindow();

	m_dwPromptContext = dwOldPromptContext;
	return nRet;
}

// Build Notification:
BOOL CTheApp::NotifyPackages(UINT id, void *Hint /*= NULL*/,
	void *ReturnArea /*= NULL*/)
{
#ifdef PERF_MEASUREMENTS
///////////// Testing code for V4.X perf release (fabriced)
	if(id == PN_END_BUILD )
		ReleaseSemaphore( hBuildSynch, 1, NULL);
	else if(id== PN_BEGIN_BUILD)
		fBuildStarted = TRUE;
/////////////////////////////////////////////////////////////
#endif  // PERF_MEASUREMENTS
	fForceIdleCycle = TRUE;
	if (id == PN_WORKSPACE_INIT)
	{
		if (m_bRunInvisibly &&
			m_bInvokedCommandLine // REVIEW
			)
		{
			g_AutomationState.DisableUI();
			g_AutomationState.SetSaveChanges(FALSE);
		}
	}

	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*) m_packages.GetNext(pos);
		if ((pPackage->m_flags & PKS_NOTIFY) != 0 &&
			!pPackage->OnNotify(id, Hint, ReturnArea) &&
			id >= PN_FIRST_VETO)
		{
			return FALSE;
		}
	}

	if (id == PN_WORKSPACE_INIT)
		CPartDoc::UpdateSaveAll(TRUE);
	else if (id == PN_WORKSPACE_CLOSE)
		CPartDoc::UpdateSaveAll(FALSE);

	if(	id==PN_WORKSPACE_INIT ||
		id==PN_WORKSPACE_CLOSE ||
		id==PN_NEW_PROJECT ||
		id==PN_OPEN_PROJECT ||
		id==PN_CLOSE_PROJECT)
	{
		m_bMenuDirty=TRUE;
		m_bProjectCommandsDirty=TRUE;
	}

	return TRUE;
}

// Node provider querying (asks for default nodes and layout info)
void CTheApp::GetPackagesDefProvidedNodes(CPtrList &DefNodeList, BOOL bWorkspaceInit)
{
	POSITION pos;
	CPackage *pPackage;
	for (pos = m_packages.GetHeadPosition(); pos != NULL;)
	{
		pPackage = (CPackage *)m_packages.GetNext(pos);
		pPackage->GetDefProvidedNodes(DefNodeList, bWorkspaceInit);
	}
}

// Map a file error code to a string id.
static struct FERRID
{
    int ferr;
    int ids;

} mpidsferr [] =
{
    { ferrCantSaveReadOnly,     IDS_ERROR_CANT_SAVERO },
	{ ferrCantSaveTempFiles,        IDS_ERROR_CANT_SAVETEMP },
    { ferrIllformedFile,        IDS_ERROR_BOGUSFILE },
};

int CTheApp::IdsFromFerr(int ferr)
{
    if( HIWORD(ferr) == 0 )
		return IDS_ERROR_FILE + ferr; // was an exception cause

	if( HIWORD(ferr) == PACKAGE_SUSHI )
	{
		// Check the error map above.
		for (int i = 0; i < sizeof (mpidsferr) / sizeof (FERRID); i += 1)
		{
		if (mpidsferr[i].ferr == ferr)
			return mpidsferr[i].ids;
		}
	}

	// Determine the package from the HIWORD.
	CPackage* pPackage = GetPackage(HIWORD(ferr));
	if( pPackage == NULL )
	{
		ASSERT( FALSE );
		return 0;
	}

    return pPackage->IdsFromFerr(ferr);         // do NOT strip the HIWORD
}

void CTheApp::InitRepeatableCommands()
{
	void* pv = NULL;

	for (int i = 0; i < theCmdCache.m_cCommands; i++)
	{
		CTE* pCTE = &theCmdCache.m_rgCommands[i];

		// If the command is repeatable, add it to the map
		if (pCTE->flags & CT_REPEATABLE)
			m_RepeatableCmds.SetAt(pCTE->id, pv);
	}
}

// Takes the name of the command and returns its command ID.
//  This searches the entire list of commands so THIS IS VERY
//  INEFFICIENT-- USE IT ONLY IF YOU HAVE TO
// Returns BOOL indicating whether the ID was found.
BOOL CTheApp::GetCommandID(LPCTSTR szCommandName, UINT* pnCmdID)
{
	return theCmdCache.GetCommandID(szCommandName, pnCmdID);
}

// Packages may use this to check whether a command is currently bound to a key
// This is used by devaut1 to remember to never change the cmdID of bound commands.
BOOL CTheApp::IsCommandKeyBound(WORD id)
{
	POSITION pos = CKeymap::c_keymaps.GetHeadPosition();
	while (pos != NULL)
	{
		WORD unused1, unused2;
		CKeymap* pKeymap = (CKeymap*)(void*)CKeymap::c_keymaps.GetNext(pos);
		if(pKeymap->LookupCommand(id, unused1, unused2, NULL))
			return TRUE;
	}
	return FALSE;
}

// Packages may use this to add a command dynamically instead of using
//  cmdcomp.  This is used by devaut1 to add commands for macros and DLL AddIns
BOOL CTheApp::AddCommand(WORD id, WORD group, WORD flags, WORD glyph,
							CPack* pPack, LPCTSTR szCommand, int nCmdLength)
{
	return theCmdCache.AddCommand(id, group, flags, glyph, pPack, szCommand, nCmdLength);
}

// Packages can use this to replace a substring within the command string:
//  either the menutext, prompt text, or tip text.  Devaut1 uses this to
//  update the command's description when the user updates a macro's description
//  in the macro file.  You may not use this to change the name of the command
//  itself.  This will dirty the command cache.
void CTheApp::ReplaceCommandString(UINT nID, UINT iString, LPCTSTR szNewSubString)
{
	theCmdCache.ReplaceCommandString(nID, iString, szNewSubString);
}

// Packages may use this to see if a command of this name already exists
//  This is used by devaut1 to make sure macros/addin cmds don't clash
//  with preexisting ones.
BOOL CTheApp::DoesCommandNameExist(LPCTSTR szCmdName)
{
	UINT nDummy;
	return theCmdCache.GetCommandID(szCmdName, &nDummy);
}

LPCTSTR CTheApp::GetCommandName(WORD id)
{
	LPCTSTR szCmdName = NULL;
	if(!theCmdCache.GetCommandString(id, STRING_COMMAND, &szCmdName))
		szCmdName = NULL;
	return szCmdName;
}

// Packages should use this to remove commands that are being permanently removed from the system.
// UI elements related to the command will be irretrievably removed from the UI. If pPack is not
// the owner of the command, then the command will not be removed. This stops most commands being removed
// erroneously by confused packages. 
BOOL CTheApp::RemoveCommand(WORD id, CPack* pPack)
{
	return theCmdCache.RemoveCommand(id, pPack);
}

void CTheApp::SetAppWizHwnd(HWND hWnd)
{
	((CMainFrame*) AfxGetMainWnd())->SetAppWizHwnd(hWnd);
}

BOOL CTheApp::ShouldExtrude(void)
{
	CWnd* pParentWnd = AfxGetMainWnd();
	CWnd* pActiveWnd = CWnd::GetForegroundWindow();
	return (!IsCustomizing()) &&
			((pParentWnd == pActiveWnd) ||
			 (pParentWnd->GetLastActivePopup() == pActiveWnd));
}

BOOL CTheApp::IsCustomizing(void)
{
	return CASBar::s_pCustomizer!=NULL;
}

// Packages may use this to create one-shot toolbars. The bar would not be owned by the package, and is 
// drawn from the users stock of custom bars. Bars should be created all at one time. If pPackage or dwCookie
// are different from the last time this function was called, then a new bar will be created.
BOOL CTheApp::AddCommandBarButton(CPackage *pPackage, DWORD dwCookie, UINT nId,
								  long nButtonType)
{
	static CPackage *pLastPackage=NULL;                     // last package to create a bar
	static DWORD dwLastCookie=0;                            // last cookie to create a bar
	static CASBar *pLastBar=NULL;                           // last bar created
	static CPoint ptLastBar(-1,-1);                         // top left of last bar created

	int nInsertIndex=-1;                                            // index in bar at which button was inserted
	BOOL bNeedRecalc=FALSE;                                         // TRUE if a recalclayout will be required

	// If it's a new request, do a new bar
	if(pPackage!=pLastPackage || dwCookie!=dwLastCookie)
	{
		pLastPackage=pPackage;
		dwLastCookie=dwCookie;

		pLastBar= new CASBar;

		// Be sure the dock manager is around.  If not, the add-in is likely
		//  calling this on startup (a no-no).
		if (((CMainFrame*) AfxGetMainWnd())->m_pManager == NULL)
			return FALSE;

		// create the bar containing the right id.
		if (!pLastBar->Create(((CMainFrame*) AfxGetMainWnd())->m_pManager, nId, NULL))
		{
			// autodeletion inside this create function
			pLastBar=NULL;
			return FALSE;
		}
		else
		{
			// mark the bar dirty, because create will assume clean when passed an id like that.
			pLastBar->SetDirty(TRUE);

			// button has been inserted at the first position, of course
			nInsertIndex=0;

			if(ptLastBar.x==-1)
			{
				// this is the first bar; just cache its position.
				CRect rectBar;

				// the bar will be floating, so we need to get to the palette window
				CWnd *pBarParent=pLastBar->GetParent();

				pBarParent->GetWindowRect(&rectBar);

				// this is the parent of the palette
				CWnd *pParent=pBarParent->GetParent();

				if(pParent)
				{
					// should always succeed
					pParent->ScreenToClient(&rectBar);
					ptLastBar.x=rectBar.left;
					ptLastBar.y=rectBar.top;
				}
			}
			else
			{
				// second and subsequent bars are cascaded

				// the bar will be floating, so we need to get to the palette window
				CWnd *pBarParent=pLastBar->GetParent();

				CRect rectBar;
				pBarParent->GetWindowRect(&rectBar);

				ptLastBar.x+=10;
				ptLastBar.y+=10;
				// 10 is an arbitrary step value
				pBarParent->SetWindowPos(NULL, ptLastBar.x, ptLastBar.y, 0,0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
			}
		}
	}
	else
	{
		if (pLastBar == NULL)
			return FALSE;
	
		nInsertIndex=pLastBar->AppendButton(nId);
		bNeedRecalc=TRUE;
	}

	// Set the button's style.  It's currently glyph-only.  If the user
	//  wants text instead, change it.
	if (nButtonType == dsText &&
		nInsertIndex!=-1)
	{
		pLastBar->AddText(nInsertIndex);
		pLastBar->RemoveBitmap(nInsertIndex);
	}

	if(bNeedRecalc)
	{
		ASSERT(pLastBar);

		// make sure it comes up as a single row.
		pLastBar->RecalcLayout(HTBOTTOM);
	}
		
	return TRUE;
}

// Packages can use this to implement dragable areas in customization pages
// call this in the page's Activate function
void CTheApp::ActivateDraggableCustomizePage(CDlgTab *pTab)
{
	CMainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();

	pFrame->EnableWindow(TRUE);
	CMenu* pMenu = pFrame->GetSystemMenu(FALSE);
	if (pMenu != NULL)
		pMenu->EnableMenuItem(SC_CLOSE, MF_BYCOMMAND | MF_DISABLED);
	::EnableWindow(pFrame->m_hWndMDIClient, FALSE);

	CObArray aWorkers;
	pFrame->m_pManager->ArrayOfType(dtEmbeddedToolbar, &aWorkers, FALSE, TRUE);

	for(int i=0; i<aWorkers.GetSize(); i++)
	{
		CDockWorker *pWorker=(CDockWorker *)(aWorkers[i]);
		if(pWorker->m_pWnd)
		{
			pWorker->m_pWnd->GetParent()->EnableWindow(TRUE);
		}
	}
	
	if(CASBar::s_pCustomizer!=NULL)
	{
		delete CASBar::s_pCustomizer;
	}

	CASBar::s_pCustomizer = new CToolCustomizer(pFrame->m_pManager, pTab, CASBar::s_aUsage, FALSE, FALSE);
}

// Call this in LBUTTONDOWN. Note that this will eat LBUTTONUP, so you will need to fake one if
// the drag source is something like a list box, which relies on the lbutton up.
void CTheApp::DragCommandButton(CPoint ptSource, UINT nId)
{
	CASBar *pBar=new CASBar;        // DoButtonMove requires a valid ASBar in case it
								// needs to create a new bar from scratch
	// it's a command
	CASBar::s_pCustomizer->DoButtonMove(ptSource, pBar->GetProxy(), -1, NULL, CToolCustomizer::cCommand, nId);

	delete pBar;
}

// call this in the page's DeActivate function
void CTheApp::DeactivateDraggableCustomizePage(CWnd *pParentWnd)
{
	CMainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();

	if(CASBar::s_pCustomizer!=NULL)
	{
		delete CASBar::s_pCustomizer;
		CASBar::s_pCustomizer = NULL;
	}

	::EnableWindow(pFrame->m_hWndMDIClient, TRUE);
	CMenu* pMenu = AfxGetMainWnd()->GetSystemMenu(FALSE);
	if (pMenu != NULL)
		pMenu->EnableMenuItem(SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
	AfxGetMainWnd()->EnableWindow(FALSE);
	pParentWnd->EnableWindow(TRUE); // MFC will disable us.
}

// For information on why this is the way it is, see the comments in the shell implementation of CPackage::GetPacakgeProperty
UINT CTheApp::GetExecutableProperty(UINT nProperty)
{
	return 0;
}

// CTheApp::MDITypedGetNext
//    We use this function when we want to close all windows of a certain
//    type, excluding others.  It may appear a little inefficient, but
//    is necessary, since closing a resource browser, closes associated
//    editor windows, which may invalidate any cached window handles we hold.

// We used to always do this backwards, but that's not what the window menu wants

CPartFrame* CTheApp::MDITypedGetNext(CPartFrame* pFrame, TYPE_FILTER tf, BOOL bForwards /*=FALSE*/)
{
	UINT nFirst=0;
	UINT nNext=0;
	if(bForwards)
	{
		nFirst=GW_HWNDFIRST;
		nNext=GW_HWNDNEXT;
	}
	else
	{
		nFirst=GW_HWNDLAST;
		nNext=GW_HWNDPREV;
	}

	extern CPartFrame* GetProjectFrame();

	CPartFrame* pProjFrame = GetProjectFrame();
	LPBUILDSYSTEM pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace);
	CPath cp;
	CPartDoc *pDoc;

	// Actually, we get the last possible window that fits the type filter,
	// so that closing a lot of maximized windows doesn't change the main
	// frame caption.

	if (pFrame != NULL)
		pFrame = (CPartFrame*) pFrame->GetWindow(nNext);
	else
	{
		pFrame = (CPartFrame*) ((CMainFrame *)m_pMainWnd)->MDIGetActive();
		if (pFrame != NULL)
			pFrame = (CPartFrame*) pFrame->GetWindow(nFirst);
	}

	for ( ; pFrame != NULL; pFrame = (CPartFrame *)pFrame->GetWindow(nNext))
	{
		if(!IsValidMDICycleMember(pFrame))
		{
			continue;
		}

		ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));
		if ((tf & FILTER_DEBUG) != 0 && pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
		{
			continue;
		}
		if ((tf & FILTER_PROJECT) != 0 && pFrame == pProjFrame)
		{
			continue;
		}

		pDoc = (CPartDoc *)pFrame->GetActiveDocument();
		ASSERT(pDoc == NULL || pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));

		if (((tf & FILTER_DOCUMENT) != 0) && (pDoc != NULL) && (!pDoc->FDisplayTitle()))
		{
			continue;
		}
		if ((tf & FILTER_NON_PROJECT) != 0 && (pBldSysIFace == NULL || (pDoc == NULL) || !cp.Create(pDoc->GetPathName())
			|| (pBldSysIFace->IsActiveBuilderValid() == S_OK && pBldSysIFace->IsProjectFile(&cp, FALSE, ACTIVE_BUILDER) != S_OK)))
		{
			// REVIEW [patbr]: do we need to check ALL projects, not just active builder?
			continue;
		}

		break;
	}

	if (pBldSysIFace)
		pBldSysIFace->Release();
	return pFrame;
}

CPartFrame* GetProjectFrame()
{
	LPBUILDSYSTEM pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace);
	CWnd* pSlobWnd = NULL;
	if (pBldSysIFace != NULL)
	{
		if (pBldSysIFace->IsActiveBuilderValid() == S_OK)
			pBldSysIFace->GetSlobWnd(ACTIVE_BUILDER, &pSlobWnd);
		pBldSysIFace->Release();
		if (pSlobWnd != NULL)
		{
#ifdef _DEBUG
			CPartFrame* pFrameProj = (CPartFrame*) pSlobWnd->GetParentFrame();
			ASSERT(pFrameProj == NULL ||
				pFrameProj->IsKindOf(RUNTIME_CLASS(CPartFrame)));
#endif
			return (CPartFrame*) pSlobWnd->GetParentFrame();
		}
	}

	return NULL;
}

HCURSOR AfxLoadCursor(LPCTSTR lpResourceID)
{
	HINSTANCE hInst = AfxFindResourceHandle(lpResourceID, RT_GROUP_CURSOR);
	ASSERT(hInst != NULL); // resource not found anywhere!
	return LoadCursor(hInst, lpResourceID);
}

HICON AfxLoadIcon(LPCTSTR lpResourceID)
{
	HINSTANCE hInst = AfxFindResourceHandle(lpResourceID, RT_GROUP_ICON);
	ASSERT(hInst != NULL); // resource not found anywhere!
	return LoadIcon(hInst, lpResourceID);
}

HICON AfxLoadIcon(UINT  nResourceID)
{
	return AfxLoadIcon(MAKEINTRESOURCE(nResourceID));
}

/////////////////////////////////////////////////////////////////////////////

// Use this to report a missing required file.  The setup type indicates which
// setup program the user will have to run in order to get the specific DLL.
//
void ReportMissingFile(const TCHAR* szFileName, SETUP_TYPE setupType)
{
	UINT ids;
	switch (setupType)
	{
	default:
		ASSERT(FALSE);

	case stStandard:
		ids = IDS_CANT_LOAD_PACKAGE;
		break;

	case stMacintosh:
		ids = IDS_CANT_LOAD_MAC;
		break;
	}

	CString str;
	VERIFY(str.LoadString(ids));
	MsgBox(Error, CString(szFileName) + str);
}


// Use this instead of LoadLibrary() to load DLL's.  It will prevent Windows
// from displaying its ugly DLL missing message.  If bRequired is TRUE, we
// will display our own message asking the user to re-install the development
// environment.  The setup type indicates which setup program the user will
// have to run in order to get the specific DLL.
//
HINSTANCE SushiLoadLibrary(const TCHAR* szName, BOOL bRequired,
	SETUP_TYPE setupType /* = stStandard*/)
{
#ifndef _DEBUG
	int nOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
#endif
	HINSTANCE hInst = LoadLibrary(szName);
#ifndef _DEBUG
	SetErrorMode(nOldErrorMode);
#endif

#ifndef _WIN32
	if (hInst <= HINSTANCE_ERROR)
		hInst = NULL;
#endif

	if (hInst == NULL && bRequired)
		ReportMissingFile(szName, setupType);

	return hInst;
}

#undef AfxMessageBox
int DsMessageBox(LPCTSTR lpszText, UINT nType /*= MB_OK*/, UINT nIDHelp /*= 0*/)
{
	return AfxMessageBox(lpszText, nType, nIDHelp); 
}

int DsMessageBox(UINT nIDPrompt, UINT nType /*= MB_OK*/)
{ 
	return AfxMessageBox(nIDPrompt, nType, 0);
}

int DsMessageBox(UINT nIDPrompt, UINT nType, UINT nIDHelp)
{ 
	return AfxMessageBox(nIDPrompt, nType, nIDHelp);
};

#define AfxMessageBox DsMessageBox
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MAINFRM_H__
#define __MAINFRM_H__

#ifndef __SMENU_H__
#include "shlmenu.h"
#endif

#ifndef __SBAR_H__
#include "sbar.h"
#endif

#ifndef __SHLDOCS_H__
#include "shldocs.h"
#endif

#ifndef _OLEREF_H_
#include <oleref.h>
#endif

#define MANAGER_STATES 4

class CVshellPackage;
class CDockManager;
class CPartFrame;
class CStateSaver;
class CIPCompFrameHook;
class CIPCompMainFrame;
interface IMsoComponentManager;
class CShellRecorder;
extern CShellRecorder g_theShellRecorder;

class CAutoDocuments ;

class CFullScreenState : public CObject
{
   static _TCHAR szKeyName[];

public:
   CFullScreenState ();

   void LoadFromReg (LPCTSTR szSection);
   void SaveToReg (LPCTSTR szSection);

   const CFullScreenState& operator<< (BYTE *);
   const CFullScreenState& operator>> (BYTE *);

   BYTE m_bFullScreen:1;
   BYTE m_bFSWasZoomed:1;
   BYTE m_bFSWasIconic:1;
   BYTE m_bStatusBar:1;
   BYTE m_bFSStatusBar:1;
   BYTE m_bFSVertScroll:1;
   BYTE m_bFSHorzScroll:1;
   BYTE m_bFirstTime:1;
   CRect m_FullScreenWindowRect;
   WINDOWPLACEMENT m_wpFSPrevWinState;

   struct Notify {
      BOOL  bUnused;
      BOOL  bFirstTime;
      RECT  rectFullScreen;
      BOOL  bVert;
      BOOL  bHorz;
   };
};

class CMDIClientValidator : public CWnd
{
public:
   CMDIClientValidator();

protected:
   virtual WNDPROC* GetSuperWndProcAddr();
   virtual void PostNcDestroy();

   afx_msg void OnParentNotify(UINT message, LPARAM lParam);
   afx_msg void OnSize(UINT nType, int cx, int cy);
   afx_msg void OnRButtonUp(UINT nFlags, CPoint pt);
   int m_cyLast;

   DECLARE_MESSAGE_MAP();
};

interface IMacroRecorder;
interface IRecorderForShell;

class CMainFrame : public CMDIFrameWnd
{
        friend class CAutoDocuments;
        friend class CAutoWindows;

        DECLARE_DYNAMIC(CMainFrame)
public:
        CMainFrame();

// Attributes
public:
        BOOL m_bInMenuMode:1;
        BOOL m_bLockLayout:1;
        BOOL m_bLockManager:1;
    BOOL m_fInOnEnterState:1;
        int m_nManagerState;
        int m_nManagerStateSave;
        CDockManager* m_pManager;
        CMDIClientValidator* m_pWndMDIClient;
        CRect m_lastWindowRect; // last non-min/max position of app window
        CSushiBar m_statusBar;
        CKeymap m_keymap;
        CUIntArray m_aDockCmds;

        CString m_strModeName;
        CString m_strAppTitle;
        CString m_strSubTitle;
        CFullScreenState m_FS;

        CPtrList m_plIPCompFrameHook;   // the active frame hook is always at the head
        CIPCompMainFrame * m_pIPCmpMainFrm;     

protected:
   HGLOBAL m_ahManagerStates[MANAGER_STATES];
   HWND m_hwndAppWiz;

   // For recording default text...
   IMacroRecorder* m_pMacroRecorder;
   IRecorderForShell* m_pRecorderForShell;
   void RecordDefaultTextIfNecessary(WORD nID); 
        
        static CShellRecorder& GetShellRec(void) { return g_theShellRecorder; }

// Implementation
public:
   virtual ~CMainFrame();
   virtual BOOL DestroyWindow();

   // frame window based modality
   virtual void BeginModalState();
   virtual void EndModalState();

   BOOL  InitAfterRegistration();
   // If bAllEditors is TRUE, then all editor specific commands will be shown, independent of the current editor. Otherwise,
   // only those for the current editor will be shown.
   // If bAllProjects is TRUE, all project dependent commands will be shown.
   // If bEmptyMenus is TRUE, then any menu which has no items (visible or invisible) will be shown
   void  RebuildMenus(BOOL bAllEditors=FALSE, BOOL bAllProjects=FALSE, BOOL bEmptyMenus=FALSE);
   // resets a single menu to its default state
   void  ResetMenu(UINT nID);
   // resets a single menu to its default state
   void  ResetAllMenus();
   // fills a list box with all commands that are missing from the menus
   void  FillDeletedMenuItemList(CListBox *pList);
   void  MapDockingCmd(UINT nID, UINT nCmd);
   void  MapDockingCmds();
   void  InitializeToolsMenu(CVshellPackage* pPackage);
   void  InitializeHelpMenu (CVshellPackage* pPackage);
   void  InitKeymap();

   void  SetDockState(int nState, int nMask = 1);
   void  LockDockState(BOOL bLock);
   void  LockLayout(BOOL bLock);

   inline   BOOL IsFullScreen () const { return m_FS.m_bFullScreen; }

   // Located in workspc.cpp.
   void LoadLayout();
   void SaveLayout();
   BOOL LoadManager();
   BOOL SaveManager();
   BOOL SerializeWorkspaceLayout(CStateSaver& stateSave);
   BOOL LoadWorkspace(CArchive& ar);
   BOOL SaveWorkspace(CArchive& ar);
   CPartFrame* LoadWorkspaceWindow(CArchive& ar,
      BOOL bPlace = TRUE, CDocument** hDoc = NULL,
        UINT* pnCmdShow = NULL);
   void SaveWorkspaceWindow(CArchive& ar, CPartFrame* pFrame,
      BOOL bRelative = FALSE);

   void AddIPCompFrameHook(CIPCompFrameHook * pHook);
   void RemoveIPCompFrameHook(CIPCompFrameHook * pHook);
        
   void EnsureCustomizerActive();
   void EnsurePopupActive();
   void EnsureViewActive();

   virtual void GetMessageString(UINT nID, CString& rMessage) const;

	void UpdateProjectCommands(void);

#ifdef _DEBUG
   virtual  void AssertValid() const;
   virtual  void Dump(CDumpContext& dc) const;
#endif

   void OnDirChange();
   virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
   virtual void RecalcLayout(BOOL bNotify = TRUE);
   virtual BOOL NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder);

   void CloseWindows(UINT nFilter = FILTER_NONE);

// Slob-based Drag&Drop
   void BeginDragDrop(class CDragNDrop* pInfo);
   void EndDragDrop ();
   class CDragNDrop* m_dragDrop; // controls the drag and drop operations

// Super-Deluxe ESC key handler
   afx_msg void OnCancel();

// Generic Edit Go To dialog
   afx_msg void CmdGoto();

   void SetAppWizHwnd(HWND hWnd) { m_hwndAppWiz = hWnd; }

   BOOL SetComponentManager(IMsoComponentManager * pCmpMgr);
   IMsoComponentManager * GetComponentMgr();    
   DWORD GetComponentID();

// Generated message map functions
protected:
   virtual BOOL PreTranslateMessage(MSG* pMsg);
   // The following is copied from MFC's CMDIFrameWnd.
   BOOL MDIFrameWnd_PreTranslateMessage(MSG* pMsg) ;

   virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
   virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
      AFX_CMDHANDLERINFO* pHandlerInfo);
   virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
   virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

   //{{AFX_MSG(CMainFrame)
   afx_msg int OnCreate(LPCREATESTRUCT lpcs);
   afx_msg void OnSize(UINT nType, int cx, int cy);
   afx_msg void OnMove(int cx, int cy);
   afx_msg void OnClose();
   afx_msg void OnDestroy();
   afx_msg void OnInitMenu(CMenu* pMenu);
   afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
   afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
   afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
   afx_msg void OnEnable(BOOL bEnable);
   afx_msg void OnWindowCloseAll();
   afx_msg void OnWindowClose();
   afx_msg void OnWindowNext();
   afx_msg void OnWindowPrevious();
   afx_msg void OnWindowFullScreen();
   afx_msg void OnWindowListDocs();
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnDragMove();
   afx_msg void OnDragCopy();
   afx_msg void OnDragCancel();
   afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
   afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
   afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
   afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
   afx_msg void OnWinIniChange(LPCSTR lpszSection);
   afx_msg void OnFontChange ();
   afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
   afx_msg BOOL OnNcActivate(BOOL bActive);
   afx_msg void OnSetFocus(CWnd* pOldWnd);
   afx_msg void OnActivate(UINT nState, CWnd* pInactiveWnd, BOOL bMinimized);
   afx_msg void OnTimer(UINT nTimerID);
   afx_msg void OnSysColorChange();
   afx_msg void OnEndSession(BOOL bEnding);
   afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
   afx_msg BOOL OnQueryNewPalette();
   afx_msg void OnUpdateNewWindow(CCmdUI* pCmdUI);
   afx_msg void OnUpdateWindowCommand(CCmdUI* pCmdUI);
   afx_msg void OnNewWindow();
   afx_msg void OnUpdateFullScreen(CCmdUI* pCmdUI);
   afx_msg void OnUpdateIndicator(CCmdUI* pCmdUI);
   afx_msg void OnUpdateMenuCommand(CCmdUI* pCmdUI);
   afx_msg void OnUpdateCustomMenuCommand(CCmdUI* pCmdUI);
   afx_msg void OnUpdateWindows(CCmdUI* pCmdUI);
   afx_msg void OnMenuCommand(UINT nID);
   afx_msg void OnWindows(UINT nID);
   afx_msg void OnHelp();
   afx_msg void OnFastHelp();
   afx_msg void OnHelpContents();
#ifdef __DEVHELP98__ 
   afx_msg void OnHelpKeywords() ;
#endif
   afx_msg void OnHelpSearch();
   afx_msg void OnHelpKeyboard();
   afx_msg void OnDropFiles(HDROP hDropInfo);
   afx_msg void OnGetMinMaxInfo (MINMAXINFO * pGetMinMaxInfo);
   afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
        //}}AFX_MSG

   afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg BOOL OnDockWindowShow(UINT nID);
   afx_msg BOOL OnDockViewShow(UINT nID);
#ifdef _DEBUG
   afx_msg void OnOpenLayout();
#endif

   afx_msg LRESULT OnSetAppValidate(WPARAM wParam, LPARAM lParam);
#ifdef _DEBUG
   afx_msg LRESULT OnFatalExit(WPARAM wParam, LPARAM lParam);
#endif
#ifdef _TEST
   afx_msg LRESULT OnSetProp(WPARAM wParam, LONG lParam);
   afx_msg LRESULT OnGetProp(WPARAM wParam, LONG lParam);
   afx_msg LRESULT OnHeapUse(WPARAM wParam, LONG lParam);
   afx_msg LRESULT OnTestDockable(WPARAM wParam, LONG lParam);

   //Project window
   afx_msg LRESULT OnGetItemProp(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnSetItemProp(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnGetProjPath(WPARAM wParam, LPARAM lParam);

   //Build state
   afx_msg LRESULT OnIsBuildPossible(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnGetErrorCount(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnGetWarningCount(WPARAM wParam, LPARAM lParam);
#endif
   afx_msg LRESULT OnPostEnableIME(WPARAM wParam, LPARAM lParam);

   afx_msg LRESULT OnFileChange(WPARAM wPackage, LPARAM lpFCItem);
   afx_msg LRESULT OnBarSizeChanging(WPARAM bLarge, LPARAM);
   afx_msg LRESULT OnTestMenu(WPARAM wParam, LPARAM lParam);

   afx_msg LRESULT OnRegMouseWheel(WPARAM wParam, LPARAM lParam);

   CPtrList m_plFileChange;

   DECLARE_MESSAGE_MAP()

public: //NoMenu
        virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
        protected:
        virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

};

inline void CMainFrame::LockLayout(BOOL bLock)
{  m_bLockLayout = bLock; }

/////////////////////////////////////////////////////////////////////////////

#define IDT_FILE_CHANGE    102

#endif // __MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

$O\$(RCFILE).res: $O\$(CMDFILE).rcs $(RCFILE).rc2 $(RCFILE).rc $(O)\shell.tlb

!if "$(DEBUG)"=="0"
DESCRIPTION="VSHELL_DLL"
DLL=dllretail
!else
DESCRIPTION="VSHELLD_DLL"
DLL=dlldebug
!endif

SHARE=shared

initexit.cpp: $(PACKVERCHECK)

!ifdef BUILD_SHELL_REDEF

# BUILD_SHELL_REDEF is defined.  Build the .def file with maptweak.
#  If VC_BUILD_MACHINE is defined, check the file in.  Otherwise, just
#  copy it to the platform subdir.

! ifdef REDEFPASS

$(PACKVERCHECK): $(DLLDEF)
#   delete the shell/package compatibility check header file
    if exist $(PACKVERCHECK) attrib -r $(PACKVERCHECK)
    if exist $(PACKVERCHECK) del $(PACKVERCHECK)
#   regenerate the shell/package compatibility check header file
    type shellver.a1 > $(PACKVERCHECK)
    shellver >> $(PACKVERCHECK)
	echo. >> $(PACKVERCHECK)

$(DLLDEF):
    -del $(DLLDEF)
    echo LIBRARY $(TARGETNAME) > $(DLLDEF)
    type $(SHARE).def >> $(DLLDEF)

! else

$(DLLDEF): $O\$(TARGETNAME).map
#   strip the map file to symbols  leave 1 space at the beginning of line
    maptweak $** $O\tmp.1
#   filter out what we don't want to export (blank at start of each line)
    qgrep -v -f regen.f2 $O\tmp.1 > $O\tmp.3
    sort < $O\tmp.3 > $O\tmp.2
#   start with canned
    type regen.a1 > $O\$(TARGETNAME).tmp
    type $O\tmp.2 >> $O\$(TARGETNAME).tmp
    -del $O\tmp.1 $O\tmp.2 $O\tmp.3
#   build the real .DEF file
    echo LIBRARY $(TARGETNAME)          > $@
    echo DESCRIPTION $(DESCRIPTION)    >> $@
    type $(SHARE).def                  >> $@
!  if "$(DEBUG)"=="0"
	genord 16 < $O\$(TARGETNAME).tmp >> $@
!  else
    type $O\$(TARGETNAME).tmp >> $@
!  endif
    -del $O\$(TARGETNAME).tmp

$O\$(TARGETNAME).map: $(LIBRARY_OBJS)
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp
    -del $(DLLDEF)
    set LINKER_FLAGS=-map:$@
    set NOLINK=
    $(MAKE) -$(MAKEFLAGS) MAKEDLL=1 REDEFPASS=1 LINKER_NOREF=1
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp

! endif

!else

$(DLLDEF): defs\$(TARGET_DIRECTORY)\$(TARGETNAME).def
    copy $** $@

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\menubtn.cpp ===
// menubtn.cpp : implementation file for the menu button control
//

// This has been converted to allow command bar menus, but can use the old type as some
// menus use loadmenu

#include "stdafx.h"
#include "resource.h"
#include "util.h"
#include "utilctrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMenuBtn

CMenuBtn::CMenuBtn() :
	m_bMenuShown(FALSE),
	m_pMenuParent(NULL),
	m_bUseTraditional(FALSE),
	m_pTraditionalMenu(FALSE),
	m_hLastActive(NULL)
{
}

CMenuBtn::~CMenuBtn()
{
	if(m_bUseTraditional)
	{
		if(m_pTraditionalMenu)
		{
			delete m_pTraditionalMenu;
		}
	}
	else
	{
		if(m_pNewMenu)
		{
			delete m_pNewMenu;
		}
	}
}

const UINT WM_SHOWMENU = ::RegisterMessage("WM_SHOWMENU");
BEGIN_MESSAGE_MAP(CMenuBtn, C3dBitmapButton)
	//{{AFX_MSG_MAP(CMenuBtn)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	ON_REGISTERED_MESSAGE(WM_SHOWMENU, OnShowMenu)
	ON_CONTROL_REFLECT(BN_CLICKED, OnClicked)
	ON_WM_LBUTTONUP()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_WM_SYSCOLORCHANGE()
END_MESSAGE_MAP()

BOOL CMenuBtn::SubclassDlgItem(UINT nID, CWnd* pParent)
{
	// Subclass the button.
	if (!C3dBitmapButton::SubclassDlgItem(nID, pParent))
		return FALSE;

	// It must be an owner-draw button.
	ASSERT(GetButtonStyle() & BS_OWNERDRAW != 0);

	m_bToggle = FALSE;
	if (!DrawBitmaps())
		return FALSE;

	ASSERT(m_bitmap.m_hObject != NULL);
	return TRUE;
}

void CMenuBtn::SetPopup(POPDESC* ppop)
{
	if(m_bUseTraditional)
	{
		if(m_pTraditionalMenu)
		{
			delete m_pTraditionalMenu;
		}
	}

	m_bUseTraditional=FALSE;
	m_pNewMenu=new CBContextPopupMenu;
	m_pNewMenu->Create(ppop);
}

BOOL CMenuBtn::LoadMenu(UINT idMenuResource)
{
	if(!m_bUseTraditional)
	{
		if(m_pNewMenu)
		{
			delete m_pNewMenu;
		}
	}

	m_bUseTraditional=TRUE;
	m_pTraditionalMenu=new CContextPopupMenu;
	return m_pTraditionalMenu->LoadMenu(idMenuResource);
}

void CMenuBtn::SetPos(int pos)
{
	ASSERT(m_bUseTraditional);

	m_pTraditionalMenu->SetPos(pos);
}

/////////////////////////////////////////////////////////////////////////////
// CMenuBtn message handlers

void CMenuBtn::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// Do we need to display the menu?
	if (!m_bMenuShown && lpDrawItemStruct->itemState & ODS_SELECTED != 0)
	{
		// Must show the popup...
		PostMessage(WM_SHOWMENU);
		m_bMenuShown = TRUE;
	}

	C3dBitmapButton::DrawItem(lpDrawItemStruct);
}

BOOL CMenuBtn::DrawBitmaps()
{
	// delete old bitmaps (if present)
	m_bitmap.DeleteObject();
	m_bitmapSel.DeleteObject();
	m_bitmapFocus.DeleteObject();
	m_bitmapDisabled.DeleteObject();

	// Get the window text.
	CString strWindow;
	GetWindowText(strWindow);

	// Get the window rect.
	CRect rcWindow;
	GetWindowRect(rcWindow);

	// Create the "Up" bitmap.
	HBITMAP hbm = CreateButtonBitmap(TBBS_BUTTON, rcWindow, NULL, strWindow);
	if (hbm == NULL)
		return FALSE; // need at least one image...

	m_bitmap.Attach(hbm);

	// Create the "Pressed" bitmap.  The 0x80 style is focus rect.
	hbm = CreateButtonBitmap(TBBS_BUTTON | TBBS_PRESSED | 0x80, rcWindow, NULL, strWindow);
	if (hbm != NULL)
		m_bitmapSel.Attach(hbm);

	// Create the "Focused" bitmap
	hbm = CreateButtonBitmap(TBBS_BUTTON | 0x80, rcWindow, NULL, strWindow);
	if (hbm != NULL)
		m_bitmapFocus.Attach(hbm);

	// Create the "Disabled" bitmap
	hbm = CreateButtonBitmap(TBBS_BUTTON | TBBS_DISABLED, rcWindow, NULL, strWindow);
	if (hbm != NULL)
		m_bitmapDisabled.Attach(hbm);

	return TRUE;
}

HBITMAP CMenuBtn::CreateButtonBitmap(UINT nStyle,  LPCRECT lpRect,
		CBitmap* pbmGlyph /*= NULL*/, LPCTSTR lpszText /*= NULL*/)
{
	return ::CreateButtonBitmap(this, nStyle, lpRect, pbmGlyph, lpszText, TRUE);
}

void CMenuBtn::ShowMenu()
{
	// since this is a union, this checks both pointers
	if(m_bUseTraditional)
	{
		if (m_pTraditionalMenu== NULL)
		{
			return;
		}
		else
		{
			ASSERT(m_pTraditionalMenu);
			ShowMenu(*m_pTraditionalMenu);
		}
	}
	else
	{
		if (m_pTraditionalMenu== NULL)
		{
			return;
		}
		else
		{
			ASSERT(m_pNewMenu);
			ShowMenu(*m_pNewMenu);
		}
	}
}

void CMenuBtn::ShowMenu(CContextPopupMenu &menuPopup)
{
	// Get the parent window.
	CWnd* pParent = m_pMenuParent==NULL ? GetParent() : m_pMenuParent;

	// Get the window text.
	CString strWindow;
	GetWindowText(strWindow);

	// Display the menu.
	CRect rect;
	GetWindowRect(rect);
	// determine which way to pop up the menu (no text, pop right)
	int xMenu = strWindow.IsEmpty() ? rect.right : rect.left;
	int yMenu = strWindow.IsEmpty() ? rect.top : rect.bottom;
	UINT nCmd = (UINT)menuPopup.TrackPopup(TPM_RETURNCMD | TPM_LEFTALIGN |
		TPM_LEFTBUTTON | TPM_RIGHTBUTTON, xMenu, yMenu, pParent);
	m_bMenuShown = FALSE;

	// Reset the button.
	SetState(FALSE);
	UpdateWindow();

	// Since the WM_LBUTTONUP is eaten by the menu,
	// send a fake one to the button.  Otherwise,
	// the button will depress whenever the user
	// moves the mouse over the button.
	SendMessage(WM_LBUTTONUP);

	// Send the command message.
	if (nCmd > 0 && pParent != NULL)
		pParent->SendMessage(WM_COMMAND, MAKEWPARAM(nCmd, 0));
}

void CMenuBtn::ShowMenu(CBContextPopupMenu &menuPopup)
{
	// Get the parent window.
	CWnd* pParent = m_pMenuParent==NULL ? GetParent() : m_pMenuParent;

	// Get the window text.
	CString strWindow;
	GetWindowText(strWindow);

	// Since the WM_LBUTTONUP is eaten by the menu,
	// send a fake one to the button.  Otherwise,
	// the button will depress whenever the user
	// moves the mouse over the button.
	SendMessage(WM_LBUTTONUP);

	// Display the menu.
	CRect rect;
	GetWindowRect(rect);
	// determine which way to pop up the menu (no text, pop right)
	int xMenu = strWindow.IsEmpty() ? rect.right : rect.left;
	int yMenu = strWindow.IsEmpty() ? rect.top : rect.bottom;
	UINT nCmd = (UINT)menuPopup.TrackPopup(TPM_RETURNCMD | TPM_LEFTALIGN |
		TPM_LEFTBUTTON | TPM_RIGHTBUTTON, xMenu, yMenu, pParent, rect);
	m_bMenuShown = FALSE;

	// Reset the button.
	SetState(FALSE);
	UpdateWindow();


	// Send the command message.
	if (nCmd > 0 && pParent != NULL)
		pParent->SendMessage(WM_COMMAND, MAKEWPARAM(nCmd, 0));
}

LRESULT CMenuBtn::OnShowMenu(WPARAM wParam, LPARAM lParam)
{
	ShowMenu();

	return 0;
}

void CMenuBtn::OnClicked()
{
	if (!m_bMenuShown)
	{
		PostMessage(WM_SHOWMENU);
		m_bMenuShown = TRUE;
	}
}

void CMenuBtn::OnSetFocus(CWnd *pOldWindow)
{
	if (pOldWindow != NULL)
	{
		m_hLastActive = pOldWindow->m_hWnd;
		C3dBitmapButton::OnSetFocus(pOldWindow);
	}
	else
		m_hLastActive = NULL;
}

void CMenuBtn::OnLButtonUp(UINT n1, CPoint pt)
{
	if(m_hLastActive && ::IsWindow(m_hLastActive))
	{
		::SetFocus(m_hLastActive);
	}
	m_hLastActive = NULL;
	C3dBitmapButton::OnLButtonUp(n1,pt);
}

void CMenuBtn::OnSysColorChange()
{
	DrawBitmaps();

	Invalidate(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\menuprxy.cpp ===
#include "stdafx.h"
#include "menuprxy.h"
#include "barglob.h"
#include "bardockx.h"
#include "prxycust.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// CMenuPopupProxy
// This class implements the bar proxy on top of a CBMenuPopup.
void CMenuPopupProxy::AttachMenu(CBMenuPopup* pPopup)
{
	m_pPopup = pPopup;
}

CWnd* CMenuPopupProxy::GetWindow()
{
	return m_pPopup;
}

BOOL CMenuPopupProxy::IsInDialog()
{
	return FALSE;
}

UINT CMenuPopupProxy::GetExpansionConstraint(const CRect &expand, ORIENTATION *orBar /*= NULL*/)
{
	if (orBar != NULL)
		*orBar = orVert;
	
	return HTRIGHT;
}

int CMenuPopupProxy::GetCount() const
{
	return m_pPopup->GetMenuItemCount();
}

DWORD CMenuPopupProxy::GetBarStyle() const
{
	return 0;
}

BOOL CMenuPopupProxy::HasButtonExtra() const
{
	return TRUE;
}

const CSize CMenuPopupProxy::GetButtonSize() const
{
	return CCustomBar::GetDefaultButtonSize(globalData.GetLargeMenuButtons());
}

const CSize CMenuPopupProxy::GetImageSize() const
{
	return CCustomBar::GetDefaultBitmapSize(globalData.GetLargeMenuButtons());
}

HBITMAP CMenuPopupProxy::GetImageWell(int nIndex)
{
	return m_pPopup->GetMenuItem(nIndex)->m_hbmCmdGlyph;
}

int CMenuPopupProxy::GetImageIndex(int nIndex) const
{
	return 0;
}

UINT CMenuPopupProxy::GetButtonStyle(int nIndex) const
{
	CBMenuItem* pItem = m_pPopup->GetMenuItem(nIndex);
	ASSERT(pItem != NULL);

	UINT nStyle=0;
	if(pItem->m_hbmCmdGlyph != NULL)
	{
		nStyle |= TBBS_GLYPH;
	}
	switch (pItem->GetItemType())
	{
	case CBMenuItem::MIT_Command:
		nStyle|= TBBS_TEXTUAL;
		break;

	case CBMenuItem::MIT_Popup:
		nStyle |= TBBS_MENU | TBBS_TEXTUAL;
		break;

	case CBMenuItem::MIT_Separator:
		nStyle = TBBS_SEPARATOR;
		break;
	}
	if(pItem->m_bCustomGlyph)
	{
		nStyle|=TBBS_CUSTOMBITMAP;
	}
	if(pItem->m_bCustomText)
	{
		nStyle|=TBBS_CUSTOMTEXT;
	}

	return nStyle;
}

BOOL CMenuPopupProxy::IsStaticItem(int nIndex)
{
	return FALSE;
}

// May be called for an invalid index
BOOL CMenuPopupProxy::IsGapItem(int nIndex)
{
	if(nIndex<0 || nIndex>=GetCount())
	{
		return FALSE;
	}
	else
	{
		return m_pPopup->GetMenuItem(nIndex)->GetItemType() == CBMenuItem::MIT_Separator;
	}
}

const CString& CMenuPopupProxy::GetButtonText(int nIndex) const
{
	return m_pPopup->GetMenuItem(nIndex)->m_strName;
}

HWND CMenuPopupProxy::GetButtonControl(int nIndex) const
{
	return NULL;
}

HBITMAP CMenuPopupProxy::GetButtonImage(int nIndex) const
{
	return NULL;
}

void CMenuPopupProxy::SetButtonControl(int nIndex, HWND hControl)
{
	// deliberate nop
}

void CMenuPopupProxy::GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const
{
	nID = m_pPopup->GetMenuItem(nIndex)->GetCmdID();
	nStyle = GetButtonStyle(nIndex);
	iImage = GetImageIndex(nIndex);
}

void CMenuPopupProxy::GetButtonInfoEx(int nIndex, HWND& hControl, CString& rText, HBITMAP& hImage) const
{
	hControl = GetButtonControl(nIndex);
	rText = GetButtonText(nIndex);
	hImage = GetButtonImage(nIndex);
}

BOOL CMenuPopupProxy::HasExInfo(int nIndex) const
{
	return TRUE; // always has text
}

int CMenuPopupProxy::InsertButton(int nIndex, TRANSFER_TBBUTTON& trans, BOOL bReplace, GAP gap)
{
	// first remove any submenus which could get confusingly orphaned
	m_pPopup->HideSubPopup();

	UINT nFlags = MF_BYPOSITION;
	CString strCommand;

	// load the appropriate bitmap, if required
	trans.LoadCommandBitmap(globalData.GetLargeMenuButtons());

	LPCTSTR pszText;

	if (trans.nStyle & TBBS_CUSTOMTEXT)
	{
		pszText = trans.extra.GetLabel();
	}
	else
	{
		theCmdCache.GetCommandString(trans.nID, STRING_MENUTEXT, &pszText);
		if (pszText == NULL || pszText[0] == _T('\0'))
		{
			theCmdCache.GetCommandString(trans.nID, STRING_COMMAND, &pszText);
		// (bobz, paranoia:) we do not want to hold onto the return string from GetCommandString
		// (could be dynamic string held in single global CString). So even though current code
		// would be ok - (InsertMenu below copies the string), I am copying to a local CString
		// to ensure no weird future problems

		strCommand = pszText;
		pszText = (LPCTSTR)strCommand;
		}
	}

	CBMenuPopup* pPopup = NULL;
	if (trans.nStyle & TBBS_MENU)
	{
		pPopup = theCmdCache.GetMenu(trans.nID);
		nFlags |= MF_POPUP;
	}
	else if (trans.nStyle & TBBS_CHECKED)
	{
		nFlags |= MF_CHECKED;
	}
	else if (trans.nStyle & TBBS_SEPARATOR)
	{
		nFlags |= MF_SEPARATOR;
	}

	// Menu code doesn't want to insert at end, so use -1 to append instead
	if(nIndex==m_pPopup->m_nMaxIndex)
	{
		nIndex=-1;
	}
	BOOL bInserted=m_pPopup->InsertMenu(nIndex, nFlags, trans.nID, pszText, pPopup);

	// if we inserted ok, add the accelerator to the end
	if(bInserted)
	{
		if(nIndex==-1)
		{
			nIndex=m_pPopup->GetMenuItemCount()-1;
		}

		CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndex);
		if(pItem &&
			pItem->m_nCmdID!=0)
		{
			// find out short cut
			CString strKey;
			if (GetCmdKeyString(pItem->m_nCmdID, strKey))
			{
				// update in item
				pItem->SetAccelerator(strKey, TRUE);
			}
		}
	}

	m_pPopup->m_bDirty=TRUE;

	return nIndex;
}

void CMenuPopupProxy::DeleteButton(int nIndex, BOOL bMoving /*= FALSE*/)
{
	// first remove any submenus which could get confusingly orphaned
	m_pPopup->HideSubPopup();

	m_pPopup->DeleteMenu(nIndex, MF_BYPOSITION);
	
	// TRUE if the item before the one deleted was a separator
	BOOL bPrevItemSeparator=FALSE;

	// TRUE if the first visible item before the one deleted was a separator
	BOOL bPrevVisibleItemSeparator=FALSE;

	// Index of the previous visible item, if it was a separator.
	int iPrevVisibleItem=-1;
	
	// TRUE if we've found the first visible item before the one deleted
	BOOL bPrevVisibleFound=FALSE;

	// first check previous/next item so deletion is done first
	if(nIndex-1>=0)
	{
		CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndex-1);
		if(	pItem &&
			pItem->GetItemType()==CBMenuItem::MIT_Separator)
		{
			bPrevItemSeparator=TRUE;
		}
	}
	else
	{
		// If we deleted the top item, then the previous item and visible item (empty space) are equivalent to a separator
		bPrevItemSeparator=TRUE;
	}

	// First handle next item possible deletion
	if(bPrevItemSeparator)
	{
		int iDelete=-1;

		if(nIndex<m_pPopup->GetMenuItemCount())
		{
			CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndex);
			if(	pItem &&
				pItem->GetItemType()==CBMenuItem::MIT_Separator)
			{
				iDelete=nIndex;
			}
		}
		else
		{
			// we are at the end of the menu, which is effectively a separator, so we need to delete the previous item
			if(nIndex-1>=0)
			{
				iDelete=nIndex-1;
				--nIndex;
			}
		}

		if(iDelete!=-1)
		{
			m_pPopup->DeleteMenu(iDelete, MF_BYPOSITION);
		}
	}

	// find previous visible item
	for(int iItem=nIndex-1;iItem>=0 && !bPrevVisibleFound;--iItem)
	{
		CBMenuItem *pItem=m_pPopup->GetMenuItem(iItem);
		if(pItem &&
			pItem->IsVisible())
		{
			bPrevVisibleFound=TRUE;
			if(pItem->GetItemType()==CBMenuItem::MIT_Separator)
			{
				iPrevVisibleItem=iItem;
				bPrevVisibleItemSeparator=TRUE;
			}
		}
	}

	// no previous visible implies that it was a separator
	if(!bPrevVisibleFound)
	{
		bPrevVisibleItemSeparator=TRUE;
	}

	// if there was a separator before, we need to delete/hide
	if(bPrevVisibleItemSeparator)
	{
		int nItems=m_pPopup->GetMenuItemCount();

		// TRUE if we've found the first visible item before the one deleted
		BOOL bNextVisibleFound=FALSE;

		for(int iItem=nIndex;iItem<nItems && !bNextVisibleFound;++iItem)
		{
			// If the next visible item is a separator, we need to hide it.
			CBMenuItem *pItem=m_pPopup->GetMenuItem(iItem);
			if(	pItem &&
				pItem->IsVisible())
			{
				bNextVisibleFound=TRUE;
				if(pItem->GetItemType()==CBMenuItem::MIT_Separator)
				{
					pItem->SetVisible(FALSE);
				}
			}

		}

		// If no subsequent visible item was found, then the previous visible separator is now the last item in the menu, and
		// needs to be hidden
		if(!bNextVisibleFound)
		{
			if(iPrevVisibleItem>=0)
			{
				CBMenuItem *pItem=m_pPopup->GetMenuItem(iPrevVisibleItem);
				if(pItem)
				{
					pItem->SetVisible(FALSE);
				}
			}
		}
	}

	m_pPopup->CalcMenuSize();

	m_pPopup->m_bDirty=TRUE;
}

void CMenuPopupProxy::RecalcLayout(UINT nHTSize /*= HTRIGHT*/)
{
}

void CMenuPopupProxy::GetItemRect(int nIndex, LPRECT lpRect) const
{
	::CopyRect(lpRect, &m_pPopup->GetMenuItem(nIndex)->m_rectFields[e_FieldAll]);
}

int CMenuPopupProxy::IndexFromPoint(const CPoint& pt, CRect *pButtonRect) const
{
	CRect rcMenu;

	m_pPopup->GetClientRect(&rcMenu);

	CRect rcItem(0,0,0,0); // rect for the current item
	CRect rcOld;  // rect for the previous item
	CRect rcReturn;

	int nIndexReturn=-2;

	int yCheckCenter=pt.y;
	int yCenter=-1; // current y center
	int yOldCenter; // previous y center
	
	int nCount=GetCount();

	int nLastVisible=-1;
	CRect rcLastVisible;
	rcLastVisible.left=rcMenu.left;
	rcLastVisible.right=rcMenu.right;
	rcLastVisible.bottom=rcLastVisible.top=((rcMenu.bottom-rcMenu.top)/2)+rcMenu.top;
	BOOL bFirstSeen=FALSE;

	for (int i = 0; i < nCount; i++)
	{
		// Always skip visible items
		CBMenuItem *pItem=m_pPopup->GetMenuItem(i);
		if(!pItem->IsVisible())
		{
			continue;
		}

		rcOld=rcItem;
		yOldCenter=yCenter;

		GetItemRect(i, &rcItem);

		if(!bFirstSeen)
		{
			// make old same as item first time around, so button -1 returns rect correctly
			rcOld=rcItem;
			rcLastVisible=rcItem;

			// check for just above first button
			if(yCenter>=yCheckCenter)
			{
				nIndexReturn=-1;
				rcReturn=rcItem;
			}

			bFirstSeen=TRUE;
		}

		yCenter=rcItem.top+rcItem.Height()/2;

		// if the center of the check rect has just passed us, then return which ever one is closer
		if(	yCenter>=yCheckCenter && 
			yOldCenter<=yCheckCenter)
		{
			if(	yCenter-yCheckCenter <
				yCheckCenter-yOldCenter)
			{
				// current is nearer
				nIndexReturn=i;
				rcReturn=rcItem;
			}
			else
			{
				// previous was nearer
				nIndexReturn=nLastVisible;
				rcReturn=rcLastVisible;
			}
			break;
		}

		nLastVisible=i;
		rcLastVisible=rcItem;
	}
	if(nIndexReturn==-2)
	{
		nIndexReturn=nLastVisible;
		rcReturn=rcLastVisible;
	}
	if(pButtonRect)
	{
		*pButtonRect=rcReturn;
	}
	return nIndexReturn;
}

int CMenuPopupProxy::HitTest(CPoint point) const
{
	int nHit=m_pPopup->HitTest(point);

	if(nHit==CBMenuPopup::HT_HITSELECTEDITEM)
	{
		nHit=m_pPopup->m_nSelectedMenuItem;
	}
	if(nHit==CBMenuPopup::HT_MISSED)
	{
		nHit=-1;
	}

	return nHit;
}

CToolBarProxy* CMenuPopupProxy::NewBar(UINT nID, const CPoint& pt)
{
	CASBar* pBar = new CASBar;
	CSize sizeButton=CCustomBar::GetDefaultButtonSize(theApp.m_bLargeToolBars);

	CRect rectInit( pt.x-sizeButton.cx/2,
					pt.y-sizeButton.cy/2,
					pt.x+sizeButton.cx/2,
					pt.y+sizeButton.cy/2);
	if (!pBar->Create(((CMainFrame*) AfxGetMainWnd())->m_pManager,
		nID, rectInit))
	{
		// auto delete inside this creation function
		return NULL;
	}
	
	return pBar->GetProxy();
}

void CMenuPopupProxy::GetButtonTransferInfo(int nIndex, DWORD& dwData, TRANSDATA_CALLBACK* lplpDataCallback) const
{
	*lplpDataCallback = NULL;
}

BOOL CMenuPopupProxy::CanChooseAppearance()
{
	return TRUE;
}

BOOL CMenuPopupProxy::CanPasteImage()
{
	return TRUE;
}

BOOL CMenuPopupProxy::CanResetImage()
{ 
	if(CASBar::s_pCustomizer->m_nSelectIndex!=-1)
	{
		CBMenuItem *pItem=m_pPopup->GetMenuItem(CASBar::s_pCustomizer->m_nSelectIndex);
		if(pItem)
		{
			return pItem->m_bCustomGlyph;
		}
	}
	
	return FALSE;
}

void CMenuPopupProxy::PasteButtonImage()
{
	AddBitmap(CASBar::s_pCustomizer->m_nSelectIndex, cBitmapSourceClipboard, NULL);
}

void CMenuPopupProxy::ResetButtonImage()
{
	if(CASBar::s_pCustomizer->m_nSelectIndex!=-1)
	{
		CBMenuItem *pItem=m_pPopup->GetMenuItem(CASBar::s_pCustomizer->m_nSelectIndex);
		if(pItem)
		{
			// no longer custom
			pItem->m_bCustomGlyph=FALSE;

			// get glyph back from package, or clear it
			pItem->UpdateGlyph();

			// redraw the item
			m_pPopup->InvalidateItem(CASBar::s_pCustomizer->m_nSelectIndex);
		}
	}
}

void CMenuPopupProxy::OnSelChange(int nIndex)
{
	// Does nothing, by design.
}

void CMenuPopupProxy::OnDeleteSelection()
	{ }
void CMenuPopupProxy::OnBarActivate()
	{ }
void CMenuPopupProxy::OnButtonSize()
	{ }
void CMenuPopupProxy::OnButtonMove(int nIndex)
	{ }
void* CMenuPopupProxy::_GetRealObject()
	{ return m_pPopup; }
ORIENTATION CMenuPopupProxy::GetOrient() const
	{ return orVert; }

// adds text to the button
void CMenuPopupProxy::AddText(int nIndex) // default menu text
{
	LPCSTR pText;

	theCmdCache.GetCommandString(m_pPopup->GetMenuItem(nIndex)->GetCmdID(), STRING_COMMAND, &pText);

	CString text(pText);

	AddText(nIndex, pText, FALSE);
	m_pPopup->m_bDirty=TRUE;
}

void CMenuPopupProxy::AddText(int nIndex, const CString &text, BOOL bCustom)
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndex);
	pItem->SetText(text);
	pItem->m_bCustomText=bCustom;
	m_pPopup->CalcMenuSize();
	m_pPopup->m_bDirty=TRUE;
}

void CMenuPopupProxy::AddBitmap(int nIndex, BITMAPSOURCE bsSource, HBITMAP hbmCustom)
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndex);
	switch(bsSource)
	{
		case cBitmapSourcePackage:
			pItem->UpdateGlyph();
			break;

		case cBitmapSourceClipboard:
			{
				// we need to create a bitmap of the right size
				HBITMAP hbmPaste=NULL;
				
				CSize sizeCmdGlyph = CCustomBar::GetDefaultBitmapSize(globalData.GetLargeMenuButtons());
				HWND hwnd = this->GetWindow()->GetSafeHwnd();
				HDC hdc = ::GetDC(hwnd);
				hbmPaste=CreateCompatibleBitmap(hdc, sizeCmdGlyph.cx, sizeCmdGlyph.cy);
				::ReleaseDC(hwnd, hdc);
				GLOBAL_DATA::PasteGlyph(this->GetWindow(), hbmPaste, 0, sizeCmdGlyph);

				pItem->SetGlyph(hbmPaste, 0, FALSE, TRUE);
			}
			break;

		case cBitmapSourceCustom:
			pItem->SetGlyph(hbmCustom, 0, TRUE, TRUE);
			break;
	}
	m_pPopup->m_bDirty=TRUE;
	m_pPopup->InvalidateItem(nIndex);
}

// remove the glyph from a glyph+label button
void CMenuPopupProxy::RemoveBitmap(int nIndex)
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndex);
	pItem->SetGlyph(NULL,0,FALSE, FALSE);
	m_pPopup->m_bDirty=TRUE;
	m_pPopup->InvalidateItem(nIndex);
}

// call this when the button has been modified to mark the bar dirty and possibly redraw (if bSized==TRUE)
void CMenuPopupProxy::ButtonModified(int nIndex, BOOL bSized)
{
	m_pPopup->m_bDirty=TRUE;
	if(bSized)
	{
		m_pPopup->CalcMenuSize();
	}
}

// Removes a separator before a button
void CMenuPopupProxy::RemoveSeparator(int iButton)
{
	m_pPopup->DeleteMenu(iButton-1,MF_BYPOSITION);
	m_pPopup->m_bDirty=TRUE;
}

// Inserts a separator before a button
void CMenuPopupProxy::InsertSeparator(int iButton)
{
	m_pPopup->InsertMenu(iButton, MF_SEPARATOR, 0, NULL, NULL);
	m_pPopup->m_bDirty=TRUE;
}

// returns if the specified button can be shown with text
APPEARANCEOPTION CMenuPopupProxy::CanText(int iButton)
{
	return cAppearanceCompulsory;
}

// returns if the specified button can be shown with a glyph
APPEARANCEOPTION CMenuPopupProxy::CanGlyph(int iButton)
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(iButton);
	ASSERT(pItem != NULL);

	if(pItem->GetItemType()==CBMenuItem::MIT_Popup)
	{
		return cAppearanceForbidden;
	}
	else
	{
		return cAppearanceOptional;
	}
}

// returns any limitations on the appearance of a given button style 
APPEARANCEOPTION CMenuPopupProxy::CanText(UINT nStyle)
{
	return cAppearanceCompulsory;
}

// returns any limitations on the appearance of a given button style
APPEARANCEOPTION CMenuPopupProxy::CanGlyph(UINT nStyle)
{
	if(	(nStyle & (TBBS_SEPARATOR|TBBS_MENU)!=0))
	{
		return cAppearanceForbidden;
	}
	else
	{
		return cAppearanceOptional;
	}
}

// returns the appearance of a button
APPEARANCE CMenuPopupProxy::GetAppearance(int iButton)
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(iButton);
	if(pItem->m_hbmCmdGlyph)
	{
		return cAppearanceImageText;
	}
	else
	{
		return cAppearanceTextOnly;
	}
}

// returns the default appearance of a button
APPEARANCE CMenuPopupProxy::GetAppearance()
{
	return cAppearanceTextOnly;
}

// returns the appearance of a button of a given type when placed in this kind of container. If these display components
// are not available, the custom button dialog will appear
APPEARANCE CMenuPopupProxy::GetInitialAppearance(UINT nStyle)
{
	if(nStyle & TBBS_MENU)
	{
		return cAppearanceTextOnly;
	}
	else
	{
		return cAppearanceImageText;
	}
}

int CMenuPopupProxy::GetButtonCmdID(int iButton) 
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(iButton);
	return pItem->GetCmdID();
}

void CMenuPopupProxy::Empty(void) 
{
	m_pPopup->DeleteAll();
}

void CMenuPopupProxy::BatchBegin(int nCount)
{
	// deliberate do nothing, since we will add normally as we go along
}

void CMenuPopupProxy::BatchAdd(int nIndex, int nID, UINT nStyle, int nExtra, HBITMAP hbmGlyph, const CString &name)
{
	CBMenuItem *pItem=new CBMenuItem;
	BOOL bShowGlyph=(nStyle & TBBS_GLYPH)!=0;
	if(nStyle & TBBS_SEPARATOR)
	{
		pItem->CreateSeparator();
	}
	else
	{
		pItem->CreateDynamic(m_pPopup, nID, name, bShowGlyph, hbmGlyph);
	}
	m_pPopup->AddMenuItem(-1, pItem);
}

void CMenuPopupProxy::BatchEnd()
{
	// again nothing - all done in there
	m_pPopup->m_bDirty=TRUE;
}

// allocates or returns an individual glyph bitmap for a given button
HBITMAP CMenuPopupProxy::CreateSingleBitmap(int iButton)
{
	CBMenuItem *pItem=m_pPopup->GetMenuItem(iButton);
	if(pItem->m_hbmOriginalGlyph)
	{
		return pItem->m_hbmOriginalGlyph;
	}
	else
	{
		return pItem->m_hbmCmdGlyph;
	}
}

// always call this function if the one above returns non-null. Do not delete hbmSingle yourself, since it
// may still be in use elsewhere
void CMenuPopupProxy::DestroySingleBitmap(int iButton, HBITMAP hbmSingle)
{
	// never do anything
}

// This should only be called if nCmdIDSrc is a menu
BOOL CMenuPopupProxy::ExpandDestination(int nCmdIDSrc, int nIndexDest)
{
	// can't expand out of range
	if(nIndexDest<0 || nIndexDest>=m_pPopup->m_nMaxIndex)
	{
		return FALSE;
	}

	CBMenuItem *pItem=m_pPopup->GetMenuItem(nIndexDest);
	if(pItem->GetItemType()!=CBMenuItem::MIT_Popup)
	{
		// can't expand non-menus
		return FALSE;
	}

	if(pItem->GetCmdID()==nCmdIDSrc)
	{
		return FALSE;
	}

	CBMenuPopup *pMenu=theCmdCache.GetMenu(pItem->GetCmdID());
	if(	pMenu->m_hWnd!=NULL &&
		pMenu->IsWindowVisible())
	{
		// already expanded
		return FALSE;
	}

	if(nCmdIDSrc)
	{
		CBMenuPopup *pMenuSrc=theCmdCache.GetMenu(nCmdIDSrc);

		ASSERT(pMenuSrc!=NULL);
		
		if(pMenuSrc->ContainsMenu(pItem->GetCmdID()))
		{
			return FALSE;
		}
	}

	m_pPopup->ShowSubPopup(nIndexDest);

	// wait for menu to open
	do
	{
		theApp.PumpMessage();
	}
	while(!pMenu->IsPainted());

	return TRUE;
}

// returns the next visible item after the specified one. nIndex==-1 gets the first visible item
int CMenuPopupProxy::FindNextVisibleItem(int nIndex, BOOL bForward)
{
	return m_pPopup->FindNextVisibleItem(nIndex, bForward);
}

// TRUE if this bar is using large buttons
BOOL CMenuPopupProxy::HasLargeButtons() const
{
	return globalData.GetLargeMenuButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\mmonitor.h ===
/*----------------------------------------------------------------------------*\
|   MMHELP.H - routines to help a app be multimonitor aware
\*----------------------------------------------------------------------------*/

///////////////////////////////////////////////////////////////////////////////
//
// I use this contant everywhere for the fWork.
//
const BOOL c_fWork = TRUE ;

///////////////////////////////////////////////////////////////////////////////
//
// Get the rectangle of the monitor containing a point.
//
void multiMonitorRectFromPoint(/*in*/  POINT ptScreenCoords, 
							   /*out*/ LPRECT prc, 
							   /*in*/  BOOL fWork);
///////////////////////////////////////////////////////////////////////////////
//
// Get the rectangle of the monitor containing the rectangle.
//
void multiMonitorRectFromRect(/*in*/  RECT rcScreenCoords, 
							  /*out*/ LPRECT prc, 
							  /*in*/  BOOL fWork) ;

///////////////////////////////////////////////////////////////////////////////
//
//
int multiGetCXMetrics(HWND hWnd) ;
int multiGetCYMetrics(HWND hWnd) ;



void GetMonitorRect(HWND hwnd, LPRECT prc, BOOL fWork);
void ClipRectToMonitor(HWND hwnd, RECT *prc, BOOL fWork);
void CenterRectToMonitor(HWND hwnd, RECT *prc, BOOL fWork);
void CenterWindowToMonitor(HWND hwndP, HWND hwnd, BOOL fWork);
void ClipWindowToMonitor(HWND hwndP, HWND hwnd, BOOL fWork);
BOOL IsWindowOnScreen(HWND hwnd);
void MakeSureWindowIsVisible(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\mmonitor.cpp ===
/*----------------------------------------------------------------------------*\
|   MMONITOR.CPP - routines to help a app be multimonitor aware
\*----------------------------------------------------------------------------*/

#include "stdafx.h"

#define COMPILE_MULTIMON_STUBS
#include <multimon.h>

#include "mmonitor.h"

#include <math.h> //for abs

///////////////////////////////////////////////////////////////////////////////
//
// Direct replacement for GetSysmteMetrics(SM_CYSCREEN) ;
//
//
int multiGetCYMetrics(HWND hwnd)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;
	ASSERT(::IsWindow(hwnd)) ;

    // Core
	RECT rect ;
	GetMonitorRect(hwnd, &rect, c_fWork) ;
	return abs(rect.bottom - rect.top) ;
}

///////////////////////////////////////////////////////////////////////////////
//
// Direct replacement for GetSystemMetrics(SM_CXSCREEN) ;
//
//
int multiGetCXMetrics(HWND hwnd)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;
	ASSERT(::IsWindow(hwnd)) ;

    // Core
	RECT rect ;
	GetMonitorRect(hwnd, &rect, c_fWork) ;
	return abs(rect.right - rect.left) ;
}

///////////////////////////////////////////////////////////////////////////////
//
// Get the rectangle of the monitor containing a point.
//
void multiMonitorRectFromPoint(/*in*/  POINT ptScreenCoords, 
							   /*out*/ LPRECT prc, 
							   /*in*/  BOOL fWork)
{
	// precondition
	ASSERT(prc != NULL) ;
	ASSERT(AfxIsValidAddress(prc, sizeof(RECT))) ;

	// Get the monitor which contains the point.
	HMONITOR hMonitor = MonitorFromPoint(ptScreenCoords, MONITOR_DEFAULTTOPRIMARY) ;
	ASSERT(hMonitor != NULL) ;
	
	// Prepare to get the information for this monitor.
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);

	// Get the rect of this monitor.
    VERIFY(GetMonitorInfo(hMonitor, &mi));
	
	// Return the rectangle.
    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;

}
///////////////////////////////////////////////////////////////////////////////
//
// Get the rectangle of the monitor containing the rectangle.
//
void multiMonitorRectFromRect(/*in*/  RECT rcScreenCoords, 
							  /*out*/ LPRECT prc, 
							  /*in*/  BOOL fWork)
{
	//Preconditions
	ASSERT(prc != NULL) ;
	ASSERT(AfxIsValidAddress(prc, sizeof(RECT))) ;

	// Get monitor which contains this rectangle.
	HMONITOR hMonitor = ::MonitorFromRect(&rcScreenCoords, MONITOR_DEFAULTTOPRIMARY) ;
	ASSERT(hMonitor != NULL) ;

	// Prepare to get the information for this monitor.
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);

	// Get the rect of this monitor.
    VERIFY(GetMonitorInfo(hMonitor, &mi));
	
	// Return the rectangle.
    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetMonitorRect
//
//  gets the "screen" or work area of the monitor that the passed
//  window is on.  this is used for apps that want to clip or
//  center windows.
//
//  the most common problem apps have with multimonitor systems is
//  when they use GetSystemMetrics(SM_C?SCREEN) to center or clip a
//  window to keep it on screen.  If you do this on a multimonitor
//  system the window we be restricted to the primary monitor.
//
//  this is a example of how you used the new Win32 multimonitor APIs
//  to do the same thing.
//
void GetMonitorRect(HWND hwnd, LPRECT prc, BOOL fWork)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;
	ASSERT(::IsWindow(hwnd)) ;

    // Core
	MONITORINFO mi;

    mi.cbSize = sizeof(mi);
    GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &mi);

    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;
}

//
// ClipRectToMonitor
//
// uses GetMonitorRect to clip a rect to the monitor that
// the passed window is on.
//
void ClipRectToMonitor(HWND hwnd, RECT *prc, BOOL fWork)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;
	ASSERT(::IsWindow(hwnd)) ;

    // Core
    RECT rc;
    int  w = prc->right  - prc->left;
    int  h = prc->bottom - prc->top;

    if (hwnd != NULL)
    {
        GetMonitorRect(hwnd, &rc, fWork);
    }
    else
    {
        MONITORINFO mi;

        mi.cbSize = sizeof(mi);
        GetMonitorInfo(MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST), &mi);

        if (fWork)
            rc = mi.rcWork;
        else
            rc = mi.rcMonitor;
    }

    prc->left   = max(rc.left, min(rc.right-w,  prc->left));
    prc->top    = max(rc.top,  min(rc.bottom-h, prc->top));
    prc->right  = prc->left + w;
    prc->bottom = prc->top  + h;
}

//
// CenterRectToMonitor
//
// uses GetMonitorRect to center a rect to the monitor that
// the passed window is on.
//
void CenterRectToMonitor(HWND hwnd, RECT *prc, BOOL fWork)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;

    // Core
    RECT rc;
    int  w = prc->right  - prc->left;
    int  h = prc->bottom - prc->top;

    GetMonitorRect(hwnd, &rc, fWork);

    prc->left	= rc.left + (rc.right  - rc.left - w) / 2;
    prc->top	= rc.top  + (rc.bottom - rc.top  - h) / 2;
    prc->right	= prc->left + w;
    prc->bottom = prc->top  + h;
}

//
// CenterWindowToMonitor
//
void CenterWindowToMonitor(HWND hwndP, HWND hwnd, BOOL fWork)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;
	ASSERT(hwndP != NULL) ;

    // Core
    RECT rc;
    GetWindowRect(hwnd, &rc);
    CenterRectToMonitor(hwndP, &rc, fWork);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

//
// ClipWindowToMonitor
//
void ClipWindowToMonitor(HWND hwndP, HWND hwnd, BOOL fWork)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;
	ASSERT(hwndP != NULL) ;

    // Core
    RECT rc;
    GetWindowRect(hwnd, &rc);
    ClipRectToMonitor(hwndP, &rc, fWork);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

//
// IsWindowOnScreen
//
BOOL IsWindowOnScreen(HWND hwnd)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;

    // Core
    HDC hdc;
    RECT rc;
    BOOL f;

    GetWindowRect(hwnd, &rc);
    hdc = GetDC(NULL);
    f = RectVisible(hdc, &rc);
    ReleaseDC(NULL, hdc);
    return f;
}

//
// MakeSureWindowIsVisible
//
void MakeSureWindowIsVisible(HWND hwnd)
{
	// Preconditions
	ASSERT(hwnd != NULL) ;

    // Core
    if (!IsWindowOnScreen(hwnd))
    {
		ClipWindowToMonitor(hwnd, hwnd, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\menuprxy.h ===
#ifndef _menuprxy_h
#define _menuprxy_h

///////////////////////////////////////////////////////////////////////////////
// CMenuPopupProxy
// This class implements the bar proxy on top of a CBMenuPopup.
class CMenuPopupProxy : public CToolBarProxy
{
public:
	// Attach the proxy to a CBMenuPopup.
	void AttachMenu(class CBMenuPopup* pPopup);

// CToolBarProxy methods.

	// Use these to work with the underlying "real" objects.
	virtual CWnd* GetWindow();

	// "Bar" states.
    virtual BOOL IsInDialog();
	virtual UINT GetExpansionConstraint(const CRect &expand, ORIENTATION *orBar=NULL);
	virtual int GetCount() const;
	virtual DWORD GetBarStyle() const;
	virtual BOOL HasButtonExtra() const;
	virtual const CSize GetButtonSize() const;
	virtual const CSize GetImageSize() const;
	virtual HBITMAP GetImageWell(int nIndex);
	virtual int GetImageIndex(int nIndex) const;
	// TRUE if this bar is using large buttons
	virtual BOOL HasLargeButtons() const;

	// Interact with items states.
	virtual UINT GetButtonStyle(int nIndex) const;
	virtual BOOL IsStaticItem(int nIndex);
	virtual BOOL IsGapItem(int nIndex);
	virtual const CString& GetButtonText(int nIndex) const;
	virtual HWND GetButtonControl(int nIndex) const;
	virtual HBITMAP GetButtonImage(int nIndex) const;
	virtual void SetButtonControl(int nIndex, HWND hControl);
	virtual void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	virtual void GetButtonInfoEx(int nIndex, HWND& hControl, CString& rText, HBITMAP& hImage) const;
	virtual int GetButtonCmdID(int nIndex);
	virtual BOOL HasExInfo(int nIndex) const;
	// call this when the button has been modified to mark the bar dirty and possibly redraw (if bSized==TRUE)
	virtual void ButtonModified(int nIndex, BOOL bSized);
	// Removes a separator before a button
	virtual void RemoveSeparator(int iButton);
	// Inserts a separator before a button
	virtual void InsertSeparator(int iButton);
	// returns true if the item is a control, and is currently visible
	virtual BOOL IsVisibleControl(int iButton) { return FALSE; };
	// returns if the specified button can be shown with text
	virtual APPEARANCEOPTION CanText(int iButton);
	// returns if the specified button can be shown with a glyph
	virtual APPEARANCEOPTION CanGlyph(int iButton);
	// returns any limitations on the appearance of a given button style 
	virtual APPEARANCEOPTION CanText(UINT nStyle);
	// returns any limitations on the appearance of a given button style
	virtual APPEARANCEOPTION CanGlyph(UINT nStyle);
	// returns the appearance of a button
	virtual APPEARANCE GetAppearance(int iButton);
	// returns the default appearance of a button
	virtual APPEARANCE GetAppearance();
	// returns the appearance of a button of a given type when placed in this kind of container. If these display components
	// are not available, the custom button dialog will appear
	virtual APPEARANCE GetInitialAppearance(UINT nStyle);
	// allocates or returns an individual glyph bitmap for a given button
	virtual HBITMAP CreateSingleBitmap(int iButton);
	// always call this function if the one above returns non-null. Do not delete hbmSingle yourself, since it
	// may still be in use elsewhere
	virtual void DestroySingleBitmap(int iButton, HBITMAP hbmSingle);

	// Operations
	virtual int InsertButton(int nIndex, TRANSFER_TBBUTTON& trans, BOOL bReplace, GAP gap);
	virtual void DeleteButton(int nIndex, BOOL bMoving = FALSE);
    virtual void RecalcLayout(UINT nHTSize = HTRIGHT);
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const;
	virtual int IndexFromPoint(const CPoint& pt, CRect *pButtonRect) const;
	virtual int HitTest(CPoint point) const;
	virtual CToolBarProxy* NewBar(UINT nID, const CPoint& rect);
	virtual void GetButtonTransferInfo(int nIndex, DWORD& dwData, TRANSDATA_CALLBACK* lplpDataCallback) const;
	virtual BOOL CanChooseAppearance();
	virtual BOOL CanPasteImage();
	virtual BOOL CanResetImage();
	virtual void PasteButtonImage();
	virtual void ResetButtonImage();
	virtual ORIENTATION GetOrient() const;
	// adds text to the button
	void AddText(int nIndex); // default menu text
	void AddText(int nIndex, const CString &text, BOOL bCustom);
	// add or replace the bitmap of a button.
	void AddBitmap(int nIndex, BITMAPSOURCE bsSource=cBitmapSourcePackage, HBITMAP hbmCustom=NULL);
	// remove the label from a glyph+label button
	void RemoveText(int nIndex) { ASSERT(FALSE); };
	// remove the glyph from a glyph+label button
	void RemoveBitmap(int nIndex);
	// remove all items from the bar
	virtual void Empty(void);
	virtual BOOL ExpandDestination(int nCmdIDSrc, int nIndexDest);
	// returns the next visible item after the specified one. nIndex==-1 gets the first visible item
	virtual int FindNextVisibleItem(int nIndex, BOOL bForward);

	virtual void BatchBegin(int nCount=0);
	virtual void BatchAdd(int nIndex, int nID, UINT nStyle, int nExtra, HBITMAP hGlyph, const CString &name);
	virtual void BatchEnd();

	// Notifications
	virtual void OnSelChange(int nIndex);
	virtual void OnDeleteSelection();
	virtual void OnBarActivate();
	virtual void OnButtonSize();
	virtual void OnButtonMove(int nIndex);

protected:
	virtual void* _GetRealObject();

private:
	class CBMenuPopup* m_pPopup;
	CMapPtrToPtr m_mapBtnExtra;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\msgboxes.cpp ===
/* MsgBoxes.cpp
 *
 * Purpose:	To provide a uniform set of message box services for all
 *			packages in Dolphin that conforms with WADG.
 *
 * Created:	22 July 1993 -by- Andrew Milton [w-amilt]
 *
 * Notes:	Message box calls come in several flavours and default values
 *			see the header file <MsgBoxes.h> for more information.
 *
 * Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
 ****************************************************************************/

#include "stdafx.h"
#include <tchar.h>
#include "msgboxes.h"
#include "resource.h"

#include "utilauto.h" // g_pAutomationState

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/* Local Data and Macros ****************************************************/

#define ALL_ICONS	(MB_ICONEXCLAMATION |\
					 MB_ICONINFORMATION |\
					 MB_ICONQUESTION 	|\
					 MB_ICONSTOP)

#define ALL_MODES	(MB_APPLMODAL 	|\
					 MB_SYSTEMMODAL	|\
					 MB_TASKMODAL)


/* WARNING!!!	WARNING!!!	WARNING!!!
 *
 * The following three arrays define the style of each type of message box.
 * If you add a message box type, then you MUST alter all three of these
 * arrays to reflect the change.
 *
 * The default message box style is given by
 *
 * nStyle = g_rnButtonStyles[BoxType] | g_rnIconStyles[BoxType] | MB_APPLMODAL
 *
 * (except for InternalErrors, which are MB_SYSTEMMODAL).
 *
 * The message box will beep when raised if g_rfBeepOnMessage[BoxType] is
 * TRUE.
 */

#define ArrayLength(x) (sizeof(x)/sizeof((x)[0]))

static UINT g_rnButtonStyles[] = {
	MB_OK,
	MB_YESNOCANCEL,
	MB_OK,
	MB_OK,
	MB_OK
};

static UINT g_rnIconStyles[] = {
	MB_ICONINFORMATION | MB_SETFOREGROUND,
	MB_ICONQUESTION | MB_SETFOREGROUND,
	MB_ICONEXCLAMATION | MB_SETFOREGROUND,
	MB_ICONSTOP | MB_SETFOREGROUND,
	MB_ICONSTOP | MB_SETFOREGROUND
};

static BOOL g_rfBeepOnMessage[] = {
	FALSE,
	FALSE,
	FALSE,
	TRUE,
	TRUE
};

static CUIntArray g_HelpStack;
static UINT g_nCrntHelp;

/**************************** Public Function *******************************\
 InitMsgBoxes()

 Purpose:	To perform a sanity check on the message box style arrays and to
 			initialize the default F1-help behavior

 Returns:	Nada.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

extern void
InitMsgBoxes()
{
// Make sure that our message box data arrays are the correct length.

	ASSERT(ArrayLength(g_rnButtonStyles) == NUMBER_OF_MESSAGE_BOXES);
	ASSERT(ArrayLength(g_rnIconStyles) == NUMBER_OF_MESSAGE_BOXES);
	ASSERT(ArrayLength(g_rfBeepOnMessage) == NUMBER_OF_MESSAGE_BOXES);

// Initialize the help stack.

	g_HelpStack.SetSize(20, 20);
	g_nCrntHelp = 0;
	g_HelpStack[g_nCrntHelp] = 0;
	return;
}

/************************** DLL Exported Function ***************************\
 PushHelpContext()
 PopHelpContext()

 Purpose:	To set/reset the default message box F1-help context.

 Returns:	Push - Nada.  Pop - last help context

 Notes:		These functions should *not* be called directly.  The
 			CLocalHelpContext constuctor/destructor call them to set up local
			help contexts, and using this class guarantees that help contexts
			will be reset at the end of a scope block.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

void
PushHelpContext(
	UINT nNewHelp)
{
	g_nCrntHelp++;
	g_HelpStack.SetAtGrow(g_nCrntHelp, nNewHelp);
	return;
}

UINT
PopHelpContext()
{
	ASSERT(g_nCrntHelp > 0);
	g_nCrntHelp--;
	return(g_HelpStack[g_nCrntHelp + 1]);
}

/************************** DLL Exported Function ***************************\
 MsgText()

 Purpose:	To format text for display in a message box.

 Returns:	Constant pointer to the formatted text.

 Notes:		This is an overloaded function.  The implementation below is for
 			formatting file-related error messages in the standard COMMDLG
			format.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	LPCTSTR pszOperation,
	const CFileException *peOffence)
{
	CString strMsgFormat;
	CString strOffense;

// Fetch the strings we need

	VERIFY(strMsgFormat.LoadString(IDS_FILE_ERROR_FORMAT));
    VERIFY(strOffense.LoadString(IDS_FEXCEP_NONE +
    								peOffence->m_cause));

// Get some space in the buffer...

    int cchBuffer = strMsgFormat.GetLength() + MAX_SUBSTITUTION_BYTES;
    LPTSTR pszBuffer = strBuffer.GetBuffer(cchBuffer);

// ...and fill it.

	VERIFY(_sntprintf(pszBuffer, cchBuffer,
					(const TCHAR *) strMsgFormat,
					(const TCHAR *) pathOffendingFile,
					(const TCHAR *) pszOperation,
					(const TCHAR *) strOffense) < cchBuffer);
	strBuffer.ReleaseBuffer();

	return strBuffer;
}

/************************** DLL Exported Function ***************************\
 SubstituteBytes()

 Purpose:	To construct a display string given a CString buffer, a format
 			string, and a va_list of substitution variables.

 Returns:	Constant pointer to the constructed string.

 Notes:		This function should *not* be called directly.  It is used by the
 			inline versions of the MsgText() functions to construct message
 			box string.  See the header file for details.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

LPCTSTR
SubstituteBytes(
	CString &strBuffer,
	LPCTSTR pszFormat,
	va_list VarArguments)
{
// Get some space in the buffer...

    int cchBuffer = lstrlen(pszFormat) + MAX_SUBSTITUTION_BYTES;
    LPTSTR pszBuffer = strBuffer.GetBuffer(cchBuffer);

// ...and fill it.

	VERIFY(wvsprintf(pszBuffer, pszFormat, VarArguments) < cchBuffer);
	strBuffer.ReleaseBuffer();

	return strBuffer;
}

/************************** DLL Exported Function ***************************\
 MsgBox()

 Purpose:	To display a message box that conforms to the WADG.

 Returns:	The ID of the button pressed to dismiss the message.

 Notes:		- No mode or icon flags are allowed to be set for the message
 			box by the calling function.  If any are slipped in with the
			button options, then we ASSERT.
			- No button options are allowed with Information or FatalError
			message box types
			- If Dolphin is not active, then the IDE main frame is set into
 			a flash state & the message box is suppressed until Dolphin
 			becomes active.
			- The displayed icon & default buttons are determined by the
			g_rnDefaultButtons[] and g_rnIconStyles[] arrays.  See the
			WARNING!!! above.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

int
MsgBox(
	const MsgBoxTypes MsgBoxType,
	LPCTSTR pszMessage,
	UINT nIDButtons,	/* = DEFAULT_BUTTONS	*/
	UINT nHelpContext)	/* = DEFAULT_HELP		*/
{
		

// Entering sanity check:
// 	- no button options with an info or fatal error box, and
// 	- the button options contain no icon or mode requests.

	ASSERT(MsgBoxType != Information || nIDButtons == DEFAULT_BUTTONS);
	ASSERT(MsgBoxType != FatalError  || nIDButtons == DEFAULT_BUTTONS);

	ASSERT(nIDButtons == DEFAULT_BUTTONS || (nIDButtons & (~(MB_TYPEMASK | MB_DEFMASK))) == 0);

//
// If we are in automation mode, we shouldn't put up the message box.
//
	if ((!g_pAutomationState->DisplayUI()) || (theApp.m_bRunInvisibly))
	{
		if (theApp.m_bInvokedCommandLine)
		{
			theApp.WriteLog(pszMessage, TRUE);
		}
		switch(MsgBoxType)
		{
		// Pretend that we put up the dialog.
		case Information:
			return IDOK; 
			break ;

		// Put up the message box no matter what.
		case InternalError:
		case FatalError:
			// These are serious errors, so ignore the automation object!!!
			break ;

		// The following may have changed their button styles
		case Error:
			if (nIDButtons == DEFAULT_BUTTONS)
			{
				// Pretend that we did the message box.
				return IDOK;
			}
			else
			{
				// Don't know which button to press without a user!
				ASSERT(0) ;
			}
			break ;

		// We don't know how to handle the following!!!
		case Question:
		default:
			ASSERT(0) ;
			break ;
		};
		if (theApp.m_bInvokedCommandLine)
		{
			return IDOK; // make the best of it
		}
	}

// Do special processing for different box types.

	CString strErrText;
	BOOL fPanic;
	switch (MsgBoxType)
	{
	case InternalError:
	// Substitute the message into the "Internal Error" string
		pszMessage = MsgText(strErrText, IDS_INTERNAL_ERROR, pszMessage);
		break;

	case FatalError:
	// Start to panic.  Note that panicking is not implemented yet.
		fPanic = TRUE;
		break;

	default:
		break;
	}

// Set the message box style & F1 help context

	if (nIDButtons == DEFAULT_BUTTONS)
		nIDButtons = g_rnButtonStyles[MsgBoxType];
	if (nHelpContext == DEFAULT_HELP)
		nHelpContext = g_HelpStack[g_nCrntHelp];

	nIDButtons &= (MB_TYPEMASK | MB_DEFMASK);
	UINT nBoxStyle;
	if (MsgBoxType != InternalError)
		nBoxStyle = nIDButtons | g_rnIconStyles[MsgBoxType] | MB_APPLMODAL;
	else
		nBoxStyle = nIDButtons | g_rnIconStyles[MsgBoxType] | MB_SYSTEMMODAL;

	// testing would like a TRACE for all assertions
	if (MsgBoxType == InternalError)
	{
		::OutputDebugString(_T("Assertion failed: "));
		::OutputDebugString(pszMessage);
		::OutputDebugString(_T("\r\n"));
	}

// If we're not active, enter a new flash state pump.  (Do not do this for
// internal errors, because internal error message boxes could be coming
// from any thread, and FlashStatePump only works for the main thread.)

	if ((!theApp.m_fVCPPIsActive || theApp.m_pMainWnd->IsIconic()) && MsgBoxType != InternalError)
	{
		MessageBeep(g_rnIconStyles[MsgBoxType]);
		((CTheApp *)AfxGetApp())->FlashStatePump();
	}
	if (g_rfBeepOnMessage[MsgBoxType])
		MessageBeep(g_rnIconStyles[MsgBoxType]);

// We guarantee that the cursor is visible with a call to ShowCursor.
// NB:  if we don't have a mouse, the cursor show count *should*
// be -1, so incrementing won't cause the cursor to come up.

	ShowCursor(TRUE);

// Now pop the box.  For InternalErrors (assertions), use the desktop
// as the owner window rather than letting MFC decide what window to use
// as the owner, because we're multithreaded, and MFC may pick a window
// whose thread is currently blocked.

	int nRetCode;
	if (MsgBoxType != InternalError)
	{
		nRetCode = AfxMessageBox(pszMessage, nBoxStyle, nHelpContext);
	}
	else
	{
		PreModalWindow();
		AfxGetApp()->EnableModeless(FALSE);
		nRetCode = ::MessageBox(NULL, pszMessage, theApp.m_pszAppName,
			nBoxStyle);
		AfxGetApp()->EnableModeless(TRUE);
		PostModalWindow();
	}
	ShowCursor(FALSE);
	return nRetCode;
}

/*

The FatalErrorBox() code is still here for example purposes only.  This is
what the IDE did in a panic situation. [w-amilt]

void FatalErrorBox(
	UINT line1,
	LPSTR line2)
{
	char text[MAX_MSG_TXT], buffer[256];

	if (line1 == 0)
		*text = 0;
	else
		Dbg(LoadString(hInst, line1, text, sizeof(text)));

	if (line2)
		sprintf(buffer, "%s %Fs",text, line2);
	else
		sprintf(buffer, "%s",text);


	Dbg(MsgBox(FatalError, buffer));

	emergency = TRUE;

	// Don't send this message if hwndFrame doesn't exist yet!
	if (hwndFrame != NULL)
		SendMessage(hwndFrame, WM_CLOSE, 0, 0L);
}
*/

#ifndef DS_CONTEXTHELP
#define DS_CONTEXTHELP 0x2000L
#endif

static const int nFontSize = 10;

/////////////////////////////////////////////////////////////////////////////
// CMessageBox dialog

int CMessageBox::DoMessageBox(LPCSTR lpszText, LPCSTR lpszCaption,
	LPCSTR lpszButtons, WORD wStyle, int nDef, int nCancel,
	DWORD* pHelpIDs, CWnd* pParentWnd)
{
	CMessageBox dlg(lpszText, lpszCaption, lpszButtons, wStyle, pHelpIDs,
		pParentWnd);
	dlg.SetDefault(nDef);
	dlg.SetCancel(nCancel);
	return dlg.DoModal();
}

CMessageBox::CMessageBox(LPCSTR lpszText, LPCSTR lpszCaption,
	LPCSTR lpszButtons, WORD wStyle, DWORD* pHelpIDs ,
	CWnd* pParentWnd)
{

	ASSERT(lpszText != NULL);
	ASSERT(lpszCaption != NULL);
	if (HIWORD(lpszText) == NULL)
		VERIFY(m_strText.LoadString(LOWORD((DWORD)lpszText)));
	else
		m_strText = lpszText;
	if (HIWORD(lpszCaption) == NULL)
		VERIFY(m_strCaption.LoadString(LOWORD((DWORD)lpszCaption)));
	else
		m_strCaption = lpszCaption;
	if (lpszButtons != NULL)
		AddButtons(lpszButtons);

	m_pParentWnd = pParentWnd;
	m_nDefButton = 0;
	m_nCancel = -1;
	m_pButtons = NULL;
	m_wStyle = wStyle;
	m_nBaseID = 10;		// don't use IDOK, IDCANCEL, etc
	m_hDlgTmp = NULL;

	m_pFont = GetStdFont(theApp.m_bWin4 ? font_Normal : font_Bold);

//	LOGFONT lf;
//	memcpy(&lf, &theApp.m_lf, sizeof(LOGFONT));
//	lf.lfHeight = -nFontSize;
//	lf.lfWidth = 0;
//	lf.lfWeight = FW_NORMAL;
//	VERIFY(m_font.CreateFontIndirect(&lf));

//	m_font.CreateFont(-nFontSize, 0, 0, 0, FW_NORMAL, FALSE, FALSE,
//		FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
//		DEFAULT_QUALITY, DEFAULT_PITCH|FF_DONTCARE, szFontName);
	m_pHelpIDs = pHelpIDs;
}

CMessageBox::~CMessageBox()
{
	delete [] m_pButtons;
	if (m_hDlgTmp != NULL)
		GlobalFree(m_hDlgTmp);
}

BEGIN_MESSAGE_MAP(CMessageBox, CDialog)
	//{{AFX_MSG_MAP(CMessageBox)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessageBox message handlers

int CMessageBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (m_pHelpIDs != NULL)
	{
		for (int i=0;i<m_strArray.GetSize();i++)
			m_pHelpIDs[i*2] = i+m_nBaseID;
	}
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	SetWindowText(m_strCaption);
	m_pButtons = new CButton[m_strArray.GetSize()];

	CRect rect(0, 0, 10, 10);
	if (!m_staticIcon.Create(NULL,
		SS_ICON | WS_GROUP | WS_CHILD | WS_VISIBLE, rect, this))
	{
		return -1;
	}
	m_staticIcon.SetIcon(::LoadIcon(NULL, GetIconID(m_wStyle)));

	if (!m_staticText.Create(m_strText, SS_LEFT | SS_NOPREFIX | WS_GROUP |
		WS_CHILD | WS_VISIBLE, rect, this))
	{
		return -1;
	}
	m_staticText.SetFont(m_pFont);
	
	for (int i=0;i<m_strArray.GetSize();i++)
	{
		if (!m_pButtons[i].Create(m_strArray[i], WS_TABSTOP | WS_CHILD |
			WS_VISIBLE | ((i == 0) ? WS_GROUP : 0) |
		    ((i == m_nDefButton) ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON),
		    rect, this, i+m_nBaseID))
		{
			return -1;
		}
		m_pButtons[i].SetFont(m_pFont);
	}
	PositionControls();
	return 0;
}

BOOL CMessageBox::OnInitDialog()
{
	CDialog::OnInitDialog();
	if (m_pHelpIDs != NULL) // context help
		ModifyStyleEx(0, WS_EX_CONTEXTHELP); //add

	m_pButtons[m_nDefButton].SetFocus();	
	return FALSE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CMessageBox operations

void CMessageBox::AddButtons(LPCSTR lpszButton)
{
	CString str, strButtons;
	int i=0;
	if (HIWORD(lpszButton) == NULL)
		strButtons.LoadString(LOWORD((DWORD)lpszButton));
	else
		strButtons = lpszButton;
	while (AfxExtractSubString(str, strButtons, i++, '\n'))
		AddButton(str);
}

#ifndef DS_3DLOOK
#define DS_3DLOOK 0x4
#endif

void CMessageBox::FillInHeader(LPDLGTEMPLATE lpDlgTmp)
{
	lpDlgTmp->style = DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
		WS_CAPTION | WS_SYSMENU;
//	if (theApp.m_bOnChicago)
//		lpDlgTmp->style |= DS_CONTEXTHELP;		// we don't want to deal with Help here
	lpDlgTmp->dwExtendedStyle = 0;
	lpDlgTmp->cdit = 0;
	lpDlgTmp->x = 0;
	lpDlgTmp->y = 0;
	lpDlgTmp->cx = 100;
	lpDlgTmp->cy = 100;
	
	LPWSTR lpStr = (LPWSTR)(lpDlgTmp + 1); /* Move ptr to the variable fields */

	*lpStr++ = 0;  /* No Menu resource for Message Box */
	*lpStr++ = 0;  /* No Class name for MessageBox */
	
	mbstowcs(lpStr, m_strCaption, m_strCaption.GetLength());

	lpStr += m_strCaption.GetLength()+1;
	WORD* pWord = (WORD*)lpStr;
	*pWord = 10; // 10 pt font
	pWord++;
	lpStr = (LPWSTR) pWord;

	const LOGFONT* plf = GetStdLogfont(font_Normal);
	LPCTSTR lpsz = plf->lfFaceName;
	mbstowcs(lpStr, lpsz, lstrlen(lpsz));
}

/////////////////////////////////////////////////////////////////////////////
// CMessageBox overridables

BOOL CMessageBox::OnCommand(WPARAM wParam, LPARAM /*lParam*/)
{
	if (wParam == IDCANCEL && m_nCancel != -1)
	{
		EndDialog(m_nCancel);
		return TRUE;
	}
	if (::GetDlgItem(m_hWnd, wParam)==NULL)
		return FALSE;
	EndDialog(wParam-m_nBaseID);
	return TRUE;
}

int CMessageBox::DoModal()
{
	ASSERT(m_strArray.GetSize() != 0);
	if (m_strArray.GetSize() == 0)
		return (m_nCancel != -1) ? m_nCancel : 0;

	// compute size of header
	// Fixed portions of DLG template header = sizeof(DLGTEMPLATE);
    // One null byte for menu name and one for class name = 2
	// Caption text plus NULL = m_strCaption.GetLength()+1
	int nSize = sizeof(DLGTEMPLATE);
	const LOGFONT* plf = GetStdLogfont(font_Normal);
	nSize += (2 + m_strCaption.GetLength()+1+lstrlen(plf->lfFaceName)+1)*2 +sizeof(WORD);
	m_hDlgTmp = GlobalAlloc(GPTR, nSize);
	if (m_hDlgTmp == NULL)
		return IDCANCEL;
	LPDLGTEMPLATE lpDlgTmp = (LPDLGTEMPLATE)GlobalLock(m_hDlgTmp);
	FillInHeader(lpDlgTmp);
	GlobalUnlock(m_hDlgTmp);
	InitModalIndirect(m_hDlgTmp);	

	return CDialog::DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMessageBox implementation

void CMessageBox::PositionControls()
{
	CSize sizeBase = GetBaseUnits();
	int nButtonHeight = (sizeBase.cy*14)/8;
	int nHeight = 0;
	int nSep,nLeftMargin,nRightMargin,nTopMargin,nBottomMargin;
    int nButtonAdj;
    int nWidth = 0;
    CRect rectText;

	// a) 5/8 screen Width
	// b) Caption
	// c) nLeftMargin ICON nSep TEXT nRightMargin
	// d) nLeftMargin Button1 nSep Button2 ... nRightMargin
	// client width is max(b,d, min(c,a))

	CSize sizeIcon(GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));
	nSep = sizeIcon.cx/2;
	nLeftMargin = nSep;
	nRightMargin = nSep;
	nTopMargin = nSep;
	nBottomMargin = nSep;
	
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(m_pFont);
	
	nButtonAdj = dc.GetTextExtent("XXX",3).cx; // padding on buttons
	
	int nScreenWidth58 = dc.GetDeviceCaps(HORZRES)*5/8;
	int nCaptionWidth = dc.GetTextExtent(m_strCaption, m_strCaption.
		GetLength()).cx;
//	CSize sizeText = dc.GetTextExtent(m_strText,m_strText.GetLength());
	CRect rcText(0, 0, 0, 0);
	CSize sizeText = rcText.Size();
	dc.DrawText(m_strText,m_strText.GetLength(), &rcText, DT_CALCRECT);
	int nTextIconWidth = nLeftMargin+sizeIcon.cx+nSep+sizeText.cx+nRightMargin;
	int nButtons = m_strArray.GetSize();
	int nButtonsWidth = nLeftMargin+nRightMargin+(nButtons-1)*nSep;
	for (int i=0;i<nButtons;i++)
	{
		nButtonsWidth +=
			dc.GetTextExtent(m_strArray[i],m_strArray[i].GetLength()).cx+
			nButtonAdj*2;
	}
	
	nWidth = min(nTextIconWidth,nScreenWidth58);
	nWidth = max(nWidth, nCaptionWidth);
	nWidth = max(nWidth, nButtonsWidth);

	m_staticIcon.SetWindowPos(NULL, nLeftMargin, nTopMargin, sizeIcon.cx,
		sizeIcon.cy, SWP_NOZORDER);

	if (sizeText.cx > nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep)
	{
		sizeText.cx = nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep;
//		int nTextWidth = nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep;
//		rectText.SetRect(0, 0, nTextWidth, 32767);
		rectText.SetRect(0, 0, sizeText.cx, 32767);
		/* Ask DrawText for the right cy */
		sizeText.cy = dc.DrawText(m_strText, m_strText.GetLength(), &rectText,
			DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX);
	}
	
	m_staticText.SetWindowPos(NULL, nSep+sizeIcon.cx+nSep, nTopMargin,
		sizeText.cx, sizeText.cy, SWP_NOZORDER);
	
	sizeText.cy = max(sizeText.cy, sizeIcon.cy); // at least icon height
	nHeight = nTopMargin + sizeText.cy + nSep + nButtonHeight + nBottomMargin;

	CRect rect;
	rect.left = (nWidth - (nButtonsWidth - nLeftMargin - nRightMargin))/2;
	rect.top = nTopMargin + sizeText.cy + nSep;
	rect.bottom = rect.top + nButtonHeight;

	for (i=0;i<m_strArray.GetSize();i++)
	{
		rect.right = rect.left + dc.GetTextExtent(m_strArray[i],m_strArray[i].GetLength()).cx +
			2*nButtonAdj;
		m_pButtons[i].MoveWindow(&rect);
		rect.left = rect.right + nSep;
	}

	rect.SetRect(0,0,nWidth,nHeight);
	CalcWindowRect(&rect);
	SetWindowPos(NULL, (dc.GetDeviceCaps(HORZRES)-rect.Width())/2,
		(dc.GetDeviceCaps(VERTRES)-rect.Height())/2, rect.Width(), rect.Height(),
		SWP_NOZORDER|SWP_NOACTIVATE);
	if(m_nCancel == -1) // no cancel button
	{
//		CMenu* pMenu = GetSystemMenu(FALSE);
//		if (pMenu != NULL)
//			pMenu->DeleteMenu(SC_CLOSE, MF_BYCOMMAND);
	}
	dc.SelectObject(pOldFont);
}

CSize CMessageBox::GetBaseUnits()
{
	CWindowDC dc(GetDesktopWindow());
	CFont* pFont = dc.SelectObject(m_pFont);
	TEXTMETRIC tm;
	VERIFY(dc.GetTextMetrics(&tm));
	dc.SelectObject(pFont);
	return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

LPCSTR CMessageBox::GetIconID(WORD wFlags)
{
	wFlags &= MB_ICONMASK;
	switch( wFlags )
	{
		case MB_ICONHAND:
			return IDI_HAND;
		case MB_ICONQUESTION:
			return IDI_EXCLAMATION;
//			return IDI_QUESTION; NOTE: style guide says don't use this!
		case MB_ICONEXCLAMATION:
			return IDI_EXCLAMATION;
		case MB_ICONASTERISK:
			return IDI_ASTERISK;
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\newwsdlg.cpp ===
// prjdlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlgbase.h"
#include "utilbld_.h"
#include "resource.h"
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CProjTypeListItem::CProjTypeListItem(const TCHAR* szText, HICON hIcon, TYPE_ITEM_CLASS itemClass,
									 int index /* =0*/)
{
	m_strText = szText;
	m_class = itemClass;
	m_hIcon = hIcon;
	m_index = index;
}

CProjTypeListItem::~CProjTypeListItem()
{
}
	
void GetRegWorkspaceDir(CString& strLocation);

BOOL RunFileExistsDlg(const char* szFile)
{
	TCHAR strIn[80];
	TCHAR strOut[2048];
	// dont use AfxFormatString, other people need ERR_File_Exists too!
	AfxLoadString(ERR_File_Exists, strIn );
	wsprintf( strOut, strIn, szFile );
	return
		(AfxMessageBox(strOut, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDYES);
}

static BOOL DoesFileExist(const char* szFile)
{
    struct _stat st;
    return (_stat(szFile, &st) == 0);
}

BOOL DestroyFile(const char* szFile)
{
	if (!DoesFileExist(szFile))
		return TRUE;
	CString strPrompt;
	AfxFormatString1(strPrompt, IDS_ERROR_CANT_DELETE_FILE, szFile);
	while (::remove(szFile) == -1)
	{
		if (AfxMessageBox(strPrompt, MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
			return FALSE;
	}
	return TRUE;
}

// These guys make sure the user doesn't enter a "reserved" name as a workspace
// name.
static const char* rgszReservedWorkspace[] =
{
	"aux",
	"con",
	"ole2",
	"compobj",
	"mfcoleui",
	"ole2conv",
	"ole2disp",
	"ole2nls",
	"ole2prox",
	"storage",
	"typelib",
	"odbc",
	"comm",
	"lpt1",
	"lpt2",
	"lpt3",
	"lpt4",
	"com1",
	"com2",
	"com3",
	"com4",
	"nul",
	"gdi",
	"krnl386",
	"user",
	"win386",
    NULL
};

static BOOL IsReservedProjectName(const char* psz)
{
    for (const char **ppsz = rgszReservedWorkspace; *ppsz != NULL; ppsz++)
    {
        if (strcmp(psz, *ppsz) == 0)
            return TRUE;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Japanese-specific functions

// This tests whether we're on a Japanese system
BOOL IsJapaneseSystem(void)
{
	return (PRIMARYLANGID(GetSystemDefaultLangID()) == LANG_JAPANESE);
}

// This function assumes we're on a Japanese system
BOOL IsSBKatakana(unsigned char c)
{
	return c >= 0xa1 && c <= 0xdf;
}

#if 0
// Removed by martynl because never called
BOOL IsValidProjectName(const TCHAR* sz)
{
	if (sz[0] == _T('\0'))
		return FALSE;

	if (IsReservedProjectName(sz))
		return FALSE;

	int cchLeft = 8;                // 8 for file name
	DWORD dwMaxLen = 8;
	DWORD  dwDummy1;
	if (::GetVolumeInformation(NULL, NULL, 0, NULL, &dwMaxLen,
		&dwDummy1, NULL, 0))
	{
		// succesfully got info from file system -- use it.
		cchLeft = (int)dwMaxLen;
	}

	while (*sz != _T('\0'))
	{
		if (_istalnum(*sz) || *sz == '_' || *sz == ' ' || IsDBCSLeadByte(*sz)
			|| (IsJapaneseSystem() && IsSBKatakana(*sz)))
		{
			// count the character
			cchLeft -= _tclen(sz);
			if (cchLeft < 0)
				return FALSE;		// too long
		}
		else
		{
			return FALSE;
		}

		sz = _tcsinc(sz);
	}

	return TRUE;
}
#endif

BOOL IsAbsolutePath(const TCHAR* sz)
{
	return _istalpha(sz[0]) && sz[1] == _T(':') || 
		sz[0] == _T('\\') && sz[1] == _T('\\');
}

void EnsureSlashAtEnd(CString& str)
{
	const TCHAR* pch = str;
	const TCHAR* pchLast = NULL;
	while (*pch != _T('\0'))
	{
		pchLast = pch;
		pch = _tcsinc(pch);
	}

	if (pchLast == NULL || *pchLast != _T('\\'))
		str += _T('\\');
}

static const TCHAR szDirectories [] = _TEXT("Directories");
static const TCHAR szWorkspaceDir [] = _TEXT("WorkspaceDir");
static const TCHAR szInstallDirs [] = _TEXT("Install Dirs");
static const TCHAR szProjects [] = _TEXT("MyProjects");

void WriteRegWorkspaceDir(const CString& strLocation)
{
	WriteRegString(szDirectories, szWorkspaceDir, strLocation);
}

void GetRegWorkspaceDir(CString& strLocation)
{
	strLocation = GetRegString(szDirectories, szWorkspaceDir);

	if (strLocation.IsEmpty())
	{
		// get the msdev.exe directory
		TCHAR rgch[MAX_PATH];
		(void) GetModuleFileName(theApp.m_hInstance, rgch, MAX_PATH);

		CPath pathExe;
		CDir dirExe;
		if (pathExe.Create(rgch))
			dirExe.CreateFromPath((const CPath)pathExe);

		strLocation = dirExe;

		int ich = strLocation.ReverseFind(_T('\\'));
		if (ich != -1 && ich == (strLocation.GetLength() - 1))
		{
			// remove last backslash
			strLocation = strLocation.Left(strLocation.GetLength() - 1);
		}

		CString strTmp = strLocation.Right(19);
		if (strTmp.CompareNoCase(_TEXT("\\common\\msdev98\\bin")) == 0)
		{
			strLocation = strLocation.Left(strLocation.GetLength() - 19);
			strLocation += _TEXT("\\");
			strLocation += szProjects;
			return;
		}

		strTmp = strLocation.Right(20);
		if (strTmp.CompareNoCase(_TEXT("\\common\\msdev98\\bind")) == 0)
		{
			strLocation = strLocation.Left(strLocation.GetLength() - 20);
			strLocation += _TEXT("\\");
			strLocation += szProjects;
			return;
		}

		strTmp = strLocation.Right(4);
		if (strTmp.CompareNoCase(_TEXT("\\bin")) == 0)
		{
			strLocation = strLocation.Left(strLocation.GetLength() - 4);
			strLocation += _TEXT("\\");
			strLocation += szProjects;
			return;
		}

		strTmp = strLocation.Right(5);
		if (strTmp.CompareNoCase(_TEXT("\\bind")) == 0)
		{
			strLocation = strLocation.Left(strLocation.GetLength() - 5);
			strLocation += _TEXT("\\");
			strLocation += szProjects;
			return;
		}

		strLocation += _TEXT("\\");
		strLocation += szProjects;
	}
}

////////////////////////////////////////////////////////////////////////////
// CProjTypeIconList class

// THIS CLASS IS TEMPORARY!!!
BEGIN_MESSAGE_MAP(CProjTypeIconList, CIconList)
	ON_WM_DESTROY()
END_MESSAGE_MAP()

void CProjTypeIconList::OnDestroy()
{
	int nItemCount = GetCount();
	for (int i = 0; i < nItemCount; i += 1)
		delete (CProjTypeListItem*)GetItemDataPtr(i);

	CIconList::OnDestroy();
}

void CProjTypeIconList::SetIcon(int nItem, HICON hIcon)
{
	ASSERT(FALSE); // Not Used!
}

HICON CProjTypeIconList::GetIcon(int nItem)
{
	CProjTypeListItem* pItem = (CProjTypeListItem*)GetItemDataPtr(nItem);
	return pItem->GetIcon();
}

int CProjTypeIconList::AddItem(CProjTypeListItem* pItem)
{
	int nItem = AddString(pItem->GetText());
	ASSERT(nItem != LB_ERR);
	SetItemDataPtr(nItem, pItem);
	return nItem;
}

void CProjTypeIconList::InsertItem(int nInsertAt, CProjTypeListItem* pItem)
{
	InsertString(nInsertAt, pItem->GetText());
	SetItemDataPtr(nInsertAt, pItem);
}

////////////////////////////////////////////////////////////////////////////
// CProjTypeList class

CProjTypeList::CProjTypeList()
{

}


CProjTypeList::~CProjTypeList()
{
	int nItemCount = GetCount();
	for (int i = 0; i < nItemCount; i++)
		delete (CProjTypeListItem*)GetItemDataPtr(i);
}

HICON CProjTypeList::GetIcon(int nItem)
{
	CProjTypeListItem* pItem = (CProjTypeListItem*)GetItemDataPtr(nItem);
	return pItem->GetIcon();
}

int CProjTypeList::AddItem(CProjTypeListItem* pItem)
{
	int nItem = AddString(pItem->GetText());
	ASSERT(nItem != LB_ERR);
	SetItemDataPtr(nItem, pItem);
	return nItem;
}

void CProjTypeList::InsertItem(int nInsertAt, CProjTypeListItem* pItem)
{
	InsertString(nInsertAt, pItem->GetText());
	SetItemDataPtr(nInsertAt, pItem);
}

int CProjTypeList::AddString(LPCTSTR str)
{
	int nIndex = m_dataPtrs.Add(NULL);
	VERIFY(nIndex == m_strings.Add(str));
	return nIndex;
}

int CProjTypeList::InsertString(int nInsertAt, LPCTSTR str)
{
	m_dataPtrs.InsertAt(nInsertAt, (void *)NULL);
	m_strings.InsertAt(nInsertAt, str);
	return nInsertAt;
}

void CProjTypeList::GetText(int nItem, CString &str)
{
	ASSERT(nItem < GetCount());
	str = m_strings[nItem];
	return;
}

void *CProjTypeList::GetItemDataPtr(int nItem)
{
	ASSERT(nItem < GetCount());
	return m_dataPtrs[nItem];
}

void CProjTypeList::SetItemDataPtr(int nItem, void *ptr)
{
	ASSERT(nItem < GetCount());
	m_dataPtrs[nItem] = ptr;
	return;
}

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\multslob.cpp ===
#include "stdafx.h"

#include "util.h"
#include "slob.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// IMPLEMENT_DYNCREATE needs real new.
#undef new
#endif

IMPLEMENT_DYNCREATE(CMultiSlob, CSlob)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


CMultiSlob::CMultiSlob()
{
    m_pSlobWnd = NULL;
    m_bSolo = FALSE;
    m_bAllowEmpty = TRUE;
	m_bAllowMultipleContainers = FALSE;
}


CMultiSlob::~CMultiSlob()
{
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
		GetNext(pos)->RemoveDependant(this);
}


CObList* CMultiSlob::GetContentList()
{
	// This is not really a 'content' list since it contains
	// references to slobs that are probably really contained
	// some other slob.  This does make a lot of things very
	// convenient though...
	
    return &m_objects;
}


CSlobWnd* CMultiSlob::GetSlobWnd() const
{
    if (m_pSlobWnd != NULL)
        return m_pSlobWnd;

	// NOTE: This makes the assumption that all slobs in a selection
	// are displayed in the same CSlobWnd.
	
    if (!m_objects.IsEmpty())
        return GetDominant()->GetSlobWnd();

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// Drag and Drop Support

// Return an index into the cursor table for dragging this slob.
//
int CMultiSlob::GetCursorIndex()
{
    return GetDominant()->GetCursorIndex();
}

// Return a cursor for dragging this slob.
//
HCURSOR CMultiSlob::GetCursor(int ddcCursorStyle)
{
	return GetDominant()->GetCursor(ddcCursorStyle);
}


/////////////////////////////////////////////////////////////////////////////
// Selection Management


BOOL CMultiSlob::IsSelected(CSlob* pSlob) const
{
	return m_objects.Find(pSlob) != NULL;
}

BOOL CMultiSlob::IsOnlySelected(CSlob* pSlob) const
{
	return m_objects.GetCount() == 1 && m_objects.GetHead() == pSlob;
}

BOOL CMultiSlob::IsDominantSelected(CSlob* pSlob) const
{
	if (m_objects.IsEmpty())
		return FALSE;
	
	return m_objects.GetHead() == pSlob;
}

CSlob* CMultiSlob::GetDominant() const
{
	if (m_objects.IsEmpty())
		return NULL;
	
	return (CSlob*)m_objects.GetHead();
}


// This function selects a single slob, deselecting any previously
// selected slobs.  If bSolo is set, the slob will be deslected if
// any other slobs are 'added' to the selection (it's a loner and
// doesn't want to be part of a group selection).
//
void CMultiSlob::Single(CSlob* pSlob, BOOL bSolo /*=FALSE*/ )
{
    ASSERT(pSlob != NULL);

    if (IsOnlySelected(pSlob))
        return;

    Clear();
	Add(pSlob);
	m_bSolo = bSolo;
}


// This function adds a slob to the current selection.  The new
// slob will be the dominant member of the selection.
//
// NOTE:    This function always adds it's argument to the BEGINNING of
//          the multislob!  This makes cloning in forward order work
//          properly.  That's also how we know it's dominant...
//
void CMultiSlob::Add(CSlob* pSlob)
{
    if (m_bSolo)
    {
		// If the current selection is an object which insists on having
		// a solo selection (cannot be part of a multiple selection) then
		// we must deselect it.
		
		Clear();
		m_bSolo = FALSE;
    }

	if (m_pSlobWnd != NULL)
		m_pSlobWnd->HideSprites();

    if (!m_bAllowMultipleContainers && !m_objects.IsEmpty())
    {
		CSlob* pPrevDom = (CSlob*) m_objects.GetHead();

        // Only allow mulitple selections within a single container!
        if (pSlob->GetContainer() != pPrevDom->GetContainer())
			Clear();
    }
	
	// Check to see if it is already selected.
	POSITION pos = m_objects.Find(pSlob);
	if (pos != NULL)
		m_objects.RemoveAt(pos);

    m_objects.AddHead(pSlob);
	
	if (pos == NULL)
		pSlob->AddDependant(this);
	
    if (m_pSlobWnd != NULL)
	{
		m_pSlobWnd->ShowSprites();
        m_pSlobWnd->OnSelChange();
	}
	
    InformDependants(SN_ALL);
}


// This function removes a slob from the selection.
//
void CMultiSlob::Remove(CSlob* pSlob)
{
    POSITION pos = m_objects.Find(pSlob);
    ASSERT(pos != NULL);
	
    if (theUndoSlob.IsRecording())
        theUndoSlob.OnMultiRemove(this, pSlob);
	
	if (m_pSlobWnd != NULL)
		m_pSlobWnd->HideSprites();
	
    m_objects.RemoveAt(pos);
    pSlob->RemoveDependant(this);

	// Now we have to fix the state of the remaining slobs in the
    // selection.
	
    int count = m_objects.GetCount();
    if (count == 0 && !m_bAllowEmpty)
	{
		CSlob* pContainer = pSlob->GetContainer();
		if (pContainer != NULL)
		{
			ASSERT(pContainer != NULL);
			Single(pContainer);
			return;
		}
    }
	
    if (m_pSlobWnd != NULL)
	{
		m_pSlobWnd->ShowSprites();
        m_pSlobWnd->OnSelChange();
	}

    InformDependants(SN_ALL);
}


// Remove all items from the current selection, leaving it empty.
//
void CMultiSlob::Clear()
{
	if (m_pSlobWnd != NULL)
		m_pSlobWnd->HideSprites();
	
    while (!m_objects.IsEmpty())
    {
        CSlob* pSlob = (CSlob*)m_objects.RemoveHead();
        pSlob->RemoveDependant(this);
    }
	
	if (m_pSlobWnd != NULL)
		m_pSlobWnd->ShowSprites();
	
    InformDependants(SN_ALL);
}


/////////////////////////////////////////////////////////////////////////////
//

// CMultiSlob::Delete
//
// This handles the delete and cut commands for all slob-based editors.
// The bClip parameter set to TRUE indicates this is a Cut and things
// should be placed in the clipboard.  If any slobs refuse to go away, 
// they are left selected. Return value is TRUE iff all of the selection 
// is deleted.  If ppNextSlob != NULL, a pointer to the first item after 
// the last selected item is stuck there (or the first item if the last 
// was deleted, or the container if all are gone).  This may be used to 
// set the selection at the end of the delete.
//
BOOL CMultiSlob::Delete(BOOL bClip, CSlob** ppNextSlob)
{
    CWaitCursor waitCursor;

    CSlob* pContainer = ((CSlob*)m_objects.GetHead())->GetContainer();
    CObList* conList = pContainer->GetContentList();
    ASSERT(conList != NULL);

    theUndoSlob.BeginUndo(bClip ? IDS_UNDO_CUT : IDS_UNDO_DELETE );
    
    if (bClip)
        theClipboardSlob.ClearContents();

    CObList deathRow;
    deathRow.AddHead(&m_objects);

    // Clear out the selection before deleting things to prevent an
    // illegal state...
    Clear();

    // Then delete the ones that were selected...
    POSITION nextPos = NULL;
    BOOL bVeto = FALSE;
    POSITION pos = deathRow.GetHeadPosition();
    while (pos != NULL)
    {
        if (InEmergencyState())
        {
            bVeto = TRUE;
            break;
        }

        CSlob* pSlob = (CSlob*)deathRow.GetNext(pos);
        if (pSlob->CanAct(bClip ? act_cut : act_delete))
        {
            if (ppNextSlob != NULL)
            {
                // don't need to do this if we aren't 
                // interested in the selection at the end
                POSITION slobPos = conList->Find(pSlob);
                if (slobPos != NULL)
                {
                    nextPos = slobPos;
                    conList->GetNext(nextPos);
                }
            }
            
            if (bClip)
            {
                CSlob* pClone = pSlob->Clone();
                if (pClone != NULL)
                    pClone->MoveInto(&theClipboardSlob);
            }
            
            pSlob->MoveInto(NULL); // Move the slob into oblivion
            pSlob = NULL;
        }
        else
        {
            // If one chooses not to die, reselect it...
            if (bVeto)
            {
                Add(pSlob);
            }
            else
            {
                Single(pSlob);
                bVeto = TRUE;
            }
        }
    }
    
    // Let the caller know what slob they might want to select after
    // the delete takes place...
    if (ppNextSlob != NULL)
    {
        if (conList->IsEmpty())
            *ppNextSlob = pContainer;
        else if (nextPos == NULL)
            *ppNextSlob = (CSlob*)conList->GetHead();
        else
            *ppNextSlob = (CSlob*)conList->GetAt(nextPos);
    }

    theUndoSlob.EndUndo();
    
    return !bVeto;
}


// If any slob cannot added to, none can!
// Caution: use this with care (you may want to ignore CanAdd() for multislobs)
BOOL CMultiSlob::CanAdd(CSlob *pAddSlob)
{
    POSITION pos = GetHeadPosition();
	if (!pos)
		return FALSE;	// must be something to consider adding

    while (pos != NULL)
    {
        CSlob* pSlob = GetNext(pos);
        if (!pSlob->CanAdd(pAddSlob))
            return FALSE;
    }
    
    return TRUE;
}

BOOL CMultiSlob::CanAct(ACTION_TYPE action)
{
	if (action != act_delete && action != act_cut &&
		action != act_copy && action != act_paste)
		return CSlob::CanAct(action);

    POSITION pos = GetHeadPosition();
	if (!pos)
		return FALSE;

	BOOL bActIfAny = (action == act_paste);

    while (pos != NULL)
    {
        CSlob* pSlob = GetNext(pos);
        if ((bActIfAny && pSlob->CanAct(action)) ||
			(!bActIfAny && !pSlob->CanAct(action)))
            return bActIfAny;
    }
    
    return !bActIfAny;
}

// Give slobs one last chance to refuse the action.
BOOL CMultiSlob::PreAct(ACTION_TYPE action)
{
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = GetNext(pos);
        if (!pSlob->PreAct(action))
            return FALSE;
    }
    
    return TRUE;
}

void CMultiSlob::EnsureValidSelection()
{
    // Default is a no-op...
	if (m_pSlobWnd != NULL)
	{
		m_pSlobWnd->EnsureValidSelection();
	}
}

void CMultiSlob::UndoAction(CSlobSequence* pSeq, UINT idAction)
{
    switch (idAction)
    {
    default:
        CSlob::UndoAction(pSeq, idAction);
        break;

    case A_PostSel:
        {
            CObList items;
            
            int cb;
            pSeq->RetrieveInt(cb);
            
            int nPtrs = cb / sizeof (CSlob*);
            while (nPtrs-- > 0)
            {
                CSlob* pSlob;
                pSeq->RetrievePtr(pSlob);
                items.AddHead(pSlob);
            }
            
            theUndoSlob.InsertSel(A_PreSel, this, &items);
        }
        break;
        
    case A_PreSel:
        {
            theUndoSlob.Pause();
            
            Clear();

            int cb;
            pSeq->RetrieveInt(cb);
            
            int nPtrs = cb / sizeof (CSlob*);
            while (nPtrs-- > 0)
            {
                CSlob* pSlob;
                pSeq->RetrievePtr(pSlob);
                Add(pSlob);
            }

            EnsureValidSelection();

            theUndoSlob.Resume();
            
            theUndoSlob.OnPostSel(this);
        }
        break;
    }
}


void CMultiSlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
    if (idChange == SN_DESTROY)
    {
		// Remove slobs that are destroyed from this list
		
        POSITION pos = m_objects.Find(pChangedSlob);
        if (pos != NULL)
            m_objects.RemoveAt(pos);
    }
    else
    {
		// All other changes are propegated to dependants of this
		
        InformDependants(idChange, dwHint);
    }

    CSlob::OnInform(pChangedSlob, idChange, dwHint);
}


/////////////////////////////////////////////////////////////////////////////
// Propery Modification Functions

BOOL CMultiSlob::SetDoubleProp(UINT idProp, double val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		double inv;
		GPT gpt = pSlob->GetDoubleProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetDoubleProp(idProp, val))
            bValid = FALSE;		// abort if we are having trouble setting this property
    }

    return bValid;
}


BOOL CMultiSlob::SetIntProp(UINT idProp, int val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		int inv;
		GPT gpt = pSlob->GetIntProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetIntProp(idProp, val))
            bValid = FALSE;
    }

    return bValid;
}


BOOL CMultiSlob::SetLongProp(UINT idProp, long val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		long inv;
		GPT gpt = pSlob->GetLongProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetLongProp(idProp, val))
            bValid = FALSE;
    }

    return bValid;
}


BOOL CMultiSlob::SetStrProp(UINT idProp, const CString& val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		CString inv;
		GPT gpt = pSlob->GetStrProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetStrProp(idProp, val))
            bValid = FALSE;
    }

    return bValid;
}


BOOL CMultiSlob::SetSlobProp(UINT idProp, CSlob* val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		CSlob* inv;
		GPT gpt = pSlob->GetSlobProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetSlobProp(idProp, val))
            bValid = FALSE;
    }

    return bValid;
}


BOOL CMultiSlob::SetRectProp(UINT idProp, const CRect& val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		CRect inv;
		GPT gpt = pSlob->GetRectProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetRectProp(idProp, val))
            bValid = FALSE;
    }

    return bValid;
}


BOOL CMultiSlob::SetPointProp(UINT idProp, const CPoint& val)
{
    BOOL bValid = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while( bValid && (pos != NULL) )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		CPoint inv;
		GPT gpt = pSlob->GetPointProp(idProp, inv);
		if( (gpt == avoid) || (gpt == invisible) )
			continue;

        if (!pSlob->SetPointProp(idProp, val))
            bValid = FALSE;
    }

    return bValid;
}


/////////////////////////////////////////////////////////////////////////////
// Property Retrieval Functions

// It is quite likely in a multiple selection that the GPT return codes
// will not match up.  We should take the worst case, and return that.
// The worst case is 'avoid' -- some control insists on outright hiding
// the property.  Next is 'invalid', which renders the property invalid
// for all.  Next is 'ambiguous', which usually means different slobs
// returned valid, but with different values.  Best is 'valid', which we only
// return if all contained slobs have the same valid value.  Finally,
// there is 'invisible', which hides the property like 'avoid' does, but
// if some other item in the selection wants it shown, then that's fine.

GPT CMultiSlob::GetDoubleProp(UINT idProp, double& valReturn)
{
    GPT gptRet = invisible;
	double val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetDoubleProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}


GPT CMultiSlob::GetIntProp(UINT idProp, int& valReturn)
{
    GPT gptRet = invisible;
    int val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetIntProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}


GPT CMultiSlob::GetLongProp(UINT idProp, long& valReturn)
{
    GPT gptRet = invisible;
    long val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetLongProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}


GPT CMultiSlob::GetStrProp(UINT idProp, CString& valReturn)
{
    GPT gptRet = invisible;
    CString val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetStrProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}


GPT CMultiSlob::GetSlobProp(UINT idProp, CSlob*& valReturn)
{
    GPT gptRet = invisible;
    CSlob* val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetSlobProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}


GPT CMultiSlob::GetRectProp(UINT idProp, CRect& valReturn)
{
    GPT gptRet = invisible;
    CRect val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetRectProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}


GPT CMultiSlob::GetPointProp(UINT idProp, CPoint& valReturn)
{
    GPT gptRet = invisible;
    CPoint val;
    BOOL bFirstTime = TRUE;
    POSITION pos = m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);
        GPT gpt = pSlob->GetPointProp(idProp, valReturn);
        gptRet = min(gpt, gptRet);

        if( gpt == invisible )
			continue;
        if (bFirstTime)
        {
            val = valReturn;
            bFirstTime = FALSE;
        }
        else if (val != valReturn)
        {
            gptRet = min(gptRet, ambiguous);
        }
    }

    return gptRet;
}

BOOL CMultiSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	CSheetWnd* pPropSheet = GetPropertyBrowser();
	InhibitExtraPropertyPages();
	StartNewPropertyPageSet();

    BOOL bFirstSlob = TRUE;
	BOOL bRet = TRUE;
	POSITION pos = m_objects.GetHeadPosition();
    while( pos != NULL )
    {
        CSlob* pSlob = (CSlob*)m_objects.GetNext(pos);

		// prepare to merge this slob's pages with the previous ones
		if( !bFirstSlob )
			StartNewPropertyPageSet();

		// add the pages for this sheet
		// REVIEW(davidga): what if SetupPropertyPages returns FALSE?
		pSlob->SetupPropertyPages(pNewSel, FALSE);

		// merge the pages
		if( !bFirstSlob )
			MergePropertyPageSets();
		else
			bFirstSlob = FALSE;

		// I can't do the following, because I don't have access to protected
		// members of CSheetWnd.
		// So instead, this is done in CSheetWnd::AddPropertyPage.
//		POSITION posPage = pPropSheet->m_listNewPages.GetHeadPosition();
//		while( posPage != NULL )
//		{
//			C3dPropertyPage* pPage = (C3dPropertyPage*)pPropSheet->
//				m_listNewPages.GetNext(posPage);
//			if( pPage->m_pSlob == pSlob )
//				pPage->m_pSlob = this;
//		}
    }

	if( bSetCaption && (m_objects.GetCount() > 0) )
	{
		// REVIEW(davidga): Is there anything better I should do for a caption?
		CString strCaption(MAKEINTRESOURCE(IDS_MULTISEL));
		SetPropertyCaption(strCaption);
	}

	InhibitExtraPropertyPages(FALSE);	// release the inhibition

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\oldbar.cpp ===
// toolbar.cpp : definition of old backward compatible CToolBar
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#define _AFX_NO_OLE_SUPPORT
#include <afxpriv.h>
#include "barglob.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


// globals for fast drawing (shared globals)
#ifndef _MAC
HDC CToolBar::s_hDCGlyphs = NULL;
HDC CToolBar::s_hDCMono = NULL;
#define hDCGlyphs s_hDCGlyphs
#define hDCMono s_hDCMono
#else
#define hDCGlyphs   m_hDCGlyphs
#define hDCMono     m_hDCMono
#endif
static HBRUSH hbrDither = NULL;

/////////////////////////////////////////////////////////////////////////////
// Init / Term

#ifndef _MAC
static HBITMAP AFXAPI CreateDitherBitmap();
#else
static HBITMAP AFXAPI CreateDitherBitmap(BOOL bMonochrome);
#endif

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif



// a special struct that will cleanup automatically
struct _AFX_TOOLBAR_TERM
{
	~_AFX_TOOLBAR_TERM()
	{
#ifndef _MAC
		AfxDeleteObject((HGDIOBJ*)&CToolBar::s_hDCMono);
		AfxDeleteObject((HGDIOBJ*)&CToolBar::s_hDCGlyphs);
#endif
		AfxDeleteObject((HGDIOBJ*)&hbrDither);
	}
};

static const _AFX_TOOLBAR_TERM toolbarTerm;

/////////////////////////////////////////////////////////////////////////////

#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

#ifndef _MAC
static HBITMAP AFXAPI CreateDitherBitmap()
#else
static HBITMAP AFXAPI CreateDitherBitmap(BOOL bMonochrome)
#endif
{
	struct  // BITMAPINFO with 16 colors
	{
		BITMAPINFOHEADER bmiHeader;
		RGBQUAD      bmiColors[16];
	} bmi;
	memset(&bmi, 0, sizeof(bmi));

	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biWidth = 8;
	bmi.bmiHeader.biHeight = 8;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biBitCount = 1;
	bmi.bmiHeader.biCompression = BI_RGB;

	COLORREF clr = ::GetSysColor(COLOR_BTNFACE);
#ifdef _MAC
	// if monochrome or the face color is already white, use black instead to make
	// sure that we draw a dither - otherwise we'll have a white on white bitmap
	if (bMonochrome || clr == RGB(255, 255, 255))
		clr = 0;
#endif
	bmi.bmiColors[0].rgbBlue = GetBValue(clr);
	bmi.bmiColors[0].rgbGreen = GetGValue(clr);
	bmi.bmiColors[0].rgbRed = GetRValue(clr);

	clr = ::GetSysColor(COLOR_BTNHIGHLIGHT);
	bmi.bmiColors[1].rgbBlue = GetBValue(clr);
	bmi.bmiColors[1].rgbGreen = GetGValue(clr);
	bmi.bmiColors[1].rgbRed = GetRValue(clr);

	// initialize the brushes
	long patGray[8];
	for (int i = 0; i < 8; i++)
	   patGray[i] = (i & 1) ? 0xAAAA5555L : 0x5555AAAAL;

	HDC hDC = GetDC(NULL);
	HBITMAP hbm = CreateDIBitmap(hDC, &bmi.bmiHeader, CBM_INIT,
		(LPBYTE)patGray, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS);
	ReleaseDC(NULL, hDC);

	return hbm;
}

void CreateCmdBarButtonMask(int iImage,
							CPoint ptOffset,
							BOOL bHilite,
							BOOL bShadow,
							const SIZE& sizeButton,
							const SIZE& sizeImage,
							HDC hdcGlyphs,
							HDC hdcMono)
{
	// initalize whole area with 0's
	PatBlt(hdcMono, 0, 0, sizeButton.cx-2, sizeButton.cy-2, WHITENESS);

	// create mask based on color bitmap
	// convert this to 1's
	SetBkColor(hdcGlyphs, globalData.clrBtnFace);
	BitBlt(hdcMono, ptOffset.x, ptOffset.y, sizeImage.cx, sizeImage.cy,
		hdcGlyphs, iImage * sizeImage.cx, 0, SRCCOPY);

	if (bHilite)
	{
		// convert this to 1's
		SetBkColor(hdcGlyphs, globalData.clrBtnHilite);

		// OR in the new 1's
		BitBlt(hdcMono, ptOffset.x, ptOffset.y, sizeImage.cx, sizeImage.cy,
			hdcGlyphs, iImage * sizeImage.cx, 0, SRCPAINT);

		if (bShadow)
			BitBlt(hdcMono, 1, 1, sizeButton.cx-3, sizeButton.cy-3,
				hdcMono, 0, 0, SRCAND);
	}
}

// create a mono bitmap mask:
void CToolBar::CreateMask(int iImage, CPoint ptOffset,
	 BOOL bHilite, BOOL bHiliteShadow)
{
	// Thunk into our helper function.
	CreateCmdBarButtonMask(iImage, ptOffset, bHilite, bHiliteShadow,
		m_sizeButton, m_sizeImage, hDCGlyphs, hDCMono);
}

// Raster Ops
#define ROP_DSPDxax  0x00E20746L
#define ROP_PSDPxax  0x00B8074AL

BOOL DrawButtonGlyph(CDC* pDC,
					 int x, int y,
					 CPoint ptOffset,
					 int iImage,
					 UINT nStyle,
					 const SIZE& sizeButton,
					 const SIZE& sizeImage,
					 HDC hdcGlyphs,
					 HDC hdcMono)
{
	// This function paints the button glyph.  It assumes
	// the border and background have already been handeled.

	if ((nStyle & TBBS_PRESSED) || !(nStyle & TBBS_DISABLED))
	{
		// normal image version
		BitBlt(pDC->m_hDC, x + ptOffset.x, y + ptOffset.y,
			sizeImage.cx, sizeImage.cy,
			hdcGlyphs, iImage * sizeImage.cx, 0, SRCCOPY);
		
		if (nStyle & TBBS_PRESSED)
			return TRUE;        // nothing more to do (rest of style is ignored)
	}
	
	if (nStyle & (TBBS_DISABLED | TBBS_INDETERMINATE))
	{
		// disabled or indeterminate version
		CreateCmdBarButtonMask(iImage, ptOffset, TRUE, FALSE,
			sizeButton, sizeImage, hdcGlyphs, hdcMono);
		
		pDC->SetTextColor(0L);                  // 0's in mono -> 0 (for ROP)
		pDC->SetBkColor((COLORREF)0x00FFFFFFL); // 1's in mono -> 1
		
		if (nStyle & TBBS_DISABLED)
		{
			// disabled - draw the hilighted shadow
			HGDIOBJ hbrOld = pDC->SelectObject(globalData.hbrBtnHilite);
			if (hbrOld != NULL)
			{
				// draw hilight color where we have 0's in the mask
				BitBlt(pDC->m_hDC, x + 1, y + 1,
					sizeButton.cx - 2, sizeButton.cy - 2,
					hdcMono, 0, 0, ROP_PSDPxax);
				pDC->SelectObject(hbrOld);
			}
		}
		
		//BLOCK: always draw the shadow
		{
			HGDIOBJ hbrOld = pDC->SelectObject(globalData.hbrBtnShadow);
			if (hbrOld != NULL)
			{
				// draw the shadow color where we have 0's in the mask
				BitBlt(pDC->m_hDC, x, y,
					sizeButton.cx - 2, sizeButton.cy - 2,
					hdcMono, 0, 0, ROP_PSDPxax);
				pDC->SelectObject(hbrOld);
			}
		}
	}
	
	// if it is checked do the dither brush avoiding the glyph; extruded checked items paint with a grey bkgnd
	if ((nStyle & (TBBS_CHECKED | TBBS_INDETERMINATE))!=0 &&
		(nStyle & (TBBS_EXTRUDED))==0)
	{
		HGDIOBJ hbrOld = pDC->SelectObject(hbrDither);
		if (hbrOld != NULL)
		{
			ptOffset.x -= globalData.cxBorder2;
			ptOffset.y -= globalData.cyBorder2;
			CreateCmdBarButtonMask(iImage, ptOffset, ~(nStyle & TBBS_INDETERMINATE),
				nStyle & TBBS_DISABLED,
				sizeButton, sizeImage, hdcGlyphs, hdcMono);
			
			pDC->SetTextColor(0L);              // 0 -> 0
			pDC->SetBkColor((COLORREF)0x00FFFFFFL); // 1 -> 1
			
			ASSERT(globalData.cxBorder2 == globalData.cyBorder2);
			int delta = (nStyle & TBBS_INDETERMINATE) ?
				globalData.bWin4 ? globalData.cxBorder2*2 : 3 : globalData.cxBorder2*2;
			
			// only draw the dither brush where the mask is 1's
			BitBlt(pDC->m_hDC,
				x + globalData.cxBorder2, y + globalData.cyBorder2, sizeButton.cx-delta, sizeButton.cy-delta,
				hdcMono, 0, 0, ROP_DSPDxax);
			pDC->SelectObject(hbrOld);
		}
	}
	
	return TRUE;
}

// if bOutlineOnly is TRUE (header default is FALSE), then the button outline will be drawn without
// the content bitmap. This can be used for special kinds of buttons which wish to exploit the inbuilt
// framing code. They should also pass the pointer to a CRect, which will be filled with the correct bounds
// for the custom drawing to be placed martynl 21Mar96
BOOL CToolBar::DrawButton(CDC* pDC, int x, int y, int iImage, UINT nStyle, BOOL bOutlineOnly, CRect *pDrawBounds)
{
	ASSERT_VALID(pDC);

	int dx = m_sizeButton.cx;
	int dy = m_sizeButton.cy;

	// interior grey
	pDC->FillSolidRect(x, y, dx, dy, globalData.clrBtnFace);

	// determine offset of bitmap (centered within button)
	CPoint ptOffset;
	ptOffset.x = (dx - m_sizeImage.cx - 1) / 2;
	ptOffset.y = (dy - m_sizeImage.cy) / 2;

	if (nStyle & (TBBS_PRESSED | TBBS_CHECKED))
	{
		// pressed in or checked
		pDC->Draw3dRect(x, y, dx, dy,
			globalData.clrBtnShadow, globalData.clrBtnHilite);

		// for any depressed button, add one to the offsets.
		ptOffset.x += 1;
		ptOffset.y += 1;
	}
	else if (nStyle & TBBS_EXTRUDED)
	{
		// regular button look
		pDC->Draw3dRect(x, y, dx, dy,
			globalData.clrBtnHilite, globalData.clrBtnShadow);
	}

	if (!bOutlineOnly)
	{
		return DrawButtonGlyph(pDC, x, y, ptOffset, iImage,
			nStyle, m_sizeButton, m_sizeImage, hDCGlyphs, hDCMono);
	}
	else if (pDrawBounds != NULL)
	{
		*pDrawBounds=CRect(     x + ptOffset.x,                                  y + ptOffset.y, 
							x + ptOffset.x + m_sizeImage.cx, y + ptOffset.y + m_sizeImage.cy);
	}

	return TRUE;
}

#ifdef _MAC
BOOL CToolBar::DrawMonoButton(CDC* pDC, int x, int y, int dx, int dy,
	int iImage, UINT nStyle)
{
	// interior is black if pressed, white if not
	if (nStyle & (TBBS_PRESSED | TBBS_CHECKED))
	{
		pDC->FillSolidRect(x, y, dx, dy, RGB(0, 0, 0));
		pDC->SetBkColor(RGB(255, 255, 255));    // bkcolor was set by PatB
	}
	else
	{
		pDC->FillSolidRect(x, y, dx, dy, RGB(0xFF, 0xFF, 0xFF));
	}

	CPoint ptOffset;
	ptOffset.x = (dx - m_sizeImage.cx - 1) / 2;
	ptOffset.y = (dy - m_sizeImage.cy) / 2;

	if ((nStyle & TBBS_PRESSED) || !(nStyle & TBBS_DISABLED))
	{
		// normal image version
		BitBlt(pDC->m_hDC, x + ptOffset.x, y + ptOffset.y, m_sizeImage.cx,
			m_sizeImage.cy, hDCGlyphs, iImage * m_sizeImage.cx, 0,
			(nStyle & (TBBS_PRESSED | TBBS_CHECKED)) ? NOTSRCCOPY : SRCCOPY);

		if (nStyle & (TBBS_PRESSED | TBBS_CHECKED))
			return TRUE;        // nothing more to do (rest of style is ignored)
	}

	if (nStyle & TBBS_DISABLED)
	{
		BitBlt(pDC->m_hDC, x + ptOffset.x, y + ptOffset.y, m_sizeImage.cx,
			m_sizeImage.cy, hDCGlyphs, iImage * m_sizeImage.cx, 0, SRCCOPY);

		int ropOld = pDC->SetROP2(R2_MASKNOTPEN);
		RECT rect;
		SetRect(&rect, 0, 0, m_sizeImage.cx, m_sizeImage.cy);
		OffsetRect(&rect, x + ptOffset.x, y + ptOffset.y);
		AfxFillRect(pDC->m_hDC, &rect, hbrDither);
		pDC->SetROP2(ropOld);

		return TRUE;
	}

	// if it is checked do the dither brush avoiding the glyph
	if (nStyle & (TBBS_CHECKED | TBBS_INDETERMINATE))
	{
		HGDIOBJ hbrOld = pDC->SelectObject(hbrDither);
		if (hbrOld != NULL)
		{
			CreateMask(iImage, ptOffset, ~(nStyle & TBBS_INDETERMINATE),
					nStyle & TBBS_DISABLED);

			pDC->SetTextColor(0L);              // 0 -> 0
			pDC->SetBkColor((COLORREF)0x00FFFFFFL); // 1 -> 1

			int delta = (nStyle & TBBS_INDETERMINATE) ? 3 : 1;

			// only draw the dither brush where the mask is 1's
			CRect rect(0, 0, dx, dy);
			::InvertRect(hDCMono, &rect);

			BitBlt(pDC->m_hDC, x, y, dx, dy, hDCMono, 0, 0, ROP_PSDPxax);
			pDC->SelectObject(hbrOld);
		}
	}

	return TRUE;
}
#endif

BOOL CToolBar::PrepareDrawButton(DrawState& ds)
{
	ASSERT(m_hbmImageWell != NULL);
	ASSERT(m_sizeButton.cx > 2 && m_sizeButton.cy > 2);

	// We need to kick-start the bitmap selection process.
	ds.hbmOldGlyphs = (HBITMAP)SelectObject(hDCGlyphs, m_hbmImageWell);
	ds.hbmMono = CreateBitmap(m_sizeButton.cx-2, m_sizeButton.cy-2,
					1, 1, NULL);
	ds.hbmMonoOld = (HBITMAP)SelectObject(hDCMono, ds.hbmMono);
	if (ds.hbmOldGlyphs == NULL || ds.hbmMono == NULL || ds.hbmMonoOld == NULL)
	{
		TRACE0("Error: can't draw toolbar.\n");
		AfxDeleteObject((HGDIOBJ*)&ds.hbmMono);
		return FALSE;
	}
	return TRUE;
}

void CToolBar::EndDrawButton(DrawState& ds)
{
	SelectObject(hDCMono, ds.hbmMonoOld);
	AfxDeleteObject((HGDIOBJ*)&ds.hbmMono);
	SelectObject(hDCGlyphs, ds.hbmOldGlyphs);
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar creation etc

#ifdef _DEBUG
AFX_TBBUTTON* CToolBar::_GetButtonPtr(int nIndex) const
{
	ASSERT(nIndex >= 0 && nIndex < m_nCount);
	ASSERT(m_pData != NULL);
	return ((AFX_TBBUTTON*)m_pData) + nIndex;
}
#endif

#if 0
// Just use AfxLoadSysColorBitmap
/*
	DIBs use RGBQUAD format:
		0xbb 0xgg 0xrr 0x00

	Reasonably efficient code to convert a COLORREF into an
	RGBQUAD is byte-order-dependent, so we need different
	code depending on the byte order we're targeting.
*/
#ifndef _MAC
#define RGB_TO_RGBQUAD(r,g,b)   (RGB(b,g,r))
#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))
#else
#define RGB_TO_RGBQUAD(r,g,b)   (RGB(r,g,b) << 8)
#define CLR_TO_RGBQUAD(clr)     (clr << 8)
#endif

#ifndef _MAC
HBITMAP AFXAPI LoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc)
#else
HBITMAP AFXAPI LoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc,
	HDC hDCGlyphs, BOOL bMonochrome)
#endif
{
	struct COLORMAP
	{
		// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
		DWORD rgbqFrom;
		int iSysColorTo;
	};
	static const COLORMAP sysColorMap[] =
	{
		// mapping from color in DIB to system color
		{ RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
		{ RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark grey
		{ RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright grey
		{ RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
	};
	const int nMaps = 4;

	HGLOBAL hglb;
	if ((hglb = ::LoadResource(hInst, hRsrc)) == NULL)
		return NULL;

	LPBITMAPINFOHEADER lpBitmap = (LPBITMAPINFOHEADER)LockResource(hglb);
	if (lpBitmap == NULL)
		return NULL;

	// make copy of BITMAPINFOHEADER so we can modify the color table
	const int nColorTableSize = 16;
	UINT nSize = lpBitmap->biSize + nColorTableSize * sizeof(RGBQUAD);
	LPBITMAPINFOHEADER lpBitmapInfo = (LPBITMAPINFOHEADER)::malloc(nSize);
	if (lpBitmapInfo == NULL)
		return NULL;
	memcpy(lpBitmapInfo, lpBitmap, nSize);

	// color table is in RGBQUAD DIB format
	DWORD* pColorTable =
		(DWORD*)(((LPBYTE)lpBitmapInfo) + (UINT)lpBitmapInfo->biSize);

	for (int iColor = 0; iColor < nColorTableSize; iColor++)
	{
		// look for matching RGBQUAD color in original
		for (int i = 0; i < nMaps; i++)
		{
			if (pColorTable[iColor] == sysColorMap[i].rgbqFrom)
			{
#ifdef _MAC
				if (bMonochrome)
				{
					// all colors except text become white
					if (sysColorMap[i].iSysColorTo != COLOR_BTNTEXT)
						pColorTable[iColor] = RGB_TO_RGBQUAD(255, 255, 255);
				}
				else
#endif
				pColorTable[iColor] =
					CLR_TO_RGBQUAD(::GetSysColor(sysColorMap[i].iSysColorTo));
				break;
			}
		}
	}

	int nWidth = (int)lpBitmapInfo->biWidth;
	int nHeight = (int)lpBitmapInfo->biHeight;
	HDC hDCScreen = ::GetDC(NULL);
	HBITMAP hbm = ::CreateCompatibleBitmap(hDCScreen, nWidth, nHeight);
	::ReleaseDC(NULL, hDCScreen);

	if (hbm != NULL)
	{
		HBITMAP hbmOld = (HBITMAP)::SelectObject(hDCGlyphs, hbm);

		LPBYTE lpBits;
		lpBits = (LPBYTE)(lpBitmap + 1);
		lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

		StretchDIBits(hDCGlyphs, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight,
			lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);
		SelectObject(hDCGlyphs, hbmOld);

#ifdef _MAC
		// We don't change this bitmap any more, so get rid of the big,
		// wasteful Macintosh port
		::SetBitmapReadOnly(hbm, BRO_READONLY);
#endif
	}

	// free copy of bitmap info struct and resource itself
	::free(lpBitmapInfo);
	::FreeResource(hglb);

	return hbm;
}
#endif

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

CToolBar::CToolBar()
{
	m_hbmImageWell = NULL;
	m_hInstImageWell = NULL;
	m_hRsrcImageWell = NULL;
	m_iButtonCapture = -1;      // nothing captured

	SetDefaultSizes();

#ifdef _MAC
	m_hDCGlyphs = CreateCompatibleDC(NULL);
	m_hDCMono = ::CreateCompatibleDC(NULL);
	if (m_hDCGlyphs == NULL || m_hDCMono == NULL)
		AfxThrowResourceException();
#endif

	// initialize the toolbar drawing engine
	static BOOL bInitialized;
	if (!bInitialized)
	{
#ifndef _MAC
		hDCGlyphs = CreateCompatibleDC(NULL);

		// Mono DC and Bitmap for disabled image
		hDCMono = ::CreateCompatibleDC(NULL);
#endif

#ifndef _MAC
		HBITMAP hbmGray = ::CreateDitherBitmap();
#else
		HBITMAP hbmGray = ::CreateDitherBitmap(m_bMonochrome);
#endif
		if (hbmGray != NULL)
		{
			ASSERT(hbrDither == NULL);
			hbrDither = ::CreatePatternBrush(hbmGray);
			AfxDeleteObject((HGDIOBJ*)&hbmGray);
		}

#ifndef _MAC
		if (hDCGlyphs == NULL || hDCMono == NULL || hbrDither == NULL)
			AfxThrowResourceException();
#else
		if (hbrDither == NULL)
			AfxThrowResourceException();
#endif
		bInitialized = TRUE;
	}
}

CToolBar::~CToolBar()
{
#ifdef _MAC
	ASSERT(m_hDCGlyphs != NULL);
	VERIFY(::DeleteDC(m_hDCGlyphs));

	ASSERT(m_hDCMono != NULL);
	VERIFY(::DeleteDC(m_hDCMono));
#endif

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);

	// MFC bug fix.  Make sure pLastHit is not this.
	if (m_hWnd != NULL)
		SetStatusText(-1);
	m_dwStyle = 0;
}

BOOL CToolBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	if (pParentWnd != NULL)
		ASSERT_VALID(pParentWnd);   // must have a parent

	// save the style
	m_dwStyle = dwStyle;
	if (nID == AFX_IDW_TOOLBAR)
		m_dwStyle |= CBRS_HIDE_INPLACE;

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();
	LPCTSTR szWndClass = AfxRegisterWndClass(0, LoadCursor(NULL, IDC_ARROW),
		(HBRUSH)(COLOR_BTNFACE + 1), NULL);
	if (!CWnd::Create(szWndClass, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	// Note: Parent must resize itself for control bar to be resized

	return TRUE;
}

void CToolBar::SetSizes(SIZE sizeButton, SIZE sizeImage)
{
	ASSERT_VALID(this);
	ASSERT(sizeButton.cx > 0 && sizeButton.cy > 0);
	ASSERT(sizeImage.cx > 0 && sizeImage.cy > 0);

	// button must be big enough to hold image + 3 pixels on each side
	ASSERT(sizeButton.cx >= sizeImage.cx + 6);
	ASSERT(sizeButton.cy >= sizeImage.cy + 6);

	m_sizeButton = sizeButton;
	m_sizeImage = sizeImage;

	// set height
	Invalidate();   // just to be nice if called when toolbar is visible
}

void CToolBar::SetDefaultSizes()
{
	// UISG standard sizes
	m_sizeButton = GetDefaultButtonSize();
	m_sizeImage = GetDefaultBitmapSize();
	m_cyTopBorder = m_cyBottomBorder = 3;   

	// adjust sizes
	m_sizeButton.cx = 23;
	m_cySharedBorder = m_cxSharedBorder = 0;
	m_cxDefaultGap = 8;
}

CSize CToolBar::GetDefaultBitmapSize()
{
	return globalData.csSmallButtonGlyph;
}

CSize CToolBar::GetDefaultButtonSize()
{
	return globalData.csSmallButton;
}

void CToolBar::SetHeight(int cyHeight)
{
	ASSERT_VALID(this);

	int nHeight = cyHeight;
	if (m_dwStyle & CBRS_BORDER_TOP)
		cyHeight -= globalData.cyBorder2;
	if (m_dwStyle & CBRS_BORDER_BOTTOM)
		cyHeight -= globalData.cyBorder2;
	m_cyBottomBorder = (cyHeight - m_sizeButton.cy) / 2;
	// if there is an extra pixel, m_cyTopBorder will get it
	m_cyTopBorder = cyHeight - m_sizeButton.cy - m_cyBottomBorder;
	if (m_cyTopBorder < 0)
	{
		TRACE1("Warning: CToolBar::SetHeight(%d) is smaller than button.\n",
			nHeight);
		m_cyBottomBorder += m_cyTopBorder;
		m_cyTopBorder = 0;  // will clip at bottom
	}
	// bottom border will be ignored (truncate as needed)
	Invalidate();   // just to be nice if called when toolbar is visible
}

BOOL CToolBar::LoadBitmap(UINT nIDBitmap)
{
	return LoadBitmap(MAKEINTRESOURCE(nIDBitmap));
}

BOOL CToolBar::LoadBitmap(LPCTSTR lpszResourceName)
{
	ASSERT_VALID(this);
	ASSERT(lpszResourceName != NULL);

	AfxDeleteObject((HGDIOBJ*)&m_hbmImageWell);     // get rid of old one

	m_hInstImageWell = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
	if ((m_hRsrcImageWell = ::FindResource(m_hInstImageWell,
		lpszResourceName, RT_BITMAP)) == NULL)
		return FALSE;

#ifndef _MAC
	m_hbmImageWell = AfxLoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell);
#else
	m_hbmImageWell = AfxLoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell,
		m_hDCGlyphs, m_bMonochrome);
#endif
	return (m_hbmImageWell != NULL);
}

BOOL CToolBar::SetButtons(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ASSERT(lpIDArray == NULL ||
		AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));

	// first allocate array for panes and copy initial data
	if (!AllocElements(nIDCount, sizeof(AFX_TBBUTTON)))
		return FALSE;
	ASSERT(nIDCount == m_nCount);

	if (lpIDArray != NULL)
	{
		int iImage = 0;
		// go through them adding buttons
		AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
		for (int i = 0; i < nIDCount; i++, pTBB++)
		{
			ASSERT(pTBB != NULL);
			if ((pTBB->nID = *lpIDArray++) == 0)
			{
				// separator
				pTBB->nStyle = TBBS_SEPARATOR;
				// width of separator includes 2 pixel overlap
				pTBB->iImage = m_cxDefaultGap + m_cxSharedBorder * 2;
			}
			else
			{
				// a command button with image
				pTBB->nStyle = TBBS_BUTTON;
				pTBB->iImage = iImage++;
			}
		}
	}
	return TRUE;
}

#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolBar attribute access

int CToolBar::CommandToIndex(UINT nIDFind) const
{
	ASSERT_VALID(this);

	AFX_TBBUTTON* pTBB = _GetButtonPtr(0);
	for (int i = 0; i < m_nCount; i++, pTBB++)
		if (pTBB->nID == nIDFind)
			return i;
	return -1;
}

UINT CToolBar::GetItemID(int nIndex) const
{
	ASSERT_VALID(this);

	return _GetButtonPtr(nIndex)->nID;
}

ORIENTATION CToolBar::GetOrient() const
{
	// backwards compatibility. Overriden differently in subclasses
	if(m_dwStyle & CBRS_ORIENT_HORZ)
	{
		return orHorz;
	}
	else
	{
		return orVert;
	}
}

void CToolBar::GetItemRect(int nIndex, LPRECT lpRect, ORIENTATION or) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0 && nIndex < m_nCount);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));

	BOOL bHorz = GetOrient()!=orVert;
	CRect rect;
	rect.SetRectEmpty();        // only need top and left
	CalcInsideRect(rect, bHorz);
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton < nIndex; iButton++, pTBB++)
	{
		ASSERT(pTBB != NULL);
		// skip this button or separator
		if (bHorz)
		{
			rect.left += (pTBB->nStyle & TBBS_SEPARATOR) ?
						pTBB->iImage : m_sizeButton.cx;
			rect.left -= m_cxSharedBorder;    // go back for overlap
		}
		else
		{
			rect.top += (pTBB->nStyle & TBBS_SEPARATOR) ?
						pTBB->iImage : m_sizeButton.cy;
			rect.top -= m_cySharedBorder;    // go back for overlap
		}
	}
	ASSERT(iButton == nIndex);
	ASSERT(pTBB == _GetButtonPtr(nIndex));

	// button or image width
	if (bHorz)
	{
		int cx = (pTBB->nStyle & TBBS_SEPARATOR) ? pTBB->iImage : m_sizeButton.cx;
		lpRect->right = (lpRect->left = rect.left) + cx;
		lpRect->bottom = (lpRect->top = rect.top) + m_sizeButton.cy;
	}
	else
	{
		int cy = (pTBB->nStyle & TBBS_SEPARATOR) ? pTBB->iImage : m_sizeButton.cy;
		lpRect->bottom = (lpRect->top = rect.top) + cy;
		lpRect->right = (lpRect->left = rect.left) + m_sizeButton.cx;
	}
}

UINT CToolBar::GetButtonStyle(int nIndex) const
{
	return _GetButtonPtr(nIndex)->nStyle;
}

void CToolBar::SetButtonStyle(int nIndex, UINT nStyle)
{
	AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex);
	UINT nOldStyle = pTBB->nStyle;
	if (nOldStyle != nStyle)
	{
		// update the style and invalidate
		pTBB->nStyle = nStyle;

		// invalidate the button only if both styles not "pressed"
		if (!(nOldStyle & nStyle & TBBS_PRESSED))
			InvalidateButton(nIndex);
	}
}

CSize CToolBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	ASSERT_VALID(this);

	CSize size = CControlBar::CalcFixedLayout(bStretch, bHorz);

	CRect rect;
	rect.SetRectEmpty();        // only need top and left
	CalcInsideRect(rect, bHorz);
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	int nButtonDist = 0;

	if (!bStretch)
	{
		for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
		{
			ASSERT(pTBB != NULL);
			// skip this button or separator
			nButtonDist += (pTBB->nStyle & TBBS_SEPARATOR) ?
				pTBB->iImage : (bHorz ? m_sizeButton.cx : m_sizeButton.cy);
			// go back one for overlap
			nButtonDist -= bHorz ? m_cxSharedBorder : m_cySharedBorder;
		}
		if (bHorz)
			size.cx = nButtonDist - rect.Width() + m_cxSharedBorder;
		else
			size.cy = nButtonDist - rect.Height() + m_cySharedBorder;
	}

	if (bHorz)
		size.cy = m_sizeButton.cy - rect.Height(); // rect.Height() < 0
	else
		size.cx = m_sizeButton.cx - rect.Width(); // rect.Width() < 0

	return size;
}

void CToolBar::GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const
{
	ASSERT_VALID(this);

	AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex);
	nID = pTBB->nID;
	nStyle = pTBB->nStyle;
	iImage = pTBB->iImage;
}

void CToolBar::SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage)
{
	ASSERT_VALID(this);

	AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex);
	pTBB->nID = nID;
	pTBB->iImage = iImage;
	pTBB->nStyle = nStyle;
	InvalidateButton(nIndex);
}

void CToolBar::DoPaint(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

#ifdef _MAC
#ifdef _DEBUG
	// turn off validation to speed up button drawing
	int wdSav = WlmDebug(WD_NOVALIDATE | WD_ASSERT);
#endif
#endif

	CControlBar::DoPaint(pDC);              // draw border

	// if no toolbar loaded, don't draw any buttons
	if (m_hbmImageWell == NULL)
		return;

	BOOL bHorz = m_dwStyle & CBRS_ORIENT_HORZ ? TRUE : FALSE;
	CRect rect;
	GetClientRect(rect);
	CalcInsideRect(rect, bHorz);

	// force the full size of the button
	if (bHorz)
		rect.bottom = rect.top + m_sizeButton.cy;
	else
		rect.right = rect.left + m_sizeButton.cx;

	DrawState ds;
	if (!PrepareDrawButton(ds))
		return;     // something went wrong

	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		ASSERT(pTBB != NULL);
		if (pTBB->nStyle & TBBS_SEPARATOR)
		{
			// separator
			if (bHorz)
				rect.right = rect.left + pTBB->iImage;
			else
				rect.bottom = rect.top + pTBB->iImage;
		}
		else
		{
			if (bHorz)
				rect.right = rect.left + m_sizeButton.cx;
			else
				rect.bottom = rect.top + m_sizeButton.cy;
		}
		if (!globalData.bWin32s || pDC->RectVisible(&rect))
		{
			DrawButton(pDC, rect.left, rect.top,
				pTBB->iImage, pTBB->nStyle);
		}

		// adjust for overlap
		if (bHorz)
			rect.left = rect.right - m_cxSharedBorder;
		else
			rect.top = rect.bottom - m_cySharedBorder;
	}
	EndDrawButton(ds);

#ifdef _MAC
#ifdef _DEBUG
	WlmDebug(wdSav);
#endif
#endif
}

void CToolBar::InvalidateButton(int nIndex)
{
	ASSERT_VALID(this);

	CRect rect;
	GetItemRect(nIndex, &rect, GetOrient());
	InvalidateRect(rect, FALSE);    // don't erase background
}

int CToolBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	// check child windows first by calling CControlBar
	int nHit = CControlBar::OnToolHitTest(point, pTI);
	if (nHit != -1)
		return nHit;

	// now hit test against CToolBar buttons
	nHit = HitTest(point);
	if (nHit != -1)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(nHit);
		if (pTI != NULL)
		{
			GetItemRect(nHit, &pTI->rect, GetOrient());
			pTI->uId = pTBB->nID;
			pTI->hwnd = m_hWnd;
			pTI->lpszText = LPSTR_TEXTCALLBACK;
		}
		nHit = pTBB->nID;
	}
	return nHit;
}

int CToolBar::HitTest(CPoint point, BOOL bCheckWindow) const // in window relative coords
{
	if (m_pData == NULL)
		return -1;      // no buttons

	BOOL bHorz = (m_dwStyle & CBRS_ORIENT_HORZ) ? TRUE : FALSE;
	CRect rect;
	rect.SetRectEmpty();        // only need top and left
	CalcInsideRect(rect, bHorz);
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	ASSERT(pTBB != NULL);
	if (bHorz)
	{
		if (point.y < rect.top || point.y >= rect.top + m_sizeButton.cy)
			return -1;      // no Y hit
		for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
		{
			if (point.x < rect.left)
				break;      // missed it
			rect.left += (pTBB->nStyle & TBBS_SEPARATOR) ?
							pTBB->iImage : m_sizeButton.cx;
			if (point.x < rect.left && !(pTBB->nStyle & TBBS_SEPARATOR))
				return iButton;     // hit !
			rect.left -= m_cxSharedBorder;    // go back for overlap
		}
	}
	else
	{
		if (point.x < rect.left || point.x >= rect.left + m_sizeButton.cx)
			return -1;      // no X hit
		for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
		{
			if (point.y < rect.top)
				break;      // missed it
			rect.top += (pTBB->nStyle & TBBS_SEPARATOR) ?
							pTBB->iImage : m_sizeButton.cy;
			if (point.y < rect.top && !(pTBB->nStyle & TBBS_SEPARATOR))
				return iButton;     // hit !
			rect.top -= m_cySharedBorder;    // go back for overlap
		}
	}

	return -1;      // nothing hit
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar message handlers

BEGIN_MESSAGE_MAP(CToolBar, CControlBar)
	//{{AFX_MSG_MAP(CToolBar)
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
	ON_WM_SYSCOLORCHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CToolBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	int iButtonCapture = HitTest(point);
	if (iButtonCapture < 0) // nothing hit
	{
		CControlBar::OnLButtonDown(nFlags, point);
		return;
	}

	// only do this for old style bars (martynl, raid 10755)
	if(!this->IsKindOf(RUNTIME_CLASS(CCustomBar)))
	{
		// DevStudio 96 Raid BUG # 5851
		// Clicking one of the tool bar buttons does not activate the 
		// parent window. Therefore, we activate it ourselves.
		if ((m_iButtonCapture < -1) &&  // Capture set by MouseMove.
			(GetCapture() == this) )        // Capture is set.
		{
			// Activate Parent.
			GetParent()->SetActiveWindow() ;
		}
	}
	m_iButtonCapture = iButtonCapture ;

	AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture);
	ASSERT(!(pTBB->nStyle & TBBS_SEPARATOR));

	// update the button before checking for disabled status
	UpdateButton(m_iButtonCapture);
	if (pTBB->nStyle & TBBS_DISABLED)
	{
		m_iButtonCapture = -1;
		return;     // don't press it
	}

	pTBB->nStyle |= TBBS_PRESSED;
	InvalidateButton(m_iButtonCapture);
	UpdateWindow(); // immediate feedback
	SetCapture();
	GetOwner()->SendMessage(WM_SETMESSAGESTRING, (WPARAM)pTBB->nID);
}

void CToolBar::OnMouseMove(UINT /*nFlags*/, CPoint point)
{
	if (m_iButtonCapture >= 0)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture);
		ASSERT(!(pTBB->nStyle & TBBS_SEPARATOR));

		UINT nNewStyle = (pTBB->nStyle & ~TBBS_PRESSED);
		int iButtonCapture = m_iButtonCapture;
		if (GetCapture() != this)
		{
			m_iButtonCapture = -1; // lost capture
			nNewStyle &= ~TBBS_EXTRUDED;

			GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
		}
		else
		{
			// should be pressed if still hitting the captured button
			if (HitTest(point) == m_iButtonCapture)
				nNewStyle |= TBBS_PRESSED;
		}
		SetButtonStyle(iButtonCapture, nNewStyle);
		UpdateWindow(); // immediate feedback
	}
	else // just "float"
	{
		int iOldBtnCap = m_iButtonCapture;

		// are we active?
		int iButton=HitTest(point);
		BOOL bActive= iButton>=0 && ShouldExtrude(iButton);
		if (bActive)
			m_iButtonCapture = - iButton - 2;
		else
			m_iButtonCapture = -1;

		if(m_iButtonCapture<-1)
		{
			AFX_TBBUTTON* pTBB = _GetButtonPtr(-m_iButtonCapture - 2);

			// don't float on pressed button
			if(pTBB->nStyle & TBBS_PRESSED)
			{
				m_iButtonCapture=-1;
			}
		}

		// Update button styles
		BOOL bDirty = FALSE;
		if (iOldBtnCap != m_iButtonCapture)
		{
			if (iOldBtnCap < -1)
			{
				AFX_TBBUTTON* pTBB = _GetButtonPtr(-iOldBtnCap - 2);
				pTBB->nStyle &= ~TBBS_EXTRUDED;
				InvalidateButton(-iOldBtnCap - 2);
				bDirty = TRUE;
			}

			if (m_iButtonCapture < -1)
			{
				AFX_TBBUTTON* pTBB = _GetButtonPtr(-m_iButtonCapture - 2);

				if ((pTBB->nStyle & TBBS_DISABLED) == 0)
				{
					pTBB->nStyle |= TBBS_EXTRUDED;
					InvalidateButton(-m_iButtonCapture - 2);
					bDirty = TRUE;
				}
			}
		}

		if (iOldBtnCap == -1 && m_iButtonCapture < -1)
			SetCapture();
		else if (iOldBtnCap < -1 && m_iButtonCapture == -1 && GetCapture()==this)
			ReleaseCapture();
	}
}

BOOL CToolBar::ShouldExtrude(int iButton)
{
	return  ((GetButtonStyle(iButton) & TBBS_DISABLED)==0) && theApp.ShouldExtrude();
}

void CToolBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_iButtonCapture < 0)
	{
		CControlBar::OnLButtonUp(nFlags, point);
		return;     // not captured
	}

	AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture);
	ASSERT(!(pTBB->nStyle & TBBS_SEPARATOR));
	BOOL bPressed=FALSE;

	UINT nNewStyle = pTBB->nStyle & ~TBBS_EXTRUDED;
	if (GetCapture() == this)
	{
		// we did not lose the capture
		ReleaseCapture();
		if (HitTest(point) == m_iButtonCapture)
		{
			// give button a chance to update
			UpdateButton(m_iButtonCapture);

			// then check for disabled state
			if (!(pTBB->nStyle & TBBS_DISABLED))
			{
				bPressed=TRUE;

				if (pTBB->nStyle & TBBS_CHECKBOX)
				{
					// auto check: three state => down
					if (nNewStyle & TBBS_INDETERMINATE)
						nNewStyle &= ~TBBS_INDETERMINATE;

					nNewStyle ^= TBBS_CHECKED;
				}
			}
		}
	}

	GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);

	int iButtonCapture = m_iButtonCapture;
	m_iButtonCapture = -1;
	if(!bPressed ||
		OnButtonPressed(iButtonCapture)) // only gets called if the button wasn't disabled
	{
		nNewStyle &= ~ TBBS_PRESSED;
	}

	if(!theApp.m_bQuitting)
	{
		SetButtonStyle(iButtonCapture, nNewStyle);
		UpdateButton(iButtonCapture);

		if(bPressed)
		{
			// deferred feedback, to allow dialog to go away
		}
		else
		{
			UpdateWindow(); // immediate feedback
		}
	}
}

BOOL CToolBar::OnButtonPressed(int iButton)
{
	AFX_TBBUTTON* pTBB = _GetButtonPtr(iButton);
	ASSERT(!(pTBB->nStyle & (TBBS_SEPARATOR|TBBS_DISABLED)));

	if (pTBB->nID != 0)
		GetOwner()->SendMessage(WM_COMMAND, pTBB->nID);    // send command

	return TRUE;
}

void CToolBar::OnCancelMode()
{
	CControlBar::OnCancelMode();

	if (m_iButtonCapture >= 0)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(m_iButtonCapture);
		ASSERT(!(pTBB->nStyle & TBBS_SEPARATOR));
		UINT nNewStyle = (pTBB->nStyle & ~TBBS_PRESSED);
		if (GetCapture() == this)
			ReleaseCapture();
		SetButtonStyle(m_iButtonCapture, nNewStyle);
		m_iButtonCapture = -1;
		UpdateWindow();
	}
	else if (m_iButtonCapture < -1)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(-m_iButtonCapture - 2);
		ASSERT(!(pTBB->nStyle & TBBS_SEPARATOR));
		UINT nNewStyle = (pTBB->nStyle & ~TBBS_EXTRUDED);
		if (GetCapture() == this)
			ReleaseCapture();
		SetButtonStyle(-m_iButtonCapture - 2, nNewStyle);
		m_iButtonCapture = -1;
		UpdateWindow();
	}
}

void CToolBar::OnSysColorChange()
{
#ifdef _MAC
	CControlBar::OnSysColorChange();

	ASSERT(hDCGlyphs != NULL);
	VERIFY(::DeleteDC(hDCGlyphs));
	hDCGlyphs = ::CreateCompatibleDC(NULL);

	ASSERT(hDCMono != NULL);
	VERIFY(::DeleteDC(hDCMono));
	hDCMono = ::CreateCompatibleDC(NULL);
#endif

	// re-initialize global dither brush
#ifndef _MAC
	HBITMAP hbmGray = ::CreateDitherBitmap();
#else
	HBITMAP hbmGray = ::CreateDitherBitmap(m_bMonochrome);
#endif
	if (hbmGray != NULL)
	{
		HBRUSH hbrNew = ::CreatePatternBrush(hbmGray);
		if (hbrNew != NULL)
		{
			AfxDeleteObject((HGDIOBJ*)&hbrDither);      // free old one
			hbrDither = hbrNew;
		}
		::DeleteObject(hbmGray);
	}

	// re-color bitmap for toolbar
	if (m_hbmImageWell != NULL)
	{
		HBITMAP hbmNew;
#ifndef _MAC
		hbmNew = AfxLoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell);
#else
		hbmNew = AfxLoadSysColorBitmap(m_hInstImageWell, m_hRsrcImageWell,
			m_hDCGlyphs, m_bMonochrome);
#endif
		if (hbmNew != NULL)
		{
			::DeleteObject(m_hbmImageWell);     // free old one
			m_hbmImageWell = hbmNew;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar idle update through CToolCmdUI class

void CToolCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) & ~TBBS_DISABLED;
	if (!bOn)
		nNewStyle |= TBBS_DISABLED;
	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle);
}

void CToolCmdUI::SetCheck(int nCheck)
{
	ASSERT(nCheck >= 0 && nCheck <= 2); // 0=>off, 1=>on, 2=>indeterminate
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) &
				~(TBBS_CHECKED | TBBS_INDETERMINATE);
	if (nCheck == 1)
		nNewStyle |= TBBS_CHECKED;
	else if (nCheck == 2)
		nNewStyle |= TBBS_INDETERMINATE;
	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle | TBBS_CHECKBOX);
}

void CToolCmdUI::SetText(LPCTSTR lpszNew)
{
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	if(lpszNew)
	{
		pToolBar->UpdateText(m_nIndex,lpszNew);
	}
}

void CToolBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CToolCmdUI state;
	state.m_pOther = this;

	state.m_nIndexMax = (UINT)m_nCount;
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
	  state.m_nIndex++)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(state.m_nIndex);
		state.m_nID = pTBB->nID;

		// ignore separators
		if (!(pTBB->nStyle & TBBS_SEPARATOR))
			state.DoUpdate(pTarget, bDisableIfNoHndler);
	}

	// update the dialog controls added to the toolbar
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

void CToolBar::UpdateButton(int nIndex)
{
	// determine target of command update
	CFrameWnd* pTarget = (CFrameWnd*)GetOwner();

	if (pTarget == NULL || !pTarget->IsFrameWnd())
	{
		// NOTE: bobz - to allow toolbars in CGridControlWnd, add this check. This is pretty
		// special case code to CGridControlWnd toolbars, so generalize or virtualize
		// this function is more general support is needed
		if (pTarget->IsKindOf(RUNTIME_CLASS(CGridControlWnd)))
		{
			return;
		}
		else
			pTarget = GetParentFrame();
	}
	// send the update notification
	if (pTarget != NULL)
	{
		CToolCmdUI state;
		state.m_pOther = this;
		state.m_nIndex = nIndex;
		state.m_nIndexMax = (UINT)m_nCount;
		AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex);
		state.m_nID = pTBB->nID;
		state.DoUpdate(pTarget, pTarget->m_bAutoMenuEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CToolBar diagnostics

#ifdef _DEBUG
void CToolBar::AssertValid() const
{
	CWnd::AssertValid();
	ASSERT(m_nCount == 0 || m_pData != NULL);
	ASSERT(m_hbmImageWell == NULL ||
		(globalData.bWin32s || ::GetObjectType(m_hbmImageWell) == OBJ_BITMAP));

	if (m_hbmImageWell != NULL)
	{
		ASSERT(m_hRsrcImageWell != NULL);
		ASSERT(m_hInstImageWell != NULL);
	}
}

void CToolBar::Dump(CDumpContext& dc) const
{
	CControlBar::Dump(dc);

	dc << "m_hbmImageWell = " << (UINT)m_hbmImageWell;
	dc << "\nm_hInstImageWell = " << (UINT)m_hInstImageWell;
	dc << "\nm_hRsrcImageWell = " << (UINT)m_hRsrcImageWell;
	dc << "\nm_iButtonCapture = " << m_iButtonCapture;
	dc << "\nm_sizeButton = " << m_sizeButton;
	dc << "\nm_sizeImage = " << m_sizeImage;

	if (dc.GetDepth() > 0)
	{
		for (int i = 0; i < m_nCount; i++)
		{
			AFX_TBBUTTON* pTBB = _GetButtonPtr(i);
			dc << "\ntoolbar button[" << i << "] = {";
			dc << "\n\tnID = " << pTBB->nID;
			dc << "\n\tnStyle = " << pTBB->nStyle;
			if (pTBB->nStyle & TBBS_SEPARATOR)
				dc << "\n\tiImage (separator width) = " << pTBB->iImage;
			else
				dc <<"\n\tiImage (bitmap image index) = " << pTBB->iImage;
			dc << "\n}";
		}
	}

	dc << "\n";
}
#endif

#undef new
#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CToolBar, CControlBar)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\oleref.cpp ===
#include "stdafx.h"

/*-----------------------------------------------------------------------------
Name:	FreeOlePtr

Description:
Free a pointer allocated through IMalloc
-----------------------------------------------------------------------------*/
void FreeOlePtr(void * pv)
{
	ASSERT(pv);

	COleRef<IMalloc>	srpMalloc;

	::CoGetMalloc(MEMCTX_TASK, &srpMalloc);
	ASSERT(srpMalloc != NULL);

	srpMalloc->Free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\opendocs.h ===
// opendocs.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// COpenDocsDlg dialog

class COpenDocsDlg : public C3dDialog
{
// Construction
public:
	COpenDocsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(COpenDocsDlg)
	enum { IDD = IDD_OPEN_DOCUMENTS };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COpenDocsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COpenDocsDlg)
	afx_msg void OnOpenDocumentsCloseDoc();
	afx_msg void OnOpenDocumentsActivate();
#ifdef PRINT_DOC_LIST
	afx_msg void OnOpenDocumentsPrint();
#endif
	afx_msg void OnOpenDocumentsSave();
	afx_msg void OnOpenDocumentsTileHorz();
	afx_msg void OnOpenDocumentsTileVert();
	afx_msg void OnSelChangeDocList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void FillListBox(void);
	void UpdateUI(void);
	BOOL IsViewPrintable(CPartView* pView);
	BOOL IsFrameSaveable(CPartFrame* pFrame);
	void SelectActiveChild(void);
	// minimizes all windows that are not selected. Used before tiling. If true is returned, the tile should
	// happen. If false, there were too few selections
	BOOL MinimizeUnselected(void);

private:
	BOOL m_bPrintable;
	BOOL m_bSaveable;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\opendocs.cpp ===
// opendocs.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop
#include "opendocs.h"
#include "util.h"
#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenDocsDlg dialog


COpenDocsDlg::COpenDocsDlg(CWnd* pParent /*=NULL*/)
	: C3dDialog(COpenDocsDlg::IDD, pParent),
	  m_bPrintable(FALSE),
	  m_bSaveable(FALSE)
{
	//{{AFX_DATA_INIT(COpenDocsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void COpenDocsDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COpenDocsDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COpenDocsDlg, C3dDialog)
	//{{AFX_MSG_MAP(COpenDocsDlg)
	ON_BN_CLICKED(IDC_OPEN_DOCUMENTS_CLOSE, OnOpenDocumentsCloseDoc)
	ON_BN_CLICKED(IDC_OPEN_DOCUMENTS_ACTIVATE, OnOpenDocumentsActivate)
#ifdef PRINT_DOC_LIST
	ON_BN_CLICKED(IDC_OPEN_DOCUMENTS_PRINT, OnOpenDocumentsPrint)
#endif
	ON_BN_CLICKED(IDC_OPEN_DOCUMENTS_SAVE, OnOpenDocumentsSave)
	ON_LBN_DBLCLK(IDC_OPEN_DOCUMENTS_LIST, OnOpenDocumentsActivate)
	ON_BN_CLICKED(IDC_OPEN_DOCUMENTS_TILE_HORZ, OnOpenDocumentsTileHorz)
	ON_BN_CLICKED(IDC_OPEN_DOCUMENTS_TILE_VERT, OnOpenDocumentsTileVert)
	ON_LBN_SELCHANGE(IDC_OPEN_DOCUMENTS_LIST, OnSelChangeDocList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COpenDocsDlg virtual function overrides
BOOL COpenDocsDlg::OnInitDialog() 
{
	C3dDialog::OnInitDialog();
	FillListBox();

	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetCount();

	pListBox->SetFocus();

	SelectActiveChild();
	
	OnSelChangeDocList();

	UpdateUI();

	return FALSE;
}

// From Orion 6115, the buttons and labels in this dialogue have been reorganised.

// In 4.x, the buttons were labelled 
//		Activate (IDOK), Cancel (IDCANCEL), Save, Close Window
// Cancel was a misnomer, because it wasn't possible to cancel actions in the dialog
// This has been fixed for 5.0 such that the buttons are now as follows:
//		Activate (ID_...ACTIVATE), OK (IDOK), Save, Close Window.
// This means that the new ok button is the old cancel button, and the new ACTIVATE 
// button is the old ok button. There is no cancel button.

// This also helps the context help to work better. martynl 29Apr96

void COpenDocsDlg::OnOpenDocumentsActivate()
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetSelCount();
	int nSelection;

	// can only activate a window if at least one item is selected
	if (cElements > 0) {
		// activate the first selected item
		pListBox->GetSelItems(1, &nSelection);

		// get the pointer to the frame
		CPartFrame* pFrame;
		pFrame = (CPartFrame*)pListBox->GetItemData(nSelection);
		ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));

		// activate the window
		// olympus 15235
		// now use theApp.SetActiveView() rather than MDIActivate()
		// get a pointer to the active view in the frame
		CPartView* pView = (CPartView*)pFrame->GetActiveView();
		ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
		// olympus 15840
		// we need to unlock the worker AND set the active docker to NULL
		// note that instead of doing these two lines of code,
		// we could also do a theApp.ReactivateView() after the DoModal call
		// that invokes this dialog (if OK was pressed)
		CDockWorker::LockWorker(FALSE);
		CDockWorker::s_pActiveDocker = NULL;
		theApp.SetActiveView(pView->m_hWnd);
	}

	C3dDialog::OnOK();			
}

/////////////////////////////////////////////////////////////////////////////
// COpenDocsDlg message handlers
void COpenDocsDlg::OnOpenDocumentsCloseDoc() 
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetSelCount();
	int iElement;

	if (cElements > 0)
	{
		CWaitCursor hourglass;
		(void)hourglass;

		// get the selected documents
		int *rgiSelections = new int[cElements];
		pListBox->GetSelItems(cElements, rgiSelections);
		
		// store the HWND for each frame
		// because if the .rc file is closed before its editors,
		// the HWNDs for the editors will no longer be valid
		HWND *aHWnds = new HWND[cElements];
		for (iElement = 0; iElement < cElements; iElement++) {
			// get the pointer to the frame
			CPartFrame* pFrame;
			pFrame = (CPartFrame*)pListBox->GetItemData(rgiSelections[iElement]);
			ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));
			aHWnds[iElement] = pFrame->m_hWnd;
		}
		// iterate through the selected documents
		for (iElement = 0; iElement < cElements; iElement++) {
			// make sure the HWND for the frame is still valid before doing anything
			if (::IsWindow(aHWnds[iElement])) {
				// get the pointer to the frame
				CPartFrame* pFrame;
				pFrame = (CPartFrame*)pListBox->GetItemData(rgiSelections[iElement]);
				ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));

				pFrame->SendMessage(WM_CLOSE);
			}
		}

		// get a pointer to the main frame
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

		// refresh the MDI window
		pMainFrame->SendMessage(WM_MDIREFRESHMENU);

		FillListBox();

		int iSel = min(rgiSelections[0], pListBox->GetCount() - 1);
		pListBox->SetCaretIndex(iSel);
		pListBox->SetSel(iSel);

		UpdateUI();

		delete [] aHWnds;
		delete [] rgiSelections;
	}
}

#ifdef PRINT_DOC_LIST
void COpenDocsDlg::OnOpenDocumentsPrint() 
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetSelCount();

	if (cElements > 0)
	{
		// get the selected windows
		int *rgiSelections = new int[cElements];
		pListBox->GetSelItems(cElements, rgiSelections);

		// iterate through the selected windows
		for (int iElement = 0; iElement < cElements; iElement++) {
			// get the pointer to the frame
			CPartFrame* pFrame;
			pFrame = (CPartFrame*)pListBox->GetItemData(rgiSelections[iElement]);
			ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));

			// get a pointer to the active view in the frame
			CPartView* pView = (CPartView*)pFrame->GetActiveView();
			ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
			// get a pointer to the view's document
			CPartDoc* pDoc = pView->GetDocument();

			// we only allow printing text documents, so make sure it's a text doc before printing
			if (IsViewPrintable(pView)) {
				// print the doc
// FUTURE: when ID_FILE_PRINT_DIRECT is working, we'll just send
// an ID_FILE_PRINT_DIRECT message to each view
#ifdef PRINT_DIRECT
				::SendMessage(pView->m_hWnd, WM_COMMAND, ID_FILE_PRINT, 0);
#else
/*
				ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CTextDoc)));
				printAll = TRUE;
				::Print(AfxGetApp()->m_pMainWnd->m_hWnd, (CTextDoc*)pDoc);
*/
#endif
			}
		}

		delete [] rgiSelections;

		UpdateUI();
	}
}
#endif

void COpenDocsDlg::OnOpenDocumentsSave() 
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetSelCount();

	if (cElements > 0)
	{
		CWaitCursor waitCursor;

		// get the selected documents
		int *rgiSelections = new int[cElements];
		pListBox->GetSelItems(cElements, rgiSelections);

		// iterate through the selected documents
		for (int iElement = 0; iElement < cElements; iElement++) {
			// get the pointer to the frame
			CPartFrame* pFrame;
			pFrame = (CPartFrame*)pListBox->GetItemData(rgiSelections[iElement]);
			ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));

			// only save frame's that are saveable
			if (IsFrameSaveable(pFrame)) {
				// get a pointer to the active view in the frame
				CPartView* pView = (CPartView*)pFrame->GetActiveView();
				ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
				// get a pointer to the view's document
				CPartDoc* pDoc = pView->GetDocument();

				// only bother to save if the document's been modified
				if (pDoc->IsModified()) {
					// Olympus:14702
					// store the current directory and restore it after saving
					// in case the directory is changed during Save As
					TCHAR szDir[MAX_PATH];
					DWORD dwResult = GetCurrentDirectory(MAX_PATH-1, szDir);

					// If the Doc is untitled, then call DoSave (NULL) which
					// will bring a a file name dialog.  This is just like OnFileSave
					// The caller is responsible for restoring the origninal view:
					if (pDoc->GetPathName().IsEmpty() && pDoc->GetFirstViewPosition() != NULL) {
						pDoc->DoSave(NULL);
					}
					else {
						pDoc->DoSave(pDoc->GetPathName());
					}

					// as long as we got a valid directory before saving, restore it
					if (dwResult) {
						// set the directory back to its original
						SetCurrentDirectory(szDir);

						// get a pointer to the main frame
						CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
						ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

						// update all window titles
						pMainFrame->OnDirChange();
					}
				}
			}
		}

		FillListBox();

		// restore selection
		for (iElement = 0; iElement < cElements; iElement++) {
			pListBox->SetSel(rgiSelections[iElement], TRUE);
		}

		delete[] rgiSelections;

		UpdateUI();
	}
}

BOOL COpenDocsDlg::MinimizeUnselected(void)
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cSelElements = pListBox->GetSelCount();
	int cElements=pListBox->GetCount();

	if (cSelElements > 1)
	{
		CPartFrame* pFrame;
		pFrame = (CPartFrame*)pListBox->GetItemData(0);

		CWnd *pMDIClient=pFrame->GetParent();

		pMDIClient->SetRedraw(FALSE);

		// iterate through the selected documents
		for (int iElement = 0; iElement < cElements; iElement++)
		{
			// get the pointer to the frame
			CPartFrame* pFrame;
			pFrame = (CPartFrame*)pListBox->GetItemData(iElement);
			// is the item selected
			BOOL bSel=pListBox->GetSel(iElement);

			// if not, minimize the child
			if(!bSel)
			{
				if(!pFrame->IsIconic())
				{
					pFrame->CloseWindow();
				}
			}
			else
			{
				if(pFrame->IsIconic())
				{
					pFrame->OpenIcon();
				}
			}
		}

		pMDIClient->SetRedraw(TRUE);

		CRect rectClient;
		pMDIClient->GetWindowRect(&rectClient);
		::InvalidateRect(NULL, rectClient, TRUE);

		return TRUE;
	}
	else
	{
		// really, the button should be disabled if this branch can be reached
		ASSERT(FALSE);
		return FALSE;
	}
}

void COpenDocsDlg::OnOpenDocumentsTileHorz() 
{
	if(MinimizeUnselected())
	{
		// tile all the remaining (selected) ones
		CMainFrame *pMainFrame=(CMainFrame *)AfxGetMainWnd();
		pMainFrame->MDITile(MDITILE_HORIZONTAL);
	}
}

void COpenDocsDlg::OnOpenDocumentsTileVert() 
{
	if(MinimizeUnselected())
	{
		// tile all the remaining (selected) ones
		CMainFrame *pMainFrame=(CMainFrame *)AfxGetMainWnd();
		pMainFrame->MDITile(MDITILE_VERTICAL);
	}
}

void COpenDocsDlg::OnSelChangeDocList() 
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetSelCount();

	m_bPrintable = FALSE;
	m_bSaveable = FALSE;

	if (cElements > 0) {
		// get the selected documents
		int *rgiSelections = new int[cElements];
		pListBox->GetSelItems(cElements, rgiSelections);

		// iterate through the selected documents
		for (int iElement = 0; iElement < cElements; iElement++) {
			// get the pointer to the frame
			CPartFrame* pFrame;
			pFrame = (CPartFrame*)pListBox->GetItemData(rgiSelections[iElement]);
			ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));

			// get a pointer to the active view in the frame
			CPartView* pView = (CPartView*)pFrame->GetActiveView();
			ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));

			// if the document's printable, set the flag
			if (IsViewPrintable(pView)) {
				m_bPrintable = TRUE;
			}
			// if the view's saveable, set the flag
			if (IsFrameSaveable(pFrame)) {
				m_bSaveable = TRUE;
			}
		}

		delete[] rgiSelections;
	}

	UpdateUI();
}


// Helper used by other helper (InsertStringIntoListBox) below.  Inserts
//  a string into a range (inclusive), sorted within that range.
static int InsertStringInListBoxRange(CListBox* pListBox, LPCTSTR szEntry,
									  int nMin, int nMax)
{
	CString strIter;
	for (int i=nMin; i <= nMax; i++)
	{
		pListBox->GetText(i, strIter);

		// Search 'til we first get after szEntry in alphabetical order
		if (_tcsicmp(strIter, szEntry) < 0)
			continue;

		break;		// i is now the place for szEntry to be
	}

	// Either the loop went to the end or we broke.  Either way,
	//  i is where szEntry should be inserted.
	int nRet = pListBox->InsertString(i, szEntry);
	ASSERT (nRet == i);
	return nRet;
}

// Helper used in FillListBox below.  We want to organize the open docs
//  list so that all files in the CWD are shown w/out paths, but alphabetized
//  amongst themselves at the top.  Then, underneath them are all other docs
//  w/ their full paths, alphabetized amongst themselves.  We don't want docs
//  from the first set being sorted with the others, since that makes the
//  dialog less usable.
static int InsertStringIntoListBox(CListBox* pListBox, LPCTSTR szEntry,
									BOOL bFullPath, int& nFirstFullPath)
{
	if (bFullPath)
	{
		// Insert sorted at bottom
		int nMax = pListBox->GetCount() - 1;
		return InsertStringInListBoxRange(pListBox, szEntry, nFirstFullPath, nMax);
	}
	else
	{
		// Insert sorted at top
		int nRet = InsertStringInListBoxRange(pListBox, szEntry, 0, nFirstFullPath-1);
		nFirstFullPath++;		// This pushes down the first fullpath entry
		return nRet;
	}
}

// Gets the number n in the title "MyDoc:n"
static LPCTSTR GetWndNum(LPCTSTR szTitle)
{
	LPCTSTR szRet = _tcsrchr(szTitle, _T(':'));
	if (szRet == NULL)
		return NULL;

	TCHAR* pch = _tcsinc(szRet);
	while (*pch != NULL)
	{
		if (!_istdigit(*pch) && *pch != '*' && !_istspace(*pch))
			return NULL;
		pch = _tcsinc(pch);
	}
	return szRet;
}

void COpenDocsDlg::FillListBox(void)
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);

	// Find the width of the longest line in the list box
	int cxMaxLineLen = 0;
	int cxCharWidth;
	TEXTMETRIC metrics;
	CDC *pDC;
	CFont *pFont;
	pDC = pListBox->GetDC();
	pFont = GetFont();
	pDC->SelectObject(pFont);
	pDC->GetTextMetrics(&metrics);
	cxCharWidth = metrics.tmMaxCharWidth;

	// Prevent flickering
	pListBox->LockWindowUpdate();

	pListBox->ResetContent();

	// iterate through all MDI windows except: FILTER_DEBUG | FILTER_PROJECT
	int nFilter = FILTER_PROJECT;
	CPartFrame* pMDIChild = theApp.MDITypedGetActive(nFilter);
	int nFirstFullPath = 0;
	while (pMDIChild != NULL)
	{
		CString strTitle;
		int nIndex;
		// get the window's title
		pMDIChild->GetWindowText(strTitle);
		BOOL bFullPath = (strTitle.Find(_T('\\')) != -1);
		if (bFullPath && strTitle.Find(_T('-')) == -1)
		{
			// if this is a non-resource editor window, use the path name instead of the frame title
			// because the frame title for non-resource editor windows is (potentially) truncated
			// but the path name for a resource editor window is just the name of the .rc file
			// is this a resource editor window (contains '-' in title)?
			// HACK: This was bad enough to scare people away from putting this code in
			//  toward the end of V4 (the hack to determine whether a window was a resource
			//  window (and thus to use its frame title instead of doc path as the listbox
			//  entry) based on the occurrence of a '-'.  But, eh, doesn't look THAT bad;
			//  plus, now the docs list will actually be useful since we can have
			//  non-abbreviated full paths in there.

			// don't use the GetWindowText title, use the path
			// get a pointer to the active view in the frame
			CPartView* pView = (CPartView*)pMDIChild->GetActiveView();
			ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
			// get a pointer to the view's document
			CPartDoc* pDoc = pView->GetDocument();
			// get the doc's path name
			strTitle = pDoc->GetPathName();
			// if the path name is empty (i.e. new window), go back to the window title
			if (strTitle.IsEmpty()) 
				pMDIChild->GetWindowText(strTitle);

			// only add following niceties to titles derived from the path name;
			// all titles from the frame window will already have these niceties
			else 
			{
				// Append extra niceties.  First, ":n" for multiple windows
				CString strFrameTitle;
				pMDIChild->GetWindowText(strFrameTitle);
				LPCTSTR szWndNum;
				if ((szWndNum = GetWndNum(strFrameTitle)) != NULL)
				{
					// There's a ":n", so add it if it's not in the title already
					LPCTSTR szDocNum;
					if (((szDocNum = GetWndNum(strTitle)) == NULL)
						|| _tcscmp(szDocNum, szWndNum))
					{
						strTitle += szWndNum;
					}
				}

				// Next nicety: is the document dirty? (Don't do this if we appended
				//  a window number, since the '*' will be included in the text
				//  grabbed after the ':'.
				else if (pDoc->IsModified()) 
					strTitle += _T(" *");
			}
		}

		// add the window to the list
		nIndex = InsertStringIntoListBox(pListBox, strTitle, bFullPath, nFirstFullPath);
		if (nIndex >= 0)
		{
			// store a pointer to the frame
			pListBox->SetItemData(nIndex, (DWORD)pMDIChild);
			// save the new max line length
			cxMaxLineLen = max(cxMaxLineLen, (pDC->GetTextExtent(strTitle, strTitle.GetLength())).cx);
		}

		// get the next MDI window
		pMDIChild = theApp.MDITypedGetNext(pMDIChild, nFilter);
	}

	// Set the width of the list box in case we have a *long* pathname
	// add cxCharWidth because the length of the longest line is always a bit too short
	pListBox->SetHorizontalExtent(cxMaxLineLen + cxCharWidth);

	pListBox->UnlockWindowUpdate();

	pListBox->ReleaseDC(pDC);
}	

void COpenDocsDlg::UpdateUI(void)
{
	// get a pointer to the list box of open documents
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetCount();
	int cSelElements = pListBox->GetSelCount();

	// get pointers to the buttons
	CButton* pbtnActivate = (CButton*)GetDlgItem(IDC_OPEN_DOCUMENTS_ACTIVATE);
	CButton* pbtnClose = (CButton*)GetDlgItem(IDC_OPEN_DOCUMENTS_CLOSE);
#ifdef PRINT_DOC_LIST
	CButton* pbtnPrint = (CButton*)GetDlgItem(IDC_OPEN_DOCUMENTS_PRINT);
#endif
	CButton* pbtnSave = (CButton*)GetDlgItem(IDC_OPEN_DOCUMENTS_SAVE);
	CButton* pbtnTileHorz = (CButton*)GetDlgItem(IDC_OPEN_DOCUMENTS_TILE_HORZ);
	CButton* pbtnTileVert = (CButton*)GetDlgItem(IDC_OPEN_DOCUMENTS_TILE_VERT);

	// Make sure the buttons are properly enabled/disabled
	pbtnActivate->EnableWindow(cSelElements == 1);
	pbtnClose->EnableWindow(cElements > 0);
#ifdef PRINT_DOC_LIST
	pbtnPrint->EnableWindow(cElements > 0 && m_bPrintable);
#endif
	pbtnSave->EnableWindow(cElements > 0 && m_bSaveable);
	pbtnTileHorz->EnableWindow(cSelElements > 1);
	pbtnTileVert->EnableWindow(cSelElements > 1);

	// remove the default style from the buttons
	pbtnClose->SetButtonStyle(pbtnClose->GetButtonStyle() & ~BS_DEFPUSHBUTTON);
#ifdef PRINT_DOC_LIST
	pbtnPrint->SetButtonStyle(pbtnPrint->GetButtonStyle() & ~BS_DEFPUSHBUTTON);
#endif
	pbtnTileHorz->SetButtonStyle(pbtnTileHorz->GetButtonStyle() & ~BS_DEFPUSHBUTTON);
	pbtnTileVert->SetButtonStyle(pbtnTileVert->GetButtonStyle() & ~BS_DEFPUSHBUTTON);

	// make the OK button the default
	SetDefID(IDC_OPEN_DOCUMENTS_ACTIVATE);

	// set focus to the list box
	pListBox->SetFocus();
}

#ifdef PRINT_DIRECT
class CTestCmdUI: public CCmdUI
{
public: // re-implementations only
	virtual void Enable(BOOL bOn) { m_bEnableChanged = bOn; }
};
#endif

BOOL COpenDocsDlg::IsViewPrintable(CPartView* pView)
{
	// get a pointer to the view's document
	CPartDoc* pDoc = pView->GetDocument();

// FUTURE: when ID_FILE_PRINT_DIRECT is working, we'll query each
// doc/view to see it supports printing
#ifdef PRINT_DIRECT
	CTestCmdUI print;
	print.m_nID = ID_FILE_PRINT;

	// check if the view can print
	print.DoUpdate(pView, TRUE);
	if (print.m_bEnableChanged) {
		return TRUE;
	}
	// we probably only need to query the view, because I think the
	// OnUpdateCommandUI will be routed to the doc if the view doesn't
	// handle it
	// check if the doc can print
	print.DoUpdate(pDoc, TRUE);
	if (print.m_bEnableChanged) {
		return TRUE;
	}
	return FALSE;
#else
#ifdef PRINT_DOC_LIST
	return pDoc->IsKindOf(RUNTIME_CLASS(CTextDoc));
#else
	return FALSE;
#endif
#endif
}

BOOL COpenDocsDlg::IsFrameSaveable(CPartFrame* pFrame)
{
	return !pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildDock));
}

void COpenDocsDlg::SelectActiveChild(void)
{
	CListBox *pListBox = (CListBox *)GetDlgItem(IDC_OPEN_DOCUMENTS_LIST);
	int cElements = pListBox->GetCount();
	
	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	// get the active child
	CMDIChildWnd* pActiveChild = pMainFrame->MDIGetActive();
	
	// deselect all items
	pListBox->SetSel(-1, FALSE);
	
	// select the active child 
	for (int iElement = 0; iElement < cElements; iElement++) {
		CPartFrame* pFrame = (CPartFrame*)pListBox->GetItemData(iElement);
		ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));

		// is this the active child
		if (pFrame->m_hWnd == pActiveChild->m_hWnd) {
			pListBox->SetSel(iElement, TRUE);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\oldstat.cpp ===
// statbar.cpp : definition of old backward compatible CStatusBar
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#define _AFX_NO_OLE_SUPPORT
#include <afxpriv.h>
#include "oldstat.h"
#include "barglob.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CStatusBar creation etc

struct AFX_STATUSPANE
{
	UINT    nID;        // IDC of indicator: 0 => normal text area
	UINT    nStyle;     // style flags (SBPS_*)
	int     cxText;     // width of string area in pixels
						//   on both sides there is a 1 pixel gap and
						//    a one pixel border, making a pane 4 pixels wider
	LPCTSTR  lpszText;  // text in the pane
};

inline AFX_STATUSPANE* CStatusBar::_GetPanePtr(int nIndex) const
{
	ASSERT(nIndex >= 0 && nIndex < m_nCount);
	ASSERT(m_pData != NULL);
	return ((AFX_STATUSPANE*)m_pData) + nIndex;
}

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

CStatusBar::CStatusBar()
{
	m_hFont = NULL;

	// setup correct margins
	m_cxRightBorder = m_cxDefaultGap;
	m_cxSizeBox = 0;
	m_bHideSizeBox = FALSE;
	if (globalData.bWin4)
	{
		m_cxLeftBorder = 4;
		m_cyTopBorder = 2;
		m_cyBottomBorder = 0;
		m_cxRightBorder = 0;
	}

	if (globalData.hStatusFont == NULL)
	{
#ifndef _MAC
		// load status bar font
		CClientDC dc(NULL);
		LOGFONT logfont;
		memset(&logfont, 0, sizeof(logfont));
		logfont.lfWeight = FW_NORMAL;
		logfont.lfHeight = -MulDiv(globalData.bWin4 ? 8 : 10, 
			globalData.cyPixelsPerInch, 72);
		lstrcpy(logfont.lfFaceName, _T("MS Sans Serif"));
		BOOL bCustom = AfxCustomLogFont(AFX_IDS_STATUS_FONT, &logfont);
		if (bCustom || !GetSystemMetrics(SM_DBCSENABLED))
		{
			// only set pitch & family if not a custom font
			if (!bCustom)
				logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
			// 10 point height Sans Serif font (8 point for Win4)
			globalData.hStatusFont = ::CreateFontIndirect(&logfont);
		}
#else
		LONG nFondAndSize;
		nFondAndSize = GetScriptVariable(smSystemScript, smScriptHelpFondSize);

		LOGFONT logfont;
		memset(&logfont, 0, sizeof(logfont));
		logfont.lfWeight = FW_NORMAL;
		logfont.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
		logfont.lfHeight = -MulDiv(LOWORD(nFondAndSize), globalData.cyPixelsPerInch, 72);
		GetFontName(HIWORD(nFondAndSize), (StringPtr) logfont.lfFaceName);
		p2cstr((StringPtr) logfont.lfFaceName);
		globalData.hStatusFont = ::CreateFontIndirect(&logfont);
#endif
		if (globalData.hStatusFont == NULL)
		{
			if (!GetSystemMetrics(SM_DBCSENABLED))
				TRACE0("Warning: Using system font for status font.\n");
			globalData.hStatusFont = (HFONT)::GetStockObject(SYSTEM_FONT);
		}
	}
}

void CStatusBar::OnWinIniChange(LPCTSTR /*lpszSection*/)
{
	if (globalData.bWin4)
	{
		// get the drawing area for the status bar 
		CRect rect;
		GetClientRect(rect);
		CalcInsideRect(rect, TRUE);

		// the size box is based off the size of a scrollbar
		m_cxSizeBox = min(GetSystemMetrics(SM_CXVSCROLL)+1, rect.Height());
	}
}

CStatusBar::~CStatusBar()
{
	// free strings before freeing array of elements
	for (int i = 0; i < m_nCount; i++)
		VERIFY(SetPaneText(i, NULL, FALSE));    // no update
	m_dwStyle = 0;
}

BOOL CStatusBar::PreCreateWindow(CREATESTRUCT& cs)
{
	// in Win4, status bars do not have a border at all, since it is
	//  provided by the client area.
	if (globalData.bWin4 &&
		(m_dwStyle & (CBRS_ALIGN_ANY|CBRS_BORDER_ANY)) == CBRS_BOTTOM)
	{
		m_dwStyle &= ~(CBRS_BORDER_ANY|CBRS_BORDER_3D);
	}

	return CControlBar::PreCreateWindow(cs);
}

BOOL CStatusBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent

	// save the style
	m_dwStyle = (UINT)dwStyle;

	// create the HWND
	CRect rect;
	rect.SetRectEmpty();
	LPCTSTR szWndClass = AfxRegisterWndClass(0, LoadCursor(NULL, IDC_ARROW),
		(HBRUSH)(COLOR_BTNFACE + 1), NULL);
	if (!CWnd::Create(szWndClass, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	// Note: Parent must resize itself for control bar to be resized

	// set initial font and calculate bar height
	SendMessage(WM_SETFONT, (WPARAM)globalData.hStatusFont);
	return TRUE;
}

BOOL CStatusBar::SetIndicators(const UINT* lpIDArray, int nIDCount)
{
	ASSERT_VALID(this);
	ASSERT(nIDCount >= 1);  // must be at least one of them
	ASSERT(lpIDArray == NULL ||
		AfxIsValidAddress(lpIDArray, sizeof(UINT) * nIDCount, FALSE));

	// free strings before freeing array of elements
	for (int i = 0; i < m_nCount; i++)
		VERIFY(SetPaneText(i, NULL, FALSE));    // no update

	// first allocate array for panes and copy initial data
	if (!AllocElements(nIDCount, sizeof(AFX_STATUSPANE)))
		return FALSE;
	ASSERT(nIDCount == m_nCount);

	BOOL bOK = TRUE;
	if (lpIDArray != NULL)
	{
		ASSERT(m_hFont != NULL);        // must have a font !
		CString strText;
		CClientDC dcScreen(NULL);
		HGDIOBJ hOldFont = dcScreen.SelectObject(m_hFont);
		for (int i = 0; i < nIDCount; i++)
		{
			AFX_STATUSPANE* pSBP = _GetPanePtr(i);
			pSBP->nID = *lpIDArray++;
			if (pSBP->nID != 0)
			{
				if (!strText.LoadString(pSBP->nID))
				{
					TRACE1("Warning: failed to load indicator string 0x%04X.\n",
						pSBP->nID);
					bOK = FALSE;
					break;
				}
				pSBP->cxText = dcScreen.GetTextExtent(strText,
						strText.GetLength()).cx;
				ASSERT(pSBP->cxText >= 0);
				if (!SetPaneText(i, strText, FALSE))
				{
					bOK = FALSE;
					break;
				}
			}
			else
			{
				// no indicator (must access via index)
				// default to 1/4 the screen width (first pane is stretchy)
				pSBP->cxText = ::GetSystemMetrics(SM_CXSCREEN) / 4;
				if (i == 0)
					pSBP->nStyle |= (SBPS_STRETCH | SBPS_NOBORDERS);
			}
		}
		dcScreen.SelectObject(hOldFont);
	}
	return bOK;
}

#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatusBar attribute access

int CStatusBar::CommandToIndex(UINT nIDFind) const
{
	ASSERT_VALID(this);

	if (m_nCount <= 0)
		return -1;

	AFX_STATUSPANE* pSBP = _GetPanePtr(0);
	for (int i = 0; i < m_nCount; i++, pSBP++)
		if (pSBP->nID == nIDFind)
			return i;

	return -1;
}

UINT CStatusBar::GetItemID(int nIndex) const
{
	ASSERT_VALID(this);
	return _GetPanePtr(nIndex)->nID;
}

void CStatusBar::GetItemRect(int nIndex, LPRECT lpRect) const
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));

	// return rectangle containing inset size
	ASSERT(nIndex >= 0 && nIndex < m_nCount);

	CRect rect;
	GetClientRect(rect);
	CalcInsideRect(rect, TRUE);

	// protect space for size box
	int cxSizeBox = m_bHideSizeBox ? 0 : m_cxSizeBox;
	int xMax = (rect.right -= cxSizeBox);
	if (cxSizeBox == 0)
		xMax += m_cxRightBorder + 1;

	// walk through to calculate extra space
	int cxExtra = rect.Width() + m_cxDefaultGap;
	AFX_STATUSPANE* pSBP = (AFX_STATUSPANE*)m_pData;
	for (int i = 0; i < m_nCount; i++, pSBP++)
		cxExtra -= (pSBP->cxText + CX_BORDER * 4 + m_cxDefaultGap);
	// if cxExtra <= 0 then we will not stretch but just clip

	for (i = 0, pSBP = (AFX_STATUSPANE*)m_pData; i < m_nCount; i++, pSBP++)
	{
		ASSERT(pSBP->cxText >= 0);
		int cxText = pSBP->cxText;
		if ((pSBP->nStyle & SBPS_STRETCH) && cxExtra > 0)
		{
			cxText += cxExtra;
			cxExtra = 0;
		}
		rect.right = rect.left + cxText + CX_BORDER * 4;
		rect.right = min(rect.right, xMax);
		if (i == nIndex)
			break;  // stop with correct rectangle (includes border)
		rect.left = rect.right + m_cxDefaultGap;
		rect.left = min(rect.left, xMax);
	}
	ASSERT(i == nIndex);
	*lpRect = rect;
}

UINT CStatusBar::GetPaneStyle(int nIndex) const
{
	return _GetPanePtr(nIndex)->nStyle;
}

void CStatusBar::SetPaneStyle(int nIndex, UINT nStyle)
{
	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	if (pSBP->nStyle != nStyle)
	{
		// just change the style of 1 pane, and invalidate it
		pSBP->nStyle = nStyle;
		CRect rect;
		GetItemRect(nIndex, &rect);
		InvalidateRect(rect);
	}
}

void CStatusBar::GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle,
	int& cxWidth) const
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	nID = pSBP->nID;
	nStyle = pSBP->nStyle;
	cxWidth = pSBP->cxText;
}

void CStatusBar::SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth)
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	pSBP->nID = nID;
	SetPaneStyle(nIndex, nStyle);  // single pane invalidate
	if (cxWidth != pSBP->cxText)
	{
		// change width of one pane -> invalidate the entire status bar
		pSBP->cxText = cxWidth;
		Invalidate();
	}
}

void CStatusBar::GetPaneText(int nIndex, CString& s) const
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	s = pSBP->lpszText;
}

BOOL CStatusBar::SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate)
{
	ASSERT_VALID(this);

	AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
	if (pSBP->lpszText != NULL)
	{
		if (lpszNewText != NULL && lstrcmp(pSBP->lpszText, lpszNewText) == 0)
			return TRUE;        // nothing to change
		free((LPVOID)pSBP->lpszText);
	}

	BOOL bOK = TRUE;
	if (lpszNewText == NULL || *lpszNewText == '\0')
	{
		pSBP->lpszText = NULL;
	}
	else
	{
		pSBP->lpszText = _tcsdup(lpszNewText);
		if (pSBP->lpszText == NULL)
			bOK = FALSE; // old text is lost and replaced by NULL
	}

	if (bUpdate)
	{
		// invalidate the text of the pane - not including the border
		CRect rect;
		GetItemRect(nIndex, &rect);
		if (!(pSBP->nStyle & SBPS_NOBORDERS))
			rect.InflateRect(-CX_BORDER, -CY_BORDER);
		else
			rect.top -= CY_BORDER;  // base line adjustment
		InvalidateRect(rect);
	}
	return bOK;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar implementation

CSize CStatusBar::CalcFixedLayout(BOOL, BOOL bHorz)
{
	ASSERT_VALID(this);

	// recalculate based on font height + borders
	TEXTMETRIC tm;
	{
		CClientDC dcScreen(NULL);
		HGDIOBJ hOldFont = dcScreen.SelectObject(m_hFont);
		VERIFY(dcScreen.GetTextMetrics(&tm));
		dcScreen.SelectObject(hOldFont);
	}

	CRect rectSize;
	rectSize.SetRectEmpty();
	CalcInsideRect(rectSize, bHorz);    // will be negative size

	// sizeof text + 1 or 2 extra on top, 2 on bottom + borders
	return CSize(32767, tm.tmHeight - tm.tmInternalLeading +
		CY_BORDER * (globalData.bWin4 ? 4 : 3) - rectSize.Height());
}

void CStatusBar::DoPaint(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CControlBar::DoPaint(pDC);      // draw border

	CRect rect;
	GetClientRect(rect);
	CalcInsideRect(rect, TRUE);

	ASSERT(m_hFont != NULL);        // must have a font!
	HGDIOBJ hOldFont = pDC->SelectObject(m_hFont);

	// protect space for size box
	int cxSizeBox = m_bHideSizeBox ? 0 : m_cxSizeBox;
	int xMax = (rect.right -= cxSizeBox);
	if (cxSizeBox == 0)
		xMax += m_cxRightBorder + 1;

	// walk through to calculate extra space
	int cxExtra = rect.Width() + m_cxDefaultGap;
	AFX_STATUSPANE* pSBP = (AFX_STATUSPANE*)m_pData;
	for (int i = 0; i < m_nCount; i++, pSBP++)
		cxExtra -= (pSBP->cxText + CX_BORDER * 4 + m_cxDefaultGap);
	// if cxExtra <= 0 then we will not stretch but just clip

	for (i = 0, pSBP = (AFX_STATUSPANE*)m_pData; i < m_nCount; i++, pSBP++)
	{
		ASSERT(pSBP->cxText >= 0);
		int cxText = pSBP->cxText;
		if ((pSBP->nStyle & SBPS_STRETCH) && cxExtra > 0)
		{
			cxText += cxExtra;
			cxExtra = 0;
		}
		rect.right = rect.left + cxText + CX_BORDER * 4;
		rect.right = min(rect.right, xMax);
		if (!globalData.bWin32s || pDC->RectVisible(&rect))
			DrawStatusText(pDC, rect, pSBP->lpszText, pSBP->nStyle);
		rect.left = rect.right + m_cxDefaultGap;
		if (rect.left >= xMax)
			break;
	}
	pDC->SelectObject(hOldFont);

	// draw the size box in the bottom right corner
	if (cxSizeBox != 0)
	{
		int cxMax = min(cxSizeBox, rect.Height()+m_cyTopBorder);
		rect.left = xMax + (cxSizeBox - cxMax) + CX_BORDER;
		rect.bottom -= CX_BORDER;
		HPEN hPenOld = (HPEN)pDC->SelectObject(globalData.hpenBtnHilite);
		for (int i = 0; i < cxMax; i += 4)
		{
			pDC->MoveTo(rect.left+i, rect.bottom);
			pDC->LineTo(rect.left+cxMax, rect.bottom-cxMax+i);
		}
		pDC->SelectObject(globalData.hpenBtnShadow);
		for (i = 1; i < cxMax; i += 4)
		{
			pDC->MoveTo(rect.left+i, rect.bottom);
			pDC->LineTo(rect.left+cxMax, rect.bottom-cxMax+i);
		}
		for (i = 2; i < cxMax; i += 4)
		{
			pDC->MoveTo(rect.left+i, rect.bottom);
			pDC->LineTo(rect.left+cxMax, rect.bottom-cxMax+i);
		}
		pDC->SelectObject(hPenOld);
	}
}

void CStatusBar::DrawStatusText(CDC* pDC, const CRect& rect,
	LPCTSTR lpszText, UINT nStyle)
{
	ASSERT_VALID(pDC);

	if (!(nStyle & SBPS_NOBORDERS))
	{
		// draw the borders
		COLORREF clrHilite;
		COLORREF clrShadow;

		if (nStyle & SBPS_POPOUT)
		{
			// reverse colors
			clrHilite = globalData.clrBtnShadow;
			clrShadow = globalData.clrBtnHilite;
		}
		else
		{
			// normal colors
			clrHilite = globalData.clrBtnHilite;
			clrShadow = globalData.clrBtnShadow;
		}
		pDC->Draw3dRect(rect, clrShadow, clrHilite);
	}

	// just support left justified text
	if (lpszText != NULL && !(nStyle & SBPS_DISABLED))
	{
		CRect rectText(rect);
		if (!(nStyle & SBPS_NOBORDERS)) // only adjust if there are borders
			rectText.InflateRect(-2*CX_BORDER, -CY_BORDER);
		else
			rectText.OffsetRect(0, -CY_BORDER); // baselines line up

		// background is already grey
		int nOldMode = pDC->SetBkMode(TRANSPARENT);
		COLORREF crTextColor = pDC->SetTextColor(globalData.clrBtnText);
		COLORREF crBkColor = pDC->SetBkColor(globalData.clrBtnFace);

		// align on bottom (since descent is more important than ascent)
		pDC->SetTextAlign(TA_LEFT | TA_BOTTOM);
		pDC->ExtTextOut(rectText.left, rectText.bottom,
			ETO_CLIPPED, &rectText, lpszText, lstrlen(lpszText), NULL);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar message handlers

BEGIN_MESSAGE_MAP(CStatusBar, CControlBar)
	//{{AFX_MSG_MAP(CStatusBar)
	ON_WM_NCHITTEST()
	ON_WM_SYSCOMMAND()
	ON_WM_SIZE()
	ON_MESSAGE(WM_SETFONT, OnSetFont)
	ON_MESSAGE(WM_GETFONT, OnGetFont)
	ON_MESSAGE(WM_SETTEXT, OnSetText)
	ON_MESSAGE(WM_GETTEXT, OnGetText)
	ON_MESSAGE(WM_GETTEXTLENGTH, OnGetTextLength)
	ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
	ON_WM_WININICHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

UINT CStatusBar::OnNcHitTest(CPoint point)
{
	// hit test the size box - convert to HTCAPTION if so
	if (!m_bHideSizeBox && m_cxSizeBox != 0)
	{
		CRect rect;
		GetClientRect(rect);
		CalcInsideRect(rect, TRUE);
		int cxMax = min(m_cxSizeBox-1, rect.Height());
		rect.left = rect.right - cxMax;
		ClientToScreen(&rect);
		if (rect.PtInRect(point))
			return HTBOTTOMRIGHT;
	}
	return CControlBar::OnNcHitTest(point);
}

void CStatusBar::OnSysCommand(UINT nID, LPARAM lParam)
{
	if (!m_bHideSizeBox && m_cxSizeBox != 0 && (nID & 0xFFF0) == SC_SIZE)
	{
		CFrameWnd* pFrameWnd = GetParentFrame();
		if (pFrameWnd != NULL)
		{
			pFrameWnd->SendMessage(WM_SYSCOMMAND, (WPARAM)nID, lParam);
			return;
		}
	}
	CControlBar::OnSysCommand(nID, lParam);
}

void CStatusBar::OnSize(UINT nType, int cx, int cy)
{
	CControlBar::OnSize(nType, cx, cy);

	// adjust m_cxSizeBox if necessary
	OnWinIniChange(NULL);	

	// force repaint on resize (recalculate stretchy)
	Invalidate();
}

LRESULT CStatusBar::OnSetFont(WPARAM wParam, LPARAM)
{
	m_hFont = (HFONT)wParam;
	ASSERT(m_hFont != NULL);

	return 0L;      // does not re-draw or invalidate - resize parent instead
}

LRESULT CStatusBar::OnGetFont(WPARAM, LPARAM)
{
	return (LRESULT)(UINT)m_hFont;
}

LRESULT CStatusBar::OnSetText(WPARAM, LPARAM lParam)
{
	int nIndex = CommandToIndex(0);
	if (nIndex < 0)
		return -1;
	return SetPaneText(nIndex, (LPCTSTR)lParam) ? 0 : -1;
}

LRESULT CStatusBar::OnGetText(WPARAM wParam, LPARAM lParam)
{
	int nMaxLen = (int)wParam;
	if (nMaxLen == 0)
		return 0;       // nothing copied
	LPTSTR lpszDest = (LPTSTR)lParam;

	int nLen = 0;
	int nIndex = CommandToIndex(0); // use pane with ID zero
	if (nIndex >= 0)
	{
		AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
		nLen = pSBP->lpszText != NULL ? lstrlen(pSBP->lpszText) : 0;
		if (nLen > nMaxLen)
			nLen = nMaxLen - 1; // number of characters to copy (less term.)
		memcpy(lpszDest, pSBP->lpszText, nLen*sizeof(TCHAR));
	}
	lpszDest[nLen] = '\0';
	return nLen+1;      // number of bytes copied
}

LRESULT CStatusBar::OnGetTextLength(WPARAM, LPARAM)
{
	int nLen = 0;
	int nIndex = CommandToIndex(0); // use pane with ID zero
	if (nIndex >= 0)
	{
		AFX_STATUSPANE* pSBP = _GetPanePtr(nIndex);
		if (pSBP->lpszText != NULL)
			nLen = lstrlen(pSBP->lpszText);
	}
	return nLen;
}

LRESULT CStatusBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
	AFX_SIZEPARENTPARAMS* lpLayout = (AFX_SIZEPARENTPARAMS*)lParam;
	if (lpLayout->hDWP != NULL)
	{
		// hide size box if parent is maximized
		CFrameWnd* pFrameWnd = GetParentFrame();
		if (pFrameWnd != NULL)
		{
			// the size box only appears when status bar is on the bottom
			//  of a non-maximized, sizeable frame window.
			CRect rectFrame;
			pFrameWnd->GetClientRect(rectFrame);
			
			// Force the status bar at the bottom
			if(rectFrame != lpLayout->rect)
				return 0;

			BOOL bHideSizeBox = pFrameWnd->IsZoomed() ||
				!(pFrameWnd->GetStyle() & WS_THICKFRAME) ||
				rectFrame.bottom != lpLayout->rect.bottom ||
				rectFrame.right != lpLayout->rect.right;

			// update the size box hidden status, if changed
			if (bHideSizeBox != m_bHideSizeBox)
			{
				m_bHideSizeBox = bHideSizeBox;
				Invalidate();
			}
		}
	}

	return CControlBar::OnSizeParent(wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar idle update through CStatusCmdUI class

#define CStatusCmdUI COldStatusCmdUI

class CStatusCmdUI : public CCmdUI      // class private to this file!
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

void CStatusCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CStatusBar* pStatusBar = (CStatusBar*)m_pOther;
	ASSERT(pStatusBar != NULL);
	ASSERT_KINDOF(CStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pStatusBar->GetPaneStyle(m_nIndex) & ~SBPS_DISABLED;
	if (!bOn)
		nNewStyle |= SBPS_DISABLED;
	pStatusBar->SetPaneStyle(m_nIndex, nNewStyle);
}

void CStatusCmdUI::SetCheck(int nCheck) // "checking" will pop out the text
{
	CStatusBar* pStatusBar = (CStatusBar*)m_pOther;
	ASSERT(pStatusBar != NULL);
	ASSERT_KINDOF(CStatusBar, pStatusBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nNewStyle = pStatusBar->GetPaneStyle(m_nIndex) & ~SBPS_POPOUT;
	if (nCheck != 0)
		nNewStyle |= SBPS_POPOUT;
	pStatusBar->SetPaneStyle(m_nIndex, nNewStyle);
}

void CStatusCmdUI::SetText(LPCTSTR lpszText)
{
	ASSERT(m_pOther != NULL);
	ASSERT_KINDOF(CStatusBar, m_pOther);
	ASSERT(m_nIndex < m_nIndexMax);

	((CStatusBar*)m_pOther)->SetPaneText(m_nIndex, lpszText);
}

void CStatusBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CStatusCmdUI state;
	state.m_pOther = this;
	state.m_nIndexMax = (UINT)m_nCount;
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
		state.m_nIndex++)
	{
		state.m_nID = _GetPanePtr(state.m_nIndex)->nID;
		state.DoUpdate(pTarget, bDisableIfNoHndler);
	}

	// update the dialog controls added to the status bar
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

/////////////////////////////////////////////////////////////////////////////
// CStatusBar diagnostics

#ifdef _DEBUG
void CStatusBar::AssertValid() const
{
	// deliberate skipping of base class, because we changed the assumptions... 
	CWnd::AssertValid();

	ASSERT(m_nCount == 0 || m_pData != NULL);
}

void CStatusBar::Dump(CDumpContext& dc) const
{
	CControlBar::Dump(dc);

	dc << "\nm_hFont = " << (UINT)m_hFont;

	if (dc.GetDepth() > 0)
	{
		for (int i = 0; i < m_nCount; i++)
		{
			dc << "\nstatus pane[" << i << "] = {";
			dc << "\n\tnID = " << _GetPanePtr(i)->nID;
			dc << "\n\tnStyle = " << _GetPanePtr(i)->nStyle;
			dc << "\n\tcxText = " << _GetPanePtr(i)->cxText;
			dc << "\n\tlpszText = " << _GetPanePtr(i)->lpszText;
			dc << "\n\t}";
		}
	}

	dc << "\n";
}
#endif //_DEBUG

#undef new
#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CStatusBar, CControlBar)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\oldstat.h ===
// statbar.h : definition of old backward compatible CStatusBar
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _STATBAR_H_
#define _STATBAR_H_

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

struct AFX_STATUSPANE;      // private to implementation

class COldStatusBar : public CControlBar
{
	DECLARE_DYNAMIC(COldStatusBar)
// Construction
public:
	COldStatusBar();
	BOOL Create(CWnd* pParentWnd,
			DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
			UINT nID = AFX_IDW_STATUS_BAR);
	BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);

// Attributes
public: // standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	void GetItemRect(int nIndex, LPRECT lpRect) const;
public:
	void GetPaneText(int nIndex, CString& s) const;
	BOOL SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate = TRUE);
	void GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle, int& cxWidth) const;
	void SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth);
	UINT GetPaneStyle(int nIndex) const;	//REVIEW: doc
	void SetPaneStyle(int nIndex, UINT nStyle);	//REIVEW: doc

// Implementation
public:
	virtual ~COldStatusBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	void EnableDocking(DWORD dwDockStyle);
#endif

protected:
	HFONT m_hFont;
	int m_cxSizeBox;        // for Win4 style size box in corner
	BOOL m_bHideSizeBox;    // hide size box if TRUE

	inline AFX_STATUSPANE* _GetPanePtr(int nIndex) const;
	void DrawStatusText(CDC* pDC, const CRect& rect,
		LPCTSTR lpszText, UINT nStyle);
	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	//{{AFX_MSG(COldStatusBar)
	afx_msg UINT OnNcHitTest(CPoint point);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	afx_msg void OnWinIniChange(LPCTSTR lpszSection);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// define CStatusBar to COldStatusBar for convenience
#define CStatusBar COldStatusBar

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

#endif //!_STATBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\package.cpp ===
// package.cpp : implementation of packages and packets
//

#include "stdafx.h"
#include "main.h"
#include "package.h"
#include "shell.h"

IMPLEMENT_DYNAMIC(CPack, CCmdTarget)
IMPLEMENT_DYNAMIC(CPackage, CPack)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CPack::CPack(CPackage* pPackage, UINT nIDPacket, LPCTSTR lpAccelID)
{
	m_pPackage = pPackage;
	m_nIDPacket = nIDPacket;

	m_lpAccelID = lpAccelID;
}

CPack::~CPack()
{
}

/////////////////////////////////////////////////////////////////////////////
//	CPackage class

CPackage::CPackage(HINSTANCE hInstance, UINT id, UINT flags,
		LPCTSTR lpCmdTableID, LPCTSTR lpBitmapID, LPCTSTR lpAccelID,
		LPCTSTR lpLargeBitmapID)
	: CPack(NULL, PACKET_NIL, lpAccelID)
{
	m_pPackage = this;
	m_hInstance = hInstance;
	m_id = id;
	m_flags = flags;

	m_lpBitmapID = lpBitmapID;
	m_lpLargeBitmapID = lpLargeBitmapID;
	m_hBitmap = NULL;
	m_bLoadedBitmapLarge=FALSE;

	if (lpCmdTableID != NULL)
		theCmdCache.AddCommandResource(this, lpCmdTableID);
}

extern "C" typedef void (FAR PASCAL* EXITPACKAGEPROC)();

CPackage::~CPackage()
{
	if (m_hBitmap != NULL)
		::DeleteObject(m_hBitmap);

	if (m_hInstance != NULL)
	{
		static char BASED_CODE szExitPackage[] = _TEXT("ExitPackage");

		EXITPACKAGEPROC lpfn = (EXITPACKAGEPROC)GetProcAddress(m_hInstance, szExitPackage);
		if (lpfn != NULL)
			(*lpfn)();
		
		// We used to call FreeLibrary() here, but that's bad.
		// The problem is that someone might have subclassed
		// CPackage, in which case this destructor will return
		// to the subclass's destructor -- which is in code that
		// no longer exists!
		//
		// In fact, it is quite dangerous to free the packages
		// until late in the shutdown -- see CTheApp::ExitInstance().
		//
		// [31-Jul-93 mattg]
		//
		// FreeLibrary(m_hInstance);
	}
}

void CPackage::SetVisibleMenuItem(UINT nID, BOOL bVisible /*=TRUE*/)
{
	SetCommandUIFlags(nID, CT_QUERYMENU, !bVisible, CT_NOUI);
}

// NOTE: This function can be used to change UI availability of
// a command (in menus, toolbars, and customized dialogs).  It does not
// however, update existing toolbars.  Thus it should not be used to
// hide a command UI after startup when toolbars have been created.
// (Intended use: removing commands that do not apply without a
// certain package.)

void CPackage::ShowCommandUI(UINT nID, BOOL bShow /*=TRUE*/)
{
	SetCommandUIFlags(nID, CT_NOUI, !bShow, CT_QUERYMENU);
}

void CPackage::SetCommandUIFlags(UINT nID, UINT flags, BOOL bSet, UINT flagHidden)
{
	CTE *pCTE = theCmdCache.GetCommandEntry(nID);
	if (pCTE == NULL ||
		((pCTE->flags & flags) == 0 && !bSet) ||
		((pCTE->flags & flags) == flags && bSet))
	{
		return;
	}

	if (bSet)
		pCTE->flags |= flags;
	else
		pCTE->flags &= ~flags;

	if ((pCTE->flags & flagHidden) == 0)
		theApp.m_bMenuDirty = TRUE;
}

BOOL CPackage::IsVisibleProjectCommand(UINT nID, GUID *pGuids, UINT cGuidCount)
{
	// Everything is visible by default
	return TRUE;
}


LPCTSTR CPackage::GetCommandString(UINT nID, UINT iString)
{

	// Caller should not hold onto the string this returns, but should copy it immediately.
	// There are dynamic string that are stored in a single global CString, and the CString
	// may be overwritten

	LPCTSTR szCommand;
	if (theCmdCache.GetCommandString(nID, iString, &szCommand))
		return szCommand;

	return NULL;
}

BSTR CPackage::GetDynamicCmdString(UINT nID, UINT iString)
{
	// FAT NOTE for derivers: this is usually only called by theCmdCache.GetCommandString.
	// DO NOT have this call theCmdCache.GetCommandString or you 
	// will loop forever. Instead, if you do not have a string and want to
	// get it from the command table, just return NULL
	// and the cmdCache code will get the string it from itself.
	// We do this because there is some tooltip stuff that wants to allow a 
	// package to add the string itself.

	return NULL; // have the cmdCache get it from the command table
}

UINT CPackage::CmdIDForToolTipKey(UINT nIDCmdOriginal)
{
	// Limited use virtual (bobz)
	// This can be called for a command with the CT_DYNAMIC_CMD_STRING flag set.
	// It allows the caller to specify a different command id to use to get the
	// key assignment for a tool tip. It exists primarily for commands that are
	// toolbar HWND controls that have a different sidedocked command, like the
	// Find control or Wizard Bar combos that otherwise lose their tooltips

	// In the default case, just return the same value passed in
	return nIDCmdOriginal;
}

// unloads the bitmap, if loaded
void CPackage::UnloadBitmap(void)
{
	if ((m_hBitmap != NULL))
	{
		::DeleteObject(m_hBitmap);
		m_hBitmap = NULL;
	}
}

// This routine (re) loads the package bitmap and returns it, for example after a change of button size.
HBITMAP CPackage::GetBitmap(BOOL bLarge)
{
	if (m_lpBitmapID != NULL)
	{
		// if something's loaded, return or lose that
		if(m_hBitmap!=NULL)
		{
			if(m_bLoadedBitmapLarge==bLarge)
			{
				return m_hBitmap;
			}
			else
			{
				UnloadBitmap();
			}
		}

		// if this isn't true, we'd leak
		ASSERT(m_hBitmap==NULL);
		
		HINSTANCE hInstance = m_hInstance;
		if (hInstance == NULL)
			hInstance = GetResourceHandle();

			// this code spots packages not following correct conventions for their package bitmaps
#ifdef _DEBUG
		{
			// This assert will fail if a package has failed to provide a 
			// large bitmap resource identifier in its CPackage constructor
			// It should be the seventh parameter to the constructor. martynl 04Mar96
			ASSERT(m_lpLargeBitmapID);

			// get size of small button glyphs
			CSize smallSize=CCustomBar::GetDefaultBitmapSize(FALSE);
			CSize largeSize=CCustomBar::GetDefaultBitmapSize(TRUE);

			HBITMAP hbmSmall=NULL;
			HBITMAP hbmLarge=NULL;

			// These assertions would fail if the bitmap wasn't present in the resource file
			HRSRC hRsrc = ::FindResource(hInstance,	m_lpBitmapID, RT_BITMAP);
			hbmSmall=AfxLoadSysColorBitmap(hInstance, hRsrc);
			ASSERT(hbmSmall!=NULL);

			hRsrc = ::FindResource(hInstance,	m_lpLargeBitmapID, RT_BITMAP);
			hbmLarge=AfxLoadSysColorBitmap(hInstance, hRsrc);
			ASSERT(hbmLarge!=NULL);

			BITMAP bmpSmall;
			BITMAP bmpLarge;
			// These asserts should only fail if GDI is in confusion
			VERIFY(GetObject(hbmSmall, sizeof(BITMAP), &bmpSmall));
			VERIFY(GetObject(hbmLarge, sizeof(BITMAP), &bmpLarge));

			// Check height of bitmaps
			ASSERT(bmpSmall.bmHeight==smallSize.cy);
			ASSERT(bmpLarge.bmHeight==largeSize.cy);

			// Check no slack at end of bitmaps
			ASSERT((bmpSmall.bmWidth % smallSize.cx)==0);
			ASSERT((bmpLarge.bmWidth % largeSize.cx)==0);

			// Check same number of glyphs on both bitmaps
			int nSmallGlyphs=bmpSmall.bmWidth / smallSize.cx;
			int nLargeGlyphs=bmpLarge.bmWidth / largeSize.cx;
			ASSERT(nSmallGlyphs==nLargeGlyphs);
		}
#endif

		LPCTSTR lpCurrentBitmapID=NULL;

		// get the right bitmap id
		if(!bLarge)
		{
			lpCurrentBitmapID=m_lpBitmapID;
		}
		else
		{
			lpCurrentBitmapID=m_lpLargeBitmapID;
		}

		// this should have been caught above anyway, so this means some weird logic error
		ASSERT(lpCurrentBitmapID!=NULL);

		HRSRC hRsrc = ::FindResource(hInstance,	lpCurrentBitmapID, RT_BITMAP);
		if (hRsrc == NULL)
		{
			TRACE0("Warning: Unable to load toolbar bitmap.\n"
				"	Use 0 in command table if bitmap is unnecessary.\n");

			// bad package hasn't got the resources it claims
			ASSERT(FALSE);
			return NULL;
		}

		m_hBitmap = AfxLoadSysColorBitmap(hInstance, hRsrc);

		if(m_hBitmap==NULL)
		{
			// this should have been caught above
			ASSERT(FALSE);
		}

		m_bLoadedBitmapLarge=bLarge;

		return m_hBitmap;
	}
	else
	{
		return NULL;
	}
}

BOOL CPackage::OnInit()
{
	LoadGlobalAccelerators();
	return TRUE;
}

BOOL CPackage::CanExit()
{
	return TRUE;
}

void CPackage::OnExit()
{
}

BOOL CPackage::OnIdle(long lCount)
{
	return FALSE;
}

BOOL CPackage::PreTranslateMessage(MSG* pMsg)
{
	return FALSE;
}

void CPackage::SaveSettings()
{
	// Do nothing.
}

void CPackage::SerializeWorkspaceSettings(CStateSaver& stateSave, DWORD dwFlags)
{
	// Do nothing.
}

void CPackage::SerializeWkspcConvSettings(CStateSaver& stateSave, DWORD dwFlags)
{
	// Do nothing.
}

void CPackage::GetDefProvidedNodes(CPtrList &DefNodeList, BOOL bWorkspaceInit)
{
	// Do nothing.  Node provider packages should create an 
	// object of CDefProvidedNode class and AddTail() a pointer
	// to it to the CPtrList supplied.
}

LPCTSTR CPackage::GetProjectWorkspaceInfoText(LPCTSTR lpszProject)
{
	ASSERT(FALSE);	// derived package should not have PKS_PROJECTINFO flag
	return NULL;
}

void CPackage::SetProjectWorkspaceInfoText(LPCTSTR lpszProject, LPCTSTR lpszInfo)
{
	ASSERT(FALSE);	// derived package should not have PKS_PROJECTINFO flag
}

LPCTSTR CPackage::GetGlobalWorkspaceInfoText()
{
	ASSERT(FALSE);	// derived package should not have PKS_GLOBALINFO flag
	return NULL;
}

void CPackage::SetGlobalWorkspaceInfoText(LPCTSTR lpszInfo)
{
	ASSERT(FALSE);	// derived package should not have PKS_GLOBALINFO flag
}

LPCTSTR CPackage::GetHelpFileName(HELPFILE_TYPE helpfileType)
{
	return NULL; //no default
}

// Dockable window interface

HGLOBAL CPackage::GetDockInfo()
{
	return NULL;
}

HWND CPackage::GetDockableWindow(UINT nID, HGLOBAL hglob)
{
	ASSERT(FALSE);	// Override this, if you register dockable windows or toolbar controls.
	return NULL;
}

HGLOBAL CPackage::GetToolbarData(UINT nID)
{
	ASSERT(FALSE);	// Override this, if you register toolbars.
	return NULL;
}

HICON CPackage::GetDockableIcon(UINT nID)
{
	ASSERT(FALSE);	// Override this, if you register dtEdit dockable windows.
	return NULL;
}

BOOL CPackage::AskAvailable(UINT nIDWnd)
{
	ASSERT(FALSE);	// Override this, if you register context sensitive windows.
	return FALSE;
}

// Customization and Options interface

void CPackage::AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type)
{
	// Default is to do nothing
}

BOOL CPackage::OnNotify(UINT id, void *Hint /*= NULL*/, void *ReturnArea /*= NULL */)
{
	return TRUE;
}

int CPackage::IdsFromFerr(int ferr)
{
	return 0;	// No string ID.
}

void CPackage::LoadGlobalAccelerators()
{
	if (m_lpAccelID != NULL)
	{
		HINSTANCE hInst = AfxFindResourceHandle(m_lpAccelID, RT_ACCELERATOR);
		ASSERT(hInst != NULL);

		HACCEL hAccelTable = LoadAccelerators(hInst, m_lpAccelID);
		ASSERT(hAccelTable != NULL);

		AddGlobalAcceleratorTable(hAccelTable);
		DestroyAcceleratorTable(hAccelTable);
	}
}

BOOL CPackage::AppendExtraPropertyPages(REFGUID guidView, IUnknown* piUnk)
{
	return FALSE;
}

// This is our secret function to enable the Microsoft on the web menu. We don't want package partners to know about this,
// So we want to hide the capability in a seemingly undocumented generic function. Packages that represent products 
// (CPP, Java, ISWS) should use the canonical implementation shown below
UINT CPackage::GetPackageProperty(UINT nProperty)
{
	return 0;
}

// The canonical implementation is this:
// For information on why this is the way it is, see the comments in the shell
// UINT CLangCPPPackage::GetPackageProperty(UINT nProperty)
// {
//	if(nProperty=030370)
//	{
//		return 0x6d736c;
//	}
//	else
//	{
//		return 0;
//	}
// }

// CommDlg interface

// In derived packages, override these functions to add your file filters to
// the Open Files Of Type combo, and to add your editors to the Open As combo.
// pnRank is the relative rank of your package's stuff.
// The existing ranks are:
//		Common Files:		0 - 50		(first)
//		Source & Headers:	100 - 150
//		Projects:			200 - 250
//		Resources:			300 - 350
//		Don't care:			-1		(will be tacked on the end)
//
// nOpenDialog is which dialog this is for.  Packages may have different
// things they want to list for the File.Open dialog vs. the Add.Files.To.Project
// dialog.  If additional File.Open dialogs are created, give them an ID in the
// enum in package.h.

void CPackage::GetOpenDialogInfo(SRankedStringID** ppFilters, 
	SRankedStringID** ppEditors, int nOpenDialog)
{
	// derived classes should return an array of string IDs
	ASSERT( ppFilters != NULL );
	*ppFilters = NULL;
	ASSERT( ppEditors != NULL );
	*ppEditors = NULL;
}

CDocTemplate* CPackage::GetTemplateFromEditor(UINT idsEditor, 
	const char* szFilename)
{
	// must handle exactly those editors passed in to GetOpenAsEditors
	return NULL;	// return NULL if the editor isn't yours
}

/////////////////////////////////////////////////////////////////////////////
//	CPacket class

CPacket::CPacket(CPackage* pPackage, UINT id,
		LPCTSTR lpCmdTableID /*=NULL*/, LPCTSTR lpAccelID /*=NULL*/,
		CSushiBarInfo* pSushiBarInfo /*=NULL*/)
	: CPack(pPackage, id, lpAccelID)
{
	m_pSushiBarInfo = pSushiBarInfo;

	if (lpCmdTableID != NULL)
		theCmdCache.AddCommandResource(this, lpCmdTableID);
}

/****************************************************************************

	FUNCTION:	IsPackageLoaded()

	PURPOSE:	Determines whether the specified package is loaded
				given a path and a file name.

	RETURNS:	TRUE if the package is loaded, FALSE otherwise

****************************************************************************/

BOOL IsPackageLoaded(UINT uiPackageId)
{
	POSITION pos = theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage *)theApp.m_packages.GetNext(pos);

		if (pPackage->PackageID() == uiPackageId)
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\partdoc.cpp ===
// partdoc.cpp : implementation of the CPartDoc class
//

#include "stdafx.h"
#include "io.h" // for access
#include "errno.h"
#include "resource.h"

#include <bldapi.h>
#include <bldguid.h>

#include "AutoDocD.h" //Default Document Automation Object.

#define DOC_CLASS COleDocument

IMPLEMENT_DYNCREATE(CPartDoc, DOC_CLASS)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPartDoc

BEGIN_MESSAGE_MAP(CPartDoc, DOC_CLASS)
	//{{AFX_MSG_MAP(CPartDoc)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_UPDATE_COMMAND_UI(ID_INDICATOR_READ, OnUpdateIndicator)
	//}}AFX_MSG_MAP
	//
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
//
// Creation events. See FireCreationEvent
//
typedef enum
{
	eEventFired = 0,
	eFireOpen = 1,
	eFireNew = 2
} enumFireCreationEvent ;

/////////////////////////////////////////////////////////////////////////////
// CPartDoc construction/destruction

CPartDoc* CPartDoc::s_pSavableDoc = NULL;

BOOL CPartDoc::CanSaveAll()
{
	return (s_pSavableDoc != NULL);
}

void CPartDoc::UpdateSaveAll(BOOL bCreating)
{
	if ((bCreating && s_pSavableDoc != NULL) ||
		(!bCreating && s_pSavableDoc == NULL))
		return;

	POSITION pos = theApp.GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		CPartTemplate* pTemplate = (CPartTemplate*)theApp.GetNextDocTemplate(pos);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));

		POSITION posDoc =pTemplate->GetFirstDocPosition();
		while (posDoc != NULL)
		{
			CPartDoc* pDoc = (CPartDoc*) pTemplate->GetNextDoc(posDoc);
			ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));
			
			// Give the document a chance to filter itself.
			if (!pDoc->IsFiltered(FILTER_DEBUG))
			{
				s_pSavableDoc = pDoc;
				return;
			}
		}
	}

	s_pSavableDoc = NULL;
}

CPartDoc::CPartDoc()
{
	m_pAutoObj = NULL ; // Pointer to the associated automation object.

	m_bReadOnly = FALSE;
	m_bReadOnlyOnDisk = FALSE;
	m_pProxyTemplate = NULL;
	m_nIDString = 0;
	m_FireCreationEvent = eEventFired ; // See FireCreationEvent.

#ifndef NO_VBA
	if (theApp.m_fOleAutomation)
	{
		EnableAutomation();	// enables this->GetIDispatch() for access via OLE automation
	}
#endif	// NO_VBA
}

CPartDoc::~CPartDoc()
{
	//OLEAUTO: Inform the associated automation object that we are gone.
	if (m_pAutoObj != NULL)
	{
		m_pAutoObj->AssociatedObjectReleased() ;
	}


	if (s_pSavableDoc == this)
	{
		if (m_pDocTemplate != NULL)
			m_pDocTemplate->RemoveDocument(this);
		ASSERT(m_pDocTemplate == NULL);     // must be detached

		UpdateSaveAll(FALSE);
	}
}

void CPartDoc::OnFileSave()
{
	LPCTSTR szFilename ;
	if (IsReadOnly())
	{
		szFilename = NULL ;
	}
	else
	{
		szFilename = m_strPathName ;
	}

	if (!DoSave(szFilename))
	{
		TRACE0("Warning: File save failed\n");
	}
}

void CPartDoc::OnFileSaveAs()
{
	if (!DoSave(NULL))
		TRACE0("Warning: File save-as failed\n");
}

// Document closing became complicated because we wanted to fire an OLE Event before the document was invalid.
// So we needed a separate virtual. But since functions overrode OnCloseDocument directly, and MFC calls
// OnClose document directly, we needed to change something. I decided to stop us overriding OnCloseDocument, 
// which is now broken down into two overridables - PreCloseDocument and CloseDocument. Override PreCloseDocument
// to take some action before saving happens, Override CloseDocument to actually save stuff.

// This is the one that gets called to actually make the close happen
void CPartDoc::OnCloseDocument()
{
	PreCloseDocument();
	CloseDocumentHook() ;

	return;
}

void CPartDoc::PreCloseDocument(void)
{
	// Fire the appropriate event
	IDispatch* pAssociatedAutoObj = GetAutomationObject(TRUE) ;
	if(pAssociatedAutoObj  != NULL)
	{
		theApp.m_pAutoApp->FireBeforeDocumentClose(pAssociatedAutoObj);
		pAssociatedAutoObj->Release();
	}
}

void CPartDoc::CloseDocumentHook()
{
#ifdef _AUTOSAVE
	// Check for an autosave file & nuke it before closing the file
	if (!GetPathName().IsEmpty())
	{
		CPath pathAutosaveClobber;
		pathAutosaveClobber.Create(GetPathName());
		gAutosaver.RemoveAutosaveFile(pathAutosaveClobber);
	}
#endif

	// Not a bug
	ParentCloseDocumentHook() ; // Call base class.	
}

//
// This function calls the base class for
// CloseDocumentHook which happens to be OnCloseDocument.
//
void CPartDoc::ParentCloseDocumentHook()
{
	DOC_CLASS::OnCloseDocument(); 
}

BOOL CPartDoc::CanCloseFrame(CFrameWnd *pFrame)
{
	if (DOC_CLASS::CanCloseFrame(pFrame))
	{
		// If the file isn't modified, we don't get a chance to remove
		// an autosave file when the frame gets closed, so we have to
		// do it here.
#ifdef _AUTOSAVE
		if (!GetPathName().IsEmpty())
		{
			CPath pathAutosaveClobber;
			pathAutosaveClobber.Create(GetPathName());
			gAutosaver.RemoveAutosaveFile(pathAutosaveClobber);
		}
#endif
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CPartDoc::IsFiltered(UINT nFlags)
{
	// Get the doc's frame (if there is one):
	POSITION pos = GetFirstViewPosition();
	if (pos == NULL)
		return TRUE;	// Filter docs with no views.

	if ((nFlags & (FILTER_DEBUG | FILTER_NON_PROJECT)) != 0)
	{
		CView* pView = GetNextView(pos);
		ASSERT(pView);
		CPartFrame* pFrame = (CPartFrame*) pView->GetParent();
		while (pFrame != NULL && !pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
			pFrame = (CPartFrame*) pFrame->GetParent();

		if ((nFlags & FILTER_DEBUG) != 0 &&
			(pFrame == NULL || pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildDock))))
			return TRUE;

		if ((nFlags & FILTER_NON_PROJECT) != 0)
		{
			extern CPartFrame* GetProjectFrame();

			CPath cp;
			LPBUILDSYSTEM pBldSysIFace;
			theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace);
			CPartFrame* pProjFrame = GetProjectFrame();
		 
			if ((pFrame == NULL || pFrame != pProjFrame) &&
				(pBldSysIFace == NULL || !cp.Create(GetPathName()) ||
				(pBldSysIFace->IsActiveBuilderValid() == S_OK && pBldSysIFace->IsProjectFile(&cp, FALSE, ACTIVE_BUILDER) != S_OK)))
			{
				if (pBldSysIFace)
					pBldSysIFace->Release();
				return TRUE;
			}

			if (pBldSysIFace)
				pBldSysIFace->Release();

			/*
			CPath cp;
			if ( !cp.Create( GetPathName() ) || !GetBldSysIFace()->IsProjectFile(&cp, TRUE ACTIVE_BUILDER) )
			{
				return TRUE;
			}
			*/
		}
	}

	if ((nFlags & FILTER_NEW_FILE) != 0	&& GetPathName().IsEmpty())
		return TRUE;

	return FALSE;
}

// Save as MFC 2.1, but doesn't delete files when the save fails!
//
BOOL CPartDoc::DoSave(const char* pszPathName, BOOL bReplace /*=TRUE*/)
	// Save the document data to a file
	// pszPathName = path name where to save document file
	// if pszPathName is NULL then the user wi..\ll be prompted (SaveAs)
	// note: pszPathName can be different than 'm_strPathName'
	// if 'bReplace' is TRUE will change file name if successful (SaveAs)
	// if 'bReplace' is FALSE will not change path name (SaveCopyAs)
	//
	// If the file name changes, then the autosave file [if it exists] for
	// the old name is deleted.
{
	CString newName = pszPathName;
	BOOL bPromptForName = newName.IsEmpty();
	CDocTemplate* pTemplate;
	UINT nSaveType = 0;

	if (!g_pAutomationState->DisplayUI() && bPromptForName) //ShellOM:State
	{
		// We cannot prompt the name because we are being called by an OLE Automation method.
		g_pAutomationState->SetError(DS_E_NOFILENAME) ;
		return FALSE ;
	};

	// We need to check to see if the file is accessable. newName may be different from m_strPathName.
	if (!bPromptForName && _access(newName, 6) != 0 && errno == EACCES)
//	if (!bPromptForName && _access(m_strPathName, 6) != 0 && errno == EACCES)
	{

		if (g_pAutomationState->DisplayUI()) // Can we show UI? ShellOM:State.
		{
			CString strComment;
			strComment.LoadString(IDS_ROCOMMENT);
			CString strMessage = m_strPathName + strComment;
			int nRet = AfxMessageBox(strMessage, MB_OKCANCEL | MB_ICONEXCLAMATION);

			// create a messagebox-like dialog, with Save As (default), Overwrite,
			// and Cancel buttons.
	//		int nRet = CMessageBox::DoMessageBox(strMessage, theApp.m_pszAppName, 
	//			strButtons, MB_ICONEXCLAMATION, 0, 2, NULL, NULL);	// FUTURE: need a parent as the last argument

			if( nRet == IDCANCEL )		// was 2: cancel button
			{
				g_pAutomationState->SetSavePromptCanceled() ; // Inform automation engine that operation was canceled
				return FALSE;
			}
			if( nRet == IDOK )			// was 0: save as button
			{
				bPromptForName = TRUE;
			}
	/*		else		// IDYES		// was overwrite button
			{
				if( !_chmod(m_strPathName, _S_IWRITE) == 0 )
				{
					// unable to affect read-only
					strComment.LoadString(IDS_ROCOMMENT);
					strMessage = m_strPathName + strComment;
					if( CMessageBox::DoMessageBox(strMessage, theApp.m_pszAppName, 
						strButtons, MB_ICONEXCLAMATION, 0, 1, NULL, NULL) == 1 )	// FUTURE: need a parent as the last argument
					{
						return FALSE;		// cancel button
					}
					bPromptForName = TRUE;	// save as button
				}
			}
	*/
		}
		else
		{
			// The Automation Object is not allowing UI, so return an error.
			g_pAutomationState->SetError(DS_E_READONLY) ;
			return FALSE ;
		}
	}

	if (bPromptForName)
	{
		ASSERT(g_pAutomationState->DisplayUI()) ; // Only prompt if not automated. ShellOM:State

		pTemplate = GetDocTemplate();
		ASSERT(pTemplate != NULL);

		newName = m_strPathName;
		if (newName.IsEmpty())
		{
			newName = GetDefaultTitle();
			int iBad = newName.FindOneOf("<>:\"/\\|");    // dubious filename
			if (iBad != -1)
				newName.ReleaseBuffer(iBad);

			newName.TrimRight();
						
			// append the default suffix if there is one
			CString strExt;
			
#if 0 // [paulde] removed GetDefaultFileExtension()
			// give the package a chance to set it if it's not already set:
			if (m_nIDString == 0)
				SetDocString(GetPackage()->GetDefaultFileExtension());
#endif

			if (GetDocString(strExt, CDocTemplate::filterExt)
				&& !strExt.IsEmpty())
			{
				ASSERT(strExt[0] == '.');
				newName += GetExtensionCase(newName, strExt);
			}
		}

		if (!theApp.DoPromptFileSave(newName, AFX_IDS_SAVEFILE,
			OFN_PATHMUSTEXIST, this, &nSaveType))
		{
			g_pAutomationState->SetSavePromptCanceled() ; // Inform automation engine that operation was canceled
			return FALSE;       // don't even try to save
		}

		if (IsReadOnly() && (newName.CompareNoCase(m_strPathName) == 0))
		{
			MsgBox(Error, IDS_ERROR_CANT_SAVERO2);
			return FALSE;
		}
	}

	// It is crazy to be recording undo around a save, since you would only be
	// undoing the side effects of the save, but not the save itself.  Also, it 
	// was causing a crash in the RES editor when undoing something that did a save.
	BOOL bUndoPause = FALSE;
	if( theUndoSlob.IsRecording() )
	{
		theUndoSlob.Pause();
		bUndoPause = TRUE;
	}

	if (!OnSaveDocument(newName, nSaveType))
		return FALSE;

	if( bUndoPause )
		theUndoSlob.Resume();

	if (bReplace)
	{
		Replace(newName, nSaveType);
	}
	return TRUE;        // success
}

BOOL CPartDoc::Replace(const char* pszPathName, UINT nSaveType)
{
	// Reset the title and change the document name
	// Clobber an existing autosave file for the old name.
#ifdef _WIN32
	if (!GetPathName().IsEmpty())
	{
		CPath pathAutosaveClobber;
		pathAutosaveClobber.Create(GetPathName());
		gAutosaver.RemoveAutosaveFile(pathAutosaveClobber);
	}
#endif
	CString newName = pszPathName;
	GetActualFileCase( newName );
	SetPathName(newName);
	//
	// NB: can't really assert this because VCPP documents
	// may not have a name.  they override SetPathName and
	// do nothing with it.	they are pseudo documents.
	// [18-Oct-1993 dans]
	//ASSERT(m_strPathName == newName); 	  // must be set
	return TRUE;
}

BOOL CPartDoc::GetValidFilters(UINT** paIDS, UINT* pnInitial)
{
	*paIDS = NULL;
	*pnInitial = 0;
	return FALSE;		// if this isn't overridden, don't expect anything
}

//
// OnSaveDocument 
// DO NOT OVERRIDE THIS FUNCTION! 
// Instead, override SaveDocumentHook.
//
BOOL CPartDoc::OnSaveDocument(const char* pszPathName, UINT nSaveType)
{
	BOOL b = SaveDocumentHook(pszPathName, nSaveType) ;
	return PostSaveDocument(b) ;
};

//
// PostSaveDocument
// Fires the automation event after the document has been saved.
//
BOOL CPartDoc::PostSaveDocument(BOOL bResult)
{
	if (bResult)
	{
		// Fire the appropriate event
		IDispatch* pAssociatedAutoObj = GetAutomationObject(TRUE) ;

		if(pAssociatedAutoObj  != NULL)
		{
			theApp.m_pAutoApp->FireDocumentSave(pAssociatedAutoObj);
			pAssociatedAutoObj->Release();
		}
	}
	return bResult ;
};

//
// SaveDocumentHook
// Packages can override this function.
//
BOOL CPartDoc::SaveDocumentHook(const char* pszPathName, UINT nSaveType)
{
	TRACE("CPartDoc::SaveDocumentHook: %s\n", pszPathName);

#ifdef _AUTOSAVE
	if (*pszPathName != '\0')
	{
		CPath pathAutosaveClobber;
		pathAutosaveClobber.Create(pszPathName);
		gAutosaver.RemoveAutosaveFile(pathAutosaveClobber);
	}
#endif

	SetModifiedFlag(FALSE);

	return TRUE ;
}

//
// Call the base class version of SaveDocumentHook which
// is really OnSaveDocument
//
BOOL CPartDoc::ParentSaveDocumentHook(const char* pszPathName, UINT nSaveType)
{
	return DOC_CLASS::OnSaveDocument(pszPathName) ;
}	


//
// OnNewDocument 
// DO NOT OVERRIDE THIS FUNCTION! 
// Instead, override NewDocumentHook.
//
BOOL CPartDoc::OnNewDocument()
{
	BOOL b = NewDocumentHook() ;
	return PostNewDocument(b) ;
};

//
// PostNewDocument
// Fires the automation event after the document has been created.
//
BOOL CPartDoc::PostNewDocument(BOOL bResult)
{
	if (bResult)
	{
		// See FireCreationEvent
		m_FireCreationEvent = eFireNew ;
	}

	return bResult;
};

//
// NewDocumentHook
// Packages can override this function to customize creating
// new documents.
//
BOOL CPartDoc::NewDocumentHook()
{
	if (!ParentNewDocumentHook())
		return FALSE;

	UpdateSaveAll(TRUE);

	return TRUE;
}

//
// This function calls the base class for
// NewDocumentHook which happens to be OnNewDocument.
//
BOOL CPartDoc::ParentNewDocumentHook()
{
	return DOC_CLASS::OnNewDocument() ;
}


//
// OnOpenDocument 
// DO NOT OVERRIDE THIS FUNCTION! 
// Instead, override OpenDocumentHook.
//
BOOL CPartDoc::OnOpenDocument(const char* pszPathName)
{
	BOOL b = OpenDocumentHook(pszPathName) ;
	return PostOpenDocument(b) ;
}

//
// PostOpenDocument
// Fires the automation event after the document has been opened.
//
BOOL CPartDoc::PostOpenDocument(BOOL bResult)
{
	if (bResult)
	{
		// See FireCreationEvent
		m_FireCreationEvent = eFireOpen ;
	}

	return bResult ;
}

//
// OpenDocumentHook
// Packages can override this function to customize creating
// new documents.
//
BOOL CPartDoc::OpenDocumentHook(const char* pszPathName)
{
	CString strPathName = pszPathName;
	GetActualFileCase( strPathName );
	SetPathName( strPathName );
	SetModifiedFlag(FALSE);

#ifdef _AUTOSAVE
	// Check for an autosaved backup copy.  Returns FALSE if the user cancels.
	CPath pathToOpen;
	pathToOpen.Create( strPathName );
	if (!gAutosaver.RecoverAutosaveFileCheck(pathToOpen))
		return FALSE;
#endif

	UpdateSaveAll(TRUE);

	return TRUE;
}

//
// This function calls the base class for
// OpenDocumentHook which happens to be OnOpenDocument.
//
BOOL CPartDoc::ParentOpenDocumentHook(const char* pszPathName)
{
	return DOC_CLASS::OnOpenDocument(pszPathName) ;
}


void CPartDoc::ActivateDoc()
{
	POSITION pos = GetFirstViewPosition();
	if (pos == NULL)
		return;

	CView* pView = GetNextView(pos);
	if (pView == NULL)
		return;

	CFrameWnd* pFrame = pView->GetParentFrame();
	if (pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
		pFrame->ActivateFrame();
}

BOOL CPartDoc::AttemptCloseDoc()
{
	InformationBox(ERR_Other_Type_Open);
	return FALSE;
}

BOOL CPartDoc::SaveModified()
{
	if (!IsModified())
		return TRUE;        // ok to continue

	CString name = m_strPathName;
	if (name.IsEmpty())
		name = m_strTitle;

#ifdef _AUTOSAVE
	CPath pathAutosave;
#endif

	int iOption = IDYES ;
	if (g_pAutomationState->DisplayUI()) //ShellOM:State
	{
		// Display UI
		CString prompt;
		AfxFormatString1(prompt, AFX_IDP_ASK_TO_SAVE, name);
		iOption = AfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE);
	}
	else
	{
		// Don't Display UI
		iOption = g_pAutomationState->SaveChanges() ? IDYES : IDNO ;
	}

	// Save or Loose changes.
	switch (iOption)
	{
	case IDCANCEL:
		g_pAutomationState->SetSavePromptCanceled() ; // Inform automation engine that operation was canceled
		return FALSE;       // don't continue

	case IDYES:
		// If so, either Save or Update, as appropriate.
		// Somewhere down DoSave() we do autosave file clobbering.
		if (!DoSave(m_strPathName))
			return FALSE;       // don't continue
		break;

	case IDNO:
		// If not saving changes, revert the document & clobber autosave file.
		// Don't do this if the document is untitled though!
		// FUTURE:  In here we must remove autosave files for untitled documents!!

#ifdef _AUTOSAVE
		if (!m_strPathName.IsEmpty())
		{
			pathAutosave.Create(m_strPathName);
			gAutosaver.RemoveAutosaveFile(pathAutosave);
		}
#endif
		break;

	default:
		ASSERT(FALSE);
		break;
	}
	return TRUE;    // keep going
}

/////////////////////////////////////////////////////////////////////////////
// CPartDoc serialization

void CPartDoc::Serialize(CArchive& ar)
{
	ASSERT(FALSE); // we don't do archives!
}

/////////////////////////////////////////////////////////////////////////////
// CPartDoc diagnostics

#ifdef _DEBUG
void CPartDoc::AssertValid() const
{
	DOC_CLASS::AssertValid();
}

void CPartDoc::Dump(CDumpContext& dc) const
{
	DOC_CLASS::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CPartDoc commands

CSlob* CPartDoc::GetSlob()
{
	return NULL;
}


BOOL CPartDoc::IsReadOnly()
{
	return m_bReadOnly;
}

// override this to supply more interesting handling of R/O condions (check out)
BOOL CPartDoc::IsReadOnlyEx(BOOL bHandleError /* = TRUE */)
{
	if ((m_bReadOnly) && (bHandleError))
	{
		MessageBeep(0);
	}
	return m_bReadOnly;
}

void CPartDoc::SetReadOnly(BOOL bReadOnly /* = TRUE */)
{
	m_bReadOnly = bReadOnly;
}

void CPartDoc::OnUpdateIndicator(CCmdUI* pCmdUI)
{
	if (pCmdUI->m_nID == ID_INDICATOR_READ)
		pCmdUI->Enable(IsReadOnly() || IsReadOnlyOnDisk());

#ifdef _DEBUG
	else
		ASSERT(FALSE);
#endif
}

void CPartDoc::SetModifiedFlag(BOOL bModified)
{
	if (bModified == m_bModified)
		return;
	
	DOC_CLASS::SetModifiedFlag(bModified);
	UpdateFrameCounts();
}

BOOL CPartDoc::GetDocString(CString& rString, enum CDocTemplate::DocStringIndex i) const
{
	if( m_nIDString != 0 )
	{
		CString strDocString;
		strDocString.LoadString(m_nIDString);
		return AfxExtractSubString(rString, strDocString, (int)i);
	}
	else if (m_pProxyTemplate != NULL)
	{
		return m_pProxyTemplate->GetDocString(rString, i);
	}

	ASSERT(GetDocTemplate() != NULL);
	return GetDocTemplate()->GetDocString(rString, i);
}

BOOL CPartDoc::OnFileChange(int nPackage, FCItem* pFCItem)
{
	// derived document classes that handle file change notifications
	// can override this function, and see if the file that changed is yours.
	return FALSE;
}

long CPartDoc::GetDocLong(int nVar)
{
	switch (nVar)
	{
	case GDL_PROXYTEMPLATE:
		return (long) m_pProxyTemplate;
	default:
		ASSERT(FALSE);	// unsupported value
		break;
	}

	return 0x0;		// there is no good error code
}

long CPartDoc::SetDocLong(int nVar, long lData)
{
	long lRet = GetDocLong(nVar);	// get previous value, to return later

	switch (nVar)
	{
	case GDL_PROXYTEMPLATE:
		m_pProxyTemplate = (CPartTemplate*)lData;
		break;
	default:
		ASSERT(FALSE);	// unsupported value
		break;
	}

	return lRet;
}

/////////////////////////////////////////////////////////////////////////////////////////
// 
//  OLE Automation support functions.
//

//
// Override to return the automation object corresponding to this object.
// Default creates an automation object and returns it.
//
IDispatch* CPartDoc::GetAutomationObject(BOOL bAddRef)
{
	if (m_pAutoObj)
	{
		return m_pAutoObj->GetIDispatch(bAddRef);
	}

	m_pAutoObj = new CAutoDocumentDefault(this) ;
	return m_pAutoObj->GetIDispatch(FALSE); // creation is an implicit AddRef
}

void CPartDoc::AutomationObjectReleased()
{
	m_pAutoObj = NULL ;
}


///////////////////////////////////////////////////////////
//
// Orion 96 Bug 12176 - We must fire the New and Open events
// after the windows have been created, but before the activation
// events for the windows. Therefore, we set a variable and wait
// for the window to get activated. This funciton is called by
// the code which fires the window activation. 
//
void CPartDoc::FireCreationEvent()
{
	//WARNING: The automation method may delete this document
	// during this call. So, we can't expect to do anything which
	// uses member variables after this point!

	// Save the member variable to a temp var on the stack.
	UINT FireCreationEventTemp = m_FireCreationEvent ;

	// Reset the member variable.
	m_FireCreationEvent = eEventFired ;

	// From now on use the temp.
	if (FireCreationEventTemp != eEventFired )
	{
		// Fire the appropriate event
		IDispatch* pAssociatedAutoObj = GetAutomationObject(TRUE) ;
		if(pAssociatedAutoObj  != NULL)
		{
			if (FireCreationEventTemp == eFireOpen)
			{
				theApp.m_pAutoApp->FireDocumentOpen(pAssociatedAutoObj);
			}
			else
			{
				theApp.m_pAutoApp->FireNewDocument(pAssociatedAutoObj);
			}
			pAssociatedAutoObj->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\partvw.cpp ===
// partvw.cpp : implementation of the CPartView class
//

#include "stdafx.h"
#include "main.h"

#include "imeutil.h"
#include "find.h"
#include "remi.h"
#include "resource.h"
#include "bardockx.h"

#include "toolexpt.h"

IMPLEMENT_DYNCREATE(CPartView, CSlobWnd)
IMPLEMENT_DYNCREATE(CDockablePartView, CPartView)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPartView

BEGIN_MESSAGE_MAP(CPartView, CSlobWnd)
	//{{AFX_MSG_MAP(CPartView)
	ON_WM_SYSCOMMAND()
	ON_COMMAND(ID_EDIT_FIND, OnEditFind)
	ON_COMMAND(ID_EDIT_FIND_DLG, OnEditFind)
	ON_COMMAND(ID_EDIT_FIND_NEXT, OnEditFindNext)
	ON_COMMAND(ID_EDIT_FIND_PREV, OnEditFindPrev)
	ON_COMMAND(IDM_EDIT_TOGGLE_CASE, OnToggleFindCase)
	ON_COMMAND(IDM_EDIT_TOGGLE_RE, OnToggleFindRE)
	ON_COMMAND(IDM_EDIT_TOGGLE_WORD, OnToggleFindWord)
	ON_COMMAND(IDM_EDIT_TOGGLE_SEARCH_ALL_DOCS, OnToggleSearchAllDocs)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateFindReplace)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND_DLG, OnUpdateFindReplace)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND_NEXT, OnUpdateFindReplace)
	ON_UPDATE_COMMAND_UI(ID_EDIT_FIND_PREV, OnUpdateFindReplace)

	ON_UPDATE_COMMAND_UI(IDM_EDIT_TOGGLE_CASE, OnUpdateToggleMatchCase)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_TOGGLE_WORD, OnUpdateToggleMatchWord)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_TOGGLE_RE, OnUpdateToggleMatchRegEx)
	ON_UPDATE_COMMAND_UI(IDM_EDIT_TOGGLE_SEARCH_ALL_DOCS, OnUpdateToggleSearchAllDocs)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPartView construction/destruction

CPartView::CPartView()
{
	m_pPacket = NULL;
}

CPartView::~CPartView()
{
}

CPartTemplate* CPartView::GetDocTemplate()
{
	CPartDoc* pDoc = GetDocument();
	if (pDoc == NULL)
		return NULL;

	return (CPartTemplate*) pDoc->GetDocTemplate();
}

int CPartView::GetAssociatedFiles(CStringArray & saFiles, BOOL /* bSelected = TRUE */)
{
	const CDocument * pDoc = GetDocument();
	if ((pDoc == NULL) || (pDoc->GetPathName().IsEmpty()))
		return 0;

	CPath path;
	if (!path.Create(pDoc->GetPathName()))
	{
		return 0;
	}

	saFiles.Add((LPCTSTR)path);
	return 1;
}

// Tries to position the dialog outside the view window.
// Returns TRUE if it could reposition the dialog
// Note: CTextView's  does more than this, but this might get the dialog out of the way at startup

BOOL CPartView::SetDialogPos(BOOL fFirstTime, HWND hDlg)
{
	if (fFirstTime)
	{
		// try moving dialog completely outside of view window
		CRect rectWindow, rectClient;
		RECT rectDlg;
		int x, y, xDlg, yDlg;
		int cxScreen = GetSystemMetrics(SM_CXSCREEN);
		int cyScreen = GetSystemMetrics(SM_CYSCREEN);


		// get rectangle for dialog box
		::GetWindowRect(hDlg, &rectDlg);
		xDlg = rectDlg.right - rectDlg.left;
		yDlg = rectDlg.bottom - rectDlg.top;

		// get window rectangle in screen coordinates.
		GetWindowRect(rectWindow);
		// get window rectangle in client coordinates (excludes scroll bars, etc).
		GetClientRect(rectClient);

		// adjust screen coordinate rectangle.Allows dialog to overlay scroll bars or title
		rectWindow.bottom = rectWindow.top + rectClient.bottom;
		rectWindow.right = rectWindow.left + rectClient.right;

		// forcing repositioning, attempt to position dialog
		// outside of editor window client window area.

		// if the dialog can be repositioned outside window rectangle, do it.
		if (yDlg < rectWindow.top)	// above
		{
			x = (cxScreen - xDlg) / 2;
			y = rectWindow.top - yDlg;
			::MoveWindow(hDlg, x, y, xDlg, yDlg, TRUE);
			return TRUE;
		}
		else if (yDlg < (cyScreen - rectWindow.bottom + 2))  // below
		{
			x = (cxScreen - xDlg) / 2;
			y = rectWindow.bottom + 2;
			::MoveWindow(hDlg, x, y, xDlg, yDlg, TRUE);
			return TRUE;
		}
		else if (xDlg < rectWindow.left)	// left
		{
			x = rectWindow.left - xDlg;
			y = (cyScreen - yDlg) / 2;
			::MoveWindow(hDlg, x, y, xDlg, yDlg, TRUE);
			return TRUE;
		}
		else if (xDlg < (cxScreen - rectWindow.right + 2))	// right
		{
			x = rectWindow.right + 2;
			y = (cyScreen - yDlg) / 2;
			::MoveWindow(hDlg, x, y, xDlg, yDlg, TRUE);
			return TRUE;
		}
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CPartView diagnostics

#ifdef _DEBUG
void CPartView::AssertValid() const
{
	CSlobWnd::AssertValid();
}

void CPartView::Dump(CDumpContext& dc) const
{
	CSlobWnd::Dump(dc);
}

CPartDoc* CPartView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument == NULL ||
		m_pDocument->IsKindOf(RUNTIME_CLASS(CPartDoc)));
	return (CPartDoc*) m_pDocument;
}
#endif //_DEBUG


BOOL CPartView::CanClose()
{
	return TRUE;
}

void CPartView::OnSysCommand(UINT nID, LPARAM lParam)
{
	switch(nID & 0xFFF0)
	{
		case SC_MOUSEMENU:
			CBMenuPopup::SetSystemClick(GetMessageTime(), CPoint(LOWORD(lParam), HIWORD(lParam)));
		case SC_KEYMENU:
			if(	((nID & 0xFFF0)==SC_MOUSEMENU || lParam=='-') &&
				CASBar::s_pMenuBar->GetSafeHwnd()!=NULL &&
				Menu::IsShowingCmdBars())
			{
				CASBar::s_pMenuBar->KeyDown(VK_SUBTRACT,0,0);
				return;
			}
			break;

		// why do this? Because it happens when you single click on an icon before the double
		// click to deminimize the icon
		case SC_MOVE:
			CBMenuPopup::SetSystemClick(GetMessageTime(), CPoint(LOWORD(lParam), HIWORD(lParam)));
			break;

	}
	CSlobWnd::OnSysCommand(nID, lParam);
}

void CPartView::OnLoadWorkspace()
{
	// Override this to load your init-data from the workspace...
}

void CPartView::OnFindNext(BOOL* pbSuccess /*=NULL*/)
{	// Combo box search
	if(findReplace.regExpr)
	{
		findReplace.CompileRegEx(GetRegExprSyntax());

		if(findReplace.pat == NULL) // Problem in the regular expression
		{
			ErrorBox(IDS_REGEXPR_INVALID, findReplace.findWhat);
			if (pbSuccess != NULL)
				*pbSuccess = FALSE;
			return;
		}
	}
	
	BOOL bFound = DoFind();

	if (pbSuccess != NULL)
		*pbSuccess = bFound;
}

BOOL CPartView::DoFind()
{
	BOOL bFound = FindString(&findReplace);

	if(!bFound && !findReplace.loop) // If we are searching through all documents
	{								// then open the next view and search it
		// get a pointer to the main frame
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

		DWORD dwNextWin = findReplace.goUp ? GW_HWNDPREV : GW_HWNDNEXT;
		DWORD dwFirstWin = findReplace.goUp ? GW_HWNDLAST : GW_HWNDFIRST;
		CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
		CPartFrame* pMDIChild = pMDIActiveChild;
		while( TRUE )
		{
			pMDIChild = (CPartFrame *)pMDIChild->GetWindow(dwNextWin);
			if(pMDIChild == NULL) // we got to the end of the list
				pMDIChild = (CPartFrame *)pMDIActiveChild->GetWindow(dwFirstWin);

			if(pMDIChild == pMDIActiveChild) // we completed the loop
				break;

			if(!IsValidMDICycleMember(pMDIChild))
				continue;

			CPartView *pView = (CPartView *)pMDIChild->GetActiveView();
			ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
			ASSERT(pView != this); // we should never see the active view in this loop
			DWORD dwFlags, dwFlags2;
			if(!GetFindReplaceFlags(&dwFlags, &dwFlags2) || (dwFlags & FDS_SEARCHALL) == 0)
				continue;	// the view does not support this type of search

			findReplace.startFromCursor = FALSE;
			bFound = pView->FindString(&findReplace);
			findReplace.startFromCursor = TRUE;
			if(bFound)
			{
				CDockWorker::LockWorker(FALSE);
				CDockWorker::s_pActiveDocker = NULL;
				theApp.SetActiveView(pView->m_hWnd);

				InvalidateRect(0); // test

				if(!findReplace.goUp) // move previous window to the bottom of
								// the list, only if we're going down
					pMDIActiveChild->SetWindowPos(&wndBottom, 0,0,0,0, 
						SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

				break;	// exits the while loop.
			}
		}
		if(!bFound) // If not found if other views, look in initial view
		{
			findReplace.loop = TRUE;
			bFound = FindString(&findReplace);
			findReplace.loop = FALSE;
		}
	}

	if(!bFound)
	{
		CString str;
		if(findReplace.regExpr)
			MsgText(str, IDS_REG_EXPR_NOT_FOUND, findReplace.findWhat);
		else
			MsgText(str, IDS_STRING_NOT_FOUND, findReplace.findWhat);
		MsgBox(Error, str);
	}

	return bFound;
}


void CPartView::OnEditFind()
{
	DWORD dwFlags, dwFlags2;
	if(!GetFindReplaceFlags(&dwFlags, &dwFlags2))
		dwFlags = FDS_WHOLEWORD | FDS_MATCHCASE | FDS_REGEXP;  // default value

	CFindStringDlg dlg(dwFlags, theApp.m_pMainWnd);
	CString str;
	if(GetFindString(str))
		dlg.m_strFindString = str;
	dlg.DoModal();
}

void CPartView::OnEditFindNext()
{
	// If we don't have the input focus, then a find control might have it.
	// We have to grab the focus since the find control's  WM_KILLFOCUS handler
	// puts its current text into <findReplace.findWhat>.
  if (GetFocus() != this)
		SetFocus();

	findReplace.goUp = FALSE;
	if(findReplace.findWhat[0]!='\0')  // if the search string is not empty
		OnFindNext();
}

void CPartView::OnEditFindPrev()
{
	// If we don't have the input focus, then a find control might have it.
	// We have to grab the focus since the find control's  WM_KILLFOCUS handler
	// puts its current text into <findReplace.findWhat>.
	if (GetFocus() != this)
		SetFocus();

	findReplace.goUp = TRUE;
	if(findReplace.findWhat[0]!='\0')  // if the search string is not empty
		OnFindNext();
}

void CPartView::OnToggleSearchAllDocs(void)
{
	// note: findReplace.loop has the opposite semantics of search all docs
	findReplace.loop = !findReplace.loop;

	// Have two separate messages to ease translation:
	SetPrompt(findReplace.loop ? STA_SearchAllDocsOff : STA_SearchAllDocsOn);
}

void CPartView::OnToggleFindCase(void)
{
	findReplace.matchCase = !findReplace.matchCase;

	// Have two separate messages to ease translation:
//	StatusText(findReplace.matchCase ? STA_MatchCaseOn : STA_MatchCaseOff, STATUS_INFOTEXT, FALSE);
	SetPrompt(findReplace.matchCase ? STA_MatchCaseOn : STA_MatchCaseOff);
}

void CPartView::OnToggleFindRE(void)
{
	findReplace.regExpr = !findReplace.regExpr;

	// Have two separate messages to ease translation:
//	StatusText(findReplace.regExpr ? STA_MatchREOn : STA_MatchREOff, STATUS_INFOTEXT, FALSE);
	SetPrompt(findReplace.regExpr ? STA_MatchREOn : STA_MatchREOff);
}

void CPartView::OnToggleFindWord(void)
{
	findReplace.wholeWord = !findReplace.wholeWord;

	// Have two separate messages to ease translation:
//	StatusText(findReplace.wholeWord ? STA_MatchWordOn : STA_MatchWordOff, STATUS_INFOTEXT, FALSE);
	SetPrompt(findReplace.wholeWord ? STA_MatchWordOn : STA_MatchWordOff);
}

void CPartView::OnUpdateFindReplace(CCmdUI* pCmdUI)
{
	DWORD dwFlags, dwFlags2;
	if(!GetFindReplaceFlags(&dwFlags, &dwFlags2) || dwFlags == 0)
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
}

void CPartView::OnUpdateToggleMatchCase(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(findReplace.matchCase);
	OnUpdateFindReplace(pCmdUI);
}

void CPartView::OnUpdateToggleMatchWord(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(findReplace.wholeWord);
	OnUpdateFindReplace(pCmdUI);
}

void CPartView::OnUpdateToggleMatchRegEx(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(findReplace.regExpr);
	OnUpdateFindReplace(pCmdUI);
}

void CPartView::OnUpdateToggleSearchAllDocs(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(!findReplace.loop); // 'loop' has opposite semantics
	OnUpdateFindReplace(pCmdUI);
}

BOOL CPartView::FindString(FINDREPLACEDISK *pfr)
{
	return FALSE;
}
BOOL CPartView::ReplaceString(FINDREPLACEDISK *pfr, BOOL bReplaceAll)
{
	return FALSE;
}
BOOL CPartView::GetFindSelectionRect(CRect* prc)
{
	return FALSE;
}
BOOL CPartView::GetFindString(CString& rstr)
{
	return FALSE;
}
BOOL CPartView::GetFindReplaceFlags(DWORD *pdwFlagsFind, DWORD *pdwFlagsReplace)
{
	return FALSE;
}
BOOL CPartView::MarkAll(FINDREPLACEDISK *pfr)
{
	return FALSE;
}

BOOL CPartView::GetSelectionInterface(GUID* pguid, IUnknown** piUnk)
{
	return FALSE;
}

UINT NEAR WM_VIEWACTIVATE = RegisterMessage("ViewActivate");

void CPartView::OnActivateView(BOOL bActivate, CView* pActivateView, 
	CView* pDeactiveView)
{
	if (CPartFrame::IsWorkspaceLocked())
		return;

	SendMessage(WM_VIEWACTIVATE, (WPARAM)bActivate, 
		(LPARAM)(bActivate ? pDeactiveView : pActivateView));

	if (bActivate)
		ShowSprites();
	else
		HideSprites();

	if (!bActivate || UsesIME())
		theIME.EnableIME( TRUE );
	else
		theIME.EnableIME( FALSE );

	CSlobWnd::OnActivateView(bActivate, pActivateView, pDeactiveView);

	// try to activate the wizard bar

	LPWIZARDBAR pWBIFace =	g_IdeInterface.GetWizBarIFace();  // released on package exit

	if (pWBIFace != NULL)
	{
		HRESULT hr;

		hr = pWBIFace->FExistWizBar();
		if (hr == S_OK)
			pWBIFace->ActivateWizBar(bActivate); 
	}
}


BOOL CPartView::PreTranslateMessage(MSG* pMsg)
{
	if (CSlobWnd::PreTranslateMessage(pMsg))
		return TRUE;

	CKeymap* pKeymap = GetKeymap();
	if (pKeymap != NULL)
	{
		if (pKeymap->TranslateMessage(GetParentFrame(), pMsg))
			return TRUE;
	}

	return FALSE;
}

void CPartView::RecalculateIME()
{
	// Override to position the IME after the mainfrm is moved or sized
}

#ifndef NO_VBA

// GetSelectionObject -- select the specified Range (if present); then return an object
//		(currently also a Range) representing the current section.
LPDISPATCH
CPartView::GetSelectionObject(LPDISPATCH pdisp)
{
	return NULL;	// generic version does nothing; overrides do all the work
}

#endif	// NO_VBA

/////////////////////////////////////////////////////////////////////////////
// CDockablePartView


CDockablePartView::CDockablePartView()
{
}

CDockablePartView::~CDockablePartView()
{
}


BEGIN_MESSAGE_MAP(CDockablePartView, CPartView)
	//{{AFX_MSG_MAP(CDockablePartView)
	ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
	ON_UPDATE_COMMAND_UI(ID_FILE_CLOSE, OnUpdateFileClose)
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CDockablePartView diagnostics

#ifdef _DEBUG
void CDockablePartView::AssertValid() const
{
	CPartView::AssertValid();
}

void CDockablePartView::Dump(CDumpContext& dc) const
{
	CPartView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDockablePartView message handlers

void CDockablePartView::OnFileClose() 
{
	CFrameWnd* pFrame = GetParentFrame();
	if (pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
		pFrame->SendMessage(WM_CLOSE);		
}

void CDockablePartView::OnUpdateFileClose(CCmdUI* pCmdUI) 
{
	CFrameWnd* pFrame = GetParentFrame();
	pCmdUI->Enable(pFrame != NULL &&
		pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildDock)));
}

//      CDockablePartView::OnMouseActivate
//              The CView implementation of this function will cause asserts
//              as well as set the CMDIFrameWnd::m_pViewActive member, so we
//              need to override back to normal window behavior.

int CDockablePartView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message) 
{
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}



static BOOL IsSeparator(LPCTSTR lpchWord, LPCTSTR lpchBorder);

BOOL FindInString( FINDREPLACEDISK *pfr, const char *szBuf,
		BOOL backwardsSearch, const char **pszStart, ULONG *pcbSize)
{
	int ichCur;
	char cLower = (char)_totlower(pfr->findWhat[0]);
	char cUpper = (char)_totupper(cLower);
	int cbFind = _tcslen(pfr->findWhat);
	int cbBuf = _tcslen(szBuf);
	BOOL fFound = FALSE;
	BOOL fWasEverFound = FALSE; // Is used for backwards searches.

  if (pszStart && *pszStart)
	{
		ichCur = (*pszStart) - szBuf;
	}
	else
		ichCur = 0;

	while(ichCur <= cbBuf) // DevStd #295: can be non-null, since BOL/EOL are valid search targets
	{
		int ichStart = ichCur;
		int ichEnd = cbBuf;

		if(pfr->regExpr)
		{
			fFound = RESearch(szBuf, (ULONG *)&ichStart, (ULONG *)&ichEnd,
								pfr->pat, pfr->findWhat, &(pfr->bWasLineMatch));
			if(fFound)
				ichCur = ichStart + _tclen (szBuf + ichStart); // Increments our cursor
		}
		else
		{
			fFound = FALSE;
			while( ichCur <= cbBuf - cbFind )
			{
				const char *pch;
				do
				{
					if((cLower == *(szBuf + ichCur)) || (cUpper == *(szBuf + ichCur)))
					{
						ichStart = ichCur;
						break;
					}
					ichCur += _tclen (szBuf + ichCur);	// Increments the cursor
				} while(ichCur <= cbBuf - cbFind );

				if( ichCur > cbBuf - cbFind ) // we did not find a match
					break;

				ichEnd = ichStart + cbFind;
				ichCur = ichStart + _tclen (szBuf + ichStart);	// Increments the cursor
				if(pfr->matchCase)
				{
					if( _tcsncmp(szBuf + ichStart, pfr->findWhat, cbFind) != 0 )
						continue;
				}
				else
				{
					if( _tcsnicmp(szBuf + ichStart, pfr->findWhat, cbFind) != 0 )
						continue;
				}
				fFound = TRUE;
				break;
			}

		}

		// if we've found a match, now make sure it's a standalone word
		if(fFound && pfr->wholeWord)
		{
			if( ((ichStart != 0) && 
				!IsSeparator(szBuf + ichStart, 
				_ftcsdec(szBuf, szBuf + ichStart))) ||		// character before
				((ichEnd < cbBuf) && 
				!IsSeparator (_ftcsdec(szBuf, szBuf + ichEnd),
				szBuf + ichEnd ) ))	// character after
			{
				fFound = FALSE;
				continue;
			}
		}

		if (fFound)
		{
			fWasEverFound = TRUE;
			if(pszStart != NULL)
				*pszStart = szBuf + ichStart;
			if(pcbSize != NULL)
				*pcbSize = ichEnd - ichStart;
			if(!backwardsSearch)	// If we're going down, we're finished
			{						// otherwize, carry on the search till the end
				break;				// to find the last occurence
			}
				
		}
		else break; // Not found
	}

	return fWasEverFound;
}


/*
**	FUNCTION:	IsSeparator
**
**	PURPOSE:	Given a character (either at the beginning or end of a "word")
**				and the character that borders it, determines if the border
**				character sufficiently defines a separator for the word.
**
**	NOTES:		The following rules are applied:
**
**			1.  If the border character is alphanumeric, then it
**			is only a valid separator if the word character is a DBC character.
**/
//To test if a character belong to the C/Pascal Alphanumeric set
#define CHARINALPHASET(c) (IsCharAlphaNumeric(c) || c == '_')

static BOOL IsSeparator (LPCTSTR lpchWord, LPCTSTR lpchBorder)
{
	if (CHARINALPHASET(*lpchBorder))
		{
		if (theApp.m_fOEM_MBCS)
			{
			if ((_ftclen(lpchWord) > 1 ) ||
					_ismbbkana(*(unsigned char *)lpchWord))
				return TRUE;
			else
				return FALSE;
			}
		else
			return FALSE;
		}
	else
		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\prodinfo.cpp ===
// prodinfo.cpp - Product ID 
//
// Modified from ACME sources for use in Microsoft Developer 4.0
// July 6, 1995 [PaulDe]
//
// - Add HMODULE parameter to support PIDs in multiple DLLs.
// - Correct resource load code according to Win32 docs/standards
// - Cleanup resource
// - Add debug TRACE (Check macro, etc.)
// - Hide ACME behind CProductInfo class
//
/////////////////////////////////////////////////////////////

// original header >>>>
///***************************************************************************
//**
//**	File:		SETUPINI.C
//**	Purpose:	Tool to validate and generate ACME Copy Disincentive files
//**	Notes:      Intended for use outside of ACME, therefore this file
//**	            duplicates some size defines in CPYDIS.H, must keep in sync!
//**
//****************************************************************************/
//
//#pragma warning(disable:4514)/* unreferenced inline function has been removed */
//#pragma warning(disable:4201)/* nonstandard extension: nameless struct/union */
//#pragma warning(disable:4214)/* nonstandard extension: bit field types other than int */
//#pragma warning(disable:4209)/* nonstandard extension: benign typdef redefinition */
//#pragma warning(disable:4115)/* named type definition in parentheses */
//#include <windows.h>         /* produces warnings at warning level /W4 */
//#pragma warning(default:4201)
//#pragma warning(default:4214)
//#pragma warning(default:4209)
//#pragma warning(default:4115)
//<<<<

#include "stdafx.h"

typedef char *	        SZ;
//typedef UINT	CB;

//#include <stdio.h>  /* printf() */
//#include <stdlib.h> /* exit() */
//#include <string.h> /* strchr() */
//#include <time.h>		/* time_t, time */

#define cbCDDate        10  /* YYYY-MM-DD */
#define cbCDUserNameMax 52
#define cbCDOrgNameMax  52
#define cbRawPID        20  /* ASCII DIGITS (and "OEM") */
#define cbFormattedPID  23  /* RPCNO-LOC-SERIALX-SEQNC */
#define cchpSetupIni   149  /* exact size of SETUP.INI */
#define cbCDHeader      15  /* size of SETUP.INI header bytes */
#define cbCDEncrypt    128  /* encrypted byte count in SETUP.INI */

SZ szGarbage  = "LtRrBceHabCT AhlenN";

#define Check( fcond, szMsg ) \
if( !(fcond) )\
	{\
		TRACE0(szMsg);\
		FreeResource((HGLOBAL)rgchBuf);\
		return FALSE;\
	} else

/***************************************************************************/
BOOLEAN ACMEDecrypt ( HMODULE hMod, UINT ResType, UINT ResNum,
		      char *szName, char *szOrg, char *szPid )
{
	BYTE   *rgchBuf;
	CHAR   pchTmp[cchpSetupIni];
	USHORT wYear;
	USHORT wMonth;
	USHORT wDay;
	BYTE   ch;
	CHAR*  pchCur;
	SZ     szGarbageCur;
	INT    cchName, cchOrg, i, j;
	INT    chksumName, chksumOrg, chksumNameNew, chksumOrgNew;
	HRSRC hrsc;

	/** FILE READ **/
	hrsc = FindResource( hMod, MAKEINTRESOURCE(ResNum), MAKEINTRESOURCE(ResType) );
	if (hrsc == NULL) goto Cant;

	rgchBuf = (BYTE *)LoadResource( hMod, hrsc );
	if( rgchBuf == NULL )
	{
Cant:	TRACE("PID:Can't load resource (Module=0x%Lx Type=0x%Lx Id=0x%Lx)\n", (ULONG)hMod, (ULONG)ResType, (ULONG)ResNum );
		return FALSE;
	}

	/** PID **/
	Check(rgchBuf[cchpSetupIni-1] == '\0' && lstrlen((SZ)rgchBuf + cbCDEncrypt) == cbRawPID, 
		"PID:Invalid PID length\n");
	lstrcpy(szPid, (SZ)rgchBuf + cbCDEncrypt);
	if (szPid[5] != '-' && szPid[17] != ' ')
		{
		szPid[5]  = '-';
   	lstrcpy(szPid+6,  (SZ)rgchBuf + cbCDEncrypt + 5);
		szPid[9]  = '-';
   	lstrcpy(szPid+10, (SZ)rgchBuf + cbCDEncrypt + 8);
		szPid[17] = '-';
   	lstrcpy(szPid+18, (SZ)rgchBuf + cbCDEncrypt + 15);
		}

	for (pchCur = szPid + 8 + 2, i=0, j=7; j-- != 0; pchCur++)
		i += (*pchCur == 'x' ? 0 : *pchCur - '0');
	Check(i % 7 == 0, "Invalid serial number check digit");

	/** DECRYPTION **/
	for (i = j = cbCDEncrypt-1; i >= 0; j = (j + 17) & 0x7F)
		pchTmp[i--] = (CHAR)rgchBuf[j];
	for (i = cbCDEncrypt-2; i-- > 0;)
		pchTmp[i + 1] = (CHAR)(pchTmp[i] ^ pchTmp[i + 1]);

	/** USERNAME **/
	pchCur = pchTmp + cbCDHeader;
	cchName = ((*(pchTmp + 2) - 'e') << 4) + (*(pchTmp + 1) - 'e');
	Check(cchName != 0 && cchName <= cbCDUserNameMax, "PID:Invalid user name length\n");
	for (i = 0, chksumNameNew = 0; i < cchName; i++)
		if ((ch = szName[i] = *pchCur++) < ' ')
			Check(1, "PID:Invalid character in user name\n");
		else
			chksumNameNew += ch;
	szName[i] = '\0';

	chksumName = ((*(pchTmp + 6) - 'e') << 4) + (*(pchTmp + 5) - 'e');
	Check(chksumName == (chksumNameNew & 0x0FF), "PID:Invalid user name checksum\n");

	/** COMPANYNAME **/
	cchOrg = ((*(pchTmp + 4) - 'e') << 4) + (*(pchTmp + 3) - 'e');
	Check(cchOrg != 0 && cchOrg <= cbCDOrgNameMax, "PID:Invalid company name length\n");
	for (i = 0, chksumOrgNew = 0; i < cchOrg; i++)
		if ((ch = szOrg[i] = *pchCur++) < ' ')
			Check(1, "PID:Invalid character in company name\n");
		else
			chksumOrgNew += ch;
	szOrg[i] = '\0';

	chksumOrg = ((*(pchTmp + 8) - 'e') << 4) + (*(pchTmp + 7) - 'e');
	Check(chksumOrg == (chksumOrgNew & 0x0FF), "PID:Invalid company name checksum\n");

	/** VALIDATE FILLER **/
	szGarbageCur = szGarbage;
	while (pchCur < pchTmp + cbCDEncrypt-1)
		{
		if (*szGarbageCur == '\0')
			szGarbageCur = szGarbage;
		Check(*pchCur++ == *szGarbageCur++, "PID:Invalid filler character\n");
		}
	Check(*pchCur == '\0', "PID:Encryption not null terminated\n");

	/** DATE **/
	if (pchTmp[9] == (CHAR)0xFF && pchTmp[10] == (CHAR)0xFF)
		;
	else
		{
		wDay = (USHORT)(((*(pchTmp + 10) - 'e') << 4) + (*(pchTmp + 9) - 'e'));
		Check(wDay >= 1 && wDay <= 31, "PID:Invalid day in date\n");
		wMonth = (USHORT)(*(pchTmp + 11) - 'e');
		Check(wMonth >= 1 && wMonth <= 12, "PID:Invalid month in date\n");
		wYear = (USHORT)((((*(pchTmp + 14) - 'e') & 0x0F) << 8) +
				  (((*(pchTmp + 13) - 'e') & 0x0F) << 4) +
				  (*(pchTmp + 12) - 'e'));
		Check(wYear >= 1900 && wYear <= 4096, "PID:Invalid year in date\n");
		}

	FreeResource((HGLOBAL)rgchBuf);
	return TRUE;
}


/////////////////////////////////////////////////////////////
// class CProductInfo

BOOL CProductInfo::Create(HMODULE hModule, UINT nId, UINT nType)
{
	if (!m_bValid)
		m_bValid =  ACMEDecrypt( hModule, nType, nId, m_szUser, m_szOrg, m_szPID );
	return m_bValid;
}

BOOL CProductInfo::CopyInfo(LPTSTR szPID, LPTSTR szUserName, LPTSTR szOrganization) const
{
	if (m_bValid)
	{
		if (szPID) _tcscpy(szPID,m_szPID);
		if (szUserName) _tcscpy(szUserName,m_szUser);
		if (szOrganization) _tcscpy(szOrganization,m_szOrg);
	}
	return m_bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\profile.cpp ===
#include "stdafx.h"

#include "tools.h"
#include "shell.h"
#include "find.h"
#include "toolexpt.h"

BOOL GetRegIntCore(UINT & nValue, HKEY hkey, LPCSTR szSection, LPCSTR szKey, UINT nDefault);
BOOL GetRegDataCore(HGLOBAL & hglobRet, HKEY hkey, LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobDefault = NULL);
LONG GetRegStringCore(LPSTR szRet, DWORD & nSize, DWORD & nType, HKEY hkey, LPCSTR szSection, LPCSTR szKey);

BOOL WriteRegDataCore(HKEY hkey, LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobValue);

IMPLEMENT_DYNAMIC(CInitFile, CMemFile);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//	Reg DB stuff

// BASED_CODE definitions for the profile string values
// I don't think INI files are ever localized... (bc)

// [General] section...
//
static char BASED_CODE szGeneral[] = "General";
static char BASED_CODE szSetup[] = "Setup";
static char BASED_CODE szMainWndPos[] = "AppWindow";
static char BASED_CODE szMainWndSize[] = "AppWindowSize";
static char BASED_CODE szPropPagePos[] = "PropertiesWindow";
static char BASED_CODE szMaxApp[] = "MaximizeApp";
static char BASED_CODE szMaxDoc[] = "MaximizeDoc";
static char BASED_CODE szToolTips[] = "ToolTips";
static char BASED_CODE szToolTipKeys[] = "ToolTipKeys";
static char BASED_CODE szLargeToolBars[] = "LargeToolBars";
static char BASED_CODE szWindowMenuItems[] = "WindowMenuItems";
static char BASED_CODE szWindowMenuSorted[] = "WindowMenuSorted";
static char BASED_CODE szPushPin[] = "PropertiesPushPin";
static char BASED_CODE szFileSection[] = "Recent File List";
static char BASED_CODE szProjectCount[] = "ProjectCount";
static char BASED_CODE szProjectEntry[] = "Project%d";
static char BASED_CODE szFileCount[] = "FileCount";
static char BASED_CODE szFileMnemonics[] = "FileMnemonics";
static char BASED_CODE szFileEntry[] = "File%d";
static char BASED_CODE szFileRTCEntry[] = "TypeInfo%d";
static char BASED_CODE szWorkspaceAuto[] = "WorkspaceAuto";
static char BASED_CODE szWindowsMenu[] = "TraditionalMenu";
static char BASED_CODE szMRUOnFile[] = "MRUListsOnFileMenu";
#ifndef NO_VBA
static char BASED_CODE szOleAutomation[] = "SupportOleAutomation";
#endif	// NO_VBA


static char BASED_CODE szPinGoToDlg[] = "PinGoToDlg";
static char BASED_CODE szDlgEdDblClickEditCode[] = "DlgEdDblClickEditCode";

#ifdef ENABLE_FILE_AUTOSAVES
static char BASED_CODE szAutosaveEnabled[] = "AutosaveEnabled";
static char BASED_CODE szAutosaveInterval[] = "AutosaveInterval";
#endif	// ENABLE_FILE_AUTOSAVES

char BASED_CODE szSearch[] = "Search";
char BASED_CODE szSearchFind[] = "Find%d";
char BASED_CODE szSearchReplace[] = "Replace%d";


// General purpose strings...
//
char BASED_CODE szEmpty[] = "";
static char BASED_CODE szCoordFmt[] = "%d,%d";
static char BASED_CODE szColorFmt[] = "%u,%u,%u";

// Stolen from afx.h before they were removed...
//
#define _countof(array)	(sizeof(array)/sizeof(array[0]))

// MBS <-> WCS conversion with truncation
#define _wcstombsz(lpszDest, lpszSrc, nMaxBytes) \
	wcstombs(lpszDest, lpszSrc, nMaxBytes), lpszDest[nMaxBytes-1] = 0

LPSTR GetRegistryKeyName()
{
	ASSERT(theApp.m_pszRegKeyName != NULL);
	return (char*) theApp.m_pszRegKeyName;
}

static BOOL ParseCoord(const char* szCoord, int* px, int* py)
{
	int n;
	const char* pch = szCoord;
	char* pch2 = (char*)pch;

	n = (int)_tcstol(pch, &pch2, 10);
	if (pch2 == pch)
		return FALSE;
	*px = n;
	pch = pch2;

	if (*pch == ',')
		pch += 1;

	pch2 = (char*)pch;
	n = (int)_tcstol(pch, &pch2, 10);
	if (pch2 == pch)
		return FALSE;
	*py = n;

	return TRUE;
}

BOOL ParseRect(const char* szRect, CRect& rect)
{
	int n;
	const char* pch = szRect;
	char* pch2 = (char*)pch;

	n = (int)_tcstol(pch, &pch2, 10);
	if (pch2 == pch)
		return FALSE;
	rect.left = n;
	pch = pch2;

	if (*pch == ',')
		pch += 1;

	pch2 = (char*)pch;
	n = (int)_tcstol(pch, &pch2, 10);
	if (pch2 == pch)
		return FALSE;
	rect.top = n;
	pch = pch2;

	if (*pch == ',')
		pch += 1;

	pch2 = (char*)pch;
	n = (int)_tcstol(pch, &pch2, 10);
	if (pch2 == pch)
		return FALSE;
	rect.right = n;
	pch = pch2;

	if (*pch == ',')
		pch += 1;

	pch2 = (char*)pch;
	n = (int)_tcstol(pch, &pch2, 10);
	if (pch2 == pch)
		return FALSE;
	rect.bottom = n;

	return TRUE;
}

BOOL GetRegRect(const char* szSection, const char* szEntry, CRect& rect)
{
	return ParseRect(GetRegString(szSection, szEntry), rect);
}

void WriteRegRect(const char* szSection, const char* szEntry, const CRect& rect)
{
	char szBuf [64];
	sprintf(szBuf, "%d,%d,%d,%d", rect.left, rect.top, rect.right, rect.bottom);
	WriteRegString(szSection, szEntry, szBuf);
}

//
// Read a profile string consisting of two numbers separated by a space
// or comma and use it as a position for a window.  The size of the
// window is passed in so this function can adjust the position if
// necessary to keep the window visible on the screen.  If the function
// is successful, TRUE is returned and rect contains a window rectangle.
// Otherwise, FALSE is returned and rect is unmodified.
//
static BOOL GetProfileWndPos(const char* szSection, const char* szEntry,
	CRect& rect, const CSize& size)
{
	CString str = GetRegString(szSection, szEntry);

	if (str.IsEmpty())
		return FALSE;

	CPoint topLeft;
	if (!ParseCoord(str, (int*)&topLeft.x, (int*)&topLeft.y))
		return FALSE;

	rect = CRect(topLeft, size);
	ForceRectOnScreen(rect);

	return TRUE;
}


static void WriteWndProfile(const char* szSection, const char* szEntry,
	CWnd* pWnd)
{
	CRect rect;
	char szBuf [20];

	ASSERT(pWnd != NULL);
	ASSERT(pWnd->m_hWnd != NULL);

	pWnd->GetWindowRect(&rect);
	sprintf(szBuf, szCoordFmt, rect.top, rect.left);
	WriteRegString(szSection, szEntry, szBuf);
}


static void ReadWndProfile(const char* szSection, const char* szEntry,
	CWnd* pWnd)
{
	CRect rect;
	pWnd->GetWindowRect(&rect);
	if (GetProfileWndPos(szSection, szEntry, rect, rect.Size()))
		pWnd->MoveWindow(&rect);
}

#ifdef _WIN32
void CTheApp::SavePrivateAutosaveSettings()
{
	// save autosave state and autosave interval [patbr]
#ifdef ENABLE_FILE_AUTOSAVES
	WriteRegInt(szGeneral, szAutosaveEnabled,  gAutosaver.IsEnabled());
	WriteRegInt(szGeneral, szAutosaveInterval, gAutosaver.GetInterval());
#endif	// ENABLE_FILE_AUTOSAVES
}
#endif

void CTheApp::SavePrivateProfileSettings()
{
	char szBuf [32];
	CRect rect;

	if(((CMainFrame*) m_pMainWnd)->m_lastWindowRect != CFrameWnd::rectDefault)
	{
		// Save the last non-min/max main window position/size
		CPoint pt = ((CMainFrame*) m_pMainWnd)->m_lastWindowRect.TopLeft();
		sprintf(szBuf, szCoordFmt, pt.x, pt.y);
		WriteRegString(szGeneral, szMainWndPos, szBuf );

		CSize size = ((CMainFrame*) m_pMainWnd)->m_lastWindowRect.Size();
		ASSERT(size.cx>0 || size.cy>0);  // Should never have negative sizes
		sprintf(szBuf, szCoordFmt, size.cx, size.cy);
		WriteRegString(szGeneral, szMainWndSize, szBuf );
	}

	// Save the position of the property page
	GetPropertyBrowser()->GetWindowRect(&rect);

	int x = GetSystemMetrics(SM_CXSCREEN);
	int y = GetSystemMetrics(SM_CYSCREEN);
	x = (rect.left < x - rect.right) ? rect.left : rect.right;
	y = (rect.top < y - rect.bottom) ? rect.top : rect.bottom;

	sprintf(szBuf, szCoordFmt, x, y);
	WriteRegString(szGeneral, szPropPagePos, szBuf );

	WriteRegInt(szGeneral, szMaxApp, m_bMaximizeApp);
	WriteRegInt(szGeneral, szMaxDoc, m_bMaximizeDoc);
	WriteRegInt(szGeneral, szToolTips, m_bToolTips);
	WriteRegInt(szGeneral, szToolTipKeys, m_bToolTipKeys);
	WriteRegInt(szGeneral, szLargeToolBars, m_bLargeToolBars);
	WriteRegInt(szGeneral, szWorkspaceAuto, m_bWorkspaceAuto);
	WriteRegInt(szGeneral, szWindowMenuItems, m_nWindowMenuItems);
	WriteRegInt(szGeneral, szWindowMenuSorted, m_bWindowMenuSorted);
	WriteRegInt(szGeneral, szMRUOnFile, m_bMRUOnFileMenu);
	WriteRegInt(szGeneral, szWindowsMenu, !Menu::IsInCmdBarMode());

	BOOL bPopProp;
	m_theAppSlob.GetIntProp(P_PoppingProperties, bPopProp);
	WriteRegInt(szGeneral, szPushPin, !bPopProp);

	WriteRegInt(szGeneral, szPinGoToDlg, m_bPinGoToDlg);
	WriteRegInt(szGeneral, szDlgEdDblClickEditCode, m_bDlgEdDblClickEditCode);

	// Save the command tools setting
	SaveToolListSetting() ;

	// Write the MRU section from scratch.
	CString strKeyMain = GetRegistryKeyName();
	RegDeleteKey(HKEY_CURRENT_USER, strKeyMain + chKeySep + szFileSection);

	if (m_pRecentProjectList != NULL)
	{
		m_pRecentProjectList->WriteList();	// Deletes contents of key!
		WriteRegInt(szFileSection, szProjectCount, m_pRecentProjectList->GetSize());
	}
	if (m_pRecentFileList != NULL)
	{
		m_pRecentFileList->WriteList();
		WriteRegInt(szFileSection, szFileCount, m_pRecentFileList->GetSize());
	}

	SavePrivateAutosaveSettings();
	SaveLastProject();
	SaveFindReplaceStrings();

	POSITION pos = m_packages.GetHeadPosition();
	while (pos != NULL)
		((CPackage*)m_packages.GetNext(pos))->SaveSettings();
}

/****************************************************************************

	FUNCTION:	SaveFindReplaceStrings

****************************************************************************/

void
SaveFindReplaceStrings()
{
	ShellPickList().SaveToRegistry();
}


#ifdef _WIN32
void CTheApp::LoadPrivateAutosaveSettings()
{
	// restore autosave state and autosave interval [patbr]
#ifdef ENABLE_FILE_AUTOSAVES
	int fAutosaveEnabled  = GetProfileInt(szGeneral, szAutosaveEnabled,  FALSE);
	int iAutosaveInterval = GetProfileInt(szGeneral, szAutosaveInterval, 15);

	if (fAutosaveEnabled)
		VERIFY(gAutosaver.Enable(iAutosaveInterval));
	else
		gAutosaver.Disable();
#endif	// ENABLE_FILE_AUTOSAVES
}
#endif

void CTheApp::LoadPrivateProfileSettings()
{
	m_bFirstInstance = (GetProfileString(NULL, szSetup, "") == "1");
	if (m_bFirstInstance)
		WriteProfileString("", szSetup, "0");

	m_bMaximizeApp = GetProfileInt(szGeneral, szMaxApp, TRUE);
	m_bMaximizeDoc = GetProfileInt(szGeneral, szMaxDoc, FALSE);
	m_bToolTips = GetProfileInt(szGeneral, szToolTips, TRUE);
	m_bToolTipKeys = GetProfileInt(szGeneral, szToolTipKeys, TRUE);
	m_bLargeToolBars = GetProfileInt(szGeneral, szLargeToolBars, FALSE);
	m_nWindowMenuItems = GetProfileInt(szGeneral, szWindowMenuItems, 10); 
	m_bWindowMenuSorted = GetProfileInt(szGeneral, szWindowMenuSorted, TRUE); 
	m_bMRUOnFileMenu = GetProfileInt(szGeneral, szMRUOnFile, FALSE); 
	m_bWorkspaceAuto = GetProfileInt(szGeneral, szWorkspaceAuto, TRUE);

	BOOL bPushPin = GetProfileInt(szGeneral, szPushPin, FALSE);
	m_theAppSlob.SetIntProp(P_PoppingProperties, !bPushPin);

	if (!(m_bInvokedCommandLine && m_bRunInvisibly)) // REVIEW
	{

	m_bPinGoToDlg = GetProfileInt(szGeneral, szPinGoToDlg, TRUE);
	m_bDlgEdDblClickEditCode = GetProfileInt(szGeneral, szDlgEdDblClickEditCode, TRUE); 


		LoadFindReplaceStrings();

	// BLOCK: get the size and position for the main window
	{
		CSize size;
		CString str = GetRegString(szGeneral, szMainWndSize);
		if (!ParseCoord(str, (int*)&size.cx, (int*)&size.cy))
			size = CFrameWnd::rectDefault.Size();

		((CMainFrame*) m_pMainWnd)->m_lastWindowRect.BottomRight() =
			((CMainFrame*) m_pMainWnd)->m_lastWindowRect.TopLeft() + size;

		GetProfileWndPos(szGeneral, szMainWndPos,
			((CMainFrame*) m_pMainWnd)->m_lastWindowRect,
			((CMainFrame*) m_pMainWnd)->m_lastWindowRect.Size());
	}

	// BLOCK: get position of the property page
	{
		CPoint pt;
		CString str = GetRegString(szGeneral, szPropPagePos);
		if (!ParseCoord(str, (int*)&m_ptPropPage.x, (int*)&m_ptPropPage.y))
			m_ptPropPage = CPoint(CSheetWnd::xDefaultPos, CSheetWnd::yDefaultPos);
	}

	// We need to determing if the user wants HMENU or CmdBars. HMENUS are used by 
	// disabled users. To allow them to get at the trad UI without having to use the
	// non-trad UI, we support a cmdline switch as well as the registry.
	BOOL bOldMenu = ScanCommandLine("WindowsMenu");	
	if (!bOldMenu)
	{
		// Ask windows if there's a screen reader in place
		BOOL bScreenReader=FALSE;
		BOOL bFoundScreenReader=SystemParametersInfo(SPI_GETSCREENREADER, 0, &bScreenReader, FALSE);
		// only notice this setting if windows supports this SPI value
		bScreenReader&=bFoundScreenReader;

		// If the command line and registry aren't specified, then the default is taken from SPI_GETSCREENREADER
		// The command line wasn't specified, so look in the registry
		bOldMenu = GetProfileInt(szGeneral, szWindowsMenu, bScreenReader);
	}

	// Set the flag indicating which the user perfers.
	Menu::UseHMENU(bOldMenu) ;
	} // cmdline
}

//	CTheApp::LoadMRUList
//		Call this after the packages are loaded, or loading the
//		runtime classes may fail.

void CTheApp::LoadMRUList()
{
	// Load the file MRU
	UINT nStart = 0;
	UINT nCount = GetProfileInt(szFileSection, szFileCount, _AFX_MRU_COUNT);
	nCount = min(nCount,  ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1);

	if (nCount > 0)
	{
		// create file MRU since nMaxMRU not zero
		m_pRecentFileList = new CTypedRecentFileList(nStart, szFileSection,
			szFileEntry, szFileRTCEntry, nCount);
		m_pRecentFileList->ReadList();

		nStart = nCount;	// Next menu starts where this left off.
	}

	// Load the project MRU
	nCount = GetProfileInt(szFileSection, szProjectCount, _AFX_MRU_COUNT);
	nCount = min(nCount, ID_PROJ_MRU_LAST - ID_PROJ_MRU_FIRST + 1);

	if (nCount > 0)
	{
		// Needs to be a CBRecentFileList so that it gets the correct UpdateMenu function.
		m_pRecentProjectList = new CBRecentFileList(nStart, szFileSection,
			szProjectEntry, nCount);
		m_pRecentProjectList->ReadList();
	}

	CalculateRecentMnemonics();
}

// Given the size of the lists, work out how many mnemonics should be given to each.
void CTheApp::CalculateRecentMnemonics()
{
	CBRecentFileList *pRecentFile=(CBRecentFileList*)m_pRecentFileList;
	CBRecentFileList *pRecentProject=(CBRecentFileList*)m_pRecentProjectList;

	if(theApp.m_bMRUOnFileMenu)
	{
		int nFileShortStart = GetProfileInt(szFileSection, szFileMnemonics, -1);

		if(nFileShortStart<=0)
		{
			// Now update the shortcut start values for each list
			ASSERT(m_pRecentFileList);
			ASSERT(m_pRecentProjectList);

			int nFiles=m_pRecentFileList->GetSize();
			int nProjects=m_pRecentProjectList->GetSize();
			int nEntries=nFiles+nProjects;
			int nFileShorts=-1;
			int nProjectShorts=-1;

			// If both can fit inside 10, do that.
			if(nEntries<=10)
			{
				nFileShorts=nFiles;
				nProjectShorts=nProjects;
			}
			else
			{
				// otherwise, split proportionately
				nFileShorts=10.0*(double)nFiles/(double)nEntries;
				nProjectShorts=10-nProjectShorts;
			}

			pRecentFile->SetShortCount(nFileShorts);
			pRecentProject->SetShortCount(nProjectShorts);
			pRecentProject->SetStart(nFileShorts);
		}
		else
		{
			// user expressed a preference, so use that.
			int nFileShortCount=min(10, nFileShortStart);
			pRecentFile->SetShortCount(nFileShortCount);
			pRecentProject->SetShortCount(10-nFileShortCount);
			pRecentProject->SetStart(nFileShortCount);
		}
	}
	else
	{
		pRecentFile->SetShortCount(10);
		pRecentFile->SetStart(0);
		pRecentProject->SetShortCount(10);
		pRecentProject->SetStart(0);
	}
}

/****************************************************************************

	FUNCTION:	LoadFindReplaceStrings

****************************************************************************/

void
LoadFindReplaceStrings()
{
	ShellPickList().LoadFromRegistry(&findReplace);
}


#define MAX_REG_STR 4096
CString GetRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szDefault)
{
	return theApp.GetProfileString(szSection, szKey, szDefault);
}

/*
//
// Sometimes we have to know whether or not the value was there
//
BOOL FGetRegString (LPCSTR szSection, LPCSTR szKey, CString& strReturn)
{
#ifdef _WIN32
	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	HKEY hSectionKey = NULL;
	RegOpenKeyEx(HKEY_CURRENT_USER, strKey, 0, KEY_READ, &hSectionKey);

	DWORD nSize = 0;
	DWORD nType = REG_NONE;
	if (hSectionKey == NULL || RegQueryValueEx(hSectionKey, (char*) szKey, NULL,
			&nType, NULL, &nSize) != ERROR_SUCCESS || nSize == 0)
	{
		return FALSE;
	}
	else
	{
		ASSERT(nType == REG_SZ);
		unsigned char * sz = (unsigned char *)malloc (nSize);

		if (RegQueryValueEx(hSectionKey, (char*) szKey, NULL,
				&nType, sz, &nSize) != ERROR_SUCCESS)
		{
			free (sz);
			return FALSE;
		}
		else
		{
			strReturn = sz;
			free (sz);
		}
	}

	if (hSectionKey != NULL)
		RegCloseKey(hSectionKey);

	return TRUE;
#else
	strReturn = GetRegString (szSection, szKey, "");
	return TRUE;
#endif
}
*/

UINT GetRegInt(LPCSTR szSection, LPCSTR szKey, int nDefault)
{
	return theApp.GetProfileInt(szSection, szKey, nDefault);
}

UINT CTheApp::GetProfileInt(LPCTSTR szSection, LPCTSTR szKey, int nDefault)
{
	UINT nValue;
	if (!GetRegIntCore(nValue, HKEY_CURRENT_USER, szSection, szKey, (UINT)nDefault))
		GetRegIntCore(nValue, HKEY_LOCAL_MACHINE, szSection, szKey, (UINT)nDefault);
	return nValue;
}

CString CTheApp::GetProfileString( LPCTSTR szSection, LPCTSTR szKey, LPCTSTR szDefault /* = NULL*/)
{
	char sz[MAX_REG_STR];
	sz[0] = 0;
	DWORD nType = REG_SZ;
	DWORD nSize = MAX_REG_STR;
	if (ERROR_SUCCESS != GetRegStringCore(sz, nSize, nType, HKEY_CURRENT_USER, szSection, szKey))
	{
		nType = REG_SZ;
		nSize = MAX_REG_STR;
		if (ERROR_SUCCESS != GetRegStringCore(sz, nSize, nType, HKEY_LOCAL_MACHINE, szSection, szKey))
			return szDefault ? szDefault : _TEXT("");
	}
	return sz;
}

BOOL GetRegIntCore(UINT & nValue, HKEY hkey, LPCSTR szSection, LPCSTR szKey, UINT nDefault)
{
	BOOL bRet = TRUE; // optimism
	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	HKEY hSectionKey = NULL;
	RegOpenKeyEx(hkey, strKey, 0, KEY_READ, &hSectionKey);

	DWORD nSize = sizeof UINT;
	DWORD nType = REG_NONE;
	if (hSectionKey == NULL || RegQueryValueEx(hSectionKey, (LPTSTR) szKey, NULL,
			&nType, (LPBYTE)&nValue, &nSize) != ERROR_SUCCESS || nSize == 0)
	{
		// copy the default value
		nValue = nDefault;
		bRet = FALSE;
	}
	else
	{
		ASSERT(nType == REG_DWORD);
	}

	if (hSectionKey != NULL)
    	RegCloseKey(hSectionKey);

	return bRet;
}

BOOL GetRegDataCore(HGLOBAL & hglobRet, HKEY hkey, LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobDefault)
{
	BOOL bRet = TRUE; // optimism
	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	HKEY hSectionKey = NULL;
	RegOpenKeyEx(hkey, strKey, 0, KEY_READ, &hSectionKey);

	LPBYTE lpData;
	DWORD nSize = 0;
	DWORD nType = REG_NONE;
	if (hSectionKey == NULL || RegQueryValueEx(hSectionKey, (LPTSTR)szKey, NULL,
			&nType, NULL, &nSize) != ERROR_SUCCESS || nSize == 0)
	{
		// copy the default value
		hglobRet = hglobDefault;
		bRet = FALSE;
	}
	else
	{
		ASSERT(nType == REG_BINARY);
		hglobRet = ::GlobalAlloc(GMEM_MOVEABLE, nSize);
		lpData = (LPBYTE) ::GlobalLock(hglobRet);

		if (RegQueryValueEx(hSectionKey, (LPTSTR)szKey, NULL,
				&nType, lpData, &nSize) != ERROR_SUCCESS)
		{
			::GlobalUnlock(hglobRet);
			::GlobalFree(hglobRet);
			hglobRet = hglobDefault;
			bRet = FALSE;
		}
		else
		{
			::GlobalUnlock(hglobRet);
		}
	}

	if (hSectionKey != NULL)
		RegCloseKey(hSectionKey);

	return bRet;
}

LONG GetRegStringCore( LPSTR szRet, DWORD & nSize, DWORD & nType, HKEY hkey, LPCSTR szSection, LPCSTR szKey)
{
	LONG lRet;
	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	HKEY hSectionKey = NULL;
	lRet = RegOpenKeyEx(hkey, strKey, 0, KEY_READ, &hSectionKey);
	if (hSectionKey != NULL)
		lRet = RegQueryValueEx(hSectionKey, (LPTSTR)szKey, NULL, &nType, (LPBYTE)szRet, &nSize);

	if (hSectionKey != NULL)
    	RegCloseKey(hSectionKey);

	return lRet;
}

static IStream *GetRegIStreamCore(HKEY hKey, LPCTSTR szSection, LPCTSTR szKey)
{
	IStream *pIStreamResult = NULL;

	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	HKEY hSectionKey = NULL;
	RegOpenKeyEx(hKey, strKey, 0, KEY_READ, &hSectionKey);

	LPBYTE lpData;
	DWORD nSize = 0;
	DWORD nType = REG_NONE;
	if ((hSectionKey != NULL) &&
		(RegQueryValueEx(hSectionKey, szKey, NULL, &nType, NULL, &nSize) == ERROR_SUCCESS) &&
		(nSize != 0))
	{
		ASSERT(nType == REG_BINARY);
		HGLOBAL hGlobal = ::GlobalAlloc(GMEM_MOVEABLE, nSize);
		lpData = (LPBYTE) ::GlobalLock(hGlobal);

		if (::RegQueryValueEx(hSectionKey, szKey, NULL, &nType, lpData, &nSize) != ERROR_SUCCESS)
		{
			::GlobalUnlock(hGlobal);
			::GlobalFree(hGlobal);
		}
		else
		{
			::GlobalUnlock(hGlobal);

			HRESULT hr = CreateStreamOnHGlobal(hGlobal, TRUE, &pIStreamResult);

			if (FAILED(hr))
				::GlobalFree(hGlobal);
		}
	}

	if (hSectionKey != NULL)
		RegCloseKey(hSectionKey);

	return pIStreamResult;
}

IStream *GetRegIStream(LPCTSTR szSection, LPCTSTR szKey)
{
	IStream *pIStreamResult = GetRegIStreamCore(HKEY_CURRENT_USER, szSection, szKey);
	if (pIStreamResult == NULL)
		pIStreamResult = GetRegIStreamCore(HKEY_LOCAL_MACHINE, szSection, szKey);
	return pIStreamResult;
}

HGLOBAL GetRegData(LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobDefault)
{
	HGLOBAL hglob = NULL; 
	if (!GetRegDataCore(hglob, HKEY_CURRENT_USER, szSection, szKey, hglobDefault))
		GetRegDataCore(hglob, HKEY_LOCAL_MACHINE, szSection, szKey, hglobDefault);
	return hglob;
}

BOOL WriteRegString(LPCTSTR szSection, LPCTSTR szKey, LPCTSTR szVal)
{
	return theApp.WriteProfileString(szSection, szKey, szVal);
}

BOOL WriteRegInt(LPCSTR szSection, LPCSTR szKey, int nValue)
{
	return theApp.WriteProfileInt(szSection, szKey, nValue);
}

BOOL WriteRegData(LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobValue)
{
	return WriteRegDataCore(HKEY_CURRENT_USER, szSection, szKey, hglobValue);
}

BOOL WriteRegDataCore(HKEY hkey, LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobValue)
{
#ifdef _WIN32
	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	DWORD dwDisp;
	HKEY hSectionKey = NULL;
	RegCreateKeyEx(hkey, strKey, 0, "", REG_OPTION_NON_VOLATILE,
		KEY_WRITE, NULL, &hSectionKey, &dwDisp);

	long lResult;

	if (hglobValue == NULL)
	{
		lResult = RegDeleteValue(hSectionKey, (char*) szKey);
	}
	else
	{
		LPBYTE lpData = (LPBYTE) ::GlobalLock(hglobValue);
		WORD* pwSize = (WORD*) lpData;
		int nSize = *pwSize + sizeof(WORD);	// First word is data size.
		ASSERT(nSize > 0);	// Hey! no data.

		lResult = RegSetValueEx(hSectionKey, (char*) szKey, NULL,
			REG_BINARY,	lpData, nSize);
		::GlobalUnlock(hglobValue);
	}

	RegCloseKey(hSectionKey);

	return (lResult == ERROR_SUCCESS);
#else
	return TRUE;	// Do nothing.
#endif
}

BOOL DeleteRegData(LPCSTR szSection, LPCSTR szKey)
{
	return WriteRegDataCore(HKEY_CURRENT_USER, szSection, szKey, NULL);
}

static BOOL WriteRegIStreamCore(HKEY hkey, LPCTSTR szSection, LPCTSTR szKey, IStream *pIStream)
{
#ifdef _WIN32
	CString strKey = GetRegistryKeyName();
	if (szSection != NULL)
		strKey = strKey + chKeySep + szSection;

	DWORD dwDisp;
	HKEY hSectionKey = NULL;
	RegCreateKeyEx(hkey, strKey, 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSectionKey, &dwDisp);

	long lResult;

	if (pIStream == NULL)
	{
		lResult = RegDeleteValue(hSectionKey, (char*) szKey);
	}
	else
	{
		HGLOBAL hGlobal = NULL;
		lResult = ::GetHGlobalFromStream(pIStream, &hGlobal);

		// If you get this assert, it's probably because you didn't create
		// the stream with CreateStreamOnHGlobal().  While we might be able
		// to do cooler stuff w.r.t. copying non-HGLOBAL streams, it doesn't
		// seem worth it at this moment.  -mgrier 6/19/96
		ASSERT(SUCCEEDED(lResult));

		LPBYTE lpData = (LPBYTE) ::GlobalLock(hGlobal);

		ULARGE_INTEGER cbStream;

		LARGE_INTEGER li;
		li.QuadPart = 0;
		// See where the end pointer is...
		pIStream->Seek(li, STREAM_SEEK_END, &cbStream);

		// No streams larger than 2^32 bytes for us!!!
		ASSERT(cbStream.HighPart == 0);
		lResult = RegSetValueEx(hSectionKey, szKey, NULL, REG_BINARY, lpData, cbStream.LowPart);
		::GlobalUnlock(hGlobal);
	}

	RegCloseKey(hSectionKey);

	return (lResult == ERROR_SUCCESS);
#else
	return TRUE;	// Do nothing.
#endif
}

BOOL WriteRegIStream(LPCTSTR szSection, LPCTSTR szKey, IStream *pIStream)
{
	return WriteRegIStreamCore(HKEY_CURRENT_USER, szSection, szKey, pIStream);
}

///////////////////////////////////////////////////////////////////////////////
//	Control Panel Registry stuff

CCPLReg::CCPLReg()
{
	m_bEnglishMeasure = TRUE;
	m_strDecimal = _TEXT(".");

	// Get pointers to the date/time formatting functions in kernel32.dll

	m_hKernel = LoadLibrary("KERNEL32.DLL");
	ASSERT(m_hKernel);

	m_lpfnGetTimeFormatW = (int (FAR WINAPI *)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int))GetProcAddress(m_hKernel, "GetTimeFormatW");
	m_lpfnGetTimeFormatA = (int (FAR WINAPI *)(LCID, DWORD, CONST SYSTEMTIME *, LPCSTR, LPSTR, int))GetProcAddress(m_hKernel, "GetTimeFormatA");

	m_lpfnGetDateFormatW = (int (FAR WINAPI *)(LCID, DWORD, CONST SYSTEMTIME *, LPCWSTR, LPWSTR, int))GetProcAddress(m_hKernel, "GetDateFormatW");
	m_lpfnGetDateFormatA = (int (FAR WINAPI *)(LCID, DWORD, CONST SYSTEMTIME *, LPCSTR, LPSTR, int))GetProcAddress(m_hKernel, "GetDateFormatA");

	// Read the registry entries - it's ok to do this now,
	// as these entries should always exist!
	Update();
}

CCPLReg::~CCPLReg()
{
	if (m_hKernel)
		FreeLibrary(m_hKernel);
}

const CString CCPLReg::Format(CTime& time, FORMAT_TYPE fType, DWORD dwFlags /*= DATE_SHORTDATE*/)
{
	CString strResult;

	// The time functions will crash past Jan 19, 2038 since GetLocalTm() will return NULL
	// and things like GetYear() dereference it unconditionaly.  Prevent that from happening
	// here and just return an empty string in the future...
	if (time.GetLocalTm(NULL) == NULL)
		return strResult;

	// Convert the time to a SYSTEMTIME structure that the os
	// date/time formatting functions use

	SYSTEMTIME TempTime;
	TempTime.wYear = (WORD)time.GetYear();
	TempTime.wMonth = (WORD)time.GetMonth();
	TempTime.wDayOfWeek = (WORD)time.GetDayOfWeek();
	TempTime.wDay = (WORD)time.GetDay();
	TempTime.wHour = (WORD)time.GetHour();
	TempTime.wMinute = (WORD)time.GetMinute();
	TempTime.wSecond = (WORD)time.GetSecond();
	TempTime.wMilliseconds = 0;

	// Do the formatting

	TCHAR *pch = strResult.GetBuffer(_MAX_PATH);
	switch (fType)
	{
		case TIME_ALL:
		case TIME_NO_SECONDS:
			{
  				DWORD timeflags = 0;

				if (fType == TIME_NO_SECONDS)
					timeflags = TIME_NOSECONDS;

				// If we have GetTimeFormatA then use it,
				// otherwise we must use GetTimeFormatW and
				// do a wide char to multi byte conversion.

				if (m_lpfnGetTimeFormatA)
				{
					(*(m_lpfnGetTimeFormatA))(GetUserDefaultLCID(), timeflags, &TempTime, NULL, pch, _MAX_PATH);
				}
				else
				{
					WCHAR szTemp[_MAX_PATH];

					(*(m_lpfnGetTimeFormatW))(GetUserDefaultLCID(), timeflags, &TempTime, NULL, szTemp, _countof(szTemp));
					_wcstombsz(pch, szTemp, _countof(szTemp));
				}
				break;
			}

		case DATE_ALL:
			{
				// If we have GetDateFormatA then use it,
				// otherwise we must use GetDateFormatW and
				// do a wide char to multi byte conversion.

 				if (m_lpfnGetDateFormatA)
				{
					(*(m_lpfnGetDateFormatA))(GetUserDefaultLCID(), dwFlags, &TempTime, NULL, pch, _MAX_PATH);
				}
				else
				{
					WCHAR szTemp[_MAX_PATH];

					(*(m_lpfnGetDateFormatW))(GetUserDefaultLCID(), dwFlags, &TempTime, NULL, szTemp, _countof(szTemp));
					_wcstombsz(pch, szTemp, _countof(szTemp));
				}
				break;

			}

		default:
			ASSERT(FALSE);
	}

	// Release the buffer and return the formatted string
	strResult.ReleaseBuffer();
 	return strResult;
}

void CCPLReg::Update()
{

	// Numbers
	m_bEnglishMeasure = (GetCPLInt(LOCALE_IMEASURE, m_bEnglishMeasure) == 1);
	m_strDecimal = GetCPLString (LOCALE_SDECIMAL, m_strDecimal);
}

CString CCPLReg::GetCPLString(LCTYPE lcType, LPCSTR szDefault)
{
	WCHAR szTemp[255];
	char szTempmb[255];
	LPCTSTR szRet;
	HINSTANCE hKernel;
	int (FAR WINAPI *lpfnGetLocaleInfoA)(LCID, LCTYPE, LPSTR, int);
	int (FAR WINAPI *lpfnGetLocaleInfoW)(LCID, LCTYPE, LPWSTR, int);

	hKernel = LoadLibrary( "KERNEL32.DLL" );
	ASSERT(hKernel);

	lpfnGetLocaleInfoA = (int (FAR WINAPI *)(LCID, LCTYPE, LPSTR, int))GetProcAddress(hKernel, "GetLocaleInfoA");
	lpfnGetLocaleInfoW = (int (FAR WINAPI *)(LCID, LCTYPE, LPWSTR, int))GetProcAddress(hKernel, "GetLocaleInfoW");

	// If we have GetLocaleInfoA then use it. The only o.s. which doesn't
	// have this is NT 511, so we just protect ourselves here by making
	// sure that we don't die even on NT 511 since we will just use
	// GetLocaleInfoW and do the multibyte conversion ourselves.
	if (lpfnGetLocaleInfoA)
	{
		if ((*(lpfnGetLocaleInfoA))(GetUserDefaultLCID(), lcType, szTempmb, sizeof(szTempmb)) != 0)
			szRet = szTempmb;
		else
			szRet = szDefault;
	}
	else
	{
		if ((*(lpfnGetLocaleInfoW))(GetUserDefaultLCID(), lcType, szTemp, _countof(szTemp)) != 0)
		{
			// GetLocaleInfoA not available on all platforms so we convert

			_wcstombsz(szTempmb, szTemp, _countof(szTempmb));
			szRet = szTempmb;
		}
		else
			szRet = szDefault;
	}

	if (hKernel)
		FreeLibrary(hKernel);

	return szRet;
}

UINT CCPLReg::GetCPLInt(LCTYPE lcType, int nDefault)
{
	CString strRegEntry;
	UINT nInt = nDefault;

	strRegEntry = GetCPLString(lcType, "DEFAULT");
	if (strRegEntry.Compare("DEFAULT") != 0)
	{
		const TCHAR* pch = strRegEntry;
		nInt = _ttoi(pch);
	}

	return nInt;
}

///////////////////////////////////////////////////////////////////////////////
//	Project saving stuff

static char BASED_CODE szLastProject[] = "LastProject";
extern BOOL g_bReloadProject;

BOOL CTheApp::LoadLastProject()
{
	BOOL bRet = FALSE;

	CString strPath;
	
	if (g_bReloadProject)
		strPath = GetRegString(szWorkspaceSection, szLastProject);

	if (!strPath.IsEmpty())
	{
		CDocTemplate* pTemplate = GetTemplate(CLSID_WorkspaceDocument);
		if (pTemplate != NULL)
		{
			theApp.m_bOpenedFromLastLoad = TRUE;
			bRet = (pTemplate->OpenDocumentFile(strPath) != NULL);
			theApp.m_bOpenedFromLastLoad = FALSE;
		}
	}

	// Make sure next instance does not just open the same project.
	CString strKeyMain = GetRegistryKeyName();
	RegDeleteKey(HKEY_CURRENT_USER, strKeyMain + chKeySep + szWorkspaceSection);

	return bRet;
}

BOOL CTheApp::SaveLastProject()
{
	CString strPath;

	IProjectWorkspace *lpWorkspaceWnd;
	lpWorkspaceWnd = g_IdeInterface.GetProjectWorkspace();
	if (lpWorkspaceWnd != NULL)
	{
		LPCSTR pszPath;
		VERIFY(SUCCEEDED(lpWorkspaceWnd->GetWorkspaceDocPathName(&pszPath)));

		CPath path;
		path.Create(pszPath);
		strPath = path.GetFullPath();
	}
	WriteRegString(szWorkspaceSection, szLastProject, strPath);

	return TRUE;
}

BOOL CTheApp::SerializeAllWorkspaceSettings(const CPath *pPath, DWORD dwFlags, BOOL bSave)
{
	// reset global file error
	SetFileError(CFileException::none);
	BOOL fRet = TRUE;

	if (bSave && m_bInvokedCommandLine)
	{
		return TRUE;	// must never touch .opt for cmd line build
	}			// because not all packages are loaded

	CStateSaver stateSave(bSave);
	CStateSaver *pSS = &stateSave;

	BOOL bConvert =	((pPath != NULL) && (!_tcsicmp(pPath->GetExtension(), ".mdp") || !_tcsicmp(pPath->GetExtension(), ".vcp")));

	if (pPath != NULL)
	{
		if (bConvert && !bSave)
		{
			ASSERT(!bSave);
			fRet = pSS->OpenMSF(*pPath, TRUE);
		}
		else
		{
			fRet = pSS->OpenStorage(*pPath);
		}
	}

	if (bSave || ((dwFlags & OPT_WORKSPACE_ONLY) != 0))
	{
		IProjectWorkspace *lpWorkspaceWnd;
		lpWorkspaceWnd = g_IdeInterface.GetProjectWorkspace();
		if (lpWorkspaceWnd != NULL)
		VERIFY(SUCCEEDED(lpWorkspaceWnd->SerializeWorkspaceState(pSS)));
		// ignore errors
	}

	if ((dwFlags & (OPT_DOCUMENTS_ONLY|OPT_WORKSPACE_ONLY)) == 0)
	{
		POSITION pos = m_packages.GetHeadPosition();
		while (pos != NULL)
		{
			CPackage* pPackage = (CPackage*)m_packages.GetNext(pos);
			if ((pPackage->m_flags & PKS_SERIALIZE) != 0)
			{
				TRY
				{
					// if we are loading from an old-style (binary) MDP file 
					// then give packages an opportunity to convert settings
					if (bConvert)
						pPackage->SerializeWkspcConvSettings(*pSS, dwFlags);
					else
						pPackage->SerializeWorkspaceSettings(*pSS, dwFlags);
				}
				CATCH_ALL(e)
				{
					// One of the packages blew its exception handling.  Catch the
					// exception here but continue the loop so that other packages
					// can serialize their settings.
					ASSERT(FALSE);
				}
				END_CATCH_ALL
			}
		}
	}

	// VShell OPT serializing.  Documents loaded alone, at end of project load.
	if ((bSave || ((dwFlags & OPT_DOCUMENTS_ONLY) != 0)) &&
		(!theApp.m_bInvokedCommandLine)) // optimize for cmdline bld
	{
		BOOL success;
		success = ((CMainFrame *)theApp.m_pMainWnd)->SerializeWorkspaceLayout(*pSS);
		if (!success && GetFileError())
			fRet = FALSE;
	}
	else if (GetFileError())
		fRet = FALSE;

	if ((pPath != NULL) && (bSave || !bConvert))
		pSS->CloseStorage();

	// Finish is only interesting for a save, and will happen in the CStateSaver
	// destructor if not done here.  Also, if we are loading, then we may have
	// gotten the CStateSaver from the project.
	if (bSave && !pSS->Finish())
		fRet = FALSE;

	// reset global file error
	SetFileError(CFileException::none);

	return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//	CInitFile
//

CInitFile::CInitFile() : CMemFile()
{
	m_type = dataNil;
	m_bWrite = FALSE;

	m_pmsf = NULL;
	m_sn = 0;

	m_lpszSection = NULL;
	m_lpszKey = NULL;

	m_hglobUserMem = NULL;
	m_lpStream = NULL;
}

CInitFile::~CInitFile()
{
	// Do this here, since the v-table will not get to our code
	// from CMemFile.
	if (m_lpBuffer)
		Close();
	ASSERT(m_lpBuffer == NULL);
}

BOOL CInitFile::Open(LPCSTR szSection, LPCSTR szKey, UINT nOpenFlags,
	INIT_DATATYPE type /*=dataReg*/)
{
	ASSERT(nOpenFlags == modeRead || nOpenFlags == modeWrite);
	ASSERT(type == dataReg || type == dataResource);
	ASSERT(type == dataReg || nOpenFlags != modeWrite);	// No writing to resource.

	m_type = type;
	m_bWrite = (nOpenFlags == modeWrite);

	m_lpszSection = szSection;
	m_lpszKey = szKey;

	if (!m_bWrite)
		return LoadFromSource();

	return TRUE;
}

DWORD LimitHash(const char *str)
{
	//a standard hash function
	const char *sz;
	DWORD val = 0, g;
	for(sz = str; *sz != '\0'; sz++){
		val = (val << 4) + (*sz);
		if (g = val&0xf000000) {
			val = val ^ (g >> 24);
			val = val ^ g;
		}
	}
	return val;
}

BOOL CInitFile::Open(LPSTORAGE pStorage, CString strStream, UINT nOpenFlags)
{
	USES_CONVERSION;

	ASSERT(pStorage != NULL);
	ASSERT(nOpenFlags == modeRead || nOpenFlags == modeWrite);

	m_type = dataStorage;
	m_strStream = strStream;

	int nLength = m_strStream.GetLength();
	if (nLength > 31)
	{
		// OLE stream name length limit is 32 chars, so if the stream name requested
		// is longer than this limit, truncate the name and append name length to get
		// a "unique" stream name.
		// REVIEW [patbr]: it is possible to get a non-unique stream name if the stream
		// names requested are identical through 28 chars and of the same length.

		// SteveJS: changed length to result of a hash function to provide a better chance of a unique id
		// - also lowered limit to 31 char's as OpenStream and CreateStream seem to 
		// fail if the NULL is not within 32 chars.
		CString strLength;
		strLength.Format("%X", LimitHash(m_strStream));
		m_strStream = m_strStream.Left(31-strLength.GetLength());
		m_strStream += strLength;
	}

	HRESULT hr;
	if (nOpenFlags == modeRead)
		hr = pStorage->OpenStream(T2W(m_strStream), 0, STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &m_lpStream);
	else
		hr = pStorage->CreateStream(T2W(m_strStream), STGM_DIRECT | STGM_WRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_lpStream);
	if (FAILED(hr) || (m_lpStream == NULL))
		return FALSE;

	m_bWrite = (nOpenFlags == modeWrite);

	if (!m_bWrite)
		return LoadFromSource();

	return TRUE;
}

BOOL CInitFile::Open(MSF *pmsf, WORD sn, UINT nOpenFlags)
{
	ASSERT(pmsf != NULL);
	ASSERT(nOpenFlags == modeRead || nOpenFlags == modeWrite);

	m_type = dataMSF;
	m_bWrite = (nOpenFlags == modeWrite);

	m_pmsf = pmsf;
	m_sn = sn;

	if (!m_bWrite)
		return LoadFromSource();

	return TRUE;
}

// Using this function gives delete responsibility for the data to
// the file.
void CInitFile::SetBuffer(HGLOBAL hglob, UINT nCountBytes /*=-1*/,
	INIT_DATATYPE type /*=dataReg*/)
{
	ASSERT(m_nFileSize + m_nBufferSize == 0 && m_lpBuffer == NULL);
	ASSERT(m_type == type || m_type == dataNil);

	if (type == dataResource)
		m_lpBuffer = (BYTE FAR*) ::LockResource(hglob);
	else
		m_lpBuffer = (BYTE FAR*) ::GlobalLock(hglob);

	if (nCountBytes == -1)
	{
		ASSERT(type == dataReg);

		WORD FAR* lpw = (WORD FAR*) m_lpBuffer;
		nCountBytes = (UINT) *lpw + sizeof(WORD);
		ASSERT(nCountBytes != 0);
	}

	m_type = type;
	m_hglobUserMem = hglob;
	m_nFileSize = nCountBytes;
	m_nBufferSize = nCountBytes;

	if (type == dataReg)
		Seek(sizeof(WORD), begin);
}

HGLOBAL CInitFile::GetInitData()
{
	ASSERT(m_hglobUserMem == NULL);	// User already has this. Close.

	// This is equivalent to a write, so turn off the write flag
	// to keep the file from writing when we close.
	m_bWrite = FALSE;

	HGLOBAL hglob = ::GlobalAlloc(GMEM_MOVEABLE, m_nFileSize + sizeof(WORD));
	WORD FAR* lpw = (WORD FAR*) ::GlobalLock(hglob);
	*lpw++ = (WORD) m_nFileSize;
	Memcpy((BYTE FAR*)lpw, m_lpBuffer, m_nFileSize);
	::GlobalUnlock(hglob);

	return hglob;
}

void CInitFile::Close()
{
	if (m_bWrite && !WriteToDest())
		AfxThrowFileException(CFileException::generic);

	Abort();
}

void CInitFile::Abort()
{
	if (m_hglobUserMem != NULL)
	{
		if (m_type != dataResource)
		{
			::GlobalUnlock(m_hglobUserMem);
			::GlobalFree(m_hglobUserMem);
		}
		else
		{
#ifndef _WIN32
			::UnlockResource(m_hglobUserMem);
#endif
			::FreeResource(m_hglobUserMem);
		}

		m_hglobUserMem = NULL;
		m_lpBuffer = NULL;
		m_nBufferSize = 0;
		m_nFileSize = 0;
	}

	if (m_type == dataStorage)
	{
		ASSERT(m_lpStream != NULL);
		m_lpStream->Release();
		m_lpStream = NULL;
	}

	m_type = dataNil;
	m_bWrite = FALSE;
	m_pmsf = NULL;
	m_sn = 0;
	m_lpszSection = NULL;
	m_lpszKey = NULL;

	CMemFile::Close();
}

#define LARGEINT2DOUBLE(x) ((double)((x).HighPart) * 4.294967296E9 + (double)((x).LowPart))

BOOL CInitFile::LoadFromSource()
{
	ASSERT (!m_bWrite);

	switch (m_type)
	{
		case dataMSF:
			//BLOCK:
			{
				CB cb = MSFGetCbStream(m_pmsf, m_sn);
				if ( cb != -1 )
				{
					SetLength((DWORD) cb);
					ASSERT(m_lpBuffer);

					if (MSFReadStream(m_pmsf, m_sn, m_lpBuffer, cb))
						return TRUE;
				}
			}
			break;

		case dataReg:
			//BLOCK:
			{
				HGLOBAL hglob = GetRegData(m_lpszSection, m_lpszKey, NULL);

				if (hglob != NULL)
				{
					WORD FAR* lpw = (WORD FAR*) ::GlobalLock(hglob);
					UINT nSize = (UINT) *lpw;
					ASSERT(nSize != 0);
					::GlobalUnlock(hglob);

					SetBuffer(hglob, nSize + sizeof(WORD));
					Seek(sizeof(WORD), CFile::begin);

					return TRUE;
				}
			}
			break;

		case dataResource:
			//BLOCK:
			{
				// Try to make a resource based file.
				HINSTANCE hinst = AfxFindResourceHandle(m_lpszKey, m_lpszSection);
				if (hinst != NULL)
				{
					HRSRC hrsrc = ::FindResource(hinst, m_lpszKey, m_lpszSection);
					if (hrsrc != NULL)
					{
						HGLOBAL hglob;
						UINT nSize = (UINT)	::SizeofResource(hinst, hrsrc);

						if (nSize != 0 &&
							(hglob = ::LoadResource(hinst, hrsrc)) != NULL)
						{
							SetBuffer(hglob, nSize, m_type);
							return TRUE;
						}
					}
				}
			}
			break;

		case dataStorage:
			//BLOCK:
			{
				STATSTG statstg;
				m_lpStream->Stat(&statstg, STATFLAG_DEFAULT);
				ULONG cb = (ULONG)LARGEINT2DOUBLE(statstg.cbSize);
				SetLength((DWORD)cb);
				ASSERT(m_lpBuffer);

				if (SUCCEEDED(m_lpStream->Read(m_lpBuffer, m_nBufferSize, &cb)))
				{
					ASSERT(m_nBufferSize == cb);
					return TRUE;
				}
			}
			break;

		default:
			return TRUE;
	}


	Abort();
	return FALSE;
}

BOOL CInitFile::WriteToDest()
{
	// Bail if no buffer or in read mode:
	if (!m_bWrite || m_lpBuffer == NULL)
		return TRUE;

	// Set mode to read, which will prevent another Flush during
	// destruction and possible recursion if an error occurs.
	m_bWrite = FALSE;

	switch (m_type)
	{
		case dataMSF:
			return MSFWriteStream(m_pmsf, m_sn, m_lpBuffer, m_nBufferSize);

		case dataReg:
			//BLOCK:
			{
				// Write the archive data preceded by a byte count to an hglob.
				HGLOBAL hglob = GetInitData();
				WriteRegData(m_lpszSection, m_lpszKey, hglob);
				::GlobalFree(hglob);
			}
			break;

		case dataStorage:
			//BLOCK:
			{
				DWORD dwWritten;
				HRESULT hr;
				hr = m_lpStream->Write(m_lpBuffer, m_nBufferSize, &dwWritten);
				if (SUCCEEDED(hr))
				{
					ASSERT(m_nBufferSize == dwWritten);
				}
				return(SUCCEEDED(hr));
			}
	}

	return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// CInitFile diagonstics

#ifdef _DEBUG
void CInitFile::AssertValid() const
{
	// don't call CMemFile::AssertValid as it doesn't know about r/o memory.
	CFile::AssertValid();

	ASSERT((m_lpBuffer == NULL && m_nBufferSize == 0) ||
		AfxIsValidAddress(m_lpBuffer, (UINT)m_nBufferSize, m_bWrite));
	ASSERT(m_nFileSize <= m_nBufferSize);
	// m_nPosition might be after the end of file, so we cannot ASSERT
	// its validity
}
#endif // _DEBUG

///////////////////////////////////////////////////////////////////////////////
//	CStateSaver
//

CStateSaver::CStateSaver(BOOL bSaving)
{
	m_bSaving = bSaving;
	m_pMSF = NULL;
	m_pSaver = NULL;
	m_lpStorage = NULL;
}

CStateSaver::~CStateSaver()
{
	if (m_pMSF != NULL)
		MSFClose(m_pMSF);

	if (m_pSaver != NULL)
		delete m_pSaver;
}

BOOL CStateSaver::OpenFile(CInitFile& fileInit, SN nStream,
	LPCSTR szSection, LPCSTR szKey)
{
	ASSERT(!m_bSaving);

	UINT nMode = CFile::modeRead;

	if (m_pMSF != NULL)
		return fileInit.Open(m_pMSF, nStream, nMode);
	else if (szSection != NULL || szKey != NULL)
		return fileInit.Open(szSection, szKey, nMode);

	return FALSE;
}

//	CStateSaver::Finish()
//		Always returns true if not saving.
BOOL CStateSaver::Finish()
{
	if (m_bSaving && m_pSaver != NULL)
		return m_pSaver->Finish();

    m_strFileName.Empty();

	return TRUE;
}

BOOL CStateSaver::OpenMSF(LPCTSTR szFilePath, BOOL bForceWriteable)
{
	ASSERT(m_pMSF == NULL);

	// Start from scratch when saving.
	if (m_bSaving)
	{
		if (m_pSaver != NULL)
			delete m_pSaver;

		m_pSaver = new CFileSaver(szFilePath);

		if (!m_pSaver->CanSave())
		{
			if (bForceWriteable)
			{
				if (!m_pSaver->MakeWriteable())
				{
					SetFileError(ferrCantSaveReadOnly);
					return FALSE;
				}
			}
			else
			{
				SetFileError(ferrCantSaveReadOnly);
				return FALSE;
			}
		}

		szFilePath = m_pSaver->GetSafeName();
	}

	m_pMSF = MSFOpen((LPTSTR) szFilePath, m_bSaving);
    m_strFileName = szFilePath;
	return(m_pMSF != NULL);
}

BOOL CStateSaver::OpenStorage(LPCTSTR szFilePath)
{
	USES_CONVERSION;

	// Start from scratch when saving.
	if (m_bSaving)
	{
		if (m_pSaver != NULL)
			delete m_pSaver;
		m_pSaver = new CFileSaver(szFilePath);

		if (!m_pSaver->CanSave() && !m_pSaver->MakeWriteable())
		{
			SetFileError(ferrCantSaveReadOnly);
			return FALSE;
		}
		szFilePath = m_pSaver->GetSafeName();
	}

	HRESULT hr;
	if (m_bSaving)
		hr = ::StgCreateDocfile(T2W(szFilePath), STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, 0, &m_lpStorage);
	else
		hr = ::StgOpenStorage(T2W(szFilePath), NULL, STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_lpStorage);
	return((SUCCEEDED(hr)) && (m_lpStorage != NULL));
}

BOOL CStateSaver::OpenStream(CInitFile& fileInit, CString strStream)
{
	UINT nMode = (m_bSaving ? CFile::modeWrite : CFile::modeRead);

	if (m_lpStorage != NULL)
		return(fileInit.Open(m_lpStorage, strStream, nMode));

	return FALSE;
}

void CStateSaver::CloseStorage()
{
	if (m_lpStorage != NULL)
		m_lpStorage->Release();
	m_lpStorage = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\propbag.cpp ===
#include "stdafx.h"
#include "slob.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////
void CPropBag::Empty () 
{
	WORD w; CProp* pProp;
	POSITION pos = m_props.GetStartPosition ();
	while (pos) 
	{
		m_props.GetNextAssoc (  pos, w, (void*&)pProp );
		VERIFY(m_props.RemoveKey(w));
		CProp::DeleteCProp (pProp);
	}
};

void CPropBag::Serialize ( CArchive &ar, CSlob *pFilterSlob /*= NULL */)
{
	WORD w; CProp* pProp;
	POSITION pos;
	PROP_TYPE pt;
	DWORD dw;

	if (ar.IsStoring())
	{
		pos = m_props.GetStartPosition ();
		while (pos) 
		{
			m_props.GetNextAssoc (  pos, w, (void*&)pProp );
			if (pFilterSlob
				 && 
				!pFilterSlob->SerializePropMapFilter (w)) continue;
			ar <<  (DWORD) pProp->m_nType << w;
			switch (pProp->m_nType)
			{
				case integer:
					ar << (DWORD) ( (CIntProp *) pProp )->m_nVal;
					break;
				case booln:
					ar << (DWORD) ( (CBoolProp *) pProp )->m_bVal;
					break;
				case number:
					ar << ( (CNumberProp *) pProp )->m_numVal;
					break;
				case string:
					ar << ( (CStringProp *) pProp )->m_strVal;
					break;
				default:
					ASSERT(FALSE);		 		
			}   
		}
		// Put in end of records marker:
		ar << (DWORD) null;
	}
	else
	{
		pProp = NULL;
		TRY
		{
			while (1)
			{
				ar >> dw;
				pt = (PROP_TYPE) dw;

				// Check for end of records:			
				if ( pt == null ) break;	
				ar >> w;

				//  Should never be overwriting props:
				#ifdef _DEBUG
				void *pv;
				ASSERT (!m_props.Lookup (w, pv ));
				#endif
				switch (pt)
				{
					case integer:
						pProp = new CIntProp;
						ar >> dw;
						( (CIntProp *) pProp )->m_nVal = (int) dw;
						break;
					case booln:
						pProp = new CBoolProp;
						ar >> dw;
						( (CBoolProp *) pProp )->m_bVal = (int) dw;
						break;
					case number:
						pProp = new CNumberProp;
						ar >> ( (CNumberProp *) pProp )->m_numVal;
						break;
					case string:
						pProp = new CStringProp;
						ar >> ( (CStringProp *) pProp )->m_strVal;
						break;
					default:
						::AfxThrowArchiveException ( 
											CArchiveException::generic 
											);		 		
				}
				if (pFilterSlob
				 	&& 
					!pFilterSlob->SerializePropMapFilter (w)
					)
				{
					CProp::DeleteCProp (pProp); //Discard
				}
				else
				{
					m_props.SetAt ( w, pProp );
				}
				pProp = NULL;	   
			}
		}
		CATCH (CException, e)
		{
			if (pProp) CProp::DeleteCProp (pProp);
			THROW_LAST ();
		}
		END_CATCH
	}

}

void CPropBag::SetIntProp(CSlob* pSlob, UINT nPropID, int val)
{
	CProp* pProp = FindProp(nPropID);
	if (pProp == NULL)
	{
		if (theUndoSlob.IsRecording())
			theUndoSlob.OnAddProp(pSlob, this, nPropID);

		AddProp(nPropID, new CIntProp(val));
	}
	else
	{
		ASSERT(pProp->m_nType == integer);
		
		if (theUndoSlob.IsRecording())
			theUndoSlob.OnSetIntProp(pSlob, nPropID, ((CIntProp*)pProp)->m_nVal, this);
		
		((CIntProp*)pProp)->m_nVal = val;
	}
}

void CPropBag::SetStrProp(CSlob* pSlob, UINT nPropID, CString & str)
{
	CProp* pProp = FindProp(nPropID);
	if (pProp == NULL)
	{
		if (theUndoSlob.IsRecording())
			theUndoSlob.OnAddProp(pSlob, this, nPropID);

		AddProp(nPropID, new CStringProp(str));
	}
	else
	{
		ASSERT(pProp->m_nType == string);
		
		if (theUndoSlob.IsRecording())
			theUndoSlob.OnSetStrProp(pSlob, nPropID, &((CStringProp*)pProp)->m_strVal, this);
		
		((CStringProp*)pProp)->m_strVal = str;
	}
}

void CPropBag::Clone (CSlob * pSlob, CPropBag * pBag, BOOL fEmpty /*=TRUE*/) 
{
	// empty the 'this' property bag?
	if (fEmpty)	Empty();

	ASSERT(pBag != NULL);

	POSITION pos = pBag->m_props.GetStartPosition();
	while (pos != NULL)
	{
		WORD id;
		CProp* pProp;
		pBag->m_props.GetNextAssoc(pos, id, (void*&)pProp);
		
		switch (pProp->m_nType)
		{
		case integer:
			SetIntProp(pSlob, id, ((CIntProp*)pProp)->m_nVal);
			break;

		case string:
			SetStrProp(pSlob, id, ((CStringProp*)pProp)->m_strVal);
			break;
		
		default:
			// FUTURE: other property types...
			ASSERT(FALSE);
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\partfrm.cpp ===
// partfrm.cpp : implementation of the CPartFrame class
//

#include "stdafx.h"

#include "imeutil.h"
#include "AutoWinD.h"
#include "bardockx.h"
#include "docobfrm.h"
#include "docobvw.h"
#include "toolexpt.h"
#include <aut1api.h>
#include <aut1guid.h>
#include "shellrec.h"
#include "ipcmpvw.h"
#include "shldocs_.h"

IMPLEMENT_DYNCREATE(CPartFrame, CMDIChildWnd)
IMPLEMENT_DYNCREATE(CDocObjectFrame, CPartFrame)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Internally used messages.
//
#define FRM_DOCOBJACTIVATE	WM_USER+1	// Delay activation for DocObjects.
#define FRM_AUTOOBJACTIVATE  WM_USER+2	// Delay automation object notification of activation.

/////////////////////////////////////////////////////////////////////////////
// CPartFrame

BOOL CPartFrame::s_bLockFrame = FALSE;
WORKSPACE_INFO AFX_EXT_DATADEF* CPartFrame::s_pwi = NULL;
HWND CPartFrame::s_hwndAfter = NULL;

void CPartFrame::LockFrame(BOOL bLock)
{
	s_bLockFrame = bLock;
	s_hwndAfter = NULL;
}

void CPartFrame::LockFrame(HWND hwndAfter)
{
	s_bLockFrame = TRUE;
	s_hwndAfter = hwndAfter;
}

void CPartFrame::LockWorkspace(BOOL bLock)
{
	if ((!bLock && s_pwi == NULL) || (bLock && s_pwi != NULL))
		return;

	theApp.LockRecentFileList(bLock);

	if (bLock)
	{
		s_pwi = new WORKSPACE_INFO;
		s_pwi->pWnd = NULL;
		s_pwi->pInitData = s_pwi->pCurData = NULL;
	}
	else
	{
		delete s_pwi;
		s_pwi = NULL;

		// If we are unlocking the workspace, call OnMDIActivate to refresh
		// menus, titles, and status bar.
		CMDIFrameWnd* pMain = (CMDIFrameWnd*) AfxGetApp()->m_pMainWnd;
		CPartFrame* pFrame = (CPartFrame*) pMain->MDIGetActive();
		if (pFrame != NULL)
		{
			ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));
			pFrame->OnMDIActivate(TRUE, pFrame, NULL);
		}
	}

}

CPartFrame::CPartFrame() : CMDIChildWnd()
{
	m_pAutoFrameObj = NULL ;
	m_hwndView = NULL;
	m_pToolbar = NULL;
}

//
// Destructor - Added 12 Apr 96 - DER.
//
CPartFrame::~CPartFrame()
{
 	//OLEAUTO: Inform the associated automation object that we are gone.
	if (m_pAutoFrameObj != NULL)
	{
		m_pAutoFrameObj->AssociatedObjectReleased() ;
	}
}


void CPartFrame::SetInitData(BYTE* pData)
{
	ASSERT(s_pwi != NULL);
	ASSERT(s_pwi->pInitData == NULL || s_pwi->pInitData != pData);
	delete [] s_pwi->pInitData;
	s_pwi->pInitData = s_pwi->pCurData = pData;

	s_pwi->pWnd = NULL;	// Reset the window pointer as well.
}

BOOL CPartFrame::IsInWorkspace()
{
	CPartDoc* pDoc = (CPartDoc*) GetActiveDocument();
	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));

	// if the document doesn't want to display its path, its path is probably not valid or useful.
	// we dont want to save this window under this situation.
	if (pDoc != NULL && !pDoc->FDisplayTitle())	 
		return (!pDoc->GetPathName().IsEmpty());
	else
		return FALSE;
}

BOOL CPartFrame::IsDependent()
{
	// Delegate this question to the active view.
	CPartView* pView = (CPartView*) GetActiveView();
	ASSERT_VALID(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));

	return pView->IsDependent();
}

BYTE* CPartFrame::GetInitData()
{
	// Delegate this to the active view.
	CPartView* pView = (CPartView*) GetActiveView();
	ASSERT_VALID(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));

	return pView->GetInitData();
}

void CPartFrame::OnLoadWorkspace()
{
	CPartView* pView = (CPartView*)GetActiveView();
	ASSERT_VALID(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));

	pView->OnLoadWorkspace();
}

CString CPartFrame::GetWorkspaceMoniker(BOOL bRelative)
{
	static char BASED_CODE chRelativeDir = '.';

	CDocument* pDoc = GetActiveDocument();
	ASSERT_VALID(pDoc);
	CString strMoniker = pDoc->GetPathName();
	CPath path;
	CDir dir;

	IProjectWorkspace *pInterface;
	pInterface = g_IdeInterface.GetProjectWorkspace();
	ASSERT(pInterface != NULL);
	LPCSTR pszWorkspace;
	CString strWorkspace;
	if (SUCCEEDED(pInterface->GetWorkspaceDocPathName(&pszWorkspace)))
		strWorkspace = pszWorkspace;

	if (!strWorkspace.IsEmpty())
		VERIFY(dir.CreateFromPath(strWorkspace));
	else
		VERIFY(dir.CreateFromCurrent());

	if (bRelative && path.Create(strMoniker))
	{
		CString strRelative;
		path.GetRelativeName(dir, strRelative);

		// Beware of GetRelativeName stripping the drive label.
		if (strRelative[0] == chRelativeDir)
			strMoniker = strRelative;
	}

	return strMoniker;
}

void CPartFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	// update our parent window first
	GetMDIFrame()->OnUpdateFrameTitle(bAddToTitle);

	if ((GetStyle() & FWS_ADDTOTITLE) == 0)
		return;     // leave child window alone!

	CDocument* pDocument = GetActiveDocument();
	if (bAddToTitle && pDocument != NULL)
	{
		CString strOld;
		GetWindowText(strOld);

		CString strTitle = pDocument->GetPathName();
		if (strTitle.IsEmpty())
			strTitle = pDocument->GetTitle();
		else
			strTitle = GetDisplayName(strTitle,	AFX_ABBREV_FILENAME_LEN);

		LPTSTR lpsz = strTitle.GetBuffer(256);
		if (m_nWindow > 0)
			wsprintf(lpsz + lstrlen(lpsz), _T(":%d"), m_nWindow);
		if (pDocument->IsModified())
		{
			lstrcat(lpsz, _T(" *"));
		}
		strTitle.ReleaseBuffer();

		// set title if changed, but don't remove completely
		if (strTitle != strOld)
			SetWindowText(strTitle);
	}
}

void CPartFrame::OnToolbarStatus()
{
	CWnd* pWnd = GetDescendantWindow(AFX_IDW_TOOLBAR);
	if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(C3dDialogBar)))
		m_pToolbar = (C3dDialogBar*) pWnd;
}

BEGIN_MESSAGE_MAP(CPartFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CPartFrame)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_MOVE()
	ON_WM_MDIACTIVATE()
	ON_WM_PARENTNOTIFY()
	ON_WM_SETFOCUS()
	ON_WM_SYSCOMMAND()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_WM_GETMINMAXINFO()
	ON_WM_MENUSELECT()

	ON_MESSAGE(WM_ENTERSIZEMOVE, OnEnterSizeMove)
	ON_MESSAGE(WM_EXITSIZEMOVE, OnExitSizeMove)
	ON_MESSAGE(FRM_DOCOBJACTIVATE, OnDocObjActivate)
	ON_MESSAGE(FRM_AUTOOBJACTIVATE, OnAutoObjActivate)

	ON_COMMAND(ID_MDI_CYCLE_FORWARD, OnMDICycleForward)

	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xffff, OnToolTipText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xffff, OnToolTipText)
END_MESSAGE_MAP()

BOOL CPartFrame::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYUP:
		if (pMsg->wParam == VK_CONTROL)
			s_hwndAfter = NULL;
		break;

	case WM_KEYDOWN:
		if (pMsg->wParam == VK_CONTROL && (pMsg->lParam & 0x40000000) == 0)
			s_hwndAfter = NULL;
	    else if (pMsg->wParam == VK_RETURN && IsIconic())
	    {
			ActivateFrame();
	        return TRUE;
	    }
		else if (m_pToolbar != NULL &&
			(pMsg->wParam == VK_RETURN ||
			pMsg->wParam == VK_ESCAPE) &&
			(GetKeyState(VK_CONTROL) & ~1) == 0 &&
			::IsChild(m_pToolbar->m_hWnd, ::GetFocus()))
		{
			SetFocus();	// Frame sets focus to active view.
		}
		break;

	case WM_SYSKEYDOWN:
		if (m_pToolbar != NULL && m_pToolbar->PreTranslateSysKey(pMsg))
			return TRUE;
		break;
	}

	return CMDIChildWnd::PreTranslateMessage(pMsg);
}

int CPartFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	int nCreate = CMDIChildWnd::OnCreate(lpCreateStruct);

	if (s_pwi != NULL)
	{
		if (nCreate == -1)
			s_pwi->pWnd = NULL;
		else
			s_pwi->pWnd = this;
	}

	return nCreate;
}

void CPartFrame::OnSize(UINT nType, int cx, int cy)
{
	switch (nType)
	{
	case SIZE_MINIMIZED:
		EnableToolTips(TRUE);
		break;

	case SIZE_RESTORED:
	case SIZE_MAXIMIZED:
		EnableToolTips(FALSE);
		if (GetMDIFrame()->MDIGetActive() == this)
			theApp.m_bMaximizeDoc = (nType == SIZE_MAXIMIZED);
		break;
	}

	CMDIChildWnd::OnSize(nType, cx, cy);

	// recalc the menu bar to sort out MDI gadgets
	CASBar *pMenuBar=CASBar::GetMenuBar();
	if(pMenuBar)
	{
		pMenuBar->EnsureMDIControls();
	}
}

void CPartFrame::OnMove(int x, int y)
{
	if (theApp.m_fOEM_MBCS && (GetMDIFrame()->MDIGetActive() == this))
		imeMoveConvertWin(m_hWnd, theIME.m_xPix, theIME.m_yPix);
}

void CPartFrame::OnGetMinMaxInfo (MINMAXINFO * pMinMaxInfo)
{
	CMDIChildWnd::OnGetMinMaxInfo (pMinMaxInfo);

	CMainFrame * pFrame = (CMainFrame *)AfxGetMainWnd();
	if (pFrame->IsFullScreen())
	{
		// Make sure we don't get restricted by the tracking size.
		pMinMaxInfo->ptMaxTrackSize.x = max(pMinMaxInfo->ptMaxTrackSize.x,
			pMinMaxInfo->ptMaxSize.x);
		pMinMaxInfo->ptMaxTrackSize.y = max(pMinMaxInfo->ptMaxTrackSize.y,
			pMinMaxInfo->ptMaxSize.y);
	}
}

void CPartFrame::ActivateFrame(int nCmdShow)
{
	if(s_bInActivation)
		return;

	CMDIFrameWnd* pFrameWnd = GetMDIFrame();
	CMDIChildWnd* pChildTop = pFrameWnd->MDIGetActive();

	if (s_bLockFrame && pChildTop != NULL)
	{
		ASSERT(nCmdShow != SW_HIDE);

		CMDIChildWnd* pChildAfter;

		if (s_hwndAfter == NULL)
			pChildAfter = pChildTop;
		else
			pChildAfter = (CMDIChildWnd*) FromHandle(s_hwndAfter);

		ASSERT(pChildAfter != NULL &&
			pChildAfter->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)));
		
		if (!IsIconic())
		{
			SetWindowPos(pChildAfter, 0, 0, 0, 0,
				SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
			ShowWindow(SW_SHOWNOACTIVATE);
		}
		else
		{
			// Windows will always put the window on top, if it is restored
			// from an icon.
			CWnd* pWndClient = GetParent();
			ASSERT(pWndClient != NULL);
			pWndClient->ShowWindow(SW_HIDE);

			ShowWindow(SW_SHOWNOACTIVATE);
			pChildTop->BringWindowToTop();
			pChildTop->SetFocus();

			if (pChildAfter != pChildTop)
			{
				SetWindowPos(pChildAfter, 0, 0, 0, 0,
					SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
			}
			
			pWndClient->ShowWindow(SW_SHOW);
		}
	}
	else
	{
		BOOL bVisibleThen = (GetStyle() & WS_VISIBLE) != 0;

		if (nCmdShow == -1 && theApp.m_bMaximizeDoc)
			nCmdShow = SW_SHOWMAXIMIZED;

		if (!IsWindowVisible())
			ShowWindow((nCmdShow == -1) ? SW_SHOW : nCmdShow); // show it
		else if (IsIconic())
			ShowWindow((nCmdShow == -1) ? SW_RESTORE : nCmdShow);
		else if (nCmdShow == SW_HIDE)
			ShowWindow(nCmdShow);

		if (GetStyle() & WS_VISIBLE)
		{
			BringWindowToTop();
			HWND hWndLastPop = ::GetLastActivePopup(m_hWnd);
			if (hWndLastPop != NULL && hWndLastPop != m_hWnd)
				::BringWindowToTop(hWndLastPop);

			// If after above calls, a dock worker is still active, set focus.
			if (CDockWorker::s_pActiveDocker != NULL)
				SetFocus();
		}

		// update the Window menu to reflect new child window
		::SendMessage(pFrameWnd->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);


		// Note: Update the m_bPseudoInactive flag.  This is used to handle the
		//  last MDI child getting hidden.  Windows provides no way to deactivate
		//  an MDI child window.

		BOOL bVisibleNow = (GetStyle() & WS_VISIBLE) != 0;
		if (bVisibleNow == bVisibleThen)
			return;

		if (!bVisibleNow)
		{
			// get current active window according to Windows MDI
			HWND hWnd = (HWND)::SendMessage(pFrameWnd->m_hWndMDIClient, 
				WM_MDIGETACTIVE, 0, 0);
			if (hWnd != m_hWnd)
			{
				// not active any more -- window must have been deactivated
				ASSERT(!m_bPseudoInactive);
				return;
			}

			// check next window
			ASSERT(hWnd != NULL);
			pFrameWnd->MDINext();

			// see if it has been deactivated now...
			hWnd = (HWND)::SendMessage(pFrameWnd->m_hWndMDIClient, 
				WM_MDIGETACTIVE, 0, 0);
			if (hWnd == m_hWnd)
			{
				// still active -- fake deactivate it
				ASSERT(hWnd != NULL);
				OnMDIActivate(FALSE, NULL, this);
				m_bPseudoInactive = TRUE;   // so MDIGetActive returns NULL
			}
		}
		else if (m_bPseudoInactive)
		{
			// if state transitioned from not visible to visible, but
			//  was pseudo deactivated -- send activate notify now
			OnMDIActivate(TRUE, this, NULL);
			ASSERT(!m_bPseudoInactive); // should get set in OnMDIActivate!
		}
	}
}

COleFrameHook *CPartFrame::s_pFrmHookActivate = NULL;
COleFrameHook *CPartFrame::s_pFrmHookDeactivate = NULL;

CPartFrame *CPartFrame::s_pLastActiveFrame = NULL;
BOOL CPartFrame::s_bInActivation = FALSE;
BOOL CPartFrame::s_bInDocObjClose = FALSE;

void CPartFrame::FinishActivation()
{
	if(s_pFrmHookActivate == NULL && s_pFrmHookDeactivate == NULL)
	{
		return;
	}

	s_bInActivation = TRUE;
	((CMainFrame *)theApp.m_pMainWnd)->LockLayout(TRUE);
	CWaitCursor waitCur;
	if(s_pFrmHookActivate && !s_pFrmHookDeactivate)
	{
		Menu::UseOLE(TRUE);		// We are entering DocObject mode
		Menu::UpdateMode(FALSE); // and update the mode
		DkDocObjectMode(TRUE);
	}
	if(s_pFrmHookDeactivate)
		s_pFrmHookDeactivate->OnDocActivate(FALSE);
	if(s_pFrmHookActivate)
		s_pFrmHookActivate->OnDocActivate(TRUE);

	if(!s_pFrmHookActivate)
	{
		Menu::UseOLE(FALSE);	// We are leaving DocObject mode
		Menu::UpdateMode(FALSE); // and update the mode
		DkDocObjectMode(FALSE);
	}
	if(((CMainFrame*) theApp.m_pMainWnd)->m_pManager)
		((CMainFrame*) theApp.m_pMainWnd)->m_pManager->IdleUpdateAvailableWnds();

	((CMainFrame *)theApp.m_pMainWnd)->LockLayout(FALSE);
	((CMainFrame *)theApp.m_pMainWnd)->RecalcLayout();
	theApp.m_pMainWnd->RedrawWindow(NULL, NULL,
	            RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_UPDATENOW);
	
	s_pFrmHookActivate = NULL;
	s_pFrmHookDeactivate = NULL;
	s_bInActivation = FALSE;
}


void CPartFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd)
{
	// Workspace load will do one final activation with
	// lock off to update everything.
	//
	if (IsWorkspaceLocked())
		return;

	// Do not try to activate another window while we switch DocObjects
	if(s_bInActivation)
		return;

	s_bInActivation = TRUE;
	
	if (bActivate  && GetMDIFrame() != GetActiveWindow())
	{
		// MFC does not do OnActivateView for us, if the main window
		// is not active.  This is to support OLE servers.  We are not
		// an OLE server, and we need the activate notification for the
		// property page.

		CPartView* pView = (CPartView*)GetActiveView();
		ASSERT(pView == NULL || pView->IsKindOf(RUNTIME_CLASS(CPartView)));

		if (pView != NULL)
			pView->OnActivateView(TRUE, pView, pView);
	}


	// This part stolen from MFC 4.2 CMDIChildWnd::OnMDIActivate()
	m_bPseudoInactive = FALSE;  // must be happening for real

	// make sure MDI client window has correct client edge
	UpdateClientEdge();

	// send deactivate notification to active view
	CPartView* pActiveView = (CPartView *)GetActiveView();
	if (!bActivate && pActiveView != NULL)
		pActiveView->OnActivateView(FALSE, pActiveView, pActiveView);

	// allow hook to short circuit normal activation
	BOOL bHooked = FALSE;

//	We don't want to activate DocObjects just yet
	if(bActivate)
	{
		// We should not have a pending activation
		ASSERT(s_pFrmHookActivate == NULL);
		bHooked = TRUE;
		s_pFrmHookActivate = m_pNotifyHook;
			
		s_pLastActiveFrame = this;
	}
	else
	{
		// Can we short circuit an activation?
		// Yes if: we are de-activating a non-DocObj and last activation
		// was a non-DocObj 
		// OR
		// if we are de-activating a DocObj which matches the last activation
		// Note: I cannot assert that m_pNotifyHook==s_pFrmHookActivate because
		// in the case of a WM_CLOSE, m_pNotifyHook is already NULL'd when we get here.
		if((s_pLastActiveFrame == this) &&
			((!s_pFrmHookActivate && !m_pNotifyHook) || s_pFrmHookActivate))
		{
			s_pFrmHookActivate = NULL;
			s_pLastActiveFrame = NULL;
		}
		else
		{
			// We should not have a deactivation pending
			ASSERT(s_pFrmHookDeactivate == NULL);

			// Make sure we deactivate the currently active object
			if(s_pLastActiveFrame != NULL)
				s_pFrmHookDeactivate = s_pLastActiveFrame->m_pNotifyHook;

			s_pLastActiveFrame = NULL;
		}
	}

	// Do not defer activation for in-place components
	if(m_pNotifyHook && pActiveView &&
		  !pActiveView->DeferActivation())
	{
		m_pNotifyHook->OnDocActivate(bActivate);
		if(bActivate)
			s_pFrmHookActivate = NULL;
		else
			s_pFrmHookDeactivate = NULL;
	}



	// update titles (don't AddToTitle if deactivate last)
	if (!bHooked)
		OnUpdateFrameTitle(bActivate || (pActivateWnd != NULL));

	// re-activate the appropriate view
	if (bActivate)
	{
		if (pActiveView != NULL && GetMDIFrame() == GetActiveWindow())
			pActiveView->OnActivateView(TRUE, pActiveView, pActiveView);
	}

	OnUpdateFrameMenu(bActivate, pActivateWnd, NULL);
	GetMDIFrame()->DrawMenuBar();

	// recalc the menu bar to sort out MDI gadgets
	CASBar *pMenuBar=CASBar::GetMenuBar();
	if(pMenuBar)
	{
		// invalidate the MDI icon, since RecalcLayout doesn't imply redraw, and we 
		// might have changed to a new doc type
		pMenuBar->EnsureMDIControls();
		pMenuBar->UpdateMDIIcon();
	}

	// Do not defer deactivation if we are closing the window, because
	// the link to the OLE server is about to be severed.
	if(s_bInDocObjClose)
	{
		// If the window is invisible, that means we are
		// shutting down the IDE, so do not try to activate anything.
		if(!((CMainFrame*)theApp.m_pMainWnd)->IsWindowVisible())
			s_pFrmHookActivate = NULL;

		// Do not deactivate another view
		if(bActivate || (!bActivate && s_pFrmHookDeactivate == m_pNotifyHook))
			FinishActivation();
	}
	// HACK! when we close a doc-object using File.Close, the NotifyHook is
	// NULL by the time we get here, so let's make sure we switch contexts
	else if(!bActivate && IsKindOf(RUNTIME_CLASS(CDocObjectFrame)) &&
		m_pNotifyHook == NULL && 
		(!pActivateWnd || !pActivateWnd->IsKindOf(RUNTIME_CLASS(CDocObjectFrame))) )
	{
		Menu::UseOLE(FALSE);	// We are leaving DocObject mode
		Menu::UpdateMode(FALSE); // and update the mode
		DkDocObjectMode(FALSE);
	}
	else if(bActivate || pActivateWnd == NULL)
	{
	// Let's defer Doc-object activation by sending ourselves a message 
	// (which will trigger the activation).
	// The message arrives after the dragging messages, if any, so that we
	// can change the doc-abject activation after a SizeMove drag.
		PostMessage(FRM_DOCOBJACTIVATE, 0, 0);
	}

	s_bInActivation = FALSE;

	// Fire the appropriate event
	// We delay the firing of the event...see the message handler.
	PostMessage(FRM_AUTOOBJACTIVATE, bActivate, 0) ;

}

void CPartFrame::OnSetFocus(CWnd* pOldWnd)
{
	if (m_pViewActive != NULL)
	{
		// Make sure we call OnActivateView, or we may not do the right thing
		// coming back from docking views.
		//

		// Deactivate any dock worker that is still active at this point.
		if (CDockWorker::s_pActiveDocker != NULL)
		{
			CDockWorker::s_bLockDocker = FALSE;
			CDockWorker::s_pActiveDocker->OnWindowActivate(FALSE, this);
		}

		// Not a friend of CView.
		((CPartView*)m_pViewActive)->OnActivateView(TRUE,
			m_pViewActive, m_pViewActive);
	}
	else
	{
		CWnd::OnSetFocus(pOldWnd);
	}
}

void CPartFrame::OnUpdateFrameMenu(BOOL bActivate, CWnd* pActivateWnd,
	HMENU hMenuAlt)
{
	if (IsWorkspaceLocked())
		return;

	if (hMenuAlt != NULL)
	{
		CMDIChildWnd::OnUpdateFrameMenu(bActivate, pActivateWnd, hMenuAlt);
		return;
	}

	CPartView* pActiveView = (CPartView*) GetActiveView();
	if (pActiveView == NULL)
		return;

	ASSERT(pActiveView->IsKindOf(RUNTIME_CLASS(CPartView)));

	if (bActivate)
		theApp.ActivatePacket(pActiveView->GetPacket());
	else if (pActivateWnd == NULL)
	{
		theApp.DeactivatePacket();
		theApp.m_theAppSlob.SetSlobProp(P_CurrentSlob, NULL);
	}
	else
	{
		// Refresh MDI Window menu (even if non-shared menu)
		::SendMessage(GetMDIFrame()->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	}

	// If OLE deactivation has left us without a menu, rebuild now.
	if (theApp.m_bMenuDead)
		((CMainFrame*) GetMDIFrame())->RebuildMenus();
}

void CPartFrame::OnSysCommand(UINT nID, LPARAM lParam)
{
	switch(nID & 0xFFF0)
	{
		case SC_NEXTWINDOW:
			MDINextWindow(TRUE);
			return;

		case SC_PREVWINDOW:
			MDINextWindow(FALSE);
			return;

		case SC_MINIMIZE:
		case SC_MAXIMIZE:
		case SC_RESTORE:
			DkUpdateAvailableWnds();
			break;

		case SC_MOVE:
			// why do this? Because it happens when you single click on an icon before the double
			// click to deminimize the icon
			CBMenuPopup::SetSystemClick(GetMessageTime(), CPoint(LOWORD(lParam), HIWORD(lParam)));
		case SC_SIZE:
			{
				CSlobWnd* pView = (CSlobWnd*)GetActiveView();
				if( (pView != NULL) && pView->IsKindOf(RUNTIME_CLASS(CSlobWnd)) )
					pView->ObscureSprites();
			}
			break;

		case SC_MOUSEMENU:
			CBMenuPopup::SetSystemClick(GetMessageTime(), CPoint(LOWORD(lParam), HIWORD(lParam)));
		case SC_KEYMENU:
			if(	((nID & 0xFFF0)==SC_MOUSEMENU || lParam=='-') &&
				CASBar::s_pMenuBar->GetSafeHwnd()!=NULL &&
				Menu::IsShowingCmdBars())
			{
				CASBar::s_pMenuBar->KeyDown(VK_SUBTRACT,0,0);
				return;
			}
			break;
	}

	CMDIChildWnd::OnSysCommand(nID, lParam);
}

void CPartFrame::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	switch( nHitTest )
	{
		case HTCAPTION:
		case HTLEFT:
		case HTTOP:
		case HTRIGHT:
		case HTBOTTOM:
		case HTTOPLEFT:
		case HTTOPRIGHT:
		case HTBOTTOMLEFT:
		case HTBOTTOMRIGHT:
		{
			CSlobWnd* pView = (CSlobWnd*)GetActiveFrame()->GetActiveView();
			if( (pView != NULL) && pView->IsKindOf(RUNTIME_CLASS(CSlobWnd)) )
				pView->ObscureSprites();
			break;
		}
	}

	CMDIChildWnd::OnNcLButtonDown(nHitTest, point);
}

static BOOL s_bInSizeMove = FALSE;

void CPartFrame::OnDocObjActivate(UINT, LONG)
{
	if(!s_bInSizeMove)
		FinishActivation();
}

//
// Delay notifying the automation object about the activation change
// We do this because the user may attempt to put up UI in the activation
// handler and then mouse up's will not get handled by the original window.
// See DevStudio Bug # 8443
//
void CPartFrame::OnAutoObjActivate(UINT bActivate, LONG)
{
	if(bActivate)
	{
		// Orion Bug# 12176 - We need to send the NewDocument event only after the
		// document been completely created and is ready for prime time.
		// Therefore, we delay sending the creations event, either NewDocument or
		// OpenDocument until we are ready to send the activation event.
		
		// There is a related problem. Suppose the user attempts to delete the
		// document inside the NewDocument handler. We don't want to crash.
		// However, if this happens this Frame will be deleted. The solution
		// is to NOT use ANY member variables after we call FireCreateEvent below.

		IDispatch* pAssociatedAutoObj = GetAutomationObject(TRUE) ;
		CAutoWindowObj* pAutoFrameObjTemp = m_pAutoFrameObj ;
		
		//UGLY NOTE: pAssociatedAutoObj is the IDispatch pointer to m_pAutoFrameObj.
		// Of course, since we are using MFC we can't just cast.

		// Get the Document which gets this message.
		CPartView* pActiveView = (CPartView*)GetActiveView();
		if (pActiveView != NULL && pActiveView->IsKindOf(RUNTIME_CLASS(CPartView)))
		{
			CPartDoc* pDoc = pActiveView->GetDocument();
			pActiveView = NULL ;

//----- DO NOT USE ANY MEMBER VARIABLES PAST THIS POINT -----

			// Fire the creation event. This may delete the document and hence the frame.
			if (pDoc != NULL)
			{
				pDoc->FireCreationEvent() ;
				pDoc = NULL ;
			}
		}

		if(pAssociatedAutoObj !=  NULL)
		{
			// Fire the event on the application. These may delete the frame.
			theApp.m_pAutoApp->FireWindowActivate(pAssociatedAutoObj);
			pAutoFrameObjTemp->FireActivate();
			pAssociatedAutoObj->Release();
		}
	}
	else
	{
		// Get pointer to the automation object.
		IDispatch* pAssociatedAutoObj = GetAutomationObject(TRUE) ;
		CAutoWindowObj* pAutoFrameObjTemp = m_pAutoFrameObj ;
		ASSERT(m_pAutoFrameObj != NULL) ;

		if(pAssociatedAutoObj !=  NULL)
		{
			// Fire the event on the application.
			theApp.m_pAutoApp->FireWindowDeactivate(pAssociatedAutoObj);
			pAutoFrameObjTemp->FireDeactivate();
			pAssociatedAutoObj->Release();
		}
	}
}


void CPartFrame::OnEnterSizeMove(UINT, LONG)
{
	s_bInSizeMove = TRUE;
}

void CPartFrame::OnExitSizeMove(UINT, LONG)
{
	s_bInSizeMove = FALSE;
	FinishActivation();
}

void CPartFrame::MDINextWindow(BOOL bNext, BOOL bLinear /*=FALSE*/)
{
	// Get the current window at bottom
	CWnd* pWndBottom = GetWindow(GW_HWNDLAST);

	CWnd *pWndAfter, *pWndNext;
	if (s_hwndAfter == NULL || bLinear)
		pWndAfter = this;
	else
		pWndAfter = FromHandle(s_hwndAfter);

	// Find the next window to be shown to the user.
	if(bNext)
		pWndNext = pWndAfter->GetWindow(GW_HWNDNEXT);
	else
		pWndNext = pWndAfter;

	do
	{
		// We got no window, so we will cycle.
		if(pWndNext == NULL)
		{
			if(bNext)
				// get the first one
				pWndNext = this;
			else
				// Get the last one instead
				pWndNext = pWndBottom;
			// Just go to next loop
			continue;
		}

		// Break when we find a valid window that is not current.
		if(pWndNext != this && IsValidMDICycleMember(pWndNext))
			break;

		if (bNext)
			pWndNext = pWndNext->GetWindow(GW_HWNDNEXT);
		else
			pWndNext = pWndNext->GetWindow(GW_HWNDPREV);

    } while (pWndNext != pWndAfter) ;

	// If the window is already on top, do nothing.
    if(pWndNext == this)
    {
   		MessageBeep(0);
   		return;
    }

	// Get the window that will be used to restore the position of the
	// next window.

	CWnd* pWndNextAfter = pWndNext->GetWindow(GW_HWNDPREV);

	while (pWndNextAfter != NULL && !IsValidMDICycleMember(pWndNextAfter))
		pWndNextAfter = pWndNextAfter->GetWindow(GW_HWNDPREV);

	if (pWndNextAfter == NULL)
    {
   		MessageBeep(0);
   		return;
    }

	// Check for a full cycle through the document windows, and make hwndAfter
	// for the first window in the cycle a no-op.

	if (bNext)
	{
		if (pWndNextAfter == pWndAfter)
			pWndNextAfter = this;	// no cycle
		else
			pWndNextAfter = pWndNext;	// cycle
	}
	else if (pWndNextAfter == this)
		pWndNextAfter = pWndNext;		// cycle

	if(bLinear)
	{
		s_hwndAfter=NULL;
	}
	else
	{
		s_hwndAfter = pWndNextAfter->m_hWnd;
	}

    // Get the window flags
	CWnd* pMDIClient = GetParent();
	ASSERT(pMDIClient != NULL);

	// Check if it is maximized
	BOOL bMaximized;		// Window was maximized
	if(bMaximized = IsZoomed())
		pMDIClient->ShowWindow(SW_HIDE);

	HDWP hdwp = ::BeginDeferWindowPos(2);

	// Put current window back where it was.
	if(!bLinear ||	// nonlinear means we need to move the old window
		bNext)	// forward linear means the old needs to be at the back
	{
		if( m_hWnd != pWndAfter->m_hWnd || bLinear )
			hdwp = ::DeferWindowPos(hdwp, m_hWnd, bLinear ? HWND_BOTTOM : pWndAfter->m_hWnd, 0, 0, 0, 0,
	    		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
	}

	// Move next window to top.
	hdwp = ::DeferWindowPos(hdwp, pWndNext->m_hWnd, HWND_TOP, 0, 0, 0, 0,
    	SWP_NOMOVE | SWP_NOSIZE);

	EndDeferWindowPos(hdwp);

   	if(bMaximized)
		pMDIClient->ShowWindow(SW_SHOW);
}

void CPartFrame::OnClose()
{
	CPartView* pView = (CPartView*)GetActiveView();
	if (pView != NULL)
	{
		ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
		if (!pView->CanClose())
			return;
	}
#ifdef _DEBUG
	else
		ASSERT(m_hwndView == NULL);
#endif

	s_hwndAfter = NULL;	// Clear ctrl+tab info.

	HWND hWndSave = m_hWnd; // save hWnd to see if we got closed/destroyed

	{
		CHaltRecording halt; // otherwise, we get bogus activations recorded

		CMDIChildWnd::OnClose();
	}

	if (!::IsWindow(hWndSave)) // if the window was closed, the ::IsWindow call will fail
	{
/*		IMacroRecorder *mr;
		theApp.FindInterface(IID_IMacroRecorder, reinterpret_cast<void**>(&mr));
		mr->RecordText("ActiveWindow.Close", "Shell");
		AfxOutputDebugString("ActiveWindow.Close\n");*/

		GetShellRec().EmitMethodCall(seCloseWin, CShellConstArg(scSaveChangesPrompt));
	}
}

void CPartFrame::OnDestroy()
{
	if (s_pwi != NULL && s_pwi->pWnd == this)
		s_pwi->pWnd = NULL;

	if (m_hwndView != NULL)
	{
		// We don't really own the view window, but we do have an HWND map
		// entry that we need to manually remove.
		CWnd* pView = CWnd::FromHandlePermanent(m_hwndView);
		if (pView != NULL)
		{
			ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
			pView->Detach();
			m_hwndView = NULL;

			delete pView;
		}
	}

	CMDIChildWnd::OnDestroy();
}

void CPartFrame::OnParentNotify(UINT message, LPARAM lParam)
{
	if (message == WM_DESTROY && (HWND)lParam == m_hwndView)
	{
		// If the package destroys the view for some reason, we need
		// to clean up after ourselves...

		CWnd* pView = CWnd::FromHandlePermanent(m_hwndView);
		if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)))
		{
			ASSERT(pView != NULL);
			pView->Detach();
			m_hwndView = NULL;

			SetActiveView(NULL);
			delete pView;
		}

		PostMessage(WM_CLOSE);
	}

	CMDIChildWnd::OnParentNotify(message, lParam);
}

void CPartFrame::OnMenuSelect( UINT nItemID, UINT nFlags, HMENU hSysMenu )
{
	theApp.m_dwMenuSelectTime = GetCurrentMessage()->time;
	
	CMDIChildWnd::OnMenuSelect( nItemID, nFlags, hSysMenu );
}

LRESULT CPartFrame::OnCommandHelp(WPARAM, LPARAM lParam)
{
	static BOOL bInCommandHelp;

	if(bInCommandHelp)
		return FALSE;

	bInCommandHelp = TRUE;
	ASSERT(m_dwPromptContext == 0);
	if (theApp.CurrentPromptContext() != 0)
	{
		theApp.HelpOnApplication(theApp.CurrentPromptContext(),HELPTYPE_WINDOW);
		goto success;
	}

	if (lParam)
	{
		// id already calculated -- menu tracking or dialog up
		theApp.WinHelp(lParam);
		goto success;
	}
	else
	{
		// Handle case in which dockable has the focus.  We do not want to
		// catch this in CMainFrame, since that would require special testing
		// for cases in which a dialog was displayed.
		CPartView* pView = (CPartView*) CWnd::FromHandlePermanent(theApp.GetActiveView());
		if (pView && pView->IsKindOf(RUNTIME_CLASS(CPartView)))
		{
			CWnd * pWndFocus = CWnd::GetFocus();
			if ((pWndFocus == pView) || 
				pView->GetParentFrame()->IsChild(pWndFocus))
			{
				CString str;
				if (pView->GetHelpWord(str))
				{
					theApp.HelpOnKeyword(str);
					goto success;
				}

				lParam = pView->GetHelpID();
			}
		}
	}

	if (lParam != 0)
	{
		theApp.HelpOnApplication(lParam,HELPTYPE_WINDOW);
		goto success;
	}

	bInCommandHelp = FALSE;
	return FALSE;

success:
	bInCommandHelp = FALSE;
	return TRUE;
}

BOOL IsValidMDICycleMember(CWnd* pWnd)
{
	if (pWnd == NULL)
		return FALSE;

	LONG lStyle = pWnd->GetStyle();

	// Window owned means an icon title window.
	return	(!pWnd->GetWindow(GW_OWNER) &&
			// Must not be disabled
			!(lStyle & WS_DISABLED) &&
			// Must be visible
		   	(lStyle & WS_VISIBLE));
}

void CPartFrame::OnNewPalette()
{
	CPartView* pView = (CPartView*)GetActiveView();
	ASSERT(pView == NULL || pView->IsKindOf(RUNTIME_CLASS(CPartView)));

	if (pView != NULL)
		pView->OnNewPalette();
}

BOOL CPartFrame::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);

	// allow top level routing frame to handle the message
	if (GetRoutingFrame() != NULL)
		return FALSE;

	return CTheApp::HandleToolTipText(nID, pNMHDR, pResult);
}

void CPartFrame::OnMDICycleForward(void)
{
	((CMainFrame*)theApp.m_pMainWnd)->MDINext();
}

/////////////////////////////////////////////////////////////////////////////////////////
// 
//  OLE Automation support functions.
//

//
// Override to return the automation object corresponding to this object.
// Default creates an automation object and returns it.
//
IDispatch* CPartFrame::GetAutomationObject(BOOL bAddRef)
{
	if (m_pAutoFrameObj)
	{
		return m_pAutoFrameObj->GetIDispatch(bAddRef);
	}

	m_pAutoFrameObj= new CAutoWindowDefault(this) ; // Change to Window
	return m_pAutoFrameObj->GetIDispatch(FALSE); // creation is an implicit AddRef
}

void CPartFrame::AutomationObjectReleased()
{
	m_pAutoFrameObj = NULL ;
}

//
// The following function was stolen from opendocs.cpp where it was
// used to close windows displayed in the window list. The code
// was also needed in the automation Window object, so it was centralized
// here.
//
void CPartFrame::CloseFrame()
{
	// get a pointer to the active view in the frame
	CPartView* pActiveView = (CPartView*)GetActiveView();
	ASSERT_KINDOF(CPartView, pActiveView) ;
	// can we close this view?
	if (pActiveView->CanClose())
	{
		// get a pointer to the view's document
		CPartDoc* pDoc = pActiveView->GetDocument();
		ASSERT_KINDOF(CPartDoc, pDoc) ;

		// only save frame's that are saveable
		BOOL bSaved = TRUE;
		if (!IsKindOf(RUNTIME_CLASS(CMDIChildDock))) // Was Is Frame Saveable
		{
			// DevStudio96 Bug # 8243 We will only save if this is the document's only
			// view.
			BOOL bFoundOurSelves = FALSE ;
			int iViewCount = 0 ;
			POSITION pos = pDoc->GetFirstViewPosition() ;
			while (pos != NULL)
			{
				CView* pView = pDoc->GetNextView(pos) ;
				iViewCount++ ;
#ifdef _DEBUG
				if (pView == pActiveView)
				{
					// This code is purely for definsive programming.
					bFoundOurSelves = TRUE ;
				}
#endif
			}

			// If we were not in the list, something is terribly wrong.
			ASSERT(bFoundOurSelves) ;
			ASSERT(iViewCount != 0) ;

			if (iViewCount == 1)
			{
				// Olympus:14702
				// store the current directory and restore it after saving
				// in case the directory is changed during Save As
				TCHAR szDir[MAX_PATH];
				DWORD dwResult = GetCurrentDirectory(MAX_PATH-1, szDir);
				// save it, if necessary
				bSaved = pDoc->SaveModified();
				if (dwResult)
				{
					// set the directory back to its original
					SetCurrentDirectory(szDir);

					// get a pointer to the main frame
					CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
					ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

					// update all window titles
					pMainFrame->OnDirChange();
				}
			}
		}
		if (bSaved)
		{
			// close the window
			if (IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
			{
				SendMessage(WM_CLOSE);
			}
			else
			{
				DestroyWindow();
			}
		}
	}
}
// Override to allow hwnd buttons to nominate an id for their tooltip, depending
// on their context
int CPartFrame::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);
	int nHit=-1;

	CPartView* pActiveView = (CPartView*)GetActiveView();
	ASSERT_KINDOF(CPartView, pActiveView) ;
	// get a pointer to the view's document
	CPartDoc* pDoc = pActiveView->GetDocument();
	if(IsIconic())
	{
		if( pDoc &&
			!pDoc->GetPathName().IsEmpty())
		{
			pTI->uFlags=TTF_IDISHWND;
			pTI->uId = (UINT)GetSafeHwnd();
			pTI->hwnd = GetParent()->GetSafeHwnd();
			pTI->lpszText = _strdup(pDoc->GetPathName());
			nHit=pTI->uId;
		}
	}

	return nHit;
}

/////////////////////////////////////////////////////////////////////////////////////////
// 
//  CDocObjectFrame class.
//
BEGIN_MESSAGE_MAP(CDocObjectFrame, CPartFrame)
	//{{AFX_MSG_MAP(CDocObjectFrame)
	ON_WM_CLOSE()
	ON_WM_GETMINMAXINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CDocObjectFrame::CDocObjectFrame()
{
}

void CDocObjectFrame::OnClose()
{
	// skip the first part of the CPartFrame::OnClose which 
	// is unnecessary for docobject and Inplace components.
	s_hwndAfter = NULL;	// Clear ctrl+tab info.
	
	s_bInDocObjClose = TRUE;

	CMDIChildWnd::OnClose();
	
	s_bInDocObjClose = FALSE;
}

void CDocObjectFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	CPartDoc * pDocument = (CPartDoc *)GetActiveDocument();
	if (pDocument != NULL && bAddToTitle)
	{
		ASSERT(pDocument->IsKindOf(RUNTIME_CLASS(CPartDoc)));
		if (pDocument->FDisplayTitle())	// default PartFrame tries to display doc path rather than title
		{
			// update our parent window first
			GetMDIFrame()->OnUpdateFrameTitle(bAddToTitle);

			if ((GetStyle() & FWS_ADDTOTITLE) == 0)
				return;     // leave child window alone!

			CString strOld;
			GetWindowText(strOld);

			CString strTitle = pDocument->GetTitle();
			LPTSTR lpsz = strTitle.GetBuffer(256);
			ASSERT(m_nWindow <= 0);
			if (pDocument->IsModified())
			{
				lstrcat(lpsz, _T(" *"));
			}
			strTitle.ReleaseBuffer();

			// set title if changed, but don't remove completely
			if (strTitle != strOld)
				SetWindowText(strTitle);

			return;
		}
	}
	
	CPartFrame::OnUpdateFrameTitle(bAddToTitle);
}


void CDocObjectFrame::OnGetMinMaxInfo (MINMAXINFO * pMinMaxInfo)
{
	CPartFrame::OnGetMinMaxInfo(pMinMaxInfo);
	
	// Allow the InPlace doc to set MinMaxInfo
	CIPCompDoc* pDocument = (CIPCompDoc*)GetActiveDocument();
	if(pDocument != NULL && pDocument->IsKindOf(RUNTIME_CLASS(CIPCompDoc)))
		pDocument->GetMinMaxInfo(pMinMaxInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\path.cpp ===
//////////////////////////////////////////////////////////////////////
// PATH.CPP
//
// Implementation of CPath and CDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName.
// 19-May-93	danw		Fixed GetExtension to return after the '.'.
// 20-May-93	mattg		Added CDir object
//							GetExtension now again returns the '.'
//							PATH.H comment fixed)
// 11-Jul-93	mattg		New methods for CPath and CDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
// 22-Nov-93	mattg		Fixed bug in CPath::CreateFromDirAndFilename
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "path.h"
#ifndef _WIN32
#include "direct.h"
#include "ctype.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#ifndef _WIN32
#define MAX_PATH _MAX_PATH
#endif

static TCHAR *StripQuotes(LPCTSTR szFilePath);

//////////////////////////////////////////////////////////////////////
// size_t RemoveNewlines(_TCHAR * buffer);  -- helper function
//
// Scans a string in place, replacing any internal newlines with ' '
// and removing '\r' and any other control characters.
//
// Returns the number of _TCHAR's in the modified string
//
// DBCS-safe
//
// CONSIDER: find a better place for this function
//
size_t RemoveNewlines(_TCHAR * buffer)
{
	_TCHAR * r = buffer;
	_TCHAR * w = buffer;
	while (*r)
	{
		if (*r < (unsigned int)(unsigned char)' ')
		{
			// replace internal newlines; strip other control characters
			if ((*r == _T('\n')) && (*(r+1)!=_T('\0')))
			{
				*w++ = _T(' '); // replace newlines with spaces
			}
			r++;	// just ignore other control characters

		}
		else
		{
			// *w++ = *r++; DBCS-safe copy for normal characters
			_tccpy(w,r);
			w = _tcsinc(w);
			r = _tcsinc(r);
		}
	}
	*w = *r;	// copy final nul
	return((size_t)(w-buffer));
}


//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted.

// Really, we're doing this mostly for nmake's benifit, so we're talking
// about nmakes' reserved characters which are:
// 			:  ;  #  (  )  $  ^  \  {  }  !  @
// We ignore ':' since it will only appear embedded in a filename nmake
// doesn't care about this case.
//
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath)
{
	while (*pPath)
	{
		if (!_istalnum (*pPath)
			&&
			*pPath != _T ('.')
			&&
			*pPath != _T ('_')
			&&
			*pPath != _T ('~')
			&&
			*pPath != _T ('\\')
			&&
			*pPath != _T ('/')
			&&
			*pPath != _T (':')
			) return TRUE;
		pPath = _tcsinc ( pPath );
	}
	return FALSE;
}

//////////////////////////////////////////////////////////////////////
// Empty string used by construct element functions:
const CString AFX_EXT_DATADEF pthEmptyString;

LPCTSTR GetLastSlash(LPCTSTR szPath)
{
	LPCTSTR pSlash = _tcsrchr(szPath, _T('\\'));
	if ((pSlash != NULL) && (*pSlash==0))
		pSlash = NULL;

	return pSlash;
}

//////////////////////////////////////////////////////////////////////
// Constructors, destructors

IMPLEMENT_DYNAMIC(CPath, CObject)

CPath::~CPath
(
)
{
}

//////////////////////////////////////////////////////////////////////
// CPath::Create

BOOL CPath::Create
(
	const TCHAR *	szFileName
)
{
	TCHAR	rgchPath[_MAX_PATH];

	// check for unbalanced quotes--means that quote is being used as path char
	TCHAR *pch = _tcschr(szFileName, _T('\"'));
	if ((pch != NULL) && (pch == _tcsrchr(szFileName, _T('\"'))))
		return FALSE;
	
	// Strip any quotes from the filename - private copy. Must be freed
	TCHAR *szFilename = StripQuotes(szFileName);
		
	// First we may need to clean up the szFilename that was passed to us
	// Possible bad scenarios are
	// (1) <whitespace><drive>:<rest of path>	(need to strip whitespace)
 	// (2) paths containing multiple :'s		(bogus filenames)
 
	TCHAR * pStart = (TCHAR *)szFilename;
 	TCHAR * pColon = _tcschr(pStart, _T(':'));
	if (pColon)
 	{
		if (_tcschr(_tcsinc(pColon), _T(':')))
		{
			delete [] szFilename;
			return FALSE;	// Multiple colons
		}

		if (pColon > pStart)
			pStart = _tcsdec(pStart, pColon);	// Drive letters must be single byte chars
		else if (pColon == pStart)
		{
			delete [] szFilename;
			return FALSE;	// filename starts with colon
		}
	}

#ifdef _WIN32
	TCHAR *	pchFilePart;
	int nPathLen = GetFullPathName(pStart, sizeof(rgchPath), rgchPath, 
		&pchFilePart);
	if( (nPathLen <= 0) || (nPathLen > sizeof(rgchPath)) )
#else
	if (_fullpath(rgchPath, pStart, sizeof(rgchPath)) == NULL)
#endif
	{
		delete [] szFilename;
		return FALSE;
	}

	// Check for some weird cases that GetFullPathName() lets slip through.
	// The following resulting full paths are all invalid:
	//
	// (1) <drive>:\			(no filename)
	// (2) <drive>:\<dirs>\		(no filename)
	// (3) \\					(no servername, sharename or filename)
	// (4) \\<server>			(no sharename or filename)
	// (5) \\<server>\<share>	(no filename)
	// (6) \\<server>\<share>\	(no filename)
	// (7) \\\<filename>
	//
	// Cases (1), (2) and (6) can be caught by checking to see if the last
	// character is "\".  Cases (3), (4) and (5) can be caught by checking
	// to see if the first two characters are both "\", and if so, verifying
	// that there are at least two other "\" characters in the pathname (case
	// (6) does have two other "\" characters, but it will have been caught
	// earlier).
	//
	// I don't know if this behavior of NT is a bug or a feature.

	int ichPathStart = 0;
	LPCTSTR pSlash;
	pStart = rgchPath;
	if (*rgchPath==_T('\\'))
	{
		ASSERT(*(rgchPath+1)==_T('\\'));	// must be UNC path
		pStart += 2;
	}

	if (((pSlash = GetLastSlash(pStart))==NULL) || (*(pSlash+1)==0) || (pSlash==pStart))
	{
		// This covers cases (1), (2), (3), (4), (6) and (7) above, as well as
		// ensuring that there is at least one "\".
		delete [] szFilename;
		return FALSE;
	}

	// Check for case (5)
	if ((*rgchPath==_T('\\')) && (_tcschr(pStart, _T('\\'))==pSlash))
	{
		delete [] szFilename;
		return FALSE;
	}

	// REVIEW: others?
	// also reject illegal characters "<>|" 
	if (_tcspbrk(pStart, _T("<>|")))
	{
		delete [] szFilename;
		return FALSE;
	}

	// now validate that full path length and component lengths are valid
	if ((_tcslen(rgchPath) >= _MAX_PATH) || (_tcslen(pchFilePart) >= _MAX_FNAME))
	{
		delete [] szFilename;
		return FALSE;
	}
	
	m_ichLastSlash = (int)(pSlash - rgchPath);
	m_strCanon = rgchPath;

	delete [] szFilename;
	m_Flags &= ~eIsActualCase;
	return TRUE;
}

//////////////////////////////////////////////////////////////////////
// CPath::CreateFromDirAndFilename

BOOL CPath::CreateFromDirAndFilename
(
	const CDir &	dir,
	const TCHAR *	szFileName
)
{
	// Strip quotes from the filename
	TCHAR* szFilename = StripQuotes(szFileName);
	TCHAR* szAllocName = szFilename;
	BOOL fRet;

	// The basic idea is to simply append the filename to the directory
	// specification and pass this to the Create() method.  HOWEVER, if
	// the filename specifies a full path, just pass that instead.

	if (*szFilename && *_tcsinc(szFilename) == _T(':'))
	{
		// 'szFilename' has a drive letter.  Is a different drive from 'dir'?

		if (dir.IsUNC() || _totupper(*szFilename) != _totupper(*dir))
		{
			// Different drive, so just call Create, which will use
			// the current directory of the drive specified in
			// szFilename.

			fRet = Create(szFilename);
			delete [] szAllocName;
			return fRet;
		}

		// Same drive: skip over drive letter and colon.
		ASSERT(!_ismbblead(*szFilename));
		szFilename += 2;
	}

	if	(
		((*szFilename == _T('/')) || (*szFilename == _T('\\')))
		&&
		((*(szFilename + 1) == _T('/')) || (*(szFilename + 1) == _T('\\')))
		)
	{
		fRet = Create(szFilename);
		delete [] szAllocName;
		return fRet;
	}
	else if ((*szFilename == _T('/')) || (*szFilename == _T('\\')))
	{
		CString	strT;

		// Almost a full path -- we just need the volume name.  Extract
		// the volume from the specified directory.

		if (dir.IsUNC())
		{
			const	TCHAR *	pch = (const TCHAR *)dir;
					int		nCountBackslash = 0, nBytes;

			// Copy characters from the directory name until we
			// hit a fourth '\' or a terminating nul.
			//
			// \\server\share\dir
			// ^^      ^     ^
			// 12      3     4
			//
			// \\server\share
			//               ^ terminating nul

			while (nCountBackslash < 4 && *pch != _T('\0'))
			{
				if (*pch == _T('\\'))
					++nCountBackslash;

				nBytes = _tclen(pch);

				strT += *pch++;

				if (nBytes == 2)
					strT += *pch++;
			}

			if (nCountBackslash != 4)
				strT += _T('\\');

			strT += szFilename;

			fRet = Create(strT);
			delete [] szAllocName;
			return fRet;
		}
		else
		{
			ASSERT(*((const TCHAR *)dir + 1) == _T(':'));

			strT += *(const TCHAR *)dir;	// Extract drive letter
			strT += _T(':');
			strT += szFilename;

			fRet = Create(strT);
			delete [] szAllocName;
			return fRet;
		}
	}
	else
	{
		CString	strT;

		strT = dir.m_strDir;

		// The length of the 'dir' string is guaranteed to be 3 if and only if
		// it represents the root of a volume (e.g., "C:\").  We need to append
		// a backslash UNLESS the directory represents the root of a volume.

		if (strT.GetLength() != 3)
			strT += _TEXT("\\");

		strT += szFilename;

		fRet = Create(strT);
		delete [] szAllocName;
		return fRet;
	}
}

//////////////////////////////////////////////////////////////////////
// CPath::CreateTemporaryName

BOOL CPath::CreateTemporaryName
(
	const CDir &	dir,
	BOOL			fKeep
)
{
	TCHAR	rgchT[MAX_PATH];

#ifdef _WIN32
	if (!GetTempFileName((const TCHAR *)dir, _TEXT("MVC"), 0, rgchT))
		return(FALSE);
#else
	TCHAR* pchT;
	if ((pchT = _tempnam((TCHAR *)(const TCHAR *)dir, _TEXT("MVC"))) == NULL)
		return(FALSE);

	_tcscpy(rgchT, pchT);
	free(pchT);
#endif

	// At this point, GetTempFileName() has created the file on disk.  If
	// fKeep is FALSE, remove that file.

	if (!fKeep)
#ifdef _WIN32
		VERIFY(DeleteFile(rgchT));
#else
		remove(rgchT);
#endif

	return(Create(rgchT));
}

//////////////////////////////////////////////////////////////////////
// CPath::PostFixNumber

VOID CPath::PostFixNumber()
{
	CString strBaseName, strNumber;

	// Strip off any existing digits on the
	// end of the base name of the path
	GetBaseNameString(strBaseName);
	int nLength = strBaseName.GetLength();
	int nPos = nLength - 1;
	while (nPos > 0 && _istdigit(strBaseName[nPos]))
	{
		strNumber = strBaseName[nPos] + strNumber;
		nPos--;
	}

	// If we didn't have a number then initialize the number
	// to be zero (remember that we will increment it)
	if (strNumber.IsEmpty())
		strNumber = _T('0');

	ASSERT(strNumber.GetLength() < 10);	// We only support up to 10 digits in the number!!!!

	// Increment the number
	int nNumber = _ttoi(strNumber);
	nNumber++;
	LPTSTR lpszNumber = strNumber.GetBuffer(10);
	_itot(nNumber, lpszNumber, 10);
	strNumber.ReleaseBuffer();

	// Construct the new file name
	CString strNewFileName = strBaseName.Left(nPos + 1) + strNumber + GetExtension();

	// Change the file name
	ChangeFileName(strNewFileName);
}

//////////////////////////////////////////////////////////////////////
// CPath::GetBaseNameString

VOID CPath::GetBaseNameString
(
	CString &	strResult
)
const
{
	const TCHAR *	pchFileName;
	const TCHAR *	pchExt;

	ASSERT(IsInit());
	pchFileName = GetFileName();
	pchExt = GetExtension();

	strResult = pchFileName;
	strResult = strResult.Left(pchExt - pchFileName);
}

//////////////////////////////////////////////////////////////////////
// CPath::GetDisplayNameString

VOID CPath::GetDisplayNameString
(
	CString &	strResult,
	int			cchMax,
	BOOL bTakeAllAsDefault
)
const
{
			int		i, cchFullPath, cchFileName, cchVolName;
	const	TCHAR *	pchCur;
	const	TCHAR *	pchBase;
	const	TCHAR *	pchFileName;

	// Following is the desired behavior.  Take as an example the full pathname
	// C:\SUSHI\VCPP32\C\MEMWIN.C.
	//
	// cchMax	strResult
	// ------	---------
	//  1- 7	<empty>
	//  8-14	MEMWIN.C
	// 15-16	C:\...\MEMWIN.C
	// 17-23	C:\...\C\MEMWIN.C
	// 24-25	C:\...\VCPP32\C\MEMWIN.C
	// 26+		C:\SUSHI\VCPP32\C\MEMWIN.C

	ASSERT(IsInit());
	cchFullPath = m_strCanon.GetLength();
	cchFileName = _tcslen(pchFileName = GetFileName());

	// If cchMax is more than enough to hold the full path name, we're done.
	// This is probably a pretty common case, so we'll put it first.

	if (bTakeAllAsDefault || cchMax >= cchFullPath)
	{
		strResult = m_strCanon;
		return;
	}

	// If cchMax isn't enough to hold at least the basename, we're done (result
	// is empty string).

	if (cchMax < cchFileName)
	{
		strResult.Empty();
		return;
	}

	// Calculate the length of the volume name.  Normally, this is two
	// characters (e.g., "C:", "D:", etc.), but for a UNC name, it could
	// be more (e.g., "\\server\share").
	//
	// If cchMax isn't enough to hold at least <volume_name>\...\<base_name>,
	// the result is the base filename.

	pchBase = (const TCHAR *)m_strCanon;
	pchCur = pchBase + 2;					// Skip "C:" or leading "\\"

	if (IsUNC())
	{
		ASSERT((m_strCanon[0] == _T('\\')) && (m_strCanon[1] == _T('\\')));

		// First skip to the '\' between the server name and the share name,
		// then skip to the '\' after the share name.

		for (i=0 ; i<2 ; ++i)
		{
			while (*pchCur != _T('\\'))
			{
				pchCur = _tcsinc((TCHAR *)pchCur);
				ASSERT(*pchCur != _T('\0'));
			}

			if (i == 0)
				pchCur = _tcsinc((TCHAR *)pchCur);
		}
	}

	ASSERT(*pchCur == _T('\\'));

	cchVolName = pchCur - pchBase;

	if (cchMax < cchVolName + 5 + cchFileName)
	{
		strResult = pchFileName;
		return;
	}

	// Now loop through the remaining directory components until something
	// of the form <volume_name>\...\<one_or_more_dirs>\<base_name> fits.
	//
	// Assert that the whole filename doesn't fit -- we should have handled
	// this earlier.

	ASSERT(cchVolName + (int)_tcslen(pchCur) > cchMax);

	while (cchVolName + 4 + (int)_tcslen(pchCur) > cchMax)
	{
		do
		{
			pchCur = _tcsinc((TCHAR *)pchCur);
			ASSERT(*pchCur != _T('\0'));
		}
		while (*pchCur != _T('\\'));
	}

	// Form the resultant string and we're done.

	strResult = m_strCanon.Left(cchVolName) + _T("\\...") + pchCur;
}

//////////////////////////////////////////////////////////////////////
// CPath::operator ==

int CPath::operator ==
(
	const CPath &		pathCmp
)
const
{
	return (m_strCanon.CompareNoCase(pathCmp.m_strCanon) == 0);
}

//////////////////////////////////////////////////////////////////////
// CPath::ChangeFileName

VOID CPath::ChangeFileName
(
	const TCHAR *	szNewFileName
)
{
	TCHAR *	pchCanon;
	int		ichOldFileName;

	ASSERT(IsInit());
	ichOldFileName = GetFileName() - (const TCHAR *)m_strCanon;

	pchCanon = m_strCanon.GetBuffer(m_strCanon.GetLength() +
		_tcslen(szNewFileName));

	lstrcpy(pchCanon + ichOldFileName, szNewFileName);

	m_strCanon.ReleaseBuffer(-1);

}

//////////////////////////////////////////////////////////////////////
// CPath::ChangeExtension

VOID CPath::ChangeExtension
(
	const TCHAR *	szNewExt
)
{
	TCHAR *	pchCanon;
	TCHAR *	szFileName;
	int		ichOldExt;
	CString	strExt;

	ASSERT(IsInit());

	// Attempt to do something clever here.  Make a copy of the filename
	// and see if it's:
	//
	// (1) UPPERCASE
	// (2) MixedCase
	// (3) lowercase
	//
	// (1): Make the extension uppercase.
	// (2): Make the extension's first letter uppercase, and the remaining
	//      letters lowercase.
	// (3): Make the extension lowercase.
	szFileName = (TCHAR *)GetFileName();
	strExt = GetExtensionCase( szFileName, szNewExt );

	// Find the current extension, if any.  Convert this to a character offset
	// since the CString's buffer could move when we GetBuffer() it.
	ichOldExt = GetExtension() - (const TCHAR *)m_strCanon;
	pchCanon = m_strCanon.GetBuffer(m_strCanon.GetLength() + strExt.GetLength() + 1);
	pchCanon[ichOldExt] = _T('.');

	lstrcpy( pchCanon + ichOldExt + 1,
			strExt[0] == _T('.') ? (const TCHAR *)strExt + 1 :
			(const TCHAR *)strExt);

	m_strCanon.ReleaseBuffer(-1);
}

//////////////////////////////////////////////////////////////////////
// CPath::GetRelativeName
#define _tcicmp(x,y) _tcsnicmp((x),(y),1)

BOOL CPath::GetRelativeName
(
	const CDir &rDir,
	CString& strResult,
	BOOL bQuote /*= FALSE*/,
	BOOL bIgnoreAlwaysRelative /* = FALSE */
) const
{
	// Plan here is simple:  Find how many of the leading characters
	// match in the two m_strCanon and rDir.  In order to be able to
	// relativize, this must be all of rDir:

	const TCHAR *pcDir, *pcPt;
	TCHAR resPath[_MAX_PATH+3], *presPath;
	BOOL bRetval = FALSE;
	int nSlashCount;

	pcDir = rDir;
	pcPt = m_strCanon;
	presPath = resPath;

	ASSERT(IsInit());

	// Quote really only means quote if needed:
	if (bQuote) bQuote = ContainsSpecialCharacters () ||
							rDir.ContainsSpecialCharacters ();

	ASSERT ( _tcslen ( pcPt) <= _MAX_PATH);
	if (bQuote) *presPath++ = _T('"');

	int rDirLen = rDir.m_strDir.GetLength();
	if (!_tcsnicmp(pcDir, pcPt, rDirLen))
	{
		pcPt += rDirLen;
		// Now, the directory may or may not end with a backslash.  If
		// it does not then the next charcter in the path must be a backslash:
		if ((*pcPt == _T('\\')) || (*_tcsdec(pcDir, pcDir+rDirLen) == _T('\\')))
		{
			// the following is DBCS safe because we already know it's a '\\'
			if (*pcPt != _T('\\')) pcPt--; // back up to the slash if necessary

			*presPath++ = _T('.');	// insert '.' before '\\'
			while ( *presPath++ = *pcPt++ );
			bRetval = TRUE;
		}

	}
	if (!bRetval)
	{

		// See if our path begins with a drive letter
		// colon and backslash.  If it does, see if the first three characters
		// match the reference directory.  If they do, then the relative path
		// just our path minus the drive letter:
		pcDir = rDir;
		pcPt = m_strCanon;
		if  (
			(!_ismbblead(*pcPt))
			&&
			*(pcPt + 1) == _T(':') && *(pcPt + 2) == _T('\\')
			&&
			(!_tcsnicmp(pcPt, pcDir, 3))
			)

		{
			pcPt += 2;							// Skip over drive letters.
			if (GetAlwaysRelative() && !bIgnoreAlwaysRelative)
			{
				// if requested, attempt full relativization
				pcDir +=3;
				int len;
				const TCHAR * pcTemp = ++pcPt;
				while (((pcTemp = _tcschr(pcPt, _T('\\')))!=NULL) &&
						(!_tcsnicmp(pcPt, pcDir, (len = (pcTemp+1)-pcPt))))
				{
					pcPt = (pcTemp+1);
					pcDir += len;
				}

				// removed common part, now add appropriate # of "..\"
				do
				{
					*presPath++ = _T('.');
					*presPath++ = _T('.');
					*presPath++ = _T('\\');
				}
				while (((pcDir = _tcschr(pcDir, _T('\\')))!=NULL) && (*++pcDir));
				// now just append the rest
			}

			while ( *presPath++ = *pcPt++ );	// Copy
			bRetval = TRUE;
		}
		// See if these are UNC paths.  Then check if they have the same
		// server and share names:
		else if ( *pcPt++ == _T('\\') && *pcPt++ == _T('\\')
				  && *pcDir++ == _T('\\') && *pcDir++ == _T('\\') )
		{
			// Go until second \, or end of string:
			nSlashCount = 0;
			while ( *pcDir && *pcPt &&  _tcicmp (pcDir, pcPt)==0)
			{
				if (*pcDir == _T ('\\'))
					if (++nSlashCount > 1 ) break;
				pcDir = _tcsinc ( (TCHAR *) pcDir);
				pcPt  = _tcsinc ( (TCHAR *) pcPt);
			}

			if ( nSlashCount == 2
				||
				(*pcDir == 0 && *pcPt == _T ('\\') && nSlashCount == 1)
				)
			{
				if (*pcPt != _T ('\\')) *presPath++ = _T ('\\');
				while ( *presPath++ = *pcPt++ );
				bRetval = TRUE;
			}
		}
		if (bRetval == FALSE) // Failure!
		{
			pcPt = m_strCanon;
			while ( *presPath++ = *pcPt++ );
		}
	}

	if (bQuote)
	{
		ASSERT ( *(presPath-1) == 0 );
		*(presPath-1) = _T('"');
		*presPath = _T('\0');
	}
	strResult = resPath;
	return bRetval;
}
//////////////////////////////////////////////////////////////////////
// CPath::CreateFromDirAndRelative
BOOL CPath::CreateFromDirAndRelative
(
	const CDir &rDir,
	const TCHAR *pstr
)
{
	// THIS FUNCTION IS OBSOLETE.  The only thing it does that
	// CreateFromDirAndFilename doesn't do is, this function removes
	// quotes from around the relative path (if present).

	if (*pstr == _T('"'))
	{
		int cch = _tcslen(pstr);

		// MARTYNL: Badly formed string was passed in, probably caused by bad parsing at the outer layer
		if(pstr[cch-1] != '"')
		{
			return FALSE;
		}

		CString str(pstr+1, cch-2);
		return CreateFromDirAndFilename(rDir, str);
	}
	else
	{
		return CreateFromDirAndFilename(rDir, pstr);
	}
}

//////////////////////////////////////////////////////////////////////
// CPath::GetActualCase()
CMapStringToString CPath::c_DirCaseMap;
void CPath::GetActualCase(BOOL bEntirePath /*= FALSE*/)
{
	ASSERT(IsInit());

	// avoid expensive call if case already set
	if (!IsActualCase())
	{
		// Let's see if we can speed this up...
		CDir tempDir;
		tempDir.CreateFromPath( *this );
		tempDir.m_strDir.MakeUpper();

		CString strActualDirCase;
		if (!c_DirCaseMap.Lookup( tempDir, strActualDirCase ))
		{
			strActualDirCase = tempDir.m_strDir;
			GetActualFileCase( strActualDirCase );
			c_DirCaseMap.SetAt( tempDir, strActualDirCase );
		}
		GetActualFileCase( m_strCanon, strActualDirCase );

		m_Flags |= eIsActualCase;
		ASSERT(IsActualCase());

		// must update in case the length has changed
		LPCTSTR pSlash = GetLastSlash(m_strCanon);
		ASSERT((pSlash!=NULL) && (*(pSlash+1)!=0));
		m_ichLastSlash = (int)(pSlash - (LPCTSTR)m_strCanon);
	}
}

//////////////////////////////////////////////////////////////////////
// CPath::SetActualCase(LPCTSTR pszFileCase)
void CPath::SetActualCase(LPCTSTR pszFileCase)
{
	ASSERT(IsInit());

	// avoid expensive call if case already set
	if (!IsActualCase())
	{
		// Let's see if we can speed this up...
		CDir tempDir;
		tempDir.CreateFromPath( *this );
		tempDir.m_strDir.MakeUpper();

		CString strActualDirCase;
		if (!c_DirCaseMap.Lookup( tempDir, strActualDirCase ))
		{
			strActualDirCase = tempDir.m_strDir;
			GetActualFileCase( strActualDirCase );
			c_DirCaseMap.SetAt( tempDir, strActualDirCase );
		}

		if (pszFileCase != NULL)
		{
			// try to avoid getting the case if we already know it
			// ASSERT(stricmp(pszFileCase, GetFileName())==0);
			// ASSERT((UINT)m_strCanon.GetLength()==(UINT)(strActualDirCase.GetLength() + strlen(pszFileCase) + 1));
			m_strCanon = strActualDirCase + _T('\\');
			m_strCanon += pszFileCase;
		}
		else
		{
			GetActualFileCase( m_strCanon, strActualDirCase );
		}
		m_Flags |= eIsActualCase;
		ASSERT(IsActualCase());

		// must update in case the length has changed
		LPCTSTR pSlash = GetLastSlash(m_strCanon);
		ASSERT((pSlash!=NULL) && (*(pSlash+1)!=0));
		m_ichLastSlash = (int)(pSlash - (LPCTSTR)m_strCanon);
	}
}

//////////////////////////////////////////////////////////////////////
// CPath::ResetDirMap()
void CPath::ResetDirMap()
{
	c_DirCaseMap.RemoveAll();
}

//////////////////////////////////////////////////////////////////////
// CPath::GetFileTime()
BOOL CPath::GetFileTime(LPFILETIME lpftLastWrite)
{
	ASSERT(IsInit());

	HANDLE hFile = ::CreateFile(m_strCanon, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	BOOL bRC = ::GetFileTime(hFile, NULL, NULL, lpftLastWrite);
	CloseHandle(hFile);

	return bRC;
}

BOOL CPath::GetFileTime(CString& rstrLastWrite, DWORD dwFlags /*= DATE_SHORTDATE*/)
{
	FILETIME ft;
	if (!GetFileTime(&ft))
		return FALSE;

	CTime time(ft);
	rstrLastWrite = theApp.m_CPLReg.Format(time, DATE_ALL, dwFlags);

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//	Somewhat redundant global path utility functions.
//		But they are easier to use.

static void AbbreviateName(LPTSTR lpszCanon, int cchMax, BOOL bAtLeastName);

// Remove the drive and directory from a file name...
//
CString StripPath(LPCTSTR szFilePath)
{
    char szName [_MAX_FNAME + _MAX_EXT];
    char szExt [_MAX_EXT];
    _splitpath(szFilePath, NULL, NULL, szName, szExt);
    lstrcat(szName, szExt);
    return CString(szName);
}


// Remove the name part of a file path.  Return just the drive and directory.
//
CString StripName(LPCTSTR szFilePath)
{
    char szPath [_MAX_DRIVE + _MAX_DIR];
    char szDir [_MAX_DIR];
    _splitpath(szFilePath, szPath, szDir, NULL, NULL);
    lstrcat(szPath, szDir);
    return CString(szPath);
}


// Get the extension of a file path.
//
CString GetExtension(LPCTSTR szFilePath)
{
    char szExt [_MAX_EXT];
    _splitpath(szFilePath, NULL, NULL, NULL, szExt);
    return CString(szExt);
}


// Return the path to szFilePath relative to szDirectory.  (E.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.)  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
// If szDirectory is NULL, the current directory is used.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory /*= NULL*/)
{
    CString strDir;

    if (szDirectory == NULL)
    {
        _getcwd(strDir.GetBuffer(_MAX_DIR), _MAX_DIR);
        strDir.ReleaseBuffer();
        strDir += '\\';
    } else {
		strDir = szDirectory;
		int len = strDir.GetLength();
		if( len > 0 ){
			TCHAR c = strDir[len-1];
			if(  c != _T('\\') && c != _T(':') )   // add a trailing slash unless drive letter
				strDir += '\\';
		}
	}
	szDirectory = strDir;

    int cchDirectory = lstrlen(szDirectory);
    if (_tcsnicmp(szFilePath, szDirectory, cchDirectory) == 0)
        return CString(szFilePath + cchDirectory);
    else if ( szFilePath[0] == szDirectory[0] &&
              szFilePath[1] == ':' && szDirectory[1] == ':' )    // Remove drive if same.
        return CString(szFilePath + 2);

    return CString(szFilePath);
}

//	GetDisplayName
//		Does the same thing to a file path as our MRU implemenation.

CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory /*= NULL*/)
{
    CString strDir;

    if ( szDirectory == NULL )
    {
        _getcwd(strDir.GetBuffer(_MAX_DIR), _MAX_DIR);
        strDir.ReleaseBuffer();
        strDir += '\\';
        szDirectory = strDir;
    }

    int cchDirectory = lstrlen(szDirectory);

	int cchFileDir = lstrlen(szFilePath) -
		(SushiGetFileTitle(szFilePath, NULL, 0)-1);
	if (cchFileDir == cchDirectory &&
			_tcsnicmp(szDirectory, szFilePath, cchDirectory) == 0)
		return CString(szFilePath + cchDirectory);
	else if (nMaxDisplayLength != -1)
	{
		CString strName;
		LPTSTR lpch = strName.GetBuffer(_MAX_PATH);

		lstrcpy(lpch, szFilePath);
		AbbreviateName(lpch, nMaxDisplayLength, TRUE);

		strName.ReleaseBuffer();

		return strName;
	}

    return CString(szFilePath);
}

/////////////////////////////////////////////////////////////////////////////
//	AbbreviateName
//		Taken from MFC\SRC\FILELIST.CPP
//
// lpszCanon = C:\MYAPP\DEBUGS\C\TESWIN.C
// cchMax	b	Result
// ------	-	---------
//  1- 7	F	<empty>
//  1- 7	T	TESWIN.C
//  8-14	x	TESWIN.C
// 15-16	x	C:\...\TESWIN.C
// 17-23	x	C:\...\C\TESWIN.C
// 24-25	x	C:\...\DEBUGS\C\TESWIN.C
// 26+		x	C:\MYAPP\DEBUGS\C\TESWIN.C
static void AbbreviateName(LPTSTR lpszCanon, int cchMax, BOOL bAtLeastName)
{
	int cchFullPath, cchFileName, cchVolName;
	const TCHAR* lpszCur;
	const TCHAR* lpszBase;
	const TCHAR* lpszFileName;

	lpszBase = lpszCanon;
	cchFullPath = lstrlen(lpszCanon);

	cchFileName = SushiGetFileTitle(lpszCanon, NULL, 0)-1;
	lpszFileName = lpszBase + (cchFullPath-cchFileName);

	// If cchMax is more than enough to hold the full path name, we're done.
	// This is probably a pretty common case, so we'll put it first.
	if (cchMax >= cchFullPath)
		return;

	// If cchMax isn't enough to hold at least the basename, we're done
	if (cchMax < cchFileName)
	{
		lstrcpy(lpszCanon, (bAtLeastName) ? lpszFileName : &afxChNil);
		return;
	}

	// Calculate the length of the volume name.  Normally, this is two
	// characters (e.g., "C:", "D:", etc.), but for a UNC name, it could
	// be more (e.g., "\\server\share").
	//
	// If cchMax isn't enough to hold at least <volume_name>\...\<base_name>,
	// the result is the base filename.

	lpszCur = lpszBase + 2;					// Skip "C:" or leading "\\"

	if (lpszBase[0] == '\\' && lpszBase[1] == '\\')	// UNC pathname
	{
		// First skip to the '\' between the server name and the share name,
		while (*lpszCur != '\\')
		{
			lpszCur = _tcsinc(lpszCur);
			ASSERT(*lpszCur != '\0');
		}

		// if a UNC get the share name, get at least one directory.  We don't need
		// to ensure a directory after c:, etc.
		ASSERT(*lpszCur == '\\');

		if (cchFullPath - cchFileName > 3)
		{
			lpszCur = _tcsinc(lpszCur);
			while (*lpszCur != '\\')
			{
				lpszCur = _tcsinc(lpszCur);
				ASSERT(*lpszCur != '\0');
			}
		}
	}

	ASSERT(*lpszCur == '\\');

	cchVolName = lpszCur - lpszBase;

	if (cchMax < cchVolName + 5 + cchFileName)
	{
		lstrcpy(lpszCanon,lpszFileName);
		return;
	}

	// Now loop through the remaining directory components until something
	// of the form <volume_name>\...\<one_or_more_dirs>\<base_name> fits.
	//
	// Assert that the whole filename doesn't fit -- this should have been
	// handled earlier.

	ASSERT(cchVolName + (int)lstrlen(lpszCur) > cchMax);

	while (cchVolName + 4 + (int)lstrlen(lpszCur) > cchMax)
	{
		do
		{
			lpszCur = _tcsinc(lpszCur);
			ASSERT(*lpszCur != '\0');
		}
		while (*lpszCur != '\\');
	}

	// Form the resultant string and we're done.
	lpszCanon[cchVolName] = '\0';
	lstrcat(lpszCanon, _T("\\..."));
	lstrcat(lpszCanon, lpszCur);
}
/////////////////////////////////////////////////////////////////////////////

BOOL FileExists(LPCTSTR szFilePath)
{
	// Use a full pathname or _access will search for the file.
	// We need to use _access instead of OpenFile() since OpenFile()
	// fails with string length > 128 characters
	LPTSTR lpszFile;
	TCHAR szBuf[_MAX_PATH];
	GetFullPathName(szFilePath, _MAX_PATH, szBuf, &lpszFile);

#if 0
	DWORD dwAttr = GetFileAttributes(szBuf);
	return (dwAttr != 0xFFFFFFFF && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0);
#else
	// surprisingly, this is much faster!
	WIN32_FILE_ATTRIBUTE_DATA find;

	if (!Compatible_GetFileAttributesEx( szBuf, GetFileExInfoStandard, &find))
	{
		return FALSE;
	}
	else
	{
		return ((find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0);
	}
#endif
}

BOOL IsFileWritable(LPCTSTR szFilePath)
{
    CFileStatus fs;
    if (!CFile::GetStatus(szFilePath, fs))
    {
        // It doesn't exist, so we'll assume it's writable...
        return TRUE;
    }

    return (fs.m_attribute & (CFile::readOnly | CFile::hidden |
        CFile::system | CFile::volume | CFile::directory)) != 0;
}

// Remember to free() the return value!
TCHAR *StripQuotes(LPCTSTR szFilePath)
{
	const TCHAR * pchLookup = szFilePath;
	TCHAR *pchSet = new TCHAR[lstrlen(szFilePath) + 1];
	TCHAR *pchRet = pchSet;

	ASSERT(pchSet != NULL);

	while (*pchLookup != _T('\0'))
	{
		if (*pchLookup != _T('"'))
 		{
			_tccpy(pchSet, pchLookup);
			pchSet = _tcsinc(pchSet);
 		}
		pchLookup = _tcsinc(pchLookup);
	}

    *pchSet = _T('\0');
	return pchRet;
}

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax)
{
	ASSERT(lpszTitle == NULL ||
		AfxIsValidAddress(lpszTitle, _MAX_FNAME));
	ASSERT(AfxIsValidString(lpszPathName, FALSE));

	// use a temporary to avoid bugs in GetFileTitle whne lpszTitle is NULL
	TCHAR szTemp[_MAX_PATH];
	LPTSTR lpszTemp = lpszTitle;
	if (lpszTemp == NULL)
	{
		lpszTemp = szTemp;
		nMax = (sizeof(szTemp) / sizeof(szTemp[0]));
	}
	// [Olympus 3582 - chauv]
	// GetFileTitle() doesn't return a name with extension
	// if user registers the extension to the system on Win95.
	// We have to rely on our cheap imitation to calculate this.
	//if (GetFileTitle(lpszPathName, lpszTemp, (WORD)nMax) != 0)
	{
		// when GetFileTitle fails, use cheap imitation
        lpszTemp = (LPTSTR)lpszPathName;
        for (LPCTSTR lpsz = lpszPathName; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // remember last directory/drive separator
            if (*lpsz == '\\' || *lpsz == '/' || *lpsz == ':')
                lpszTemp = _tcsinc(lpsz);
        }
        if (lpszTitle != NULL)
            lstrcpyn(lpszTitle, lpszTemp, nMax);
	}
	return lpszTitle == NULL ? lstrlen(lpszTemp)+1 : 0;
}

//////////////////////////////////////////////////////////////////////
// Constructors, destructors

IMPLEMENT_DYNAMIC(CDir, CObject)

CDir::~CDir
(
)
{
}

//////////////////////////////////////////////////////////////////////
// CDir::CreateFromCurrent

BOOL CDir::CreateFromCurrent
(
)
{
	TCHAR	rgchDir[MAX_PATH];

#ifdef _WIN32
	if (GetCurrentDirectory(sizeof(rgchDir), rgchDir) == 0)
#else
	if (_getcwd(rgchDir, sizeof(rgchDir)) == NULL)
#endif
		return(FALSE);

	m_strDir = rgchDir;

	return(TRUE);
}

//////////////////////////////////////////////////////////////////////
// CDir::CreateFromPath

BOOL CDir::CreateFromPath
(
	const CPath & path
)
{
	TCHAR * pch;
	ASSERT(path.IsInit());

	int ichLastSlash = path.m_ichLastSlash;
	ASSERT(ichLastSlash >= 2);

	pch = m_strDir.GetBuffer(ichLastSlash+2);
	memcpy(pch, (const TCHAR *)path.m_strCanon, ichLastSlash * sizeof(TCHAR));

	// If the resulting directory name is only two characters,
	// it must be <drive>:, and we should append a "\".
	if (ichLastSlash <= 2)
		pch[ichLastSlash++] = _T('\\');
	pch[ichLastSlash] = 0;
	m_strDir.ReleaseBuffer(ichLastSlash);

	return(TRUE);
}

//////////////////////////////////////////////////////////////////////
// CDir::CreateFromPath
// Warning: this is very expensive; Use CreateFromPath(const CPath&) if possible

BOOL CDir::CreateFromPath(const TCHAR *pszPath)
{
	CPath path;
	path.Create(pszPath);
	return(CreateFromPath(path));
}

//////////////////////////////////////////////////////////////////////
// CDir::CreateTemporaryName

BOOL CDir::CreateTemporaryName
(
)
{
	TCHAR	rgchT[MAX_PATH];
	TCHAR *	pch;
	int		cch;
	// To avoid a performance hit with checking the existence of this path, we do so only once per session
	static BOOL bTempPathChecked=FALSE;			// TRUE if we've established whether the temp path exists. If this is false, bTempPathValid is undefined.
	static BOOL bTempPathValid=FALSE;			// TRUE if we've established that the temp path does exist

	// If tmp is set, but points to a non-existent dir, then we return FALSE, as if tmp was unset
	if(bTempPathChecked && !bTempPathValid)
	{
		return FALSE;
	}

#ifdef _WIN32
	if (!GetTempPath(sizeof(rgchT), rgchT))
		return(FALSE);
#else
// HACK:
	_tcscpy(rgchT, "c:\\");
#endif

	// If the last character is '\' and this is NOT the root of
	// a drive (e.g., C:\ -- always 3 characters), remove the
	// last '\'.

	cch = _tcslen(rgchT);
	pch = rgchT + cch;
	pch = _tcsdec(rgchT, pch);

	if ((*pch == _T('\\')) && (cch != 3))
		*pch = _T('\0');

	m_strDir = rgchT;

	if(!bTempPathChecked)
	{
		bTempPathChecked=TRUE;

		// If the temporary path is set, ensure that it is usable
		if (!GetTempFileName((const TCHAR *)m_strDir, _TEXT("MVC"), 0, rgchT))
		{
			bTempPathValid=FALSE;
			m_strDir.Empty();
			return(FALSE);
		}
		else
		{
			VERIFY(DeleteFile(rgchT));
			bTempPathValid=TRUE;
		}
	}

	return(TRUE);
}


//////////////////////////////////////////////////////////////////////
// CDir::CreateFromStringEx - extended form of CreateFromString

BOOL CDir::CreateFromStringEx
(
	const TCHAR *	sz,
	BOOL fRootRelative	// if true, treat dir ending with colon as relative not root dir 
)
{
	TCHAR *	pch;
	CString	strT = sz;
	CPath	pathT;

	// Tack on a bogus filename, create a CPath object from the result,
	// and then return CreateFromPath().

	if (sz && *sz)
	{
		pch = (TCHAR *)sz + _tcslen(sz);
		pch = _tcsdec(sz, pch);
		if (!fRootRelative)
		{
			if ((*pch != _T('\\')) && (*pch != _T('/')))
				strT += _T('\\');

		}
		else
		{		// bobz 6/14/95 added check for : so c: would be left relative, not turned into "c:\"
			if ((*pch != _T('\\')) && (*pch != _T('/')) && (*pch != _T(':')) )
				strT += _T('\\');
		}

	}

	strT += _T("x");	// A filename!

	if (!pathT.Create(strT))
		return(FALSE);

	return(CreateFromPath(pathT));
}

//////////////////////////////////////////////////////////////////////
// CDir::IsRootDir

BOOL CDir::IsRootDir
(
)
const
{
	const	TCHAR *	pchT;

	if (IsUNC())
	{
		pchT = m_strDir;

		ASSERT((*pchT == _T('\\')) && (*(pchT + 1) == _T('\\')));

		// Find the '\' separating the server name and the share name.

		pchT = _tcschr(pchT + 2, _T('\\'));

		ASSERT(pchT != NULL);

		// If there is another '\' after the one we just found, it's
		// NOT a root directory.  Otherwise, it is.

		if (_tcschr(pchT, _T('\\')) == NULL)
			return(TRUE);
		else
			return(FALSE);
	}
	else
	{
		// If the name is exactly 3 characters, it's a root directory.
		// Otherwise, it's not.

		if (m_strDir.GetLength() == 3)
			return(TRUE);
		else
			return(FALSE);
	}
}

//////////////////////////////////////////////////////////////////////
// CDir::AppendSubdirName

VOID CDir::AppendSubdirName
(
	const TCHAR *	szSubdir
)
{
	// If the existing directory string DOESN'T end in '\', append one.

	if (m_strDir.GetLength() != 3)
		m_strDir += _T('\\');

	m_strDir += szSubdir;
}

//////////////////////////////////////////////////////////////////////
// CDir::RemoveLastSubdirName

VOID CDir::RemoveLastSubdirName
(
)
{
	const	TCHAR *		pchBase;
	const	TCHAR *		pchCur;
	const	TCHAR *		pchPrevBackslash;
			int			i;

	if (IsRootDir())
		return;

	// Find the first '\' following the volume name.

	pchBase = (const TCHAR *)m_strDir;
	pchCur = pchBase + 2;					// Skip "C:" or leading "\\"

	if (IsUNC())
	{
		ASSERT((m_strDir[0] == _T('\\')) && (m_strDir[1] == _T('\\')));

		// First skip to the '\' between the server name and the share name,
		// then skip to the '\' after the share name.

		for (i=0 ; i<2 ; ++i)
		{
			while (*pchCur != _T('\\'))
			{
				pchCur = _tcsinc((TCHAR *)pchCur);
				ASSERT(*pchCur != _T('\0'));
			}

			if (i == 0)
				pchCur = _tcsinc((TCHAR *)pchCur);
		}
	}

	ASSERT(*pchCur == _T('\\'));

	// Now look for '\' characters until we've found the last one.

	pchPrevBackslash = pchCur;

	for (;;)
	{
		do
		{
			pchCur = _tcsinc((TCHAR *)pchCur);
		}
		while ((*pchCur != _T('\\')) && (*pchCur != _T('\0')));

		if (*pchCur == _T('\\'))
			pchPrevBackslash = pchCur;
		else
			break;
	}

	// Truncate the directory name at that point (the last '\').

	ASSERT(*pchPrevBackslash == _T('\\'));

	m_strDir = m_strDir.Left(pchPrevBackslash - pchBase);

	// Finally, we may have truncated the directory to "C:".  If
	// this is the case, tack on the '\'.

	if (m_strDir.GetLength() == 2)
		m_strDir += _T('\\');
}

//////////////////////////////////////////////////////////////////////
// CDir::MakeCurrent

// Make this object the current working directory.  May fail
// if the directory no longer exists (e.g., a floppy drive).

BOOL CDir::MakeCurrent() const
{
	// Warning: Win32 SetCurrentDirectory() is "broken"--must use _chdir()!
	const TCHAR *szDir = m_strDir;
	if (*szDir && *_tcsinc(szDir) == _T(':'))
	{
		ASSERT( _tclen( szDir ) == 1 );
		UINT ch = _tcsnextc(szDir);
		ASSERT(_istalpha(ch));
		if (_chdrive(_totupper(ch) + 1 - 'A') != 0)
			return FALSE;
	}
	return (_tchdir(m_strDir) == 0);
}

//////////////////////////////////////////////////////////////////////
// CDir::operator ==

int CDir::operator ==
(
	const CDir &	dirCmp
)
const
{
	return (m_strDir.CompareNoCase(dirCmp.m_strDir) == 0);
}

//////////////////////////////////////////////////////////////////////
// CDir::MakeDirectory()
BOOL CDir::MakeDirectory (LPCTSTR lpszPathName) const
{
    CString strBuffer;
	strBuffer = lpszPathName;

    //
    // Check to see if the given directory already exists and 
    // return TRUE if successful.
    //
 
	DWORD dwAttribs = GetFileAttributes(strBuffer);
	if (dwAttribs != 0xFFFFFFFF && (dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
           return TRUE;
 
    //
    // Try to create the subdirectories (if any) named in the path.
    //
    
 	TCHAR* pStart = strBuffer.GetBuffer(strBuffer.GetLength() + 1);
	TCHAR* pCurr = pStart;

    while (*pCurr != _T('\0'))
    {
        if (*pCurr == _T('\\'))
		{
            *pCurr = _T('\0');
            CreateDirectory(pStart,NULL);
            *pCurr = _T('\\');
        }
        pCurr = _tcsinc(pCurr);
    }
	CreateDirectory(pStart, NULL);
	strBuffer.ReleaseBuffer();

    //
    // Try again to see if the given directory exists and 
    // return TRUE if successful.
    //

	dwAttribs = GetFileAttributes(strBuffer);
	if (dwAttribs != 0xFFFFFFFF && (dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
           return TRUE;
 
    //
    // If fopen failed again, the path name must be invalid.
    //
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//

CCurDir::CCurDir(const TCHAR* szPath, BOOL bFile /*=FALSE*/)
{
	CPath path;

	m_dir.CreateFromCurrent();

	if (szPath != NULL)
	{
		if (!bFile)
			CreateFromString(szPath);
		else if (path.Create(szPath))
			CreateFromPath(path);

		MakeCurrent();
	}
}

CCurDir::CCurDir(const CDir& dir)
	: CDir(dir)
{
	m_dir.CreateFromCurrent();
	MakeCurrent();
}

CCurDir::CCurDir()
{
	m_dir.CreateFromCurrent();
}

CCurDir::~CCurDir()
{
	m_dir.MakeCurrent();
}

// This function returns true if the path passed in is UNC.
BOOL IsUNCPath( LPCTSTR lpszPath )
{
	ASSERT( lpszPath != NULL );
	return (lpszPath[0] == _T('\\') && lpszPath[1] == _T('\\'));
}

// This function replaces all '/' characters with '\\' characters
void AdjustPathSymbols( LPTSTR lpszPath )
{
	ASSERT( lpszPath != NULL );
	PTCHAR psz = lpszPath;

	while (*psz != _T('\0'))
	{
		if (*psz == _T('/'))
			*psz = _T('\\');
		psz = _tcsinc(psz);
	}
}

// This function searches for lpszFind in lpszArray, which should be formatted
// as "<string1>\0<string2>\0<last string>\0\0"
int FindInStringArray( LPCTSTR lpszArray, LPCTSTR lpszFind )
{
	ASSERT( lpszArray != NULL && lpszFind != NULL );
	LPCTSTR psz = lpszArray;
	UINT nLen = lstrlen(lpszFind);

	while (*psz != _T('\0'))
	{
		if (_tcsnicmp(psz, lpszFind, nLen) == 0)
			return psz-lpszArray;
		psz = psz + lstrlen(psz) + 1;	
	}
	return -1;
}

// This routine returns a pointer to the character after the last '\' in the drive (or UNC)
LPTSTR SkipDrive( LPTSTR lpszPath )
{
	ASSERT( lpszPath != NULL );
	PTCHAR psz = lpszPath;

	if (IsUNCPath(lpszPath)) // this is a UNC path
	{
		// find the end of the computer/share name
		int cBkSp = 0;
		while (*psz != _T('\0'))
		{
			if (*psz == _T('\\'))
				if (++cBkSp == 4)	// psz now points to the \ after the share name
					break;
			psz = _tcsinc( psz );
		}
		if (cBkSp != 4 || *psz == _T('\0'))
			return NULL;	// invalid path
	}
	else
	{
		// find the end of the drive name (should always be in the form "C:\")
		psz = &lpszPath[2];
	}

	// psz should now point to the '\' after the share name if this is a UNC path,
	// or the '\' after the drive letter
	ASSERT( *psz == _T('\\') );

	return ++psz;
}

// On Win95, this function changes an all caps filename to Mixed case.
void BeautifyAllCaps(LPTSTR pszFilename)
{
	ASSERT(pszFilename != NULL);

	// Do nothing on NT...
	if (!theApp.m_bOnChicago)
		return;

	// Are there any lower case letters?
	LPTSTR psz = pszFilename;
	while (*psz != _T('\0') && *psz != _T('\\'))
	{
		if (_istlower(*psz))
			return;

		psz = _tcsinc(psz);
	}

	// Change all except the first to lower case.
	psz = _tcsinc(pszFilename);
	while (*psz != _T('\0') && *psz != _T('\\'))
	{
		if (_istupper(*psz))
			*psz = (TCHAR)_totlower(*psz);

		psz = _tcsinc(psz);
	}
}

// This function changes rFilename to match the case of the
// actual filename (the way it is in the directory entry).
BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir /*= NULL*/ )
{
#ifdef _DEBUG
	TCHAR szOldPath[MAX_PATH];
	::GetFullPathName( rFilename, MAX_PATH-1, szOldPath, NULL );
#endif

	if (rFilename.IsEmpty())
		return FALSE;

	// Get a fully qualified filename
	TCHAR szPath[MAX_PATH];
	DWORD dwLen = ::GetFullPathName( rFilename, MAX_PATH-1, szPath, NULL );
	if (dwLen == 0 || dwLen >= MAX_PATH)
		return FALSE;	// can't fix a path this long...

	if (lstrlen(szPath) < 4)	// need at least a drive and filename (shortest legal filename is "C:\A")
		return FALSE; // can't fix a path this short

	// replace all / with \ characters
	AdjustPathSymbols( szPath );

	// lpszDir can be used as a case hint; i.e. if you are checking the
	// case of several files in the same directory, you can get the case
	// of the directory, and then checking the case for each file is much
	// quicker.
	PTCHAR psz = NULL;
	BOOL bDirSet = FALSE;
	if (lpszDir != NULL)
	{
		LPCTSTR pSlash = GetLastSlash(szPath);
		ASSERT(pSlash != NULL);
		int chLen = _tcslen(lpszDir);
	// if lpszDir ends with a slash, strip this one, so we don't get
	// C:\\file_at_root.c
#ifndef _DEBUG
		if (chLen == 3)
#endif
		{
			LPCTSTR lastDirChar = _tcsdec(lpszDir, lpszDir+chLen);
			if (lastDirChar != NULL
				&& (lastDirChar[0] == '\\' || lastDirChar[0] == '/'))
			{
				ASSERT(chLen == 3);
				pSlash = _tcsinc(pSlash);
			}
		}
		CString strFile = pSlash; // save off '\' + filename

		_tcscpy( szPath, lpszDir );
		psz = szPath + chLen;
		_tcscpy(psz, strFile);
		bDirSet = TRUE;
	}

	if (!bDirSet)
	{
		psz = SkipDrive( szPath );	// skip psz to after the drive or UNC path
		if (psz == NULL)	// the path was invalid
			return FALSE;
	}


	CString strOldFileName = rFilename;
		
	// FUTURE: Don't know how to get the actual case for the computer/share names
	// used in a UNC path...

	// now fix each component of the path
	TCHAR cTemp;
	ASSERT( psz != NULL );

	cTemp = *psz;		// We build rFilename one component at a time.
	*psz = _T('\0');
	rFilename = szPath;
	*psz = cTemp;
	while (*psz != _T('\0'))
	{
		WIN32_FIND_DATA ffd;
		if ( *psz == _T('\\') )
		{
			rFilename += *psz;
			psz++;
		}

		// Get a pointer to the end of this path segment (either the next '\' or the end of the path)
		PTCHAR pszEnd = _tcschr( psz, _T('\\') );
		if (pszEnd == NULL)
			pszEnd = psz + lstrlen(psz);
		ASSERT( *pszEnd == _T('\\') || *pszEnd == _T('\0') );	// must be pointing at the end of a segment

		// Do a FindFirst to find the actual directory entry
		cTemp = *pszEnd;
		*pszEnd = _T('\0');
		PTCHAR szTrueName = psz;
		if (_tcschr(psz, _T('*')) == NULL && _tcschr(psz, _T('?')) == NULL )	// if it includes widecards, can't do anything
		{
			HANDLE hFind = FindFirstFile( szPath, &ffd );
			if (hFind == INVALID_HANDLE_VALUE)
			{
				rFilename = strOldFileName;
				return TRUE;
			}
			VERIFY( FindClose( hFind ) );

			szTrueName = ffd.cFileName;
		}
		BeautifyAllCaps(szTrueName);
		rFilename += szTrueName;
		*pszEnd = cTemp;

		psz = pszEnd;
	}

	//ASSERT( _tcsicmp(szPath, szOldPath) == 0 );
	//rFilename = szPath;

	return TRUE;
}

// This function returns a pointer to a string which contains lpszExtension
// in a case to match lpszFilename. I.E. if lpszFilename is uppercase, GetExtensionCase
// returns a pointer to a copy of lpszExtension which is all uppercase.
// Likewise, is lpszExtension is all lower or mixed case, it returns a pointer to
// a copy of lpszExtension which is all lower case.
LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension )
{
	TCHAR szFilename[ MAX_PATH ];
	if (SushiGetFileTitle( lpszFilename, szFilename, MAX_PATH ) != 0)
		return lpszExtension;	// invalid filename

	BOOL bFoundL = FALSE, bFoundU = FALSE;
	PTCHAR pChar = szFilename;
	while (pChar != NULL && *pChar != _T('\0'))
	{
		if (_istupper(*pChar))
			bFoundU = TRUE;
		else if (_istlower(*pChar))
			bFoundL = TRUE;

		pChar = _tcsinc( pChar );
	}

	static CString strExt;
	strExt = lpszExtension;
	if (bFoundU && !bFoundL)	// only upper
	{
		// make output upper
		strExt.MakeUpper();
	}
	else	// either mixed or all lower - make extension lower
	{
		strExt.MakeLower();
	}

	return strExt;
}

static TCHAR szEllipse[] = _T("...\\");
#define cbEllipse (sizeof(szEllipse) / sizeof(TCHAR) - sizeof(TCHAR))

BOOL GetDisplayFile(CString& rFilename, CDC* pDC, int& cxPels)
{
	// This function is used to calculate the best path string
	// to display that is cxPels pixels wide or narrower.
	ASSERT_VALID(pDC);

	if (rFilename.IsEmpty())
		return FALSE;

	// Get a fully qualified filename
	TCHAR szPath[MAX_PATH + 1];
	TCHAR *pszFilePart;
	DWORD dwLen = ::GetFullPathName(rFilename, MAX_PATH, szPath, &pszFilePart);
	if (dwLen == 0 || dwLen > MAX_PATH)
		return FALSE;	// can't fix a path this long

	if (lstrlen(szPath) < 4)	// need at least a drive and filename (shortest legal filename is "C:\A")
		return FALSE; // can't fix a path this short

	rFilename = szPath;
	CSize size = pDC->GetTextExtent(rFilename);
	int nExtent = size.cx;
	if (nExtent <= cxPels)
	{
		cxPels = nExtent;
		return TRUE;
	}

	if (nExtent > cxPels)
	{
		CString strTemp = szPath, strReturn;
		TCHAR  *lpszTemp = SkipDrive(szPath);
		strTemp = strTemp.Left(lpszTemp - szPath);
		strTemp += _TEXT("...\\");

		while (nExtent > cxPels)
		{
			strReturn = strTemp;

			// strip out directories until wExtent not greater
			lpszTemp = _tcschr(lpszTemp, _T('\\'));

			if (lpszTemp)
			{
				lpszTemp = _tcsinc(lpszTemp);
				strReturn += lpszTemp;
			}
			else
				break;

			size = pDC->GetTextExtent(strReturn);
			nExtent = size.cx;
		}

		rFilename = strReturn;
		cxPels = nExtent;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//
//		The format of a multiple-file select string is:
//
//			<dir-name> <file1> <file2> ...
//

CFileOpenReturn::CFileOpenReturn (const _TCHAR * szRawString /* = NULL */)
{
	m_pchData = (szRawString != NULL) ? _tcsdup (szRawString) : NULL;
	m_bBufferInUse = FALSE;
	m_bArrayHasChanged = FALSE;

	GenArrayFromBuffer ();
}


CFileOpenReturn::~CFileOpenReturn ()
{
	if (m_pchData)
		free (m_pchData);

	ClearNamesArray ();
}		


void CFileOpenReturn::ReInit (const _TCHAR * szRawString)
{
	SetBuffer (szRawString);
	GenArrayFromBuffer ();
}


void CFileOpenReturn::ClearNamesArray ()
{
int cNames = m_rgszNames.GetSize();

	for (int i = 0; i < cNames; i++)
		free (m_rgszNames[i]);
		
	m_rgszNames.RemoveAll();
}


///// GenArrayFromBuffer - Set internal state to match current raw string value
//
///
void CFileOpenReturn::GenArrayFromBuffer ()
{
	// Assume no data in buffer
	m_cbData = 0;
	m_bSingle = TRUE;
	ClearNamesArray ();

	if (m_pchData != NULL)
	{
		m_cbData  = strlen (m_pchData) + 1;	// Bytes!

		if (!(m_bSingle = (NULL == _tcschr (m_pchData, ' '))))
		{
			int i;
			_TCHAR * pchWalk;
			for (pchWalk = m_pchData, i = 0; *pchWalk; i++)
			{
				_TCHAR * pchCurName = pchWalk;
				_TCHAR chPrev;
				if (NULL != (pchWalk = _tcschr (pchWalk, ' ')))
				{
					chPrev = *pchWalk;
					*pchWalk = '\0';
				}

				m_rgszNames.SetAtGrow (i, _tcsdup(pchCurName));

				if (pchWalk != NULL)
				{
					*pchWalk = chPrev;
					if (NULL == (pchWalk = _tcsspnp (pchWalk, " ")))
						break;
				}
				else
					break;

			}
		}
	}
}


///// GenBufferFromArray - Update buffer to match names array
//
///
void CFileOpenReturn::GenBufferFromArray ()
{
	if (!IsSingle())
	{
		ASSERT (m_pchData != NULL);
		ASSERT (!m_bBufferInUse);

		// First we need to know how long the buffer should be.
		// This is the sum of the individual strings, plus a space
		// between each one and a nul terminator.
  		int cNames = m_rgszNames.GetSize();
		for (int i = 0, cbrgNames = 0; i < cNames; i++)
		{
			cbrgNames += strlen ((const char *)m_rgszNames[i]) + 1;
		}

		// Now we can allocate a new one.
		free (m_pchData);
		m_pchData = (_TCHAR *)malloc (cbrgNames);

		// Now we copy each string into the buffer.
		_TCHAR * pchWalk = m_pchData;
		for (i = 0, cbrgNames = 0; i < cNames; i++)
		{
			_tcscpy (pchWalk, (const char *)m_rgszNames[i]);
			pchWalk += strlen ((const char *)m_rgszNames[i]);
			*pchWalk++ = ' ';
		}

		// The final space was put where we should really have a nul
		pchWalk[-1] = '\0';
	}
	else
		; // Single-choice case doesn't use the name array.
}


///// GetPathname - Fill a string with the full pathname of the i'th file
//
//	A FALSE return means either that there is no i'th file.
//
//	For multiple file selects, the full pathname must be assembled from the dir name
//	and filename.
//  For single file selects, COMMDLG has already generated the full path.
///
BOOL CFileOpenReturn::GetPathname (int i, CString& strPath) const
{
	if (!IsSingle())
	{
		// A multiple select has at least a dir name and a file name.
		ASSERT (m_rgszNames.GetSize() >= 2);
		ASSERT (!m_bBufferInUse);

   		if (i + 1 < m_rgszNames.GetSize())
		{
			strPath = (_TCHAR *)m_rgszNames[0];

			if (strPath.ReverseFind ('\\') != strPath.GetLength() - 1)
				strPath += '\\';

			strPath += (TCHAR *)m_rgszNames[i+1];	// +1 because [0] is the dir name

			// Chicago bogosity.  COMMDLG leaves dots at end of filenames.
			int cbStrLessOne = strPath.GetLength () - 1;
			if (strPath.ReverseFind ('.') == cbStrLessOne)
			{
				// The effect of these calls is to shorten the string by one character
				strPath.GetBuffer (cbStrLessOne);
				strPath.ReleaseBuffer (cbStrLessOne);
			}

			return TRUE;
		}
		else
			return FALSE;
	}
	else
	if (i == 0)
	{
		strPath = m_pchData;
		return TRUE;
	}
	else
		return FALSE;
}


///// GetBuffer - Ensure correct size for buffer and return ptr to it
//
//	This gives permission to the caller to do whatever it wants with our buffer.
//	When the caller is done with the buffer, it must call ReleaseBuffer() so we
//	can synchronize with the new contents.
//	This function also guarantees a minimum size for the buffer, preserving the
//	current contents.
///
_TCHAR * CFileOpenReturn::GetBuffer (int cbBufferNew)
{
	if (cbBufferNew > m_cbData)
	{
		_TCHAR * pchNew = (_TCHAR *)malloc (cbBufferNew);

		if (m_cbData)
		{
			ASSERT (m_pchData != NULL);
			memcpy (pchNew, m_pchData, m_cbData);
			free (m_pchData);
		}
		else
			*pchNew = '\0';

		m_cbData = cbBufferNew;
		m_pchData = pchNew;
	}

	m_bBufferInUse = TRUE;
	return m_pchData;
}


///// ChangeExtension - Change the extension of the i'th file
//
///
void CFileOpenReturn::ChangeExtension (int i, const CString& strExtNew)
{
	ASSERT (!m_bBufferInUse);

	CString strFileNameCur (IsSingle() ? m_pchData : (const char *)m_rgszNames[i+1]);

	if (strFileNameCur.IsEmpty())
		return;

	CString strExtCur = GetExtension (strFileNameCur);

	CString strFileNameNew ((strExtCur.IsEmpty()
								? strFileNameCur
								: strFileNameCur.Left(strExtCur.GetLength()))
							+ '.'	// Assume we need to add the dot.
							+ strExtNew);

	_TCHAR * szFileNameNew = _tcsdup (strFileNameNew);

	if (IsSingle())
	{
		free (m_pchData);
		m_pchData = szFileNameNew;
		m_cbData = strFileNameNew.GetLength() + 1;
	}
	else
	{
		free (m_rgszNames[i+1]);
		m_rgszNames[i+1] = szFileNameNew;
	}

	m_bArrayHasChanged = TRUE;
}
	

///// CopyBuffer
//
///
void CFileOpenReturn::CopyBuffer (_TCHAR * szTarget)
{
	if (IsDirty())
		GenBufferFromArray ();

	_tcscpy (szTarget, m_pchData);
}


///// SetBuffer
//
///
void CFileOpenReturn::SetBuffer (const _TCHAR * szRawString)
{
	if (m_pchData)
		free (m_pchData);

	if (szRawString == NULL)
	{
		m_pchData = NULL;
		m_cbData = 0;
	}

	_TCHAR * pchSpace = _tcschr (szRawString, ' ');
	int cbSzRaw = strlen (szRawString) + 1;

	if (pchSpace)
	{	// This should be a multi-file select, but we don't trust it.
		CString strDirName;
		_TCHAR * pchDirName = strDirName.GetBuffer (pchSpace - szRawString);
		_tcsncpy (pchDirName, szRawString, pchSpace - szRawString);
		strDirName.ReleaseBuffer (pchSpace - szRawString);

		struct _stat statbuf;

		if (_stat (strDirName, &statbuf) || !(statbuf.st_mode & _S_IFDIR))
		{	// First string is NOT a directory!
			CDir dirCur;

			VERIFY (dirCur.CreateFromCurrent ());

			int cbDirCur = strlen (dirCur) + 1;

			m_pchData = (TCHAR *)malloc (cbDirCur + cbSzRaw);

			_tcscpy (m_pchData, dirCur);
			m_pchData[cbDirCur-1] = ' ';
			_tcscpy (m_pchData + cbDirCur, szRawString);

			m_cbData = cbDirCur + cbSzRaw;

			return;
		}
	}

	m_pchData = _tcsdup (szRawString);
	m_cbData = cbSzRaw;
}

//
// Support for new win32 api, GetFileAttributesEx
//

static BOOL WINAPI Choose_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);

static BOOL WINAPI Slow_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);

// Initialize g_pGetFileAttributesEx = Choose_GetFileAttributesEx.
BOOL (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation) = Choose_GetFileAttributesEx;

static BOOL WINAPI Choose_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	//
	// Block any other threads using mutex.  This is normally a one shot deal.
	//
	TCHAR szMutexName[50];

	//
	// Create a mutex name that is unique each process.
	//
	_stprintf( szMutexName, _T("Choose_GetFileAttributesEx:Shell:%lX"), GetCurrentProcessId() );

	HANDLE hMutex = CreateMutex( NULL, FALSE, szMutexName );
	if (NULL==hMutex)
	{
		ASSERT(0);
		if (&Choose_GetFileAttributesEx==g_pGetFileAttributesEx)
		{
			g_pGetFileAttributesEx = &Slow_GetFileAttributesEx;
			TRACE("::Choose_GetFileAttributesEx: Slow_GetFileAttributesEx was selected because of failure\n");
		}
	}
	else
	{
		// Time out after 10 seconds. 
		DWORD dwWait = WaitForSingleObject(hMutex, 10000L);

		switch(dwWait)
		{
		case WAIT_OBJECT_0:
			if (&Choose_GetFileAttributesEx==g_pGetFileAttributesEx)
			{
				HINSTANCE hLib = GetModuleHandle( _T("kernel32.dll") );
				if (NULL!=hLib)
				{
#ifdef _UNICODE
					FARPROC lpProc = GetProcAddress(hLib, "GetFileAttributesExW" );
#else
					FARPROC lpProc = GetProcAddress(hLib, "GetFileAttributesExA" );
#endif
					if (NULL!=lpProc)
					{
						g_pGetFileAttributesEx = 
							(BOOL (WINAPI *)( LPCTSTR, GET_FILEEX_INFO_LEVELS,LPVOID))lpProc;
						TRACE("::Choose_GetFileAttributesEx: GetFileAttributesEx was selected\n");
					}
					else
					{
						g_pGetFileAttributesEx = &Slow_GetFileAttributesEx;
						TRACE("::Choose_GetFileAttributesEx: Slow_GetFileAttributesEx was selected\n");
					}
				}

			}
			VERIFY(ReleaseMutex(hMutex));
			break;

		case WAIT_TIMEOUT:
		case WAIT_ABANDONED:
		default:
			//
			// Use Slow_GetFileAttributesEx when checking for GetFileAttributesEx fails.
			//
			ASSERT(0);
			if (&Choose_GetFileAttributesEx==g_pGetFileAttributesEx)
			{
				g_pGetFileAttributesEx = &Slow_GetFileAttributesEx;
			}
			TRACE("::Choose_GetFileAttributesEx: Slow_GetFileAttributesEx was selected because of failure\n");
			break;
		}
		CloseHandle(hMutex);
	}
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}

//
// Slow_GetFileAttributesEx is used when GetFileAttributesEx is unsupported.
//
BOOL WINAPI Slow_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	WIN32_FILE_ATTRIBUTE_DATA*  pFileData = (WIN32_FILE_ATTRIBUTE_DATA*)lpFileInformation;

	ASSERT(GetFileExInfoStandard==fInfoLevelId);

	WIN32_FIND_DATA find;
	HANDLE hfind = ::FindFirstFile(lpFileName, &find);

	if (hfind != INVALID_HANDLE_VALUE)
	{
		::FindClose(hfind);

		pFileData->dwFileAttributes = find.dwFileAttributes;
		pFileData->ftCreationTime = find.ftCreationTime; 
		pFileData->ftLastAccessTime = find.ftLastAccessTime; 
		pFileData->ftLastWriteTime = find.ftLastWriteTime; 
		pFileData->nFileSizeHigh = find.nFileSizeHigh; 
		pFileData->nFileSizeLow = find.nFileSizeLow; 

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\partmpl.cpp ===
// partmpl.cpp : Part document template class definition
//

#include "stdafx.h"
#include <io.h>
#include <dde.h>
#include "main.h"
#include "prjapi.h"
#include "utilauto.h"

IMPLEMENT_DYNAMIC(CPartTemplate, CMultiDocTemplate)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CPartTemplate

CPartTemplate::CPartTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
	CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass,
	CPackage* pPackage, CPacket* pPacket, REFCLSID clsid,
	LPCTSTR szAutoType /* = NULL */)
		: CMultiDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass)
{
	ASSERT(m_docList.IsEmpty());
	ASSERT(pDocClass != NULL);

	m_hMenuShared = NULL;
	m_hAccelTable = NULL;
	m_nUntitledCount = 0;   // start at 1
	
	m_pPackage = pPackage;
	m_pPacket = pPacket;

	// CLSID_NULL is reserved for DocObject types.
	ASSERT(clsid != CLSID_NULL);
	m_clsid = clsid;

	m_strAutoType = szAutoType;
	m_nIconID = nIDResource;
	m_TabName = Files;
}

CPartTemplate::~CPartTemplate()
{
}

void CPartTemplate::SetContainerInfo()
{
	m_hMenuInPlace = theCmdCache.GetOleMenu();
}

CDocument* CPartTemplate::OpenDocumentFile(const TCHAR* pszPathName,
		BOOL bMakeVisible /*=TRUE*/)
{
	// NOTE: The only difference between this function and the one in
	// CMultiTemplate is this one initializes the appropriate Packet
	// for the type.
	
	CDocument* pDocument = CreateNewDocument();

#ifndef NEWPROJ
	if (pDocument == NULL)
	{
		// HACK_M2: Here we differ from MFC by adding paths of failed opens 
		// to the recent file list.  This was done because old-style project
		// files did not have part doc's so CreateNewDocument() always
		// "failed"  This hack gets those projects onto the MRU...
		if (pszPathName != NULL)
			AfxGetApp()->AddToRecentFileList(pszPathName);
		
		TRACE0("CDocTemplate::CreateNewDocument returned NULL\n");
//		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		return NULL;
	}
#endif
	ASSERT_VALID(pDocument);

	BOOL bOldAuto = pDocument->m_bAutoDelete;
	pDocument->m_bAutoDelete = FALSE; // don't destroy if something goes wrong
	CMDIChildWnd* pFrame = (CMDIChildWnd*) CreateNewFrame(pDocument, NULL);
	pDocument->m_bAutoDelete = bOldAuto;

	if (pFrame == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
		delete pDocument;       // explicit delete on error
		return NULL;
	}
	ASSERT_VALID(pFrame);
	ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)));

	if (pszPathName == NULL)
	{
		// create a new document - with default document name
		UINT nUntitled = m_nUntitledCount + 1;

		CString strDocName;
		if (GetDocString(strDocName, CDocTemplate::docName) &&
			!strDocName.IsEmpty())
		{
			char szNum[8];
			wsprintf(szNum, "%d", nUntitled);
			strDocName += szNum;
		}
		else
		{
			// use generic 'untitled' - ignore untitled count
			VERIFY(strDocName.LoadString(AFX_IDS_UNTITLED));
		}
		pDocument->SetTitle(strDocName);

		if (!pDocument->OnNewDocument())
		{
			// user has be alerted to what failed in OnNewDocument
			TRACE0("CDocument::OnNewDocument returned FALSE\n");
			pFrame->DestroyWindow();
			return NULL;
		}

		// it worked, now bump untitled count
		m_nUntitledCount++;
	}
	else
	{
		// open an existing document
		if (!pDocument->OnOpenDocument(pszPathName))
		{
			// user has be alerted to what failed in OnOpenDocument
			TRACE0("CDocument::OnOpenDocument returned FALSE\n");
			pFrame->DestroyWindow();
			return NULL;
		}
	}

	// Initialize the view's Packet pointer
	POSITION pos = pDocument->GetFirstViewPosition();
	CPartView* pPartView = (CPartView*) pDocument->GetNextView(pos);
	ASSERT(pPartView && pPartView->IsKindOf( RUNTIME_CLASS(CPartView) ));
	CPartTemplate* pTemplate = (CPartTemplate*) pDocument->GetDocTemplate();
	ASSERT(pTemplate && pTemplate->IsKindOf( RUNTIME_CLASS(CPartTemplate) ));
	pPartView->m_pPacket = pTemplate->m_pPacket;

	InitialUpdateFrame(pFrame, pDocument);
	pFrame->OnUpdateFrameMenu(TRUE, pFrame, NULL);

	return pDocument;
}

void CPartTemplate::InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
	BOOL bMakeVisible /* = TRUE */)
{
	ASSERT_VALID(pFrame);

	// if the frame does not have an active view, set to first pane
	if (pFrame->GetActiveView() == NULL)
	{
		CWnd* pWnd = pFrame->GetDescendantWindow(AFX_IDW_PANE_FIRST);
		if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CView)))
		{
			pFrame->SetActiveView((CView*)pWnd,
				!CPartFrame::s_bLockFrame && !CPartFrame::IsWorkspaceLocked());
		}
	}

	if (pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
		((CPartFrame*) pFrame)->OnToolbarStatus();

	if (!CPartFrame::IsWorkspaceLocked())
	{
		// send initial update to all views (and other controls) in the frame
		pFrame->SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE);

		// finally, activate the frame
		// (send the default show command unless the main desktop window)
		int nCmdShow = -1;      // default
		if (pFrame == AfxGetApp()->m_pMainWnd)
			nCmdShow = AfxGetApp()->m_nCmdShow; // use the parameter from WinMain
		pFrame->ActivateFrame(nCmdShow);

		// now that the frame is visible - update frame counts
		if (pDoc != NULL)
		{
			pDoc->UpdateFrameCounts();
			pFrame->OnUpdateFrameTitle(TRUE);
		}
	}

	// at this point the frame should be properly linked to the document
	ASSERT(pDoc == NULL || pFrame->GetActiveDocument() == pDoc);
}

BOOL CPartTemplate::SaveAll( 
						BOOL bQuery /*= FALSE*/, 
						UINT nFlags /*= FILTER_NONE*/)
{
	CPartDoc* pDoc;

	POSITION pos = GetFirstDocPosition();
	while (pos)
	{
		pDoc = (CPartDoc *) GetNextDoc(pos);
		ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));
		
		// Give the document a chance to filter itself.
		if (pDoc->IsFiltered(nFlags))
			continue;

		// Save:
		if (bQuery) 
		{
			if (!pDoc->SaveModified ()) return FALSE;
		}	
		else if (pDoc->IsModified())
		{
			BSTR	bstrLang = NULL;
			
			// If the Doc is untitled,
			// then activate one of its views and call DoSave (NULL) which
			// will bring a a file name dialog.  This is just like OnFileSave/
			// The caller is responsible for restoring the origninal view:
			//
			// skip this code if, we get a valid language name that is "Microsoft TSQL",
			// "Microsoft SQL", or "Oracle SQL+" -- in that case we want to call DoSave
			//	with an empty pathname, which will appropriately save. these strings are
			//	guaranteed to be not localized (DTG package).
			//
			if (pDoc->GetPathName().IsEmpty() && pDoc->GetFirstViewPosition() != NULL &&
				!(SUCCEEDED(pDoc->GetLanguageName(&bstrLang))
					&& bstrLang
					&& (!wcscmp(L"Microsoft TSQL", bstrLang) ||
						!wcscmp(L"Microsoft SQL", bstrLang) ||
						!wcscmp(L"Oracle PL/SQL", bstrLang) ||
						!wcscmp(L"Oracle SQL+", bstrLang)
					   )
				 )
			   )
			{
				POSITION pos = pDoc->GetFirstViewPosition();
				CView* pView = pDoc->GetNextView(pos);
				CPartFrame* pFrame = (CPartFrame*) pView->GetParent();
				while (pFrame != NULL && !pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
					pFrame = (CPartFrame*) pFrame->GetParent();

				if (pFrame != NULL)
				{
					((CMDIFrameWnd *) theApp.m_pMainWnd)->MDIActivate(pFrame);

					if (!pDoc->DoSave(NULL))
						return FALSE;
				}
			}
			else if (!pDoc->DoSave(pDoc->GetPathName() )) return FALSE;

			if (bstrLang)
				::SysFreeString(bstrLang);
		}
	}
	return TRUE;
}

CDocTemplate::Confidence CPartTemplate::MatchDocType(const TCHAR* pszPathName,
					CDocument*& rpDocMatch)
{
	Confidence confidence = CDocTemplate::MatchDocType(pszPathName, rpDocMatch);
	if (confidence < yesAttemptNative)
		confidence = noAttempt; // you have to positive!
	return confidence;
}

BOOL CPartTemplate::CanBeAddedToProject(IPkgProject *pProject)
{
	return TRUE;
}

// Default implementation creates a new file, gives it a name and adds it to
// a project if pProject is not NULL
CPartDoc *CPartTemplate::NewDocumentFile(LPCTSTR szFileName, IPkgProject *pProject, LPCTSTR szFolder)
{
	USES_CONVERSION;
	CString strFileName = szFileName;
	CPartDoc *pDoc = (CPartDoc *)OpenDocumentFile(NULL);
	ASSERT(pDoc == NULL || pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));

	if (pDoc != NULL)
	{
		if (!strFileName.IsEmpty())
		{
			BOOL bSave = pDoc->DoSave(strFileName);
			if ( bSave && pProject != NULL)
			{
				LPCOLESTR wstr = T2OLE(szFileName);
				LPOLESTR wstrcopy = (LPOLESTR)malloc((wcslen(wstr)+1) * sizeof(wchar_t));
				wcscpy(wstrcopy, wstr);

				pProject->AddFiles((LPCOLESTR *)&wstrcopy, 1, T2OLE(szFolder));
				free(wstrcopy);
			} 
			if (!bSave){				
				//REVIEW: This is probably not enough if we failed to create the doc,
				//do we need to take it out of some lists or something?
				pDoc->OnCloseDocument();
				
			}
		}
	}
	return pDoc;
}

HICON CPartTemplate::GetIcon() 
{
   return ::LoadIcon(GetPackage()->HInstance(), MAKEINTRESOURCE(GetIconID()));
}

CPartTemplate::FileNewTabType CPartTemplate::GetTabType(void)
{
   CString strName;
   if(GetDocString(strName, CDocTemplate::fileNewName))
      return strName.IsEmpty() ? newnone : newfile;
   return newnone;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\provider.cpp ===
// provider.cpp : implementation for node provider interface classes:
//				  CDefProvidedNode (abstract class)
//

#include <stdafx.h>

#ifdef _DEBUG
#undef THIS_FILE

static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

////////////////////////////////////////////////////////////////////////////

CDefProvidedNode::CDefProvidedNode()
{
}

CDefProvidedNode::~CDefProvidedNode()
{
}

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\proppage.cpp ===
#include "stdafx.h"

#include "util.h"
#include "resource.h"

#include <prjapi.h>
#include <prjguid.h>
#include <oleipcid.h>
#include "ipcslob.h"
#include <ocdevo.h>

#include "sheet.h"
#include "allpage2.h"

// IID_IForm needed for ISBug: 7249 - defined in forms3.h which wont compile
// in the devstudio tree
// {04598fc8-866c-11cf-ab7c-00aa00c08fcf}
DEFINE_GUID(IID_IForm, 0x04598fc8, 0x866c, 0x11cf, 0xab, 0x7c, 0x0, 0xaa, 0x0, 0xc0, 0x8f, 0xcf);
#include "shldocs_.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Globals

CSheetWnd *g_PropSheet;
BOOL g_PropSheetVisible = FALSE;

/////////////////////////////////////////////////////////////////////////////
//	C3dPropertyPage

IMPLEMENT_DYNAMIC(C3dPropertyPage, CDialog)

C3dPropertyPage::C3dPropertyPage()
{
	m_pSlob = NULL;
	m_pSheetWnd = NULL;
}

BOOL C3dPropertyPage::SetupPage(CSheetWnd* pSheetWnd, CSlob* pSlob)
{
	m_pSheetWnd = pSheetWnd;
//	m_pSlob = pSlob;

	if (!IsPageActive())
	{
		if (!Create(0, pSheetWnd))
		{
			m_pSheetWnd->FlushUnusedPages();

			if (!Create(0, pSheetWnd))
			{
				// PPMOVE : [matthewt]
				// VSHELL currently does not support this
				// SetUserEmergency(TRUE);
				return FALSE;
			}
		}

		CSheetWnd::s_listLoadedPages.AddTail(this);
		
		CPoint ptPos(cxWndMargin + cxPageMargin - GetSystemMetrics(SM_CYBORDER),
			pSheetWnd->s_cyBreakLine + cyPageMargin - GetSystemMetrics(SM_CYBORDER));
		MovePage(CRect(ptPos, GetPageSize()));
		
		if (m_hWnd != NULL)
		{
			// If this assert fires, you need to fix your dialog template...
			// Each page must be a borderless, disabled child window
			ASSERT(GetStyle() & (WS_DISABLED | WS_CHILD | WS_BORDER) ==
				WS_DISABLED | WS_CHILD);
		
			EnableWindow();
		}
	}

	// Calculate desired SheetWnd client area size.
	// Also store away the maximum page size, so the pages can expand during
	// InitializePage() if they want to.

	CSize sizeSheet = m_pSheetWnd->CalcMaxPageSize();
	sizeSheet.cx += (cxPageMargin + cxWndMargin) * 2;
	sizeSheet.cy += CSheetWnd::s_cyBreakLine +
		cyPageMargin * 2 + cyWndMargin;

	// Adjust to get window size.
	CRect rectWnd, rectClient;
	pSheetWnd->GetWindowRect(rectWnd);
	pSheetWnd->GetClientRect(rectClient);

	// find out if we need to adjust the height to account
	// for the html level combo box in the property dialog
	// if level combo box was shown, we reduce that height
	int		iLevelComboHeight = m_pSheetWnd->GetLevelComboHeight();
	if (iLevelComboHeight > 0)
	{
		rectWnd.bottom -= iLevelComboHeight;
		rectClient.bottom -= iLevelComboHeight;
	}

	pSheetWnd->ClientToScreen(rectClient);
	sizeSheet.cx += (rectClient.left - rectWnd.left) +
		(rectWnd.right - rectClient.right);
	sizeSheet.cy += (rectClient.top - rectWnd.top) +
		(rectWnd.bottom - rectClient.bottom);

	if (sizeSheet != rectWnd.Size())
	{
		// Calculate the sheet rect by anchoring the current rect by
		// the corner closest to the edge, and sizing to the new size.

		CRect rectSheet;
		int cxScreen = GetSystemMetrics(SM_CXSCREEN);
		int cyScreen = GetSystemMetrics(SM_CYSCREEN);

		if (rectWnd.left < cxScreen - rectWnd.right)
			rectSheet.left = rectWnd.left;
		else
			rectSheet.left = rectWnd.right - sizeSheet.cx;

		if (rectWnd.top < cyScreen - rectWnd.bottom)
			rectSheet.top = rectWnd.top;
		else
			rectSheet.top = rectWnd.bottom - sizeSheet.cy;

		rectSheet.right = rectSheet.left + sizeSheet.cx;
		rectSheet.bottom = rectSheet.top + sizeSheet.cy;

		// Keep the sheet from growing off screen.
		ForceRectOnScreen(rectSheet);

		// if the level combo box has a height, add it to the
		// height so that there is space on the dialog to show
		// the combo box
		m_pSheetWnd->SetWindowPos(NULL, rectSheet.left, rectSheet.top,
			rectSheet.Width(), rectSheet.Height() + iLevelComboHeight,
			SWP_NOZORDER | SWP_NOACTIVATE);
	}
	
	return TRUE;
}

void C3dPropertyPage::InitializePage()
{
	// Default is to do nothing...

	// Override this to do special processing for page initialization.
}

void C3dPropertyPage::TermPage()
{
	m_pSlob = NULL;
}

void C3dPropertyPage::Activate(UINT, CSlob *)
{
	// Default is to do nothing...

	// Override this to do special processing just prior to the property
	// window being activated/deactivated.
}

BOOL C3dPropertyPage::ShowPage(int nCmdShow)
{
	BOOL bShow = ShowWindow(nCmdShow);

	if (nCmdShow == SW_SHOWNORMAL)
		SetFocus();
		
	return bShow;
}

void C3dPropertyPage::MovePage(const CRect& rect)
{
	MoveWindow(rect);
}

void C3dPropertyPage::OnActivate()
{
	// Default is to do nothing...

	// Override this to do special processing when the property
	// window is activated.
}

void C3dPropertyPage::OnDeactivate()
{
	// Default is to do nothing...

	// Override this to do special processing when the property
	// window is deactivated.
}

LRESULT C3dPropertyPage::OnPageHelp(WPARAM wParam, LPARAM lParam)
{
	return SendMessage(WM_COMMANDHELP, wParam, lParam);
}

void C3dPropertyPage::GetPageName(CString& strName)
{
	VERIFY(strName.LoadString(IDS_UNNAMED));
}

CSize C3dPropertyPage::GetPageSize()
{
	CRect rect;
	if (m_hWnd == NULL)
		rect.SetRectEmpty();
	else
		GetWindowRect(rect);

	return rect.Size();
}

/////////////////////////////////////////////////////////////////////////////
//	CSlobPage

IMPLEMENT_DYNAMIC(CSlobPage, C3dPropertyPage)

BEGIN_IDE_CONTROL_MAP(CSlobPage, 0, IDS_UNNAMED)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CSlobPage, C3dPropertyPage)
	ON_WM_SYSCOMMAND()
END_MESSAGE_MAP()

CSlobPage::CSlobPage()
{
	m_nValidateID = NULL;

	m_bIgnoreChange = FALSE;
	m_bEnabled = TRUE;
}

BOOL CSlobPage::Create(UINT nIDSheet, CWnd* pWndOwner)
{
	if (nIDSheet == 0)
		nIDSheet = GetControlMap()->m_nCtlID;

	// May need to set our own help ID, since we're creating from a
	// template rather than letting CDialog do its own load code.
	if (m_nIDHelp == 0)
		m_nIDHelp = nIDSheet;

	C3dDialogTemplate dt;
	VERIFY(dt.Load(MAKEINTRESOURCE(nIDSheet)));
	SetStdFont(dt);
	return C3dPropertyPage::CreateIndirect(dt.GetTemplate(), pWndOwner);
}

static BOOL CALLBACK EnableChildWnd(HWND hwnd, LPARAM lParam) 
{
	::EnableWindow(hwnd, lParam);

	return TRUE ;
}

BOOL CSlobPage::EnablePage(BOOL bEnable)
{
	m_bIgnoreChange = TRUE;

	if (!bEnable)
		InitPage();	// init. before disable

	if( (m_bEnabled && !bEnable) || (!m_bEnabled && bEnable) )
		::EnumChildWindows(m_hWnd,
			    (WNDENUMPROC)::EnableChildWnd,
			    (long) bEnable);	

	if (bEnable)
		InitPage();	// init. after enable

	m_bIgnoreChange = FALSE;

	BOOL bOldEnable = m_bEnabled;
	m_bEnabled = bEnable;
	return bOldEnable;
}

void CSlobPage::InitializePage()
{
	EnablePage(m_bEnabled);
}

// Initialize the values of the controls in the property dialog.
// FUTURE:	The need to do this will be eliminated by simply having the
//			selection announce changes to all properties when the selected
//			object changes!

void CSlobPage::InitPage()
{
	CControlMap* pCtlMap;

	if (m_pSlob == NULL)
		return;

	// If several slob types share the same page we may need to change
	// the help ID, so the context sensitive help can reflect the
	// correct slob type.
	//
	UINT nHelpID = GetControlMap()->m_nProp;
	if (nHelpID)
		SetHelpID(nHelpID);

	for (pCtlMap = GetControlMap() + 1;
		pCtlMap->m_nCtlType != CControlMap::null; pCtlMap += 1)
	{
		CEnum* pEnum = NULL;
		if( (pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_ENUM )
			pEnum = (CEnum*)pCtlMap->m_nExtra;

		switch (pCtlMap->m_nCtlType)
		{
		// FUTURE: use the code from CSlobPageTab for check-list
		// property page controls
		case CControlMap::checkList:
			ASSERT(FALSE);	// NYI
			break;

		case CControlMap::comboList:
		case CControlMap::comboText:
		case CControlMap::autoComboList:
			if (pEnum != NULL)
			{
				pEnum->FillComboBox((CComboBox*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			((CComboBox*)GetDlgItem(pCtlMap->m_nCtlID))->SetExtendedUI();
			goto LThinFont;
			break;

		case CControlMap::list:
		case CControlMap::listText:
			if (pEnum != NULL)
			{
				pEnum->FillListBox((CListBox*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::edit:
		case CControlMap::editInt:
		case CControlMap::editNum:
		case CControlMap::autoEdit:
			if ((pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_LIMIT)
			{
				((CEdit*)GetDlgItem(pCtlMap->m_nCtlID))->LimitText(pCtlMap->m_nExtra);
			}
			// FALL THROUGH

		case CControlMap::editStrCap:
		case CControlMap::thinText:
		case CControlMap::pathText:
LThinFont:
			GetDlgItem(pCtlMap->m_nCtlID)->SetFont(GetStdFont(font_Normal));
			break;

		case CControlMap::thickText:
			break;
		}
		OnPropChange(pCtlMap->m_nProp);
	}

	// may also need to show/hide SCC status text
	CWnd * pWnd = GetDlgItem(IDC_SCC_STATUS);
	if (pWnd)
	{
		LPSOURCECONTROLSTATUS pInterface;
		BOOL bIsSccActive = FALSE;
		if (SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)))
		{
			bIsSccActive = (pInterface->IsSccInstalled() == S_OK);
			pInterface->Release();
		}
		pWnd->ShowWindow(bIsSccActive ? SW_SHOWNA : SW_HIDE);
		VERIFY(pWnd = GetDlgItem(IDC_SCC_STATUS_TEXT));
		pWnd->ShowWindow(bIsSccActive ? SW_SHOWNA : SW_HIDE);
	}
}

void CSlobPage::GetPageName(CString& strName)
{
	if (!strName.LoadString(GetControlMap()->m_nLastCtlID))
		VERIFY(strName.LoadString(IDS_UNNAMED));
}

BOOL CSlobPage::PreTranslateMessage(MSG* pMsg)
{
	BOOL bForwardAccel = FALSE;
	
	if (pMsg->message == WM_SYSKEYDOWN)
	{
		if (pMsg->wParam == VK_BACK ||
			(pMsg->wParam >= '1' && pMsg->wParam <= '9') ||		// Debug windows.
			(pMsg->wParam >= VK_F1 && pMsg->wParam <= VK_F12))
		{
			bForwardAccel = TRUE; // Forward Alt+Backspace for Undo.
		}
		else if (pMsg->hwnd != m_hWnd && !::IsChild(m_hWnd, pMsg->hwnd))
		{
			// mnemonic key passed to us by the frame.

			HWND hWnd = pMsg->hwnd;
			pMsg->hwnd = GetTopWindow()->GetSafeHwnd();
			if (IsDialogMessage(pMsg))
				return TRUE;
			pMsg->hwnd = hWnd;
		}
	}
	else if (pMsg->message == WM_KEYDOWN)
	{
		ASSERT(!bQuitting);
		
		// If the control key is down, and we are not just pressing the
		// control, shift, or alt key, or its a function key, forward the
		// accelerator.
		//
		// LOCALIZE: This may cause problems for Kanji, since Scott says
		//		They use right control key to generate some chars.
		if ((GetKeyState(VK_CONTROL) < 0 &&
#ifdef _WIN32
			 GetKeyState(VK_MENU) >= 0 &&	// Check for right Alt.
#endif
			 pMsg->wParam != VK_CONTROL && pMsg->wParam != VK_SHIFT &&
			 pMsg->wParam != VK_MENU) ||
			(pMsg->wParam >= VK_F1 && pMsg->wParam <= VK_F12))
		{
			bForwardAccel = TRUE;
		}

		switch (pMsg->wParam)
		{
		case VK_PRIOR:
		case VK_NEXT:
		case VK_RETURN:
		case VK_ESCAPE:
		case VK_F1:
			// Pass these along to the property window
			return FALSE;

		case VK_TAB:
			if (GetKeyState(VK_CONTROL) < 0)
				// Pass these along to the property window
				return FALSE;

			if (!IsChild(GetFocus()))
			{
				if (IsPageDisabled())
					::MessageBeep((UINT) -1);
				// Restore the focus to the first tabstop in the sheet.
				else if (GetKeyState(VK_SHIFT) >= 0)
					SetFocus();
				// Restore the focus to the last tabstop in the sheet.
				else
				{
					CWnd* pWnd = GetTopWindow();
					ASSERT_VALID(pWnd);
					pWnd = pWnd->GetWindow(GW_HWNDLAST);
					while (pWnd != NULL)
					{
						if ((pWnd->GetStyle() & (WS_DISABLED | WS_TABSTOP)) ==
							WS_TABSTOP)
						{
							GotoDlgCtrl(pWnd);
							break;
						}
		
						pWnd = pWnd->GetWindow(GW_HWNDPREV);
					}
				}

				return TRUE;
			}
			else if (IsTabNextFocus(this, GetKeyState(VK_SHIFT) < 0 ?
				GW_HWNDPREV : GW_HWNDNEXT))
			{
				// fix for default button border
				DWORD dwDefID = GetDefID();
				if (HIWORD(dwDefID) == DC_HASDEFID)
				{
					CWnd *pDefBtn = GetDlgItem(LOWORD(dwDefID));
					if (pDefBtn != NULL && pDefBtn->IsWindowEnabled())
						GotoDlgCtrl(pDefBtn);
				}

				if (m_pSheetWnd->SetFocus())
					return TRUE;
			}
			break;

		case VK_DOWN:
		case VK_UP:
		case VK_LEFT:
		case VK_RIGHT:
			bForwardAccel = FALSE;
			break;

		// LOCALIZE:  Don't forward cut, copy, paste.
		case 'X':
		case 'C':
		case 'V':
		case VK_INSERT:	// Ctrl+Insert - copy.
		case VK_HOME:	// Ctrl+Home - MLE beginning of text.
		case VK_END:	// Ctrl+End - MLE end of text.
			bForwardAccel = FALSE;
			break;
		}
	}

	if (bForwardAccel)
	{
		// Uses CSheetWnd::Validate to avoid two alerts.
		if (pMsg->wParam == 'Z' || pMsg->wParam == VK_BACK ||
			m_pSheetWnd->Validate())
		{
			CWnd* pWnd = GetActiveSlobWnd();
			if (pWnd == NULL)
				pWnd = theApp.m_pMainWnd;
				
			pWnd->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
		}
		return TRUE;
	}

	return C3dPropertyPage::PreTranslateMessage(pMsg);
}

//	CSlobPage::OnSysCommand
//		Routes Menu command keys to the MiniFrameWnd, which in turn
//		will route them to the parent FrameWnd.

void CSlobPage::OnSysCommand(UINT nID, LONG lParam)
{
	if(nID == SC_KEYMENU)
		m_pSheetWnd->SendMessage(WM_SYSCOMMAND, nID, lParam);
	else
		C3dPropertyPage::OnSysCommand(nID, lParam);
}

BOOL CSlobPage::UndoPendingValidate()
{
	// HACK: Cancel any pending property browser validations.  This
	// will NOT be redoable!
	
	if (m_nValidateID == NULL)
		return FALSE;

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	if( pCtlMap->m_nCtlType == CControlMap::autoEdit )
	{
		// autoEdit means that we've already called SetStrProp with the user's 
		// change.  To "cancel" this, we need to undo.
		ASSERT( (m_pSlob != NULL) && (m_pSlob->GetSlobWnd() != NULL) );
		theUndoSlob.DoUndo(m_pSlob->GetSlobWnd());
	}
	
	BOOL bRet = OnPropChange(FindControl(m_nValidateID)->m_nProp);
	m_nValidateID = NULL;

	return bRet;
}

// Validate
//
// This gets called when the user clicks on something that might change
// the property page.  This should make sure the property page is valid,
// and, if for some reason it isn't, bring up an error dialog, and set the
// focus back to the appropriate error location.
//
// Other windows (specifically, editor windows which contain objects that
// are viewed by the property page) should call this function before
// changing the selection.	This must not be called inside a setfocus or
// killfocus routine, and this function CAN fail.  If the function fails,
// it *will* have changed the windows focus back to the property sheet,
// in the field that failed..  It also may have put up a message box
// alerting the user to the problem.

BOOL CSlobPage::Validate()
{
	if (m_nValidateID == NULL)
		return TRUE;

	ASSERT(!bQuitting);
	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	if( pCtlMap->m_nCtlType == CControlMap::autoEdit )
		return TRUE;	// has already been validated automatically

	CWnd* pCtl = GetDlgItem(pCtlMap->m_nCtlID);
	ASSERT(pCtl != NULL);

	BOOL bString = (pCtlMap->m_nCtlType != CControlMap::comboList);

	CString strBuf;
	CString strCurVal;
	int val, curVal;

	if (bString)
	{
		pCtl->GetWindowText(strBuf);
		m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal);
	}
	else
	{
		ASSERT(pCtlMap->m_nCtlType == CControlMap::comboList);
		int iSel = ((CComboBox*)pCtl)->GetCurSel();
		val = ((CComboBox*)pCtl)->GetItemData(iSel);
		m_pSlob->GetIntProp(pCtlMap->m_nProp, curVal);
	}

	// special case the string page caption control because
	// what it displays in the edit is not always what is stored
	// in the property
	if (pCtlMap->m_nCtlType == CControlMap::editStrCap)
	{
		StringEditorEditToProp(strBuf.GetBuffer(1025));		// FUTURE(davidga) a string can be much longer
		strBuf.ReleaseBuffer();
		// if there are backslashes in the string we need to go
		// ahead and update
		if (strCurVal == strBuf && strCurVal.Find("\\") == -1)
		{
			m_nValidateID = NULL;
			return TRUE;
		}
	}
	else if (  (bString && (strCurVal == strBuf))
	         || ((!bString) && (curVal == val)))
	{
		m_nValidateID = NULL;
		return TRUE;
	}

	switch (pCtlMap->m_nCtlType)
	{
#ifdef _DEBUG
	default:
		ASSERT(FALSE);
#endif
	case CControlMap::editStrCap:
	case CControlMap::comboText:
	case CControlMap::comboList:
	case CControlMap::symbolCombo:
	case CControlMap::edit:
	case CControlMap::editInt:
	case CControlMap::editNum:
		break;
	}

	theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
	BOOL bValid;
	if (bString)
		bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
	else
		bValid = m_pSlob->SetIntProp(pCtlMap->m_nProp, val);
	theUndoSlob.EndUndo();

	if(m_pSlob == NULL)
		return FALSE;
		
	if (bValid)
		m_nValidateID = NULL;
	else
	{
		// Only set focus if we don't already have it, or we will have
		// cases where combo boxes go into an infinite loop.

		CWnd* pWndFocus = GetFocus();
		if (pWndFocus == NULL || (pCtl != pWndFocus && !pCtl->IsChild(pWndFocus)))
			pCtl->SetFocus();
	}

	// Since the user made a change on this page, use it as the default...
	m_pSheetWnd->SetDefaultPage();

	return bValid;
}

//	CSlobPage::OnCommand
//		Handle a control notification from a property dialog.

BOOL CSlobPage::OnCommand(UINT wParam, LONG lParam)
{
	// HACK -- Since Combos always send their messages to their original
	// parent, rather than their current parent, the symbol combo's
	// original parent (the nullPage) is forced to forward all messages
	// to the appropriate property page.

	if ((this == &(m_pSheetWnd->m_nullPage)) &&
		(LOWORD(wParam) == IDC_ID) &&
		m_pSheetWnd->m_pCurPage->GetSafeHwnd() != NULL &&
		m_pSheetWnd->m_pCurPage != this)
	{
		CSlobPage *pSlobPage = STATIC_DOWNCAST(CSlobPage, m_pSheetWnd->m_pCurPage);
		return pSlobPage->OnCommand(wParam, lParam);
	}

	CControlMap* pCtlMap = FindControl(LOWORD(wParam));
	CString strBuf;
	int val;
	BOOL bString = FALSE;
	BOOL bSetProp = FALSE;
	BOOL bValidateReq = FALSE;

	if (m_pSlob == NULL || pCtlMap == NULL ||
		(m_nValidateID && LOWORD(wParam) != ((UINT) m_nValidateID) &&
		pCtlMap->m_nCtlType != CControlMap::check &&
		pCtlMap->m_nCtlType != CControlMap::radio))
	{
		// If the control is not found in the map, just pass this
		// message on for default processing...
		// Or if we have a validate ID already, this message is from
		// another control.
LDefault:
		return C3dPropertyPage::OnCommand(wParam, lParam);
	}

#ifdef _WIN32
	HWND hWndCtl = (HWND)(lParam);
	UINT nNotify = HIWORD(wParam);
#else
	HWND hWndCtl = (HWND)LOWORD(lParam);
	UINT nNotify = HIWORD(lParam);
#endif

	ASSERT(m_pSlob != NULL);

	switch (pCtlMap->m_nCtlType)
	{
	default:
		goto LDefault;

	case CControlMap::check:
		if (nNotify != BN_CLICKED)
			goto LDefault;

		val = (int)::SendMessage(hWndCtl, BM_GETCHECK, 0, 0);
		
		// ambiguous becomes checked
		// checked becomes unckeched
		// unchecked becomes checked...
		val = (val + 1) % 2;	// 2->1; 1->0; 0->1; 1->0...
		bSetProp = TRUE;
		break;

	case CControlMap::radio:
		if (nNotify != BN_CLICKED)
			goto LDefault;

		ASSERT( (pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_OFFSET );
		val = LOWORD(wParam) - pCtlMap->m_nCtlID + pCtlMap->m_nExtra;
		bSetProp = TRUE;
		break;

	case CControlMap::list:
	case CControlMap::listText:
	{
		if (nNotify != LBN_SELCHANGE)
			goto LDefault;

		int isel = (int)::SendMessage(hWndCtl, LB_GETCURSEL, 0, 0);
		val = (int)::SendMessage(hWndCtl, LB_GETITEMDATA, isel, 0);
		bSetProp = TRUE;

		if (pCtlMap->m_nCtlType == CControlMap::listText)
		{
			((CListBox*)CWnd::FromHandle(hWndCtl))->GetText(val, strBuf);
			bString = TRUE;
		}
		break;
	}

	case CControlMap::autoComboList:
	{
		if (nNotify != CBN_SELCHANGE)
			goto LDefault;
		int isel = (int)::SendMessage(hWndCtl, CB_GETCURSEL, 0, 0);
		val = (int)::SendMessage(hWndCtl, CB_GETITEMDATA, isel, 0);
		bSetProp = TRUE;
		break;
	}

	case CControlMap::autoEdit:
		if( m_bIgnoreChange )
			goto LDefault;

		if( nNotify == EN_CHANGE )
		{
			bSetProp = TRUE;
			CEdit::FromHandle(hWndCtl)->GetWindowText(strBuf);
			bString = TRUE;
			m_nValidateID = pCtlMap->m_nCtlID;
		}
		else if (nNotify == EN_KILLFOCUS)
			bValidateReq = TRUE;
		else
			goto LDefault;
		break;

	case CControlMap::comboList:
	case CControlMap::comboText:
	case CControlMap::symbolCombo:
		if ((nNotify == CBN_EDITCHANGE || nNotify == CBN_SELCHANGE) && !m_bIgnoreChange)
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == CBN_SELENDCANCEL || nNotify == CBN_SELENDOK)
			bValidateReq = TRUE;
		break;

	case CControlMap::editStrCap:
	case CControlMap::editInt:
	case CControlMap::edit:
	case CControlMap::editNum:
		if (nNotify == EN_CHANGE && !m_bIgnoreChange)
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == EN_KILLFOCUS)
			bValidateReq = TRUE;
		break;
	}

	if (bSetProp)
	{
		ASSERT(!bValidateReq);

		CMultiSlob* pSelection = NULL;
		CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
		if (pSlobWnd != NULL)
			pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
		if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
			pSelection = NULL;

		theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
		if (bString)
			m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
		else
			m_pSlob->SetIntProp(pCtlMap->m_nProp, val);
		theUndoSlob.EndUndo();
	}
	else if( bValidateReq && (m_nValidateID != NULL) )
	{
		m_pSheetWnd->ValidateRequest();
		return C3dPropertyPage::OnCommand(wParam, lParam);
	}

	// Since the user made a change on this page, use it as the default...

	m_pSheetWnd->SetDefaultPage();

	return TRUE;
}

//	CSlobPage::FindControl
//		Given a control (window) id, return the control map entry for it...

CControlMap* CSlobPage::FindControl(UINT nCtlID)
{
	CControlMap* pCtlEntry;

	for (pCtlEntry = GetControlMap() + 1;
		pCtlEntry->m_nCtlType != CControlMap::null; pCtlEntry += 1)
	{
		if (nCtlID >= pCtlEntry->m_nCtlID &&
			nCtlID <= pCtlEntry->m_nLastCtlID)
		{
			return pCtlEntry;
		}
	}

	return NULL;
}

// Given a property id, return the control map entry for it.
CControlMap* CSlobPage::FindProp(UINT nProp)
{
	CControlMap* pCtlEntry;

	for (pCtlEntry = GetControlMap() + 1;
		pCtlEntry->m_nCtlType != CControlMap::null; pCtlEntry += 1)
	{
		if (pCtlEntry->m_nProp == nProp)
			return pCtlEntry;
	}

	return NULL;
}

/* EnableControl
 *	if gpt is valid or ambiguous, the control is visible and enabled.
 *	if gpt is invalid, control is visible but disabled.
 *	if gpt is invisible or avoid, control is invisible and disabled.
 */
void EnableControl(CWnd* pWnd, GPT gpt)
{
	if( pWnd == NULL )
		return;
	pWnd->EnableWindow( (gpt == valid) || (gpt == ambiguous) );
	if( (gpt == invisible) || (gpt == avoid) )
	{
		pWnd->ShowWindow(SW_HIDE);
	}
	else
	{
		pWnd->ShowWindow(SW_SHOWNA);
		pWnd->Invalidate(FALSE);
	}
}

/* ApplyControlMapFlags
 *	There are flags in CControlMap::m_dwFlags that can affect gpt.
 *	In particular, CM_NOMULTISEL disables a control (by making gpt invalid)
 *	if CSlobPage::m_pSlob is a multiple selection.
 *	Also, CM_NOAMBIGUOUS disables a control if the original gpt was ambiguous.
 */
void ApplyControlMapFlags(CControlMap* pCtlMap, GPT& rgpt, CSlob* pSlob)
{
	// CM_NOMULTISEL takes precedence over CM_NOAMBIGUOUS
	if( (pCtlMap->m_dwFlags & CM_NOMULTISEL) && 
		pSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)) && 
		(pSlob->GetContentList()->GetCount() > 1) )
	{
		// Crazy idea to fix DevStudio96 bug #2861:
		// It isn't really necessary to invalidate a field in a multi-selection
		// if only one item in that selection uses it, and all the others 
		// return invisible.  To test for this, we'd have to loop through all 
		// of the items in pSlob->GetContentList(), and call GetStrProp() 
		// (or GetIntProp() for some types of pCtlMap->m_nCtlType), and see if 
		// more than one returns a gpt != invisible.  -- DavidGa

		rgpt = min(rgpt, invalid);
	}
	else if( (pCtlMap->m_dwFlags & CM_NOAMBIGUOUS) && (rgpt == ambiguous) )
	{
		rgpt = invalid; 
	}
}

// Update the control that reflects a given property in the dialog.
// Called whenever any property of any of the selected objects changes.
BOOL CSlobPage::OnPropChange(UINT nProp)
{
	BOOL bChanged = TRUE;

	// we need to check to make sure the current page isn't pointing
	// at a NULL editor (which would be the case if this is the NUL
	// or MULTIPLE SELECITON page).   If so, do nothing.

	if (m_pSlob == NULL)
		return FALSE;

	CControlMap* pCtlMap = FindProp(nProp);
	if (pCtlMap == NULL)
	{
		if (nProp == P_QuoteName)
			pCtlMap = FindProp(P_ID);

		if (pCtlMap == NULL)
		{
			TRACE("No control map!\n");
			return FALSE;
		}
	}

	CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);
	CWnd* pPromptWnd = GetDlgItem(pCtlMap->m_nCtlID - 1);

	if (pWndCtl == NULL)
	{
		TRACE1("Control %d is in the map but not the dialog!\n",
			pCtlMap->m_nCtlID);
		return FALSE;
	}

	GPT gpt;
	int val;
	CString str;
	UINT id;

	switch (pCtlMap->m_nCtlType)
	{
		case CControlMap::check:
		//BLOCK:
		{
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt == ambiguous )
				val = 2;	// indeterminate state
			else if( gpt == invalid )
				val = 0;	// disabled state

			((CButton*)pWndCtl)->SetCheck(val);
			EnableControl(pWndCtl, gpt);
		}
		break;

		case CControlMap::editStrCap:
		{
			CString strWindow;
			gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt != valid )
				str.Empty();

			pWndCtl->GetWindowText(strWindow);

            //
            // going from property into edit window
            //
            StringEditorPropToEdit(str);          // GLOBAL func

			if (str != strWindow)
			{
				m_bIgnoreChange = TRUE;
				pWndCtl->SetWindowText(str);
				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}

			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);
		}
        break;

		case CControlMap::editInt:
		case CControlMap::edit:
		case CControlMap::editNum:
		case CControlMap::autoEdit:
		case CControlMap::thinText:
		case CControlMap::thickText:
		case CControlMap::pathText:
		{
			CString strWindow;
			gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt != valid )
				str.Empty();

			if (pCtlMap->m_nCtlType == CControlMap::pathText)
			{
				// If this is a pathText then we may
				// truncate the text for display

				CRect rect;
				TEXTMETRIC tm;
				int MaxWidth = 0;
				CPath path;
				CString strPath;

				pWndCtl->GetWindowRect(&rect);

				CDC * pDC = pWndCtl->GetDC();
				ASSERT(pDC != (CDC *)NULL);
				pDC->GetTextMetrics(&tm);
				VERIFY(pWndCtl->ReleaseDC(pDC));

				MaxWidth = rect.Width() / tm.tmAveCharWidth;
				// Make sure it hasn't alredy been adjusted first.
				if (str.Find("...") < 0 && path.Create(str))
				{
					path.GetDisplayNameString(strPath, MaxWidth);
					str = strPath;
				}
			}
			pWndCtl->GetWindowText(strWindow);
			if (str != strWindow)
			{
				m_bIgnoreChange = TRUE;
				if (pCtlMap->m_nCtlType != CControlMap::thinText &&
					pCtlMap->m_nCtlType != CControlMap::thickText)
					((CEdit*)pWndCtl)->LimitText(0); // remove limit

				pWndCtl->SetWindowText(str);

				if (pCtlMap->m_nCtlType != CControlMap::thinText &&
					pCtlMap->m_nCtlType != CControlMap::thickText)
				{
					if ((pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_LIMIT)
					{
						((CEdit*)pWndCtl)->LimitText(pCtlMap->m_nExtra);
					}
				}

				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);
		}
		break;

		case CControlMap::listText:
		case CControlMap::comboText:
// PPMOVE SPECIAL: [matthewt]
// Does this resource handling need to be moved back into VRES?
		case CControlMap::symbolCombo:
		{
			CString strWindow;
			gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt != valid )
				str.Empty();

			if( (pCtlMap->m_nCtlType == CControlMap::symbolCombo) && 
				((gpt == ambiguous) || 
				m_pSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob))) )
			{
				// symbols on multiple selections are dangerous
				gpt = min(gpt, invalid);
			}

			pWndCtl->GetWindowText(strWindow);
			if (str != strWindow)
			{
				m_bIgnoreChange = TRUE;
				if (pCtlMap->m_nCtlType == CControlMap::listText)
				{
					if( gpt == ambiguous )
						((CListBox*)pWndCtl)->SetCurSel(-1);
					else
					{
						int iCurSel = ((CListBox*)pWndCtl)->
							FindStringExact(-1, str);
						if( iCurSel!=LB_ERR )
							((CListBox*)pWndCtl)->SetCurSel(iCurSel);
					}
				}
				else
				{
					if( gpt == ambiguous )
						((CListBox*)pWndCtl)->SetCurSel(-1);
					else
					{
						int iCurSel = ((CComboBox*)pWndCtl)->
							FindStringExact(-1, str);
						if( iCurSel!=CB_ERR )
							((CComboBox*)pWndCtl)->SetCurSel(iCurSel);
					}
				}
				pWndCtl->SetWindowText(str);
				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);
		}
		break;

		case CControlMap::radio:
		{
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt != valid )
				val = -1;
			
			ASSERT( (pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_OFFSET );
			CheckRadioButton(pCtlMap->m_nCtlID, pCtlMap->m_nLastCtlID,
				val == -1 ? val : pCtlMap->m_nCtlID + val - pCtlMap->m_nExtra);
			for (id = pCtlMap->m_nCtlID; id <= pCtlMap->m_nLastCtlID;
				id += 1)
			{
				EnableControl(GetDlgItem(id), gpt);
			}
			break;
		}

		case CControlMap::list:
		{
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt != valid )
				val = -1;

			if (val != -1)
			{
				int icnt = ((CListBox*)pWndCtl)->GetCount();
				for (int iitem = 0; iitem < icnt; iitem++)
				{
					int idata = ((CListBox*)pWndCtl)->GetItemData(iitem);
					if (val == idata)
					{
						val = iitem; break;
					}
				}

				// found matching item?
				if (iitem == icnt)
					val = -1; // no so remove selection
			}
			((CListBox*)pWndCtl)->SetCurSel(val);
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);
			break;
		}

		case CControlMap::comboList:
		case CControlMap::autoComboList:
		{
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

			if( gpt != valid )
				val = -1;

			if (val != -1)
			{
				int icnt = ((CComboBox*)pWndCtl)->GetCount();
				for (int iitem = 0; iitem < icnt; iitem++)
				{
					int idata = ((CComboBox*)pWndCtl)->GetItemData(iitem);
					if (val == idata)
					{
						val = iitem; break;
					}
				}

				// found matching item?
				if (iitem == icnt)
					val = -1; // no so remove selection
			}
			((CComboBox*)pWndCtl)->SetCurSel(val);
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);
			break;
		}

		case CControlMap::bitmap:
		{
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			ApplyControlMapFlags(pCtlMap, gpt, m_pSlob);

//			if( gpt == ambiguous )	// REVIEW(davidga): instead of this, I made
//				gpt == invisible;	// CM_NOAMBIGUOUS part of the MAP_BITMAP macro

			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);
			GetDlgItem(pCtlMap->m_nCtlID)->Invalidate();
			break;
		}
	}

	return bChanged;
}

/////////////////////////////////////////////////////////////////////////////
// Simple Enumeration Implementation
//
// Simple Enumerations are used to fill list and combo boxes with a static
// array of strings.  Create a new class derived from CEnum to deal with
// variable arrays...
//

BOOL CEnum::ContainsVal(int val)
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CEnumerator* pEnum = GetNext(pos);
		if (pEnum->val == val)
			return TRUE;
	}

	return FALSE;
}

POSITION CEnum::GetHeadPosition()
{
	CEnumerator* pEnum = GetList();
	if (pEnum->szId == NULL)
		return NULL;
	return (POSITION)pEnum;
}

CEnumerator* CEnum::GetNext(POSITION& pos)
{
	CEnumerator* pEnum = (CEnumerator*)pos;
	ASSERT(pEnum != NULL);
	pos = (POSITION) (pEnum + 1);
	if (((CEnumerator*)pos)->szId == NULL)
		pos = NULL;
	return pEnum;
}

void CEnum::FillListBox(CListBox* pWnd, BOOL bClear, CSlob*)
{
	ASSERT(pWnd != NULL);

	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CEnumerator* pEnum = GetNext(pos);
		pWnd->SetItemData(pWnd->AddString(pEnum->szId), pEnum->val);
	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}

void CEnum::FillCheckList(CPropCheckList* pWnd, BOOL bClear, CSlob*)
{
	ASSERT(pWnd != NULL);

	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CEnumerator* pEnum = GetNext(pos);
		pWnd->AddItem(pEnum->szId, pEnum->val);
	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}

void CEnum::FillComboBox(CComboBox* pWnd, BOOL bClear, CSlob*)
{
	ASSERT(pWnd != NULL);

	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CEnumerator* pEnum = GetNext(pos);
		pWnd->SetItemData(pWnd->AddString(pEnum->szId), pEnum->val);
	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}

// a CEnum like class for localized enumerations
static char BASED_CODE szEmpty[] = "";
CLocalizedEnumerator::CLocalizedEnumerator(UINT aId, int aVal) : szId(szEmpty), id(aId), val(aVal)
{
}

BOOL CLocalizedEnum::ContainsVal(int val)
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CLocalizedEnumerator* pEnum = GetNextL(pos);
		if (pEnum->val == val)
			return TRUE;
	}

	return FALSE;
}

POSITION CLocalizedEnum::GetHeadPosition()
{
	CLocalizedEnumerator* pEnum = GetListL();
	if (!pEnum->id)
		return NULL;
	return (POSITION)pEnum;
}


CLocalizedEnumerator* CLocalizedEnum::GetNextL(POSITION& pos)
{
	CLocalizedEnumerator* pEnum = (CLocalizedEnumerator*)pos;
	ASSERT(pEnum != NULL);
	pos = (POSITION) (pEnum + 1);
	if (!((CLocalizedEnumerator*)pos)->id)
		pos = NULL;

	VERIFY(pEnum->szId.LoadString(pEnum->id));
	return pEnum;
}

void CLocalizedEnum::FillListBox(CListBox* pWnd, BOOL bClear, CSlob*)
{
	ASSERT(pWnd != NULL);

	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CLocalizedEnumerator* pEnum = GetNextL(pos);

		pWnd->SetItemData(pWnd->AddString(pEnum->szId), pEnum->val);
	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}

void CLocalizedEnum::FillCheckList(CPropCheckList* pWnd, BOOL bClear, CSlob*)
{
	ASSERT(pWnd != NULL);

	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CLocalizedEnumerator* pEnum = GetNextL(pos);
		pWnd->AddItem(pEnum->szId, pEnum->val);
	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}

void CLocalizedEnum::FillComboBox(CComboBox* pWnd, BOOL bClear, CSlob*)
{
	ASSERT(pWnd != NULL);

	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CLocalizedEnumerator* pEnum = GetNextL(pos);
		pWnd->SetItemData(pWnd->AddString(pEnum->szId), pEnum->val);
	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}

/////////////////////////////////////////////////////////////////////////////
// Utility functions

// copy out ofs edit in propert sheet into property
// called from  CSlobPage::OnCommand

void StringEditorEditToProp(char* szBuf)
{
    char *pc = szBuf;
    char *pcOut = szBuf;

	// since the final string length is limited to 255 bytes, and 
	// each byte may be represented by up to 4 characters, the maximum
	// possible length is (4*255) + 1
	// FUTURE(davidga): the string length is now limited to 65535, not 255
    char *pcLimit = szBuf + (4*255) + 1;

    for (; *pc; pc++)
    {
        if (*pc == 0x0d)
        {
            pc++;                       // skip first 0d
            if (*pc == 0x0d)
            {
                pc++;                   // skip second od
                if (*pc == 0x0a)
                    pc++;               // skip 0a
                continue;               // skip soft line breaks
            }
        }

        // CR, LF so use a single LF

        if (*pc == 0)                  // unusual case
        {
            *pcOut++ = '\n';
            if (pcOut > pcLimit) pcOut = pcLimit;
            break;
        }

        if (IsDBCSLeadByte(*pc))
        {
        	*pcOut++ = *pc++;
        	*pcOut++ = *pc;
            if (pcOut > pcLimit)
            	pcOut = pcLimit;
            continue;
        }

        if (*pc == '\\')
        {
            WORD    w;

            pc++;                       // skip first back-slash

            if (*pc == '\\')
            {
                *pcOut++ = '\\';              // convert \\ to single back-slash
                if (pcOut > pcLimit) pcOut = pcLimit;
                continue;
            }

            if (*pc < '0' || *pc > '7')                // not an octal
            {
                switch((unsigned char) *pc)
                {
                case 'a':
                    *pcOut++ = 0x08;
                    break;
                case 'n':
                    *pcOut++ = '\n';
                    break;
                case 'r':
                    *pcOut++ = '\r';
                    break;
                case 't':
                    *pcOut++ = '\t';
                    break;
                default:
                    *pcOut++ = '\\';                    // output the first back slash
                    pc--;                               // process next character as is
                }
                if (pcOut > pcLimit) pcOut = pcLimit;
                continue;
            }

            w = *pc++ - '0';            // first octal digit

            if (*pc < '0' || *pc > '7')
            {
                *pcOut++ = (char)(w & 0x00ff);
                if (pcOut > pcLimit) pcOut = pcLimit;
                pc--;
                continue;
            }
            w = (w<<3) + *pc++ - '0';   // second

            if (*pc < '0' || *pc > '7')
            {
                *pcOut++ = (char)(w & 0x00ff);
                if (pcOut > pcLimit) pcOut = pcLimit;
                pc--;
                continue;
            }

            w = (w<<3) + *pc - '0';     // third

            *pcOut++ = (char)(w & 0x00ff);
            if (pcOut > pcLimit) pcOut = pcLimit;
            continue;
        }
        *pcOut++ = *pc;
        if (pcOut > pcLimit) pcOut = pcLimit;
    }

    *pcOut = 0;
}

// from property into edit
// called from  CSlobPage::OnPropChange

void StringEditorPropToEdit(CString& str)
{
	CString strResult;

    const char *pc = (const char*) str;

    //
    //  unprintable characters as \777 octal
    //
    for (; *pc; pc++)
    {
        if (IsDBCSLeadByte(*pc))
        {
        	strResult += *pc++;
        	strResult += *pc;
        	continue;
        }
        
        if (*pc == '\\')
        {
            strResult += '\\';
            strResult += '\\';
            continue;
        }

        switch((unsigned char) *pc)
        {
        case 0x08:
            strResult += "\\a";
            continue;
        case '\r':
            strResult += "\\r";
            continue;
        case '\n':
            strResult += "\\n";
            continue;
        case '\t':
            strResult += "\\t";
            continue;
        }

        if ((unsigned char)*pc < 0x20)
        {
            WORD w = (unsigned char) *pc;

            strResult += '\\';
            strResult += (char)('0' + (w >> 6));
            strResult += (char)('0' + ((w >> 3) & 7));
            strResult += (char)('0' + (w & 7));
            continue;
        }
        strResult += *pc;
    }

	str = strResult;
}

/////////////////////////////////////////////////////////////////////////////
//	COlePage helper functions

CString _AfxGetHelpDir(const CString& strClsid)
{
	CString strHelp;
	TCHAR szBuff[_MAX_PATH];
	TCHAR szKey[_MAX_PATH];
	HKEY hKey;

	if (!strClsid.IsEmpty())
	{
		wsprintf(szKey, _T("CLSID\\%s"), (LPCTSTR) strClsid);

		if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey) == ERROR_SUCCESS)
		{
			LONG cb = sizeof(szBuff) / sizeof(TCHAR);

			if (RegQueryValue(hKey, _T("helpdir"), szBuff, &cb) ==
				ERROR_SUCCESS)
			{
				// Found a helpdir key.  Use it.

				strHelp = szBuff;
			}
			else if (RegQueryValue(hKey, _T("InprocServer32"), szBuff, &cb) ==
				ERROR_SUCCESS)
			{
				// Found an InprocServer[32] key.  Strip down to dir name only.

				strHelp = StripName(szBuff);
			}

			RegCloseKey(hKey);
		}
	}

	// If we didn't get anything, just use current directory.
	if (strHelp.IsEmpty())
		strHelp = _T(".");

	return strHelp;
}

/////////////////////////////////////////////////////////////////////////////
//	COlePage

IMPLEMENT_DYNAMIC(COlePage, C3dPropertyPage)

BEGIN_INTERFACE_MAP(COlePage, C3dPropertyPage)
	INTERFACE_PART(COlePage, IID_IPropertyPageSite, PropertyPageSite)
END_INTERFACE_MAP()

//	Page caching.
#define MAX_PAGELIST 20
CObList COlePage::s_listPages;
COleAllPage *COlePage::s_pAllPage = NULL;
LPUNKNOWN *COlePage::s_pObjectCurrent = NULL;
LPUNKNOWN COlePage::s_pSingleObject = NULL;
ULONG COlePage::s_nObjectCurrent;
UINT COlePage::s_nPagesCurrent;
LPCLSID COlePage::s_lpClsID = NULL;

//REVIEW (scotg) HACK HACK HACK  get rid of this when the resource package
// changes its databound controls handling
BOOL COlePage::s_fShowAllPage = TRUE;
BOOL COlePage::GetShowAllPage() 
{ 
	return s_fShowAllPage; 
}
void COlePage::SetShowAllPage(BOOL fSet)
{ 
	s_fShowAllPage = fSet; 
}

// Flag which is set when we may have released all pointers to the
// server of some OLE control (in which case we should call
// ::CoFreeUnusedLibraries before starting a build).
BOOL COlePage::s_bPossibleUnusedServers = FALSE;

BOOL COlePage::InPageCache(ULONG nUnkCnt, LPUNKNOWN *pprgUnk)
{
	BOOL fReturn = FALSE;
	ASSERT(pprgUnk && pprgUnk[0]);
	if(NULL == pprgUnk || NULL == pprgUnk[0])
		return FALSE;

	COleRef<ISpecifyPropertyPages>	srpSPP;
	COleMalloc<GUID> srpElems;
	// optimized for single selection case
	if(1 != nUnkCnt || nUnkCnt != s_nObjectCurrent ||
			s_pSingleObject != *pprgUnk)
		return FALSE;

	// if we have only one page, is it the all page
	if(NULL != s_lpClsID && 1 == s_nPagesCurrent && 
		::IsEqualCLSID(*s_lpClsID, CLSID_NULL))
		return TRUE;

	if(FAILED(pprgUnk[0]->QueryInterface(
		IID_ISpecifyPropertyPages, (void**)&srpSPP)))
		return FALSE;

	CAUUID caguid = {0, (GUID *)NULL};
	if(FAILED(srpSPP->GetPages(&caguid)))
		return FALSE;

	srpElems = caguid.pElems;
	// make sure cElems accounts for the allpage
	if(s_nPagesCurrent == (caguid.cElems + 1) &&
		0 == ::memcmp(s_lpClsID, caguid.pElems, sizeof(GUID *) * caguid.cElems))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

UINT COlePage::LoadPages(ULONG nUnkCnt, LPUNKNOWN *pprgUnk)
{
	ASSERT(NULL != pprgUnk);
	if(NULL == pprgUnk)
		return 0;

	// optimize for the single selection case
	if(1 == nUnkCnt && InPageCache(nUnkCnt, pprgUnk))
		return s_nPagesCurrent;

	if(s_lpClsID != NULL)
	{
		AfxFreeTaskMem(s_lpClsID);
		s_lpClsID = NULL;
	}

	// we've special cased this so that if only one
	// unk is passed in, it is assumed that it was
	// not dynamically allocated.  Greater than one
	// means a previous allocation that we are
	// responsible for freeing
	/*
	// The above comment is no longer true, the ownership of
	// the punk array is NOT transfered to the property page.
	// if is up to the slob that allocated the punk array to
	// free this memory up, as it was who allocated it in the
	// first place.
	if(s_nObjectCurrent > 1)
	{
		ASSERT(s_pObjectCurrent);
		AfxFreeTaskMem(s_pObjectCurrent);
	}
	*/
	s_nObjectCurrent = nUnkCnt;
	if(1 == s_nObjectCurrent)
	{
		s_pSingleObject = *pprgUnk;
		s_pObjectCurrent = &s_pSingleObject;
	}
	else
	{
		s_pSingleObject = NULL;
		s_pObjectCurrent = pprgUnk;
	}


	COleRef<ISpecifyPropertyPages>	srpSPP;
	CAUUID caGUID = {0, (GUID*)NULL};
	ULONG nPages = 0;

	for(ULONG nCnt = 0; nCnt < nUnkCnt; ++nCnt)
	{
		if(SUCCEEDED(s_pObjectCurrent[nCnt]->QueryInterface(
			IID_ISpecifyPropertyPages, (void**)&srpSPP)))
		{
			// get pages and if clsid's exist in caGUID, do
			// page intersection
			DoPageIntersection(srpSPP, &caGUID);
			srpSPP.SRelease();
			// if we don't have any elements, then there
			// is no need to continue
			if(0 == caGUID.cElems)
				break;
		}
		else	
		{
			// one within a possible group has failed
			// we must bail on trying to display individual
			// property pages and try for an all page
			caGUID.cElems = 0;
			break;
		}
	}

	if(0 == caGUID.cElems && NULL != caGUID.pElems)
	{
		AfxFreeTaskMem(caGUID.pElems);
		caGUID.pElems = NULL;
	}

	nPages = caGUID.cElems;		
	s_lpClsID = caGUID.pElems;

	LPCLSID lpClsIDNext = s_lpClsID;
	for (int i = 0; i < (int) nPages; i++)
	{
		// Start: IStudio Bug 7249 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// THIS CODE IS ASSOCIATED WITH THE CODE IN ALLPAGE2.CPP (MapPropertyToPage
		// static function).
		// The following code is provided to fix a bug in ISCTRLS.OCX.  The Stock Font,
		// Color and Picture property pages provided by MFC does not work because,
		// the ITypeInfos are not merged in ISCTRLS.OCX and so, the enumeration of
		// properties does not work with these property pages, but they do work in the
		// MS Stock Propperty Pages.  So we remove these property pages and let the user
		// use the AllPage to edit those properties.
		
		CFrameWnd*	pFrame = ((CFrameWnd*)AfxGetMainWnd())->GetActiveFrame();
		ASSERT(pFrame);
		if(pFrame)
		{
			CDocument*	pDoc = pFrame->GetActiveDocument();
			if(pDoc != NULL && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)))
			{
				// Only the Layout & Object Editor docs contain forms96==IID_IForm.
				// QI for IForm.  If successful then we know we have a Layout ||
				// Object Editor Doc, since IID_IForm is Forms96 only.
				LPOLEOBJECT pOleObj = ((CIPCompDoc*)pDoc)->GetOleObject(); // Un-AddRefed
				if(pOleObj != NULL)
				{
					COleRef<IUnknown> srpForms96;
					if(SUCCEEDED(pOleObj->QueryInterface(IID_IForm, (void**)&srpForms96)))
					{
						if(IsEqualCLSID(s_lpClsID[i], CLSID_CFontPropPage) ||
							IsEqualCLSID(s_lpClsID[i], CLSID_CColorPropPage) ||
							IsEqualCLSID(s_lpClsID[i], CLSID_CPicturePropPage))
							continue;
					}	
				}
			}
		}
		// End: IStudio Bug 7249 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		
		// Remove CLSIDs for pages that fail to load.
		if (GetPropPage(s_lpClsID[i]) == NULL)
			continue;

		if (lpClsIDNext != s_lpClsID + i)
			*lpClsIDNext = s_lpClsID[i];

		lpClsIDNext++;
	}

	UINT nPagesCurrent = (UINT) (lpClsIDNext - s_lpClsID);

//REVIEW (scotg) HACK HACK HACK get rid of this when the resource package
// changes how it handles data bound controls
	if(GetShowAllPage())
	{
		s_nPagesCurrent = AddAllPageToList(nPagesCurrent, &caGUID);
		s_lpClsID = caGUID.pElems;		// AddAllPageToList reallocs
	}
	else
		s_nPagesCurrent = nPagesCurrent;

	return s_nPagesCurrent;
}

UINT COlePage::LoadAllPageOnly(ULONG nUnkCnt, LPUNKNOWN *pprgUnk)
{
	ASSERT(NULL != pprgUnk);
	if(NULL == pprgUnk)
		return 0;

	// Store the array of IUnknown's

	/*
	// Ownership of the punk array is NOT transfered to the property page.
	// if is up to the slob that allocated the punk array to
	// free this memory up, as it was who allocated it in the
	// first place.
	if(s_nObjectCurrent > 1)
	{
		ASSERT(s_pObjectCurrent);
		AfxFreeTaskMem(s_pObjectCurrent);
	}
	*/
	s_nObjectCurrent = nUnkCnt;
	if(1 == s_nObjectCurrent)
	{
		s_pSingleObject = *pprgUnk;
		s_pObjectCurrent = &s_pSingleObject;
	}
	else
	{
		s_pSingleObject = NULL;
		s_pObjectCurrent = pprgUnk;
	}

	// Free old CLSID array of pages

	if(s_lpClsID != NULL)
	{
		AfxFreeTaskMem(s_lpClsID);
		s_lpClsID = NULL;
	}

	// Create a new CLSID array of pages with just the all page in it

	if(GetShowAllPage())
	{
		CAUUID caGUID = {0, (GUID*)NULL};
		s_nPagesCurrent = AddAllPageToList(0, &caGUID);
		s_lpClsID = caGUID.pElems;		// AddAllPageToList reallocs
	}
	else
		s_nPagesCurrent = 0;

	return s_nPagesCurrent;
}

UINT COlePage::AddAllPageToList(UINT nPagesCurrent, CAUUID *pcaGUID)
{

	// make sure all the objects support IDispatch
	// before we go off and create the all page object
	COleRef<IPerPropertyBrowsing>	srpPPB;
	for(ULONG nCnt = 0; nCnt < s_nObjectCurrent; ++nCnt)
	{
		if(FAILED(s_pObjectCurrent[nCnt]->QueryInterface(
			IID_IDispatch, (void**)&srpPPB)))
		{
			// OK, no all page
			return nPagesCurrent;
		}
		srpPPB.SRelease();
	}

	// look to see if I have space available in the
	// GUID array, if so use it, else resize the array
	// to make room for the allpage
	if(nPagesCurrent < pcaGUID->cElems)
	{
		// use the memory we already have
		pcaGUID->pElems[nPagesCurrent] = CLSID_NULL;
		++nPagesCurrent;
	}
	else
	{
		ASSERT(nPagesCurrent == pcaGUID->cElems);
		LPVOID pVoid = ::CoTaskMemRealloc(pcaGUID->pElems, 
								(sizeof(GUID) * (pcaGUID->cElems + 1)));
		ASSERT(NULL != pVoid);
		if(NULL == pVoid)
			return nPagesCurrent;

		pcaGUID->pElems = (GUID*)pVoid;
		pcaGUID->pElems[pcaGUID->cElems] = CLSID_NULL;
		++(pcaGUID->cElems);
		++nPagesCurrent;
	}

	return nPagesCurrent;
}

HRESULT COlePage::DoPageIntersection(ISpecifyPropertyPages *pSPP, 
	CAUUID *pcaGUID)
{
	ASSERT(NULL != pSPP);
	ASSERT(NULL != pcaGUID);

	if (pcaGUID != NULL)
		pcaGUID->cElems = 0;

	if(NULL == pSPP || NULL == pcaGUID)
		return E_INVALIDARG;

	CAUUID caguid;
	HRESULT hr;

	// Initialize caguid here because at least one ActiveX Control
	// (The MS Investor NewsClient Control) returns hr == 1 from the
	// ISpecifyPropertyPages::GetPages() call, and doesn't fill in
	// the caguid structure.  -mgrier 11/03/96
	caguid.cElems = 0;
	caguid.pElems = NULL;

	hr = pSPP->GetPages(&caguid);
	if (FAILED(hr))
		return hr;

	if(0 == caguid.cElems)
	{
		ASSERT(NULL == caguid.pElems);
		pcaGUID->cElems = 0;
		return S_OK;
	}

	ASSERT(caguid.pElems);
	// is this the first time?
	if(0 == pcaGUID->cElems)
	{
		pcaGUID->cElems = caguid.cElems;
		pcaGUID->pElems = caguid.pElems;
		return S_OK;
	}

	// ok, so this is not the first time, now 
	// we've got to actually do some real work
	// grab some heap to store the common guids
	ULONG nNext = 0;
	for(ULONG nCnt1 = 0; nCnt1 < pcaGUID->cElems; ++nCnt1)
	{
		for(ULONG nCnt2 = 0; nCnt2 < caguid.cElems; ++nCnt2)
		{
			if(::IsEqualCLSID(caguid.pElems[nCnt2], pcaGUID->pElems[nCnt1]))
			{
				pcaGUID->pElems[nNext] = pcaGUID->pElems[nCnt1];
				++nNext;
				break;
			}
		}
	}

	// rebuild the common list
	if(!nNext)
	{
		AfxFreeTaskMem(pcaGUID->pElems);
		pcaGUID->pElems = NULL;
	}
	pcaGUID->cElems = nNext;
 
	return S_OK;
}

void COlePage::SetUnusedServers(BOOL fUnused /*= TRUE*/) 
{ 
	s_bPossibleUnusedServers = fUnused; 
}

C3dPropertyPage* COlePage::GetPropPage(UINT iPage)
{
	ASSERT(s_pObjectCurrent != NULL);
	ASSERT(s_lpClsID != NULL);
	ASSERT(iPage < s_nPagesCurrent);
	
	return GetPropPage(s_lpClsID[iPage]);
}

C3dPropertyPage* COlePage::GetPropPage(REFCLSID clsid)
{
	COlePage* pPage;

	// see if we want the all page
	if(::IsEqualCLSID(CLSID_NULL, clsid))
	{
		if(NULL == s_pAllPage)
		{
			s_pAllPage = new COleAllPage();
		}
		return s_pAllPage;
	}

	// See if there is a matching page in the cache.
	POSITION pos = s_listPages.GetHeadPosition();
	while (pos != NULL)
	{
		pPage = (COlePage*) s_listPages.GetAt(pos);
		if (IsEqualCLSID(clsid, pPage->m_clsid))
			break;
		s_listPages.GetNext(pos);
	}

	if (pos != NULL)
		s_listPages.RemoveAt(pos);
	else
	{
		// If there was no match, create a new page.
		pPage = new COlePage(clsid);
		if (!pPage->IsUsable())			// not registered, or other problem
		{
			delete pPage;
			return NULL;
		}

		// If the cache size reaches its limit, remove the least recently
		// used page.

		if (s_listPages.GetCount() >= MAX_PAGELIST)
		{
			COlePage* pLRUPage = (COlePage*) s_listPages.RemoveTail();
			pLRUPage->m_pSheetWnd->RemovePageFromUse(pLRUPage);
			delete pLRUPage;
		}
	}

	// Promote the current page to most recently used status.
	s_listPages.AddHead(pPage);

	return pPage;
}

void COlePage::Cleanup()
{
	C3dPropertyPage* pCurPage = NULL;
	CSheetWnd* pSheetWnd = GetPropertyBrowser();

	if(pSheetWnd != NULL && ::IsWindow(pSheetWnd->m_hWnd))
	{
		// Force the current page to be updated.
		UpdatePropertyBrowser();
		pCurPage = pSheetWnd->GetCurrentPage();
	}

	BOOL bReplaceCurPage = FALSE;

	// clean up the OLE page cache.
	while (!s_listPages.IsEmpty())
	{
		COlePage *pPage = (COlePage *)s_listPages.RemoveHead();
		ASSERT(pPage->IsKindOf(RUNTIME_CLASS(COlePage)));

		if (pPage == pCurPage)
		{
			// Cannot delete the page because it is the currently visible one.
			// We will delete all the others, then put this one back in the cache.
			bReplaceCurPage = TRUE;
		}
		else
		{
			delete pPage;
		}
	}
	if (bReplaceCurPage)
	{
		s_listPages.AddHead(pCurPage);
	}

	if(NULL != s_pAllPage && s_pAllPage != pCurPage)
	{
		delete s_pAllPage;
		s_pAllPage = NULL;
	}

	// we've special cased this so that if only one
	// unk is passed in, it is assumed that it was
	// not dynamically allocated.  Greater than one
	// means a previous allocation that we are
	// responsible for freeing
	/*
	// The above comment is no longer true, the ownership of
	// the punk array is NOT transfered to the property page.
	// if is up to the slob that allocated the punk array to
	// free this memory up, as it was who allocated it in the
	// first place.
	if(s_nObjectCurrent > 1)
	{
		AfxFreeTaskMem(s_pObjectCurrent);
	}
	*/
	s_pObjectCurrent = NULL;
	s_nObjectCurrent = 0;

	if (s_lpClsID != NULL)
	{
		AfxFreeTaskMem(s_lpClsID);
		s_lpClsID = NULL;
	}

	if (s_bPossibleUnusedServers)
	{
		// We might have released all pointers owned by an OLE control
		// server; if so we want the system to unload it now so it
		// can be rebuilt if the user desires.
		::CoFreeUnusedLibraries();
		s_bPossibleUnusedServers = FALSE;
	}
}

COlePage::COlePage(REFCLSID clsid)
	: m_size(0, 0)
{
	USES_CONVERSION;

	m_bActive = FALSE;
	m_bVisible = FALSE;
	m_bTranslatingAccel = FALSE;
	m_clsid = clsid;

	// Attempt to create the Property Page object
	HRESULT hr = ::CoCreateInstance(m_clsid, NULL, CLSCTX_INPROC_SERVER,
		(REFIID)IID_IPropertyPage, (void **)&m_lpPropPage);
		
	if (FAILED(hr))
	{
		m_lpPropPage = NULL;
		ASSERT(!IsUsable());
		return;				// caveat caller
	}

	// Bind the Property Page to its objects
	try
	{
		m_lpPropPage->SetPageSite(&m_xPropertyPageSite);
	}
	catch(...)
	{
	}

	PROPPAGEINFO pgi;
	pgi.cb = sizeof(PROPPAGEINFO);
	BOOL bGetPageInfo = FALSE;
	try
	{
		hr = m_lpPropPage->GetPageInfo(&pgi);
		if (SUCCEEDED(hr))
			bGetPageInfo = TRUE;
	}
	catch(...)
	{
	}
	if( bGetPageInfo )
	{
		m_size = pgi.size;
		if (pgi.pszTitle != NULL)
		{
			// HACK: Keep OLE controls from using "General" as Tab text.
			//		 Use "Control" instead.
			CString strGeneral;
			strGeneral.LoadString(IDS_GENERAL);
			if (strGeneral.CompareNoCase(W2A(pgi.pszTitle)) == 0)
				m_strName.LoadString(IDS_PROP_CONTROL);
			else
				m_strName = pgi.pszTitle;
		}

		AfxFreeTaskMem(pgi.pszTitle);
		AfxFreeTaskMem(pgi.pszDocString);
		AfxFreeTaskMem(pgi.pszHelpFile);
	}

	if (m_strName.IsEmpty())
		C3dPropertyPage::GetPageName(m_strName);
}

COlePage::~COlePage()
{

	// since we can't get mfc based controls to release the addref
	// they are holding on us from a previous call to their
	// IPropertyPage::SetPageSite(&m_xPropertyPageSite),
	// we manage the ref count here in our destructor
	ASSERT(m_dwRef > 0);
	m_dwRef = 9999;			// add a ref count guard

	if (m_bActive)
		DestroyWindow();

	if (m_lpPropPage != NULL)
	{
		// OLE protocol requires a SetObjects will
		// before the page is released.  This gives the
		// page a chance to cleanup.
		try
		{
			// we should be calling IPropertyPage::SetPageSite(NULL)
			// to get the control to release an addref it is holding 
			// on our prop page site (from a previous call to 
			// m_lpPropPage->SetPageSite(&m_xPropertyPageSite);)
			// We can't do this due to an MFC bug that does not 
			// correctly handle the call (they crash).  Therefore
			// we're explicitly taking ownership of the addref and
			// performing a release on ourselves.  By the way, VB5 
			// controls do the right thing.  They handle a NULL
			// page site.
			m_lpPropPage->SetObjects(0, NULL);
			m_lpPropPage->Release();
		}
		catch(...)
		{
		}
		m_lpPropPage = NULL;
		s_bPossibleUnusedServers = TRUE;
	}

	s_bPossibleUnusedServers = TRUE;
	// account for not being able to call SetPageSite(NULL)
	m_dwRef = 1;
}

BOOL COlePage::Create(UINT, CWnd* pWndOwner)
{
	ASSERT_VALID(pWndOwner);
	ASSERT(m_lpPropPage != NULL);

	// We must initialize the page (i.e. set its object) before creating it ...
	// some controls will crash if their property pages are invoked with 0
	// objects.
	// 
	
	// IStudio bug #210, components can have a setobjects call fail.  when
	// this occurs they will assert if Activate is called.  since 
	// InitializePage doen't return a value a setobjects call has been
	// placed here as well as in the InializePage
	//InitializePage();
	try
	{
		if(FAILED(m_lpPropPage->SetObjects(s_nObjectCurrent, s_pObjectCurrent)))
			return FALSE;

		CRect rect(0, 0, m_size.cx, m_size.cy);
		if (FAILED(m_lpPropPage->Activate(pWndOwner->m_hWnd, rect, FALSE)))
			return FALSE;
	}
	catch(...)
	{
		return FALSE;
	}

	m_bActive = TRUE;
	return TRUE;
}

BOOL COlePage::PreTranslateMessage(MSG* pMsg)
{
	ASSERT(m_lpPropPage != NULL);
	
	BOOL bForwardAccel = FALSE;
	
	if (pMsg->message == WM_SYSKEYDOWN)
	{
		if (pMsg->wParam == VK_BACK ||
			(pMsg->wParam >= '1' && pMsg->wParam <= '9') ||		// Debug windows.
			(pMsg->wParam >= VK_F1 && pMsg->wParam <= VK_F12))
		{
			bForwardAccel = TRUE; // Forward Alt+Backspace for Undo.
		}
	}
	else if (pMsg->message == WM_KEYDOWN)
	{
		// If the control key is down, and we are not just pressing the
		// control, shift, or alt key, or its a function key, forward the
		// accelerator.
		//
		// LOCALIZE: This may cause problems for Kanji, since Scott says
		//		They use right control key to generate some chars.
		if ((GetKeyState(VK_CONTROL) < 0 &&
			 GetKeyState(VK_MENU) >= 0 &&	// Check for right Alt.
			 pMsg->wParam != VK_CONTROL && pMsg->wParam != VK_SHIFT &&
			 pMsg->wParam != VK_MENU) ||
			(pMsg->wParam >= VK_F1 && pMsg->wParam <= VK_F12))
		{
			bForwardAccel = TRUE;
		}

		switch (pMsg->wParam)
		{
		case VK_PRIOR:
		case VK_NEXT:
		case VK_RETURN:
		case VK_ESCAPE:
		case VK_F1:
			// Pass these along to the property window
			return FALSE;

		case VK_TAB:
			if (GetKeyState(VK_CONTROL) < 0)
				// Pass these along to the property window
				return FALSE;

		case VK_DOWN:
		case VK_UP:
		case VK_LEFT:
		case VK_RIGHT:
			bForwardAccel = FALSE;
			break;

		// LOCALIZE:  Don't forward cut, copy, paste.
		case 'X':
		case 'C':
		case 'V':
		case VK_INSERT:	// Ctrl+Insert - copy.
		case VK_HOME:	// Ctrl+Home - MLE beginning of text.
		case VK_END:	// Ctrl+End - MLE end of text.
			bForwardAccel = FALSE;
			break;

		}
	}

	if (bForwardAccel)
	{
		// Uses CSheetWnd::Validate to avoid two alerts.
		if (pMsg->wParam == 'Z' || pMsg->wParam == VK_BACK ||
			m_pSheetWnd->Validate())
		{
			CWnd* pWnd = GetActiveSlobWnd();
			if (pWnd == NULL)
				pWnd = theApp.m_pMainWnd;
				
			pWnd->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
		}
		return TRUE;
	}

	BOOL bTranslated = FALSE;
	if (!m_bTranslatingAccel)
	{
		m_bTranslatingAccel = TRUE;
		bTranslated = (m_lpPropPage->TranslateAccelerator(pMsg) == S_OK);
		m_bTranslatingAccel = FALSE;
	}

	// REVIEW: Possibly we should call the base class here
	return bTranslated;
}

void COlePage::InitializePage()
{
	ASSERT(m_lpPropPage != NULL);

	if (m_bVisible)
		m_pSheetWnd->UpdateWindow();

	try
	{
		m_lpPropPage->SetObjects(s_nObjectCurrent, s_pObjectCurrent);
	}
	catch(...)
	{
	}

	C3dPropertyPage::InitializePage();
}

void COlePage::TermPage()
{
	try
	{
		if(m_lpPropPage)
			m_lpPropPage->SetObjects(0, NULL);
	}
	catch(...)
	{
	}

	C3dPropertyPage::TermPage();
}

BOOL COlePage::ShowPage(int nCmdShow)
{
	ASSERT(m_lpPropPage != NULL);

	BOOL bSuccess = FALSE;
	try
	{
		if( SUCCEEDED(m_lpPropPage->Show(nCmdShow)) )
			bSuccess = TRUE;
	}
	catch(...)
	{
	}

	if (bSuccess)
		m_bVisible = !(nCmdShow == SW_HIDE);

	return bSuccess;
}

void COlePage::MovePage(const CRect& rect)
{
	ASSERT(m_lpPropPage != NULL);

	try
	{
		m_lpPropPage->Move(rect);
	}
	catch(...)
	{
	}
}

BOOL COlePage::DestroyWindow()
{
	if (m_bActive)
	{
		ASSERT(m_lpPropPage != NULL);

		try
		{
			m_lpPropPage->Deactivate();
			m_bActive = FALSE;
		}
		catch(...)
		{
			m_bActive = FALSE;
		}
	}
	return TRUE;
}

BOOL COlePage::Validate()
{
	ASSERT(m_lpPropPage != NULL);

	try
	{
		if (m_lpPropPage->IsPageDirty() == S_FALSE)
			return TRUE;
		else
		{
			COleRef<IPropertyPageUndoString> srpPPUS;
			LPOLESTR pStr = NULL;
			m_pSlob->BeginUndo(IDS_UNDO_OLE_PROPS);
			BOOL bSuccess = SUCCEEDED(m_lpPropPage->Apply());
			// give inplace components a chance to provide there own
			// undo string.  they can do this if they provide an
			// IPropertyPageUndoString interface
			if(bSuccess && m_pSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)) && 
				SUCCEEDED(m_lpPropPage->QueryInterface(IID_IPropertyPageUndoString, 
				(void**)&srpPPUS)))
			{
				ASSERT(srpPPUS != NULL);
				((CIPCompSlob*)m_pSlob)->SetUndoStringMgr(srpPPUS);
			}
			m_pSlob->EndUndo(!bSuccess);

			return bSuccess;
		}
	}
	catch(...)
	{
		return FALSE;
	}
}

BOOL COlePage::UndoPendingValidate()
{
	ASSERT(m_lpPropPage != NULL);

	// Should not try to validate if the page is not visible (the
	// corresponding object might have been deleted (Bug Dev Stud 96 #743)
	try
	{
		if (!IsPropertyBrowserVisible() || m_lpPropPage->IsPageDirty() == S_FALSE)
			return FALSE;

		return SUCCEEDED(m_lpPropPage->SetObjects(s_nObjectCurrent, s_pObjectCurrent));
	}
	catch(...)
	{
	}
	return FALSE;
}

LRESULT COlePage::OnPageHelp(WPARAM wParam, LPARAM lParam)
{
	USES_CONVERSION;

	ASSERT(m_lpPropPage != NULL);
	LPOLESTR wzTemp = NULL;
	CString str1;

	try
	{
		if(SUCCEEDED(::StringFromCLSID(m_clsid, &wzTemp)) &&
			SUCCEEDED(m_lpPropPage->Help(A2CW((LPCTSTR)_AfxGetHelpDir(CString(OLE2T(wzTemp)))))))
				goto noerror;
	}
	catch(...)
	{
	}

	str1.LoadString(IDS_PROP_ERROR_NOPAGEHELP);
	AfxMessageBox(str1);

noerror:
	if(NULL != wzTemp)
		AfxFreeTaskMem(wzTemp);
	return S_OK;
}

void COlePage::GetPageName(CString& strName)
{
	ASSERT(!m_strName.IsEmpty());

	strName = m_strName;
}

CSize COlePage::GetPageSize()
{
	return m_size;
}

void COlePage::EditProperty(DISPID dispid)
{
	ASSERT(m_lpPropPage != NULL);

	LPPROPERTYPAGE2 lpPropPage2;
	try
	{
		if (FAILED(m_lpPropPage->QueryInterface(IID_IPropertyPage2,
			(LPVOID*) &lpPropPage2)))
		{
			return;
		}
	}
	catch(...)
	{
		return;
	}

	lpPropPage2->EditProperty(dispid);
	lpPropPage2->Release();
}

/////////////////////////////////////////////////////////////////////////////
// COlePage::XPropertyPageSite

STDMETHODIMP COlePage::XPropertyPageSite::OnStatusChange(DWORD dwFlags)
{
	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)

	ASSERT_VALID(pThis);

	// Hack to work around ImageList version 5 control which sends an OnStatusChange to its
	// site when getting the property page information.  If the name of the page
	// hasn't initialized to non-empty, we don't actually do anything.
	// -mgrier 10/28/96

	if (!pThis->m_strName.IsEmpty())
	{
		ASSERT(pThis->m_lpPropPage != NULL);

		if (dwFlags & PROPPAGESTATUS_VALIDATE)
			pThis->m_pSheetWnd->ValidateRequest();
	}

	return NOERROR;
}

STDMETHODIMP COlePage::XPropertyPageSite::GetLocaleID(
	LCID FAR* pLocaleID)
{
	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)
	ASSERT_VALID(pThis);
	ASSERT(pLocaleID != NULL);

	if (pLocaleID == NULL)
		return ResultFromScode(E_POINTER);

	*pLocaleID = GetThreadLocale();
	return NOERROR;
}


STDMETHODIMP COlePage::XPropertyPageSite::GetPageContainer(
	LPUNKNOWN FAR* ppUnk)
{
	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)
	ASSERT_VALID(pThis);
	ASSERT(ppUnk != NULL);

	if (ppUnk != NULL)
		return ResultFromScode(E_POINTER);

	*ppUnk = NULL;
	return ResultFromScode(E_FAIL);
}


STDMETHODIMP COlePage::XPropertyPageSite::TranslateAccelerator(
	LPMSG lpMsg)
{
	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)
	ASSERT_VALID(pThis);
	ASSERT(pThis->m_lpPropPage != NULL);

	if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB)
	{
		pThis->m_pSheetWnd->SetFocus();
		return NOERROR;
	}

	if (pThis->m_pSheetWnd->PreTranslateMessage(lpMsg))
		return NOERROR;

	return ResultFromScode(S_FALSE);
}


STDMETHODIMP_(ULONG) COlePage::XPropertyPageSite::AddRef()
{
	// Delegate to our exported AddRef.

	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COlePage::XPropertyPageSite::Release()
{
	// Delegate to our exported Release.

	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COlePage::XPropertyPageSite::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.

	METHOD_PROLOGUE_EX(COlePage, PropertyPageSite)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
//	Global property window API

BOOL CreatePropertyBrowser()
{
	ASSERT(g_PropSheet == NULL);
	
	g_PropSheet = new CSheetWnd;
	if (!g_PropSheet->Create())
		return FALSE;

	//  PPMOVE : [matthewt]
	// need to do this in a VSHELL across package kinda way
	// ReadPropertyBrowserProfile();
	
	return TRUE;
}

void DestroyPropertyBrowser()
{
	if (g_PropSheet != NULL)
	{
		g_PropSheet->DestroyWindow();
		g_PropSheet = NULL;
	}
}

CSheetWnd* GetPropertyBrowser()
{
	return g_PropSheet;
}

//	SetPropertyBrowserVisible
//		Used for operations that need to hide the property window
//		temporarily, but do not want to change the push pin state.

void SetPropertyBrowserVisible(BOOL bVisible)
{
	// IStudio needs to progamatically show and hide
	// the property browser,  but under certain conditions
	// (ie. when processing File.Exit, istudio will 
	// call this routine to hide the browser, but the
	// browser has already been destroyed by the shell.
	if(!g_PropSheet || !::IsWindow(g_PropSheet->m_hWnd))
		return;

	g_PropSheetVisible = bVisible;
	if (!bVisible)
		ShowPropertyBrowser(FALSE);
}

void ShowPropertyBrowser(BOOL bShow /* = TRUE */)
{
	ASSERT_VALID(g_PropSheet);

	BOOL fPoppingProperties;
	theApp.m_theAppSlob.GetIntProp(P_PoppingProperties, fPoppingProperties);

	g_PropSheet->ShowWindow(bShow ? (fPoppingProperties ? SW_SHOW : SW_SHOWNOACTIVATE) : SW_HIDE);
}

void PinPropertyBrowser(BOOL bPin /* = TRUE */)
{
	if(!g_PropSheet || !::IsWindow(g_PropSheet->m_hWnd) || !IsPropertyBrowserVisible())
		return;
	g_PropSheet->SetPushPin(bPin);
}

BOOL IsPropertyBrowserPinned()
{
	// IStudio needs to progamatically Pin 
	// the property browser,  but under certain conditions
	// (ie. when processing File.Exit, istudio will 
	// call this routine to hide the browser, but the
	// browser has already been destroyed by the shell.
	if(!g_PropSheet || !::IsWindow(g_PropSheet->m_hWnd))
		return FALSE;
		
	ASSERT_VALID(g_PropSheet);
	if(!IsPropertyBrowserVisible())
	{
		ASSERT(!g_PropSheet->IsPinned());
		return FALSE;
	}
	return g_PropSheet->IsPinned();
}

void InvalidatePropertyBrowser()
{
	ASSERT_VALID(g_PropSheet);
	
	g_PropSheet->Invalidate(FALSE);
}

void UpdatePropertyBrowser()
{
	ASSERT_VALID(g_PropSheet);
	
	g_PropSheet->IdleUpdate();
}

BOOL IsPropertyBrowserVisible()
{
	ASSERT_VALID(g_PropSheet);
	
	return g_PropSheetVisible;
}

BOOL ValidatePropertyBrowser()
{
	if (g_PropSheet == NULL)
		return TRUE;
	
	return g_PropSheet->Validate();
}

void ClosePropertyBrowser()
{
	ASSERT_VALID(g_PropSheet);
	
	g_PropSheet->SendMessage(WM_CLOSE);
}

void SetPropertyBrowserSelection(CSlob* pSlob, int nPage /* = -1 */, 
	CSheetWnd::SELSTYLE style /* = editor */)
{
	if (g_PropSheet == NULL) // happens during exit...
		return;

	ASSERT_VALID(g_PropSheet);
	
	if (pSlob == NULL)
		style = CSheetWnd::none;
	
	g_PropSheet->SelectionChange(style, pSlob, nPage);
	
	if (pSlob == NULL)
		UpdatePropertyBrowser();

	g_PropSheet->NukeInforms();
}

void ResetPropertyBrowserSelectionSlob(CSlob* pSlob)
{
	SetPropertyBrowserSelection(pSlob);
}

void ActivatePropertyBrowser()
{
	__try 
	{
		ASSERT_VALID(g_PropSheet);
		ASSERT(!bQuitting);
		
		g_PropSheet->IdleUpdate();	// Make sure slobs are up to date.
		g_PropSheet->SetActiveWindow();
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		AfxMessageBox (IDS_ERROR_PROPERTYPAGES, MB_ICONEXCLAMATION |MB_OK);
		TRACE ("Error: caught exception in proppage.cpp, ActivatePropertyBrowser()\n");
	}
}

void DeactivatePropertyBrowser()
{
	if (g_PropSheet != NULL &&
		CWnd::GetActiveWindow() == g_PropSheet)
	{
		ASSERT(!bQuitting);
		AfxGetApp()->m_pMainWnd->SetFocus();
	}
}

void CancelPropertyBrowser()
{
	ASSERT_VALID(g_PropSheet);
	
	g_PropSheet->CancelPage();
}

BOOL BeginPropertyBrowserEdit(UINT nProp, UINT nChar, UINT nRepeat, UINT nFlags)
{
	ASSERT_VALID(g_PropSheet);
	
	CWnd* pEdit = g_PropSheet->SetEditFocus(nProp);
	if (pEdit == NULL)
		return FALSE;
	
	g_PropSheetVisible = TRUE;
	
	if (nChar != 0)
		pEdit->PostMessage(WM_CHAR, nChar, MAKELPARAM(nRepeat, nFlags));
	
	return TRUE;
}

CWnd* GetPropertyBrowserControl(UINT nID)
{
	ASSERT_VALID(g_PropSheet);
	
	return g_PropSheet->GetControl(nID);
}

C3dPropertyPage* GetNullPropertyPage()
{
	ASSERT_VALID(g_PropSheet);
	
	return &g_PropSheet->m_nullPage;
}

C3dPropertyPage* GetCurrentPropertyPage()
{
	ASSERT_VALID(g_PropSheet);
	
	return g_PropSheet->GetCurrentPage();
}

void SetPropertyBrowserDefPage()
{
	ASSERT_VALID(g_PropSheet);
	
	g_PropSheet->SetDefaultPage();
}

BOOL IsPropertyBrowserInCancel()
{
	ASSERT_VALID(g_PropSheet);
	
	return g_PropSheet->IsInCancel();
}

BOOL IsPropertyBrowserValidating()
{
	ASSERT_VALID(g_PropSheet);
	
	return g_PropSheet->IsValidating();
}

void PropPageIdle()
{
	if (GetPropertyBrowser() != NULL)
	{
		// PPMOVE : [matthewt]
		// VSHELL currently does not support this
		/*
		if (InEmergencyState())
		{
			// Hide the popups when we're in an emergency state. Note
			// that the user will have to explicitly show these windows
			// after they have been closed due to an emergency.  (This
			// prevents them from flashing on and off when hiding them
			// frees just enough memory to show them again.)

			if (m_pMainwnd->GetLastActivePopup() == pPropSheet)
			{
				CancelPropertyBrowser();
				ClosePropertyBrowser();
			}
		}
		else
			*/
		{
			// If one window is open, and the use minimizes it, we
			// need this final line of defense to null out the properties.
			//
			CWnd* pFrame = GetActiveSlobWnd();
			if (pFrame != NULL)
			{
				pFrame = pFrame->GetParentFrame();
					if (pFrame != NULL &&
						pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)) &&
						pFrame->IsIconic())
						theApp.m_theAppSlob.SetSlobProp(P_CurrentSlob, NULL);
			}

			// If the page will be visible, update it.
			BOOL bShowProps = IsPropertyBrowserVisible();
			if (bShowProps)
				UpdatePropertyBrowser();

			ShowPropertyBrowser(bShowProps);
		}
	}
}

//
// Methods used during CSlob::SetupPropertyPages()
//

int AddPropertyPage(C3dPropertyPage* pPage, CSlob* pSlob)
{
	ASSERT( GetPropertyBrowser() != NULL );
	return GetPropertyBrowser()->AddPropertyPage(pPage, pSlob);
}

void SetPropertyCaption(LPCTSTR sz)
{
	ASSERT( GetPropertyBrowser() != NULL );
	GetPropertyBrowser()->SetCaption(sz);
}

BOOL AppendExtraPropertyPages(void)
{
	ASSERT( GetPropertyBrowser() != NULL );
	return GetPropertyBrowser()->AppendExtraPages();
}

BOOL InhibitExtraPropertyPages(BOOL bInhibit)
{
	ASSERT( GetPropertyBrowser() != NULL );
	return GetPropertyBrowser()->InhibitExtraPages(bInhibit);
}

int StartNewPropertyPageSet(void)
{
	ASSERT( GetPropertyBrowser() != NULL );
	return GetPropertyBrowser()->StartNewPageSet();
}

int MergePropertyPageSets(void)
{
	ASSERT( GetPropertyBrowser() != NULL );
	return GetPropertyBrowser()->MergePageSets();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\re.h ===
/*  re.h - common include files for regular expression compilers
 */

#define INTERNAL    near

/* defined actions for parsing */

typedef  int OPTYPE ;

#define ACTIONMIN   ((OPTYPE) 0)

#define PROLOG	    ((OPTYPE) 0)
#define LEFTARG     ((OPTYPE) 1)
#define RIGHTARG    ((OPTYPE) 2)
#define SMSTAR	    ((OPTYPE) 3)
#define SMSTAR1     ((OPTYPE) 4)
#define STAR	    ((OPTYPE) 5)
#define STAR1	    ((OPTYPE) 6)
#define ANY	    ((OPTYPE) 7)
#define BOL	    ((OPTYPE) 8)
#define EOL	    ((OPTYPE) 9)
#define NOTSIGN     ((OPTYPE) 10)
#define NOTSIGN1    ((OPTYPE) 11)
#define LETTER	    ((OPTYPE) 12)
#define LEFTOR	    ((OPTYPE) 13)
#define ORSIGN	    ((OPTYPE) 14)
#define RIGHTOR     ((OPTYPE) 15)
#define CCLBEG	    ((OPTYPE) 16)
#define CCLNOT	    ((OPTYPE) 17)
#define RANGE	    ((OPTYPE) 18)
#define EPILOG	    ((OPTYPE) 19)
#define PREV	    ((OPTYPE) 20)

// International (Japan only)
#define RANGEJ1     ((OPTYPE) 21)
#define RANGEJ2     ((OPTYPE) 22)
#define ACTIONMAX	((OPTYPE) 22)

/*	query */
BOOL	FParseExpr(UINT, BOOL);		// Check to see if an expression is valid

/*  function forward declarations */

char			 fREMatch (struct patType *,char *,char *,char );
char			 REGetArg (struct patType *,int ,char *);
int			 RELength (struct patType *,int );
char *			 REStart (struct patType *);

typedef unsigned INTERNAL ACT (OPTYPE, unsigned int,
			       unsigned char, unsigned char, patType *);

typedef ACT *PACT;

ACT			 CompileAction;
ACT			 EstimateAction;
ACT			 NullAction;

int	PASCAL	INTERNAL RECharType (char *);
int	PASCAL	INTERNAL RECharLen (char *);
int	PASCAL	INTERNAL REClosureLen (char *);
BOOL PASCAL INTERNAL FREAltExpr(char *, patType *);
char *	PASCAL INTERNAL FEpsASCII(char *, long *);
BOOL PASCAL INTERNAL FEpsTab(char *);
char *	PASCAL	INTERNAL REParseRE (PACT, char *,int *, patType *);
char *	PASCAL	INTERNAL REParseE (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseGroup (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseSE (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseAltE (PACT, register char *, patType *);
char *	PASCAL	INTERNAL REParseClass (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseAny (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseXAscii(PACT, char *, patType *);
char *	PASCAL	INTERNAL REParseCaret(PACT, char *, patType *);
char *	PASCAL	INTERNAL REParseWild (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseBOL (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParsePrev (PACT, char *, patType *);
char *	PASCAL	INTERNAL REParseEOL (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseAlt (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseNot (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseAbbrev (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseChar (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseClosure (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParseGreedy (PACT,char *, patType *);
char *	PASCAL	INTERNAL REParsePower (PACT,char *, patType *);
char	PASCAL	INTERNAL REClosureChar (char *, patType *);
char	PASCAL	INTERNAL Escaped (char );

void	PASCAL	INTERNAL REStackOverflow (void);
BOOL	REEstimate (char *, int *);

#ifdef _DEBUG
void INTERNAL REDump (struct patType *p);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\remi.h ===
/*
 *  History:
 *
 *	??-???-???? ?? Created
 *	15-Sep-1988 bw Added REM_*, changed REMatch parameters.
*/

#ifndef __REMI_H__
#define __REMI_H__

#define MAXPATARG   10			/* 0 is entire 1-9 are valid	     */

/* Return codes from REMatch */

#define REM_MATCH   0		    /* A match was found		    */
#define REM_NOMATCH 1		    /* No match was found		    */
#define REM_UNDEF   2		    /* An undefined Op-code was encountered */
#define REM_STKOVR  3		    /* The stack overflowed		    */
#define REM_INVALID 4		    /* A parameter was invalid		    */


#define MAX_USER_LINE		2048	//Max inside length of editor line

extern char XLTab[256];
typedef char flagType;
typedef unsigned char RE_OPCODE;

/* structure of compiled pattern */

struct patType {
    flagType	fCase;				/* TRUE => case is significant	     */
    reSyntax	reSyntx;			/* unix, brief, epsilon or zibo      */
	int			RESize;				/* estimated size */
	RE_OPCODE *	REip;				/* Instruction pointer */
	int			REArg;
    char *		pArgBeg[MAXPATARG];	/* beginning of tagged strings	     */
    char *		pArgEnd[MAXPATARG];	/* end of tagged strings	     */
    RE_OPCODE	code[1];			/* pseudo-code instructions	     */
};

#define RE_LOCAL	0				// Indices for global vars above:  Only two simultaneous searches allowed,
#define RE_GREP		1				// one from grep and one local to a file. dolphin 7522: [kherold]


int		REMatch(struct patType  *,LPCTSTR,LPCTSTR,RE_OPCODE *[], unsigned, char, /* out */ BOOL *pbLineMatch);
char	REGetArg(struct patType  *,int ,char  *);
char	RETranslate(struct patType  *,char  *,char  *);
int		RELength(struct patType  *,int );
char	*REStart(struct patType  *);

#endif	// __REMI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\reparse.cpp ===
/*  reparse.c - parse a regular expression
 *
 *  cl /c /Zep /AM /NT RE /Gs /G2 /Oa /D LINT_ARGS /Fc reparse.c
 *
 *  Modifications:
 *
 *	22-Jul-1986 mz	Hookable allocator (allow Z to create enough free space)
 *	19-Nov-1986 mz	Add RETranslateLength for Z to determine overflows
 *	18-Aug-1987 mz	Add field width and justification in translations
 *	01-Mar-1988 mz	Add in UNIX-like syntax
 *	14-Jun-1988 mz	Fix file parts allowing backslashes
 *	04-Dec-1989 bp	Let :p accept uppercase drive names
 *	20-Dec-1989 ln	capture trailing periods in :p
 *	23-Jan-1990 ln	Handle escaped characters & invalid trailing \ in
 *			RETranslate.
 *	05-Feb-1991 mz	Merged in KANJI stuff
 *
 */
#include "stdafx.h"
#include <stdio.h>
#include <ctype.h>
#include <malloc.h>
#include <string.h>
#include <tchar.h>

#undef CC_NONE

#include "remi.h"
#include "re.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#if _DEBUG
#if 0
static CString g_strBuf;
#define DEBOUT(x) { g_strBuf.Format x; AfxOutputDebugString(g_strBuf); } // gross, but under debug & works
#else
#define DEBOUT(x)
#endif
#else
#define DEBOUT(x)
#endif


/*  regular expression compiler.  A regular expression is compiled into pseudo-
 *  machine code.  The principle is portable to other machines and is outlined
 *  below.  We parse by recursive descent.
 *
 *  The pseudo-code is fairly close to normal assembler and can be easily
 *  converted to be real machine code and has been done for the 80*86
 *  processor family.
 *
 *  The basic regular expressions handled are:
 *
 *	letter	    matches a single letter
 *	[class]     matches a single character in the class
 *	[~class]    matches a single character not in the class
 *	^	    matches the beginning of the line
 *	$	    matches the end of the line
 *	?	    matches any character (except previous two)
 *	\x	    literal x
 *	\n	    matches the previously tagged/matched expression (n digit)
 *
 *  Regular expressions are now build from the above via:
 *
 *	x*	    matches 0 or more x, matching minimal number
 *	x+	    matches 1 or more x, matching minimal number
 *	x@	    matches 0 or more x, matching maximal number
 *	x#	    matches 1 or more x, matching maximal number
 *	(x1!x2!...) matches x1 or x2 or ...
 *	~x	    matches 0 characters but prevents x from occuring
 *	{x}	    identifies an argument
 *
 *  The final expression that is matched by the compiler is:
 *
 *	xy	    matches x then y
 *
 *
 *  The actual grammar used is: 		    Parsing action:
 *
 *	TOP ->	re				    PROLOG .re. EPILOG
 *
 *
 *	re ->	alte re |
 *			empty
 *
 *	alte -> e '|' alte	|
 *			e			|
 *
 *	e ->	
 *		se *		|			    SMSTAR .se. SMSTAR1
 *		se +	    |
 *		se @	    |			    STAR .se. STAR1
 *		se #	    |
 *		se
 *
 *	se ->	( alt )     |
 *		[ ccl ]     |
 *		{ re }	|
 *		?	    |			    ANY
 *		^	    |			    BOL
 *		$	    |			    EOL
 *		~ se	    |			    NOTSIGN .se. NOTSIGN1
 *		:x	    |
 *		\n	    |			    PREV
 *		letter				    LETTER x
 *
 *	alt ->	re ! alt    |			    LEFTOR .re. ORSIGN
 *		re				    LEFTOR .re. ORSIGN RIGHTOR
 *
 *	ccl ->	~ cset	    |			    CCLBEG NOTSIGN .cset. CCLEND
 *		cset				    CCLBEG NULL .cset. CCLEND
 *
 *	cset -> item cset   |
 *		item
 *
 *	item -> letter - letter |		    RANGE x y
 *		letter				    RANGE x x
 *
 *  Abbreviations are introduced by :.
 *
 *	:a	[a-zA-Z0-9]				alphanumeric
 *	:b	[<space><tab>]		single whitespace character
 *	:c	[a-zA-Z]				alphabetic
 *	:d	[0-9]					digit
 *	:f	([~/\\ "\[\]\:<|>+=;,.]#)               file part
 *	:h	([0-9a-fA-F]#)				hex number
 *	:i	([a-zA-Z_$][a-zA-Z0-9_$]@)		identifier
 *	:n	([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)	number
 *	:p	(([A-Za-z]\:!)(\\!)(:f(.:f!)(\\!/))@:f(.:f!.!))	path
 *	:q	("[~"]@"!'[~']@')                       quoted string
 *	:w	([a-zA-Z]#)				word
 *	:z	([0-9]#)				integer
 *
 */

/*  There are several classes of characters:
 *
 *  Closure characters are suffixes that indicate repetition of the previous
 *  RE.
 *
 *  Simple RE chars are characters that indicate a particular type of match
 *
 */

/*  Closure character equates
 */
#define CC_SMPLUS	0		/* plus closure 		     */
#define CC_SMCLOSURE	1		/* star closure 		     */
#define CC_POWER	2		/* n repetitions of previous pattern */
#define CC_CLOSURE	3		/* greedy closure		     */
#define CC_PLUS 	4		/* greedy plus			     */
#define CC_NONE 	5
#define CC_ERROR	-1

/*  Simple RE character equates */
#define SR_BOL		0
#define SR_EOL		1
#define SR_ANY		2
#define SR_CCLBEG	3
#define SR_LEFTOR	4
#define SR_CCLEND	5
#define SR_ABBREV	6
#define SR_RIGHTOR	7
#define SR_ORSIGN	8
#define SR_NOTSIGN	9
#define SR_LEFTARG	10
#define SR_RIGHTARG	11
#define SR_LETTER	12
#define SR_PREV 	13
#define SR_WILD		14
#define SR_XASCII	15
#define SR_NOT_HANDLED	16

int EndAltRE[] =    { SR_ORSIGN, SR_RIGHTOR, -1 };
int EndArg[] =	    { SR_RIGHTARG, -1 };

char *pAbbrev[] = {
	 "a[a-zA-Z0-9]",
//	 "b([ \t]#)",
	 "b[ \t]",
	 "c[a-zA-Z]",
	 "d[0-9]",
	 "f([~/\\\\ \\\"\\[\\]\\:<|>+=;,.]#!..!.)",
	 "h([0-9a-fA-F]#)",
	 "i([a-zA-Z_$][a-zA-Z0-9_$]@)",
	 "n([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)",
	 "p(([A-Za-z]\\:!)(\\\\!/!)(:f(.:f!)(\\\\!/))@:f(.:f!.!))",
	 "q(\"[~\"]@\"!'[~']@')",
	 "w([a-zA-Z]#)",
	 "z([0-9]#)",
	 NULL
};

static char *digits = "0123456789";
static char strEpsTab[] = "<tab>";

static reSyntax g_reSntx = reZibo;

static int cArg;

/*  RECharType - classify a character type
 *
 *  p		character pointer
 *
 *  returns	type of character (SR_xx)
 */
int PASCAL INTERNAL RECharType (char *p)
{
	LONG lArg;

	if (g_reSntx == reZibo) {
	/* Zibo syntax
     */
		switch (*p) {
		case '^':
			 return SR_BOL;
		case '$':
			if (_istdigit ((unsigned char)p[1]))
				return SR_PREV;
			else
				return SR_EOL;
		case '?':
			return SR_ANY;
		case '[':
			return SR_CCLBEG;
		case '(':
			return SR_LEFTOR;
		case ']':
			return SR_CCLEND;
		case ':':
			return SR_ABBREV;
		case ')':
			return SR_RIGHTOR;
		case '!':
			return SR_ORSIGN;
		case '~':
			return SR_NOTSIGN;
		case '{':
			return SR_LEFTARG;
		case '}':
			return SR_RIGHTARG;
		default:
			return SR_LETTER;
		}
	}
	else if (g_reSntx == reUnix) {
	/*  Crappy UNIX syntax
	 */
		switch (*p) {
		case '^':
			return SR_BOL;
		case '$':
			return SR_EOL;
		case '.':
			return SR_ANY;
		case '[':
			return SR_CCLBEG;
		case ']':
			return SR_CCLEND;
		case '\\':
			switch (p[1]) {
			case ':':			    /*	\:C */
				return SR_ABBREV;
			case '(':			    /*	\(  */
				return SR_LEFTARG;
			case ')':			    /*	\)  */
				return SR_RIGHTARG;
			case '~':			    /*	\~  */
				return SR_NOTSIGN;
			case '{':			    /*	\{  */
				return SR_LEFTOR;
			case '}':			    /*	\}  */
				return SR_RIGHTOR;
			case '!':			    /*	\!  */
				return SR_ORSIGN;
			}
			if (_istdigit ((unsigned char)p[1])) 	    /*	\N  */
				return SR_PREV;
		default:
			return SR_LETTER;
		}
	}
	else if (g_reSntx == reBrief) {

		switch (*p) {
		case '{':
			return SR_LEFTARG;
		case '}':
			return SR_RIGHTARG;
		case '<':
		case '%':
			return SR_BOL;
		case '|':
			return SR_ORSIGN;
		case '>':
		case '$':
			return SR_EOL;
		case '[':
			return SR_CCLBEG;
		case ']':
			return SR_CCLEND;
		case '~':
			return SR_NOTSIGN;
		case '?':
			return SR_ANY;
		case '*':
			return SR_WILD;
		case '\\':
			switch (p[1]) {
			case 'x':
				return SR_XASCII;		// hex ascii specifier
			case 'n':
			case 'c':
				return SR_NOT_HANDLED;	// part of the syntax, but we don't compile them
			}
		default:
			return SR_LETTER;
		}
	}
	else {
		ASSERT(g_reSntx == reEpsilon);

		switch (*p) {
		case '|':
			return SR_ORSIGN;
		case '^':
			 return SR_BOL;
		case '.':
			return SR_ANY;
		case '[':
			return SR_CCLBEG;
		case ']':
			return SR_CCLEND;
		case '~':
			return SR_NOTSIGN;
		case '(':
			return SR_LEFTARG;
		case ')':
			return SR_RIGHTARG;
		case '$':
			return SR_EOL;
		case '<':
			if (FEpsASCII(p, &lArg))
				return SR_XASCII;

			// else fall through
		default:
			return SR_LETTER;
		}
	}
}

/*  RECharLen - length of character type
 *
 *  p		character pointer to type
 *
 *  returns	length in chars of type
 */
int PASCAL INTERNAL RECharLen (char *p)
{
	if (g_reSntx == reZibo)
		if (RECharType (p) == SR_PREV)	    /*	$N  */
			return 2;
	else
		if (RECharType (p) == SR_ABBREV)    /*	:N  */
			return 2;
	else
		 return 1;

	else {
		if (*p == '\\')
		switch (p[1]) {
			case '{':
			case '}':
			case '~':
			case '(':
			case ')':
			case '!':
				return 2;		    /*	\C  */
			case ':':			    /*	\:C */
				return 3;
			default:
				if (_istdigit ((unsigned char)p[1]))
					return 2;		/*	\N  */
			else
				return 1;
			}
		return 1;
	}
}

/*  REClosureLen - length of character type
 *
 *  p		character pointer to type
 *
 *  returns	length in chars of type
 */
int PASCAL INTERNAL REClosureLen (char *p)
{
	p;

	return 1;
}

/*  REParseRE - parse a general RE up to but not including the pEnd set
 *  of chars.  Apply a particular action to each node in the parse tree.
 *
 *  pAction	Parse action routine to call at particluar points in the
 *		parse tree.  This routine returns an unsigned quantity that
 *		is expected to be passed on to other action calls within the
 *		same node.
 *  p		character pointer to string being parsed
 *  pEnd	pointer to set of char types that end the current RE.
 *		External callers will typically use NULL for this value.
 *		Internally, however, we need to break on the ALT-terminating
 *		types or on arg-terminating types.
 *
 *  Returns:	pointer to delimited character if successful parse
 *		NULL if unsuccessful parse (syntax error).
 *
 */
char * PASCAL INTERNAL REParseRE (PACT pAction, register char *p, int *pEnd, patType *pat)
{
	int *pe;
	DEBOUT (("REParseRE (%04x, %s)\n", pAction, p));

	while (TRUE)
	{
		/*  If we're at end of input
		 */

		if (*p == '\0')
		{
			/*	If we're not in the midst of an open expression
			 */
			if (pEnd == NULL)
				/*  return the current parse position
				 */
				return p;
			else
			{
				/*  End of input, but expecting more, ERROR
				 */
				DEBOUT (("REParse expecting more, ERROR\n"));
				return NULL;
			}
		}

		/*  If there is an open expression
		 */
		if (pEnd != NULL)
		{
			/*	Find a matching character
			 */
			for (pe = pEnd; *pe != -1; pe++)
				if (RECharType (p) == *pe)
					return p;
		}

		if ((p = REParseAltE (pAction, p, pat)) == NULL)
			return NULL;
	}
}


char * PASCAL INTERNAL REParseAltE (PACT pAction, register char *p, patType *pat)
{
	unsigned int u = 0;

	if (FREAltExpr (p, pat))
	{
		u = (*pAction) (LEFTOR, u, 0, 0, pat);
		// Parse the left expression
		if ((p = REParseE (pAction, p, pat)) == NULL)
			return NULL;

		u = (*pAction) (ORSIGN, u, 0, 0, pat);
		p += RECharLen(p);

		// Parse the right expression
		u = (*pAction) (LEFTOR, u, 0, 0, pat);
		if ((p = REParseAltE (pAction, p, pat)) == NULL)
			return NULL;
		u = (*pAction) (ORSIGN, u, 0, 0, pat);
		(*pAction) (RIGHTOR, u, 0, 0, pat);
	}
	else
		p = REParseE (pAction, p, pat);

	return p;
}


char * PASCAL INTERNAL REParseGroup (PACT pAction, char *p, patType *pat)
{
	unsigned u;

	u = (*pAction) (LEFTARG, 0, 0, 0, pat);
	p += RECharLen(p);
	while (RECharType (p) != SR_RIGHTARG)
	{
		if ((p = REParseRE (pAction, p, EndArg, pat)) == NULL)
			return NULL;
	}
	(*pAction) (RIGHTARG, u, 0, 0, pat);
	cArg++;
	return p + RECharLen (p);
}


/*  REParseE - parse a simple regular expression with potential closures.
 *
 *  pAction	Action to apply at special parse nodes
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseE (PACT pAction, register char *p, patType *pat)
{
	DEBOUT (("REParseE (%04x, %s)\n", pAction, p));

	switch (REClosureChar (p, pat)) {
	case CC_SMPLUS:
		if (REParseSE (pAction, p, pat) == NULL)
				return NULL;
	case CC_SMCLOSURE:
		return REParseClosure (pAction, p, pat);

	case CC_PLUS:
		if (REParseSE (pAction, p, pat) == NULL)
			return NULL;
	case CC_CLOSURE:
		return REParseGreedy (pAction, p, pat);

	case CC_POWER:
		return REParsePower (pAction, p, pat);

	case CC_NONE:
		return REParseSE (pAction, p, pat);

	default:
		return NULL;
	}
}

/*  REParseSE - parse a simple regular expression
 *
 *  pAction	Action to apply at special parse nodes
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseSE (register PACT pAction, register char *p, patType *pat)
{
	DEBOUT (("REParseSE (%04x, %s)\n", pAction, p));

	switch (RECharType (p)) {
	case SR_CCLBEG:
		return REParseClass (pAction, p, pat);
	case SR_LEFTARG:
		return REParseGroup (pAction, p, pat);
	case SR_ANY:
		return REParseAny (pAction, p, pat);
	case SR_WILD:
		return REParseWild (pAction, p, pat);
	case SR_XASCII:
		return REParseXAscii(pAction, p, pat);
	case SR_BOL:
		return REParseBOL (pAction, p, pat);
	case SR_EOL:
		return REParseEOL (pAction, p, pat);
	case SR_PREV:
		return REParsePrev (pAction, p, pat);
	case SR_LEFTOR:
		return REParseAlt (pAction, p, pat);
	case SR_NOTSIGN:
		return REParseNot (pAction, p, pat);
	case SR_ABBREV:
		return REParseAbbrev (pAction, p, pat);
	case SR_NOT_HANDLED:	// for syntax we don't handle
		return NULL;
	default:
		return REParseChar (pAction, p, pat);
	}
}

/*  REParseClass - parse a class membership match
 *
 *  pAction	Action to apply at beginning of parse and at each range
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseClass (PACT pAction, register char *p, patType *pat)
{
	char c;
	char c2, c3, c4;
	unsigned u;

	DEBOUT (("REParseClass (%04x, %s)\n", pAction, p));

	p += RECharLen (p);
	if (((g_reSntx == reZibo) && *p == '~') ||
		((g_reSntx == reBrief) && *p == '~') ||
		((g_reSntx == reUnix || g_reSntx == reEpsilon) && *p == '^'))
	{
		u = (*pAction) (CCLNOT, 0, 0, 0, pat);
		p += RECharLen (p);
	}
	else
		u = (*pAction) (CCLBEG, 0, 0, 0, pat);

	while (RECharType (p) != SR_CCLEND)
	{

		if ((*p == '\\' && g_reSntx != reEpsilon) ||
			(*p == '%' && g_reSntx == reEpsilon))
		{
			p++;
			if (g_reSntx == reBrief || g_reSntx == reEpsilon)
				*p = Escaped(*p);
		}

		if (*p == '\0') {
			DEBOUT (("REParseClass expecting more, ERROR\n"));
			return NULL;
		}

		if (FEpsTab(p))
		{
			c = '\t';
			p += _tcslen(strEpsTab);
		}
		else
			c = *p++;

		if (theApp.m_fOEM_MBCS) {
			if (isleadbyte((unsigned char)c))
				c2 = *p++;
			else {
				c2 = c;
				c = 0;
			}
		}
		if (*p == '-') {
			p++;
			if (*p == '\\')
				p++;
			if (*p == '\0') {
				DEBOUT (("REParseClass expecting more, ERROR\n"));
				return NULL;
			}
			if (theApp.m_fOEM_MBCS) {
				c3 = *p;
				if (isleadbyte(*(unsigned char *)p))
					c4 = *++p;
				else {
					c4 = c3;
					c3 = 0;
				}
				if ( (c == 0 && c3 == 0) || (c != 0 && c3 != 0) ) {
					u = (*pAction) (RANGEJ1, 0, c, c2, pat);
					(*pAction) (RANGEJ2, u, c3, c4, pat);
				}
				else
					return NULL;
			}
			else {
				(*pAction) (RANGE, u, c, *p, pat);
			}
			p++;
		}
		else {
			if (theApp.m_fOEM_MBCS) {
				u = (*pAction) (RANGEJ1, 0, c, c2, pat);
				(*pAction) (RANGEJ2, u, c, c2, pat);
			}
			else {
			(*pAction) (RANGE, u, c, c, pat);
			}
		}
	}
	if (theApp.m_fOEM_MBCS) {
		c = 0;
		u = (*pAction) (RANGEJ1, 0, c, c, pat);
		(*pAction) (RANGEJ2, u, c, c, pat);
	}
	return p + RECharLen (p);
}

/*	REParseWild - parse a match-zero-or-more-any expression
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseWild (PACT pAction, char *p, patType *pat)
{
	unsigned u;
	DEBOUT (("REParseWild (%04x, %s)\n", pAction, p));

	// Create this instruction by emulating a '.*'
	u = (*pAction) (SMSTAR, 0, 0, 0, pat);
	(*pAction) (ANY, 0, 0, 0, pat);
	(*pAction) (SMSTAR1, u, 0, 0, pat);

	return p + RECharLen(p);
}

/*	REParseXAscii - parse a hex-specified ascii character
 *
 *	pAction	Action to apply
 *	p		Character pointer to spot where parsing occurs
 *
 *	Returns pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseXAscii (PACT pAction, char *p, patType * pat)
{
	if (g_reSntx == reEpsilon)
	{
		LONG l;
		if (p = FEpsASCII(p, &l))
		{
			(*pAction)(LETTER, 0, (unsigned char)l, 0, pat);
			return p;
		}

		// Wasn't the format we expected!
		ASSERT(FALSE);
		return NULL;
	}
	else
	{
		int i;
		int	cDigits = 0;

		p += 2;

		// Make sure we have at least one valid digit following
		if (!*p || !_istxdigit(*(unsigned char *)p))
			return NULL;
		else
			cDigits++;

		// And check to see if there's a second
		if (*(p + 1) && _istxdigit(*(unsigned char *)(p + 1)))
			cDigits++;

		// Take a look at the two subsequent digits and create an ascii character out of them.
		_stscanf(p, "%2x", &i);

		// Make a character out of what we just read
		(*pAction) (LETTER, 0, (unsigned char)i, 0, pat);

		return p + cDigits;
	}
}

/*  REParseAny - parse a match-any-character expression
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseAny (PACT pAction, char *p, patType * pat)
{
	DEBOUT (("REParseAny (%04x, %s)\n", pAction, p));

	(*pAction) (ANY, 0, 0, 0, pat);
	return p + RECharLen (p);
}

/*  REParseBOL - parse a beginning-of-line match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseBOL (PACT pAction, char *p, patType * pat)
{
	DEBOUT (("REParseBOL (%04x, %s)\n", pAction, p));

	(*pAction) (BOL, 0, 0, 0, pat);
	return p + RECharLen (p);
}

/*  REParsePrev - parse a previous-match item
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParsePrev (PACT pAction, char *p, patType * pat)
{
	unsigned int i = *(p + 1) - '0';

	DEBOUT (("REParsePrev (%04x, %s)\n", pAction, p));

	if (i < 1 || i > (unsigned) cArg) {
		DEBOUT (("REParsePrev invalid previous number, ERROR\n"));
		return NULL;
	}

	(*pAction) (PREV, i, 0, 0, pat);
	return p + RECharLen (p);
}

/*  REParseEOL - parse an end-of-line match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseEOL (PACT pAction, char *p, patType * pat)
{
	DEBOUT (("REParseEOL (%04x, %s)\n", pAction, p));

	(*pAction) (EOL, 0, 0, 0, pat);
	return p + RECharLen (p);
}

/*  REParseAlt - parse a series of alternatives
 *
 *  pAction	Action to apply before and after each alternative
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseAlt (PACT pAction, register char *p, patType * pat)
{
	unsigned u = 0;

	DEBOUT (("REParseAlt (%04x, %s)\n", pAction, p));

	while (RECharType (p) != SR_RIGHTOR) {
		p += RECharLen (p);
		u = (*pAction) (LEFTOR, u, 0, 0, pat);
		if ((p = REParseRE (pAction, p, EndAltRE, pat)) == NULL)
			return NULL;
		u = (*pAction) (ORSIGN, u, 0, 0, pat);
	}
	(*pAction) (RIGHTOR, u, 0, 0, pat);
	return p + RECharLen (p);
}

/*  REParseNot - parse a guard-against match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseNot (PACT pAction, register char *p, patType * pat)
{
	unsigned u;

	DEBOUT (("REParseNot (%04x, %s)\n", pAction, p));

	p += RECharLen (p);
	if (*p == '\0') {
		DEBOUT (("REParseNot expecting more, ERROR\n"));
		return NULL;
	}
	u = (*pAction) (NOTSIGN, 0, 0, 0, pat);
	p = REParseSE (pAction, p, pat);
	(*pAction) (NOTSIGN1, u, 0, 0, pat);
	return p;
}

/*  REParseAbbrev - parse and expand an abbreviation
 *
 *  Note that since the abbreviations are in Z syntax, we must change syntax
 *  temporarily to Z.  We are careful to do this so that we do not mess up
 *  advancign the pointers.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseAbbrev (PACT pAction, register char *p, patType * pat)
{
	int i;
	reSyntax	reSntxTmp;

	DEBOUT (("REParseAbbrev (%04x, %s)\n", pAction, p));

	p += RECharLen (p);

	reSntxTmp = g_reSntx;
	g_reSntx = reZibo;
	if (p[-1] == '\0') {
		DEBOUT (("REParseAbbrev expecting abbrev char, ERROR\n"));
		g_reSntx = reSntxTmp;
		return NULL;
	}

	for (i = 0; pAbbrev[i]; i++)
		if (p[-1] == *pAbbrev[i])
			if (REParseSE (pAction, pAbbrev[i] + 1, pat) == NULL) {
				g_reSntx = reSntxTmp;
				return NULL;
			}
			else {
				g_reSntx = reSntxTmp;
				return p;
			}
	DEBOUT (("REParseAbbrev found invalid abbrev char %s, ERROR\n", p - 1));
	g_reSntx = reSntxTmp;
	return NULL;
}

/*  REParseChar - parse a single character match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseChar (PACT pAction, register char *p, patType * pat)
{
	char c;
	UINT ib;

	DEBOUT (("REParseChar (%04x, %s)\n", pAction, p));

	if ((*p == '\\' && g_reSntx != reEpsilon) ||
		(*p == '%' && g_reSntx == reEpsilon))
	{
		p++;
		if (g_reSntx == reBrief || g_reSntx == reEpsilon)
			c = Escaped(*p);
		else
			c = *p;
	}
	else
		c = *p;

	if (*p == '\0') {
		DEBOUT (("REParseChar expected more, ERROR\n"));
		return NULL;
	}

	if ((g_reSntx == reEpsilon) && FEpsTab(p))
	{
		c = '\t';
		ib = _tcslen(strEpsTab);
	}
	else
		ib = 1;

	if (theApp.m_fOEM_MBCS) {
		if ( isleadbyte ((unsigned char)*p) ) {
			(*pAction) (LETTER, 0, c, *(p+1), pat);
			return p+2;
		}
		else {
			(*pAction) (LETTER, 0, c, 0, pat);
			return p+ib;
		}
	}
	else {
		(*pAction) (LETTER, 0, c, 0, pat);
		return p+ib;
	}
}

/*  REParseClosure - parse a minimal match closure.  The match occurs by
 *  matching none, then one, ...
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseClosure (PACT pAction, register char *p, patType * pat)
{
	unsigned u;

	DEBOUT (("REParseaClosure (%04x, %s)\n", pAction, p));

	u = (*pAction) (SMSTAR, 0, 0, 0, pat);
	if ((p = REParseSE (pAction, p, pat)) == NULL)
		return NULL;
	(*pAction) (SMSTAR1, u, 0, 0, pat);
	return p + REClosureLen (p);
}

/*  REParseGreedy - parse a maximal-match closure.  The match occurs by
 *  matching the maximal number and then backing off as failures occur.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParseGreedy (PACT pAction, register char *p, patType * pat)
{
	unsigned u;

	DEBOUT (("REParseGreedy (%04x, %s)\n", pAction, p));

	u = (*pAction) (STAR, 0, 0, 0, pat);
	if ((p = REParseSE (pAction, p, pat)) == NULL)
		return NULL;
	(*pAction) (STAR1, u, 0, 0, pat);
	return p + REClosureLen (p);
}

/*  REParsePower -  parse a power-closure.  This is merely the simple pattern
 *  repeated the number of times specified by the exponent.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char * PASCAL INTERNAL REParsePower (PACT pAction, char *p, patType * pat)
{
	register char *p1;
	int exp;

	DEBOUT (("REParsePower (%04x, %s)\n", pAction, p));

	/*	We have .se. POWER something.  Skip over the .se. and POWER
	 *	to make sure that what follows is a valid number
	 */
	p1 = REParseSE (NullAction, p, pat);

	if (p1 == NULL)
		/*  Parse of .se. failed
		 */
		return NULL;

	/*	skip POWER
	 */
	p1 += REClosureLen (p1);

	if (*p1 == '\0') {
		DEBOUT (("REParsePower expecting more, ERROR\n"));
		return NULL;
	}

	/* try to parse off number */
	if (sscanf (p1, "%d", &exp) != 1) {
		DEBOUT (("REParsePower expecting number, ERROR\n"));
		return NULL;
	}

	p1 += strspn(p1, digits);

	/* iterate the pattern the exponent number of times */
	while (exp--)
		if (REParseSE (pAction, p, pat) == NULL)
			return NULL;
	return p1;
}

/*  NullAction - a do-nothing action.  Used for stubbing out the action
 *  during a parse.
 */
unsigned  INTERNAL NullAction (OPTYPE type, unsigned int u, unsigned char x, unsigned char y, patType * pat)
{
	type; u; x; y;
	return 0;
}

BOOL PASCAL INTERNAL FREAltExpr (char *p, patType * pat)
{
	if (g_reSntx == reBrief || g_reSntx == reEpsilon)
	{
		p = REParseE (NullAction, p, pat);
		return p && (*p == '|');
	}

	return FALSE;
}


// Returns NULL if false, or the pointer to the character past the end
// of the parsed string if true.

char * PASCAL INTERNAL FEpsASCII(char *p, long *plArg)
{
	char *pEnd = NULL;
	*plArg = 0;

	if (*p == '<')
	{
		p++;

		if (*p == '#')
		{
			char	*pStop, *pTmp;
			char	ch;
			int		base = 10;

			// scan for the matching '>' and temporarily set it to NULL
			if (!(pEnd = _tcschr(p, '>')))
				goto L_Return;

			// Remember to restore this before leaving!
			ch = *pEnd;
			*pEnd = '\0';

			p++;	// past the '#'

			// Decide which sort of number we're trying to scan:
			if (p && ((pTmp = _tcsstr(p, "0b")) || (pTmp = _tcsstr(p, "0B"))))
			{
				base = 2;
				p = pTmp + 2;
			}
			else if (p && ((pTmp = _tcsstr(p, "0x")) || (pTmp = _tcsstr(p, "0X"))))
			{
				base = 16;
				p = pTmp + 2;
			}
			else if (p && ((pTmp = _tcsstr(p, "0o")) || (pTmp = _tcsstr(p, "0O"))))
			{
				base = 8;
				p = pTmp + 2;
			}

			// otherwise, it's 10
			if (p)
				*plArg = _tcstol(p, &pStop, base);
			*pEnd = ch;

			if (*plArg > 0 && (pStop == pEnd))
				pEnd++;
			else
				pEnd = NULL;
		}
	}

L_Return:

	return pEnd;
}

BOOL PASCAL INTERNAL FEpsTab(char *p)
{
	return p && !_tcsnicmp(p, strEpsTab, _tcslen(strEpsTab));
}


/*  REClosureChar - return the character that corresponds to the next
 *  closure to be parsed.  We call REParseSE with a null action to merely
 *  advance the character pointer to point just beyond the current simple
 *  regular expression.
 *
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	closure character if appropriate
 *		CC_NONE if no closure character found.
 */
char  PASCAL INTERNAL REClosureChar (char *p, patType * pat)
{
	p = REParseSE (NullAction, p, pat);
	if (p == NULL)
		return CC_ERROR;

	if (g_reSntx == reZibo)
		/*  Zibo syntax
		 */
		switch (*p) {
		case '^':
			return CC_POWER;
		case '+':
			return CC_SMPLUS;
		case '#':
			return CC_PLUS;
		case '*':
			return CC_SMCLOSURE;
		case '@':
			return CC_CLOSURE;
		default:
			return CC_NONE;
		}
	else if (g_reSntx == reUnix) {
		/*  Crappy UNIX syntax
		 */
		switch (*p) {
		case '+':
			return CC_PLUS;
		case '*':
			return CC_CLOSURE;
		default:
			return CC_NONE;
		}
	}
	else if (g_reSntx == reBrief) {

		switch (*p) {
		case '+':
			return CC_PLUS;
		case '@':
			return CC_SMCLOSURE;
		default:
			return CC_NONE;
		}
	}
	else {

		ASSERT(g_reSntx == reEpsilon);
		switch (*p) {
			case '+':
				return CC_PLUS;
			case '?':			// [kherold]  This actually isn't right, but we can't do "zero or one"
			case '*':
				return CC_CLOSURE;
			default:
				return CC_NONE;
		}
	}
}

/*  RECompile - compile a pattern into the internal machine.  Return a
 *  pointer to the match machine.
 *
 *  p	    character pointer to pattern being compiled
 *
 *  Returns:	pointer to the internal machine if compilation was successful
 *		NULL if syntax error or not enough memory for malloc
 */
patType *RECompile (char *p, flagType fCase, reSyntax reSyntx)
{
	char cLoc ;
	static fXLTabInit = FALSE;
	g_reSntx = reSyntx;
	patType *pat;

	// CUDA #2808 -- compute XLTab correctly for doing case mapping...
	if (!fXLTabInit) {
		AnsiLowerBuff(XLTab, sizeof(XLTab));
		fXLTabInit = TRUE;
	}
	int size;
	if(!REEstimate(p, &size))
		return NULL;

	DEBOUT (("Length is %04x\n", size));

	if ((pat = (struct patType *) malloc(size)) == NULL)
		return NULL;

	memset ((void *) pat, cLoc = (char)(-1), (unsigned int)size);
	memset ((void *) pat->pArgBeg, cLoc = '\0', (unsigned int)sizeof (pat->pArgBeg));
	memset ((void *) pat->pArgEnd, cLoc = '\0', (unsigned int)sizeof (pat->pArgEnd));

	pat->REip = pat->code;
	pat->REArg = 1;
	pat->fCase = fCase;
	pat->reSyntx = reSyntx;

	cArg = 0;

	CompileAction (PROLOG, 0, 0, 0, pat);

	if (REParseRE (CompileAction, p, NULL, pat) == NULL)
		return NULL;

	CompileAction (EPILOG, 0, 0, 0, pat);

#if DEBUG
	REDump (pat);
#endif
	return pat;
}

/*  Escaped - translate an escaped character ala UNIX C conventions.
 *
 *  \t => tab	    \e => ESC char  \h => backspace \g => bell
 *  \n => lf	    \r => cr	    \\ => \
 *
 *  c	    character to be translated
 *
 *  Returns:	character as per above
 */
char  PASCAL INTERNAL Escaped (char c)
{
	switch (c) {
	case 't':
		return '\t';
	case 'e':
		return 0x1B;
	case 'h':
		return 0x08;
	case 'g':
		return 0x07;
#ifdef SUPPORT_NEWLINE_REPLACE
	case 'n':
		return '\n';
	case 'r':
		return '\r';
#endif
	case '\\':
		return '\\';
	default:
		return c;
	}
}

/*  REGetArg - copy argument string out from match.
 *
 *  pat     matched pattern
 *  i	    index of argument to fetch, 0 is entire pattern
 *  p	    destination of argument
 *
 *  Returns:	TRUE if successful, FALSE if i is out of range.
 */
flagType REGetArg (struct patType *pat, int i, char *p)
{
	int l = 0;

	if (i > MAXPATARG)
		return FALSE;
	else
	if (pat->pArgBeg[i] != (char *)-1)
		memmove ((char far *)p, (char far *)pat->pArgBeg[i], l = RELength (pat, i));
	p[l] = '\0';
	return TRUE;
}

/*  RETranslate - translate a pattern string and match structure into an
 *  output string.  During pattern search-and-replace, RETranslate is used
 *  to generate an output string based on an input match pattern and a template
 *  that directs the output.
 *
 *  The input match is any patType returned from RECompile that has been passed
 *  to fREMatch and that causes fREMatch to return TRUE.  The template string
 *  is any set of ascii chars.	The $ character leads in arguments:
 *
 *	$$ is replaced with $
 *	$0 is replaced with the entire match string ** EXCEPT IN BRIEF's SYNTAX! **  where 0 - 9 represent grouped items.
 *	$1-$9 is replaced with the corresponding tagged (by {}) item from
 *	    the match.
 *
 *  An alternative method is to specify the argument as:
 *
 *	$([w,]a) where a is the argument number (0-9) and w is an optional field
 *	    width that will be used in a printf %ws format.
 *
 *  buf     pattern matched
 *  src     template for the match
 *  dst     destination of the translation
 *
 *  Returns:	TRUE if translation was successful, FALSE otherwise
 */
flagType RETranslate (struct patType *buf, register char *src, register char *dst)
{
	int		i, w;
	char *	work;
	ULONG	cbCh;
	char	chArg;
	
	// Decide which symbol denotes the numbered argument
	if ((buf->reSyntx == reUnix) || (buf->reSyntx == reBrief))
		chArg = '\\';
	else if (buf->reSyntx == reEpsilon)
		chArg = '#';
	else
		chArg = '$';

	work = (char *)malloc(MAX_USER_LINE);
	if (work == NULL)
		return FALSE;

	*dst = '\0';

	while (*src != '\0') {
		/*  Process tagged substitutions first */
		if (*src == chArg && (_istdigit ((unsigned char)src[1]) || src[1] == '(')) {
			/*	presume 0-width field */
			w = 0;

			/*	skip $ and char */
			src += 2;

			/*	if we saw $n */
			if (_istdigit ((unsigned char)src[-1]))
				i = src[-1] - '0';
				/*	else we saw $( */
			else {
				/*  get tagged expr number */
				i = atoi (src);

				/*  skip over number */
				if (*src == '-')
					src++;
				src += strspn(src, digits);

				/*  was there a comma? */
				if (*src == ',') {
					/*	We saw field width, parse off expr number */
					w = i;
					i = atoi (++src);
					src += strspn(src, digits);
				}

				/*  We MUST end with a close paren */
				if (*src++ != ')') {
					free((HANDLE)work);
					return FALSE;
				}
			}
			/*	w is field width
			 *	i is selected argument
			 */
			if (g_reSntx == reBrief)
				i++;

			if (!REGetArg (buf, i, work)) {
				free((HANDLE)work);
				return FALSE;
			}

			sprintf (dst, "%*s", w, work);
			dst += _ftcslen (dst);
		}
		else
		/* process escaped characters */
		if ((*src == '\\' && g_reSntx != reEpsilon) ||
			(*src == '%' && g_reSntx == reEpsilon)) {

			src++;
			if (!*src) {
				free((HANDLE)work);
				return FALSE;
				}
			*dst++ = Escaped (*src++);
		}
		else
		/*  chArg quotes itself */
		if (*src == chArg && src[1] == chArg) {
			*dst++ = chArg;
			src += 2;
			}
		else
		{
			// [olympus 2805 : kherold]  Better copy a whole character at a time,
			// or a trail byte of '0x5c' will look like an escaped character!
			cbCh = _tclen(src);
			_tccpy(dst, src);
			dst += cbCh;
			src += cbCh;
		}
	}
	*dst = '\0';
	free((HANDLE)work);
	return TRUE;
}

/*  RETranslateLength - given a matched pattern and a replacement string
 *  return the length of the final replacement
 *
 *  The inputs have the same syntax/semantics as in RETranslate.
 *
 *  buf     pattern matched
 *  src     template for the match
 *
 *  Returns:	number of bytes in total replacement, -1 if error
 */
int RETranslateLength (struct patType *buf, register char *src)
{
	int i, w;
	int length = 0;
	char chArg = (char) (buf->reSyntx == reUnix ? '\\' : '$');

	while (*src != '\0') {
		/*  Process tagged substitutions first
		 */
		if (*src == chArg && (_istdigit ((unsigned char)src[1]) || src[1] == '(')) {
			w = 0;
			src += 2;
			if (_istdigit ((unsigned char)src[-1]))
				i = src[-1] - '0';
			else {
				i = atoi (src);
				if (*src == '-')
					src++;
				src += strspn(src, digits);
				if (*src == ',') {
					w = i;
					i = atoi (++src);
					src += strspn(src, digits);
				}
				if (*src++ != ')')
					return -1;
			}
			/*	w is field width
			 *	i is selected argument
			 */
			i = RELength (buf, i);
			length += max (i, abs(w));
		}
		else
		/* process escaped characters */
		if ((*src == '\\' && g_reSntx != reEpsilon) ||
			(*src == '%' && g_reSntx == reEpsilon)) {
			src += 2;
			length++;
		}
		else
		/*  chArg quotes itself */
		if (*src == chArg && src[1] == chArg) {
			src += 2;
			length++;
		}
		else {
			length++;
			src++;
		}
	}
	return length;
}

/*  RELength - return length of argument in match.
 *
 *  pat     matched pattern
 *  i	    index of argument to examine, 0 is entire pattern
 *
 *  Returns:	length of ith argument, -1 if i is out-of-range.
 */
int RELength (struct patType *pat, int i)
{
	if (i > MAXPATARG)
		return -1;
	else
	if (pat->pArgBeg[i] == (char *)-1)
		return 0;
	else
		return pat->pArgEnd[i] - pat->pArgBeg[i];
}

/*  REStart - return pointer to beginning of match.
 *
 *  ppat    matched pattern
 *
 *  Returns:	character pointer to beginning of match
 */
char *REStart (struct patType *pat)
{
	return pat->pArgBeg[0] == (char *)-1 ? NULL : pat->pArgBeg[0];
}


/*
**	FUNCTION:	FParseExpr
**
**	PURPOSE:	See if the current specified expression can produce a valid parse.
**
**	NOTES:
*/
/*  [fabriced] This should go away, once the edit package does not rely on it any more.
BOOL
FParseExpr(UINT nID, BOOL fMatchCase)
{
	if (pat[nID] != NULL)
	{
		free((HANDLE)(pat[nID]));
		pat[nID] = NULL;
	}

	// TODO: Fix the reSyntax on the following line 
	pat[nID] = RECompile(findReplace.findWhat, fMatchCase, g_reCurrentSyntax, nID);
	return pat[nID] != NULL;
}
*/
char XLTab[ ] = {	// Table for lowercase translation

    '\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
    '\x08', '\x09', '\x0A', '\x0B', '\x0C', '\x0D', '\x0E', '\x0F',
    '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
    '\x18', '\x19', '\x1A', '\x1B', '\x1C', '\x1D', '\x1E', '\x1F',

    ' ', '!', '"', '#', '$', '%', '&', '\x27',
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '{', '|', '}', '~', '\x7F',

    '\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
    '\x88', '\x89', '\x8A', '\x8B', '\x8C', '\x8D', '\x8E', '\x8F',
    '\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
    '\x98', '\x99', '\x9A', '\x9B', '\x9C', '\x9D', '\x9E', '\x9F',
    '\xA0', '\xA1', '\xA2', '\xA3', '\xA4', '\xA5', '\xA6', '\xA7',
    '\xA8', '\xA9', '\xAA', '\xAB', '\xAC', '\xAD', '\xAE', '\xAF',
    '\xB0', '\xB1', '\xB2', '\xB3', '\xB4', '\xB5', '\xB6', '\xB7',
    '\xB8', '\xB9', '\xBA', '\xBB', '\xBC', '\xBD', '\xBE', '\xBF',
    '\xC0', '\xC1', '\xC2', '\xC3', '\xC4', '\xC5', '\xC6', '\xC7',
    '\xC8', '\xC9', '\xCA', '\xCB', '\xCC', '\xCD', '\xCE', '\xCF',
    '\xD0', '\xD1', '\xD2', '\xD3', '\xD4', '\xD5', '\xD6', '\xD7',
    '\xD8', '\xD9', '\xDA', '\xDB', '\xDC', '\xDD', '\xDE', '\xDF',
    '\xE0', '\xE1', '\xE2', '\xE3', '\xE4', '\xE5', '\xE6', '\xE7',
    '\xE8', '\xE9', '\xEA', '\xEB', '\xEC', '\xED', '\xEE', '\xEF',
    '\xF0', '\xF1', '\xF2', '\xF3', '\xF4', '\xF5', '\xF6', '\xF7',
    '\xF8', '\xF9', '\xFA', '\xFB', '\xFC', '\xFD', '\xFE', '\xFF'
};

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vshell.rc
//
#define IDC_PROJ_NAME                   100
#define IDC_WORKSPACE_NAME              101
#define IDC_CHANGE                      102
#define IDC_FIND_WHAT                   102
#define IDC_PROJ_TYPE                   103
#define IDC_FIND_NEXT                   103
#define IDC_FIND_WHOLEWORD              104
#define IDC_FIND_MATCHUPLO              105
#define IDC_FIND_REGEXP                 107
#define IDC_FIND_UP                     113
#define IDC_FIND_DOWN                   114
#define IDC_BARTEXT                     212
#define IDC_STATIC_WINDOW               1001
#define IDC_TIP_SHOW                    1001
#define IDC_TIP_NEXT                    1002
#define IDC_STATIC_SIZE                 1003
#define IDC_COMBO_FONT_NAME             1004
#define IDC_COMBO_FONT_SIZE             1005
#define IDC_LIST_ELEMENTS               1007
#define IDC_COMBO_FORE_COLOR            1008
#define IDC_COMBO_BACK_COLOR            1009
#define IDC_COLOR_GROUP                 1014
#define IDC_STATIC_FORE_COLOR           1018
#define IDC_STATIC_BACK_COLOR           1019
#define IDC_SAMPLE                      1030
#define IDC_SCOPE_LIST                  1031
#define IDC_NETWORK                     0x40d
#define ID_PAGESETUP_HEADER             1161
#define ID_PAGESETUP_FOOTER             1162
#define ID_PAGESETUP_LEFT               1163
#define ID_PAGESETUP_RIGHT              1164
#define ID_PAGESETUP_TOP                1165
#define ID_PAGESETUP_BOTTOM             1166
#define ID_PAGESETUP_FIELDS             1167
#define IDCUR_BUTTON_MOVE               20010
#define IDCUR_BUTTON_COPY               20011
#define IDCUR_BUTTON_DELETE             20012
#define IDS_INSERTFILESDLG              20200
#define IDS_TOOMANY_FILES               20201
#define IDS_INSERTFILESDLG_OK           20202
#define IDD_BWIZ_ENUM                   20203
#define IDS_PROP_GENERAL                20204
#define IDS_PROP_CONTROL                20205
#define IDS_PROP_ERROR_INVPROP          20206
#define IDS_PROP_NOPROP                 20207
#define IDS_PROP_TRUE                   20208
#define IDS_PROP_FALSE                  20209
#define IDS_PROP_ERROR_NOPAGEHELP       20210
#define IDS_PROP_ALL                    20211
#define IDS_UNDO_OLE_PROPS              20212
#define IDS_PROP_UNKNOWNPROP            20213
#define ID_SBAR_PROGRESS                20398
#define IDCT_SHELLPACKAGE               20398
#define IDS_ERROR_FILE_TEMPLATE         20399
#define IDS_ERROR_FILE                  20400
#define IDS_E_FILENOTFOUND              20402
#define IDS_E_BADPATH                   20403
#define IDS_E_ACCESSDENIED              20405
#define IDS_E_INVALIDFILE               20406
#define IDS_E_SHARINGVIOLATION          20411
#define IDS_E_DISKFULL                  20413
#define IDS_E_ENDOFFILE                 20414
#define IDS_ERROR_CANT_SAVETEMP         20432
#define IDS_ERROR_CANT_SAVERO           20433
#define IDS_ERROR_TOOLBAR_CREATE        20434
#define IDS_ERROR_CANT_DELETE_FILE      20435
#define IDS_INVALID_PROJECT_NAME        20436
#define IDS_SUBDIR_ERROR                20437
#define IDS_ERROR_NEED_FULL_PATH        20438
#define IDS_PATH_TOO_LONG               20439
#define IDS_ERROR_CANT_SAVERO2          20440
#define IDS_ERROR_DUPLICATE_TOOLBAR_NAME 20441
#define IDS_ERR_FILE_TYPE               20442
#define IDS_ERR_WIZARD_TYPE             20443
#define IDS_ERR_PROJECT_TYPE            20444
#define IDS_ERR_WORKSPACE_TYPE          20445
#define IDS_ERR_DOCUMENT_TYPE           20446
#define IDS_ERR_NO_PLATFORMS            20447
#define IDS_RESETTOOLBAR                20481
#define IDS_DELETETOOLBAR               20482
#define IDS_RepeatCount                 20483
#define IDS_SAMPLE_LINE                 20484
#define IDS_AUTOMATIC                   20485
#define IDS_ALLWINDOWS                  20486
#define IDS_MULTIPLE_FONTS              20487
#define IDS_BUTTONLABEL                 20488
#define IDS_TEXTBUTTON                  20489
#define IDS_NOT_WIN32S                  20490
#define IDS_SAMPLE_TURKISH              20491
#define IDS_SAMPLE_HEBREW               20492
#define IDS_NOT_WINDOWS4                20493
#define IDC_TOOLBAR                     20504
#define IDC_DELETE                      20505
#define IDC_PLACEHOLDER                 20506
#define IDC_RESET                       20506
#define IDC_CUSTOM                      20507
#define IDC_RESET_ALL_BARS              20507
#define IDB_BITMAP_TRUETYPE             20509
#define IDC_ASSIGN                      20510
#define IDC_NAME                        20511
#define IDC_REMOVE                      20512
#define IDC_CATEGORIES_COMBO            20514
#define IDC_RESET_ALL                   20515
#define IDC_TOOLS                       20516
#define IDC_CAT_COMBO                   20517
#define IDC_DESCRIPTION                 20518
#define IDC_CMD_LIST                    20519
#define IDC_NEW                         20520
#define IDC_KEY_LIST                    20521
#define IDS_RESETALLKEYS                20522
#define IDS_MENUACCESS                  20523
#define IDD_CHICAGO_FILEOPEN            20523
#define IDD_CHICAGO_WRKSPCOPEN          20524
#define IDC_USEDBY                      20525
#define IDC_USEDBY_CAP                  20526
#define IDB_CHECKLISTBOXES              20528
#define IDR_ACCEL_PROP                  20530
#define IDC_EDITOR                      20531
#define IDC_EDITOR_CAP                  20532
#define IDC_TAP                         20535
#define IDS_UNDO_CANCEL                 20536
#define IDS_UNDO_ONE                    20537
#define IDS_UNDO_N                      20538
#define IDS_REDO_ONE                    20539
#define IDS_REDO_N                      20540
#define IDB_MAINTOOLS                   20543
#define IDS_POPUP_TOOLBARS              20544
#define IDS_POPUP_CUSTOMIZE             20545
#define IDS_POPUP_CLOSE                 20546
#define IDCUR_BLACKARROW                20549
#define IDS_NODOCK_WINDOW               20550
#define IDDP_CUSTOMIZE_TOOLBARS         20551
#define IDD_NEWTOOLBAR                  20552
#define IDD_TOOLBARS                    20553
#define IDDP_CUSTOMIZE_KEYBOARD         20554
#define IDS_FEXCEP_NONE                 20558
#define IDS_FEXCEP_GENERIC              20559
#define IDS_FEXCEP_NOTFOUND             20560
#define IDS_FEXCEP_BADPATH              20561
#define IDS_FEXCEP_2MANYFILES           20562
#define IDS_FEXCEP_DENIED               20563
#define IDS_FEXCEP_INVALIDFILE          20564
#define IDS_FEXCEP_RDCURRENT            20565
#define IDS_FEXCEP_DIRFULL              20566
#define IDS_FEXCEP_BADSEEK              20567
#define IDS_FEXCEP_IOERR                20568
#define IDS_FEXCEP_SHARING              20569
#define IDS_FEXCEP_LOCK                 20570
#define IDS_FEXCEP_DISKFULL             20571
#define IDS_FEXCEP_EOF                  20572
#define IDS_FILE_ERROR_FORMAT           20575
#define IDS_INTERNAL_ERROR              20576
#define IDS_AUTOSAVE_DETECTED_BACKUP    20577
#define IDS_AUTOSAVE_ERROR              20578
#define IDS_AUTOSAVE_READONLY           20579
#define IDS_AUTOSAVE_BAD_INTERVAL       20580
#define IDDP_NOPAGE                     20581
#define IDDP_MUL                        20582
#define IDDP_NUL                        20583
#define IDMX_NEXTPAGE                   20584
#define IDMX_PREVPAGE                   20585
#define IDMX_OKPAGE                     20589
#define IDMX_CANCELPAGE                 20590
#define IDB_UNDO                        20591
#define IDB_REDO                        20592
#define IDB_REDODISABLED                20593
#define IDB_UNDODISABLED                20594
#define IDDP_OPTIONS_WORKSPACE          20595
#define IDC_AUTO_WORKSPACE              20596
#define IDS_DOCKABLE_MOVE               20597
#define IDS_DOCKABLE_SIZE               20598
#define IDS_DOCKABLE_CLOSE              20599
#define IDS_DRAG_MOVE                   20600
#define IDS_DRAG_COPY                   20601
#define IDC_VIEWS                       20602
#define IDS_DRAG_CANCEL                 20602
#define IDS_ERR_EXPAND_MACRO            20619
#define ERR_File_Not_Found              20624
#define ERR_Workspace_Window            20625
#define IDB_PPBAR_PINNED                20626
#define ERR_Other_Type_Open             20626
#define IDC_DIRNAME                     20626
#define IDB_PPBAR_UNPINNED              20627
#define IDC_DIRPROMPT                   20627
#define IDS_TOOLBARS                    20628
#define IDS_WORKSPACE                   20630
#define IDS_TOOLS                       20631
#define IDD_MTTF                        20632
#define IDS_NEED_FILENAME               20632
#define IDC_UNEXPECTED                  20633
#define IDS_ERROR_HELP_NOFILE           20633
#define IDC_ASSERT                      20634
#define IDS_ERROR_HELP_NOKEYWORD        20634
#define IDC_EXCEPTION                   20635
#define IDD_NOHELPFILE                  20635
#define IDS_HELP                        20635
#define IDC_HANG                        20636
#define IDS_FONTSANDCOLORS              20636
#define IDC_OTHER                       20637
#define IDD_HELP_SEARCH                 20637
#define IDS_DIRECTORY_NAME              20637
#define IDC_FEATURE                     20638
#define IDD_OPENDIR                     20638
#define IDS_DIRNOEXIST                  20638
#define IDC_INFORMATION                 20639
#define IDB_SCROLL                      20639
#define IDS_INVALID_FILENAME            20639
#define IDC_STATUSBAR                   20640
#define IDB_SCROLL_L                    20640
#define IDS_INVALID_PATHNAME            20640
#define IDB_SCROLL_R                    20641
#define IDS_EXISTING_FILEPATH           20641
#define IDB_SCROLL_RD                   20642
#define IDS_EXISTING_PROJECT            20642
#define IDC_GOTOEDIT                    20643
#define IDB_SCROLL_LD                   20643
#define IDS_EXISTING_PROJECT2           20643
#define IDC_GOTOTEXT                    20644
#define IDB_TREECTL                     20644
#define IDS_INVALID_PROJECTNAME         20644
#define IDS_EXISTING_WORKSPACE          20645
#define IDC_NAME_TEXT                   20646
#define IDB_MENUBTN_ARROW               20646
#define IDS_INSERTING_FILES             20646
#define IDC_HELPPATH1                   20647
#define IDS_PROJECT_NOT_DEPENDENT       20647
#define IDC_HELPPATH2                   20648
#define IDS_FAIL_NEW_WORKSPACE          20648
#define IDS_ALREADY_IN_PROJ             20649
#define ERR_SlashP_NoPidNumber          20650
#define ERR_SlashE_NoEventNumber        20651
#define ERR_Switch_TwiceP               20652
#define ERR_Missing_Jit_SwitchP         20653
#define ERR_Switch_TwiceE               20654
#define ERR_Missing_Jit_SwitchE         20655
#define IDS_FILE_TYPE_DLG               20656
#define IDS_ADD_NONEXISTENT_FILE        20657
#define IDC_INFO_ICON                   20658
#define IDS_ADD_NONEXISTENT_FILE2       20658
#define IDS_ADDTOOL_DLG_TITLE           20659
#define IDC_AUTOSAVE_ENABLE             20660
#define ERR_Change_Drive                20660
#define IDC_AUTOSAVE_INTERVAL           20661
#define ERR_Change_Directory            20661
#define IDC_AUTOSAVETEXT1               20662
#define ERR_File_NoExist                20662
#define IDC_AUTOSAVETEXT2               20663
#define ERR_File_Already_Open           20663
#define IDC_DDNODROP                    20664
#define ERR_File_Buffer_Overflow        20664
#define ERR_File_Read_Only              20665
#define ERR_File_Exists                 20666
#define ERR_Idx_Corrupt                 20667
#define ERR_MultipleMakes               20668
#define ERR_Duplicate_AddItem           20669
#define ERR_Goto_Busy                   20670
#define ERR_File_Invalid_Length         20671
#define ERR_File_Invalid_Caption        20672
#define IDS_ERR_CANTOPENMRUFILE         20673
#define IDS_SAVE_FILE_AS_TYPE           20800
#define IDS_RESOURCETREE                20801
#define IDS_TOOLONG_FILENAME            20801
#define IDS_IMAGE                       20802
#define ID_HDR_FIELD_FILE               20803
#define ID_HDR_FIELD_PAGE               20804
#define ID_HDR_FIELD_TIME               20805
#define ID_HDR_FIELD_DATE               20806
#define ID_HDR_FIELD_LEFT               20807
#define ID_HDR_FIELD_CENTER             20808
#define ID_HDR_FIELD_RIGHT              20809
#define IDS_SHL_HLP_USAGE               20810
#define IDS_SHL_HLP_USAGE2              20811
#define IDS_SHL_HLP_HELP                20812
#define IDS_AUT_HLP_EX                  20813
#define IDS_SHL_HLP_OUT                 20814
#define IDS_ERR_NO_PROJECT_LOADED       20815
#define IDS_ERR_OUT_ARG                 20816
#define ID_FIND_ANYCHARACTER            21000
#define IDS_MULTISEL                    21000
#define IDS_PROPERTIES                  21001
#define ID_FIND_RANGE                   21001
#define ID_FIND_NOTRANGE                21002
#define IDS_BUILDDATE                   21003
#define ID_FIND_LINE_BEGIN              21003
#define IDS_DEFTBTITLE                  21004
#define ID_FIND_LINE_END                21004
#define IDS_UNDESCRIBED                 21005
#define ID_FIND_TAG                     21005
#define IDS_CANNOTOPEN                  21006
#define ID_FIND_NOT                     21006
#define IDS_MAIN                        21007
#define ID_FIND_OR                      21007
#define IDS_ROCOMMENT                   21008
#define ID_FIND_CLOSURE_ZERO            21008
#define IDS_ROBUTTONS2                  21009
#define IDS_ROCOMMENT2                  21009
#define ID_FIND_CLOSURE_ONE             21009
#define IDS_ROBUTTONS3                  21010
#define IDS_ROLOCKED                    21010
#define ID_FIND_GROUP                   21010
#define IDS_LNCOLPRMPT                  21011
#define ID_FIND_ALPHANUM                21011
#define ID_FIND_WHITESPACE              21012
#define ID_FIND_ALPHA                   21013
#define ID_FIND_DECIMAL                 21014
#define ID_FIND_HEX                     21015
#define ID_FIND_NUMBER                  21016
#define ID_FIND_INTEGER                 21017
#define IDS_MOVETO                      21018
#define ID_FIND_IDENTIFIER              21018
#define IDS_LOADINGWRKSPC               21019
#define ID_FIND_WORD                    21019
#define IDS_SAVINGWRKSPC                21020
#define ID_FIND_STRING                  21020
#define ID_REPLACE_FINDWHATTEXT         21021
#define IDS_UNASSIGNED                  21022
#define ID_REPLACE_TAG_1                21022
#define IDS_PREFIXKEY                   21023
#define ID_REPLACE_TAG_2                21023
#define IDS_FILTER_0                    21024
#define IDS_HELPLESS                    21024
#define ID_REPLACE_TAG_3                21024
#define IDS_FILTER_1                    21025
#define ID_REPLACE_TAG_4                21025
#define IDS_FILTER_2                    21026
#define ID_REPLACE_TAG_5                21026
#define IDS_FILTER_3                    21027
#define ID_REPLACE_TAG_6                21027
#define IDS_FILTER_4                    21028
#define ID_REPLACE_TAG_7                21028
#define IDS_FILTER_5                    21029
#define ID_REPLACE_TAG_8                21029
#define IDS_FILTER_6                    21030
#define ID_REPLACE_TAG_9                21030
#define IDS_FILTER_7                    21031
#define IDS_FILTER_8                    21033
#define IDS_STANDARD                    21034
#define IDS_UNDOLIST                    21036
#define IDS_AUTO                        21037
#define IDS_TEXT                        21038
#define IDS_BINARY                      21039
#define IDS_MAKEFILE                    21040
#define IDS_DEFAULTCHOOSERTITLE         21041
#define IDS_DEFAULTCHOOSERPROMPT        21042
#define IDS_OPENDIR_STATUS_WRONGFILE    21043
#define IDS_OPENDIR_STATUS_NOFILE       21044
#define IDS_OPENDIR_STATUS_TURNOFFPDBS  21045
#define IDS_RESOURCESCRIPT              21055
#define IDS_HELP_DEFAULTDIR             21056
#define IDS_TABDLG_OK                   21057
#define IDS_TABDLG_CANCEL               21058
#define IDS_TABDLG_CLOSE                21059
#define IDS_TABDLG_HELP                 21060
#define IDS_CUSTOMIZE                   21061
#define IDS_OPTIONS                     21062
#define IDS_STOP_TOOL_PREFIX            21063
#define IDS_TOOL_PATH_INVALID           21068
#define IDS_NO_ARGS_IN_PATH             21069
#define IDD_FIND                        21070
#define IDS_FULLSCREEN                  21070
#define IDS_NO_EXT_HELP                 21071
#define IDS_LAST_TIP                    21072
#define IDS_DIDYA                       21073
#define IDS_FOR_FILTER_0                21074
#define IDS_SORRY_NO_TIP                21074
#define IDS_FOR_FILTER_1                21075
#define IDS_TIP_OF_THE_DAY              21075
#define IDS_FOR_FILTER_2                21076
#define IDS_GOTO_GOTO                   21076
#define IDS_FOR_FILTER_3                21077
#define IDS_GOTO_NEXT                   21077
#define IDS_ALL_FILTER_0                21078
#define IDS_NOT_A_WKSPACE               21078
#define IDS_ALL_FILTER_1                21079
#define IDS_TOOL_MAX_REACHED            21079
#define IDC_TOOLTIPS                    21080
#define IDC_BTN_DEFAULTS                21081
#define IDC_LARGETOOLBARS               21081
#define IDC_TEXTLIST                    21081
#define IDC_PROPLIST                    21081
#define IDC_ALLPROP_PROPLIST            21081
#define IDC_FILETYPES                   21081
#define IDB_WIDGETBAR_ARROWS            21082
#define IDD_PAGESETUP                   21084
#define ID_PREVIOUS                     21084
#define IDC_LIST_WINDOWS                21085
#define IDC_STATIC_FONT                 21086
#define IDB_TIPOFTHEDAY                 21087
#define IDC_STATIC_SAMPLE               21088
#define IDD_TIPOFTHEDAY                 21088
#define IDS_ALL_FILTER_2                21089
#define IDS_ALL_FILTER_3                21090
#define IDC_ICON_EXCLAMATION            21093
#define IDB_MENUBTN_ARROWD              21094
#define IDC_CLOCK                       21095
#define IDI_VAGUE                       21095
#define IDC_RELOAD_PROJECT              21096
#define IDC_WINDOWS_SORT                21097
#define IDI_PRJ_TEST                    21098
#define IDC_MENU_TRADITIONAL            21098
#define IDC_STATIC_SCRIPT               21099
#define IDB_MENUBTN_NOTEXT_ARROW        21099
#define IDC_TM_BROWSE                   21099
#define IDC_MRU_SUBMENU                 21099
#define IDC_COMBO_FONT_SCRIPT           21100
#define IDC_KEYS                        21100
#define IDB_MENUBTN_NOTEXT_ARROWD       21100
#define IDC_GOTOHELPTEXT                21101
#define IDC_GOTOCAPTION                 21102
#define IDC_GOTOWHAT                    21103
#define IDC_GOTOLIST                    21104
#define IDC_GOTOCOMBO                   21105
#define IDC_GOTO_PUSHPIN                21107
#define IDS_TOOLMACRO_First             21111
#define IDS_TOOLMACRO_FilePath          21111
#define IDS_TOOLMACRO_FileNameExt       21112
#define IDS_TOOLMACRO_FileDir           21113
#define IDS_TOOLMACRO_FileName          21114
#define IDS_TOOLMACRO_FileExt           21115
#define IDS_TOOLMACRO_Line              21116
#define IDS_TOOLMACRO_Col               21117
#define IDS_TOOLMACRO_CurText           21118
#define IDS_TOOLMACRO_Dir               21119
#define IDS_TOOLMACRO_TargetPath        21120
#define IDS_TOOLMACRO_TargetDir         21121
#define IDS_TOOLMACRO_TargetName        21122
#define IDS_TOOLMACRO_TargetExt         21123
#define IDS_TOOLMACRO_TargetArgs        21124
#define IDS_TOOLMACRO_WkspDir           21125
#define IDS_TOOLMACRO_WkspName          21126
#define IDS_TOOLMACRO_RCFile            21127
#define IDS_TOOLMACRO_Last              21127
#define IDS_TOOLMACRODIR_First          21128
#define IDS_TOOLMACRODIR_FileDir        21128
#define IDS_TOOLMACRODIR_FileName       21129
#define IDS_TOOLMACRODIR_Dir            21130
#define IDS_TOOLMACRODIR_TargetDir      21131
#define IDS_TOOLMACRODIR_TargetName     21132
#define IDS_TOOLMACRODIR_WkspDir        21133
#define IDS_TOOLMACRODIR_WkspName       21134
#define IDS_TOOLMACRODIR_Last           21134
#define IDR_TOOL_MACRO                  21140
#define IDR_HELP_KEYBOARD               21141
#define IDR_GRD_TOOLBAR                 21142
#define IDR_GRD_TB_DELETE               21143
#define IDR_DOCOBJECT                   21144
#define IDD_OPEN_DOCUMENTS              21145
#define IDC_OPEN_DOCUMENTS_LIST         21146
#define IDC_OPEN_DOCUMENTS_CLOSE        21147
#define IDC_OPEN_DOCUMENTS_SAVE         21148
#define IDC_OPEN_DOCUMENTS_PRINT        21149
#define IDC_OPEN_DOCUMENTS_TILE_HORZ    21149
#define IDD_NEW_WKSP                    21150
#define IDC_OPEN_DOCUMENTS_TILE_VERT    21150
#define IDS_ERR_NTSPAWN_NOT_FOUND       21151
#define IDS_ERR_CANNOT_SPAWN_TOOL       21152
#define IDS_ERR_TOOL_PATH_INVALID       21153
#define IDS_ERR_CANNOT_START_TOOL       21154
#define IDS_ERR_TOOL_RETURN             21155
#define IDS_ERR_PATH_NOT_FOUND          21156
#define IDS_ERR_FILE_NOT_FOUND          21157
#define IDS_ERR_BAD_EXE_FORMAT          21158
#define IDS_ERR_NOT_ENOUGH_MEMORY       21159
#define IDS_TOOL_STOP_MSG               21160
#define IDS_SOUND_OUTPUT_ERROR          21161
#define IDS_SOUND_OUTPUT_WARNING        21162
#define IDD_TOOLARGUMENTS               21163
#define IDS_ERROR_BOGUSFILE             21163
#define IDC_TOOLARGUMENTS_ARGS          21164
#define IDS_ERR_CANNOT_ADD_WKS          21164
#define IDC_TOOLARGUMENTS_MACROS        21165
#define IDS_ERR_CANNOT_ADD_PRJ          21165
#define IDC_TOOLARGUMENTS_REDIRECT      21166
#define IDS_ERR_WIZARD_PROJ             21166
#define IDS_OUTPUT_ERROR                21167
#define IDS_OUTPUT_WARNING              21168
#define IDS_ERR_CHANGE_DRIVE            21169
#define IDS_ERR_CHANGE_DIR              21170
#define IDS_ERR_NO_DISK_IMAGE           21171
#define IDC_ALLPROP_LABEL               21172
#define IDS_WIZARD_ORPHANS              21172
#define IDC_ALLPROP_PROPVAL             21173
#define IDS_ERR_WIZARD_NO_PROJ          21173
#define IDC_ALLPROP_PROPDLG             21174
#define IDS_BAD_CRT_VER                 21174
#define IDC_ALLPROP_PROPDLIST           21175
#define IDS_BAD_MFC42_VER               21175
#define IDC_ALLPROP_PROPDDOWN           21176
#define IDC_ALLPROP_PROPNAME            21177
#define IDDP_ALLPROP                    21178
#define IDB_ALLPROP_DROPARROW95         21179
#define IDDP_CUSTOMIZE_TOOLSMENU        21179
#define IDD_CUSTOMBUTTON                21180
#define IDB_ALLPROP_DROPARROW           21180
#define IDS_OC_GENERAL                  21181
#define IDB_MAINLARGETOOLS              21181
#define IDS_ERR_CANT_LOAD_PKG           21183
#define IDS_ERR_CANT_LOAD_PKG_VER       21184
#define IDS_AUTOCOL_NOMEM               21185
#define IDC_TM_PLACEHOLDER              21185
#define IDS_AUTOCOL_BADPARAM            21186
#define IDC_TM_COMMAND_LABEL            21186
#define IDS_AUTOAPP_NODEVAUT1           21187
#define IDC_BUTTON_NAME                 21187
#define IDC_TM_COMMAND                  21187
#define IDC_BUTTON_TEXT                 21188
#define IDC_TM_ARGUMENTS_LABEL          21188
#define IDS_AUTOAPP_NAME                21188
#define IDC_TM_ARGUMENTS                21189
#define IDS_AUTOAPP_VERSION             21189
#define IDB_REDOLARGE                   21190
#define IDC_TM_INITDIR_LABEL            21190
#define IDS_STRING_NOT_FOUND            21190
#define IDB_UNDOLARGE                   21191
#define IDC_TM_INITDIR                  21191
#define IDS_REG_EXPR_NOT_FOUND          21191
#define IDB_REDODISABLEDLARGE           21192
#define IDC_TM_PROMPTFORARGS            21192
#define IDS_REGEXPR_INVALID             21192
#define IDB_UNDODISABLEDLARGE           21193
#define IDS_ERR_TOOL_RUNNING            21193
#define IDC_TM_REDIRECTOUTPUT           21193
#define IDC_TM_CLOSEONEXIT              21194
#define IDB_TOOL_CUSTOMIZE              21194
#define IDS_AUTOAPP_BADFIRSTKEY         21194
#define IDC_TM_ARGMACROS                21195
#define IDDP_ALLPROP_NEW                21195
#define IDS_AUTOAPP_BADSECONDKEY        21195
#define IDB_MENUBTN_ARROWV              21195
#define IDC_TM_DIRMACROS                21196
#define IDS_AUTOAPP_TOOMANYKEYS         21196
#define IDDP_FILENEW_FILES              21196
#define IDB_MENUBTN_ARROWVD             21197
#define IDC_TM_TOOLSGRID                21197
#define IDS_AUTOAPP_INVALIDCOMMAND      21197
#define IDDP_FILENEW_PROJECTS           21197
#define IDC_ALLPROP_NOBROWSEABLE        21198
#define IDB_CUSTOMGLYPHSLARGE           21198
#define IDS_AUTOAPP_INVALIDEDITOR       21198
#define IDDP_FILENEW_WORKSPACES         21198
#define IDC_IMAGE_RESET                 21199
#define IDC_FIND_MARK_ALL               21199
#define IDB_CUSTOMGLYPHS                21199
#define IDI_BUILDER                     21199
#define IDDP_FILENEW_OTHERDOCS          21199
#define IDS_AUTOAPP_NOPROJECT           21199
#define IDC_FIND_SEARCH_ALL             21200
#define IDC_IMAGEONLY                   21200
#define IDB_DROPFLAT                    21200
#define IDI_CATEGORY                    21200
#define IDC_LARGEICONVIEW               21200
#define IDDP_FILENEW_TEMPLATES          21200
#define IDS_AUTOAPP_INVALID_PROJ        21200
#define IDS_ZOOM_PAGE_WIDTH             21201
#define IDC_PROP_BUTTON                 21201
#define IDC_OPEN_DOCUMENTS_ACTIVATE     21201
#define IDB_DROP95FLAT                  21201
#define IDS_ZOOM_ONE_PAGE               21202
#define IDC_PROP_LISTBOX                21202
#define IDI_FILENEWWIZDEFAULT           21202
#define IDS_ZOOM_TWO_PAGES              21203
#define IDC_PROP_EDIT                   21203
#define IDB_MENUSCROLLDOWN              21203
#define IDC_SPECIAL                     21204
#define IDS_ZOOM_SELECTION              21204
#define IDB_DROP95LARGEFLAT             21204
#define IDD_DIALOGFONT                  21204
#define IDC_PROP_HEADER                 21205
#define IDS_ZOOM_FIT                    21205
#define IDC_BUTTONGROUP                 21205
#define IDB_DROPLARGEFLAT               21205
#define IDS_ERR_BAD_CMD                 21206
#define IDB_MENUSCROLLUP                21206
#define IDC_TEXTONLY                    21207
#define IDC_STATIC_DIRECTION            21207
#define IDS_ERR_CANT_INIT_PKG           21207
#define IDS_ALLCOMMANDS                 21208
#define IDC_IMAGETEXT                   21208
#define IDC_BWIZ_TREE                   21208
#define IDC_SMALLICONVIEW               21209
#define IDC_IMAGES_GROUP                21209
#define IDS_DELETEDCOMMANDS             21209
#define IDC_LISTVIEW                    21210
#define IDC_BUTTON_TEXT_PROMPT          21210
#define IDS_MENUS                       21210
#define IDC_ADDTOPROJECT                21211
#define IDC_WINDOWS_COUNT               21211
#define IDS_NEWMENU                     21211
#define IDC_ADDOTHERFILETOPROJECT       21211
#define IDC_PROJECTFORFILE              21212
#define IDC_FILES_COUNT                 21212
#define IDC_NAMEFORFILE                 21214
#define IDC_PROJECTS_COUNT              21214
#define IDC_LOCATIONFORFILE             21215
#define IDS_HELP_KEY_CAPTION            21216
#define IDC_BROWSE                      21216
#define IDS_HELP_KEY_CATEGORY           21217
#define IDC_CREATENEWWORKSPACE          21217
#define IDS_HELP_KEY_COMMAND            21218
#define IDC_ADDTOCURRENTWORKSPACE       21218
#define IDS_HELP_KEY_KEYS               21219
#define IDC_DEPENDENCYOF                21219
#define IDS_HELP_KEY_DESCRIPTION        21220
#define IDC_DEPENDENCYPROJECT           21220
#define IDS_HELP_KEY_BOUND              21221
#define IDC_PLATFORMS                   21221
#define IDS_HELP_KEY_ALL                21222
#define IDC_NAMEFORPROJECT              21222
#define IDS_HELP_KEY_PRINT_TITLE        21223
#define IDC_LOCATIONFORPROJECT          21223
#define IDS_HELP_KEY_PRINT_CRIGHT       21224
#define IDS_HELP_KEY_PRINT_PAGE         21225
#define IDC_NAMEFORWORKSPACE            21225
#define IDS_HELP_KEY_PRINT_FOOTER       21226
#define IDC_LOCATIONFORWORKSPACE        21226
#define IDS_HELP_KEY_EDITOR             21227
#define IDC_WORKSPACETYPES              21227
#define ID_HELP_KEY_CATEGORY_COMBO      21228
#define IDC_PROJECTTYPES                21228
#define IDC_OTHERDOCTYPES               21229
#define IDC_PROJECTFOROTHERFILE         21230
#define IDC_NAMEFOROTHERFILE            21231
#define IDC_LOCATIONFOROTHERFILE        21232
#define IDC_PROJECTFORTEMPLATE          21233
#define IDC_NAMEFORTEMPLATE             21234
#define IDC_LOCATIONFORTEMPLATE         21235
#define IDC_TEMPLATETYPES               21236
#define ID_GOTO_GOTOANDNEXT             21237
#define IDC_NAMESTATIC                  21238
#define IDC_WORKSPACENAMESTATIC         21238
#define IDC_LOCATIONSTATIC              21239
#define IDC_WORKSPACELOCATIONSTATIC     21239
#define IDS_OLE2UICONVERT               21240
#define IDC_PLATSTATIC                  21240
#define IDC_NAME_EDIT                   21240
#define IDS_OLE2UIEDITLINKCMD_1VERB     21241
#define IDC_SELECTVIEWGROUP             21241
#define IDC_COMMANDS_TEXT               21241
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   21242
#define IDC_BUTTON_LABEL                21242
#define IDS_OLE2UIEDITLINKCMD_NVERB     21243
#define IDC_WINDOWS_UNIT                21243
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   21244
#define IDC_FILES_UNIT                  21244
#define IDS_OLE2UIEDITNOOBJCMD          21245
#define IDC_PROJECTS_UNIT               21245
#define IDS_OLE2UIUNKNOWN               21246
#define IDC_FOLDER_LABEL                21246
#define IDC_FOLDER_NAME                 21247
#define IDC_PROJECTTOADDTO_LABEL        21248
#define IDC_TEXTFRAME                   21249
#define IDS_E_BAD_PARAM_VALUE           21250
#define IDS_E_DOC_RELEASED              21251
#define IDC_OPENDIR_STATUS              21251
#define IDS_E_WINDOW_RELEASED           21252
#define IDC_SHOWMENUSFOR                21252
#define IDS_AUTOAPP_NOBLD               21253
#define IDC_MENU_FILTER                 21253
#define IDS_NOFILENEWWIZSUPPORT         21254
#define IDS_REGISTRYCORRUPTED           21255
#define IDC_FOLDERPROJECT               21255
#define IDS_MISSINGWIZARD               21256
#define IDI_DEVSTUDIO_FOLDER            21257
#define IDS_DOCKWNDS_UNAVAILABLE        21257
#define IDC_DESCRIPTION_KEYBOARD        21257
#define IDS_FILESTAB                    21258
#define IDC_EXPLANATION                 21258
#define IDS_TEMPLATESTAB                21259
#define IDC_TEMPLATENAMESTATIC          21259
#define IDS_PROJECTSTAB                 21260
#define IDC_TEMPLATELOCATIONSTATIC      21260
#define IDS_WORKSPACESTAB               21261
#define IDC_ADDTEMPLATETOPROJECT        21261
#define IDS_OTHERDOCSTAB                21262
#define IDC_ADDFILETOPROJECT            21262
#define IDS_NEW                         21263
#define IDC_FILENAMESTATIC              21263
#define IDS_ERROR_CANT_CREATE_IPCMPDOC  21264
#define IDC_FILELOCATIONSTATIC          21264
#define IDS_CUSTOMMENU                  21265
#define IDC_OTHERFILENAMESTATIC         21265
#define IDS_E_READONLY                  21266
#define IDC_OTHERFILELOCATIONSTATIC     21266
#define IDS_E_NOFILENAME                21267
#define IDC_PROJECTNAMESTATIC           21267
#define IDS_E_UNKNOWN                   21268
#define IDC_PROJECTLOCATIONSTATIC       21268
#define IDD_CHICAGO_ADDFILES            21269
#define IDC_PROJECTTOADDTO              21270
#define IDS_MENUBAR                     21271
#define IDS_E_SHUTDOWN_REQUESTED        21272
#define STA_MatchWordOff                21273
#define STA_MatchCaseOn                 21274
#define STA_MatchCaseOff                21275
#define STA_MatchREOn                   21276
#define STA_MatchREOff                  21277
#define STA_MatchWordOn                 21278
#define STA_SearchAllDocsOn             21279
#define STA_SearchAllDocsOff            21280
#define IDS_MSDEV_SHELL_LINK_DESCRIPTION 21281
#define IDS_RENAME_FAILED               21282
#define IDS_PICTUREFILTER               21283
#define IDS_BITMAPFILTER                21284
#define IDS_METAFILEFILTER              21285
#define IDS_ICONFILTER                  21286
#define IDS_ENHMETAFILEFILTER           21287
#define IDS_PICTURETITLE                21288
#define IDS_BITMAPTITLE                 21289
#define IDS_METAFILETITLE               21290
#define IDS_ICONTITLE                   21291
#define IDS_ENHMETAFILETITLE            21292
#define IDS_DOCOBJ_CANT_CREATE          21293
#define IDS_DOCOBJ_CANT_OPEN            21294
#define IDS_HELP_MOW_FREESTUFF          21295
#define IDS_HELP_MOW_PRODUCTNEWS        21296
#define IDS_HELP_MOW_FAQ                21297
#define IDS_HELP_MOW_ONLINESUPPORT      21298
#define IDS_HELP_MOW_DEVONLYHOMEPAGE    21299
#define IDS_HELP_MOW_SENDFEEDBACK       21300
#define IDS_HELP_MOW_BESTOFTHEWEB       21301
#define IDS_HELP_MOW_SEARCHTHEWEB       21302
#define IDS_HELP_MOW_WEBTUTORIAL        21303
#define IDS_HELP_MOW_MSHOMEPAGE         21304
#define IDS_MENUFILTER_CURRENT          21305
#define IDS_MENUFILTER_ALL              21306
#define IDS_PICTURETYPENONE             21308
#define IDS_PICTURETYPEBITMAP           21309
#define IDS_PICTURETYPEMETAFILE         21310
#define IDS_PICTURETYPEICON             21311
#define IDS_PICTURETYPEENHMETAFILE      21312
#define IDS_E_PROJECT_OLD_MAKEFILE_VC   21313
#define IDS_E_PROJECT_OLD_MAKEFILE_DEVSTUDIO 21314
#define IDS_E_PROJECT_EXTERNAL_MAKEFILE 21315
#define IDS_E_CANNOTCREATENEWWINDOW     21316
#define IDS_E_CANNOT_FIND_DOCUMENT      21317
#define IDS_E_CANNOT_FIND_WINDOW        21318
#define IDS_DOCK_HIDE                   21319
#define IDS_DOCK_EXPAND                 21320
#define IDS_DOCK_CONTRACT               21321
#define IDS_NO_CONTROL_TYPEINFO         21322
#define IDS_PROPERTYBROWSER_PROPERTY    21323
#define IDS_PROPERTYBROWSER_VALUE       21324
#define IDS_E_CANNOTGOTOPAGE            21325
#define IDC_COMBOBOX_LEVEL              21326
#define IDS_PACKAGEINITFAILED           21326
#define IDS_PACKAGEINITFAILED2          21327
#define IDS_PACKAGEINITFAILED3          21328
#define IDS_ERROR_PROPERTYPAGES         21329
#define IDS_AUTOAPP_CANTADDPROJECT      21330
#define IDS_AUTOAPP_NOBLDNOW            21331
#define IDS_ERROR_NO_GOTOITEMS          21332
#define IDS_BLANKWKS                    21333
#define IDS_E_PROJECT_FUTURE_FORMAT     21334
#define IDS_ABOUT_DEVSTUD               21335
#define IDC_MODIFY                      57671
#define IDC_MODIFY2                     57672
#define IDC_RESET_ALL_MENUS             57672
#define IDC_IMAGE_PASTE                 57673

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        21335
#define _APS_NEXT_COMMAND_VALUE         21185
#define _APS_NEXT_CONTROL_VALUE         21270
#define _APS_NEXT_SYMED_VALUE           21185
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\prxycust.cpp ===
#include "stdafx.h"

#include "prxycust.h"

#include "barglob.h"
#include "custbtn.h"
#include "menuprxy.h"
#include "shell.h"
#include "bardockx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

UINT DSM_COMMANDREMOVED = RegisterMessage("DevStudioCommandRemoved");

///////////////////////////////////////////////////////////////////////////////
//      CToolCustomizer
//              The tool customizer is responisble for managing the customizing of
//              toolbars, which constists of managing the selection, button moving,
//              and button sizing.
//

//      CToolCustomizer::CToolCustomizer
//              Construction.

CToolCustomizer::CToolCustomizer(CDockManager* pManager, CDlgTab* pDlg,
	const CObArray& aBars, BOOL bTemp /*=FALSE*/, BOOL bUndo /*=FALSE*/)
	: m_aBars(aBars)
{
	m_pManager = pManager;
	m_pDialog = pDlg;
	m_pSelectBar = NULL;
	m_nSelectIndex = 0;
	m_bTemp = bTemp;
	m_bUndo = bUndo;
	
	if (m_pDialog != NULL)
	{
		ASSERT_VALID(m_pManager);
		m_pManager->EnableManagerInput(FALSE);
		SetPropertyBrowserVisible(FALSE);
	}
}

//      CToolCustomizer::~CToolCustomizer
//              Destruction. Turn off the selection, update the visible command cache,
//              and re-enable input to dockable windows.

CToolCustomizer::~CToolCustomizer()
{
	SetSelection(NULL, 0);

	// if there's a dropped menu, dedrop it: !!! REVIEW: HACK
	if(	CASBar::s_pCustomizer==this &&
		CCustomBar::s_pDroppedBar!=NULL)
	{
		CCustomBar::s_pDroppedBar->ExpandItem(CCustomBar::s_nDroppedItem, FALSE);
	}

	if (m_pDialog != NULL)
	{
		ASSERT_VALID(m_pManager);
		m_pManager->EnableManagerInput(TRUE);

		// Re-enable windows in window menu.
		CMDIFrameWnd* pFrame = (CMDIFrameWnd*) m_pManager->m_pFrame;
		if (pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)))
			::SendMessage(pFrame->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);

		BOOL bPopProp;
		theApp.m_theAppSlob.GetIntProp(P_PoppingProperties, bPopProp);

		SetPropertyBrowserVisible(!bPopProp);
	}
}

//      CToolCustomizer::SetSelection
//              Changes the selection (fuzzy rect around button), and stores the new
//              location.
void CToolCustomizer::SetSelection(CToolBarProxy* pBar, int nIndex)
{
	if (m_pSelectBar == NULL && m_nSelectIndex == -1)
		return; // Locked selection.
	if (m_pSelectBar == pBar && m_nSelectIndex == nIndex)
	return;

	if (m_pSelectBar != NULL && m_nSelectIndex!=-1)
	{
		CClientDC dcClient(m_pSelectBar->GetWindow());
		DrawSelection(&dcClient);
	}
	
	m_pSelectBar = pBar;
	m_nSelectIndex = nIndex;
	
	if (m_pSelectBar != NULL)
	{
		m_pSelectBar->OnSelChange(nIndex);

		CClientDC dcClient(m_pSelectBar->GetWindow());
		DrawSelection(&dcClient);
	}

	// In 4.x, there was some special-case code here to update the button description
	// whenever the selection was changed. In Orion, we want change notification in
	// another place too (the choose button dialog), so I'm sending a message
	// to the parent window, which can pick it up and perform any required action.
	// There are now 2 possible recipients; we only send it twice if they're different
	// martynl 2Apr96

	CWnd *pParent=NULL;
	if(m_pSelectBar)
	{
		pParent=pBar->GetWindow()->GetParent();

		if(pParent)
		{
			pParent->SendMessage(DSM_BARSELECTCHANGING, nIndex, (LPARAM)pBar);
		}
	}

	if( m_pDialog && 
		pParent->GetSafeHwnd()!=m_pDialog->GetSafeHwnd())
	{
		m_pDialog->SendMessage(DSM_BARSELECTCHANGING, nIndex, (LPARAM)pBar);
	}

	// Hide any destination that would be invalid for this selection.
	if(m_pSelectBar &&
		nIndex)
	{
		int nId=m_pSelectBar->GetButtonCmdID(nIndex);

		if(nId)
		{
			CTE *pCTE=theCmdCache.GetCommandEntry(nId);
			if(pCTE)
			{
				if(pCTE->flags & CT_MENU)
				{
					CASBar::HideInvalidDestination(nId);
				}
			}
		}
	}
}

//      CToolCustomizer::DeleteSelection
//              Deletes the selected button from it's toolbar.

BOOL CToolCustomizer::DeleteSelection(BOOL bDeferRemove)
{
	if (m_pSelectBar == NULL || m_pSelectBar->IsInDialog())
		return FALSE;

	BOOL bRemovePending=FALSE;

	if (m_bUndo)
		theUndoSlob.BeginUndo(IDS_UNDO_DELETE);
	
	if (m_pSelectBar->IsStaticItem(m_nSelectIndex))
	{
		m_pSelectBar->OnDeleteSelection();
	}
	else
	{
		CToolBarProxy* pBar = m_pSelectBar;
		int nIndex = m_nSelectIndex;
		UINT nIDWnd = (UINT) pBar->GetWindow()->GetDlgCtrlID();

		SetSelection(NULL, 0);

		if (pBar->GetCount() > 1 || nIDWnd < IDTB_CUSTOM_BASE)
		{
			UINT nCmdID=pBar->GetButtonCmdID(nIndex);

			pBar->DeleteButton(nIndex);
			pBar->OnDeleteSelection();
			pBar->RecalcLayout();

			// inform the parent dialog that a command has been removed
			if(	m_pDialog &&
				nCmdID>0)
			{
				m_pDialog->SendMessage(DSM_COMMANDREMOVED, nCmdID, 0);
			}
		}
		else if (m_pManager != NULL)
		{
			// if we're deleting the bar, lose the menu first
			if(	pBar &&		// should *never* be null, but safety first during the endgame
				CASBar::s_pDroppedBar==pBar->GetWindow())
			{
				CASBar::CancelMenu();
			}

			if(bDeferRemove)
			{
				bRemovePending=TRUE;
			}
			else
			{
				// Toolbars above the IDTB_CUSTOM_BASE range must belong to the shell.
				m_pManager->RemoveWnd(MAKEDOCKID(PACKAGE_SUSHI, nIDWnd));
			}
		}
	}

	if (m_bUndo)
		theUndoSlob.EndUndo();

	return bRemovePending;
}       

//      CToolCustomizer::DrawSelection
//              Draws the selection (fuzzy rect) on a given DC.

void CToolCustomizer::DrawSelection(CDC* pDC)
{
	CRect rect;
	
	m_pSelectBar->GetItemRect(m_nSelectIndex, rect);
	CBrush* pBrush = CDC::GetHalftoneBrush();
	if (pBrush != NULL)
		pBrush->UnrealizeObject();

	DrawTrackRect(pDC, &rect);
}

// A helper for DoButtonMove - creates a TRANSFER_TBBUTTON for a dragged command from the list
TRANSFER_TBBUTTON *CToolCustomizer::CreateCommandTransfer(int nCommand, CToolBarProxy *pBarDest )
{
	TRANSFER_TBBUTTON *pTrans=NULL;

	// copy from the all commands list
	CPackage *pPackage;

	// is there an available default appearance for this command?
	UINT nStyle=theApp.GetCommandBtnInfo(nCommand, &pPackage);
	BOOL bHasGlyph=theApp.HasCommandBitmap(nCommand);

	LPCTSTR pszMenuText;
	BOOL bFound=theCmdCache.GetCommandString(nCommand, STRING_MENUTEXT, &pszMenuText);
	BOOL bHasText=bFound && pszMenuText!=NULL && *pszMenuText!='\0';

	APPEARANCE apInitial=pBarDest->GetInitialAppearance(nStyle);
	if(	(apInitial==cAppearanceImageOnly && !bHasGlyph) ||
		(apInitial==cAppearanceTextOnly && !bHasText))
	{
		// user must choose a representation for the button
		CCustomButtonDlg *pCustom;

		CString buttonName;                     // name of the button such as DebugGo

		CAppToolGroups::GetAppToolGroups()->GetCommandName(nCommand,buttonName);
		CAppToolGroups::ReleaseAppToolGroups();

		pCustom=new CCustomButtonDlg(buttonName,pszMenuText, pBarDest->GetAppearance(), m_pManager, pBarDest->CanText(nStyle), pBarDest->CanGlyph(nStyle));
		if(pCustom->DoModal()==IDOK)
		{
			switch(pCustom->m_aAppearance)
			{
				default:
					ASSERT(FALSE);
					break;

				case cAppearanceImageOnly:
					// user chose one of the stock glyphs, so copy that
					ASSERT(pCustom->m_hbmCustomGlyph!=NULL);
					pTrans=new TRANSFER_TBBUTTON(nCommand, pCustom->m_hbmCustomGlyph, pBarDest->HasLargeButtons());
					break;

				case cAppearanceTextOnly: 
					// user entered a string label
					pTrans=new TRANSFER_TBBUTTON(nCommand, &(pCustom->m_buttonText), TRUE);
					break;

				case cAppearanceImageText:
					// user chose a stock glyph and a text label
					pTrans=new TRANSFER_TBBUTTON(nCommand, &(pCustom->m_buttonText), pCustom->m_hbmCustomGlyph, pBarDest->HasLargeButtons(), TRUE);
					break;
			}
		}
		else
		{
			// user cancelled dialog
			pTrans=NULL; 
		}
		delete pCustom;
	}
	else
	{
		// use default bitmap from package
		pTrans=new TRANSFER_TBBUTTON(nCommand);
	}

	return pTrans;
}

TRANSFER_TBBUTTON *CToolCustomizer::CreateSeparatorTransfer()
{
    return new TRANSFER_TBBUTTON(ID_SEPARATOR);
}

// determines, for a given point, what the drop button is
void CToolCustomizer::GetDropButton(CPoint pt, CToolBarProxy **ppBarDest, int *pnIndexDest, 
									CRect *pPrevious, ORIENTATION *porBar, UINT *pnHTSize)
{
	ASSERT(ppBarDest!=NULL);
	ASSERT(pnIndexDest!=NULL);
	ASSERT(pnHTSize!=NULL);
	ASSERT(porBar!=NULL);

	*ppBarDest=NULL; // no bar
	*pnIndexDest=-1; // dropped on dialog
	
	CRect rectTest;

	if (m_pDialog != NULL)
	{
		// check if it's inside the parent of this tab page, or below
		CWnd* pHit = CWnd::WindowFromPoint(pt);
		CWnd* pParent=m_pDialog->GetParent();
		if(	pParent==pHit ||
			pParent->IsChild(pHit))
		{
			return;
		}
	}

	POSITION pos=CBMenuPopup::s_listMenus.GetTailPosition();
	int nBarCount = m_aBars.GetSize();
	int iBar=0;
	BOOL bFound=FALSE;

	// Note: We must check menus before bars, because menus are parented to bars, so we need to
	// offer then the first chance to match.

	// loop over all bars and menus
	while(iBar<nBarCount || pos!=NULL)
	{
		// after menus, do bars
		if(pos!=NULL)
		{
			// loop menus
			CBMenuPopup *pMenu=CBMenuPopup::s_listMenus.GetPrev(pos);

			if(pMenu &&
				pMenu->GetSafeHwnd())
			{
				// only have a proxy when the menu is open
				*ppBarDest=pMenu->GetProxy();
			}
			else
			{
				*ppBarDest=NULL;
			}
		}
		else
		{
			// loop bars
			*ppBarDest = CToolBarProxy::GetBarProxy(m_aBars[iBar]);

			++iBar;
		}

		if(*ppBarDest==NULL)
		{
			continue;
		}

		// Two types of bar aren't checked: NODRAG bars (which should remain
		// immune at both ends), and bars which are uncreated (such as the phoney
		// one we create when dragging from the all commands list)
		if( (*ppBarDest)->GetWindow()->GetSafeHwnd()==NULL ||
			(*ppBarDest)->GetBarStyle() & CTBRS_NODRAG)
			continue;

		(*ppBarDest)->GetWindow()->GetWindowRect(rectTest);

		// First check if it's in the right boundaries
		if (rectTest.PtInRect(pt))
		{
			// Is this bar actually the owner of the point in question.
			CWnd* pWnd = CWnd::WindowFromPoint(pt);     
			while (pWnd != NULL && pWnd != (*ppBarDest)->GetWindow())
				pWnd = pWnd->GetParent();
				
			if (pWnd == (*ppBarDest)->GetWindow())
			{
				bFound=TRUE;
				break;
			}
		}
	}
	
	if (!bFound)
		*ppBarDest = NULL;

	if(*ppBarDest)
	{
		CPoint ptLocal=pt; // pt of button, adjusted to bar coordinates
		(*ppBarDest)->GetWindow()->ScreenToClient(&ptLocal);

		*pnHTSize=(*ppBarDest)->GetExpansionConstraint(CRect(ptLocal.x, ptLocal.y, ptLocal.x, ptLocal.y) ,porBar); // !!! maybe dicey
		
		*pnIndexDest = (*ppBarDest)->IndexFromPoint(ptLocal,pPrevious);
	}
	else
	{
		*pnHTSize=HTRIGHT;
		*pnIndexDest=0; // dropped in empty space
	}
}

//      CToolCustomizer::DoButtonMove
//              The guts of the tool customizer, handles the dragging of a button from
//              one location to another.

/* It is not valid for pBar to be NULL. But pBar may be a new-ed, uncreated 
CustomBar derivative, in which case, nIndex should be -1 and nCommand is the
id of the command being dragged from the all commands or all menus list. mtType
explains what kind of move is happening

This allows most of the code in this function to remain ignorant of whether there
is really a source toolbar or not. 

It's not valid to call any window-related function on a new-ed, uncreated bar. But we can
call pBar->NewBar(...), which is the reason we need the object.
*/
BOOL CToolCustomizer::DoButtonMove(CPoint pt, CToolBarProxy* pBar, int nIndex, BOOL *pbDeletePending, MOVETYPE mtType, int nCommand)
{
	CRect rectTest;
	BOOL bCopy;
	BOOL bLastButton=FALSE;

	// TRUE if the bar was created by the move, and so should be deleted if the move is cancelled
	BOOL bSynthesizedBar=FALSE;

	ASSERT(pBar!=NULL);
	if(pbDeletePending)
	{
		*pbDeletePending=FALSE;
	}
	
	if (mtType==cBar)
	{
		// if there's a source which isn't already the selection, make it the selection
		if(pBar != m_pSelectBar || nIndex != m_nSelectIndex)
		{
			SetSelection(pBar, nIndex);
		}
		
		// don't allow dragging from toolbars that don't want to.
		if(pBar->GetBarStyle() & CTBRS_NODRAG)
		{
			return FALSE;
		}
	}
	else
	{
		// when there's no original source for the button, clear the current selection,
		// to avoid confusion about what is being dragged
		SetSelection(NULL,0);
	}

	CToolBarProxy* pBarDest;
	int nIndexDest;
	int nCmdIDSrc=0;				// the command being dragged if it is a menu, or 0 if not.
	int nCmd=0;						// the command being dragged
	UINT nIDBar=0;					// window id of the source bar. Need to get in advance, in case the
									// bar goes away while dragging

	// determine command being dragged
	if(mtType==cBar)
	{
		ASSERT(pBar);
		nCmd=pBar->GetButtonCmdID(nIndex);
		nIDBar= (UINT) pBar->GetWindow()->GetDlgCtrlID();
	}
	else
	{	
		nCmd=nCommand;
	}

	if(nCmd!=0)
	{
		CTE *pCTE=theCmdCache.GetCommandEntry(nCmd);

		if(pCTE &&
			pCTE->flags & CT_MENU)
		{
			// only use source command id for menus.
			nCmdIDSrc=nCmd;
		}
	}
	
	ORIENTATION orBar;
	UINT nHTSize;
	CPoint ptInitial=pt;
	if (!TrackButtonMove(pt, bCopy, &pBarDest, &nIndexDest, &orBar, &nHTSize, nCmdIDSrc))
		return FALSE;

	// must be copy when nIndex is -1 (can't perform a move when
	// there's no source to perform a 'delete' on).
	ASSERT(nIndex!=-1 || bCopy);
	
	if (pBarDest == NULL)
	{
		if (!bCopy)
		{
			BOOL bDeletePending=DeleteSelection(TRUE);
			if(pbDeletePending)
			{
				*pbDeletePending=bDeletePending;
			}
			return TRUE;
		}
		else if (nIndexDest==0 &&       // drop was in empty space
				m_pManager != NULL) // and there's a dock manager present
		{
			// In V4,x. we passed in the command id of the new button here, and then returned.
			// This was ok, because there couldn't be any kind of custom button options. Now that
			// there can, we must treat a drag to an empty space the same way as any other.
			// martynl 08Apr96
			if ((pBarDest = pBar->NewBar((UINT)-1, pt)) == NULL)
			{
				return FALSE;
			}
			bSynthesizedBar=TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	if(!bCopy && pBar)
	{
		if(pBar->GetCount()==1)
		{
			bLastButton=TRUE;
		}
	}
	
	GAP gap = gapNil;
	BOOL bReplace = FALSE;
	
	if (nIndexDest == -1)
	{
		nIndexDest = 0;
	}
	else if (pBarDest->IsGapItem(nIndexDest))
	{
		bReplace = TRUE;
	}

	if (bCopy)
	{
		TRANSFER_TBBUTTON *pTrans=NULL;
		switch(mtType)
		{
			case cBar:
				pTrans=new TRANSFER_TBBUTTON(pBar, nIndex, FALSE);
				break;

			case cCommand:
				pTrans=CreateCommandTransfer(nCommand, pBarDest);
				break;

			default:
				ASSERT(FALSE);
				break;
		}

		if (pTrans==NULL)
		{
			if(bSynthesizedBar && pBarDest && pBarDest->GetWindow())
			{
				UINT nIDWnd = (UINT) pBarDest->GetWindow()->GetDlgCtrlID();

				if(m_pManager)
				{
					m_pManager->RemoveWnd(MAKEDOCKID(PACKAGE_SUSHI, nIDWnd));
				}
				pBarDest=NULL;
			}
			return FALSE;
		}
		
		SetSelection(NULL, 0);
		if (pBar->GetRealObject() != pBarDest->GetRealObject())
		{
			m_nSelectIndex = -1;    // Lock the selection.
			pBarDest->OnBarActivate();
			m_nSelectIndex = 0;
		}

		// Start recording after activation to assure correct window.
		if (m_bUndo)
			theUndoSlob.BeginUndo(IDS_UNDO_COPY);

		if(nIndex!=-1 && !bLastButton)
		{
			ASSERT_VALID(pBar->GetWindow());
		}

		pBarDest->InsertButton(nIndexDest, *pTrans, bReplace, gap);

		pBarDest->RecalcLayout(nHTSize);
		ASSERT_VALID(pBarDest->GetWindow());

		if(pTrans)
		{
			delete pTrans;
		}
	}
	else
	{
		ASSERT(mtType==cBar);

		if (pBarDest->GetRealObject() != pBar->GetRealObject())
		{
			if (pBar->IsStaticItem(nIndex))
				return FALSE; // Cannot move a static item to another toolbar.
		}
		else
		{
			if (bReplace)
			{
				// May want to preserve some gaps.
				if ((nIndexDest == nIndex + 1) &&
					pBar->IsGapItem(nIndex - 1))
				{
					gap = gapBefore;
				}
				else if ((nIndexDest == nIndex - 1) &&
					pBar->IsGapItem(nIndex + 1))
				{
					gap = gapAfter;
				}
			}
			else if (nIndexDest == nIndex ||
				nIndexDest == nIndex + 1)
			{
				// nudge time.
				nIndexDest = nIndex;
				CRect rectButton;
				pBar->GetItemRect(nIndexDest, rectButton);
				int nDiffRect = (orBar == orVert) ?
					pt.y - ptInitial.y : pt.x - ptInitial.x;

				if (nDiffRect > 0)
				{
					if (pBar->IsGapItem(nIndexDest - 1) || nIndex == 0)
						return FALSE;
					else
						gap = gapBefore;
				}
				else
				{
					if (pBar->IsGapItem(nIndexDest + 1) ||
						nIndex == pBarDest->GetCount() - 1)
						return FALSE;
					else
						gap = gapAfter;
				}
			}
		}
	    
	    // Here we actually do the button move by deleting the button from
	    // its old location, and inserting it in its new location.  Not always
	    // optimal, but seems fast enough.
	    //
		TRANSFER_TBBUTTON trans(pBar, nIndex, TRUE);

		SetSelection(NULL, 0);
		int nCountOld = pBar->GetCount();
		HWND hwnd = NULL;
		BOOL bRemoveBar = FALSE;

		if (m_bUndo)
			theUndoSlob.BeginUndo(IDS_UNDO_MOVE);
		
		pBar->DeleteButton(nIndex, TRUE);

		if(pBarDest==NULL)
		{
			UINT nCmdID=trans.nID;

			// inform the parent dialog that a command has been removed
			if(	m_pDialog &&
				nCmdID>0)
			{
				m_pDialog->SendMessage(DSM_COMMANDREMOVED, nCmdID, 0);
			}
		}
		
		if (pBar != pBarDest)
		{
			if (!(pBar->GetCount() > 0 || nIDBar < IDTB_CUSTOM_BASE))
				bRemoveBar = TRUE;
			else
				pBar->RecalcLayout();

			// Restart undo to assure correct window.
			if (m_bUndo)
			{
				theUndoSlob.EndUndo();
				theUndoSlob.Link();
			}

			m_nSelectIndex = -1;    // Lock the selection.
			pBarDest->OnBarActivate();
			m_nSelectIndex = 0;

			if (m_bUndo)
				theUndoSlob.BeginUndo(IDS_UNDO_MOVE);
		}
		else if (nIndex < nIndexDest)
		{
			nIndexDest -= nCountOld - pBar->GetCount();
		}

		if (nIndexDest < 0)
		{
			nIndexDest = 0;
			bReplace = FALSE;
		}
		
		// No gaps, if this is the first button.
		if (pBarDest->GetCount() == 0)
			gap = gapNil;
		
		// we must ensure pBar is valid before we insert button, because it might disappear as a result of the insert
		if(nIndex!=-1 && !bLastButton)
		{
			ASSERT_VALID(pBar->GetWindow());
		}

		pBarDest->InsertButton(nIndexDest, trans, bReplace, gap);
		pBarDest->RecalcLayout(nHTSize);

		if (bRemoveBar && m_pManager != NULL)
			m_pManager->RemoveWnd(MAKEDOCKID(PACKAGE_SUSHI, nIDBar));
	}
		
	if (!m_bTemp &&
		pBarDest->GetWindow()->GetSafeHwnd()!=NULL)
	{
		if (pBarDest->IsGapItem(nIndexDest))
			nIndexDest++;   // Make sure we don't select a separator.
	
		pBarDest->GetWindow()->UpdateWindow();
		int nNewSelection=nIndexDest;

		// could be past the end if we just deleted; move back if it's past the end, and we're not at 0
		if(nNewSelection>pBarDest->GetCount() - 1 &&
			pBarDest->GetCount()>0)
		{
			nNewSelection=pBarDest->GetCount() - 1;
		}
		ASSERT(nNewSelection>=0);
		ASSERT(nNewSelection<pBarDest->GetCount());

		SetSelection(pBarDest, nNewSelection);
	}

	if(pBarDest && pBarDest != pBar)
	{
		ASSERT_VALID(pBarDest->GetWindow());
	}

	if (theUndoSlob.IsRecording())
		theUndoSlob.EndUndo();

	return TRUE;
}

static inline int Brightness(COLORREF cr)
{
	return (3*GetRValue(cr) + 6*GetGValue(cr) + GetBValue(cr));
}

// This code, which is similar to office's GetRopToDrawFeedback (!) draws or undraws 
// the insertion point, given the rectangle of the preceding button, the orientation of the bar
// and an indication of whether it goes before or after
void CToolCustomizer::DrawDragFeedback(CDC *pDC, const CRect &rect, ORIENTATION or, BOOL bBefore)
{
	ASSERT(pDC != NULL);
	int ROP2;
	int ROP2Sav = pDC->GetROP2();
	CBrush brushBtn;
	brushBtn.CreateSolidBrush(globalData.clrBtnFace);
	const int cPoint = 8;
	POINT rgPoint[cPoint];
	POINT *ppt = rgPoint;

	CRect rectDest=rect;
	// make a 6 pixel width/height rectangle to draw into.
	if(or!=orVert)
	{
		// horizontal, so collapse width
		if(bBefore)
		{
			rectDest.right=rectDest.left;
		}
		else
		{
			rectDest.left=rectDest.right;
		}
		rectDest.left-=3;
		rectDest.right+=3;
	}
	else
	{
		if(bBefore)
		{
			rectDest.bottom=rectDest.top;
		}
		else
		{
			rectDest.top=rectDest.bottom;
		}
		rectDest.top-=3;
		rectDest.bottom+=3;
	}

	ROP2 = (Brightness(globalData.clrBtnFace) > 1100) ? R2_XORPEN : R2_NOTXORPEN;
	VERIFY(ROP2Sav == pDC->SetROP2(ROP2));
	int iPolyFillModeSav=pDC->GetPolyFillMode();
	VERIFY(iPolyFillModeSav == pDC->SetPolyFillMode(ALTERNATE));
	ASSERT((rectDest.Height() == 6) || (rectDest.Width()== 6));

#define SetAPoint(ppt, xx, yy) (ppt->x = (xx), ppt->y = (yy), ppt++)

	if (or==orVert)
		{
		SetAPoint(ppt, rectDest.left, rectDest.top-1);
		SetAPoint(ppt, rectDest.left+3, rectDest.top+2);
		SetAPoint(ppt, rectDest.right-3, rectDest.top+2);
		SetAPoint(ppt, rectDest.right, rectDest.top-1);
		SetAPoint(ppt, rectDest.right, rectDest.bottom);
		SetAPoint(ppt, rectDest.right-2, rectDest.bottom-2);
		SetAPoint(ppt, rectDest.left+2, rectDest.bottom-2);
		SetAPoint(ppt, rectDest.left, rectDest.bottom);
		}
	else
		{
		SetAPoint(ppt, rectDest.left, rectDest.top);
		SetAPoint(ppt, rectDest.right, rectDest.top);
		SetAPoint(ppt, rectDest.right-2, rectDest.top+2);
		SetAPoint(ppt, rectDest.right-2, rectDest.bottom-3);
		SetAPoint(ppt, rectDest.right+1, rectDest.bottom);
		SetAPoint(ppt, rectDest.left-1, rectDest.bottom);
		SetAPoint(ppt, rectDest.left+2, rectDest.bottom-3);
		SetAPoint(ppt, rectDest.left+2, rectDest.top+2);
		}

#undef SetAPoint

	CBrush *pbrSav = pDC->SelectObject(&brushBtn);
	CPen *pPenSav = pDC->SelectObject(CPen::FromHandle((HPEN)GetStockObject(NULL_PEN)));
	pDC->Polygon(rgPoint, cPoint);
	pDC->SelectObject(pbrSav);
	VERIFY(ROP2 == pDC->SetROP2(ROP2Sav));
	VERIFY(ALTERNATE == pDC->SetPolyFillMode(iPolyFillModeSav));
	pDC->SelectObject(pPenSav);
}


//      CToolCustomizer::TrackButtonMove
//              Tracks the button rectangle as the user drags it around the screen,
//              and also whether or not the operation is a copy or move.

//              This routine must now allow for the situation where there is no selected
//				button when it is called
BOOL CToolCustomizer::TrackButtonMove(CPoint &pt, BOOL& bCopy, CToolBarProxy **ppBarDest, int *pnIndexDest, ORIENTATION *porBar, UINT *pnHTSize, int nCmdIDSrc)
{
    BOOL bCancel = FALSE;
    BOOL bMoved = FALSE;
	BOOL bDestChanged=TRUE;
    
    BOOL bControl, bControlOld;
    CPoint ptOld;

	// We use a pointer to a DC so we can change DC as we change bar, because we only want to draw our
	// feedback inside the visible region of the destination bar.
	CLockDC *pDC=NULL;
    
	CWnd* pWndTrack=NULL;

	if(m_pDialog==NULL)
	{
		// Loop while the mouse is down.
		pWndTrack = CWnd::GetFocus(); // So we stay the active window.
		if (pWndTrack == NULL && m_pManager != NULL)
		{
			// Try to get a valid focused window.
			m_pManager->m_pFrame->SetFocus();
			if ((pWndTrack = CWnd::GetFocus()) == NULL)
				return FALSE;
		}
	}
	else
	{
		pWndTrack=m_pDialog;
	}

	pWndTrack->SetCapture();
	
    ptOld = pt;
	CPoint ptInitial=pt;
    bControlOld = -1; // neither false nor true

	CToolBarProxy *pBarDest=NULL;           // current destination
	CToolBarProxy *pBarDestOld=NULL;        // previous destination
	int nIndexDest=0;
	int nIndexDestOld=0;
	int nIndexExpand=-1;
	int nIndexExpandOld=-1;
	CToolBarProxy  *pBarExpandOld=NULL;
	CRect rectPreviousButton(0,0,0,0); // rectangle of the button before the insert position
	CRect rectPreviousButtonOld; // rectangle of the button before the insert position
	BOOL bUndraw=FALSE;
	BOOL bCanDrop=FALSE;		// TRUE if the current location would support a drop of the current item

	// We need to work out m_pSelectBar related stuff before we do the drag, because the drag could cause the selection to be lost
	// when a menu is auto-closed
	BOOL bNoSource=(m_pSelectBar==NULL);				// TRUE if the source bar was null to start with
	BOOL bSourceInDialog=(!bNoSource && m_pSelectBar->IsInDialog());	// TRUE if the source bar is inside a dialog
	BOOL bSourceStatic=(!bNoSource && !m_pSelectBar->IsStaticItem(m_nSelectIndex));
    
    while (!PollForMouseChange(pt, FALSE, bCancel, TRUE))
    {                 
		bControl = ((GetAsyncKeyState(VK_CONTROL) & ~1)  &&
					bSourceStatic) ||							// Cannot copy static item.
					bNoSource ||                                // Always copy from no source.
					bSourceInDialog;                            // Always copy from customize dialog.

		if (pt == ptOld &&
			bControl==bControlOld)
			continue;
		
		pBarDestOld=pBarDest;
		nIndexDestOld=nIndexDest;
		rectPreviousButtonOld=rectPreviousButton;

		GetDropButton(pt,&pBarDest, &nIndexDest, &rectPreviousButton, porBar, pnHTSize);

#if _DEBUG
		// These assertions can be pretty hard to be debug, but they are important. They indicate when we would have
		// done a bad paint, because we expect the control id and the rectangle to always change in sync.

		// To debug the problem, if it's in a toolbar, you can use the IFP_TRACE options I've added over there. They make it
		// much easier to see why a failure has occurred, since one normally needs to know how both sets of rectangles
		// were calculated.

		if(	pBarDest==pBarDestOld && pBarDest!=NULL)
		{
			// if the rect changed, the index must too
			if(nIndexDestOld==nIndexDest)
			{
				// same index, same rect
				ASSERT(rectPreviousButtonOld==rectPreviousButton);
			}
			else
			{
				int nFirstVisible=pBarDest->FindNextVisibleItem(-1, TRUE);
				if(nFirstVisible!=-1)
				{
					if( (nIndexDest==nFirstVisible && nIndexDestOld==-1) ||
						(nIndexDest==-1 && nIndexDestOld==nFirstVisible))
					{
						// index -1 and 0 must have same rect
						ASSERT(rectPreviousButtonOld==rectPreviousButton);
					}
					else
					{
						// different index, different rect
						ASSERT(rectPreviousButtonOld!=rectPreviousButton);
					}
				}
			}
		}
#endif

		// draw the insertion point
		if( pBarDest!=pBarDestOld ||
			nIndexDest!=nIndexDestOld)
		{
			if(pBarDestOld!=NULL)
			{
				// shouldn't get here unless we're undrawing, in which case DC should be set up already
				ASSERT(pDC!=NULL);

				ORIENTATION or=pBarDestOld->GetOrient();
				DrawDragFeedback(pDC, &rectPreviousButtonOld, or, nIndexDestOld==-1);
				bUndraw=FALSE;
			}

			// since we've just moved out of the old bar, lose it's DC
			if(pBarDestOld!=pBarDest)
			{
				if(pDC!=NULL)
				{
					delete pDC;
					pDC=NULL;
				}
			}

			if(pBarDest!=NULL)
			{
				if(pDC==NULL)
				{
					pDC=new CLockDC(pBarDest->GetWindow());
					ASSERT(pDC);
				}

				ORIENTATION or=pBarDest->GetOrient();
				DrawDragFeedback(pDC, &rectPreviousButton, or, nIndexDest==-1);
				bUndraw=TRUE;
			}
		}

		// determine what we should expand
		if(pBarDest!=NULL)
		{
			CPoint ptLocal=pt;
			pBarDest->GetWindow()->ScreenToClient(&ptLocal);
			nIndexExpand=pBarDest->HitTest(ptLocal);
		}
		else
		{
			nIndexExpand=-1;
		}

		// if there is a change in expansion, reflect it.
		if(nIndexExpand!=nIndexExpandOld ||
			pBarDest!=pBarExpandOld)
		{
			// expand the new
			if(	pBarDest!=NULL &&
				nIndexExpand!=-1)
			{
				if(pBarDest->ExpandDestination(nCmdIDSrc, nIndexExpand))
				{
					nIndexExpandOld=nIndexExpand;
					pBarExpandOld=pBarDest;
				}
			}
		}

		if (pBarDest!=pBarDestOld ||
			nIndexDest!=nIndexDestOld ||
			bControl != bControlOld)
		{
			int nIdCursor=IDCUR_BUTTON_COPY;
			if(pBarDest==NULL)
			{
				if(bControl)
				{
					nIdCursor=IDCUR_BUTTON_COPY;
				}
				else
				{
					nIdCursor=IDCUR_BUTTON_DELETE;
				}
			}
			else
			{
				if(bControl)
				{
					nIdCursor=IDCUR_BUTTON_COPY;
				}
				else
				{
					nIdCursor=IDCUR_BUTTON_MOVE;
				}
			}
			
			::SetCursor(theApp.LoadCursor(nIdCursor));
			bControlOld = bControl;
		}
	
		ptOld = pt;
    } // while
    
	// undraw insertion point
	if(bUndraw && pBarDest!=NULL)
	{
		ASSERT(pDC!=NULL);

		ORIENTATION or=pBarDest->GetOrient();
		DrawDragFeedback(pDC, &rectPreviousButton, or, nIndexDest==-1);

		if(pDC)
		{
			delete pDC;
			pDC=NULL;
		}
	}

	ASSERT(pDC==NULL);

    ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
	if(pWndTrack->GetCapture()==pWndTrack)
	{
		ReleaseCapture();
	}

    if (bCancel || (abs(pt.x - ptInitial.x) < 2 &&
		abs(pt.y - ptInitial.y) < 2))     // avoid slip
	{
		*ppBarDest=NULL;
		*pnIndexDest=-1;
		return FALSE;
	}
    else
    {
		bCopy = bControl;
		*ppBarDest=pBarDest;
		if(pBarDest)
		{
			// reason for the +1, indexfrompoint returns the index of the button
			// after which we are pointing at, while the caller wants to know about 'before'.
			nIndexDest+=1;
		}
		*pnIndexDest=nIndexDest;	
		return TRUE;
    }
}

//      CToolCustomizer::DoButtonSize
//              Manages the sizing of a control in a toolbar.

void CToolCustomizer::DoButtonSize(CPoint pt, CToolBarProxy* pBar, int nIndex)
{
	CRect rect;
	
	if (pBar->GetRealObject() != m_pSelectBar->GetRealObject() || nIndex != m_nSelectIndex)
		SetSelection(pBar, nIndex);
			
	if (!TrackButtonSize(pt, rect))
		return;
				
	HWND hwnd = pBar->GetButtonControl(nIndex);

	CRect rectDrop = rect;
	::GetDroppedRect(hwnd, rectDrop);
	::SetWindowPos(hwnd, NULL, 0, 0,
		rect.Width(), rectDrop.Height(),
		SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);

	pBar->OnButtonSize();
	pBar->RecalcLayout(pBar->GetExpansionConstraint(rect));
}

//      CToolCustomizer::TrackButtonSize
//              Tracks the control's size rectangle as the user moves the mouse.
//              Assumes that sizing is only allowed on the right edge of the control.

BOOL CToolCustomizer::TrackButtonSize(CPoint ptStart, CRect& rectFinal)
{
    BOOL bCancel = FALSE;
    
    CRect rect, rectOld;
    CPoint pt, ptOld;

    m_pSelectBar->GetItemRect(m_nSelectIndex, rect);
    m_pSelectBar->GetWindow()->ClientToScreen(rect);
    rectFinal = rect;
    
	ASSERT(m_pSelectBar->GetButtonStyle(m_nSelectIndex) & TBBS_SIZABLE);
	ASSERT(m_pSelectBar->GetButtonStyle(m_nSelectIndex) & TBBS_HWND);
	
	HWND hwnd = m_pSelectBar->GetButtonControl(m_nSelectIndex);

	// Get min-max info.  We provide defaults, in case window doesn't handle.
    MINMAXINFO mmi;
	mmi.ptMaxTrackSize = CPoint(::GetSystemMetrics(SM_CXSCREEN), rect.Height());
    mmi.ptMinTrackSize = CPoint(m_pSelectBar->GetButtonSize().cx, rect.Height());
    
    ::SendMessage(hwnd, WM_GETMINMAXINFO, 0, (LPARAM) (LPVOID) &mmi);

	// Do not allow windows smaller than button width.
	mmi.ptMinTrackSize.x = max(mmi.ptMinTrackSize.x,
		m_pSelectBar->GetButtonSize().cx);
    
    // Need a client DC for the first erase, and final draw to avoid trash
    // on the screen DC.

    CDC dcClient;

    if (!dcClient.Attach(::GetDC(m_pSelectBar->GetWindow()->GetSafeHwnd())))
		return FALSE;
	
	rectOld = rect;
	m_pSelectBar->GetWindow()->ScreenToClient(rectOld);
	DrawTrackRect(&dcClient, &rectOld);

#if 1
	CLockDC dc(NULL);
#else
	CClientDC dc(NULL);
#endif

	DrawTrackRect(&dc, &rect);

	// Loop while the mouse is down.
    CWnd* pWndTrack = CWnd::GetFocus(); // So we stay the active window.
    if (pWndTrack == NULL && m_pManager != NULL)
	{
		// Try to get a valid focused window.
		m_pManager->m_pFrame->SetFocus();
		if ((pWndTrack = CWnd::GetFocus()) == NULL)
			return FALSE;
	}
	
    pWndTrack->SetCapture();
    ptOld = ptStart; //[der] Was pt, but pt is not initialized.
    
    while (!PollForMouseChange(pt, FALSE, bCancel))
    {                 
	if (pt.x == ptOld.x)
		continue;
	
	rectOld = rect;

	rect.right = rectFinal.right + pt.x - ptStart.x;
		rect.right = rect.left +
			min(max(rect.Width(), mmi.ptMinTrackSize.x),
				mmi.ptMaxTrackSize.x);
	
	// Move the drag rect on screen.
		DrawTrackRect(&dc, &rect, &rectOld);
	
	ptOld = pt;
    } // while
    
    // Turn off drag rectangle.
	DrawTrackRect(&dc, &rect);
	
    ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
	if(pWndTrack->GetCapture()==pWndTrack)
	{
		ReleaseCapture();
	}

	BOOL bReturn = FALSE;
    if (!(bCancel || abs(rect.right - rectFinal.right) < 2))
	{
	    rectFinal = rect;
		bReturn = TRUE;
	}

	m_pSelectBar->GetWindow()->ScreenToClient(rectFinal);

	if (!bReturn)
		DrawTrackRect(&dcClient, &rectFinal);   //Redraw the selection.

	::ReleaseDC(m_pSelectBar->GetWindow()->GetSafeHwnd(), dcClient.Detach());
    return bReturn;
}

//      CToolCustomizer::DrawTrackRect
//              Handles drawing of track rects, which include the selection rect.
//              BrushOrg is set so that the selection rect will always paint the same.

void CToolCustomizer::DrawTrackRect(CDC* pdc, const CRect* prect,
	const CRect* prectLast /*=NULL*/)
{
	CSize size(g_mt.cxFrame - g_mt.cxBorder, g_mt.cyFrame - g_mt.cyBorder);

	COLORREF crBk = pdc->SetBkColor(RGB(0xFF, 0xFF, 0xFF));
	COLORREF crFG = pdc->SetTextColor(RGB(0, 0, 0));

	pdc->DrawDragRect(prect, size, prectLast, size);

	pdc->SetBkColor(crBk);
	pdc->SetTextColor(crFG);
}

BEGIN_POPUP_MENU(ButtonCustomize)
	MENU_ITEM(IDM_BUTTON_RESET)
	MENU_ITEM(IDM_BUTTON_DELETE)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_BUTTON_COPYIMAGE)
	MENU_ITEM(IDM_BUTTON_PASTEIMAGE)
	MENU_ITEM(IDM_BUTTON_RESETIMAGE)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_BUTTON_CHOOSEAPPEARANCE)
	MENU_ITEM(IDM_BUTTON_IMAGEONLY)
	MENU_ITEM(IDM_BUTTON_TEXTONLY)
	MENU_ITEM(IDM_BUTTON_IMAGETEXT)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_BUTTON_GROUPSTART)
END_POPUP_MENU()

POPDESC *CToolCustomizer::GetButtonMenu(void)
{
	return MENU_CONTEXT_POPUP(ButtonCustomize);
}

BOOL CToolCustomizer::DisplayButtonMenu(UINT nFlags, CPoint point)
{
	if (m_nSelectIndex != -1 &&
		m_pSelectBar!=NULL)
	{
		// find screen position
		::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(ButtonCustomize), point, theApp.m_pMainWnd);

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BEGIN_MESSAGE_MAP(CToolCustomizer, CCmdTarget)
	//{{AFX_MSG_MAP(CToolCustomizer)
	ON_COMMAND(IDM_BUTTON_COPYIMAGE, OnButtonCopyImage)
	ON_COMMAND(IDM_BUTTON_PASTEIMAGE, OnButtonPasteImage)
	ON_COMMAND(IDM_BUTTON_RESETIMAGE, OnButtonResetImage)
	ON_COMMAND(IDM_BUTTON_CHOOSEAPPEARANCE, OnButtonChooseAppearance)
	ON_COMMAND(IDM_BUTTON_RESET, OnButtonReset)
	ON_COMMAND(IDM_BUTTON_DELETE, OnButtonDelete)
	ON_COMMAND(IDM_BUTTON_IMAGEONLY, OnButtonImageOnly)
	ON_COMMAND(IDM_BUTTON_TEXTONLY, OnButtonTextOnly)
	ON_COMMAND(IDM_BUTTON_IMAGETEXT, OnButtonImageText)
	ON_COMMAND(IDM_BUTTON_GROUPSTART, OnButtonGroupStart)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_COPYIMAGE, OnUpdateButtonCopyImage)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_PASTEIMAGE, OnUpdateButtonPasteImage)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_RESETIMAGE, OnUpdateButtonResetImage)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_CHOOSEAPPEARANCE, OnUpdateButtonChooseAppearance)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_RESET, OnUpdateButtonReset)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_DELETE, OnUpdateButtonDelete)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_IMAGEONLY, OnUpdateButtonImageOnly)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_TEXTONLY, OnUpdateButtonTextOnly)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_IMAGETEXT, OnUpdateButtonImageText)
	ON_UPDATE_COMMAND_UI(IDM_BUTTON_GROUPSTART, OnUpdateButtonGroupStart)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

afx_msg void CToolCustomizer::OnButtonCopyImage()
{
	if (!m_pSelectBar->GetWindow()->OpenClipboard())
		return;
	
	EmptyClipboard();
	
	// copy the button
	HBITMAP hbmWell=m_pSelectBar->GetImageWell(m_nSelectIndex);
	int iImage=m_pSelectBar->GetImageIndex(m_nSelectIndex);
	CSize sizeImage=m_pSelectBar->GetImageSize();
	if(hbmWell!=NULL)
	{
		HBITMAP hbmClip=GLOBAL_DATA::DuplicateBitmap(m_pSelectBar->GetWindow(), // in this context
													hbmWell,                    // duplicate a portion of this well
													sizeImage, // size of portion
													CPoint(iImage*sizeImage.cx, 0)); // offset of portion
		
		// set the standard format (bitmap) data
		SetClipboardData(CF_BITMAP, hbmClip);
	}

	CloseClipboard();
}

afx_msg void CToolCustomizer::OnButtonPasteImage()
{
	m_pSelectBar->PasteButtonImage();
}

afx_msg void CToolCustomizer::OnButtonResetImage()
{
	m_pSelectBar->ResetButtonImage();
}

afx_msg void CToolCustomizer::OnButtonChooseAppearance()
{
	CCustomButtonDlg *pCustom;
	CString buttonName;                     // name of the button such as DebugGo
	CString buttonText;                     // label on toolbar, such as Start Program

	int nID=m_pSelectBar->GetButtonCmdID(m_nSelectIndex);
	CAppToolGroups::GetAppToolGroups()->GetCommandName(nID,buttonName);
	CAppToolGroups::ReleaseAppToolGroups();

	APPEARANCE aAppearance=m_pSelectBar->GetAppearance(m_nSelectIndex);

	if(aAppearance==cAppearanceImageOnly)
	{
		LPCSTR pText;
		theCmdCache.GetCommandString(nID, STRING_MENUTEXT, &pText);
		if(pText || *pText=='\0')
		{
			theCmdCache.GetCommandString(nID, STRING_COMMAND, &pText);
		}
		buttonText=pText;
	}
	else
	{
		buttonText = m_pSelectBar->GetButtonText(m_nSelectIndex);
	}

	// Get current glyph details
	HBITMAP hbmCurrent=NULL;
	int nIndexCurrent=m_pSelectBar->GetImageIndex(m_nSelectIndex);
	if(nIndexCurrent!=-1)
	{
		hbmCurrent=m_pSelectBar->GetImageWell(m_nSelectIndex);
	}

	pCustom=new CCustomButtonDlg(buttonName,buttonText, aAppearance, m_pManager, m_pSelectBar->CanText(m_nSelectIndex), m_pSelectBar->CanGlyph(m_nSelectIndex), hbmCurrent, nIndexCurrent);
	if(pCustom->DoModal()==IDOK)
	{
		ASSERT(m_pSelectBar);
		switch(pCustom->m_aAppearance)
		{
			default:
				ASSERT(FALSE);
				break;

			case cAppearanceTextOnly:
				m_pSelectBar->AddText(m_nSelectIndex, pCustom->m_buttonText, TRUE);
				if(aAppearance!=cAppearanceTextOnly)
				{
					m_pSelectBar->RemoveBitmap(m_nSelectIndex);
				}
				m_pSelectBar->ButtonModified(m_nSelectIndex, TRUE);
				break;

			case cAppearanceImageOnly:
				m_pSelectBar->AddBitmap(m_nSelectIndex, cBitmapSourceCustom, pCustom->m_hbmCustomGlyph);
				if(aAppearance!=cAppearanceImageOnly)
				{
					m_pSelectBar->RemoveText(m_nSelectIndex);
					m_pSelectBar->ButtonModified(m_nSelectIndex, TRUE);
				}
				break;

			case cAppearanceImageText:
				m_pSelectBar->AddText(m_nSelectIndex, pCustom->m_buttonText, TRUE);
				m_pSelectBar->AddBitmap(m_nSelectIndex, cBitmapSourceCustom, pCustom->m_hbmCustomGlyph);
				m_pSelectBar->ButtonModified(m_nSelectIndex, TRUE);
				break;
		}
	}
	delete pCustom;
}

afx_msg void CToolCustomizer::OnButtonReset()
{
	m_pSelectBar->ResetButtonImage();
	m_pSelectBar->ButtonModified(m_nSelectIndex, TRUE);

	// reset the attached menu, if appropriate
	int iImage;
	UINT nStyle;
	UINT nID;
	m_pSelectBar->GetButtonInfo(m_nSelectIndex, nID, nStyle, iImage);

	if(nStyle & TBBS_MENU)
	{
		CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();

		pFrame->ResetMenu(nID);
	}
}

afx_msg void CToolCustomizer::OnButtonDelete()
{ 
	DeleteSelection();
}

afx_msg void CToolCustomizer::OnButtonImageOnly()
{
	int iImage;
	UINT nStyle;
	UINT nID;
	m_pSelectBar->GetButtonInfo(m_nSelectIndex, nID, nStyle, iImage);

	if((nStyle & (TBBS_TEXTUAL | TBBS_GLYPH))==TBBS_GLYPH)
	{
		return;
	}

	if((nStyle & TBBS_GLYPH)==0)
	{
		m_pSelectBar->AddBitmap(m_nSelectIndex);        
	}

	if(nStyle & TBBS_TEXTUAL)
	{
		m_pSelectBar->RemoveText(m_nSelectIndex);
	}
	m_pSelectBar->ButtonModified(m_nSelectIndex,TRUE);
}

afx_msg void CToolCustomizer::OnButtonTextOnly()
{
	int iImage;
	UINT nStyle;
	UINT nID;
	m_pSelectBar->GetButtonInfo(m_nSelectIndex, nID, nStyle, iImage);

	if((nStyle & (TBBS_TEXTUAL | TBBS_GLYPH))==TBBS_TEXTUAL)
	{
		return;
	}

	if((nStyle & TBBS_TEXTUAL)==0)
	{
		m_pSelectBar->AddText(m_nSelectIndex);
	}

	if(nStyle & TBBS_GLYPH)
	{
		m_pSelectBar->RemoveBitmap(m_nSelectIndex);
	}
	m_pSelectBar->ButtonModified(m_nSelectIndex,TRUE);
}

afx_msg void CToolCustomizer::OnButtonImageText()
{
	int iImage;
	UINT nStyle;
	UINT nID;
	m_pSelectBar->GetButtonInfo(m_nSelectIndex, nID, nStyle, iImage);

	if((nStyle & (TBBS_TEXTUAL | TBBS_GLYPH))==(TBBS_TEXTUAL | TBBS_GLYPH))
	{
		return;
	}

	if((nStyle & TBBS_TEXTUAL)==0)
	{
		m_pSelectBar->AddText(m_nSelectIndex);
	}

	if((nStyle & TBBS_GLYPH)==0)
	{
		m_pSelectBar->AddBitmap(m_nSelectIndex);
	}

	m_pSelectBar->ButtonModified(m_nSelectIndex,TRUE);
}

afx_msg void CToolCustomizer::OnButtonGroupStart()
{
	// can begin group on all but first item
	if(     ((m_pSelectBar!=NULL &&
		  m_pSelectBar->IsInDialog()) ||
		  m_nSelectIndex==0))
	{
		return;
	}
	else
	{
		// now work out whether we're already starting a group
		ASSERT(m_nSelectIndex>0);
		UINT nStyle=m_pSelectBar->GetButtonStyle(m_nSelectIndex-1);

		// remove selection to avoid it moving during deletion
		CToolBarProxy *pSelectBar=m_pSelectBar;
		int nSelectIndex=m_nSelectIndex;
		SetSelection(NULL,0);

		if(nStyle & TBBS_SEPARATOR)
		{
			// remove the separator
			pSelectBar->RemoveSeparator(nSelectIndex);
			SetSelection(m_pSelectBar, nSelectIndex-1);
		}
		else
		{
			// insert a separator
			pSelectBar->InsertSeparator(nSelectIndex);
			SetSelection(m_pSelectBar, nSelectIndex+1);
		}
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonCopyImage(CCmdUI *pCmdUI)
{
	UINT nStyle=m_pSelectBar->GetButtonStyle(m_nSelectIndex);

	if((m_pSelectBar!=NULL &&
		m_pSelectBar->IsVisibleControl(m_nSelectIndex)) ||
	   (nStyle & (TBBS_GLYPH))==0)
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonPasteImage(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	pCmdUI->Enable(m_pSelectBar->CanPasteImage());
}


afx_msg void CToolCustomizer::OnUpdateButtonResetImage(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	pCmdUI->Enable(m_pSelectBar->CanResetImage());
}

afx_msg void CToolCustomizer::OnUpdateButtonChooseAppearance(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	pCmdUI->Enable(m_pSelectBar->CanChooseAppearance());
}

afx_msg void CToolCustomizer::OnUpdateButtonReset(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);

	UINT nStyle=m_pSelectBar->GetButtonStyle(m_nSelectIndex);

	// we can always reset menus, but other things can only be reset in the same conditions as custom glyphs
	if(nStyle & TBBS_MENU)
	{
		if((m_pSelectBar!=NULL &&
			m_pSelectBar->IsInDialog()) ||
			m_pSelectBar->IsVisibleControl(m_nSelectIndex))
		{
			pCmdUI->Enable(FALSE);
		}
		else
		{
			pCmdUI->Enable(TRUE);
		}
	}
	else
	{
		// can always reset custom text buttons
		if(nStyle & TBBS_CUSTOMTEXT)
		{
			pCmdUI->Enable(TRUE);
		}
		else
		{
			OnUpdateButtonResetImage(pCmdUI);
		}
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonDelete(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	// everything can be deleted
	if( m_pSelectBar->IsInDialog())
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonImageOnly(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	APPEARANCEOPTION aoText=m_pSelectBar->CanText(m_nSelectIndex);
	APPEARANCEOPTION aoImage=m_pSelectBar->CanGlyph(m_nSelectIndex);
	
	if(!m_pSelectBar->IsInDialog() &&
		GLOBAL_DATA::CanChooseImageOnly(aoText, aoImage))
	{
		// we can only use the menu to switch to this if we already have a glyph.
		int iImage;
		UINT nStyle;
		UINT nID;
		m_pSelectBar->GetButtonInfo(m_nSelectIndex, nID, nStyle, iImage);

		BOOL bHasGlyph=TRUE;
		if((nStyle & TBBS_GLYPH)==0)
		{
			bHasGlyph=theApp.HasCommandBitmap(nID);
		}

		if(bHasGlyph)
		{
			pCmdUI->Enable(TRUE);
		}
		else
		{
			pCmdUI->Enable(FALSE);
		}
	}
	else
	{
		pCmdUI->Enable(FALSE);
	}

	if(m_pSelectBar->GetAppearance(m_nSelectIndex)==cAppearanceImageOnly)
	{
		pCmdUI->SetCheck(TRUE);
	}
	else
	{
		pCmdUI->SetCheck(FALSE);
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonTextOnly(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	APPEARANCEOPTION aoText=m_pSelectBar->CanText(m_nSelectIndex);
	APPEARANCEOPTION aoImage=m_pSelectBar->CanGlyph(m_nSelectIndex);
	
	if(!m_pSelectBar->IsInDialog() &&
		GLOBAL_DATA::CanChooseTextOnly(aoText, aoImage))
	{
		pCmdUI->Enable(TRUE);
	}
	else
	{
		pCmdUI->Enable(FALSE);
	}

	if(m_pSelectBar->GetAppearance(m_nSelectIndex)==cAppearanceTextOnly)
	{
		pCmdUI->SetCheck(TRUE);
	}
	else
	{
		pCmdUI->SetCheck(FALSE);
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonImageText(CCmdUI *pCmdUI)
{
	ASSERT(m_pSelectBar);
	APPEARANCEOPTION aoText=m_pSelectBar->CanText(m_nSelectIndex);
	APPEARANCEOPTION aoImage=m_pSelectBar->CanGlyph(m_nSelectIndex);
	
	if(!m_pSelectBar->IsInDialog() &&
		GLOBAL_DATA::CanChooseImageText(aoText, aoImage))
	{
		int iImage;
		UINT nStyle;
		UINT nID;
		m_pSelectBar->GetButtonInfo(m_nSelectIndex, nID, nStyle, iImage);

		BOOL bHasGlyph=TRUE;
		if((nStyle & TBBS_GLYPH)==0)
		{
			bHasGlyph=theApp.HasCommandBitmap(nID);
		}

		if(bHasGlyph)
		{
			pCmdUI->Enable(TRUE);
		}
		else
		{
			pCmdUI->Enable(FALSE);
		}
	}
	else
	{
		pCmdUI->Enable(FALSE);
	}
	
	if(m_pSelectBar->GetAppearance(m_nSelectIndex)==cAppearanceImageText)
	{
		pCmdUI->SetCheck(TRUE);
	}
	else
	{
		pCmdUI->SetCheck(FALSE);
	}
}

afx_msg void CToolCustomizer::OnUpdateButtonGroupStart(CCmdUI *pCmdUI)
{
	// can begin group on all but first item
	if(     ((m_pSelectBar!=NULL &&
		  m_pSelectBar->IsInDialog()) ||
		  m_nSelectIndex==0))
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);

		// now work out whether we're already starting a group
		ASSERT(m_nSelectIndex>0);

		UINT nStyle=m_pSelectBar->GetButtonStyle(m_nSelectIndex-1);

		if(nStyle & TBBS_SEPARATOR)
		{
			pCmdUI->SetCheck(TRUE);
		}
		else
		{
			pCmdUI->SetCheck(FALSE);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// CToolBarProxy::GetBarProxy
CToolBarProxy* CToolBarProxy::GetBarProxy(CObject* pBar)
{
	// FUTURE: Add CRuntimeClass pointers and conversion function
	// points to a list, and then this routine will just walk the list.

	if (pBar->IsKindOf(RUNTIME_CLASS(CCustomBar)))
		return static_cast<CCustomBar*>(pBar)->GetProxy();
	else if (pBar->IsKindOf(RUNTIME_CLASS(CBMenuPopup)))
		return static_cast<CBMenuPopup*>(pBar)->GetProxy();
	else
		return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\prxycust.h ===
#ifndef _prxycust_h
#define _prxycust_h

///////////////////////////////////////////////////////////////////////////////
//      CToolCustomizer
class CToolCustomizer : public CCmdTarget
{
public:
	CToolCustomizer(CDockManager* m_pManager, CDlgTab* pDlg,
		const CObArray& aBars, BOOL bTemp = FALSE, BOOL bUndo = FALSE);
	~CToolCustomizer();
	
	void SetSelection(CToolBarProxy* pBar, int nIndex);
	BOOL DeleteSelection(BOOL bDeferRemove=FALSE);
	void DrawSelection(CDC* pDC);

	// This specifies what kind of button is being moved with DoButtonMove
	enum MOVETYPE
	{
		cBar=0,
		cCommand=1
	};
	// This function is now able to deal with dragging from the 'all commands' or 'menus' list,
	// where there is no source bar. To signal this kind of move, pass pBar==NULL, nIndex ignored, 
	// and the appropriate MOVETYPE code and nCommand the command id (or menu index) to be placed 
	// on the toolbar. martynl 23Apr96
	// This function now returns false if nothing was move, and whether a delete is pending in bDeletePending
	BOOL DoButtonMove(CPoint pt, CToolBarProxy* pBar, int nIndex, BOOL *bDeletePending, MOVETYPE mtType=cBar, int nCommand=0);
	BOOL TrackButtonMove(CPoint &pt, BOOL& bCopy, CToolBarProxy **ppBar, int *nIndex, ORIENTATION *or, UINT *pnHTSize, int nCmdIDSrc);
	void DoButtonSize(CPoint pt, CToolBarProxy* pBar, int nIndex);
	BOOL TrackButtonSize(CPoint pt, CRect& rectFinal);
	// creates a TRANSFER_TBUTTON appropriate for inserting a separator.
	static TRANSFER_TBBUTTON *CreateSeparatorTransfer(void);
	// displays the button customisation menu
	BOOL DisplayButtonMenu(UINT nFlags, CPoint point);
	static POPDESC *GetButtonMenu(void);

protected:
	void DrawTrackRect(CDC* pdc, const CRect* prect1,
		const CRect* prect2 = NULL);
	// for a given point, this determines which bar, and after which button, the insertion would occur.
	// If the insertion would be before the first button, then *nIndex is -1 after the call. If previous
	// is non null, then it will be filled with the rect of the preceding button, or of the first button
	// if nIndex is -1.
	// If pBarDest is NULL, the button was dropped in empty space (nIndex==0) or on the parent dialog (nIndex==-1)
	// It also returns the correct orientation to be used when expanding the bar, and the ht code
	void GetDropButton(CPoint pt, CToolBarProxy **ppBar, int *nIndex, CRect *previous, ORIENTATION *or, UINT *pnHTSize);
	// draws the insertion point cursor on a bar
	void DrawDragFeedback(CDC *pDC, const CRect &rect, ORIENTATION or, BOOL bBefore);

	// implementation helpers
	// creates a TRANSFER_TBUTTON appropriate for moving the given command id from nowhere. Puts
	// up the choose button dialogue
	TRANSFER_TBBUTTON *CreateCommandTransfer(int nCommand, CToolBarProxy *pBarDest);

public:
	BOOL m_bTemp:1;
	BOOL m_bUndo:1;
	CDockManager* m_pManager;
	CDlgTab* m_pDialog;
	CToolBarProxy* m_pSelectBar;
	int m_nSelectIndex;

    //{{AFX_MSG(CToolCustomizer)
	afx_msg void OnButtonCopyImage();
	afx_msg void OnButtonPasteImage();
	afx_msg void OnButtonResetImage();
	afx_msg void OnButtonChooseAppearance();
	afx_msg void OnButtonReset();
	afx_msg void OnButtonDelete();
	afx_msg void OnButtonImageOnly();
	afx_msg void OnButtonTextOnly();
	afx_msg void OnButtonImageText();
	afx_msg void OnButtonGroupStart();
	afx_msg void OnUpdateButtonCopyImage(CCmdUI *);
	afx_msg void OnUpdateButtonPasteImage(CCmdUI *);
	afx_msg void OnUpdateButtonResetImage(CCmdUI *);
	afx_msg void OnUpdateButtonChooseAppearance(CCmdUI *);
	afx_msg void OnUpdateButtonReset(CCmdUI *);
	afx_msg void OnUpdateButtonDelete(CCmdUI *);
	afx_msg void OnUpdateButtonImageOnly(CCmdUI *);
	afx_msg void OnUpdateButtonTextOnly(CCmdUI *);
	afx_msg void OnUpdateButtonImageText(CCmdUI *);
	afx_msg void OnUpdateButtonGroupStart(CCmdUI *);
	//}}AFX_MSG
    
    DECLARE_MESSAGE_MAP()

protected:
	const CObArray& m_aBars;
};

extern UINT DSM_COMMANDREMOVED;
// This message will be sent to the dialog whenever a command is deleted from a bar or menu
// during toolbar customisation
// WPARAM: nCmd - index of newly removed command
// LPARAM: must be 0 (reserved)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\re_mi.cpp ===
/*  re_mi.c - machine independent regular expression compiler
 *  cl /c /Zep /AM /NT RE /Gs /G2 /Oa /D LINT_ARGS /Fc re_mi.c
 *
 *  Modifications:
 *	09-Mar-1988 mz	Add check in fREMtch for pat == NULL
 *	15-Sep-1988 bw	Change fREMatch to REMatch.  New parameters and
 *			return type.
 *	23-Nov-1989 bp	Use relative adresses: OFST and PNTR macros
 *	05-Feb-1991 mz	Merge in KANJI changes
 *
 */

#include "stdafx.h"
#include <tchar.h>

#include "util.h"

#include <ctype.h>
#include <malloc.h>
#include <string.h>

#include "remi.h"
#include "re.h"
#include "msgboxes.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

typedef unsigned short int			DBCS;
typedef UNALIGNED RE_OPCODE * UNALIGNED *		PPREOP;
typedef unsigned char * UNALIGNED *	PPUCH;
typedef UNALIGNED unsigned *		PU;
typedef UNALIGNED unsigned short *	PUS;
typedef UNALIGNED DBCS *			PDBCS;
typedef const char *		PCC;

unsigned char *MovePBackwards (unsigned char *bos, unsigned char *P);


/*
	class CRegExStack -- this class exists simply to handle the stack
	allocation management for the RESearch fn below, which had a one-
	time leak
*/

class CRegExStack
{
protected:
	RE_OPCODE **m_stack; // Allocation for RE stack
	int maxREStack; // stack size

	void AllocateStack(void);
public:
	CRegExStack(void);
	~CRegExStack(void);
	void GrowStack(void);
	RE_OPCODE **GetData(void) { return m_stack; }
	int GetMax(void) { return maxREStack; }
};

void CRegExStack::AllocateStack(void)
{
	ASSERT(!m_stack); // cleared under _DEBUG
	m_stack = static_cast<RE_OPCODE **>(malloc(maxREStack * sizeof(*m_stack))); // presently 1024 total
}

void CRegExStack::GrowStack(void)
{
	ASSERT(m_stack);
	free(m_stack);
#ifdef _DEBUG
	m_stack = 0;
#endif
	maxREStack += 256;
	AllocateStack();
}

CRegExStack::CRegExStack(void)
{
	maxREStack = 256;
#ifdef _DEBUG
	m_stack = 0;
#endif
	AllocateStack();
}

CRegExStack::~CRegExStack(void)
{
	ASSERT(m_stack);
	free(m_stack);
}

BOOL RESearch(
	LPCTSTR line,
	ULONG *ichStart,	// byte index into line
	ULONG *xEnd,
	patType *pat,
	LPCTSTR szString,	// pointer to reg expression
	/* out */ BOOL *pbLineMatch)
{
//	static int maxREStack = 256;
	BOOL done;
//	static RE_OPCODE **stack = NULL; //Allocation for RE stack
	static CRegExStack theStack;
	flagType f = '\1' ;
	ULONG		cbSrchLine;

	//Allocates the stack for the regular expression
//	if (stack == NULL)
//		stack = (RE_OPCODE **)malloc(maxREStack * sizeof(*stack));

	//We may redo it if we need more stack
	do {

		done = TRUE;

		//Do not search if start is out of string
		cbSrchLine = (ULONG)_ftcslen(line);
		if(*ichStart > cbSrchLine) // DevStd #295: can be equal in case of empty line
			break;

		//Try the match
		switch (REMatch(pat, line, line + *ichStart, theStack.GetData(), theStack.GetMax(), f, pbLineMatch))
		{

			case REM_MATCH: {
				int len = RELength(pat, 0);
				if (len >= 0) {

					int newichStart = (REStart (pat) - line);

					// Returning a byte index into the document line
					*ichStart = newichStart;
					*xEnd = newichStart + len;

					return TRUE;
				}
				//else {
				//   if (len == 0) {
				//      *xEnd = *ichStart + 1;
				//      VERIFY(LocalFree((HANDLE)stack) == NULL);
				//      return TRUE;
				//   }
				//}
				break;
			}

			case REM_NOMATCH:
				break;

			case REM_STKOVR:

				//The RE engine had a stack overflow. Add 256 bytes
				//and try again

				theStack.GrowStack();

				done = FALSE;
				break;

			case REM_INVALID:
//				ErrorBox(IDS_REGEXPR_INVALID, szString);
//				frMem.hadError = TRUE;
				break;

			case REM_UNDEF:
//				ErrorBox(IDS_REGEXPR_UNDEF, szString);
//				frMem.hadError = TRUE;
				break;

			default:
				break;

		}

	} while (!done);

	return FALSE;
}

/*  The following are dependent on the low-level representation of the compiled
 *  machine.  The cases that have been implemented are:
 *
 *  Simple interpreted machine
 */

/* pseudo-instruction definitions */

#define I_CALL	    0
#define I_RETURN    1
#define I_LETTER    2
#define I_ANY	    3
#define I_EOL	    4
#define I_BOL	    5
#define I_CCL	    6
#define I_NCCL	    7
#define I_MATCH     8
#define I_JMP	    9
#define I_SPTOM     10
#define I_PTOM	    11
#define I_MTOP	    12
#define I_MTOSP     13
#define I_FAIL	    14
#define I_PUSHP     15
#define I_PUSHM     16
#define I_POPP	    17
#define I_POPM	    18
#define I_PNEQM     19
#define I_ITOM	    20
#define I_PREV	    21

/* instruction templates and lengths */

//#if defined(KANJI)
#define LLETTER     3
//#else
//#define LLETTER     2
//#endif
#define LANY	    1
#define LBOL	    1
#define LEOL	    1

/* address part of instruction */

#define ADDR(ip)    (*(PPREOP)(ip+sizeof(RE_OPCODE)))

/* conversion macros for adresses */

#define OFST(p)     ((RE_OPCODE *) (((char *) p) - ((char *) pat)))
#define PNTR(p)     ((RE_OPCODE *) (((char *) pat) + ((unsigned) p)))

#define IMM(ip)     (*(PPREOP)(ip+sizeof(RE_OPCODE)+sizeof(RE_OPCODE *)))

//#if defined(KANJI)
#define LRANGE	    (sizeof(RE_OPCODE)+sizeof(RE_OPCODE)+sizeof(RE_OPCODE)+sizeof(RE_OPCODE))
//#define LCCL	    (sizeof(RE_OPCODE))
//#define LNCCL	    (sizeof(RE_OPCODE))
//#else
#define LCCL	    (sizeof(RE_OPCODE)+(256/8))
#define LNCCL	    (sizeof(RE_OPCODE)+(256/8))
//#endif

#define LOFFSET     sizeof(RE_OPCODE *)
#define LCALL	    (sizeof(RE_OPCODE)+LOFFSET)
#define LJMP	    (sizeof(RE_OPCODE)+LOFFSET)
#define LSPTOM	    (sizeof(RE_OPCODE)+LOFFSET)
#define LPTOM	    (sizeof(RE_OPCODE)+LOFFSET)
#define LMTOP	    (sizeof(RE_OPCODE)+LOFFSET)
#define LMTOSP	    (sizeof(RE_OPCODE)+LOFFSET)
#define LRETURN     sizeof(RE_OPCODE)
#define LMATCH	    sizeof(RE_OPCODE)
#define LFAIL	    sizeof(RE_OPCODE)
#define LPUSHM	    (sizeof(RE_OPCODE)+LOFFSET)
#define LPOPM	    (sizeof(RE_OPCODE)+LOFFSET)
#define LPUSHP	    sizeof(RE_OPCODE)
#define LPOPP	    sizeof(RE_OPCODE)
#define LPNEQM	    (sizeof(RE_OPCODE)+LOFFSET)
#define LITOM	    (sizeof(RE_OPCODE)+LOFFSET+LOFFSET)
#define LPREV	    (sizeof(RE_OPCODE)+sizeof(RE_OPCODE))

/* action templates */

typedef struct {
	 RE_OPCODE	i1[LCALL];		/*	CALL	pattern 	  */
	 RE_OPCODE	i2[LFAIL];		/*	FAIL			      */
	 } T_PROLOG; 				/* pattern:			      */

typedef struct {
	 RE_OPCODE	i1[LPTOM];		/*	PTOM	ArgBeg[cArg]	*/
	 RE_OPCODE	i2[LCALL];		/*	CALL	x				*/
	 RE_OPCODE	i3[LITOM];		/*	ITOM	ArgBeg[cArg],-1 */
	 RE_OPCODE	i4[LRETURN];	/*	RETURN			      	*/
	 } T_LEFTARG;				/* x:				      	*/

typedef struct {
	 RE_OPCODE	i1[LPTOM];		/*	PTOM	ArgEnd[cArg]	*/
	 } T_RIGHTARG;

typedef struct {
	 RE_OPCODE	i1[LPUSHM];		/*	PUSHM	tmp		      */
	 RE_OPCODE	i2[LCALL];		/*	CALL	l1		      */
	 RE_OPCODE	i3[LPOPM];		/*	POPM	tmp		      */
	 RE_OPCODE	i4[LRETURN];	/*	RETURN			      */
	 RE_OPCODE	tmp[LOFFSET];	/* tmp	DW			      */
	 RE_OPCODE	i6[LPUSHP];		/* l1:	PUSHP			  */
	 RE_OPCODE	i7[LCALL];		/*	CALL	y		      */
	 RE_OPCODE	i8[LPOPP];		/*	POPP			      */
	 RE_OPCODE	i9[LPTOM];		/*	PTOM	tmp		      */
	 } T_SMSTAR; 				/* x:	...			      */

typedef struct {
	 RE_OPCODE	i1[LPNEQM];		/*	PNEQM	tmp				*/
	 RE_OPCODE	i2[LJMP];		/*	JMP	l1					*/
	 } T_SMSTAR1;				/* y:	...					*/

typedef struct {
	 RE_OPCODE	i1[LPUSHM];		/* l1:	PUSHM	tmp		  */
	 RE_OPCODE	i2[LPTOM];		/*	PTOM	tmp		      */
	 RE_OPCODE	i3[LPUSHP];		/*	PUSHP			      */
	 RE_OPCODE	i4[LCALL];		/*	CALL	x		      */
	 RE_OPCODE	i5[LPOPP];		/*	POPP			      */
	 RE_OPCODE	i6[LPOPM];		/*	POPM	tmp		      */
	 RE_OPCODE	i7[LJMP];		/*	JMP	y		      	  */
	 RE_OPCODE	tmp[LOFFSET];	/* tmp	DW			      */
	 } T_STAR;					/* x:	...			      */

typedef struct {
	 RE_OPCODE	i1[LPNEQM];		/*	PNEQM	tmp		      */
	 RE_OPCODE	i2[LPTOM];		/*	PTOM	tmp		      */
	 RE_OPCODE	i3[LJMP];		/*	JMP	l1		      	  */
	 } T_STAR1;					/* y:	...			      */

typedef struct {
	 RE_OPCODE	i1[LANY];		/*	ANY			      */
	 } T_ANY;

typedef struct {
	 RE_OPCODE	i1[LBOL];		/*	BOL			      */
	 } T_BOL;

typedef struct {
	 RE_OPCODE	i1[LEOL];		/*	EOL			      */
	 } T_EOL;

typedef struct {
	 RE_OPCODE	i1[LSPTOM];		/*	SPTOM	tmp		      */
	 RE_OPCODE	i2[LPTOM];		/*	PTOM	tmp1		  */
	 RE_OPCODE	i3[LCALL];		/*	CALL	x		      */
	 RE_OPCODE	i4[LMTOP];		/*	MTOP	tmp1		  */
	 RE_OPCODE	i5[LJMP];		/*	JMP	y		          */
	 RE_OPCODE	tmp[LOFFSET];	/* tmp	DW			      */
	 RE_OPCODE	tmp1[LOFFSET];	/* tmp1 DW			      */
	 } T_NOTSIGN;				/* x:	...			      */

typedef struct {
	 RE_OPCODE	i1[LMTOSP];		/*	MTOSP	tmp		      */
	 RE_OPCODE	i2[LMTOP];		/*	MTOP	tmp1		  */
	 RE_OPCODE	i3[LRETURN];	/*	RETURN			      */
	 } T_NOTSIGN1;				/* y:	...			      */

typedef struct {
	 RE_OPCODE	i1[LLETTER];	/*	LETTER	c		      */
	 } T_LETTER;

typedef struct {
	 RE_OPCODE	i1[LPUSHP];		/* ln:	PUSHP			  */
	 RE_OPCODE	i2[LCALL];		/*	CALL	cn		      */
	 RE_OPCODE	i3[LPOPP];		/*	POPP			      */
	 RE_OPCODE	i4[LJMP];		/*	JMP	ln+1		      */
	 } T_LEFTOR; 				/* cn:	...			      */

typedef struct {
	 RE_OPCODE	i1[LJMP];		/*	JMP	y		      */
	 } T_ORSIGN;

typedef struct {
	 RE_OPCODE	i1[LRETURN];	/* cn+1:RETURN			  */
	 } T_RIGHTOR;				/* y:	...			      */

typedef struct {
	 RE_OPCODE	i1[LCCL];		/*	CCL <bits>		      */
	 } T_CCL;

typedef struct {
	 RE_OPCODE	i1[LMATCH];		/*	MATCH			      */
	 } T_EPILOG;

typedef struct {
	 RE_OPCODE	i1[LPREV];		/*	PREV	n		      */
	 } T_PREV;

//#if defined(KANJI)
typedef struct {
	 RE_OPCODE	i1[LRANGE];		/*	x1:x2 - y1:y2		  */
	 } T_RANGE;
//#endif

typedef union {
	 T_PROLOG	U_PROLOG;
	 T_LEFTARG	U_LEFTARG;
	 T_RIGHTARG	U_RIGHTARG;
	 T_SMSTAR	U_SMSTAR;
	 T_SMSTAR1	U_SMSTAR1;
	 T_STAR		U_STAR;
	 T_STAR1	U_STAR1;
	 T_ANY		U_ANY;
	 T_BOL		U_BOL;
	 T_EOL		U_EOL;
	 T_NOTSIGN	U_NOTSIGN;
	 T_NOTSIGN1	U_NOTSIGN1;
	 T_LETTER	U_LETTER;
	 T_LEFTOR	U_LEFTOR;
	 T_ORSIGN	U_ORSIGN;
	 T_RIGHTOR	U_RIGHTOR;
	 T_CCL		U_CCL;
	 T_EPILOG	U_EPILOG;
	 T_PREV		U_PREV;
//#if defined(KANJI)
	 T_RANGE	U_RANGE;
//#endif
	 } re_template ;

/* size of each compiled action */

const int cbIns[] =  {
/* PROLOG      0    */	sizeof (T_PROLOG      ),
/* LEFTARG     1    */	sizeof (T_LEFTARG     ),
/* RIGHTARG    2    */	sizeof (T_RIGHTARG    ),
/* SMSTAR      3    */	sizeof (T_SMSTAR      ),
/* SMSTAR1     4    */	sizeof (T_SMSTAR1     ),
/* STAR        5    */	sizeof (T_STAR	      ),
/* STAR1       6    */	sizeof (T_STAR1       ),
/* ANY	       7    */	sizeof (T_ANY	      ),
/* BOL	       8    */	sizeof (T_BOL	      ),
/* EOL	       9    */	sizeof (T_EOL	      ),
/* NOTSIGN     10   */	sizeof (T_NOTSIGN     ),
/* NOTSIGN1    11   */	sizeof (T_NOTSIGN1    ),
/* LETTER      12   */	sizeof (T_LETTER      ),
/* LEFTOR      13   */	sizeof (T_LEFTOR      ),
/* ORSIGN      14   */	sizeof (T_ORSIGN      ),
/* RIGHTOR     15   */	sizeof (T_RIGHTOR     ),
/* CCLBEG      16   */	sizeof (T_CCL	      ),
/* CCLNOT      17   */	sizeof (T_CCL	      ),
/* RANGE       18   */	0,
/* EPILOG      19   */	sizeof (T_EPILOG      ),
/* PREV        20   */	sizeof (T_PREV	      ),
//#if defined(KANJI)
/* RANGEJ1     21   */	sizeof (T_RANGE       ),
/* RANGEJ2     22   */	0,
//#endif
			0
			};

#if DEBUG
#if 0
static CString g_strBuf;
#define DEBOUT(x) { g_strBuf.Format x; AfxOutputDebugString(g_strBuf); } // gross, but under debug & works
#else
#define DEBOUT(x)
#endif
#else
#define DEBOUT(x)
#endif



//#if defined (KANJI)
/* MovePBackwards - Move P backwards
 *
 *
 */
unsigned char *MovePBackwards (unsigned char *bos, unsigned char *P)
{
	unsigned char *P1, *P2;

	P1 = P2 = bos;
	while (P1 < P) {
		P2 = P1;
		if (isleadbyte(*P1) )
			P1++;
		P1++;
	}

	return P2;
}

//#endif


/*  REMatch - enumerate all matches of a pattern onto a string
 *
 *	pat	compiled pattern (gotten from RECompile)
 *	bos	pointer to beginning of string to scan
 *	str	pointer to into bos of place to begin scan
 *	fFor	direction to move on unsuccessful compares (for <msearch> in Z)
 *
 *  REMatch returns 0 if a match was found.  Otherwise it returns a non-zero
 *  error code.
 *
 *  REMatch interprets the compiled patching machine in the pattern.
 */
int REMatch (struct patType *pat, LPCTSTR bos, LPCTSTR str, RE_OPCODE *Stack[],
						 unsigned MaxREStack, flagType fFor, /* out */ BOOL *pbLineMatch)
{
	char cLoc ;
	PPREOP	SP;					/* top of stack 		             */
	register RE_OPCODE *IP;		/* current instruction to execute    */
	register unsigned char *P;	/* pointer to next char to match     */
	RE_OPCODE	  C;
//#if defined(KANJI)
	unsigned short U;
	int fMatched;
//#endif
	int i, n;
	PPREOP StackEnd = (PPREOP) & Stack[MaxREStack-sizeof(Stack[0])];
	typedef int __cdecl fnCompType (const char *, const char *, size_t);
	fnCompType *pfncomp;

/*	for performance reasons, we cache theApp.m_fOEM_MBCS on the frame, since otherwise we pay a
    hit both in locality and in TLS overhead; however, note that this can't be static since
	theApp.m_fOEM_MBCS is set in the ctor for theApp! */
	BOOL bIsMBCS = theApp.m_fOEM_MBCS; // cache this on the stack instead of going through TLS hell repeatedly


	if ( pat == NULL)
		return REM_INVALID;

	if (pbLineMatch)
		*pbLineMatch = FALSE; // we'll assume false unless we find otherwise

	pfncomp = pat->fCase ? _tcsncmp : _tcsnicmp;

	/* initialize the machine */
	memset ((void *) pat->pArgBeg,cLoc = (char)(-1),(unsigned int) sizeof (pat->pArgBeg));
	P = (unsigned char *)str;
	pat->pArgBeg[0] = (char *)P;

	/* begin this instance of the machine */
	SP = (PPREOP) &Stack[-1];
	IP = pat->code;

	while (TRUE) {
		DEBOUT (("%04x/%04x/%04x ", IP, SP-&Stack[0], P));
		/* execute instruction */
		switch (*IP) {
			/* call a subroutine */
			case I_CALL:
				if (SP >= StackEnd)
					return REM_STKOVR;
				*++SP = IP + LCALL;
				IP = PNTR (ADDR (IP));
				DEBOUT (("CALL %04x\n", IP));
				break;

			/* return from a subroutine */
			case I_RETURN:
				DEBOUT (("RETURN\n"));
				IP = *SP--;
				break;

			/* match a character, fail if no match */
			case I_LETTER:
				if (bIsMBCS && isleadbyte(*P)) {
					// [olympus 2332 : kherold] Pay attention to case-sensitivity!
					if ((!pat->fCase && !_tcsnicmp((PCC)P, (PCC)(IP + 1), 2)) ||
							(pat->fCase && (*(PDBCS)P == *(PDBCS)(IP+1))))
					{
						 IP += LLETTER;
					}
					else
						 IP = *SP--;
					P += 2;
				}
				else {
					C = pat->fCase ? *P++ : XLTab[*P++];
					DEBOUT (("LETTER %c\n", IP[1]));
					if (C == IP[1])
						IP += LLETTER;
					else
						IP = *SP--;
				}
				break;

			/* match any character, fail if no match */
			case I_ANY:
				DEBOUT (("ANY\n"));
				if (bIsMBCS) {
					if (*P != '\0') {
						if (isleadbyte(*P))
							P++;
						IP += LANY;
					}
					else
						IP = *SP--;
				 	P++;
				}
				else {
					if (*P++ != '\0')
						IP += LANY;
					else
						IP = *SP--;
				}
				break;

			/* match end of line, fail if no match */
			case I_EOL:
				DEBOUT (("EOL\n"));
				if (*P == '\0')
				{
					IP += LEOL;
					if (pbLineMatch)
						*pbLineMatch = TRUE;
				}
				else
					IP = *SP--;
				break;

			/* match beginning of line, fail if no match */
			case I_BOL:
				DEBOUT (("BOL\n"));
				if (P == (unsigned char *)bos)
				{
					IP += LBOL;
					if (pbLineMatch)
						*pbLineMatch = TRUE;
				}
				else
					IP = *SP--;
				break;

			/* handle character class, fail if no match */
			case I_CCL:
				if (bIsMBCS) {
					IP += LCCL;
					fMatched = FALSE;
					U = pat->fCase ? *P++ : (unsigned char)XLTab[*P++];
					if (isleadbyte(U))
						U = (U << 8) + *P++;
					if (U == '\0') {
						IP = *SP--;
						break;
					}
#define USIP	((PUS)IP)
#define CLOW	(USIP[0])
#define CHIGH	(USIP[1])
					while (CLOW != 0) {
						fMatched |= (CLOW <= U) && (U <= CHIGH);
						IP += LRANGE;
					}
					IP += LRANGE;
#undef USIP
#undef CLOW
#undef CHIGH
					if (!fMatched)
						IP = *SP--;
				}
				else {
					C = pat->fCase ? *P++ : XLTab[*P++];
					DEBOUT (("CCL '%c', %d\n", C, C));
					if (C != '\0' && (IP[1 + (C >> 3)] & (1 << (C & 7))) != 0)
						IP += LCCL;
					else
						IP = *SP--;
				}
				break;

			/* handle not character class, fail if match */
			case I_NCCL:
				if (bIsMBCS) {
					IP += LCCL;
					fMatched = FALSE;
					U = pat->fCase ? *P++ : (unsigned char)XLTab[*P++];
					if (isleadbyte(U))
						U = (U << 8) + *P++;
					if (U == '\0') {
						IP = *SP--;
						break;
					}
#define USIP	((PUS)IP)
#define CLOW	(USIP[0])
#define CHIGH	(USIP[1])
					while (CLOW != 0) {
						fMatched |= (CLOW <= U) && (U <= CHIGH);
						IP += LRANGE;
					}
					IP += LRANGE;
#undef USIP
#undef CLOW
#undef CHIGH
					if (fMatched)
						IP = *SP--;
				}
				else {
					DEBOUT (("NCCL %c\n", C));
					C = pat->fCase ? *P++ : XLTab[*P++];
					if (C != '\0' && (IP[1 + (C >> 3)] & (1 << (C & 7))) == 0)
						IP += LNCCL;
					else
						IP = *SP--;
				}
				break;

			/* signal a match */
			case I_MATCH:
				DEBOUT (("MATCH\n"));
				pat->pArgEnd[0] = (char *)P;
				return REM_MATCH;

			/* jump to an instruction */
			case I_JMP:
				IP = PNTR (ADDR (IP));
				DEBOUT (("JMP %04x\n", IP));
				break;

			/* save the character pointer in a memory location */
			case I_PTOM:
				DEBOUT (("PTOM %04x\n", PNTR (ADDR(IP))));
				* ((PPUCH) PNTR (ADDR (IP))) = P;
				IP += LPTOM;
				break;

			/* restore the character pointer from a memory location */
			case I_MTOP:
				DEBOUT (("MTOP %04x\n", PNTR (ADDR(IP))));
				P = * ((PPUCH) PNTR (ADDR (IP)));
				IP += LMTOP;
				break;

			/* save the stack pointer in a memory location */
			case I_SPTOM:
				DEBOUT (("SPTOM %04x\n", PNTR (ADDR(IP))));
				* ((PPREOP*) PNTR (ADDR (IP))) = SP;
				IP += LSPTOM;
				break;

			/* restore the stack pointer from a memory location */
			case I_MTOSP:
				DEBOUT (("MTOSP %04x\n", PNTR (ADDR (IP))));
				SP = * ((PPREOP*) PNTR (ADDR (IP)));
				IP += LMTOSP;
				break;

			/* push the char pointer */
			case I_PUSHP:
				DEBOUT (("PUSHP\n"));
				if (SP >= StackEnd)
					return REM_STKOVR;
				*++SP = (RE_OPCODE *) P;
				IP++;
				break;

			/* pop the char pointer */
			case I_POPP:
				DEBOUT (("POPP\n"));
				P = (unsigned char *) (*SP--);
				IP ++;
				break;

			/* push memory */
			case I_PUSHM:
				DEBOUT (("PUSHM %04x\n", PNTR (ADDR (IP))));
				if (SP >= StackEnd)
					return REM_STKOVR;
				*++SP = * ((PPREOP) PNTR (ADDR (IP)));
				IP += LPUSHM;
				break;

			/* pop memory */
			case I_POPM:
				DEBOUT (("POPM %04x\n", PNTR (ADDR (IP))));
				* ((PPREOP) PNTR (ADDR (IP))) = *SP--;
				IP += LPOPM;
				break;

			/* make sure that the char pointer P is != memory, fail if necessary */
			case I_PNEQM:
				DEBOUT (("PNEQM %04x\n", PNTR (ADDR (IP))));
				if (P != * ((PPUCH) PNTR (ADDR (IP))))
					IP += LPNEQM;
				else
					IP = *SP--;
				break;

			/* move an immediate value to memory */
			case I_ITOM:
				DEBOUT (("ITOM %04x,%04x\n", PNTR (ADDR (IP)), IMM(IP)));
				* ((PPREOP) PNTR (ADDR (IP))) = IMM (IP);
				IP += LITOM;
				break;

			/* indicate a fail on the total match */
			case I_FAIL:
				DEBOUT (("FAIL\n"));
				P = (unsigned char *)pat->pArgBeg[0];
				if (bIsMBCS) {
					if (fFor) {
						if (isleadbyte(*P))
					 		P++;
						if (*P++ == '\0')
					 		return REM_NOMATCH;
						else
					 		;
					}
					else
						if (P == (unsigned char *)bos)
							return REM_NOMATCH;
						else
							P = MovePBackwards ((unsigned char *)bos, (unsigned char *)P);
				}
				else {
					if (fFor)
						if (*P++ == '\0')
					 		return REM_NOMATCH;
						else
					 		;
				 	else
						if (P-- == (unsigned char *)bos)
							return REM_NOMATCH;
				}

				pat->pArgBeg[0] = (char *)P;
				SP = (PPREOP) &Stack[-1];
				IP = pat->code;
				break;

			/* perform a match with a previously matched item */
			case I_PREV:
				i = IP[1];
				n = pat->pArgEnd[i] - pat->pArgBeg[i];
				DEBOUT (("PREV %04x\n", i));
				if (pat->pArgBeg[i] == (char *) -1)
					IP = *SP--;
				else
					if ((*pfncomp) (pat->pArgBeg[i], (const char *)P, n))
						IP = *SP--;
					else {
						IP += LPREV;
						P += n;
					}
				break;
			default:
				return REM_UNDEF;

		 }
	}
}

void PASCAL INTERNAL REStackOverflow ()
{
//	MsgBox(InternalError, SYS_RegExpr_StackOverflow); TODO: Fix MsgBox
}

/*  CompileAction - drop in the compilation template at a particular node
 *  in the tree.  Continuation appropriate to a node occurs by relying on
 *  passed input and past input (yuk, yuk).
 *
 *  type	type of action being performed
 *  u		previous return value.	Typically points to a previous
 *		template that needs to be linked together.
 *  x		low byte of a range
 *  y		high range of a range.
 *
 *  Returns	variable depending on action required.
 *
 */
unsigned INTERNAL CompileAction (OPTYPE type, register unsigned int u, unsigned char x, unsigned char y, 
								 patType *pat)
{
	register re_template *t = (re_template *) pat->REip;
	unsigned u1, u2, u3;

/*	for performance reasons, we cache theApp.m_fOEM_MBCS on the frame, since otherwise we pay a
    hit both in locality and in TLS overhead; however, note that this can't be static since
	theApp.m_fOEM_MBCS is set in the ctor for theApp! */
	BOOL bIsMBCS = theApp.m_fOEM_MBCS;

	DEBOUT (("%04x CompileAction %04x\n", pat->REip, type));

	pat->REip += cbIns[type];

	switch (type) {

		case PROLOG:
#define ip  (&(t->U_PROLOG))
			ip->i1[0] = I_CALL;	ADDR(ip->i1) = OFST (pat->REip);
			ip->i2[0] = I_FAIL;
			return (unsigned) NULL;
#undef	ip
			break;

		case LEFTARG:
#define ip  (&(t->U_LEFTARG))
			ip->i1[0] = I_PTOM;
			ADDR(ip->i1) = OFST ((RE_OPCODE *) &(pat->pArgBeg[pat->REArg]));
			ip->i2[0] = I_CALL;		ADDR(ip->i2) = OFST (pat->REip);
			ip->i3[0] = I_ITOM;
			ADDR(ip->i3) = OFST ((RE_OPCODE *) &(pat->pArgBeg[pat->REArg]));
			IMM(ip->i3) = (RE_OPCODE *) -1;
			ip->i4[0] = I_RETURN;
			return (unsigned) (pat->REArg)++;
#undef	ip
			break;

		case RIGHTARG:
#define ip  (&(t->U_RIGHTARG))
			ip->i1[0] = I_PTOM;
			ADDR(ip->i1) = OFST ((RE_OPCODE *) &(pat->pArgEnd[u]));
			return (unsigned) NULL;
#undef	ip
			break;

		case SMSTAR:
#define ip  (&(t->U_SMSTAR))
			return (unsigned) ip;
#undef	ip
			break;

		case SMSTAR1:
#define ip  ((T_SMSTAR *)u)
#define ip2 (&(t->U_SMSTAR1))
			ip->i1[0] = I_PUSHM;	ADDR(ip->i1) = OFST (ip->tmp);
			ip->i2[0] = I_CALL;		ADDR(ip->i2) = OFST (ip->i6);
			ip->i3[0] = I_POPM;		ADDR(ip->i3) = OFST (ip->tmp);
			ip->i4[0] = I_RETURN;
			/* DW */
			ip->i6[0] = I_PUSHP;
			ip->i7[0] = I_CALL;		ADDR(ip->i7) = OFST (pat->REip);
			ip->i8[0] = I_POPP;
			ip->i9[0] = I_PTOM;		ADDR(ip->i9) = OFST (ip->tmp);

			ip2->i1[0] = I_PNEQM;	ADDR(ip2->i1) = OFST (ip->tmp);
			ip2->i2[0] = I_JMP;		ADDR(ip2->i2) = OFST (ip->i6);
			return (unsigned) NULL;
#undef	ip
#undef	ip2
			break;

		case STAR:
#define ip  (&(t->U_STAR))
			return (unsigned) ip;
#undef	ip
			break;

		case STAR1:
#define ip  ((T_STAR *)u)
#define ip2 (&(t->U_STAR1))
			ip->i1[0] = I_PUSHM;	ADDR(ip->i1) = OFST (ip->tmp);
			ip->i2[0] = I_PTOM;		ADDR(ip->i2) = OFST (ip->tmp);
			ip->i3[0] = I_PUSHP;
			ip->i4[0] = I_CALL;		ADDR(ip->i4) = OFST (((RE_OPCODE *)ip) + sizeof (*ip));
			ip->i5[0] = I_POPP;
			ip->i6[0] = I_POPM;		ADDR(ip->i6) = OFST (ip->tmp);
			ip->i7[0] = I_JMP;		ADDR(ip->i7) = OFST (pat->REip);

			ip2->i1[0] = I_PNEQM;	ADDR(ip2->i1) = OFST (ip->tmp);
			ip2->i2[0] = I_PTOM;	ADDR(ip2->i2) = OFST (ip->tmp);
			ip2->i3[0] = I_JMP;		ADDR(ip2->i3) = OFST (ip->i1);
			return (unsigned) NULL;
#undef	ip
#undef	ip2
			break;

		case ANY:
#define ip  (&(t->U_ANY))
			ip->i1[0] = I_ANY;
			return (unsigned) NULL;
#undef	ip
			break;

		case BOL:
#define ip  (&(t->U_BOL))
			ip->i1[0] = I_BOL;
			return (unsigned) NULL;
#undef	ip
			break;

		case EOL:
#define ip  (&(t->U_EOL))
			ip->i1[0] = I_EOL;
			return (unsigned) NULL;
#undef	ip
			break;

		case NOTSIGN:
#define ip  (&(t->U_NOTSIGN))
			return (unsigned) ip;
#undef	ip
			break;

		case NOTSIGN1:
#define ip  ((T_NOTSIGN *)u)
#define ip2 (&(t->U_NOTSIGN1))
			ip->i1[0] = I_SPTOM;	ADDR(ip->i1) = OFST (ip->tmp);
			ip->i2[0] = I_PTOM;		ADDR(ip->i2) = OFST (ip->tmp1);
			ip->i3[0] = I_CALL;		ADDR(ip->i3) = OFST (((RE_OPCODE *)ip) + sizeof (*ip));
			ip->i4[0] = I_MTOP;		ADDR(ip->i4) = OFST (ip->tmp1);
			ip->i5[0] = I_JMP;		ADDR(ip->i5) = OFST (pat->REip);

			ip2->i1[0] = I_MTOSP;	ADDR(ip2->i1) = OFST (ip->tmp);
			ip2->i2[0] = I_MTOP;	ADDR(ip2->i2) = OFST (ip->tmp1);
			ip2->i3[0] = I_RETURN;
			return (unsigned) NULL;
#undef	ip
#undef	ip2
			break;

		case LETTER:
#define ip  (&(t->U_LETTER))
			if (!pat->fCase)
				x = XLTab[x];
			ip->i1[0] = I_LETTER;	ip->i1[1] = (RE_OPCODE) x;
			if (bIsMBCS)
				ip->i1[2] = (RE_OPCODE) y;
			return (unsigned) NULL;
#undef	ip
			break;

		case LEFTOR:
#define ip  (&(t->U_LEFTOR))
			* (PU) ip = u;
			return (unsigned) ip;
#undef	ip
			break;

		case ORSIGN:
#define ip  (&(t->U_ORSIGN))
			* (PU) ip = u;
			return (unsigned) ip;
#undef	ip
			break;

		case RIGHTOR:
			u1 = u;
			u2 = (unsigned int) t;
			while (u1 != (unsigned) NULL) {
				u  = * (PU)u1;
				u3 = * (PU) u;
				/*	u   points to leftor
				 *	u1  points to orsign
				 *	u2  points to next leftor
				 *	u3  points to previous orsign
				 */
#define ip  (&(((re_template *)u)->U_LEFTOR))
				ip->i1[0] = I_PUSHP;
				ip->i2[0] = I_CALL;	ADDR (ip->i2) = OFST (((RE_OPCODE *)ip) + sizeof (*ip));
				ip->i3[0] = I_POPP;
				ip->i4[0] = I_JMP;	ADDR (ip->i4) = OFST ((RE_OPCODE *) u2);
#undef	ip
#define ip  (&(((re_template *)u1)->U_ORSIGN))
				ip->i1[0] = I_JMP;	ADDR (ip->i1) = OFST (pat->REip);
#undef	ip
				u2 = u;
				u1 = u3;
			}
#define ip  (&(t->U_RIGHTOR))
			ip->i1[0] = I_RETURN;
#undef	ip
			return (unsigned) NULL;
			break;

		case CCLBEG:
#define ip  (&(t->U_CCL))
			if (bIsMBCS) {
				ip->i1[0] = I_CCL;
				return (unsigned) NULL;
			}
			else {
				char cLoc ;
				memset ((void far *) ip->i1, cLoc = '\0',(unsigned int) sizeof (ip->i1));
				ip->i1[0] = I_CCL;
				return (unsigned) ip;
			}
#undef	ip
			break;


		case CCLNOT:
#define ip  (&(t->U_CCL))
			if (bIsMBCS) {
				ip->i1[0] = I_NCCL;
				return (unsigned) ip;
			}
			else {
				char cLoc ;
				memset ((void far *) ip->i1, cLoc = '\0',(unsigned int) sizeof (ip->i1));
				ip->i1[0] = I_NCCL;
				return (unsigned) ip;
			}
#undef	ip
			break;

		case RANGEJ1:
#define ip  (&(t->U_RANGE))
			ip->i1[0] = (pat->fCase || x) ? y : XLTab[y];
			ip->i1[1] = x;
			return (unsigned) ip;
#undef	ip
			break;

		case RANGEJ2:
#define ip  ((T_RANGE *)u)
			ip->i1[2] = (pat->fCase || x) ? y : XLTab[y];
			ip->i1[3] = x;
			return (unsigned) NULL;
#undef	ip
			break;

		case RANGE:
#define ip  ((T_CCL *)u)
			{
			unsigned int ch;

			for (ch = x; ch <= y; ch++) {
				 x = pat->fCase ? (unsigned char) ch : XLTab[ch];
				 ip->i1[1 + (x >> 3)] |= 1 << (x & 7);
				 }
			return (unsigned) NULL;
			}
#undef	ip
			break;


		case EPILOG:
#define ip  (&(t->U_EPILOG))
			ip->i1[0] = I_MATCH;
			return (unsigned) NULL;
#undef	ip
			break;

		case PREV:
#define ip (&(t->U_PREV))
			ip->i1[0] = I_PREV;
			ip->i1[1] = (RE_OPCODE) u;
			return (unsigned) NULL;
#undef ip

		default:
//			MsgBox(InternalError, SYS_RegExpr_CompileAction);  TODO: fix that [fabriced]
			return (unsigned) NULL;
	}
}

#if DEBUG
void INTERNAL REDump ( struct patType *p)
{
	RE_OPCODE *REip = p->code;
	DEBOUT(("=> Start REDump <=\n"));
	while (TRUE) {
		DEBOUT (("%04x ", REip));
		switch (*REip) {
			case I_CALL:
				DEBOUT (("CALL    %04x\n", ADDR(REip)));
				REip += LCALL;
				break;
			case I_RETURN:
				DEBOUT ( ("RETURN\n"));
				REip += LRETURN;
				break;
			case I_LETTER:
				DEBOUT ( ("LETTER  %c\n", REip[1]));
				REip += LLETTER;
				break;
			case I_ANY:
				DEBOUT ( ("ANY\n"));
				REip += LANY;
				break;
			case I_EOL:
				DEBOUT ( ("EOL\n"));
				REip += LEOL;
				break;
			case I_BOL:
				DEBOUT ( ("BOL\n"));
				REip += LBOL;
				break;
			case I_CCL:
				DEBOUT ( ("CCL\n"));
				REip += LCCL;
				break;
			case I_NCCL:
				DEBOUT ( ("NCCL\n"));
				REip += LNCCL;
				break;
			case I_MATCH:
				DEBOUT(("=> End REDump <=\n"));
				DEBOUT ( ("MATCH\n"));
				return;
				break;
			case I_JMP:
				DEBOUT ( ("JMP     %04x\n", ADDR(REip)));
				REip += LJMP;
				break;
			case I_SPTOM:
				DEBOUT ( ("SPTOM   %04x\n", ADDR(REip)));
				REip += LSPTOM;
				break;
			case I_PTOM:
				DEBOUT ( ("PTOM    %04x\n", ADDR(REip)));
				REip += LPTOM;
				break;
			case I_MTOP:
				DEBOUT ( ("MTOP    %04x\n", ADDR(REip)));
				REip += LMTOP;
				break;
			case I_MTOSP:
				DEBOUT ( ("MTOSP   %04x\n", ADDR(REip)));
				REip += LMTOSP;
				break;
			case I_FAIL:
				DEBOUT ( ("FAIL\n"));
				REip += LFAIL;
				break;
			case I_PUSHP:
				DEBOUT ( ("PUSHP\n"));
				REip += LPUSHP;
				break;
			case I_PUSHM:
				DEBOUT ( ("PUSHM   %04x\n", ADDR(REip)));
				REip += LPUSHM;
				break;
			case I_POPP:
				DEBOUT ( ("POPP\n"));
				REip += LPOPP;
				break;
			case I_POPM:
				DEBOUT ( ("POPM    %04x\n", ADDR(REip)));
				REip += LPOPM;
				break;
			case I_PNEQM:
				DEBOUT ( ("PNEQM   %04x\n", ADDR(REip)));
				REip += LPNEQM;
				break;
			case I_ITOM:
				DEBOUT ( ("ITOM    %04x,%04x\n", ADDR(REip), IMM(REip)));
				REip += LITOM;
				break;
			default:
				DEBOUT ( ("%04x ???\n", *REip));
				REip += LOFFSET;
				DEBOUT(("=> End REDump <=\n"));
				return;
		}
	}
}
#endif

/*  EstimateAction - sum up the number of bytes required by each individual
 *  parsing action in the tree.  Take the input action and add it up to the
 *  running total.
 *
 *  type	type of action being performed
 *  u		dummy parm
 *  x		dummy parm
 *  y		dummy parm
 *
 *  Returns	0 always
 *
 */
unsigned INTERNAL EstimateAction (OPTYPE type, unsigned int u, unsigned char x, unsigned char y, patType *pat)
{
	u; x; y;

//	DEBOUT (("%04x EstimateAction %04x\n", RESize, type));

//	if (type < ACTIONMIN || type > ACTIONMAX)
//		MsgBox(InternalError, SYS_RegExpr_EstimateAction);  TODO: Fix MsgBox
	pat->RESize += cbIns[type];
	return (unsigned) 0;
}

/*  REEstimate - estimates the number of bytes required to
 *  compile a specified pattern.
 *
 *  REEstimate returns the number of bytes required to compile
 *  a pattern.	If there is a syntax error in the pattern, the function
 *  returns FALSE.
 *
 *  p		character pointer to pattern that will be compiled
 */
BOOL REEstimate (char *p, int *pSize)
{
	patType pat;
	ASSERT(pSize != NULL);
	pat.RESize = sizeof (struct patType) - 1;
	pat.REArg = 1;

	EstimateAction (PROLOG, (unsigned int) 0, '\0', '\0', &pat);

	if (REParseRE (EstimateAction, p, NULL, &pat) == NULL || pat.REArg > MAXPATARG)
		return FALSE;
	else
		EstimateAction (EPILOG, (unsigned int) 0, '\0', '\0', &pat);
	*pSize = pat.RESize;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\sheet.cpp ===
#include "stdafx.h"

#include "util.h"
#include "imeutil.h"
#include "resource.h"
#include "ipcslob.h"

#include <prjapi.h>
#include <prjguid.h>

#include "ipcits.h"		// for IInternalTrackSelection

extern "C"
{
#include "string.h"
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern void PASCAL AfxCancelModes(HWND hWndRcvr);

extern UINT WM_SETAPPVALIDATE;
extern UINT WM_ISERROR;

/////////////////////////////////////////////////////////////////////////////
//	CSheetSlob

IMPLEMENT_DYNAMIC(CSheetSlob, CSlob)

CSheetSlob::CSheetSlob() : CSlob()
{
	m_pSheetWnd = NULL;

	theApp.m_theAppSlob.AddDependant(this);
}

CSheetSlob::~CSheetSlob()
{
	theApp.m_theAppSlob.RemoveDependant(this);
	g_PropSheet = NULL;

	NukeInforms();
}

void CSheetSlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
	if (idChange == SN_DESTROY)
	{
		CSlob::OnInform(pChangedSlob, idChange, dwHint);
		return;
	}

	CInformRecord* pIR = new CInformRecord(pChangedSlob, idChange);
	m_informList.AddTail(pIR);
}

void CSheetSlob::FlushInforms()
{
	ASSERT(m_pSheetWnd != NULL);

	while (!m_informList.IsEmpty())
	{
		CInformRecord* pIR = (CInformRecord*) m_informList.RemoveHead();

		if (m_pSheetWnd->m_pCurPage != NULL &&
			m_pSheetWnd->m_pCurPage->IsKindOf(RUNTIME_CLASS(CSlobPage)))
		{
			((CSlobPage*) m_pSheetWnd->m_pCurPage)->
				OnPropChange(pIR->m_idChange);
		}

		CSlob::OnInform(pIR->m_pChangedSlob, pIR->m_idChange, 0);
		delete pIR;
	}
}

void CSheetSlob::NukeInforms()
{
	ASSERT(m_pSheetWnd != NULL);

	while (!m_informList.IsEmpty())
		delete (CInformRecord*) m_informList.RemoveHead();
}

CInformRecord::CInformRecord(CSlob* pSlob, UINT idChange)
{
	ASSERT(idChange != SN_DESTROY);

	m_pChangedSlob = pSlob;
	m_idChange = idChange;
}

static UINT BASED_CODE propPageButtons [] = 
{
	ID_PROP_PUSHPIN,
	ID_HELP,
};

///////////////////////////////////////////////////////////////////////////////
//	CPropFrameToolBar

CPropFrameToolBar::CPropFrameToolBar()
	: CToolBar()
{
}

void CPropFrameToolBar::SetSizes()
{
	CToolBar::SetSizes(CSize(sizeButtonX, sizeButtonY),
	                   CSize(sizeImageX, sizeImageY));

	m_cxDefaultGap = 0;
	m_cyTopBorder = m_cyBottomBorder = 0;
	m_cxLeftBorder = 0;
	m_dwStyle = m_dwStyle & ~0x0F00;

	UINT nID, nStyle;
	int iImage;

	GetButtonInfo(0, nID, nStyle, iImage);
	SetButtonInfo(0, nID, TBBS_CHECKBOX, iImage);
}

void CPropFrameToolBar::SetPushPin(BOOL bPushed)
{
	if (bPushed == IsPinned())
		return;

	UINT nID, style;
	int iImage;
	GetButtonInfo(0, nID, style, iImage);

	if (bPushed)
	{
		theApp.m_theAppSlob.SetIntProp(P_PoppingProperties, FALSE);
		LoadBitmap(IDB_PPBAR_PINNED);
		style |= TBBS_CHECKED;
	}
	else
	{
		theApp.m_theAppSlob.SetIntProp(P_PoppingProperties, TRUE);
		LoadBitmap(IDB_PPBAR_UNPINNED);
		style &= ~TBBS_CHECKED;
	}

	ASSERT(bPushed == IsPinned());
	SetButtonInfo(0, nID, style, iImage);
	Invalidate(FALSE);
}

BOOL CPropFrameToolBar::IsPinned()
{
	BOOL bPopProp;
	theApp.m_theAppSlob.GetIntProp(P_PoppingProperties, bPopProp);

	return !bPopProp;
}

#ifdef _DEBUG
void CPropFrameToolBar::AssertValid() const
{
	// deliberate skipping of base class, because we changed the assumptions... 
	CWnd::AssertValid();

	ASSERT(m_nCount == 0 || m_pData != NULL);
}
#endif

/////////////////////////////////////////////////////////////////////////////
//	CSheetWnd

CObList CSheetWnd::s_listLoadedPages;
int CSheetWnd::s_cyBreakLine;

// CSheetWnd message map

BEGIN_MESSAGE_MAP(CSheetWnd, CMiniFrameWnd)
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_WM_SYSCOMMAND()
	ON_WM_ACTIVATE()
	ON_WM_SIZE()
	ON_WM_ENABLE()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_TIMER()
	ON_WM_MOUSEACTIVATE()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()

	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
		
	ON_COMMAND(IDMX_OKPAGE, CmdOkPage)
	ON_COMMAND(IDMX_CANCELPAGE, CmdCancelPage)
	ON_COMMAND(IDMX_NEXTPAGE, CmdNextPage)
	ON_COMMAND(IDMX_PREVPAGE, CmdPrevPage)

	ON_COMMAND(ID_PROP_PUSHPIN, OnCmdPushPin)
	ON_COMMAND(ID_HELP, OnCmdHelp)

	ON_CBN_SELCHANGE(IDC_COMBOBOX_LEVEL, OnSelChangeLevel)

	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xffff, OnToolTipText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xffff, OnToolTipText)
	ON_MESSAGE(WM_USER_VALIDATEREQ, OnValidateReq)
	ON_REGISTERED_MESSAGE(WM_ISERROR, OnIsError)
END_MESSAGE_MAP()

CSheetWnd::CSheetWnd() : CMiniFrameWnd(),
	m_noPage(), m_nullPage(), m_multiPage(),
	m_tabRow(), m_strDefaultPage(),
	m_sheetSlob(), m_toolBar()
{
	m_pCurPage = &m_noPage;
	m_iFocusSave = 0;
	m_bSheetChanged = FALSE;
	m_bValidating = FALSE;
	m_bValidateEnabled = TRUE;
	m_bInCancel = FALSE;
	m_pCurSlob = NULL;
	m_pNewSlob = NULL;
	m_selState = blank;
	m_newSelState = blank;
	m_nCurPage = 0;
	m_nNewPage = -1;

	m_sheetSlob.m_pSheetWnd = this;
	m_tabRow.SetParent(this);

	m_refInhibitExtraPages = 0;
	m_nFirstPageSet = 0;
	
	m_cyRowHeight = INITIAL_LEVELCOMBO_HEIGHT;
}

CSheetWnd::~CSheetWnd()
{
	// free up the OLE property page cache
	COlePage::Cleanup();
}

//	CSheetWnd::Create

BOOL CSheetWnd::Create()
{
	CPoint pos(xDefaultPos, yDefaultPos);
	CSize size(cxSize, cySize);
	pos.y -= 15;				// ACK!

	VERIFY(LoadAccelTable(MAKEINTRESOURCE(IDR_ACCEL_PROP)));

	DWORD dwStyle = WS_CAPTION | WS_SYSMENU | WS_POPUP | WS_DISABLED;

	if (!CMiniFrameWnd::Create(AfxRegisterWndClass(CS_VREDRAW | CS_HREDRAW,
			LoadCursor(NULL, IDC_ARROW),
			(HBRUSH)(COLOR_BTNFACE + 1)),
		NULL,
		dwStyle,
		CRect(pos.x, pos.y, pos.x + size.cx, pos.y + size.cy),
		theApp.m_pMainWnd,
		NULL))
	{
		return FALSE;
	}								

	EnableWindow(TRUE);

	// Hide the ID and ID caption fields on this prop page -- they are
	// here only because they must go _somewhere_ and this spot is as
	// good as any other.
	//
	CWnd* pWnd = m_nullPage.GetDlgItem(IDC_ID);
	ASSERT(pWnd != NULL);
	pWnd->ShowWindow(SW_HIDE);

	pWnd = m_nullPage.GetDlgItem(IDC_ID_CAP);
	ASSERT(pWnd != NULL);
	pWnd->ShowWindow(SW_HIDE);

	// Do this so the sheet wnd will be set to the right size so the
	// ini file position stuff can calculate a rectangle...
	VERIFY(m_nullPage.SetupPage(this, NULL));

	// Chicago may want to show a system menu for this window, so let's
	// make sure it looks consistent with the rest of our app.

	CMenu* pMenu = GetSystemMenu(FALSE);
	if (pMenu != NULL)
	{
		pMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);
		pMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
		pMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
	}

	return TRUE;
}

int CSheetWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// Create the toolbar for the pushpin and help button
	if (!m_toolBar.Create(this) ||
	    !m_toolBar.SetButtons(propPageButtons, sizeof(propPageButtons) / sizeof(UINT)))
	{
		TRACE("Failed to create toolbar\n");
		return -1;
	}

	m_toolBar.SetSizes();
	m_toolBar.m_dwStyle |= CBRS_TOOLTIPS | CBRS_FLYBY;
	m_toolBar.EnableToolTips(TRUE);
	m_toolBar.MoveWindow(cxWndMargin, 2, CPropFrameToolBar::sizeButtonX * 2, CPropFrameToolBar::sizeButtonY);

	// Flip popping properties so that setting the push pin will work.
	theApp.m_theAppSlob.SetIntProp(P_PoppingProperties, m_toolBar.IsPinned());
	m_toolBar.SetPushPin(! m_toolBar.IsPinned());

	// Figure out where to put the pages.
	CDC* pDC = GetDC();
	int cyRowHeight = m_tabRow.DesiredHeight(pDC);
	ReleaseDC(pDC);

	int cyButtonTop = 1;
	if(cyRowHeight <= 22)
		s_cyBreakLine = 22 + 3;
	else
	{
		cyButtonTop = 1 + (cyRowHeight - 22) / 2;
		s_cyBreakLine = cyRowHeight + 3;
	}

	// Preload the pages that do not have their own class...
	VERIFY(m_multiPage.Create(IDDP_MUL, this));
	VERIFY(m_nullPage.Create(IDDP_NUL, this));
 	VERIFY(m_noPage.Create(IDDP_NOPAGE, this));

	CPoint ptPos(cxWndMargin + cxPageMargin - GetSystemMetrics(SM_CYBORDER),
		s_cyBreakLine + cyPageMargin - GetSystemMetrics(SM_CYBORDER));
	m_multiPage.MovePage(CRect(ptPos, m_multiPage.GetPageSize()));
	m_nullPage.MovePage(CRect(ptPos, m_nullPage.GetPageSize()));
	m_noPage.MovePage(CRect(ptPos, m_noPage.GetPageSize()));

	BOOL	bRet;
	
	bRet = m_cbLevel.Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP | CBS_DROPDOWNLIST,// | WS_DISABLED,
		CRect(0, 0, 0, 0), this, IDC_COMBOBOX_LEVEL);

	ASSERT(bRet);
	m_cbLevel.SetFont(GetStdFont(font_Normal));

	return CMiniFrameWnd::OnCreate(lpCreateStruct);
}

void CSheetWnd::InitialUpdate(CPoint ptInitial)
{
	CRect rectWnd;
	GetWindowRect(rectWnd);

	int cxScreen = GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = GetSystemMetrics(SM_CYSCREEN);

	// Calculate the top-left coordinates from the initial anchor point.
	if (ptInitial.x >= cxScreen - ptInitial.x)
		ptInitial.x -= rectWnd.Width();
	if (ptInitial.y >= cyScreen - ptInitial.y)
		ptInitial.y -= rectWnd.Height();

	rectWnd.SetRect(ptInitial.x, ptInitial.y,
		ptInitial.x + rectWnd.Width(), ptInitial.y + rectWnd.Height());
	ForceRectOnScreen(rectWnd);

	SetWindowPos(NULL, rectWnd.left, rectWnd.top, 0, 0,
	             SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

	g_PropSheetVisible = m_toolBar.IsPinned();
}

BOOL CSheetWnd::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
		case WM_KEYDOWN:
			FlushInforms();
			switch (pMsg->wParam)
			{
			case VK_LEFT:
				if (GetFocus() == this)
				{
					CmdPrevPage();
					return TRUE;
				}
				break;

			case VK_RIGHT:
				if (GetFocus() == this)
				{
					CmdNextPage();
					return TRUE;
				}
				break;

			case VK_ESCAPE:
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage(WM_CLOSE);
					return TRUE;
				}
				break;

			case VK_F1:
				OnCmdHelp();
				return TRUE;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
			FlushInforms();
			break;

		case WM_SYSCOMMAND:
			// OLE property pages might forward on of these to us.
			if(pMsg->wParam == SC_KEYMENU)
			{
				SendMessage(WM_SYSCOMMAND, pMsg->wParam, pMsg->lParam);
				return TRUE;
			}
			break;
	}
	
	// If the sheet has the focus, or the current page doesn't have a window
	// then the page has not yet had a chance to PreTranslate this message.

	if (m_pCurPage != NULL &&
		(GetFocus() == this || m_pCurPage->m_hWnd == NULL) &&
		m_pCurPage->PreTranslateMessage(pMsg))
	{
		return TRUE;
	}

	if (CMiniFrameWnd::PreTranslateMessage(pMsg))
		return TRUE;

	return FALSE;
}

//	CSheetWnd::OnPaint

void CSheetWnd::OnPaint()
{
	CPaintDC dc(this);
	if (dc.m_hDC == NULL)
	{
		// PPMOVE : [matthewt]
		// VSHELL currently does not support this
		// SetPaintEmergency();
		return;
	}

	// Draw tabs.
	dc.SetBkMode(TRANSPARENT);
	m_tabRow.Draw(&dc);

	CRect rectPage;
	GetClientRect(rectPage);
	rectPage.InflateRect(-cxWndMargin, -cyWndMargin);
	rectPage.top = s_cyBreakLine;

	if ((NULL != m_pNewSlob) &&
		m_pNewSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)) &&
		((CIPCompSlob*)m_pNewSlob)->ShowLevelCombo())
		rectPage.bottom -= GetLevelComboHeight();

	m_tabRow.DrawPageRect(&dc, rectPage);
}

void CSheetWnd::OnPaletteChanged(CWnd* pFocusWnd)
{
	if (IsWindowVisible() && m_pCurPage->GetSafeHwnd() != NULL &&
		m_pCurPage->IsWindowVisible())
	{
		m_pCurPage->SendMessage(WM_PALETTECHANGED, 
			(WPARAM)pFocusWnd->GetSafeHwnd());
	}
}

BOOL CSheetWnd::OnQueryNewPalette()
{
	BOOL bRet = FALSE;
	
	if (IsWindowVisible())
	{
		if (m_pCurPage->GetSafeHwnd() != NULL && m_pCurPage->IsWindowVisible())
			bRet = m_pCurPage->SendMessage(WM_QUERYNEWPALETTE);

		OnPaletteChanged(m_pCurPage);
	}
	
	return bRet;
}

void CSheetWnd::OnSize(UINT nType, int cx, int cy)
{
	CDC* pDC = GetDC();

	m_cyRowHeight = m_tabRow.DesiredHeight(pDC);

	ReleaseDC(pDC);

	CRect	rect;
	CRect	rectCB;

	m_toolBar.GetWindowRect(rect);

	ScreenToClient(rect);

	rect.SetRect(rect.right + 4, s_cyBreakLine - m_cyRowHeight - 1,
		cx - cxWndMargin, s_cyBreakLine - 1);

	m_tabRow.SetPos(rect);

	if ((NULL != m_pNewSlob) &&
		m_pNewSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)) &&
		((CIPCompSlob*)m_pNewSlob)->ShowLevelCombo())
	{
		rectCB.top = cy - (cyWndMargin + 2 + m_cyRowHeight);
		rectCB.left = cxWndMargin;
		rectCB.bottom = rectCB.top + (m_cyRowHeight * 5);
		rectCB.right = cx - cxWndMargin;

		m_cbLevel.SetWindowPos(NULL, rectCB.left, rectCB.top,
			rectCB.Width(), rectCB.Height(),
			SWP_NOZORDER | SWP_NOACTIVATE);
		m_cbLevel.ShowWindow(SW_SHOW);
	}
	else
	{
		m_cbLevel.ShowWindow(SW_HIDE);
	}

	CMiniFrameWnd::OnSize(nType, cx, cy);
}

int CSheetWnd::GetLevelComboHeight()
{
	int		iHeight = 0;

	// if the slob is a IPCompSlob and if it says that we can display
	// the combo box, return the height to accomodate the combo box
	// otherwise, return 0
	if ((NULL != m_pNewSlob) &&
		m_pNewSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)) &&
		((CIPCompSlob*)m_pNewSlob)->ShowLevelCombo())
		iHeight = (cyWndMargin + 2 + m_cyRowHeight + cyWndMargin + 2);

	return iHeight;
}

void CSheetWnd::RecalcLayout(BOOL bNotify)
{
	// Keep MFC from changing the layout.
}

void CSheetWnd::CmdOkPage()
{
	if (Validate())
	{
		SetActive(FALSE);
		theApp.ReactivateView();

		if (! m_toolBar.IsPinned())
		{
			ShowWindow(SW_HIDE);
			g_PropSheetVisible = FALSE;
		}
	}
}

void CSheetWnd::CancelPage()
{
	m_bInCancel = TRUE;
	
	UndoPendingValidate();
	theApp.ReactivateView();

	if (! m_toolBar.IsPinned())
	{
		ShowWindow(SW_HIDE);
		g_PropSheetVisible = FALSE;
	}

	m_bInCancel = FALSE;
}

void CSheetWnd::CmdCancelPage()
{
	CancelPage();
}

void CSheetWnd::CmdPrevPage()
{
	IncrementPage(-1);
}

void CSheetWnd::CmdNextPage()
{
	IncrementPage(1);
}

void CSheetWnd::IncrementPage(int nInc)
{
	int cItems = m_tabRow.MaxTab() + 1;
	if (cItems == 0 || !Validate())
		return;

	int iActiveTab = m_tabRow.GetActiveTab();
	m_tabRow.SetActiveTab((iActiveTab + nInc + cItems) % cItems);
	OnSelPage();
	if (!m_tabRow.HasFocus())
		RestoreFocus();
}

void CSheetWnd::OnCmdPushPin()
{
	m_toolBar.SetPushPin(! m_toolBar.IsPinned());
}

void CSheetWnd::OnCmdHelp()
{
	// If there is a current popup, give it the first chance to handle
	// this help request.
	CWnd* pWnd = GetTopLevelParent();
	HWND hWnd = ::GetLastActivePopup(pWnd->GetSafeHwnd());

	// IStudio bug# 4031 & 2437 (fixed by scotg)
	// if we are the last active popup window, there is no need
	// to send the WM_COMMANDHELP message to ourself, since we
	// are already processing a WM_COMMANDHELP message.  this
	// is how we got here in the first place.
	if(hWnd != this->GetSafeHwnd())
	{
		if (::SendMessage(hWnd, WM_COMMANDHELP, 0, 0))
			return;
	}

	// Otherwise, let the current property page process the help request.
	OnCommandHelp(0, 0);
}

void CSheetWnd::OnSelChangeLevel()
{
	// if the slob is of type IPCompSlob, get its internal track selection
	// interface pointer and inform that of the internal select change
	if ((m_pNewSlob != NULL) &&
		(m_pNewSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob))))
	{
		int		iIndex;
		DWORD	dwCookie;

		iIndex = m_cbLevel.GetCurSel();
		ASSERT(iIndex != CB_ERR);

		dwCookie = m_cbLevel.GetItemData(iIndex);

		HRESULT								hr;
		COleRef<IInternalTrackSelection>	srpITS;

		hr = ((CIPCompSlob*)m_pNewSlob)->GetInternalTrackSelection(&srpITS);
		if (NOERROR == hr)
			srpITS->OnInternalSelectChange(dwCookie);
	}
}

LRESULT CSheetWnd::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	IdleUpdate();	// Make sure the slobs up to date.

	if (m_pCurPage != NULL)
		return (S_OK == m_pCurPage->OnPageHelp(wParam, lParam));

	return FALSE;
}

LRESULT CSheetWnd::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
	LRESULT lr = AfxGetMainWnd()->SendMessage(WM_SETMESSAGESTRING, wParam, lParam);

	UINT nIDLast = m_nIDLastMessage;
	m_nIDLastMessage = (UINT)wParam;    // new ID (or 0)
	m_nIDTracking = (UINT)wParam;       // so F1 on toolbar buttons work

	return lr;
}

BOOL CSheetWnd::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);

	if (!theApp.m_bToolTips)
	{
		CTheApp::SetEmptyToolTip(pNMHDR);
	
		*pResult = 0;
		return TRUE;
	}

	return CMiniFrameWnd::OnToolTipText(nID, pNMHDR, pResult);
}

BOOL CSheetWnd::UndoPendingValidate()
{
	if (m_pCurPage == NULL)
		return FALSE;
	
	return m_pCurPage->UndoPendingValidate();
}

BOOL CSheetWnd::FlipToPage(int iStringID)
{
	// iStringID == -1 means the first page no matter what its name is.
	//
	if (iStringID == -1)
	{
		m_tabRow.SetActiveTab(0);
		OnSelPage();
		RestoreFocus();
		return TRUE;
	}
	else
	{
		CString str;
		str.LoadString(iStringID);

		return FlipToPage(str);
	}

	return FALSE;
}

BOOL CSheetWnd::FlipToPage(const CString& str)
{
	if (m_tabRow.SetActiveTab(str) != -1)
	{
		OnSelPage();
		RestoreFocus();
		return TRUE;
	}

	return FALSE;
}

void CSheetWnd::OnSelPage()
{
	// scotg ASSERT(Validate());
	Validate();

	SaveFocus();
	SelectionChange(m_selState, m_pCurSlob, m_tabRow.GetActiveTab());
	IdleUpdate(); // force immediate selection change

	// Make this new one the default page since the user explicitly
	// selected it...
	SetDefaultPage();
}

// Set the default page to the one currently selected.
void CSheetWnd::SetDefaultPage()
{
	m_strDefaultPage = m_tabRow.GetTabString(m_tabRow.GetActiveTab());
}

void CSheetWnd::OnLButtonDown(UINT nHitTest, CPoint point)
{
	AfxCancelModes(m_hWnd);

	int nTab = m_tabRow.TabFromPoint(point);
	switch(nTab)
	{
		default:
			if (Validate())
			{
				ASSERT(nTab >= 0);
				
				m_iFocusSave = 0;
				m_tabRow.SetActiveTab(nTab);

				SetFocus();
				OnSelPage();
			}
			break;

		case CTabRow::SCROLL_LEFT:
		case CTabRow::SCROLL_RIGHT:

			m_tabRow.Scroll(nTab);
			m_tabRow.Capture(nTab);
			break;

		case -1:
			break;
	}

	CMiniFrameWnd::OnLButtonDown(nHitTest, point);
}

void CSheetWnd::OnTimer(UINT nTimerID)
{
	if (m_tabRow.HasCapture())
	{
		ASSERT(nTimerID == CTabRow::TIMER_ID);
		m_tabRow.OnTimer();
	}
	else
		CMiniFrameWnd::OnTimer(nTimerID);
}

void CSheetWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_tabRow.HasCapture())
		m_tabRow.OnMouseMove(point);
	else
		CMiniFrameWnd::OnMouseMove(nFlags, point);
}

void CSheetWnd::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_tabRow.HasCapture())
		m_tabRow.OnLButtonUp(point);
	else
		CMiniFrameWnd::OnLButtonUp(nFlags, point);
}

void CSheetWnd::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	AfxCancelModes(m_hWnd);

	switch( nHitTest )
	{
		case HTCAPTION:
		case HTLEFT:
		case HTTOP:
		case HTRIGHT:
		case HTBOTTOM:
		case HTTOPLEFT:
		case HTTOPRIGHT:
		case HTBOTTOMLEFT:
		case HTBOTTOMRIGHT:
		{
			CSlobWnd* pView = (CSlobWnd*)((CMainFrame*)theApp.m_pMainWnd)->GetActiveFrame()->
				GetActiveView();
			if( (pView != NULL) && pView->IsKindOf(RUNTIME_CLASS(CSlobWnd)) )
				pView->ObscureSprites();
			break;
		}
	}

	CMiniFrameWnd::OnNcLButtonDown(nHitTest, point);
}

int CSheetWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	IdleUpdate();	// Make sure the slobs up to date.

	return CMiniFrameWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

//	CSheetWnd::OnClose
//		A sheet is usally created by the parent, and will be destroyed
//		specifically by the parent upon leaving the app.  When the user closes
//		the sheet, it is simply hidden.  The parent can then reshow it without
//		recreating it.

void CSheetWnd::OnClose()
{
	if (!Validate())
		return;
		 
 	g_PropSheetVisible = FALSE;
	ShowWindow(SW_HIDE);

	m_toolBar.SetPushPin(FALSE);
}

void CSheetWnd::ClearPage()
{
	// if we're displaying a page, cause commits & then close the
	// page.

	if (m_pCurPage != NULL)
	{
		m_pCurPage->TermPage();
		m_pCurPage->ShowPage(SW_HIDE);
		m_pCurPage = NULL;

		m_pCurSlob = NULL;
	}
}

//	CSheetWnd::OnSysCommand
//		Implements Alt+F6 and Shift+Alt+F6 for  the SheetWnd to
//		be same as pressing Enter.

void CSheetWnd::OnSysCommand(UINT nID, LONG lParam)
{
	switch (nID & 0xfff0)
	{
		case SC_NEXTWINDOW:
		case SC_PREVWINDOW:
			if (LOWORD(lParam) == VK_F6)
			{
				if (m_pCurPage != NULL)
					CmdOkPage();
				else
					GetParent()->SetFocus();
				return;
			}
			break;

		case SC_KEYMENU:
			if (LOWORD(lParam) == VK_RETURN)
			{
				CmdOkPage();
				return;
			}
			// Check lParam.  If it is 0L, then the user may have done
			// an Alt+Tab, so just ignore it.  This breaks the ability to
			// just press the Alt-key and have the first menu selected,
			// but this is minor compared to what happens in the Alt+Tab
			// case.
			else if (lParam == 0L || !Validate())
			{
				return;
			}
		
		//FALL THROUGH
		case SC_CLOSE:
			if (((nID & 0xfff0) == SC_CLOSE && lParam == 0L) ||
				((nID & 0xfff0) == SC_KEYMENU && lParam != 0L))
			{
				CWnd* pParent = GetParent();
				ASSERT(pParent != NULL);

				ASSERT(!bQuitting);
				pParent->SetActiveWindow();

				if (! m_toolBar.IsPinned())
				{
					ShowWindow(SW_HIDE);
					g_PropSheetVisible = FALSE;
				}
				pParent->SendMessage(WM_SYSCOMMAND, nID, lParam);
				if (nID & 0xfff0 != SC_CLOSE)
				{
					ASSERT(IsWindow(m_hWnd));
					SetActiveWindow();
				}

				return;
			}
			break;
		case SC_MOVE:
		case SC_SIZE:
		{
			CSlobWnd* pView = (CSlobWnd*)((CMainFrame*)theApp.m_pMainWnd)->
				GetActiveFrame()->GetActiveView();
			if( (pView != NULL) && pView->IsKindOf(RUNTIME_CLASS(CSlobWnd)) )
				pView->ObscureSprites();
			break;
		}
	}

	CMiniFrameWnd::OnSysCommand(nID, lParam);
}

void CSheetWnd::OnEnable(BOOL bEnable)
{
	// Deal with the frame too so dialog boxes using this as the owner
	// are truly modal...
	if (!theApp.m_pMainWnd->IsWindowEnabled() != !bEnable)
		theApp.m_pMainWnd->EnableWindow(bEnable);

	CMiniFrameWnd::OnEnable(bEnable);

	// We used to disable the page here for VB to get page notification.
	// This caused DOLPHIN Bug 2574.  If you think you need this kind
	// of notification, beware.
}

void CSheetWnd::DrawFocusRect()
{
	if (!m_tabRow.HasFocus() || m_tabRow.MaxTab() < 0)
		return;		

	CRect rect;
	if (GetUpdateRect(rect) && rect.IntersectRect(rect, m_tabRow.GetRect()))
	{
		m_tabRow.InvalidateTab(m_tabRow.GetActiveTab());
		return;
	}

	CDC* pDC = GetDC();
	m_tabRow.DrawFocusRect(pDC);
	ReleaseDC(pDC);
}

void CSheetWnd::OnSetFocus(CWnd* pOldWnd)
{
	ASSERT(!bQuitting);
	m_tabRow.PutFocus(TRUE);
	DrawFocusRect();
}

void CSheetWnd::OnKillFocus(CWnd* pNewWnd)
{
	if (IsWindowVisible() && m_tabRow.HasFocus())
		DrawFocusRect();

	m_tabRow.PutFocus(FALSE);
}

//	CSheetWnd::OnActivate
//		Performs Save and Restore on focus.  Also sets the "modal window"
// 		flag, which turns on the validation checking if the user clicks
// 		away from this window.  We do an OnIdle hide/show of the property
// 		sheet here just to make sure nothing can throw a PoppingProp sheet
// 		out of synch.

void CSheetWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
//	CMiniFrameWnd::OnActivate(nState, pWndOther, bMinimized);

	static BOOL bDisableIME;
	if (nState == WA_INACTIVE)
	{
		// hide the property sheet only if we're losing activation to
		// one of our app's own windows -- if we lose activation to
		// a window of another app, we don't want to hide, because
		// doing so will cause us to not appear in the alt-tab list.

		// NOTE:  pWndOther is NULL under NT if you are losing focus
		// to another application!

		// Loop on GetParent to support activation loss to other popups.
		while (pWndOther != NULL && pWndOther != AfxGetMainWnd())
			pWndOther = pWndOther->GetParent();

		if (pWndOther == AfxGetMainWnd())
		{
			if (! m_toolBar.IsPinned())
				g_PropSheetVisible = FALSE;

			theApp.m_pMainWnd->SendMessage(WM_SETAPPVALIDATE, (UINT) NULL);
	
			// inform the current slob page of this activation change
			if (m_pCurPage != NULL)
				m_pCurPage->Activate(nState, m_pCurSlob);
		}

		SaveFocus();

		if (bDisableIME)
		{
			theIME.EnableIME(FALSE);
			bDisableIME = FALSE;
		}
	}
	else
	{
		// inform the current slob page of this activation change
		if (m_pCurPage != NULL)
			m_pCurPage->Activate(nState, m_pCurSlob);

		g_PropSheetVisible = TRUE;
		RestoreFocus();

		theApp.m_pMainWnd->SendMessage(WM_SETAPPVALIDATE, (UINT) m_hWnd);

		SetActive(TRUE);

		if (theIME.IsEnabled())
		{
			bDisableIME = FALSE;
		}
		else
		{
			bDisableIME = TRUE;
			theIME.EnableIME(TRUE);
		}
	}
}

void CSheetWnd::SetActive(BOOL bActive)
{
TRACE1("CSheetWnd::Activate(%d)\n", bActive);

	m_bActive = bActive;

	if (m_pCurPage != NULL)
	{
		if (bActive)
			m_pCurPage->OnActivate();
		else
			m_pCurPage->OnDeactivate();
	}
}

void CSheetWnd::CurrentSlobDestroyed()
{
	m_pCurSlob = (CSlob *)NULL;	// destroyed!
	SetPropertyBrowserSelection(NULL);	// update view
}

//	CSheetWnd::SelectionChange
// 		Called when the property page needs to change to reflect a newly
//		selected object.  This is generally called by the editor or the
//		selection.	This is a "deferred change", i.e. the property page
//		maintains it's current state until IdleUpdate() is called, at which
//		time the property page changes to the new selection.  This avoids
//		nastyness in the switching of the property sheet.

void CSheetWnd::SelectionChange(CSheetWnd::SELSTYLE selState,
	CSlob *pEditor, int nPage)
{
    if(selState == editorupdate)
    {
        // force an update eneven though the slob is the same
        m_selState = selState;              // old different from new
        selState = CSheetWnd::editor;       // new is editor
    }

	m_pNewSlob = pEditor;
	m_newSelState = selState;
	m_nNewPage = nPage;
}

//	CSheetWnd::IdleUpdate
//		Called when the we hit the idle loop, or when the property sheet should
//		really be updated -- this must be called at a "safe" time, (i.e. not
//		in a focus change handler).	This actually updates the property page.

void CSheetWnd::IdleUpdate()
{
	// PPMOVE : [matthewt]
	// VSHELL currently does not support this
	//if (InEmergencyState())
	//	return;

	// if validation of the property page has already happened, it will
	// likely have disabled further validation until the idle loop, so
	// re-enable validation.

	m_bValidateEnabled = TRUE;

	// if selection didn't change, then don't update the property
	// page at all,
	if (m_pNewSlob == m_pCurSlob &&
		m_newSelState == m_selState &&
		m_nNewPage == m_nCurPage)
	{
		FlushInforms(); // make sure controls are up to date
		return;
	}

	// We just changed the selection, so we won't need to handle
	// any of these pending updates...
	while (!m_sheetSlob.m_informList.IsEmpty())
		delete m_sheetSlob.m_informList.RemoveHead();

    // otherwise go through the work.

	if (GetActiveWindow() == this)
		SaveFocus();

	if (m_pNewSlob == NULL)
	{
		m_newSelState = CSheetWnd::blank;
	}

	// before setting up pages, see if we can resolve a mutliple selection
	// to a single selection
	if( (m_pNewSlob != NULL) && m_pNewSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob))
		&& (m_pNewSlob->GetContentList()->GetCount() == 1) )
	{
		POSITION pos = m_pNewSlob->GetHeadPosition();
		CSlob* pSlob = m_pNewSlob->GetNext(pos);
		ASSERT( (pSlob != NULL) && (pos == NULL) );
		m_pNewSlob = pSlob;
		m_newSelState = CSheetWnd::editor;
	}

	// Ask the m_pNewSlob to add any property pages it wants to
	// This should also set the caption
	SetupPropertyPages();

	// make sure we come out of a multi-selection ok
	if( (m_pNewSlob != NULL) && m_pNewSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)) )
	{
		POSITION pos = m_pNewSlob->GetHeadPosition();
		if( m_pNewSlob->GetContentList()->GetCount() == 0 )
		{
			ASSERT( m_listNewPages.IsEmpty() );
			m_pNewSlob = NULL;
			m_newSelState = CSheetWnd::none;
		}
		else
		{
			// this would have been caught above
			ASSERT( m_pNewSlob->GetContentList()->GetCount() > 1 );

			if( m_listNewPages.IsEmpty() )
			{
				// we have a multiple selection with no common pages
				m_pNewSlob = NULL;
				m_newSelState = CSheetWnd::multiple;
			}
		}
	}

	// Fill in the list of pages.
	// NOTE: I used to try to optimize this by only filling the list when
	// the class of the slob changed, but unfortunatly even the style of
	// the parent of a slob can affect the list of pages...

	// IStudio bug# 964  it is possible for inplace components to use the same
	// slob but through the use of ITrackSelection change the objects that are
	// to be displayed in the property frame.  Thus the additional check for an
	// CIPCompSlob is necessary to allow ipcslobs to display new property pages
	// from the same slob object.
//	if( m_pNewSlob != m_pCurSlob
//		|| m_pNewSlob != NULL && m_pNewSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob))
//		|| m_pNewSlob != NULL && m_pNewSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)) )
	{
		m_tabRow.ResetContent();

		if( m_listNewPages.GetCount() > 0 )
		{
			C3dPropertyPage* pPage;
			CDC* pDC = GetDC();
			CString str;

			POSITION pos = m_listNewPages.GetHeadPosition();
			while( pos != NULL )
			{
				pPage = (C3dPropertyPage*)m_listNewPages.GetNext(pos);
				pPage->GetPageName(str);
				m_tabRow.AddTab(str, pDC, 0);
			}

			ReleaseDC(pDC);
		}
	}

	if( m_pNewSlob != NULL )
	{
		m_nNewPage = m_nNewPage != -1 ?
			m_tabRow.SetActiveTab(m_nNewPage) :
			m_tabRow.SetActiveTab(m_strDefaultPage);

		if( m_nNewPage == -1 )
		{
			m_nNewPage = 0;
			m_tabRow.SetActiveTab(0);
		}
	}

	m_pCurSlob = m_pNewSlob;
	m_selState = m_newSelState;
	m_nCurPage = m_nNewPage;

	// move all new pages to the CurPages list
	m_listCurPages.RemoveAll();
	m_listCurPages.AddTail(&m_listNewPages);
	m_listNewPages.RemoveAll();

	if( (m_pCurSlob == NULL) && (m_selState == CSheetWnd::editor) )
		m_selState = CSheetWnd::none;

	C3dPropertyPage* pNewPage = NULL;

	switch (m_selState)
	{
		case CSheetWnd::none:
			pNewPage = &m_nullPage;
			break;

		case CSheetWnd::blank:
			ClearPage();
			pNewPage = &m_noPage;
			break;

		case CSheetWnd::multiple:
			if( m_pNewSlob == NULL )
			{
				ASSERT( m_listCurPages.IsEmpty() );
				pNewPage = &m_multiPage;
				break;
			}
			// otherwise fall through

		case CSheetWnd::editor:
		{
			if( m_listCurPages.IsEmpty() )
			{	// some perfectly valid selections have no property pages
				pNewPage = &m_noPage;
				break;
			}

			if( (m_nCurPage < 0) || (m_nCurPage >= m_listCurPages.GetCount()) )
				m_nCurPage = 0;
			POSITION posPage = m_listCurPages.FindIndex(m_nCurPage);
			if( posPage != NULL )
				pNewPage = (C3dPropertyPage*)m_listCurPages.GetAt(posPage);
			// We can't deal with having a NULL page on a usable SheetWnd
			if( pNewPage == NULL )
				pNewPage = &m_noPage;
			break;
		}
	}

	// ok, now pNewPage is the property page we want to display, so
	// hide the old one and show the new one in one operation, optimize
	// for the case where they're the same page.
	//
	if (pNewPage != NULL)
	{
		if (!pNewPage->SetupPage(this, m_pNewSlob))
		{
			pNewPage = NULL;
		}
		else
		{
			pNewPage->InitializePage();
			pNewPage->ShowPage(SW_SHOW);

			if (pNewPage->m_hWnd != NULL)
				pNewPage->SendMessage(WM_QUERYNEWPALETTE);
		}
	}

	// if the new and old pages aren't the same, then hide the old one
	C3dPropertyPage* pOldPage = m_pCurPage;
	m_pCurPage = pNewPage;

	if (pOldPage != NULL && pOldPage != pNewPage)
		pOldPage->ShowPage(SW_HIDE);

	// Need to restore focus before getting rid of the old page because the
	// old one will get a kill focus...  Also need to update m_pCurPage, since
	// RestoreFocus depends on it.
	//

	if (GetActiveWindow() == this)
		RestoreFocus();

	// if the new and old pages aren't the same, then hide the old one
	if (pOldPage != NULL && pOldPage != pNewPage)
		pOldPage->TermPage();

	m_bSheetChanged = TRUE;
}

LRESULT CSheetWnd::OnIsError(WPARAM wIfEnabled, LPARAM)
{
	if (wIfEnabled && !m_bValidateEnabled)
		return TRUE;

	return !Validate();
}

// CSheetWnd::Validate
//
// This validates the information in the currently displayed property
// sheet (if any), and saves away the information -- if any information
// is not valid, this will show a dialog notifying the user of the error,
// setfocus to the appropriate field, and return FALSE.	It will
// return TRUE if the property sheet was validated and it's information
// stored in the viewed object.
//
// If we're already in a validation routine, this will return TRUE to
// allow operations to proceed without piling up.

BOOL CSheetWnd::Validate()
{
	BOOL bResult = TRUE;

	if (m_pCurPage && !m_bValidating)
	{
		m_bValidating = TRUE;
		bResult = m_pCurPage->Validate();
		m_bValidating = FALSE;

		// If the validation failed, the validate enable flag is cleared.
		// Certain validation code uses this flag to avoid validating twice
		// on a single user action, and hence showing two error message
		// boxes.  The flag is reset in IdleUpdate.

		if (!bResult)
			m_bValidateEnabled = FALSE;
	}

	return bResult;
}

// OnValidateReq
//
// This responds to a "special" message which is posted when an edit
// loses focus, and validation of that edit's contents need to be
// done.  It may change the focus back to the edit.   This should
// !!not!! do validation on focus changes outside of the property sheet,
// as they are handled elsewhere!
static const GUID CLSID_ADODC_General = 
{0xaa2073e6, 0x7b9c, 0x11d0, {0xb1, 0x43, 0x00, 0xa0, 0xc9, 0x22, 0xe8, 0x20}};

static const GUID CLSID_ADODC_Authenticate  = 
{0x27f8ffb1, 0x7406, 0x11d1, {0xb1, 0x8c, 0x00, 0xa0, 0xc9, 0x22, 0xe8, 0x20}};

static const GUID CLSID_ADODC_RecordSource = 
{0x27f8ffb2, 0x7406, 0x11d1, {0xb1, 0x8c, 0x00, 0xa0, 0xc9, 0x22, 0xe8, 0x20}};

LRESULT CSheetWnd::OnValidateReq(WPARAM, LPARAM)
{
	// Don't handle focus changes if the window the focus changed to is
	// not the property window or one of its descendants.

	CWnd* pWndFocus = GetFocus();
	if (this == pWndFocus || IsChild(pWndFocus))
	{
		// HACK HACK HACK:
		// This is to disable validation when we type a character.
		// Instead we only want to validate when we switch page
		// This is done only on the ADODC control
		BOOL bValidate = TRUE;
		if (m_pCurPage->IsKindOf (RUNTIME_CLASS (COlePage)))
		{
			CLSID clsid = CLSID_NULL ;
			((COlePage *)m_pCurPage)->GetCLSID(&clsid); 
			bValidate = !(::IsEqualCLSID (clsid, CLSID_ADODC_Authenticate) ||
						  ::IsEqualCLSID (clsid, CLSID_ADODC_RecordSource) ||	
						  ::IsEqualCLSID (clsid, CLSID_ADODC_General));
		}
		if (bValidate)
			Validate();
	}
	return TRUE;
}

BOOL CSheetWnd::ValidateRequest()
{
	PostMessage(WM_USER_VALIDATEREQ);
	
	return TRUE;
}

// 	CSheetWnd::SetEditFocus
//		Sets the focus to an edit field of the general property page,
//		if present -- if no edit property with ID is present, or there is no
//		valid current page, the focus is not changed.
//
//		This also selects the entire edit text, so that any keystrokes will
//		replace the current caption.
//
//		The edit window (if any) is returned, in case a message should be
//		posted to it.

CWnd* CSheetWnd::SetEditFocus(UINT nProp)
{
	ASSERT(!bQuitting);
	
	IdleUpdate();	// Make sure the slobs up to date.

	if (m_pCurSlob == NULL || !Validate())
		return NULL;

	// Look out for pending slob changes.
	//
	POSITION pos = m_listCurPages.GetHeadPosition();
	for( int nPage = 0; pos != NULL; nPage++ )
	{
		CSlobPage* pPage = (CSlobPage*)m_listCurPages.GetNext(pos);
		ASSERT( pPage != NULL );

		ASSERT(pPage->IsKindOf(RUNTIME_CLASS(CSlobPage)));
		CControlMap* pCtlMap = pPage->FindProp(nProp);
		if (pCtlMap == NULL)
			continue;
		CWnd* pControl = (CWnd*) pPage->GetDlgItem(pCtlMap->m_nCtlID);
		if (pControl == NULL)
			continue;
		if (!pControl->IsWindowEnabled())
			return NULL;

		if (nPage != m_tabRow.GetActiveTab())
		{
			m_tabRow.SetActiveTab(nPage);
			OnSelPage();
		}

		CString str;
		::GetClassName(pControl->m_hWnd, str.GetBuffer(256), 256);
		str.ReleaseBuffer();

		pControl->SetFocus();
		if (str.CompareNoCase("Edit") == 0)
			((CEdit*)pControl)->SetSel(0,32727);
		else
		{
			// We only support combo's and edits.
			ASSERT(str.CompareNoCase("ComboBox") == 0);
			((CComboBox*)pControl)->SetEditSel(0,32727);
		}

		return pControl;
	}

	return NULL;
}

CWnd* CSheetWnd::GetControl(UINT nControlID)
{
	IdleUpdate();	// Make sure the slobs up to date.

	if( (m_pCurSlob != NULL) && (m_listCurPages.GetCount() > 0) )
	{
		// Look out for pending slob changes.
		//
		C3dPropertyPage* pPage = (C3dPropertyPage*)m_listCurPages.GetHead();
		if (pPage->GetSafeHwnd() == NULL)
			return NULL;

		CWnd* pControl = (CWnd*) pPage->GetDlgItem(nControlID);
		return pControl;
	}
	return NULL;
}

//	CSheetWnd::SaveFocus
//		Saves the current page's focus in the form of the control's
//		ID, so that we can restore focus even if the page (and hence the
//		controls' hWnds) have changed.

#define FOCUS_TABS -1

BOOL CSheetWnd::SaveFocus()
{
	CWnd* pWnd = GetFocus();
	if (m_pCurPage == NULL || (pWnd == this && m_tabRow.HasFocus()))
	{
		m_iFocusSave = FOCUS_TABS;
		return TRUE;
	}
	else if(pWnd != NULL)
	{
		if (m_pCurPage->GetSafeHwnd() == NULL)
		{
			// No page window, so just save the hwnd with focus.

			m_hwndFocusSave = pWnd->GetSafeHwnd();
			m_iFocusSave = NULL;
			m_bSheetChanged = FALSE;
			return TRUE;
		}
		else if(m_pCurPage->IsChild(pWnd))
		{
			// Search up for first child, so we don't get part of a
			// combo-box.

			while(pWnd->GetParent() != m_pCurPage)
				pWnd = pWnd->GetParent();

			m_iFocusSave = pWnd->GetDlgCtrlID();
			m_hwndFocusSave = NULL;
			m_bSheetChanged = FALSE;
			return TRUE;
		}
	}

	m_iFocusSave = NULL;
	return FALSE;
}

//	CSheetWnd::RestoreFocus
//		Restores the focus to the SheetWnd using the saved ID.

BOOL CSheetWnd::RestoreFocus()
{
	ASSERT(!bQuitting);
	
	BOOL bRestored = FALSE;

    if (m_pCurPage != NULL)
	{
	 	// Don't restore the focus if we are disabled, give the tab focus.
		if (m_iFocusSave == FOCUS_TABS || m_pCurPage->IsPageDisabled())
		{
			SetFocus();
			return TRUE;
		}
		else if (m_iFocusSave == NULL || m_pCurPage->GetSafeHwnd() == NULL)
		{
			if (::IsWindow(m_hwndFocusSave)	&&
					::IsChild(m_hWnd, m_hwndFocusSave) &&
					::IsWindowVisible(m_hwndFocusSave) &&
					::IsWindowEnabled(m_hwndFocusSave))
				::SetFocus(m_hwndFocusSave);
			else
				m_pCurPage->ShowPage(SW_SHOWNORMAL);

			return TRUE;
		}

		CWnd* pWnd = m_pCurPage->GetDlgItem(m_iFocusSave);

		// If no window with the ID is in this dialog, or the window is
		// disabled, or it just isn't a tabstop, set focus to the dialog
		// itself, which will set focus to it's first tabstop.
		// because this will seem like a focus change, be sure to save
		// the old focussed id so that we can restore there when we can!
		// ggh 08-Sep-92

		if (pWnd == NULL || !pWnd->IsWindowEnabled() ||
			 !(pWnd->GetStyle() & WS_TABSTOP))
		{
			UINT oldFocus = m_iFocusSave;
		 	bRestored = (m_pCurPage->SetFocus() != NULL);
		 	m_iFocusSave = oldFocus;
		}
		else		// we can restore focus where it was saved!
		{
			char szClass[5];
			::GetClassName(pWnd->m_hWnd, (LPSTR) szClass, 5);

			// If we are not restoring to an edit, or we are restoring
			// to the unchanged edit from which we saved, then just SetFocus.

			if (lstrcmp(szClass, "Edit") || !m_bSheetChanged)
			{
				bRestored = (pWnd->SetFocus() != NULL);
			}

			// This is a new/changed editbox, so select its contents.

			else
			{
				bRestored = (pWnd->SetFocus() != NULL);
				((CEdit*) pWnd)->SetSel(0,0x7FFF);
			}
		}
	}

	return bRestored;
}

void CSheetWnd::FlushUnusedPages()
{
	TRACE("Flushing unused property pages...\n");
	POSITION pos = s_listLoadedPages.GetHeadPosition();
	while (pos != NULL)
	{
		POSITION posThis = pos;
		C3dPropertyPage* pPage = (C3dPropertyPage*)s_listLoadedPages.GetNext(pos);

		if (pPage != &m_nullPage && pPage != &m_multiPage &&
			pPage != &m_noPage && pPage != m_pCurPage)
		{
			TRACE1("Destroying page 0x%08lx\n", pPage);

			CWnd* pWnd;
			while ((pWnd = pPage->GetDlgItem(IDC_ID)) != NULL)
				pWnd->SetParent(&m_nullPage);
			while ((pWnd = pPage->GetDlgItem(IDC_ID_CAP)) != NULL)
				pWnd->SetParent(&m_nullPage);

			pPage->DestroyWindow();
			s_listLoadedPages.RemoveAt(posThis);
		}
	}
}

void CSheetWnd::RemovePageFromUse(C3dPropertyPage* pPage)
{
	POSITION pos = CSheetWnd::s_listLoadedPages.Find(pPage);
	if (pos != NULL)
		CSheetWnd::s_listLoadedPages.RemoveAt(pos);
}

/* SetupPropertyPages
 *	Set up property pages on the newly selected slob
 */
int CSheetWnd::SetupPropertyPages()
{
	// In case no one sets the caption...
	SetCaption(NULL);	// set it to "Properties"

	// initially, extra pages are allowed whenever the slob likes
	m_refInhibitExtraPages = 0;

	// let the slob add as many pages as they like
	if( m_pNewSlob != NULL )
	{
		m_pNewSlob->SetupPropertyPages(m_pNewSlob, TRUE);

		// if the slob is an CIPCompSlob, get the internal track selection
		// and find out if an external change happened.  If so, repopulate
		// the combo box
		if (m_pNewSlob->IsKindOf(RUNTIME_CLASS(CIPCompSlob)))
		{
			HRESULT								hr;
			COleRef<IInternalTrackSelection>	srpITS;

			hr = ((CIPCompSlob*)m_pNewSlob)->GetInternalTrackSelection(&srpITS);
			if (NOERROR == hr)
			{
				VARIANT_BOOL	bRet = VARIANT_FALSE;

				hr = srpITS->IsExternalSelectChange(&bRet);
				if ((NOERROR == hr) && (bRet == VARIANT_TRUE))
				{
					CALPOLESTR	caStringsOut;
					CADWORD		caCookiesOut;

					// delete all the items from the combo box
					m_cbLevel.ResetContent();

					hr = srpITS->GetInternalSelectList(&caStringsOut, &caCookiesOut);
					if (NOERROR == hr)
					{
						// release the interfaces of the old items from the combo box
						int			iIndex;

						USES_CONVERSION;

						// now add new items to the combo box
						ASSERT(caStringsOut.cElems == caCookiesOut.cElems);
						for (int i = 0; i < (int) caStringsOut.cElems; ++i)
						{
							iIndex = m_cbLevel.AddString(OLE2T(caStringsOut.pElems[i]));
							ASSERT(iIndex != CB_ERR);
							ASSERT(iIndex != CB_ERRSPACE);
							ASSERT(NULL != caCookiesOut.pElems[i]);
							m_cbLevel.SetItemData(iIndex, (DWORD)caCookiesOut.pElems[i]);
							AfxFreeTaskMem(caStringsOut.pElems[i]);
						}

						AfxFreeTaskMem(caStringsOut.pElems);
						AfxFreeTaskMem(caCookiesOut.pElems);

						m_cbLevel.SetCurSel(0);
					}
				}
			}
		}

		// show/hide the combo box depending upon whether
		// we need have HTML Elements to edit
		if (GetLevelComboHeight() > 0)
			m_cbLevel.ShowWindow(SW_SHOW);
		else
			m_cbLevel.ShowWindow(SW_HIDE);
	}

	// Try to append extra property pages from other packages.
	// If this has already been done, or is otherwise inhibited, this is harmless.
	AppendExtraPages();

	return m_listNewPages.GetCount();
}

/* AddPropertyPage
 *	Add a property page to the list.  
 *	Also, specifies what slob contains the data that this page reflects.
 */
int CSheetWnd::AddPropertyPage(C3dPropertyPage* pPage, CSlob* pSlob)
{
	ASSERT( pPage != NULL );
	// Set page's m_pSlob to be the slob passed to us.
	// The provider can pass NULL to use the m_pNewSlob of the whole sheet.
	// Finally, if m_pNewSlob is actually a multiple selection, and pSlob is 
	// actually a member of the selection, then point to the multiple selection.
	if( (pSlob == NULL) || (m_pNewSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)) &&
		m_pNewSlob->GetContentList()->Find(pSlob)) )
	{
		pPage->m_pSlob = m_pNewSlob;
	}
	else
		pPage->m_pSlob = pSlob;

	m_listNewPages.AddTail(pPage);
	return m_listNewPages.GetCount() - 1;	// return index of page in list
}

/* SetCaption
 *	Allows the owner of a property page to set the noun part of our caption 
 *	(e.g. "Foo" Properties).  The word " Properties" is appended automatically.
 */
void CSheetWnd::SetCaption(LPCTSTR sz)
{
	CString strCaption, strProperties;
	VERIFY( strProperties.LoadString(IDS_PROPERTIES) );

	strCaption.Format((LPCTSTR)strProperties, (sz == NULL) ? _T("") : sz);
	SendMessage(WM_SETTEXT, 0, (LPARAM)(LPCTSTR)strCaption);
}

/* AppendExtraPages
 *	Calls a virtual function in CPackage that allows them to add on extra 
 *	property pages of their own, depending on the selection.
 */
BOOL CSheetWnd::AppendExtraPages(void)
{
	if( m_refInhibitExtraPages > 0 )
		return FALSE;

	CPartView* pView = (CPartView*)CWnd::FromHandle(theApp.GetActiveView());
	if( pView == NULL )
		return FALSE;
	ASSERT( pView->IsKindOf(RUNTIME_CLASS(CPartView)) );

	// go get the GUID of the current view, and the selection interface
	GUID guidView;
	IUnknown* piUnkSel;

	if( !pView->GetSelectionInterface(&guidView, &piUnkSel) )
		return FALSE;	// lacking a guid and interface, there's no point

	POSITION pos = theApp.m_packages.GetHeadPosition();
	while( pos != NULL )
	{
		CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
		ASSERT( (pPackage != NULL) && pPackage->IsKindOf(RUNTIME_CLASS(CPackage)) );
		pPackage->AppendExtraPropertyPages(guidView, piUnkSel);
	}

	// once we've been called, we cannot be called again
	m_refInhibitExtraPages++;

	piUnkSel->Release();

	return TRUE;	// we at least tried
}

/* InhibitExtraPages
 *	Dissalow AppendExtraPages.  Ref-count to be sure.
 *	This can be used by owners of pages who don't want to allow any extra pages
 *	at all, by calling InhibitExtraPages(), and then not releasing it.
 *	Return whether or not extra pages are now inhibited.
 */
BOOL CSheetWnd::InhibitExtraPages(BOOL bInhibit /*=TRUE*/)
{
	if( bInhibit )
	{
		m_refInhibitExtraPages++;
		return TRUE;
	}

	m_refInhibitExtraPages = max(m_refInhibitExtraPages - 1, 0);

	// return whether or not inhibition is now off
	return m_refInhibitExtraPages > 0;
}

/* StartNewPageSet
 *	Marks all of the existing pages as belonging to a single set,
 *	and all subsequent pages as belonging to a new set.
 *	This marker is then used by MergePageSets() to tell the sets apart.
 *	Returns size of first page set.
 */
int CSheetWnd::StartNewPageSet(void)
{
	m_nFirstPageSet = m_listNewPages.GetCount();	// index of next page to be added
	return m_nFirstPageSet;
}

/* MergePageSets
 *	Merges two sets of pages together.  Afterwards, the only pages that will be 
 *	left will be those that occureded in both sets.
 *	Thus, to set up the pages for a 2-item multiple selection, add the pages of
 *	the first object (using AddPropertyPage()), then call StartNewPageSet(), 
 *	then add the pages of the second object, and call MergePageSets().
 *	To merge pages for more than 2 objects in a multiple selection, simply call
 *	StartNewPageSet(), add the pages, and call MergePageSets() for each object.
 *	Return the number of pages in common.
 */
int CSheetWnd::MergePageSets(void)
{
	if( (m_nFirstPageSet == 0) ||
		(m_nFirstPageSet >= m_listNewPages.GetCount()) )
	{
		// Either the first or second set is empty,
		// so there are no mutual pages.

		m_listNewPages.RemoveAll();
		m_nFirstPageSet = 0;
		return 0;	// no pages
	}

	POSITION posFirst = m_listNewPages.GetHeadPosition();
	POSITION posSecond = m_listNewPages.FindIndex(m_nFirstPageSet);
	ASSERT( (posFirst != NULL) && (posSecond != NULL) );

	// Loop through all of the pages in the first set.
	// If the page also exists in the second set, then remove it from that set
	// to shorten the loops.
	// If the page does not exist in the second set, remove it from the first 
	// set.
	// Finally, remove everything left from the second set.

	POSITION pos1 = posFirst;
	while( pos1 != posSecond )
	{
		POSITION pos1cur = pos1;
		C3dPropertyPage* pPage1 = (C3dPropertyPage*)m_listNewPages.GetNext(pos1);
		UINT idPage1 = (UINT)-1;
		if( pPage1->IsKindOf(RUNTIME_CLASS(CSlobPage)) )
			idPage1 = ((CSlobPage*)pPage1)->GetControlMap()->m_nCtlID;

		BOOL bMatch = FALSE;
		POSITION pos2 = posSecond;
		while( pos2 != NULL )
		{
			POSITION pos2cur = pos2;
			C3dPropertyPage* pPage2 = (C3dPropertyPage*)m_listNewPages.GetNext(pos2);

			// REVIEW(davidga): how do I really tell if pPage1 and pPage2 are 
			// the same dailog?  I'd like to use the IDD_, but those are only
			// in CSlobPages.
			UINT idPage2 = (UINT)-1;
			if( pPage2->IsKindOf(RUNTIME_CLASS(CSlobPage)) )
				idPage2 = ((CSlobPage*)pPage2)->GetControlMap()->m_nCtlID;

			if( (idPage1 != -1) && (idPage1 == idPage2) )
			{
				// These are both CSlobPages, and use the same dialog template.
				if( pos2cur != posSecond )
					m_listNewPages.RemoveAt(pos2cur);		// shorten list for speed
				bMatch = TRUE;
				break;
			}
			else if( (idPage1 == (UINT)-1) && (idPage2 == (UINT)-1) )
			{
				// both pages are COlePages.
				ASSERT( pPage1->IsKindOf(RUNTIME_CLASS(COlePage)) );
				ASSERT( pPage2->IsKindOf(RUNTIME_CLASS(COlePage)) );

				// In a multiple selection, all OLE pages will be removed.
				// This is accomplished by not setting bMatch to TRUE.

				break;
			}
		}

		if( !bMatch )
		{
			m_listNewPages.RemoveAt(pos1cur);
		}
	}

	// Remove everything from the second set
	while( posSecond != NULL )
	{
		POSITION pos2 = posSecond;
		m_listNewPages.GetNext(posSecond);
		m_listNewPages.RemoveAt(pos2);
	}

	m_nFirstPageSet = 0;
	return m_listNewPages.GetCount();	// return number of mutual pages
}

CSize CSheetWnd::CalcMaxPageSize(BOOL bNewPages /*=FALSE*/)
{
	// Calculate desired SheetWnd client area size.
	// Also store away the maximum page size, so the pages can expand during
	// InitializePage() if they want to.

	CSize sizeRet = m_noPage.GetPageSize();

	BOOL bFirst = TRUE;
	CObList* pList = bNewPages ? &m_listNewPages : &m_listCurPages;
	POSITION pos = pList->GetHeadPosition();
//	ASSERT( pos != NULL );
	while( pos != NULL )
	{
		C3dPropertyPage* pPage = (C3dPropertyPage*)pList->GetNext(pos);
		if( bFirst )
		{
			sizeRet = pPage->GetPageSize();
			bFirst = FALSE;
		}
		else
		{
			CSize size = pPage->GetPageSize();
			if( size.cx > sizeRet.cx )
				sizeRet.cx = size.cx;
			if( size.cy > sizeRet.cy )
				sizeRet.cy = size.cy;
		}
	}

	// if we're calculating the current set, update this member I found lying around
	if( !bNewPages )
		m_sizePageMax = sizeRet;

	return sizeRet;
}

void CSheetWnd::SetPushPin(BOOL fPushed /* = TRUE */)
{
	if(fPushed != m_toolBar.IsPinned())
		m_toolBar.SetPushPin(fPushed);		
}

BOOL CSheetWnd::IsPinned()
{
	return m_toolBar.IsPinned();
}

#if 0
//
// Globals for MLE sublassing in the property page
//

FARPROC glpfnOldSheetEditProc = NULL;
FARPROC glpfnNewSheetEditProc = NULL;

//
// SheetMleProc (C windowproc function)
//
// This overrides the default behaviors for WM_KEYDOWN and WM_CHAR to map the
// carriage return to a newline (which goes to the next line in the window,
// rather than pushing the default dialog button.
//

int FAR PASCAL EXPORT SheetMleProc(HWND hMLE, UINT wMessage, WPARAM wParam, LPARAM lParam)
{
    switch(wMessage)
    {
    case WM_KEYDOWN:	// make return work in MLE, not push the def button
    case WM_CHAR:
		if(wParam == 0x0d)
	    	wParam = 0x0A;
		break;
    }

    ASSERT(glpfnOldSheetEditProc != NULL);

    return (int) CallWindowProc((WNDPROC)glpfnOldSheetEditProc,
    	hMLE, wMessage, wParam, lParam);
}
#endif	// 0

//
// CSheet
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\sbar.cpp ===
// sbar.cpp
//
// This file contains the Sushi status bar.
//
// Copyright (c) 1993 Microsoft Corporation, all rights reserved.

#include "stdafx.h"

#include "shell.h"
#include "sbar.h"
#include "barglob.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize status bars

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,
};

#define PERCENT_NIL -1

/////////////////////////////////////////////////////////////////////////////

static BOOL g_bEnableClock = FALSE;

void EnableClock(BOOL bEnableClock)
{
	g_bEnableClock = bEnableClock;
	if (theApp.m_pMainWnd != NULL)
		((CMainFrame*)theApp.m_pMainWnd)->m_statusBar.ResetIndicators();
}

BOOL IsClockEnabled()
{
	return g_bEnableClock;
}

CSushiBarInfo::CSushiBarInfo(const UINT FAR* pIndicators, int cIndicators,
	              STATINFO FAR* pBitmaps, int cBitmaps)
{
	m_pIndicators = pIndicators;
	m_cIndicators = cIndicators;

	m_pBitmaps = pBitmaps;
	m_cBitmaps = cBitmaps;
}

IMPLEMENT_DYNAMIC(CSushiBar, CStatusBar)

BEGIN_MESSAGE_MAP(CSushiBar, CStatusBar)
	//{{AFX_MSG_MAP(CSushiBar)
	ON_MESSAGE(WM_SETTEXT, OnSetText)
	ON_WM_CREATE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CString CSushiBar::m_strAfxIdleMessage;

CSushiBar::CSushiBar()
{
	if (GetSystemMetrics(SM_DBCSENABLED))
	{
		// olympus 14527: Make sure we use a reasonable font for DBCS environments
		ASSERT(globalData.hStatusFont != NULL);

		// Use something other than the system font
		DeleteObject(globalData.hStatusFont);
		globalData.hStatusFont = HFONT(*GetStdFont(font_Normal));
	}

	for (int i = 0 ; i < MAXPANES; i++)
		m_hbitmapArray[i] = NULL;

	// Optimization -- load this static string only once.
	if (m_strAfxIdleMessage.IsEmpty())
	{
		VERIFY( m_strAfxIdleMessage.LoadString(AFX_IDS_IDLEMESSAGE) );
		m_strIdlePrompt = m_strAfxIdleMessage;
	}

	m_pCurrentIndicators = NULL;
	m_bLockedUntilIdle = FALSE;
	m_bScrollingPrompt = FALSE;
	Reset();
}

CSushiBar::~CSushiBar()
{
	for (int i = 0 ; i < MAXPANES; i++)
		if (m_hbitmapArray[i] != NULL)
			::DeleteObject(m_hbitmapArray[i]);
}

int CSushiBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	return CStatusBar::OnCreate(lpCreateStruct);
}

void CSushiBar::DrawIndicatorNow(UINT nIDIndicator, BOOL bBitmapToo)
{
	int nItem = CommandToIndex(nIDIndicator);
	if (nItem != -1)
	{
		CString str, strOld;
		GetText(nIDIndicator, str);
		GetPaneText(nItem, strOld);
		if (str == strOld)
			return;

		SetPaneText(nItem, str, FALSE);
		CRect rect;
		GetItemRect(nItem, rect);

		// no need to redraw borders or bitmap; only invalidate text region
		rect.InflateRect(-1, -1);
	
		if (!bBitmapToo && m_hbitmapArray[nItem] != NULL)
		{
			BITMAP bmap;
			::GetObject(m_hbitmapArray[nItem], sizeof(BITMAP), &bmap);
			rect.left += bmap.bmWidth + CX_BORDER * 2;
		}
		
		InvalidateRect(rect, TRUE);
		UpdateWindow();
	}
}

void CSushiBar::OnTimer(UINT nIDEvent)
{
	ASSERT(nIDEvent == 0);
	DrawIndicatorNow(ID_INDICATOR_CLOCK);
}

void CSushiBar::SetPrompt(const char* szMessage, BOOL bScrolling)
{
	if (m_bLockedUntilIdle)
		return;

	m_bScrollingPrompt = bScrolling;

	// Note that szMessage can be NULL, meaning the status bar should be blank.
	CString strCurrentText;
	GetPaneText(0, strCurrentText);

	if ((szMessage == NULL) && strCurrentText.IsEmpty())
		return;

	if (szMessage && !strCurrentText.Compare(szMessage))
		return;

	SetPaneText(0, szMessage, FALSE);
	Invalidate(FALSE);
}

LRESULT CSushiBar::OnSetText(WPARAM, LPARAM lParam)
{
	if (!m_bLockedUntilIdle)
	{
		SetPromptColor(0, 0);

		if (lParam && !m_strAfxIdleMessage.Compare((LPCSTR)lParam))
			SetPrompt(m_strIdlePrompt);
		else
			SetPrompt((LPCSTR)lParam);
	}

	return 1;
}

void CSushiBar::SetIdlePrompt(const char* szMessage)
{
	m_strIdlePrompt = szMessage;
}

void CSushiBar::SetPromptUntilIdle(const char* szMessage)
{
	SetPrompt(szMessage);
	UpdateWindow();
	m_bLockedUntilIdle = TRUE;
}

void CSushiBar::SetPromptColor(COLORREF textColor, COLORREF bkColor)
{
	if (m_bLockedUntilIdle)
		return;

	BOOL bZeros = ((textColor == 0) && (bkColor == 0));

	if (m_bStandardColors && bZeros)
		return;

	if ((m_textColor = textColor) == 0)
		m_textColor = ::GetSysColor(COLOR_BTNTEXT);
	if ((m_bkColor = bkColor) == 0)
		m_bkColor = ::GetSysColor(COLOR_BTNFACE);

	m_bStandardColors = bZeros;
}

void CSushiBar::OnIdle()
{
	m_bLockedUntilIdle = FALSE;
}

void CSushiBar::BeginPercentDone(const char* szPrompt)
{
	ASSERT(szPrompt != NULL);

	m_iPercentDone++;

	if (m_iPercentDone == 1)
	{
		SetPrompt(" ");
		m_strPercentDonePrompt = szPrompt;
	}
	else
	{
		if (m_iPercentDone >= MAXLEVELS)
		{
			ASSERT(FALSE);
			return;
		}

		SetPrompt(szPrompt);
	}

	Invalidate(TRUE);
	m_rectCounter.SetRectEmpty();

	m_rgPercentDone[m_iPercentDone] = PERCENT_NIL;
	PercentDone(0);
}

void CSushiBar::EndPercentDone()
{
	if (m_iPercentDone < 1)
		return;

	m_iPercentDone--;
	::SetPrompt();
	Invalidate();
}

void CSushiBar::PercentDone(int percent)
{
	if (m_iPercentDone < 1)
		return;

	// No going back, and staying the same is a no-op.
	if (percent <= m_rgPercentDone[m_iPercentDone])
		return;

	// Do not allow percentages less than 0 or greater than 100.
	m_rgPercentDone[m_iPercentDone] = min(max(percent, 0), 100);

	// Unless we've got two counters running, we can simply invalidate the
	// rect in which the percent-done blocks appear.
	if (m_iPercentDone == 1)
		InvalidateRect(m_rectCounter, FALSE);
	else
		Invalidate(FALSE);
	UpdateWindow();
}

BOOL CSushiBar::SetIndicators(const CSushiBarInfo* pSushiBarInfo)
{
	if (pSushiBarInfo == NULL)
		return SetIndicators();

	return SetIndicators(pSushiBarInfo->m_pIndicators, pSushiBarInfo->m_cIndicators,
	                     pSushiBarInfo->m_pBitmaps, pSushiBarInfo->m_cBitmaps);
}

void CSushiBar::ResetIndicators()
{
	m_pCurrentIndicators = NULL;
	CPacket* pPacket = theApp.m_pActivePacket;
	SetIndicators(pPacket == NULL ? NULL : pPacket->m_pSushiBarInfo);
}

BOOL CSushiBar::SetIndicators(const UINT FAR* pIDArray, int nIDCount,
                              const STATINFO FAR* pStatInfo, int nCount)
{
	if (pIDArray == NULL)
	{
		ASSERT(nIDCount == 0);
		pIDArray = indicators;
		nIDCount = sizeof(indicators) / sizeof(UINT);
	}

	if (pIDArray == m_pCurrentIndicators)
		return TRUE;

	// If there is status text, preserve it across the switch
	CString str;
	if (m_nCount > 0)
		GetPaneText(0, str);

	// BLOCK: Add default indicators (e.g. the clock)
	{
		UINT* pRealIDArray = (UINT*)pIDArray;

		if (g_bEnableClock)
		{
			pRealIDArray = new UINT [nIDCount + 1];
			memcpy(pRealIDArray, pIDArray, sizeof (UINT) * nIDCount);
			pRealIDArray[nIDCount++] = ID_INDICATOR_CLOCK;
		}

		BOOL bOkay = CStatusBar::SetIndicators(pRealIDArray, nIDCount);

		if (pRealIDArray != pIDArray)
			delete [] pRealIDArray;

		if (!bOkay)
			return FALSE;
	}

	if (g_bEnableClock)
		SetTimer(0, 10000, NULL);
	else
		KillTimer(0);

	ASSERT(nIDCount < MAXPANES);
	for (int i = 0 ; i < MAXPANES; i++)
		if (m_hbitmapArray[i] != NULL)
		{
			::DeleteObject(m_hbitmapArray[i]);
			m_hbitmapArray[i] = NULL;
		}

	UINT nID, nStyle;
	int cxWidth, index;

	for (i = 0 ; i < nCount ; i++, pStatInfo++)
	{
		ASSERT(pStatInfo);

		index = CommandToIndex(pStatInfo->nID);
		if (index != -1)
		{
			m_hbitmapArray[index] = LoadBitmap(pStatInfo->nGroup, pStatInfo->nBitmap);
			ASSERT(m_hbitmapArray[index] != NULL);	// we could not find the
			                                      	// specified bitmap.
			BITMAP bmap;
			::GetObject(m_hbitmapArray[index], sizeof(BITMAP), &bmap);

			GetPaneInfo(index, nID, nStyle, cxWidth);
			ASSERT(nID == pStatInfo->nID);

			SetPaneInfo(index, nID, nStyle, cxWidth + bmap.bmWidth + CX_BORDER * 4);
		}
	}

	m_pCurrentIndicators = pIDArray;

	// Load the text into the newly-created status pane, if necessary
	if (m_bLockedUntilIdle && !str.IsEmpty())
		SetPaneText(0, str);
	else
		::SetPrompt();

	Invalidate();
	OnIdleUpdateCmdUI((WPARAM)TRUE, (LPARAM)0);
	return TRUE;
}

HBITMAP CSushiBar::LoadBitmap(int nPackage, int nBitmap)
{
	ASSERT(theApp.m_pMainWnd != NULL);
	ASSERT(theApp.m_pMainWnd->IsKindOf( RUNTIME_CLASS(CMainFrame) ));
	
	// locate the package which offers this bitmap
	CPack* pPack = theApp.GetPackage(nPackage);
	ASSERT(pPack != NULL);

	HINSTANCE hInstance = pPack->HInstance();
	if (hInstance == NULL)
		hInstance = GetResourceHandle();

	return ::LoadBitmap(hInstance, MAKEINTRESOURCE(nBitmap));
}

void CSushiBar::OnSysColorChange()
{
	CStatusBar::OnSysColorChange();
	m_bStandardColors = FALSE;
	::SetPrompt();
}

UINT
LnColMinWidth(CDC* pDC, UINT nLines, UINT nCols)
{
	CString strPrmpt;
	char strTmp[30];

	VERIFY( strPrmpt.LoadString(IDS_LNCOLPRMPT) );
	strPrmpt += 'W';		// Add some padding
	sprintf(strTmp, strPrmpt, nLines, nCols);
	return pDC->GetTextExtent(strTmp, _tcslen(strTmp)).cx;
}


void CSushiBar::DoPaint(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CControlBar::DoPaint(pDC);      // draw border

	CRect rect;
	GetClientRect(rect);

	int xMax = rect.right - m_cxSizeBox;

	CalcInsideRect(rect, TRUE);

	UINT nID, nStyle, extraSpace = 0;
	int i, cxWidth;

	ASSERT(m_hFont != NULL);        // must have a font !
	HGDIOBJ hOldFont = pDC->SelectObject(m_hFont);

	// When we're in a progress loop, only the progress indicator shows
	if (m_iPercentDone > 0)
	{
		CString str;
		GetPaneText(0, str);
		if (m_iPercentDone == 1)
		{
			// Never put "ready" next to a progress bar
			if (!str.Compare(m_strAfxIdleMessage))
				str.Empty();
			DrawStatusPercentDone(pDC->m_hDC, rect, m_strPercentDonePrompt, m_rgPercentDone[1], str);
		}
		else
		{
			char buf [255];
			CString strFormat;
			VERIFY( strFormat.LoadString(ID_SBAR_PROGRESS) );

			sprintf(buf, (const char*)strFormat, (const char*)str, m_rgPercentDone[2]);
			DrawStatusPercentDone(pDC->m_hDC, rect, m_strPercentDonePrompt, m_rgPercentDone[1], buf);
		}
		pDC->SelectObject(hOldFont);
		return;
	}

	// If we are in a progress loop, only show the prompt -- not other panes
	int nCount = (m_iPercentDone > 0) ? 1 : m_nCount;
	static UINT cxLnColMin = 0;
	
	if (!cxLnColMin)
		cxLnColMin = LnColMinWidth(pDC, 100, 10);

	for (i = 0; i < nCount; i++)
	{
		CString str;
		BOOL	bRightAlign = FALSE;
		GetPaneInfo(i, nID, nStyle, cxWidth);
		GetPaneText(i, str);
		ASSERT(cxWidth >= 0);

		GetItemRect(i, &rect);

		if (::RectVisible(pDC->m_hDC, &rect))
		{
			if (m_hbitmapArray[i] != NULL)
				DrawStatusBitmap(pDC->m_hDC, rect, m_hbitmapArray[i], str, nStyle);
			else
			{
				// To improve the appearance when the text does not completely
				// fill the field (such as the LNCOL indicator) move the text
				// 1/3 towards the center of the available space.
				UINT textWidth = pDC->GetTextExtent(str, str.GetLength()).cx;
				if (nID != ID_SEPARATOR)
				{
					// Resize the line/col indicator if we're overflowing the available space
					if (nID == ID_INDICATOR_LNCOL)
					{
						CString strTmp = str + 'W';
						UINT	cxWidthRequired = max(cxLnColMin, (UINT)(pDC->GetTextExtent(strTmp, strTmp.GetLength()).cx));

						if ((UINT)cxWidth != cxWidthRequired)
							SetPaneInfo(i, nID, nStyle, cxWidth = cxWidthRequired);
					}
					extraSpace = ((UINT)cxWidth > textWidth) ? (cxWidth - textWidth) / 3 : 0;
				}
				else
				{
					extraSpace = 0;
				}

				DrawStatusText(pDC->m_hDC, rect, str, nStyle, textWidth, extraSpace);
			}
		}
	}

	pDC->SelectObject(hOldFont);

	// draw the size box in the bottom right corner
	if (!m_bHideSizeBox)
	{
		int cxMax = min(m_cxSizeBox, rect.Height()+m_cyTopBorder);
		rect.left = xMax + (m_cxSizeBox - cxMax) + CX_BORDER;
		rect.bottom -= CX_BORDER;
		HPEN hPenOld = (HPEN)pDC->SelectObject(globalData.hpenBtnHilite);
		for (i = 0; i < cxMax; i += 4)
		{
			pDC->MoveTo(rect.left+i, rect.bottom);
			pDC->LineTo(rect.left+cxMax, rect.bottom-cxMax+i);
		}
		pDC->SelectObject(globalData.hpenBtnShadow);
		for (i = 1; i < cxMax; i += 4)
		{
			pDC->MoveTo(rect.left+i, rect.bottom);
			pDC->LineTo(rect.left+cxMax, rect.bottom-cxMax+i);
		}
		for (i = 2; i < cxMax; i += 4)
		{
			pDC->MoveTo(rect.left+i, rect.bottom);
			pDC->LineTo(rect.left+cxMax, rect.bottom-cxMax+i);
		}
		pDC->SelectObject(hPenOld);
	}
}

void CSushiBar::DrawStatusBitmap(HDC hdcDest, CRect rect, HBITMAP hBitmap,
                                 LPCSTR szText, UINT nStyle)
{
	DrawStatusHelper(hdcDest, rect, nStyle);
	
	if (! (nStyle & SBPS_DISABLED))
	{
		CRect rectDraw(rect);
		rectDraw.InflateRect(-2*CX_BORDER, -CY_BORDER);

		HDC hdcSrc = ::CreateCompatibleDC(hdcDest);
		if (hdcSrc != NULL)
		{
			BITMAP bmap;
			::GetObject(hBitmap, sizeof(BITMAP), &bmap);
			HBITMAP hOldBitmap = (HBITMAP) ::SelectObject(hdcSrc, hBitmap);

			BitBlt(hdcDest, rectDraw.left, rectDraw.top, bmap.bmWidth,
			    bmap.bmHeight, hdcSrc, 0, 0, SRCCOPY);

			::SelectObject(hdcSrc, hOldBitmap);
			::DeleteDC(hdcSrc);

			rectDraw.left += bmap.bmWidth + CX_BORDER * 2;
		}

		if (szText != NULL)
		{
			SIZE size;
			if (GetTextExtentPoint32(hdcDest, szText, lstrlen(szText), &size))
			{
				if (size.cx < rectDraw.Width())
					rectDraw.InflateRect((size.cx - rectDraw.Width()) / 3, 0);
			}

			// align on bottom (since descent is more important than ascent)
			SetTextAlign(hdcDest, TA_LEFT | TA_BOTTOM);
			ExtTextOut(hdcDest, rectDraw.left, rectDraw.bottom,
				ETO_CLIPPED, &rectDraw, szText, lstrlen(szText), NULL);
		}
	}
}

void CSushiBar::DrawStatusText(HDC hdcDest, CRect rect, LPCSTR lpszText, UINT nStyle, UINT textWidth, UINT extraSpace /* =0 */)
{
	DrawStatusHelper(hdcDest, rect, nStyle);

	// just support left justified text
	if (lpszText != NULL)
	{
		COLORREF oldColor;
		if (nStyle & SBPS_DISABLED)
			oldColor = SetTextColor(hdcDest, GetSysColor(COLOR_BTNSHADOW));

		CRect rectText(rect);
		rectText.InflateRect(-2*CX_BORDER, -CY_BORDER);

		// align on bottom (since descent is more important than ascent)
		if (m_bScrollingPrompt && rectText.Width() < (INT)textWidth)
		{
			SetTextAlign(hdcDest, TA_RIGHT | TA_BOTTOM);
			ExtTextOut(hdcDest, rectText.right - extraSpace, rectText.bottom,
				ETO_CLIPPED | ETO_OPAQUE, &rectText, lpszText, lstrlen(lpszText), NULL);
		}
		else
		{
			SetTextAlign(hdcDest, TA_LEFT | TA_BOTTOM);
			ExtTextOut(hdcDest, rectText.left + extraSpace, rectText.bottom,
				ETO_CLIPPED | ETO_OPAQUE, &rectText, lpszText, lstrlen(lpszText), NULL);
		}

		if (nStyle & SBPS_DISABLED)
			SetTextColor(hdcDest, oldColor);
	}
}

void CSushiBar::DrawStatusHelper(HDC hdcDest, CRect rect, UINT nStyle)
{
	ASSERT(hdcDest != NULL);
	ASSERT(! (nStyle & SBPS_POPOUT));	// do bitmap indicators need this?

	HBRUSH hbrHilite = NULL;
	HBRUSH hbrShadow = NULL;
	if (!(nStyle & SBPS_NOBORDERS))
	{
		// normal colors
		hbrHilite = ::CreateSolidBrush(::GetSysColor(COLOR_BTNHIGHLIGHT));
		hbrShadow = ::CreateSolidBrush(::GetSysColor(COLOR_BTNSHADOW));
	}

	// background is already grey
	if (nStyle & SBPS_STRETCH)
	{
		SetBkMode(hdcDest, OPAQUE);
		SetTextColor(hdcDest, m_textColor);
		SetBkColor(hdcDest, m_bkColor);
	}
	else
	{
		SetBkMode(hdcDest, TRANSPARENT);
		SetTextColor(hdcDest, ::GetSysColor(COLOR_BTNTEXT));
		SetBkColor(hdcDest, ::GetSysColor(COLOR_BTNFACE));
	}

	// Draw the hilites
	if (hbrHilite != NULL)
	{
		HGDIOBJ hOldBrush = SelectObject(hdcDest, hbrHilite);
		if (hOldBrush)
		{
			PatBlt(hdcDest, rect.right, rect.bottom,
				-(rect.Width() - CX_BORDER),
				-CY_BORDER, PATCOPY);
			PatBlt(hdcDest, rect.right, rect.bottom,
				-CX_BORDER,
				-(rect.Height() - CY_BORDER), PATCOPY);
			SelectObject(hdcDest, hOldBrush);
		}
	}

	if (hbrShadow != NULL)
	{
		HGDIOBJ hOldBrush = SelectObject(hdcDest, hbrShadow);
		if (hOldBrush)
		{
			PatBlt(hdcDest, rect.left, rect.top,
				rect.Width(), CY_BORDER, PATCOPY);
			PatBlt(hdcDest, rect.left, rect.top,
				CX_BORDER, rect.Height(), PATCOPY);
			SelectObject(hdcDest, hOldBrush);
		}
	}

	if (hbrHilite != NULL)
		DeleteObject(hbrHilite);

	if (hbrShadow != NULL)
		DeleteObject(hbrShadow);
}

void CSushiBar::DrawStatusPercentDone(HDC hDC, CRect rect, LPCSTR lpszText,
                                      int percent, LPCSTR lpszExtraText)
{
	ASSERT(lpszText != NULL);

	CSize size;
	// FUTURE: Remove once chicago support GetTextExtentPoint32
	if (!theApp.m_bOnChicago)
		VERIFY( GetTextExtentPoint32(hDC, lpszText, lstrlen(lpszText), &size) );
	else
		// NOTE: GetTextExtentPoint is known to have an off by 1 bug on NT 
		VERIFY( GetTextExtentPoint(hDC, lpszText, lstrlen(lpszText), &size) );

	m_rectCounter = rect;
	m_rectCounter.left += size.cx + m_cxDefaultGap + (4 * CX_BORDER);
	m_rectCounter.right = m_rectCounter.left + (BLOCKWIDTH * 20) + (BLOCKMARGIN * 22);

	DrawStatusHelper(hDC, m_rectCounter, SBPS_NORMAL);

	// Draw leading prompt, left justified
	CRect rectText (rect);
	rectText.right = m_rectCounter.left - m_cxDefaultGap;
	rectText.InflateRect(-2*CX_BORDER, -CY_BORDER);

	// align on bottom (since descent is more important than ascent)
	SetTextAlign(hDC, TA_LEFT | TA_BOTTOM);
	ExtTextOut(hDC, rectText.left, rectText.bottom,
		ETO_CLIPPED | ETO_OPAQUE, &rectText, lpszText, lstrlen(lpszText), NULL);

	// If there's a trailing prompt, draw that too
	if (lpszExtraText != NULL)
	{
		CRect rectText (rect);
		rectText.left = m_rectCounter.right + m_cxDefaultGap;
		rectText.InflateRect(-2*CX_BORDER, -CY_BORDER);

		// align on bottom (since descent is more important than ascent)
		SetTextAlign(hDC, TA_LEFT | TA_BOTTOM);
		ExtTextOut(hDC, rectText.left, rectText.bottom,
			ETO_CLIPPED | ETO_OPAQUE, &rectText, lpszExtraText, lstrlen(lpszExtraText), NULL);
	}

	// Draw a number of blocks appropriate to the current percent done.
	ASSERT(percent <= 100);
	CRect rectBlock (m_rectCounter);
	rectBlock.InflateRect(-BLOCKMARGIN, -4);
	HBRUSH hbrBlue = CreateSolidBrush( RGB(0, 0, 128) );
	for (int i = 0 ; i < percent ; i += 5)
	{
		rectBlock.right = rectBlock.left + BLOCKWIDTH;
		FillRect(hDC, &rectBlock, hbrBlue);
		rectBlock.left = rectBlock.right + BLOCKMARGIN;
	}

	DeleteObject(hbrBlue);
}

void CSushiBar::Reset()
{
	m_position = CPoint(0, 0);
	m_size = CSize(0, 0);
	m_zoom = 100;
	m_line = 0;
	m_column = 0;
	m_bOverStrike = FALSE;
	m_bLockedUntilIdle = FALSE;
	m_bStandardColors = FALSE;

	// Because we can be in nested levels of percent-dones at a time, we
	// use an array to store all the percentages.  Note that this array
	// is indexed by the levels of nesting depth, meaning that position 0
	// is never used.
	for (int i = 0 ; i <= MAXLEVELS ; i++)
		m_rgPercentDone[i] = PERCENT_NIL;
	m_iPercentDone = 0;

	ASSERT(!m_strAfxIdleMessage.IsEmpty());

	// Reset to the current idle prompt [marklam]
	SetIdlePrompt(m_strIdlePrompt);
}

void CSushiBar::SetPosition(const CPoint& pos)
{
	m_position = pos;
	DrawIndicatorNow(ID_INDICATOR_POSITION);
}

void CSushiBar::SetSize(const CSize& size)
{
	m_size = size;
	DrawIndicatorNow(ID_INDICATOR_SIZE);
}

void CSushiBar::SetZoom(int zoom)
{
	m_zoom = zoom;
}

void CSushiBar::SetLineColumn(int line, int col, BOOL fForce /* = FALSE */)
{
	// Optimization: only paint on every third change during scrolling.
	// It will update to the actual correct value when we hit idle.
	BOOL bUpdate = fForce ||
				   ((line != m_line) && (line % 3 == 0)) ||
	               ((col != m_column) && (col % 3 == 0));

	m_line = line;
	m_column = col;

	if (bUpdate)
		DrawIndicatorNow(ID_INDICATOR_LNCOL);
}

void CSushiBar::SetOffsetExtent(long lOffset, long lExtent)
{
	m_offset = lOffset;
	m_extent = lExtent;
}

void CSushiBar::SetOverStrike(BOOL bOverStrike)
{
	m_bOverStrike = bOverStrike;
}

void CSushiBar::GetText(UINT nID, CString& str)
{
	char* pch = str.GetBufferSetLength(30);
	switch (nID)
	{
		case ID_INDICATOR_CLOCK:
			str = m_clock.Format();
			break;
		case ID_INDICATOR_ZOOM:
			sprintf(pch, "%d:1", m_zoom);
			break;
		case ID_INDICATOR_SIZE:
			if (m_size.cx == -32768 && m_size.cy == -32768)
				*pch = 0;
			else
				sprintf(pch, "%d x %d", m_size.cx, m_size.cy);
			break;
		case ID_INDICATOR_POSITION:
			if (m_position.x == -32768 && m_position.y == -32768)
				*pch = 0;
			else
				sprintf(pch, "%d, %d", m_position.x, m_position.y);
			break;
		case ID_INDICATOR_LNCOL:
			{
				CString strPrmpt;
				VERIFY( strPrmpt.LoadString(IDS_LNCOLPRMPT) );
				sprintf(pch, strPrmpt, m_line, m_column);
				break;
			}
		case ID_INDICATOR_OFFSET:
		case ID_INDICATOR_EXTENT:
			{
				// Load the string we used for sizing.
				CString strPrmpt;
				VERIFY(strPrmpt.LoadString(nID));

				// Strip sizing text after the space, and replace with zeros.
				int nSpace = strPrmpt.Find(_TEXT(" "));
				strPrmpt = strPrmpt.Left(nSpace + 1) + _TEXT("000000");

				// Get hex string for actual value.
				_ltoa((nID == ID_INDICATOR_OFFSET) ? m_offset : m_extent, pch, 16);
				str.ReleaseBuffer();
				str.MakeUpper();

				str = strPrmpt.Left(strPrmpt.GetLength() - str.GetLength()) + str;
				return;		// Buffer alread released.
			}
		default:
			ASSERT(FALSE);
			*pch = '\0';
			break;
	}

	str.ReleaseBuffer();
}

BOOL CSushiBar::IsIndicator(UINT nID)
{
	for (int i = 0; i < m_nCount; i++)
	{
		if (nID == GetItemID(i))
			return TRUE;
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Global Status Bar API
//
// These global functions are used by all project components to access the
// status bar.
//

#define TheStatusBar ((CMainFrame*)(theApp.m_pMainWnd))->m_statusBar

void ShowStatusBar(BOOL bShow /* = TRUE */)
{
	if (theApp.m_pMainWnd)
	{
		TheStatusBar.ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
		TheStatusBar.OnIdleUpdateCmdUI((WPARAM)TRUE, (LPARAM)0);
	}
}

BOOL IsStatusBarVisible()
{
	if (theApp.m_pMainWnd)
		return (TheStatusBar.GetStyle() & WS_VISIBLE) != 0;
	else
		return FALSE;
}

BOOL IsStatusBarIndicator(UINT nID)
{
	return TheStatusBar.IsIndicator(nID);
}

int GetStatusBarHeight()
{
	CRect rect;
	if (theApp.m_pMainWnd)
		TheStatusBar.GetWindowRect(rect);
	else
		rect.SetRectEmpty();
	return rect.Height();
}

void InvalidateStatusBar(BOOL bErase /* = FALSE */)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.Invalidate(bErase);
}

void ClearStatusBarSize()
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetSize(CSize(-32768, -32768));
//	if (theApp.m_pMainWnd)
//		g_pMainWnd->m_statBar.ClearSize();
}

void ClearStatusBarPosition()
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetPosition(CPoint(-32768, -32768));
//	if (theApp.m_pMainWnd)
//		g_pMainWnd->m_statBar.ClearPosition();
}

void ClearStatusBarPositionAndSize()
{
	ClearStatusBarSize();
	ClearStatusBarPosition();
}

void ResetStatusBar()
{
	if (theApp.m_pMainWnd)
		TheStatusBar.Reset();
}

void SetStatusBarPosition(const CPoint& pos)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetPosition(pos);
}

void SetStatusBarSize(const CSize& size)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetSize(size);
}

void SetStatusBarPositionAndSize(const CRect& rect)
{
	SetStatusBarPosition(((CRect&)rect).TopLeft());
	SetStatusBarSize(rect.Size());
}

void SetStatusBarZoom(int zoom)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetZoom(zoom);
}

void SetStatusBarLineColumn(int line, int col, BOOL fForce /* = FALSE */)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetLineColumn(line, col, fForce);
}

void SetStatusBarOffsetExtent(long lOffset, long lExtent)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetOffsetExtent(lOffset, lExtent);
}

void SetStatusBarOverStrike(BOOL bOverStrike)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.SetOverStrike(bOverStrike);
}

void SetPrompt(UINT nStringID, BOOL bRedrawNow,
               COLORREF textColor, COLORREF bkColor)
{
	// Optimize for the common (AFX_IDS_IDLEMESSAGE) case.
	if (nStringID == AFX_IDS_IDLEMESSAGE)
	{
		ASSERT(textColor == 0);	ASSERT(bkColor == 0);
		SetPrompt(CSushiBar::m_strAfxIdleMessage, bRedrawNow, 0, 0);
	}
	else
	{
	    CString str;
	    VERIFY( str.LoadString(nStringID) );
		SetPrompt(str, bRedrawNow, textColor, bkColor);
	}
}

void SetPrompt(const char* szPrompt, BOOL bRedrawNow,
               COLORREF textColor, COLORREF bkColor)
{
	if (theApp.m_pMainWnd)
	{
		TheStatusBar.SetPrompt(szPrompt);
		TheStatusBar.SetPromptColor(textColor, bkColor);

		if (bRedrawNow)
			TheStatusBar.UpdateWindow();
	}
}

void SetScrollingPrompt(const char* szPrompt, BOOL bRedrawNow,
						COLORREF textColor, COLORREF bkColor)
{
	if (theApp.m_pMainWnd)
	{
		TheStatusBar.SetPrompt(szPrompt, TRUE);
		TheStatusBar.SetPromptColor(textColor, bkColor);

		if (bRedrawNow)
			TheStatusBar.UpdateWindow();
	}
}

void SetIdlePrompt(UINT nStringID, BOOL bRedrawNow)
{
    CString str;
    VERIFY( str.LoadString(nStringID) );
	SetIdlePrompt(str, bRedrawNow);
}

void SetIdlePrompt(const char* szPrompt, BOOL bRedrawNow)
{
	if (theApp.m_pMainWnd)
	{
		TheStatusBar.SetIdlePrompt(szPrompt);

		if (bRedrawNow)
			TheStatusBar.UpdateWindow();
	}
}

void SetPromptUntilIdle(const char* szMessage, COLORREF textColor, COLORREF bkColor)
{
	if (theApp.m_pMainWnd)
	{
		TheStatusBar.SetPromptColor(textColor, bkColor);
		TheStatusBar.SetPromptUntilIdle(szMessage);
	}
}

BOOL IsPromptSetUntilIdle()
{
	return TheStatusBar.IsSetUntilIdle();
}

void StatusBeginPercentDone(const char* szPrompt)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.BeginPercentDone(szPrompt);
}

void StatusEndPercentDone()
{
	if (theApp.m_pMainWnd)
		TheStatusBar.EndPercentDone();
}

void StatusPercentDone(int percentDone)
{
	if (theApp.m_pMainWnd)
		TheStatusBar.PercentDone(percentDone);
}

void StatusOnIdle()
{
	if (theApp.m_pMainWnd)
		TheStatusBar.OnIdle();
}

CString CStatusClock::Format()
{
	CTime now(CTime::GetCurrentTime());

	return theApp.m_CPLReg.Format(now, TIME_NO_SECONDS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\sbar.h ===
// sbar.h
//
// Header file for the Sushi status bar.

// Copyright (C) 1993 Microsoft Corporation, all rights reserved.

#ifndef __SBAR_H__
#define __SBAR_H__

#include "oldstat.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
// CStatusClock

class CStatusClock
{
public:
	CString Format();
};

/////////////////////////////////////////////////////////////////////////////
// CSushiBar
//

class CSushiBarInfo;

class CSushiBar : public CStatusBar
{
	DECLARE_DYNAMIC(CSushiBar)

public:
	enum {
		MAXPANES = 12,
		BLOCKWIDTH = 6,
		BLOCKMARGIN = 2,
		MAXLEVELS = 4		// We need #3 when converting Caviar proj files
	};

	CSushiBar();
	~CSushiBar();

	void SetPrompt(const char* szMessage, BOOL bScrolling = FALSE);
	void SetPromptColor(COLORREF textColor = 0, COLORREF bkColor = 0);
	void SetIdlePrompt(const char* szMessage);
	void SetPromptUntilIdle(const char* szMessage);
	void OnIdle();

	afx_msg LRESULT	OnSetText(WPARAM, LPARAM lParam);
	afx_msg void  	OnSysColorChange();
	afx_msg int 	OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void	OnTimer(UINT nIDEvent);

	void BeginPercentDone(const char* szPrompt);
	void PercentDone(int percent);
	void EndPercentDone();

	BOOL SetIndicators(const UINT FAR* lpIDArray = NULL, int nIDCount = 0,
	                   const STATINFO FAR* pStatInfo = NULL, int nCount = 0);
	BOOL SetIndicators(const CSushiBarInfo* pSushiBarInfo);
	void ResetIndicators();

	virtual void DoPaint(CDC* pDC);
	HBITMAP LoadBitmap(int nGroupUI, int nBitmap);
	void DrawStatusBitmap(HDC hDC, CRect rect, HBITMAP hBitmap, LPCSTR szText, UINT nStyle);
	void DrawStatusText(HDC hDC, CRect rect, LPCSTR lpszText, UINT nStyle, UINT textWidth, UINT extraSpace = 0);
	void DrawStatusPercentDone(HDC hDC, CRect rect, LPCSTR lpszText, int percent, LPCSTR lpszExtraText);
	void DrawStatusHelper(HDC hdcDest, CRect rect, UINT nStyle);

	void DrawIndicatorNow(UINT nIDIndicator, BOOL bBitmapToo = FALSE);
	
	void Reset();
	void SetPosition(const CPoint& pos);
	void SetSize(const CSize& size);
	void SetZoom(int zoom);
	void SetLineColumn(int line, int col, BOOL fForce = FALSE);
	void SetOffsetExtent(long lOffset, long lExtent);
	void SetOverStrike(BOOL bOverStrike);
	void GetText(UINT nID, CString& str);

	BOOL GetOverStrike()
		{ return m_bOverStrike; }

	BOOL IsIndicator(UINT nID);
	BOOL IsSetUntilIdle(void) { return m_bLockedUntilIdle; }

	static CString m_strAfxIdleMessage;

private:
	int	m_rgPercentDone[MAXLEVELS+1];
	int m_iPercentDone;
	CString	m_strPercentDonePrompt;
	CRect	m_rectCounter;

	CStatusClock m_clock;
	HBITMAP m_hbitmapArray [MAXPANES+1];
	const UINT FAR* m_pCurrentIndicators;
	CPoint	m_position;
	CSize	m_size;
	int 	m_zoom;
	int 	m_line;
	int 	m_column;
	long	m_offset;
	long	m_extent;
	BOOL	m_bOverStrike;
	COLORREF	m_textColor;
	COLORREF	m_bkColor;
	BOOL		m_bStandardColors;
	BOOL		m_bScrollingPrompt;

	CString m_strIdlePrompt;
	BOOL	m_bLockedUntilIdle;

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\sfind.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SFIND.CPP
//		Implementation for general find architecture.

#include "stdafx.h"
#include "find.h"
#include "remi.h"
#include "resource.h"
#include "findspec.h"
#include "utilauto.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


// these strings are defined in profile.cpp
extern char BASED_CODE szSearch[];
extern char BASED_CODE szSearchFind[];
extern char BASED_CODE szSearchReplace[];
extern char BASED_CODE szEmpty[];


FINDREPLACEDISK AFX_EXT_DATADEF findReplace;
CPickList thePickList;

CPickList::CPickList(void)
{
	for (int j = FIND_PICK; j <= REPLACE_PICK; j++)
	{
		nbInPick[j] = 0;
		for (int i = 0; i < MAX_PICK_LIST; i++)
			aaszPickList[j][i] = 0;
	}
}

CPickList::~CPickList(void)
{
	//Free find and replace pick lists
	for (int j = FIND_PICK; j <= REPLACE_PICK; j++)
	{
		for (int i = 0; i < nbInPick[j]; i++)
			delete [] aaszPickList[j][i];
	}
}

FINDREPLACEDISK::FINDREPLACEDISK()
{
	//Initialize Replace/Find structure
	matchCase  = FALSE;
	regExpr = FALSE;
	bWasLineMatch = FALSE;
	wholeWord = FALSE;
	goUp = FALSE;
	loop = TRUE;
	startFromCursor = TRUE;
	pat = NULL;

	findWhat[0] = '\0';
	replaceWith[0] = '\0';
}

FINDREPLACEDISK::~FINDREPLACEDISK()
{
	DisposeOfPattern();
}

void FINDREPLACEDISK::DisposeOfPattern()
{
	if(pat != NULL) 
	{
		free((void *) pat);
		pat = NULL;
	}
}

BOOL FINDREPLACEDISK::CompileRegEx(reSyntax syntax)
{
	if(!regExpr)
		return FALSE;

	DisposeOfPattern();

	//For unknown reasons RE Engine take care of the dynamic Allocs
	//but you have to do the freeing ...
	//Compile the regular expression, 
	//(WARNING : RECompile can return NULL)
	pat = RECompile(findWhat, (flagType)matchCase, syntax);

  return (pat != NULL);
}

reSyntax	g_reCurrentSyntax = reUnix;

BOOL SetRegExprSyntax(reSyntax _reSyntax)
{
	ASSERT(reUnix <= _reSyntax && _reSyntax <= reEpsilon );
	g_reCurrentSyntax = _reSyntax;
	return TRUE;
}

reSyntax GetRegExprSyntax(void)
{
	ASSERT(reUnix <= g_reCurrentSyntax && g_reCurrentSyntax <= reEpsilon );
  return g_reCurrentSyntax;
}

/////////////////////////////////////////////////////////////////////////////
// CButtonEdit
BEGIN_MESSAGE_MAP(CButtonEdit, CEdit)
	//{{AFX_MSG_MAP(CButtonEdit)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CButtonEdit::CButtonEdit()
{
	m_dwLastSel = 0;
}

void CButtonEdit::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
{
	SetSel(m_dwLastSel); // Restore previous selection
	CEdit::ReplaceSel(lpszNewText, bCanUndo);
}

/////////////////////////////////////////////////////////////////////////////
// CButtonEdit message handlers

void CButtonEdit::OnKillFocus(CWnd *pNewWnd)
{
	m_dwLastSel = GetSel();
	CEdit::OnKillFocus(pNewWnd);
}

/////////////////////////////////////////////////////////////////////////////



CPickList &ShellPickList(void)
{
	return thePickList;
}

void CPickList::AllocateEntry(PickListType type, UINT iIndex)
{
	ASSERT(!aaszPickList[type][iIndex]); // this should be null!
	aaszPickList[type][iIndex] = new TCHAR[LIMIT_FIND_COMBO_TEXT + 1];
}

void CPickList::DeallocateEntry(PickListType type, UINT iIndex)
{
	ASSERT(aaszPickList[type][iIndex]); // this should never be nonzero!
	delete [] aaszPickList[type][iIndex];
	aaszPickList[type][iIndex] = 0;
}

BOOL CPickList::InsertEntry(PickListType type, FINDREPLACEDISK *pfr)
{
	if (type == FIND_PICK)
		return InsertEntry(type,pfr->findWhat);
	else
		return InsertEntry(type,pfr->replaceWith);
}

BOOL CPickList::InsertEntry(PickListType type, LPCTSTR newString)
{
	BOOL found = FALSE;
	int nb = nbInPick[type];
	int i;

	// Don't insert an empty string
	if(newString[0] == '\0')
		return FALSE;

	//First check if string is not already in list
	for (i = 0; i < nb; i++)
	{
		if (found = (_ftcscmp(aaszPickList[type][i], newString) == 0))
			break;
	}

	if (found)
	{
		//String already exists, move it to first place
		if (i > 0)
		{
			char szTmp[LIMIT_FIND_COMBO_TEXT + 1];

			_ftcscpy((LPSTR)szTmp, aaszPickList[type][i]);
			for (int j = i; j > 0; j--)
				_ftcscpy(aaszPickList[type][j], aaszPickList[type][j - 1]);
			_ftcscpy(aaszPickList[type][0], (LPSTR)szTmp);
		}
	}
	else
	{
		//String not found, do we have a new space to create ?
		if (nb < MAX_PICK_LIST)
		{
			AllocateEntry(type, nb);
			nb++;
		}

		//Shift list
		for (i = nb - 1; i >= 1; i--)
			_ftcscpy(aaszPickList[type][i], aaszPickList[type][i - 1]);
		_ftcscpy(aaszPickList[type][0], newString);
	}

	nbInPick[type] = nb;

	UpdateFindCombos();
	return !found;
}

void CPickList::RemoveEntry(PickListType type)
{
	if (nbInPick[type] <= 0)
		return;

	//Free the first element
	DeallocateEntry(type,0);

	//Shift the pick list
	for (int i = 1; i < nbInPick[type]; i++)
		aaszPickList[type][i - 1] = aaszPickList[type][i];

#ifdef _DEBUG
	int nLastEntry = nbInPick[type] - 1; // the last is at index [count - 1]
  aaszPickList[type][nLastEntry] = 0; // for our error checking in the allocation code
#endif

	nbInPick[type]--;

	UpdateFindCombos();
}

void CPickList::LoadFromRegistry(FINDREPLACEDISK *pfr)
{
	int	type;   // FIND_PICK or REPLACE_PICK
	int		iLoop;
	LPSTR	lpText;
	CString	str;
	char *	szBaseKey;
	char	szKeyName[32];		// Needs to be big enough to accomodate Find16 and Replace16

	for (type = FIND_PICK; type <= REPLACE_PICK; type++) {
		
		if(type == FIND_PICK)
			szBaseKey = szSearchFind;
		else
			szBaseKey = szSearchReplace;

		for (iLoop = 0; iLoop < MAX_PICK_LIST; iLoop ++) 
		{
			sprintf(szKeyName, szBaseKey, iLoop + 1);
			AllocateEntry(static_cast<PickListType>(type), iLoop);
			VERIFY (lpText = aaszPickList[type][iLoop]);
			str = GetRegString(szSearch, szKeyName);
			_ftcscpy(lpText, str);
			if(iLoop == 0)
			{
				if(type == FIND_PICK)  // So that F3 will work right off the bat.
					_ftcscpy(pfr->findWhat, str);
				else
					_ftcscpy(pfr->replaceWith, str);
			}
		}
		nbInPick[type] = MAX_PICK_LIST;
	}
}

void CPickList::SaveToRegistry(void)
{
	int	type;   // FIND_PICK or REPLACE_PICK
	int		iLoop;
	LPSTR	lpText;
	char *	szBaseKey;
	char	szKeyName[32];		// Needs to be big enough to accomodate Find16 and Replace16

	for (type = FIND_PICK; type <= REPLACE_PICK; type++) {
		
		if(type == FIND_PICK)
			szBaseKey = szSearchFind;
		else
			szBaseKey = szSearchReplace;

		for (iLoop = 0; iLoop < nbInPick[type]; iLoop++) 
		{
			sprintf(szKeyName, szBaseKey, iLoop + 1);
			VERIFY(lpText = aaszPickList[type][iLoop]);
			WriteRegString(szSearch, szKeyName, lpText);
		}
		for ( ; iLoop < MAX_PICK_LIST; iLoop ++) 
		{
			sprintf (szKeyName, szBaseKey, iLoop + 1 );
			WriteRegString(szSearch, szKeyName, szEmpty);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFindStringDlg dialog
//

CFindStringDlg::CFindStringDlg(LONG lStyle, CWnd* pParent /*=NULL*/)
	: C3dDialog(IDD_FIND, pParent)
{
	//{{AFX_DATA_INIT(CFindStringDlg)
	m_bMatchCase = findReplace.matchCase;
	m_bRegExp = findReplace.regExpr;
	m_bWholeWord = findReplace.wholeWord;
	m_nDirection = findReplace.goUp ? 0 : 1;
	m_bSearchAllDocs = !findReplace.loop;
	m_strFindString = "";
	//}}AFX_DATA_INIT

	m_lStyle = lStyle;
	m_bInitString = FALSE;

	// If we don't support some of the find modifiers, then clear
	// the value, so the checkbox won't show up checked.

	if ((m_lStyle & FDS_MATCHCASE) == 0)
		m_bMatchCase = FALSE;
	if ((m_lStyle & FDS_REGEXP) == 0)
		m_bRegExp = FALSE;
	if ((m_lStyle & FDS_WHOLEWORD) == 0)
		m_bWholeWord = FALSE;
	if ((m_lStyle & FDS_SEARCHALL) == 0)
		m_bSearchAllDocs = FALSE;
}

CFindStringDlg::~CFindStringDlg()
{
	if (m_bInitString)
	{
		LPCSTR lpsz;
		ShellPickList().RemoveEntry(FIND_PICK);	// Remove the guess.
		// And restore the findReplace value
		VERIFY(lpsz = ShellPickList().GetEntry(FIND_PICK,0));
		_tcscpy(findReplace.findWhat, lpsz);
	}
}

void CFindStringDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFindStringDlg)
	DDX_Check(pDX, IDC_FIND_MATCHUPLO, m_bMatchCase);
	DDX_Check(pDX, IDC_FIND_REGEXP, m_bRegExp);
	DDX_Check(pDX, IDC_FIND_WHOLEWORD, m_bWholeWord);
	DDX_Check(pDX, IDC_FIND_SEARCH_ALL, m_bSearchAllDocs);
	DDX_Radio(pDX, IDC_FIND_UP, m_nDirection);
	DDX_CBString(pDX, IDC_FIND_WHAT, m_strFindString);
	DDX_Control(pDX, IDC_FIND_NEXT, m_btnFindNext);
	//}}AFX_DATA_MAP
}

BOOL CFindStringDlg::OnInitDialog()
{
	if(_tcscmp(m_strFindString, findReplace.findWhat) != 0)
	{
		if (m_strFindString.IsEmpty())
			m_strFindString = findReplace.findWhat;
		else
		{
			m_bInitString = TRUE;

			_tcscpy(findReplace.findWhat, (const _TCHAR*)m_strFindString);
			ShellPickList().InsertEntry(FIND_PICK, &findReplace);
		}
	}
	C3dDialog::OnInitDialog();
	
	LPCSTR lpsz;
	CWnd *pwndCombo;
	pwndCombo = GetDlgItem(IDC_FIND_WHAT);
	ASSERT(pwndCombo != NULL);
	::SendMessage(pwndCombo->m_hWnd, CB_LIMITTEXT, LIMIT_FIND_COMBO_TEXT, 0);
	::SendMessage(pwndCombo->m_hWnd, CB_RESETCONTENT, 0, 0);

	for (int i = 0 ; i < ShellPickList().GetEntryCount(FIND_PICK); i++)
	{
		VERIFY(lpsz = ShellPickList().GetEntry(FIND_PICK,i));
		if(lpsz[0] != '\0')	// Do not add empty strings.
			::SendMessage(pwndCombo->m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpsz);
	}

	::SendMessage(pwndCombo->m_hWnd, CB_SETEXTENDEDUI, TRUE, 0);
	::SendMessage(pwndCombo->m_hWnd, CB_SETCURSEL, 0, 0);
	OnSelChangeFindWhat();

	if ((m_lStyle & FDS_WHOLEWORD) == 0)
		GetDlgItem(IDC_FIND_WHOLEWORD)->EnableWindow(FALSE);
	if ((m_lStyle & FDS_MATCHCASE) == 0)
		GetDlgItem(IDC_FIND_MATCHUPLO)->EnableWindow(FALSE);
	if ((m_lStyle & FDS_REGEXP) == 0)
		GetDlgItem(IDC_FIND_REGEXP)->EnableWindow(FALSE);
	if ((m_lStyle & FDS_SEARCHALL) == 0)
		GetDlgItem(IDC_FIND_SEARCH_ALL)->EnableWindow(FALSE);
	// Mark all window gets enabled if it is supported AND we are not searching
	// across documents.
	GetDlgItem(IDC_FIND_MARK_ALL)->EnableWindow((m_lStyle & FDS_MARKALL) && !m_bSearchAllDocs);

	m_btnSpecial.SubclassDlgItem(IDC_SPECIAL, this);
	VERIFY(m_btnSpecial.LoadMenu(IDR_FIND_SPECIAL));
	
	// Now subclass the edit control, part of the combo Box
	// so that we can remember where its selection is.
	m_comboEdit.SubclassDlgItem(1001, pwndCombo);

	UpdateButtons(!m_strFindString.IsEmpty());

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CFindStringDlg::UpdateState()
{
	if (m_bInitString)
	{
		ShellPickList().RemoveEntry(FIND_PICK);
		m_bInitString = FALSE;
	}

	UpdateData();

	ASSERT(!m_strFindString.IsEmpty());
	_ftcscpy(findReplace.findWhat, (const _TCHAR *)m_strFindString);
	ShellPickList().InsertEntry(FIND_PICK, &findReplace);

	// Only reset global flags if the dialog support user input to these flags.
	if (m_lStyle & FDS_MATCHCASE)
		findReplace.matchCase = m_bMatchCase;
	if (m_lStyle & FDS_REGEXP)
		findReplace.regExpr = m_bRegExp;
	if (m_lStyle & FDS_WHOLEWORD)
		findReplace.wholeWord = m_bWholeWord;
	if (m_lStyle & FDS_SEARCHALL)
		findReplace.loop = !m_bSearchAllDocs;
	findReplace.goUp = (m_nDirection == 0);
	findReplace.startFromCursor = TRUE;
}

BEGIN_MESSAGE_MAP(CFindStringDlg, C3dDialog)
	//{{AFX_MSG_MAP(CFindStringDlg)
	ON_BN_CLICKED(IDC_FIND_NEXT, OnClickedFindNext)
	ON_BN_CLICKED(IDC_FIND_MARK_ALL, OnClickedMarkAll)
	ON_BN_CLICKED(IDC_FIND_SEARCH_ALL, OnClickedSearchAll)
	ON_CBN_EDITCHANGE(IDC_FIND_WHAT, OnEditChangeFindWhat)
	ON_CBN_SELCHANGE(IDC_FIND_WHAT, OnSelChangeFindWhat)
	ON_CBN_SELENDOK(IDC_FIND_WHAT, OnSelChangeFindWhat)
	ON_COMMAND_RANGE(ID_FIND_ANYCHARACTER, ID_FIND_STRING, OnSpecialItem)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFindStringDlg message handlers

void CFindStringDlg::OnClickedFindNext()
{
	UpdateState();
	HWND hwndView = theApp.GetActiveView();
	ASSERT(hwndView != NULL);
	CPartView* pView = (CPartView*) FromHandlePermanent(hwndView);
	ASSERT(pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)));

	if(findReplace.pat != NULL) 
	{
		free((void *) findReplace.pat);
		findReplace.pat = NULL;
	}

	BOOL bFound;
	pView->OnFindNext(&bFound);

	if (bFound)
		EndDialog(IDC_FIND_NEXT);
	else
		GetDlgItem(IDC_FIND_WHAT)->SetFocus();
}

void CFindStringDlg::OnSpecialItem(UINT nId)
{
	if (FindSpecialHandler(m_comboEdit,nId))
		((CButton *)GetDlgItem(IDC_FIND_REGEXP))->SetCheck(1);
	OnEditChangeFindWhat(); // to properly the state of the Find Next button
}


void CFindStringDlg::OnClickedMarkAll()
{
	UpdateState();
	HWND hwndView = theApp.GetActiveView();
	ASSERT(hwndView != NULL);
	CPartView* pView = (CPartView*) FromHandlePermanent(hwndView);
	ASSERT(pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)));
	BOOL bFound;

	{
		// DS #10524 [CFlaat]: we don't want to record this preparatory find operation
		HALT_RECORDING();
		pView->OnFindNext(&bFound);
	}
	if(bFound && pView->MarkAll(&findReplace))
		EndDialog(IDC_FIND_NEXT);
	else
		GetDlgItem(IDC_FIND_WHAT)->SetFocus();
}
void CFindStringDlg::UpdateButtons(BOOL fEnable)
{
	m_btnFindNext.EnableWindow(fEnable);
	if(m_lStyle & FDS_MARKALL)
		GetDlgItem(IDC_FIND_MARK_ALL)->EnableWindow(!m_bSearchAllDocs && 
													fEnable);
}

void CFindStringDlg::OnEditChangeFindWhat()
{
	UpdateData();
	if(m_strFindString.GetLength()>LIMIT_FIND_COMBO_TEXT)
	{
		m_strFindString = m_strFindString.Left(LIMIT_FIND_COMBO_TEXT);
		UpdateData(FALSE);
	}
	UpdateButtons(!m_strFindString.IsEmpty());
}

void CFindStringDlg::OnSelChangeFindWhat()
{
	UpdateData();
	UpdateButtons(TRUE);
}

void CFindStringDlg::OnClickedSearchAll()
{
	UpdateData();
	UpdateButtons(!m_strFindString.IsEmpty());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\shellrec.cpp ===
/*

	Copyright 1996, Microsoft Corp.

	SHELLREC.CPP
		This header contains the implementation of the CShellRecorder object,
		which manages macro recording for the shell.

	HISTORY

		08-26-96	CFlaat	Adapted from pkgs\edit\editrec.cpp.
		08-27-96	CFlaat	Added some finishing touches.

*/


#include "stdafx.h"  // PCH
#include <utilauto.h>
#include "shellrec.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


#ifdef _DEBUG
#include "typeinfo.h" // for debug checks
#endif // _DEBUG



// implementation of CGeneralRecorder

IMacroRecorder *CShellRecorder::m_pMacroRecorder;
//IScriptGenerator *CGeneralRecorder::s_pScrGen; // will be only VBS to start with

// implementation of CShellRecorder

CShellRecorder g_theShellRecorder;


const TCHAR * const CShellRecorder::szPkgName = "devshl";  /* REVIEW(CFlaat): isn't this stored someplace else?? */ 



void CShellRecorder::EmitCurrentAction(void)
{
#ifdef _DEBUG
	// this is a reentrancy check that's probably not needed, but just here for sanity
	static BOOL bEntered = FALSE;
	ASSERT(!bEntered);
	bEntered = TRUE;
#endif

	if (!m_pCurrentShellAction)
	{
		ASSERT(FALSE); // hey!  need to set up the current action before it can be emitted!
		return;
	}

	ASSERT(ShouldEmitCode()); // the caller should have verified this already!!

	CString str;

	m_pCurrentShellAction->GetText(str); // NOTE: this can't be factored above, since coalescing changes its value
	GetMacRec()->RecordText(str, GetPkgName());

	delete m_pCurrentShellAction;
	m_pCurrentShellAction = 0;

#ifdef _DEBUG
	bEntered = FALSE;
#endif
}


void CShellRecorder::EmitMethodCall(ShellElement eMethod)
{
  if (ShouldEmitCode())
	{
		ASSERT(!m_pCurrentShellAction);
		m_pCurrentShellAction = new CShellAction(eMethod, CShellAction::acMethod);
		EmitCurrentAction();
		ASSERT(!m_pCurrentShellAction);
	}
}

void CShellRecorder::EmitMethodCall(ShellElement eMethod, CRecArg &arg1)
{
  if (ShouldEmitCode())
	{
		ASSERT(!m_pCurrentShellAction);
		m_pCurrentShellAction = new CShellAction(eMethod, CShellAction::acMethod, arg1);
		EmitCurrentAction();
		ASSERT(!m_pCurrentShellAction);
	}
}


void CShellRecorder::EmitPropertyAssignment(ShellElement eProperty, CRecArg &arg)
{
  if (ShouldEmitCode())
	{
		ASSERT(!m_pCurrentShellAction);
		m_pCurrentShellAction = new CShellAction(eProperty, CShellAction::acProperty, arg);
		EmitCurrentAction();
		ASSERT(!m_pCurrentShellAction);
	}
}

void CShellRecorder::EmitParameterizedPropertyAssignment(ShellElement eProperty, CRecArg &param, CRecArg &value)
{
  if (ShouldEmitCode())
	{
		ASSERT(!m_pCurrentShellAction);
		m_pCurrentShellAction = new CShellAction(eProperty, CShellAction::acProperty, param, value);
		EmitCurrentAction();
		ASSERT(!m_pCurrentShellAction);
	}
}


CShellRecorder::CShellRecorder(void)
{
	m_pCurrentShellAction = 0;
}

CShellRecorder::~CShellRecorder(void)
{
	ASSERT(!m_pCurrentShellAction); // should have been deleted in EmitCurrentAction
}


// CShellAction implementation


CShellAction::CShellAction(ShellElement ee, ActionCat ac)
{
	m_eElement = ee;
	m_eCategory = ac;

	m_cArgs = 0;

#ifdef _DEBUG
	VerifyCorrectness();
#endif
}

CShellAction::CShellAction(ShellElement ee, ActionCat ac, CRecArg &arg1)
{
	m_eElement = ee;
	m_eCategory = ac;

	m_cArgs = 1;

	m_aArgs[0] = arg1.Clone(); // sort of a virtual copy ctor

#ifdef _DEBUG
	VerifyCorrectness();
#endif
}

CShellAction::CShellAction(ShellElement ee, ActionCat ac, CRecArg &arg1, CRecArg &arg2)
{
	m_eElement = ee;
	m_eCategory = ac;

	m_cArgs = 2;

	m_aArgs[0] = arg1.Clone(); // sort of a virtual copy ctor
	m_aArgs[1] = arg2.Clone(); // sort of a virtual copy ctor

#ifdef _DEBUG
	VerifyCorrectness();
#endif
}

#ifdef _DEBUG

/*
	Don't get scared by the functions below!  They simply verify (in debug builds
	only) that the element specified by m_eElement has the right corresponding
	arguments.  The funky	typeid comparisons are how we make sure that our
	generic CRecArg pointer actually corresponds to the right argument type.
	Because CRegArg objects are polymorphic (i.e. they have a vtable), we can
	use the RTTI typeid operator to determine actual the underlying type.

	Note: "ZB" here stands for "zero-based", just as a reminder.
*/

void CShellAction::CheckZBArgType(int nIndex, const type_info & Type)
{
	ASSERT(nIndex >= 0);
	ASSERT (nIndex < MaxArgCount);

	try
	{
		ASSERT(typeid(*(m_aArgs[nIndex])) == Type);
	}
	catch(bad_typeid &bt)
	{
		ASSERT(FALSE); // bad type given to typeid above!
	}
	catch(...)
	{
		ASSERT(FALSE); // some other horrible error!
	}
}

void CShellAction::CheckArgCount(int nIndex)
{
	ASSERT(nIndex >= 0); 
	ASSERT (nIndex <= MaxArgCount); 
	ASSERT(m_cArgs == nIndex);
}

void CShellAction::CheckArgCountRange(int nLow, int nHigh)
{
	ASSERT(nLow >= 0);
	ASSERT(nLow < nHigh);  // note: this call is only for ranges!
	ASSERT (nHigh <= MaxArgCount);
	ASSERT(nLow <= m_cArgs); ASSERT(m_cArgs <= nHigh);
}

void CShellAction::VerifyCorrectness(void)
{
#ifndef _DEBUG
#error Hey!  CShellAction::VerifyCorrectness is a debug-only integrity-check!
#endif

	try
	{
		switch (m_eElement)
		{
			default:
				{
					ASSERT(FALSE); // the input value is not in the list -- what gives?!?
					break;
				}


			case seCloseWin: // one optional const arg
			case seSaveAll:
				{
					ASSERT(m_eCategory == acMethod);

					CheckArgCountRange(0, 1); // can be 0 or 1 args
					if (m_cArgs == 1)
						CheckZBArgType(0, typeid(CShellConstArg));
					break; 
				}


			// these elements have zero parameters

			case seNewWin: // always takes zero args
				{
					ASSERT(m_eCategory == acMethod);

					CheckArgCount(0); // must have zero args
					break; 
				}

				// TODO(CFlaat): add cases here for each element

		}
	}
	catch(...)
	{
		ASSERT(FALSE); // some terrible error has occurred!!!!
	}

}

#endif

/*
		The global static functions Get/SetArg exist as a workaround to the compiler's current
	inability to handle member function templates.  Once member fn templates are available,
	we can use those.
*/
#if 0

template <class ValType, class ArgContainerType>
ValType GetArg(CShellAction *pEA, unsigned iArg, ValType vDefault, BOOL bCreate)
{
	ASSERT(iArg < CShellAction::MaxArgCount);

	if (iArg < pEA->m_cArgs)
		ASSERT( dynamic_cast<ArgContainerType*>(pEA->m_aArgs[iArg]) );

	if (iArg >= pEA->m_cArgs) // if the requested argument doesn't exist
	{
		if (bCreate)
		{
#ifdef _DEBUG
			{
				for (int i = 0; i < iArg; i++)
				{
					ASSERT(i < pEA->m_cArgs);
					ASSERT(i < CShellAction::MaxArgCount);
					ASSERT(pEA->m_aArgs[i]); // if we're creating an arg, no previous arg should be NULL
				}
			}
#endif // _DEBUG

			pEA->m_aArgs[iArg] = new ArgContainerType(vDefault);
			pEA->m_cArgs++;
		}
		return vDefault;
	}
	else
		return static_cast<ArgContainerType*>(pEA->m_aArgs[iArg])->GetValue();
}

template <class ValType, class ArgContainerType>
void SetArg(CShellAction *pEA, unsigned iArg, ValType vData)
{
	ASSERT(iArg < CShellAction::MaxArgCount);
	ASSERT(iArg <= pEA->m_cArgs);

	ASSERT(pEA->m_aArgs[iArg]);
	ASSERT(dynamic_cast<ArgContainerType*>(pEA->m_aArgs[iArg]));

	static_cast<ArgContainerType*>(pEA->m_aArgs[iArg])->SetValue(vData);
}

template ShellConst GetArg<ShellConst, CShellConstArg>(CShellAction *, unsigned, ShellConst, BOOL);
template int GetArg<int, CIntArg>(CShellAction *, unsigned, int, BOOL);
template void SetArg<int, CIntArg>(CShellAction *, unsigned int, int);


ShellConst CShellAction::GetConstArg(unsigned iArg, ShellConst ecDefault, BOOL bCreate /* =FALSE */)
{
	return GetArg<ShellConst, CShellConstArg>(this, iArg, ecDefault, bCreate);
}

int CShellAction::GetIntArg(unsigned iArg, int nDefault, BOOL bCreate /* =FALSE */)
{
	return GetArg<int, CIntArg>(this, iArg, nDefault, bCreate);
}

void CShellAction::SetIntArg(unsigned iArg, int nValue)
{
	SetArg<int, CIntArg>(this, iArg, nValue);
}

LPCTSTR CShellAction::GetQuotedStringArg(unsigned iArg, LPCTSTR szDefault, BOOL bCreate /* =FALSE */)
{
	return GetArg<LPCTSTR, CQuotedStringArg>(this, iArg, szDefault, bCreate);
}

void CShellAction::SetQuotedStringArg(unsigned iArg, LPCTSTR szValue)
{
	SetArg<LPCTSTR, CQuotedStringArg>(this, iArg, szValue);
}
#endif


void CShellAction::GetText(CString &str) // gets the language-specific representation
{

	if (m_eCategory == acProperty) // if a property
	{
		// properties should either have a single RHS arg or include a parameterization
		ASSERT((m_cArgs == 1) || (m_cArgs == 2));

		if (m_cArgs == 1)
			GetElementText(str);
		else
		{
			CString strParam;
			m_aArgs[0]->GetText(strParam);

			GetElementText(str, strParam);
		}

		CString strRHS;

		// if 1 arg, RHS is zero-based index 0; if 2 args, RHS is zero-based index 1
		m_aArgs[m_cArgs == 1 ? 0 : 1]->GetText(strRHS);

		str += _T(" = ");
		str += strRHS;

//		pScrGen->CreatePropertyAssignment(strLHS, strRHS);
//		pScrGen->Finish(str);
	}
	else // it's a method call
	{
		GetElementText(str);

		ASSERT(m_eCategory == acMethod);

		ASSERT(m_cArgs <= MaxArgCount);

		CString strArg;

		if (m_cArgs)
		{
			str += _T(' ');
			m_aArgs[0]->GetText(strArg); // special-case the first param
			str += strArg;

			for (int i = 1; i < m_cArgs; i++) // now take care of the rest, starting with #1
			{
				m_aArgs[i]->GetText(strArg);
				str += _T(", ");
				str += strArg;
			}
		}


//		for (int i = 0; i < m_cArgs; i++)
//			m_aArgs[i]->GetText(astrParams[i], pScrGen);
//		pScrGen->CreateMethodCall(strLHS, m_cArgs, astrParams);
//		pScrGen->Finish(str);
	}
}

void CShellAction::GetElementText(CString &str, LPCTSTR szParam /* =0 */ /*, IScriptGenerator *pScrGen*/) const
{
// in the editor we use a table for this, but since we have so few calls here presently that we'll be lazy

//	theIdentifierTable.GetTextFromElement(str, m_eElement, szParam);

	switch (m_eElement)
	{
	case seSaveAll:
		{
			str = "Documents.SaveAll";
			break;
		}

	case seCloseWin:
		{
			str = "ActiveWindow.Close";
			break;
		}
	case seNewWin:
		{
			str = "ActiveDocument.NewWindow";
			break;
		}
	}

	ASSERT(!str.IsEmpty());
}


CShellAction::~CShellAction(void)
{
  int i;

  for (i = 0; i < m_cArgs; i++)
		delete m_aArgs[i];
}


void CShellConstArg::GetText(CString &str)
{
	switch (GetValue())
	{
	case scTrue:
			{
				str = "True";
				break;
			}
	case scSaveChangesPrompt:
			{
				str = "dsSaveChangesPrompt"; /* "3" */
				break;
			}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\shell.h ===
/////////////////////////////////////////////////////////////////////////////
//      SHELL.H
//              Shell implementation header.

#ifndef __SHELL_H__
#define __SHELL_H__

#include "bwizmgr.h"
#include <shlapi_.h>

/////////////////////////////////////////////////////////////////////////////
//      CBRecentFileList
//
// Overloads UpdateMenu to support Command bar menus. Used directly by the
// project list and indirectly by CTypedRecentFileList
//              CRecentFileList
//                      CBRecentFileList
//                              CTypedRecentFileList
// 

class CBRecentFileList : public CRecentFileList
{
public:
	CBRecentFileList(UINT nStart, LPCTSTR lpszSection,
					LPCTSTR lpszEntryFormat, int nSize, 
					int nMaxDispLen = AFX_ABBREV_FILENAME_LEN, int nShortCount=4)
	:       CRecentFileList(nStart, lpszSection,lpszEntryFormat, nSize, nMaxDispLen)
	{ m_nLastSize=nSize; m_nShortCount=nShortCount; }


	~CBRecentFileList() {}

	virtual void SetSize(int nSize);
	// sets the start accelerator number
	virtual void SetStart(int nStart);
	// sets the number of accelerators to issue in this list
	virtual void SetShortCount(int nStart);
	// returns the number of items in the list
	virtual int GetSize(void) const { return m_nSize; };
	// returns the number of items in the list
	virtual int GetShortCount(void) const { return m_nShortCount; };

	// Need to use CmdBar code to update menu
	virtual void UpdateMenu(CCmdUI* pCmdUI);        

	// this is the number of items that were put in the menu last time around
	int m_nLastSize;
	// Number of items to be given shortcuts
	int m_nShortCount;
};

/////////////////////////////////////////////////////////////////////////////
//      CTypedRecentFileList
//              Recent file list that saves the CDocTemplate type used to open it.
class CTypedRecentFileList : public CBRecentFileList
{
public:
	CTypedRecentFileList(UINT nStart, LPCTSTR lpszSection, 
		LPCTSTR lpszEntryFormat, LPCTSTR lpszEntryTypeFormat, int nSize, 
		int nMaxDispLen = AFX_ABBREV_FILENAME_LEN, int nShortCount=4);
	~CTypedRecentFileList();

// Attributes
	CLSID* m_arrTypes;
	CString m_strEntryTypeFormat;

// Operations
	CDocTemplate* GetTypeAt(int nIndex);
	virtual void Add(LPCTSTR lpszPathName, CDocTemplate* pTemplate);
	virtual void ReadList();        // reads from registry file
	virtual void WriteList();       // writes to registry file
	// sets the number of entries in the list
	virtual void SetSize(int nSize);
};
/////////////////////////////////////////////////////////////////////////////
//      CInternalApp
//              defined in intrnlap.cpp
//

class CInternalApp : public CCmdTarget
{
public:
	CBuilderWizardManager *GetBuilderWizardManager();       

private:
	CBuilderWizardManager m_builderWizardManager;
};


/////////////////////////////////////////////////////////////////////////////
//      CVShellPackage

class CVshellPackage : public CPackage
{
public:
	CVshellPackage();
	~CVshellPackage();

	enum { PKS = PKS_COMMANDS | PKS_INIT | PKS_QUERYEXIT | 
			PKS_INTERFACES | PKS_PREEXIT | PKS_AUTOMATION};

	void OnUpdateCommandUI(CCmdUI* pCmdUI);
	void OnUpdateCommandUI_View(CCmdUI* pCmdUI);
	void OnUpdateCommandUI_Tools(CCmdUI* pCmdUI);
	void OnUpdateCommandUI_MSOnTheWeb(CCmdUI* pCmdUI);
	void OnCommand_Tools(UINT nID);

	void RegisterTypeLibsIfNecessary(BOOL bForceFullRegistration = FALSE);
	void GetAllApplicationExtensions();

	virtual BOOL OnInit();
	virtual BOOL CanExit();
	virtual void OnPreExit();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, 
		AFX_CMDHANDLERINFO* pHandlerInfo);

//      DWORD GetIdRange(RANGE_TYPE rt);
//      LPCTSTR CVshellPackage::GetHelpFileName(HELPFILE_TYPE helpfileType);

	// Dynamic Command key strings for tooltips
	virtual UINT CmdIDForToolTipKey(UINT nIDCmdOriginal);

// Dockable window interface
	virtual HGLOBAL GetDockInfo();
	virtual HWND GetDockableWindow(UINT nID, HGLOBAL hglob);
	virtual HGLOBAL GetToolbarData(UINT nID);
	virtual BOOL AskAvailable(UINT nID);

	virtual void GetOpenDialogInfo(SRankedStringID** ppFilters, 
		SRankedStringID** ppEditors, int nOpenDialog);
	virtual void AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type);

	virtual POPDESC *GetMenuDescriptor(UINT nId);
	virtual BOOL IsMenuVisible(UINT nId);

protected:
	// Lists used to collect information about type libraries and
	//  top-level named items (for VBS) from each package

	// Main list of top-level named items for each package, used to implement
	//  IAutomationItems.  This is a private interface used exclusively by
	//  devaut1 for adding named items to VBS.
	CTypedPtrList< CPtrList, CAutomationItem* > m_ptrlAutomationItems;
	void RegisterTypeLib(CPackage* pPackage, BOOL bForceFullRegistration,
									 BOOL bGetApplicationExtensions);
	void AddNewAutoItem(const GUID* pTlid, WORD wMajorVersion, WORD wMinorVersion,
									LPCTSTR szName, const CLSID* pClsid);

	// Called by the IRecordNotifyShell interface to set theApp's members
	void SetShouldRecordText(BOOL bShouldRecordText)
		{ theApp.m_bShouldRecordText = bShouldRecordText; }
	void SetRecordState(int nRecordState)
		{ theApp.m_nRecordState = nRecordState; }

	//{{AFX_MSG(CVshellPackage)
	afx_msg void OnFileNew();
	afx_msg void OnFileNewInProject();
	afx_msg void OnFileOpen();
	afx_msg void OnFileSaveAll();
	afx_msg void OnFileSaveAllExit();
	afx_msg void OnAppAbout();
	afx_msg void OnHelpPSS();
	afx_msg void OnHelpMSOnTheWeb(UINT nID);
	afx_msg void OnHelpExtHelp();
	afx_msg void OnHelpTip();
	afx_msg void OnToolbarOptions();
	afx_msg void OnCustomize();
	afx_msg void OnToolbarCustomize();
	afx_msg void OnOptions();
	afx_msg void OnInsertFiles();
	afx_msg void OnWindowHide();
	afx_msg void OnToggleMDI();
	afx_msg void OnCmdRepeat();
	afx_msg void OnCmdRepeat0();
	afx_msg void OnCmdRepeat1();
	afx_msg void OnCmdRepeat2();
	afx_msg void OnCmdRepeat3();
	afx_msg void OnCmdRepeat4();
	afx_msg void OnCmdRepeat5();
	afx_msg void OnCmdRepeat6();
	afx_msg void OnCmdRepeat7();
	afx_msg void OnCmdRepeat8();
	afx_msg void OnCmdRepeat9();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

protected:
	BEGIN_INTERFACE_PART(AutomationItems, IAutomationItems)
		STDMETHOD(GetAutomationItems)(CAutomationItem* pAutomationItems, DWORD* pdwNumItems);
		STDMETHOD(GetIDispatch)(LPCTSTR szItemName, IDispatch** ppDispatch);
	END_INTERFACE_PART(AutomationItems)
	BEGIN_INTERFACE_PART(RecordNotifyShell, IRecordNotifyShell)
		STDMETHOD(OnStartRecord)(THIS);
		STDMETHOD(OnStopRecord)(THIS);
		STDMETHOD(OnPauseRecord)(THIS);
		STDMETHOD(OnResumeRecord)(THIS);
		STDMETHOD(SetShouldRecordText)(THIS_ BOOL bShouldRecordText);
	END_INTERFACE_PART(RecordNotifyShell)
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//      Global dimensions

typedef struct tagSCREEN_METRIC
{
    int cxBorder, cyBorder;
    int cxFrame, cyFrame;
    int cxToolBorder, cyToolBorder;
	int cxToolCaption, cyToolCaption;
	int cxToolCapBorder, cyToolCapBorder;
	int cxToolCapGap, cyToolCapGap;			// gap between tool caption buttons
	int cxToolCapButton, cyToolCapButton;
    int nSplitter;
} SCREEN_METRIC;

extern SCREEN_METRIC g_mt;

extern void InitMetrics();

/////////////////////////////////////////////////////////////////////////////
//      General utility functions.

HINSTANCE GetResourceHandle();

//  Set main product registration info from PID resource in the 
//  specified module (normally the EXE).

BOOL InitProductId(HMODULE hMod);

//////////////////////////////////////////////////////////////////////////////
// Help

BOOL GetPSSHelpFile(CString & strHelpFile);
void ReleaseHelpInterface();

// control help
LPCTSTR HelpFileFromID(DWORD dwId, UINT type);

// Ext Help
BOOL ShowExtHelp(); // expose UI?
BOOL UseExtHelp();  // use ext help?
BOOL GetExtHelpFile(CString & strHelpFile);
BOOL HelpIndexExt(LPCTSTR szKeyword = NULL);
BOOL HelpContentsExt();
BOOL HelpOnKeywordExt(LPCTSTR szKeyword = NULL);
BOOL SetExtHelp(BOOL b = TRUE);
BOOL ToggleExtHelp();

// initexit.cpp strings used by bwizmgr and bwizdlg do something similar to
// GetRegKeyName
// 
extern const TCHAR g_szKeyRoot[];
extern const TCHAR g_szCompanyName[];

//////////////////////////////////////////////////////////////////////////////
// Util

// Wrappers for the winmm functions

BOOL MyPlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
BOOL ShsndPlaySound(LPCSTR lpszSound, UINT fuSound);

/////////////////////////////////////////////////////////////////////////////
//
// GetFirstChildWindowWithID
//
//	A breath first version of CWnd::GetDescendentWindow.
//
// This function is in util.h.
//
class CPartView ;
CPartView* GetFirstChildWindowWithID(HWND hWnd, int nID, BOOL bOnlyPerm = FALSE) ;

#endif  // __SHELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\sheet.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHEET.H

#ifndef __SHEET_H__
#define __SHEET_H__

#include "proppage.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

#define cxPageMargin 6
#define cyPageMargin 4
#define cxWndMargin 5
#define cyWndMargin 5

#define MAX_TEXTSIZE 255 // normal edit controls

#define	INITIAL_LEVELCOMBO_HEIGHT	26

#ifdef _DEBUG
extern BOOL bQuitting;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSheetSlob

class CSheetSlob : public CSlob
{
	DECLARE_DYNAMIC(CSheetSlob)
public:
	CSheetSlob();
	~CSheetSlob();

	void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);
	void NukeInforms();
	void FlushInforms();
	inline BOOL HasInforms() { return !m_informList.IsEmpty(); }

	class CSheetWnd* m_pSheetWnd;
	CPtrList m_informList;
};

class CInformRecord
{
public:
	CInformRecord(CSlob*, UINT);

	CSlob*	m_pChangedSlob;
	UINT	m_idChange;
};

/////////////////////////////////////////////////////////////////////////////
//	CPropFrameToolBar
//		This is the minature toolbar with pushpin and help buttons

class CPropFrameToolBar : public CToolBar
{
public:
	enum {
		sizeButtonX = 21,
		sizeButtonY = 20,
		sizeImageX = 15,
		sizeImageY = 14,
	};

	CPropFrameToolBar();

	void SetSizes();

	BOOL IsPinned();
	void SetPushPin(BOOL bPushed = TRUE);
#ifdef _DEBUG
	virtual void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
//	CSheetWnd
// 		Implements the property frame, displaying C3dPropertyPage objects
//		in it's client area.

class CSheetWnd : public CMiniFrameWnd
{
public:
	static CObList s_listLoadedPages;
	static int s_cyBreakLine;	// y-coord of top of page

public:
	enum SELSTYLE { 					// selection state
		none,
		editor,
		multiple,
		blank,
        editorupdate                    // force an update even if sel same
	};

	enum {
		cxSize = 395,
		cySize = 157,
		xDefaultPos = 60,
		yDefaultPos = 470,
	};

// Construction
public:
	CSheetWnd();
	virtual ~CSheetWnd();

	BOOL Create();

public:
	void InitialUpdate(CPoint);
	void IdleUpdate();

	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	void CancelPage();
	BOOL IsInCancel() const { return m_bInCancel; }

	void SetActive(BOOL bActive);
	BOOL IsActive() const { return m_bActive; }

	BOOL Validate();
	BOOL ValidateRequest();
	BOOL IsValidating() const { return m_bValidating; }

	void ResetFocusSave() { m_iFocusSave = 0; }
	void SetDefaultPage();
	BOOL FlipToPage(int iStringID);
	BOOL FlipToPage(const CString& str);
	void IncrementPage(int nInc);
	void ClearPage();
	void SelectionChange(CSheetWnd::SELSTYLE, CSlob *, int nPage = -1);
	void CurrentSlobDestroyed();
	void SetPushPin(BOOL fPushed = TRUE);
	BOOL IsPinned();

	CWnd* SetEditFocus(UINT nProp);
	CWnd* GetControl(UINT nControlID);

	BOOL SaveFocus();
	BOOL RestoreFocus();
	void DrawFocusRect();
	
	BOOL UndoPendingValidate();

	void FlushUnusedPages();
	void RemovePageFromUse(C3dPropertyPage* pPage);
	inline void NukeInforms() { m_sheetSlob.NukeInforms(); }
	inline void FlushInforms() { m_sheetSlob.FlushInforms(); }
	inline BOOL HasInforms() { return m_sheetSlob.HasInforms(); }

	// Methods used during CSlob::SetupPropertyPages()
	int SetupPropertyPages(void);
	int AddPropertyPage(C3dPropertyPage* pPage, CSlob* pSlob);
	void SetCaption(LPCTSTR sz);
	BOOL AppendExtraPages(void);
	BOOL InhibitExtraPages(BOOL bInhibit = TRUE);
	int StartNewPageSet(void);
	int MergePageSets(void);
	CSize CalcMaxPageSize(BOOL bNewPages = FALSE);

	// please use the method GetCurrentPage rather than
	// access the m_pCurPage data directly .. the latter
	// may not be valid at all times!
	inline C3dPropertyPage* GetCurrentPage() { IdleUpdate(); return m_pCurPage; }

	int GetLevelComboHeight();

	C3dPropertyPage* m_pCurPage;
	CSlobPage m_noPage;
	CSlobPage m_nullPage;
	CSlobPage m_multiPage;

	// For pages which want to expand beyond their minimum size, if some other page
	// has already forced the sheet to be larger.
	// Set in C3dPropertyPage::SetupPage() ... the page can look at the value during
	// C3dPropertyPage::InitializePage() and change its size if desired.
	CSize m_sizePageMax;

protected:
	BOOL m_bInCancel:1;
	BOOL m_bSheetChanged:1;
	BOOL m_bValidating:1;
	BOOL m_bValidateEnabled:1;

	// This bool is true whenever the property window is the active app
	// window (still true if the property window was active when the
	// app was deactivated), or false if some other app window (usually
	// an MDI child, or the main frame) is active (or was when the app
	// was deactivated).
	BOOL m_bActive:1;

//	BOOL m_bExtraPagesAdded:1;	// used by AddOnExtraPages()
	int m_refInhibitExtraPages;	// ref-counts InhibitExtraPages

	CObList m_listCurPages;	// current list of pages for m_pCurSlob
	CObList m_listNewPages;	// list of pages m_pNewSlob adds with AddPropertyPage
	int m_nFirstPageSet;	// used when merging pages in m_listNewPages

	CTabRow m_tabRow;
	CPropFrameToolBar m_toolBar;

	HWND m_hwndFocusSave;	// HWND of the last control w/ focus.
	int m_iFocusSave;	// ID of the last control w/ focus.
	int m_iActiveTab;

	CSlob *m_pCurSlob;	// The currently attached editor
	CSlob *m_pNewSlob;	// Editor to attach at next idle moment
	CSheetWnd::SELSTYLE m_selState;
	CSheetWnd::SELSTYLE m_newSelState;
	int m_nCurPage;
	int m_nNewPage;

	CSheetSlob m_sheetSlob;

	CString m_strDefaultPage;

	CComboBox	m_cbLevel;
	int			m_cyRowHeight;

// Message handling
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	afx_msg void OnSysCommand(UINT nID, LONG lParam);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT nTimerID);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnIsError(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnValidateReq(WPARAM wParam, LPARAM lParam);
	
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);

	afx_msg void OnSelPage();

	afx_msg void CmdOkPage();
	afx_msg void CmdCancelPage();
	afx_msg void CmdNextPage();
	afx_msg void CmdPrevPage();

	afx_msg void OnCmdPushPin();
	afx_msg void OnCmdHelp();

	afx_msg void OnSelChangeLevel();

	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	
	DECLARE_MESSAGE_MAP()

	friend class CSheetSlob;
};

// Globals
extern CSheetWnd *g_PropSheet;
extern BOOL g_PropSheetVisible;

// Global helper functions
BOOL CreatePropertyBrowser();
void DestroyPropertyBrowser();
void PropPageIdle();

CSheetWnd* GetPropertyBrowser();
void SetPropertyBrowserSelection(CSlob* pSlob, int nPage = -1, 
	CSheetWnd::SELSTYLE style = CSheetWnd::editor); // select slob or NULL

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\shellrec.h ===
#ifndef __SHELLREC_H
#define __SHELLREC_H

/*

	Copyright 1996, Microsoft Corp.

	SHELLREC.H
		This header contains declarations for the CShellRecorder object, which
		manages macro recording for the shell.

	HISTORY

		08-23-96	CFlaat	Created in something like the current form.

*/

#include <aut1api.h>
#include <utilauto.h>

class CShellAction;


enum ShellElement
{ 
	FirstElement = 0,

	// Documents elements

	seSaveAll = FirstElement,
	FirstDocumentsElement = seSaveAll,
	LastDocumentsElement = seSaveAll,

	// Window elements
	seCloseWin,
	FirstWindowElement = seCloseWin,
	seNewWin,
	LastEditorElement = seNewWin,

	// Count of Elements
	ElementCount
};

enum ShellConst
{
	FirstConst = 0,
	scSaveChangesPrompt = FirstConst,
	scTrue,
	LastConst = scTrue
};

class CShellRecorder : public CGeneralRecorder
{
friend class CTheApp; // for initialization

protected: // data

	static const TCHAR * const szPkgName;
	static IMacroRecorder *m_pMacroRecorder; // REVIEW(CFlaat): is this a valid assumption?

	CShellAction *m_pCurrentShellAction;

protected: // methods

	void SetMacRec(IMacroRecorder *pMacRec) { VERIFY(m_pMacroRecorder = pMacRec); }
	IMacroRecorder *GetMacRec(void) const { ASSERT(m_pMacroRecorder); return m_pMacroRecorder; }

protected: // methods

	virtual LPCTSTR GetPkgName(void) const { return szPkgName; }
	void EmitCurrentAction(void);

public: // methods

	CShellRecorder(void);
	virtual ~CShellRecorder(void);

	BOOL InRecordingMode() const;

	void EmitPropertyAssignment(ShellElement eProperty, CRecArg &arg);
	void EmitParameterizedPropertyAssignment(ShellElement eProperty, CRecArg &param, CRecArg &value);

	void EmitMethodCall(ShellElement eMethod);
	void EmitMethodCall(ShellElement eMethod, CRecArg &arg1);
};


class CShellConstArg;

class CShellAction
{
public: // types

	enum ActionCat { acProperty = 1, acMethod = 2 }; // categories of actions (other things may come in the future)
	enum { MaxArgCount = 5 };

//protected: // data

	// this needs to be public until DS bug #4579 is resolved, letting us use friend templates
public: // data 

	CRecArg *m_aArgs[MaxArgCount];
	unsigned m_cArgs;
	ActionCat m_eCategory;
	ShellElement m_eElement;

protected: // methods

//	friend class CEditConstArg;

/*	friend template <class ValType, class ArgContainerType>
ValType GetArg(CEditAction *, unsigned, ValType, BOOL);

	friend template <class ValType, class ArgContainerType>
void SetArg(CEditAction *, unsigned int, ValType);*/


	void GetElementText(CString &str, LPCTSTR szParam = 0) const;

//	EditConst GetConstArg(unsigned iArg, EditConst ecDefault, BOOL bCreate = FALSE);
//	int GetIntArg(unsigned iArg, int nDefault, BOOL bCreate = FALSE);
//	LPCTSTR GetQuotedStringArg(unsigned iArg, LPCTSTR szDefault, BOOL bCreate = FALSE);

//	void SetIntArg(unsigned iArg, int nValue);
//	void SetQuotedStringArg(unsigned iArg, LPCTSTR szValue);

#ifdef _DEBUG
	void CheckZBArgType(int nIndex, const type_info & Type);
	void CheckArgCount(int nIndex);
	void CheckArgCountRange(int nLow, int nHigh);
	void VerifyCorrectness(void);
#endif

public: // methods

	CShellAction(ShellElement ee, ActionCat ac);
	CShellAction(ShellElement ee, ActionCat ac, CRecArg &arg1);
	CShellAction(ShellElement ee, ActionCat ac, CRecArg &arg1, CRecArg &arg2);
	CShellAction(ShellElement ee, ActionCat ac, CRecArg &arg1, CRecArg &arg2, CRecArg &arg3);

	~CShellAction(void); // make this virtual if we use polymorphism later on

	void GetText(CString &str); // gets the language-specific representation

};



// shell-specific arg types

class CShellRecorder;


class CShellConstArg : public CRecArg
{
protected: // data

	ShellConst m_scData;

private: // unused ctor

	CShellConstArg(void) { ASSERT(FALSE); } // this ctor shouldn't be used!!

public: // methods

	CShellConstArg(ShellConst scData) : m_scData(scData) {}

	virtual void GetText(CString &str);

	virtual CRecArg *Clone(void) { return new CShellConstArg(m_scData); }

	ShellConst GetValue(void) { return m_scData; }
};


extern CShellRecorder g_theShellRecorder;


#endif // __SHELLREC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\slobdrag.cpp ===
#include "stdafx.h"
#include "slob.h"
#include "mainfrm.h"
#include "bardockx.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


HCURSOR hcurNoDrop = NULL;
HCURSOR hcurArrow = NULL;


/////////////////////////////////////////////////////////////////////////////
// Drag and Drop Manager API

void BeginDragDrop(CPoint downPoint, CSlob* dragSlob)
{
	ASSERT(!IsDragDropInProgress());
	BeginDragDrop(new CDragNDrop(downPoint, dragSlob));
}

void BeginDragDrop(CDragNDrop* pInfo)
{
    VERIFY(((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop == pInfo);

	if (hcurNoDrop == NULL)
//		VERIFY((hcurNoDrop = LoadCursor(GetResourceHandle(), MAKEINTRESOURCE(IDC_DDNODROP))) != NULL);
		VERIFY((hcurNoDrop = theApp.LoadStandardCursor(IDC_NO)) != NULL);
	if (hcurArrow == NULL)
		VERIFY((hcurArrow = AfxGetApp()->LoadStandardCursor(IDC_ARROW)) != NULL);

    theApp.m_pMainWnd->SetCapture();
}

void CancelDragDrop()
{
	ASSERT(IsDragDropInProgress());
	((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop->AbortDrop();
	delete ((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop;
	((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop = NULL;

	ReleaseCapture();
}

BOOL IsDragDropInProgress()
{
	return ((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop != NULL;
}


/////////////////////////////////////////////////////////////////////////////
// Drag/Drop Handling in the main window

void CMainFrame::OnMouseMove(UINT nFlags, CPoint point)
{
    if (m_dragDrop == NULL || GetCapture() != this)
		CMDIFrameWnd::OnMouseMove(nFlags, point);
	else
    {
        ClientToScreen(&point);
        m_dragDrop->OnMouseMove(nFlags, point);
    }
}

void CMainFrame::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	OnLButtonDown(nFlags, point);
}

void CMainFrame::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (CASBar::s_pCustomizer != NULL)
		::MessageBeep(UINT(-1));
	else if (GetCapture() != this)
        CMDIFrameWnd::OnLButtonDown(nFlags, point);
    else
    {
        if (m_dragDrop != NULL)
            m_dragDrop->AbortDrop();

        EndDragDrop();
    }
}

void CMainFrame::OnRButtonDown(UINT nFlags, CPoint point)
{
    if (GetCapture() != this)
        CMDIFrameWnd::OnRButtonDown(nFlags, point);
    else
    {
        if (m_dragDrop != NULL)
            m_dragDrop->AbortDrop();

        EndDragDrop();
    }
}

void CMainFrame::OnLButtonUp(UINT nFlags, CPoint point)
{
    if (GetCapture() != this)
        CMDIFrameWnd::OnLButtonUp(nFlags, point);
    else
    {
        if (m_dragDrop != NULL)
        {
            ClientToScreen(&point);

            m_dragDrop->OnLButtonUp(nFlags, point);
        }

        EndDragDrop();
    }
}

void CMainFrame::OnRButtonUp(UINT nFlags, CPoint point)
{
    if (GetCapture() != this)
        CMDIFrameWnd::OnRButtonUp(nFlags, point);
    else
    {
        if (m_dragDrop != NULL)
        {
            ClientToScreen(&point);

			m_dragDrop->m_flags = nFlags;
			m_dragDrop->m_point = point;

            m_dragDrop->OnRButtonUp(nFlags, point);
        }

		// The menu menu probably took capture from us anyway, but this
		// will force us to abort the drag in idle if the user cancels
		// the menu.

		ReleaseCapture();
    }
}

void CMainFrame::OnDragMove()
{
	ASSERT (m_dragDrop != NULL);
	m_dragDrop->m_MoveCopy = CDragNDrop::dragMove;
	m_dragDrop->Drop(m_dragDrop->m_flags, m_dragDrop->m_point);
	EndDragDrop();
}

void CMainFrame::OnDragCopy()
{
	ASSERT (m_dragDrop != NULL);
	m_dragDrop->m_MoveCopy = CDragNDrop::dragCopy;
	m_dragDrop->Drop(m_dragDrop->m_flags, m_dragDrop->m_point);
	EndDragDrop();
}

void CMainFrame::OnDragCancel()
{
	ASSERT (m_dragDrop != NULL);

    m_dragDrop->AbortDrop();
	EndDragDrop();
}

void CMainFrame::EndDragDrop()
{
	if (m_dragDrop != NULL)
	{
		delete m_dragDrop;
		m_dragDrop = NULL;
	}

	ReleaseCapture ();
}

////////////////////////////////////////////////////////////////////////////
// CDragNDrop

CDragNDrop::CDragNDrop(CPoint downPoint, CSlob *dragSlob)
{
    ASSERT(dragSlob != NULL);
    
    ASSERT(((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop == NULL);
    ((CMainFrame*)theApp.m_pMainWnd)->m_dragDrop = this;

    m_dragSlob = dragSlob;
    m_dragInfo = NULL;

	CObList* pList = m_dragSlob->GetContentList();
	BOOL bMulti (pList != NULL && pList->GetCount() > 1);

    m_wLastKeyState = 0;

    // HACK to make sure that we go through the mousemove code at
    // least once
    m_target = (CSlob*)(-1);

	// we may get here before we get to the initialization in BeginDragDrop(),
	// so make sure we have a valid no-drop cursor before calling OnMouseMove
	if (hcurNoDrop == NULL)
//		VERIFY((hcurNoDrop = LoadCursor(GetResourceHandle(), MAKEINTRESOURCE(IDC_DDNODROP))) != NULL);
		VERIFY((hcurNoDrop = theApp.LoadStandardCursor(IDC_NO)) != NULL);

    m_lastPoint.x = -1;
    m_lastPoint.y = -1;
    m_downPoint = downPoint;

	m_MoveCopy = dragNotSet;

    OnMouseMove(0, m_downPoint);
}

CDragNDrop::~CDragNDrop()
{
    if (m_dragInfo)
        delete m_dragInfo;

    if ( m_dragSlob && m_dragSlob->GetContentList() )
        delete m_dragSlob;
}

BOOL CDragNDrop::IsCopy()
{
    // default behavior is to move unless the control key is down.
	// User's choice in dragdrop menu overrides.
    return (m_dragSlob->CanAct(act_copy)
		&&	(m_MoveCopy == dragCopy
			||	(m_MoveCopy == dragNotSet && (m_wLastKeyState & DD_CTRL) != 0)));
}

void CDragNDrop::OnLButtonUp(UINT nFlags, CPoint point)
{
	Drop(nFlags, point);
}

BEGIN_POPUP_MENU(DragDrop)
	MENU_ITEM_(ID_DRAG_MOVE, IDS_DRAG_MOVE)
	MENU_ITEM_(ID_DRAG_COPY, IDS_DRAG_COPY)
	MENU_SEPARATOR()
	MENU_ITEM_(ID_DRAG_CANCEL, IDS_DRAG_CANCEL)
END_POPUP_MENU()

void CDragNDrop::OnRButtonUp(UINT nFlags, CPoint point)
{
    if (m_dragInfo == NULL)
    {
        AbortDrop();
        return;
    }

#ifndef NO_CMDBARS
    TRACE2("CBShow: DragDrop (%s, %d)\r\n", __FILE__, __LINE__);
	::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(DragDrop), point); //DER
#else
	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(DragDrop), point);
#endif
}

void CDragNDrop::Drop(UINT nFlags, CPoint point)
{
    CWaitCursor waitCursor;

    // Make sure the point where going to use has been passed to 
    // OnMouseMove...
    if (point != m_lastPoint)
	{
        OnMouseMove(nFlags, point);
	}
    
    if (m_dragInfo == NULL || !m_target->PreAct(act_drop))
    {
        AbortDrop();
        return;
    }

    // need one last update to make sure that the keystate flag is
    // correct.
    IdleUpdate();

    // tell the last drop target to go ahead and make the drop
    CSlobWnd* pWnd = (CSlobWnd*)CWnd::WindowFromPoint(point);
    while (pWnd != NULL && !pWnd->IsKindOf(RUNTIME_CLASS(CSlobWnd)))
        pWnd = (CSlobWnd*)pWnd->GetParent();
    ASSERT(pWnd != NULL);
    ASSERT(pWnd->IsKindOf(RUNTIME_CLASS(CSlobWnd)));

    theApp.m_pMainWnd->SetActiveWindow();

    m_dragInfo->Hide();
	
	
	CSlobWnd* pSourceWnd = m_dragSlob->GetSlobWnd();
	CSlobWnd* pDestWnd = m_target->GetSlobWnd();
	
	ASSERT(pDestWnd != NULL);
	ASSERT(pDestWnd == pWnd);
	// NOTE: pSourceWnd is NULL when dragging from control palette
	
    CMultiSlob* pSelection = NULL;
    if (pSourceWnd != NULL)
        pSelection = (CMultiSlob*)pSourceWnd->GetSelection();
    if (pSelection != NULL &&
        !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
    {
        // no selection slob in the wnd
        pSelection = NULL;
    }

    CMultiSlob* pDestSelection = (CMultiSlob*)pDestWnd->GetSelection();
    if (pDestSelection != NULL &&
        !pDestSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
    {
        pDestSelection = NULL;
    }

	m_target->PrepareDrop(this);

    theUndoSlob.FlushLast(); // Don't coalesce D&D operations!

	CSlob* pDeleteThisSlob = NULL; // used for cross-window moves

    if (!m_dragSlob->GetContentList()->IsEmpty())
    {
		theApp.NotifyPackages(PN_BEGIN_MULTIOP);
		pDestWnd->BeginUndo((UINT) (IsCopy() ? IDS_UNDO_COPY : IDS_UNDO_MOVE));
		pDestWnd->EnableUpdates(FALSE);
        
        // Clear the selection (if there is one) so DoDrop 
        // can just Add everything
        if (pDestSelection != NULL)
            pDestSelection->Clear();
    
        ASSERT(m_target != NULL);
		
		if (pSourceWnd != pDestWnd && pSourceWnd != NULL)
		{
			// Clone the thing no matter what.  Drop the clone on the
			// destination and delete the original.  That way the undo
			// stacks will get set up correctly...
			
			CSlob* pClone = m_dragSlob->Clone();
			if (pClone != NULL)
			{
				m_target->DoDrop(pClone, m_dragInfo);

				if (pClone->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
					delete pClone;

				if (!IsCopy())
					pDeleteThisSlob = m_dragSlob;
			}
		}
		else // dropping in source window
		{
			if (!IsCopy())
			{
				m_target->DoDrop(m_dragSlob, m_dragInfo);
			}
			else
			{
				// Keep a pointer, so if the clone is really just a list
				// we can delete it, and avoid leaks.
				//
				CSlob* pClone = m_dragSlob->Clone();
				if (pClone != NULL)
				{
					m_target->DoDrop(pClone, m_dragInfo);

					if (pClone->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
						delete pClone;
				}
			}
		}
		theApp.NotifyPackages(PN_END_MULTIOP);
	}	

	FixupSelections(pSelection, pDestSelection);

    if (theUndoSlob.IsRecording())
    {
		pDestWnd->EnableUpdates(TRUE);
        pDestWnd->EndUndo();
        theUndoSlob.FlushLast();
    }
	
	// We did a cross-window move, so we need to delete the original
	// slob and record that in the source window's undo stack.
	if (pDeleteThisSlob != NULL)
	{
		ASSERT(pSourceWnd != NULL);
		theUndoSlob.Link();
		pSourceWnd->BeginUndo(IDS_UNDO_MOVE);
		pSourceWnd->EnableUpdates(FALSE);
		pDeleteThisSlob->MoveInto(NULL);
		pSourceWnd->EnableUpdates(TRUE);
		pSourceWnd->EndUndo();
	}
	
	ASSERT(!theUndoSlob.IsRecording());

    // Activate after doing the drop, so if we are doing dragging between
    // windows, the old window's toolbar gets updated to the new selection.
    //
	ActivateSlobWnd(pDestWnd);
	   
    m_target = NULL;
}

void CDragNDrop::FixupSelections(CMultiSlob* pSource, CMultiSlob* pDest)
{
    if (pDest != NULL)
        pDest->EnsureValidSelection();
    
    if (pSource != NULL && pSource != pDest)
        pSource->EnsureValidSelection();
}


void CDragNDrop::OnMouseMove(UINT nFlags, CPoint point)
{
    // Nasty hack here because Windows sends a continuous stream of
    // WM_MOUSEMOVE messages when a button is held down...
    if (point == m_lastPoint)
        return;
    m_lastPoint = point;

	BOOL bChange = FALSE;

    // get the drop target from the screen point and see if
    // it will accept the slob being dragged
    CSlob* newTarget = CSlob::DropTargetFromPoint (point);

	// walk up parent chain looking for a slob that will accept the drop.
	while (newTarget != NULL && newTarget != m_target &&
			!newTarget->CanAdd(m_dragSlob))
		newTarget = newTarget->GetContainer();

    // if the target has changed, delete the old dragInfo
    // and make a new one
    if (newTarget != m_target)
    {
        m_target = newTarget;
        if (m_dragInfo != NULL)
        {
            delete m_dragInfo;
            m_dragInfo = NULL;
        }

        if (m_target != NULL)
            m_dragInfo = m_target->CreateDragger(m_dragSlob, point);

		bChange = TRUE;
    }
    
	if (m_target != NULL && (nFlags & MK_RBUTTON) == 0)
    {
		WORD wKeyState  = 0;
		if (nFlags & MK_CONTROL)
			wKeyState |= DD_CTRL;
		if (nFlags & MK_SHIFT)
			wKeyState |= DD_SHIFT;

		if (wKeyState != m_wLastKeyState)
		{
			m_wLastKeyState = wKeyState;
			bChange = TRUE;
		}
    }

	if (bChange)	
		ChangeCursor();

    // tell the target about the drag
    if (m_target && m_dragInfo)
        m_target->DoDrag(m_dragSlob, m_dragInfo, point);
}

void CDragNDrop::ChangeCursor()
{
	CObList* pList = m_dragSlob->GetContentList();
	BOOL bMulti (pList != NULL && pList->GetCount() > 1);
	
	SetCursor(m_target == NULL ? hcurNoDrop : 
		(m_dragSlob->GetCursor(IsCopy() ? (bMulti ? DDC_COPY_MULTI : DDC_COPY_SINGLE) : 
			(bMulti ? DDC_MULTI : DDC_SINGLE))));
}

void CDragNDrop::AbortDrop()
{
    TRACE( "ABORTING Drag-Drop!\n" );

    // the following code restores the trackers on the source.
        
    if (m_dragInfo != NULL)
        m_dragInfo->Hide();

    CSlobWnd* pSrcWnd = m_dragSlob->GetSlobWnd();
	if (pSrcWnd == NULL)
		pSrcWnd = GetActiveSlobWnd();

    if (pSrcWnd != NULL)
    {
        pSrcWnd->OnSelChange();
		pSrcWnd->ShowSprites();
    }

    m_target= NULL;

    ::SetCursor(hcurArrow);
}

void CDragNDrop::IdleUpdate()
{
    // don't do anything if we don't have a drag slob or if
    // we haven't processed a mouse move yet, or this is not a left
	// mouse drag.

    if ((m_dragSlob != NULL) && GetKeyState(VK_LBUTTON) < 0 &&
		(m_target != (CSlob*)(-1)) && (m_target != NULL))
    {
        WORD wKeyState = 0;
		if (GetKeyState(VK_CONTROL) < 0)
			wKeyState |= DD_CTRL;
		if (GetKeyState(VK_SHIFT) < 0)
			wKeyState |= DD_SHIFT;

        if (wKeyState != m_wLastKeyState)
        {
            m_wLastKeyState = wKeyState;
			ChangeCursor();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\smenu.cpp ===
// menu.cpp : Management of menu bar and command hierarchy
//

#include "stdafx.h"

#include <ctype.h>

#include "package.h"
#include "shlmenu.h"
#include "mainfrm.h"
#include "bardockx.h"
#include "resource.h"
#include "barglob.h"
#include "cmduiena.h"
#include "toolexpt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// This little collection of macros determines the size of string buffer required to hold an unsigned short, excluding
// string terminator. It determines this at compile time, which means that it doesn't impose any retail runtime overhead.
// There is a runtime overhead in the debug build, because the string won't get optimised away in that one. However, this
// is completely portable to other limits.h settings. martynl 25Jun96
// makes a literal into a string
#define STRINGIZE(x) (# x)
// expands a macro and then makes that into a string
#define STRINGIZE_MACRO(x) STRINGIZE(x)
// determines the buffersize (excluding terminator) required by a numeric macro
#define BUFFERSIZE_MACRO(x) (sizeof(STRINGIZE_MACRO(x))-1)
#define COMMAND_ID_BUFFERSIZE BUFFERSIZE_MACRO(USHRT_MAX)

// define this to 1 to show trace messages on suspicious empty groups (groups which contain no commands in a particular execution of process commands). Useful for rooting out litter from the menu structures
#define FIND_EMPTY_GROUPS 0

// define this to 1 to show trace messages on suspicious commands (commands that don't belong to any group in a menu structure, but which don't have the no menu flag present). Useful for rooting out missing flags, but also happens validly
#define FIND_BAD_GROUPS 0

static char BASED_CODE szMenuKey[] = "Menu%x";
static char BASED_CODE szPackagesKey[] = "Packages";

//CObject
	class CCmdObject;
		class CCmd;
			class CCmdMenu;
		class CCmdGroup;
			class CMainGroup;	// A complete menu bar


#define ANYCMD ((WORD) -1)
#define ANYENABLEDCMD ((WORD) -2)

typedef CTypedPtrArray<CPtrArray, CCmdGroup *> CCmdGroupArray;

class CCmdObject : public CObject
{
public:
	// Since a group can appear in more than one menu, this now supports returning all groups in an array, or just the first group (bFirst==TRUE)
	virtual BOOL		FindGroups(WORD, CCmdGroupArray &groups, BOOL bFirst=FALSE) { return NULL; };
	virtual CCmd*		FindCmd(WORD) = 0;
	virtual int 		RebuildMenus(CMenu* pMenu) = 0;
	virtual int 		RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive) = 0;
};

class CCmd : public CCmdObject
{
public:
	CCmd(WORD id, WORD flags, WORD group, LPCTSTR sz);

	virtual CCmd*	FindCmd(WORD);
	virtual int 	RebuildMenus(CMenu* pMenu);
	virtual int 	RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive);

	LPCTSTR 	m_szMenu;
	CCmdGroup*	m_pParent;
	WORD m_id;
	WORD m_flags;
	WORD m_group;
};

class CCmdMenu : public CCmd
{
public:
						CCmdMenu(WORD id, WORD flags, WORD group, const CString &menuName, CPackage *pPackage);
	virtual				~CCmdMenu();
	virtual	BOOL		Add(CCmdGroup* pCmdGroup);
	virtual BOOL		FindGroups(WORD, CCmdGroupArray &groups, BOOL bFirst=FALSE);
	virtual CCmd*		FindCmd(WORD);
	virtual int 		RebuildMenus(CMenu* pMenu);
	virtual int 		RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive);
	virtual int			AddMenu(CBMenuPopup* pMenu);
	virtual void		AddItems(CBMenuPopup *pMenu, BOOL bRecursive);
	

	CObList	m_children;
	CPackage *m_pPackage;
	CString m_menuName; // (m_szMenu points at this)
};

class CCmdGroup : public CCmdObject
{
public:
						CCmdGroup(WORD id = -1);
	virtual				~CCmdGroup();
	virtual BOOL		Add(CCmd* pCmd, BOOL bFirst = FALSE);
	       	BOOL		IsRoot()
		   	    			{ return (m_pParent == NULL); };
	virtual BOOL		FindGroups(WORD, CCmdGroupArray &groups, BOOL bFirst=FALSE);
	virtual CCmd*		FindCmd(WORD);
	virtual int 		RebuildMenus(CMenu* pMenu);
	virtual int 		RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive);

	WORD		m_id;
	CObList 	m_children;
	CCmdMenu*	m_pParent;
};

// used when a separator appears literally in a menu (used only by OLE at the moment)
class CCmdGroupSeparator : public CCmdGroup
{
public:
						CCmdGroupSeparator(WORD id = -1);
	virtual				~CCmdGroupSeparator();
	virtual BOOL		Add(CCmd* pCmd, BOOL bFirst = FALSE);
	       	BOOL		IsRoot()
		   	    			{ return (m_pParent == NULL); };
	virtual BOOL		FindGroups(WORD, CCmdGroupArray &groups, BOOL bFirst=FALSE);
	virtual CCmd*		FindCmd(WORD);
	virtual int 		RebuildMenus(CMenu* pMenu);
	virtual int 		RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive);
};

class CMainGroup : public CCmdGroup
{
public:
						CMainGroup();
						~CMainGroup();
	virtual BOOL		Add(CCmd* pCmd);
	
	void BuildMenu(CMenu* pMenu);
	void BuildMenu(CBMenuPopup* pMenu);
	void BuildSingleMenu(CBMenuPopup *pMenu, int nCmdID);
	void ResetMenu(UINT nID, BOOL bRecurse=TRUE);
};

static HMENU hMenuWindow = NULL;

/////////////////////////////////////////////////////////////////////////////
// CCmd

CCmd::CCmd(WORD id, WORD flags, WORD group, LPCTSTR sz)
{
    ASSERT(id != -1);   // reserved value
    m_szMenu = sz;
    m_pParent = NULL;
    m_id = id;
    m_flags = flags;
    m_group = group;
}

int CCmd::RebuildMenus(CMenu* pMenu)
{
    ASSERT(m_pParent != NULL);
	ASSERT(m_szMenu != NULL);
    
	CString strItem = m_szMenu;
	CString strKey;
	if (GetCmdKeyString(m_id, strKey))
	{
		strItem += '\t';
		strItem += strKey;
	}
    pMenu->AppendMenu(MF_STRING | MF_GRAYED, m_id, strItem);
    return 1;
}

int CCmd::RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive)
{
    ASSERT(m_pParent != NULL);
	ASSERT(m_szMenu != NULL);
    
	CString strItem = m_szMenu;
	CString strKey;
	if (GetCmdKeyString(m_id, strKey))
	{
		strItem += '\t';
		strItem += strKey;
	}
    pMenu->AppendMenu(MF_STRING | MF_GRAYED, m_id, strItem);
    return 1;
}

CCmd* CCmd::FindCmd(WORD id)
{
    if ((id == m_id) || (id == (WORD) ANYCMD) || (id == (WORD) ANYENABLEDCMD))
        return this;
    
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CCmdMenu

CCmdMenu::CCmdMenu(WORD id, WORD flags, WORD group, const CString &menuName, CPackage *pPackage)
    :	CCmd(id, flags, group, NULL)
{
	m_menuName=menuName;
	m_szMenu=(LPCTSTR)m_menuName;
	m_pPackage=pPackage;
}

CCmdMenu::~CCmdMenu()
{
    CCmdGroup* pGroup;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pGroup = (CCmdGroup*) m_children.GetNext(pos);
        delete pGroup;
    }
}

BOOL CCmdMenu::Add(CCmdGroup* pCmdGroup)
{
    ASSERT(pCmdGroup->m_pParent == NULL);
    
    pCmdGroup->m_pParent = this;
    m_children.AddTail(pCmdGroup);
    return TRUE;
}

BOOL CCmdMenu::FindGroups(WORD idGroup, CCmdGroupArray &groups, BOOL bFirst)
{
    CCmdGroup* pGroup;
    BOOL bFound=FALSE;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pGroup = (CCmdGroup*) m_children.GetNext(pos);
        bFound |= pGroup->FindGroups(idGroup, groups, bFirst);
		if(bFirst && bFound)
		{
			return TRUE;
		}
    }
    
    return bFound;
}

CCmd* CCmdMenu::FindCmd(WORD id)
{
	if(id==m_id)
	{
		return this;
	}

    CCmdGroup* pGroup;
    CCmd* pFound;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pGroup = (CCmdGroup*) m_children.GetNext(pos);
        if ((pFound = pGroup->FindCmd(id)) != NULL)
            return pFound;
    }
    
    return NULL;
}

int CCmdMenu::RebuildMenus(CMenu* pMenu)
{
	if(m_pPackage)
	{
		if(m_pPackage->IsMenuVisible(m_id)==FALSE)
		{
			return 0;
		}
	}

	ASSERT(m_pPackage!=NULL);
    ASSERT(m_pParent != NULL);
    
    CMenu menuPopup;
    menuPopup.CreateMenu();
    
    CCmdGroup* pGroup;
	int nPrevGroup=0;

    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pGroup = (CCmdGroup*) m_children.GetNext(pos);
        ASSERT(pGroup->m_pParent == this);

        if (pGroup->FindCmd(ANYCMD) != NULL)
        {
            // Add separator if needed
            if (nPrevGroup!=0 && ((nPrevGroup & 1) == 0))
                menuPopup.AppendMenu(MF_SEPARATOR);
            pGroup->RebuildMenus(&menuPopup);
            nPrevGroup = pGroup->m_id;
        }
		else
		{
#if FIND_EMPTY_GROUPS
			TRACE1("CCmdMenu::RebuildMenus: Empty group suspect %d found\n\r", pGroup->m_id);
#endif
		}
    }

    UINT flags = MF_POPUP;
    if (FindCmd(ANYENABLEDCMD) == NULL)
    {
        if (FindCmd(ANYCMD) == NULL)
            return 0;
        else
            flags = MF_POPUP | (m_pParent->IsRoot() ? 0 : MF_GRAYED);
    }
    
	CString strMenu;
	if (m_szMenu[0] == _T('\0'))
		strMenu = " ";
	else
		strMenu = m_szMenu;
    pMenu->AppendMenu(flags, (UINT)menuPopup.m_hMenu, strMenu);

	if (m_id==IDM_MENU_WINDOW)
		hMenuWindow = menuPopup.m_hMenu;

    menuPopup.Detach(); // So popup won't be destroyed on scope exit.

    return 1;
}

int CCmdMenu::AddMenu(CBMenuPopup* pMenu)
{
	CString strMenu;
	if (m_szMenu == NULL)
		strMenu = " ";
	else
		strMenu=m_szMenu;
	// append this as a deferred action popup
    pMenu->AppendMenu(MF_POPUP, m_id, strMenu);

	return 1;
}

void CCmdMenu::AddItems(CBMenuPopup* pMenu, BOOL bRecursive)
{
	ASSERT(m_pParent != NULL);

	CCmdGroup* pGroup;
	int nPrevGroup = 0;

	POSITION pos = m_children.GetHeadPosition();
	while (pos != NULL)
	{
		pGroup = (CCmdGroup*) m_children.GetNext(pos);
		ASSERT(pGroup->m_pParent == this);

		if (pGroup->FindCmd(ANYCMD) != NULL)
		{
			// Add separator if needed
            if (nPrevGroup!=0 && ((nPrevGroup & 1) == 0))
				pMenu->AppendMenu(MF_SEPARATOR);
			pGroup->RebuildMenus(pMenu, bRecursive);
			nPrevGroup = pGroup->m_id;
		}
		else
		{
#if FIND_EMPTY_GROUPS
			TRACE1("CCmdMenu::AddItems: Empty group suspect %d found\n\r", pGroup->m_id);
#endif
		}
	}
}

int CCmdMenu::RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive)
{
	// if this menu can be loaded, we should do that
	ASSERT(CDockWorker::s_lpszLayoutSection != NULL);

	CBMenuPopup *menuPopup=new CBMenuPopup;
	menuPopup->CreateMenu();
	menuPopup->SetAutoEnable(TRUE);

	AddItems(menuPopup, bRecursive);
    
	AddMenu(pMenu);
    
	theCmdCache.SetMenu(m_id, menuPopup);

    return 1;
}

/////////////////////////////////////////////////////////////////////////////
// CCmdGroup

CCmdGroup::CCmdGroup(WORD id)
{
    m_id = id;
    m_pParent = NULL;
}

CCmdGroup::~CCmdGroup()
{
    CCmd* pItem;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pItem = (CCmd*) m_children.GetNext(pos);
        delete pItem;
    }
}

BOOL CCmdGroup::Add(CCmd* pCmd, BOOL bFirst /*=FALSE*/)
{
    ASSERT(pCmd->m_pParent == NULL);

    pCmd->m_pParent = this;
    if (bFirst)
        m_children.AddHead(pCmd);
    else
        m_children.AddTail(pCmd);
    return TRUE;
}

BOOL CCmdGroup::FindGroups(WORD idGroup, CCmdGroupArray &groups, BOOL bFirst)
{
	// if this is one of them
    if (idGroup == m_id)
	{
		// add it to the array
		groups.Add(this);

		if(bFirst)
		{
			return TRUE;
		}
	}

    CCmd* pItem;
    BOOL bFound=FALSE;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pItem = (CCmd*) m_children.GetNext(pos);
        bFound|=pItem->FindGroups(idGroup, groups, bFirst);
		if(bFirst && bFound)
		{
			return TRUE;
		}
    }
    
    return bFound;
}

CCmd* CCmdGroup::FindCmd(WORD id)
{
    CCmd* pItem;
    CCmd* pFound;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pItem = (CCmd*) m_children.GetNext(pos);
        if ((pFound = pItem->FindCmd(id)) != NULL)
            return pFound;
    }
    
    return NULL;
}

int CCmdGroup::RebuildMenus(CMenu* pMenu)
{
    // Iterate through all child CmdItems and add them to the menu
    int count = 0;
    CCmd* pCmd;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pCmd = (CCmd*) m_children.GetNext(pos);
        ASSERT(pCmd->m_pParent == this);
        count += pCmd->RebuildMenus(pMenu);
    }

    // return total number of command items added
    return count;
}

int CCmdGroup::RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive)
{
    // Iterate through all child CmdItems and add them to the menu
    int count = 0;
    CCmd* pCmd;
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        pCmd = (CCmd *)(m_children.GetNext(pos));
        ASSERT(pCmd->m_pParent == this);
		if(pCmd->m_flags & CT_MENU)
		{
			// don't recurse down into submenus, just add this to menu
			count += ((CCmdMenu *)pCmd)->AddMenu(pMenu);
		}
		else
		{
			count += pCmd->RebuildMenus(pMenu, bRecursive);
		}
    }

    // return total number of command items added
    return count;
}

/////////////////////////////////////////////////////////////////////////////
// CCmdGroupSeparator

CCmdGroupSeparator::CCmdGroupSeparator(WORD id) : CCmdGroup(id)
{
}

CCmdGroupSeparator::~CCmdGroupSeparator()
{
}

BOOL CCmdGroupSeparator::Add(CCmd* pCmd, BOOL bFirst /*=FALSE*/)
{
	// can't add to a separator
	ASSERT(FALSE);
    return TRUE;
}

BOOL CCmdGroupSeparator::FindGroups(WORD , CCmdGroupArray &, BOOL)
{
	return FALSE;
}

CCmd* CCmdGroupSeparator::FindCmd(WORD id)
{
    return NULL;
}

int CCmdGroupSeparator::RebuildMenus(CMenu* pMenu)
{
	pMenu->AppendMenu(MF_SEPARATOR);

    // return total number of command items added
    return 1;
}

int CCmdGroupSeparator::RebuildMenus(CBMenuPopup* pMenu, BOOL bRecursive)
{
	pMenu->AppendMenu(MF_SEPARATOR);
    return 1;
}

/////////////////////////////////////////////////////////////////////////////
//	Class CMainGroup

CMainGroup::CMainGroup() :
    CCmdGroup()
{
}

CMainGroup::~CMainGroup()
{
}

BOOL CMainGroup::Add(CCmd* pCmd)
{
    // At present, we only support pCmdMenu addition
    CCmdMenu* pCmdMenu = (CCmdMenu*) pCmd;

    ASSERT(pCmdMenu->m_pParent == NULL);
    pCmdMenu->m_pParent = this;
    m_children.AddTail(pCmdMenu);
    
    return TRUE;
}

void CMainGroup::BuildMenu(CMenu* pMenu)
{
    CCmdGroup* pCmdGroup;
    CCmdMenu* pMainMenu;
    
	// child of the main group is the main menu bar
    POSITION mainpos = m_children.GetHeadPosition();
	pMainMenu = (CCmdMenu*) m_children.GetNext(mainpos);

	POSITION pos =pMainMenu->m_children.GetHeadPosition();
	
    while (pos != NULL)
    {
        // At present, we only support pCmdMenu addition
        pCmdGroup = (CCmdGroup*) pMainMenu->m_children.GetNext(pos);
        ASSERT(pCmdGroup->m_pParent == pMainMenu);

        pCmdGroup->RebuildMenus(pMenu);
    }
}

void CMainGroup::BuildMenu(CBMenuPopup* pMenu)
{
    CCmdMenu* pCmdMenu;
    
    POSITION pos = m_children.GetHeadPosition();
    while (pos != NULL)
    {
        // At present, we only support pCmdMenu addition
        pCmdMenu = (CCmdMenu*) m_children.GetNext(pos);
        ASSERT(pCmdMenu->m_pParent == this);

        pCmdMenu->RebuildMenus(pMenu, TRUE);
    }
}

void CMainGroup::BuildSingleMenu(CBMenuPopup *pMenu, int nCmdID)
{
	CCmdMenu* pCmdMenu=(CCmdMenu *)(FindCmd((WORD)nCmdID));

	if(pCmdMenu)
	{
		ASSERT(pCmdMenu->m_flags & CT_MENU);

		pCmdMenu->AddItems(pMenu, FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame menu stuff

void CCmdCache::AddPopToGroup(POPDESC* ppop, CCmdGroup* pGroup)
{
	CTE* pCTE = GetCommandEntry(ppop->cmdID);

	LPCTSTR pszMenu;
	VERIFY(GetCommandString(ppop->cmdID, STRING_MENUTEXT, &pszMenu));
	CString menuName=pszMenu;
	CCmdMenu* pCmdMenu = new CCmdMenu(pCTE->id, pCTE->flags, pCTE->group, menuName, pCTE->GetPack()->GetPackage());
	pGroup->Add(pCmdMenu);
	
	MTM* pmtm = &ppop->rgmtm[0];
	UINT idLast = 0;
	CCmdGroup* pCmdGroupLast = NULL;
	while (pmtm->id != 0)
	{
		if(pmtm->id==POP_SEPARATOR)
		{
			pCmdGroupLast = new CCmdGroupSeparator((WORD)pmtm->id);
			pCmdMenu->Add(pCmdGroupLast);
			idLast = pmtm->id;
		}
		else
		{
			if (pmtm->id != idLast)
			{
				pCmdGroupLast = new CCmdGroup((WORD)pmtm->id);
				pCmdMenu->Add(pCmdGroupLast);
				idLast = pmtm->id;
			}

			if (pmtm->ppop != NULL)
			{
				ASSERT(pCmdGroupLast != NULL);
				ASSERT(pmtm->ppop != NULL); // duplicate group id in popup?
				AddPopToGroup(pmtm->ppop, pCmdGroupLast);
			}
			// search all the menus in the command table for any menus in the specified group, and add them
			for (int i = 0; i < m_rgMenuCommands.GetSize() ; i++)
			{
				ASSERT(m_rgMenuCommands[i]<theCmdCache.m_cCommands);

				pCTE = &m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

				ASSERT(pCTE);
				ASSERT(pCTE->flags & CT_MENU);

				if(pCTE->group == pmtm->id)
				{
					ASSERT(pCTE->GetPack());
					ASSERT(pCTE->GetPack()->GetPackage());

					POPDESC *pPopDesc=pCTE->GetPack()->GetPackage()->GetMenuDescriptor(pCTE->id);

					ASSERT(pPopDesc);
					AddPopToGroup(pPopDesc, pCmdGroupLast);
				}
			}
		}
		pmtm++;
	}
}

void CCmdCache::ProcessCommands(CMainGroup* pMainGroup, BOOL bRestrict, BOOL bOLE, BOOL bMenuOnly)
{
	POPDESC* pBarPopDesc;
	if(bOLE)
	{
		pBarPopDesc=theApp.GetMenuDescriptor(IDM_MENU_OLEBAR);
	}
	else
	{
		pBarPopDesc=theApp.GetMenuDescriptor(IDM_MENU_BAR);
	}

	AddPopToGroup(pBarPopDesc, pMainGroup);

	// Add menuitems.
    CTE* pCTE;
    CCmdGroup* pGroup;
	CPacket* pPack;
	
	for (int i = 0; i < m_cCommands; i++)
	{
		pCTE = &m_rgCommands[i];

		if(bMenuOnly)
		{
			if (pCTE->flags & CT_NOMENU)
				continue;
		}

		if ((pCTE->flags & (CT_NOUI | CT_MENU)) != 0)
			continue;

		if(bRestrict)
		{
			// when building traditional menu, leave off querymenu menus
			if ((pCTE->flags & CT_QUERYMENU) != 0)
				continue;

			if(!pCTE->IsActive())
			{
				continue;
			}
		}

		// Find all groups associated with this command 
		CCmdGroupArray rgGroups;
		pMainGroup->FindGroups(pCTE->group, rgGroups);

		// now iterate over them
		int nGroups=rgGroups.GetSize();
		for(int iGroup=0; iGroup<nGroups; ++iGroup)
		{
			CCmdGroup *pGroup=rgGroups[iGroup];

			LPCTSTR lpszText = NULL;
			theCmdCache.GetCommandString(pCTE->id, STRING_MENUTEXT, &lpszText, NULL, pCTE);

			// add the command to the group
			pGroup->Add(new CCmd(pCTE->id, pCTE->flags, pCTE->group, lpszText),	pCTE->flags & CT_TOP);

		}

		if(nGroups==0 && !bOLE)
		{
			// This warning means somebody tried to use a command group which doesn't 
			// exist on any menu.  Perhaps they intended to use the CT_NOMENU flag?

			// Another cause of this can be a command that's on the menu in a different EXE, such as some infoviewer commands.
			// Known instances of this are special-cased here:
			if(	pCTE->group!=IDG_IV_TOOLS_SEARCH &&
				pCTE->group!=IDG_IV_HELP_CONTENTS &&
				pCTE->group!=IDG_IV_HELP_ABOUT)
			{
#if FIND_BAD_GROUPS
				TRACE1("CCmdCache::ProcessCommands: Unexpected group %d\n", pCTE->group);
#endif
			}
		}
    }
}

HMENU GetCommandMenu(BOOL bOleIPMenu)
{
	if (Menu::IsShowingCmdBars() && !bOleIPMenu)	//OLD_MENU
	{
		// We are currently in command bar mode, so we will just be polite
		// and return NULL.
		return NULL ;
	}

	CMainGroup mainGroup;
    theCmdCache.ProcessCommands(&mainGroup, TRUE, bOleIPMenu);
    
    CMenu menuBar;
    menuBar.CreateMenu();
    
    mainGroup.BuildMenu(&menuBar);

    return menuBar.Detach();
}

// Apply flags now fixes a deeply devious bug. Imagine that you have a menu M that contains a package specific menu P1. You
// customize P1 to contain menu O. Then you restart devstudio with P1 not loaded. You then customize O to contain M. Next
// time you restart devstudio, your menus are in a cycle. In this case, we break the cycle at an arbitrary point (the point furthest from the 
// top left of the menu bar, depth first.

// applys invisibility flags to a menu, recursing as appropriate. Fixes any broken recursive menus. 
// Never counts the same menu twice.

// In debug builds, this routine now checks for duplicate mnemonic letters in non-customized menus. Customized menus are omitted (because they
// could have been duplicated by users). Only visible commands are checked, which allows two different editors to use the same mnemonic, potentially

#ifdef _DEBUG
#define CHECK_MNEMONICS 1
#else
#define CHECK_MNEMONICS 0
#endif

static BOOL ApplyFlags(UINT nIDMenu, BOOL bAllEditors, BOOL bAllProjects, BOOL bEmptyMenus)
{
	CBMenuPopup *pPopup=theCmdCache.GetMenu(nIDMenu);
	CASBar *pMenuBar=CASBar::GetMenuBar();

#if CHECK_MNEMONICS
	BOOL abLetterUsed[26];					// One bool for each letter. TRUE if the letter is used
	for(int i=0; i<(sizeof(abLetterUsed)/sizeof(BOOL)); ++i)
	{
		abLetterUsed[i]=FALSE;
	}
#endif

	// should be unknown to start with
	ASSERT(pPopup->m_nVisibleItems==-1);

	// stop any infinite recursion
	pPopup->m_nVisibleItems=-2;

	// so now we need to decide which items are visible
	int nVisibleItems=0;

	BOOL bBarModified=FALSE;

	CTE *pCTE=theCmdCache.GetCommandEntry(nIDMenu);
	CPackage *pPackage=NULL;
	if(	pCTE &&													// All menus should have a CTE
		pCTE->GetPack() &&										// and a pack
		(pPackage=pCTE->GetPack()->GetPackage())!=NULL &&		// and a package, but let's be safe
		pPackage->IsMenuVisible(nIDMenu)==FALSE)				// check if it's currently hidden
	{
		nVisibleItems=0;
	}
	else
	{
		int nLastVisibleItem=-1;
		int nLastSeparator=-1;

		for(int iItem=0;iItem<pPopup->GetCount(); ++iItem)
		{
			CBMenuItem *pItem=pPopup->GetMenuItem(iItem);

			BOOL bVisible=TRUE;

			if(pItem)
			{
				if(	pItem->m_pCTE &&
					pItem->m_pCTE->flags & CT_MENU)
				{
					// a submenu
					CBMenuPopup *pMenu=theCmdCache.GetMenu(pItem->m_pCTE->id);
					if(pMenu)
					{
						switch(pMenu->m_nVisibleItems)
						{
							case -2:
								// circular menu structure
								// We remove the cycle by cutting out this item
								pMenu->DeleteMenu(MF_BYPOSITION, iItem);

								// then decrement i so that we don't skip an item
								--iItem;

								// and continue the for loop since pItem is now invalid
								continue;

							case -1:
								// uncalculated menu
								bBarModified|=ApplyFlags(pItem->m_pCTE->id, bAllEditors, bAllProjects, bEmptyMenus);
								// must have counted now
								ASSERT(pMenu->m_nVisibleItems>=0);
								if(pMenu->m_nVisibleItems==0)
								{
									if(bEmptyMenus && pMenu->GetMenuItemCount()==0 && (pMenu->IsDirty() || (pItem->m_pCTE->id>=IDM_CUSTOMMENU_BASE && pItem->m_pCTE->id<=IDM_CUSTOMMENU_LAST)))
									{
										// A menu is visible if we're showing empty menus and it's an empty custom menu
										bVisible=TRUE;
									}
									else
									{
										bVisible=FALSE;
									}
								}
								break;

							case 0:
								// we already know this is empty
								if(bEmptyMenus && pMenu->GetMenuItemCount()==0 && (pMenu->IsDirty() || (pItem->m_pCTE->id>=IDM_CUSTOMMENU_BASE && pItem->m_pCTE->id<=IDM_CUSTOMMENU_LAST)))
								{
									// A menu is visible if we're showing empty menus and it's an empty custom menu
									bVisible=TRUE;
								}
								else
								{
									bVisible=FALSE;
								}
								break;

							default:
								if(pMenu->m_nVisibleItems>0)
								{
									// we already know this is used and visible
								}
								else
								{
									ASSERT(FALSE);
								}
								break;
						}

					}
					else
					{
						bVisible=FALSE;
					}
				}
				else
				{
					if( pItem->GetItemType()==CBMenuItem::MIT_Separator)
					{
						if(nLastVisibleItem==nLastSeparator)
						{
							bVisible=FALSE;
						}
						else
						{
							nLastSeparator=iItem;
						}
					}
					else
					{
						if(	pItem->m_pCTE &&
							pItem->m_pCTE->GetPack())
						{
							// suppress QUERYMENU items
							if(pItem->m_pCTE->flags & CT_QUERYMENU)
							{
								if(	(pItem->m_pCTE->flags & CT_PROJECT_DEPENDENT)!=0 &&
									bAllProjects)
								{
									// If we're showing all projects, then ignore the query menu that invisible project dependant commands have
									bVisible=TRUE;
								}
								else
								{
									bVisible=FALSE;
								}
							}

							// otherwise, suppress for wrong packet
							if(	!bAllEditors && 
								!pItem->m_pCTE->IsActive())
							{
								bVisible=FALSE;
							}

							// if it's visible, update its accelerator
							if(bVisible)
							{
								if(bAllEditors)
								{
									// when we're showing menus from all editors, there's no definitive set of keys, so don't show them.
									pItem->SetAccelerator("", FALSE);
								}
								else
								{
									// find out short cut
									CString strKey;
									if (GetCmdKeyString(pItem->m_pCTE->id, strKey))
									{
										// update in item, saving recalc for later
										pItem->SetAccelerator(strKey, FALSE);
									}
									else
									{
										// update in item, saving recalc for later
										pItem->SetAccelerator(NULL, FALSE);
									}

								}
							}
						}
						else
						{
							// no CTE implies the menu item belongs to an absent package
							bVisible=FALSE;
						}
					}
				}
			}

			if(!bVisible)
			{
				pItem->m_bVisible=FALSE;
			}
			else
			{
				nLastVisibleItem=iItem;
				pItem->m_bVisible=TRUE;
				if( pItem->GetItemType()!=CBMenuItem::MIT_Separator)
				{
					++nVisibleItems;

					// If item has been modified since last rebuild, we need to update its text
					if(pItem->IsTextModified() && pItem->m_nCmdID != 0)
					{
						LPCTSTR lpszMenuText=NULL;

						// get the default menu text
						VERIFY(theCmdCache.GetCommandString(pItem->m_nCmdID, STRING_MENUTEXT, &lpszMenuText, NULL, pItem->m_pCTE));

						// ensure it wasn't empty
						ASSERT(lpszMenuText[0]!='\0');
	
						// reset the menu text
						pItem->SetText(lpszMenuText);
						pItem->SetTextModified(FALSE);
					}
#if CHECK_MNEMONICS
					// don't check in all editors mode (clashes are bound to happen), or when the menu has been customized
					if(!bAllEditors && !pPopup->IsDirty())
					{
						// ignore disabled commands
						CCmdUIEnable state;
						state.m_nID = pItem->m_pCTE->id;
						state.DoUpdate(AfxGetApp()->m_pMainWnd, TRUE);

						if(state.m_bEnabled)
						{
							// ensure that this item isn't a duplicate of any other
							char chAccel=GLOBAL_DATA::ExtractAccelerator(pItem->GetName());

							if(isalpha(chAccel))
							{
								char chLower=(char)tolower(chAccel);

								int nIndex=chLower-'a';

								// FAILURES imply some kind of logic error, or a strange locale is in force
								ASSERT(nIndex>=0);		
								ASSERT(nIndex<(sizeof(abLetterUsed)/sizeof(BOOL)));

								if(nIndex>=0 && nIndex<(sizeof(abLetterUsed)/sizeof(BOOL)))
								{
									// If this fails, then the menu being built contains the same accelerator twice. You should fix it in the command table
									// or ccmdui handler. We don't make any attempt to fix this up, since this is a debug-only check.
									ASSERT(abLetterUsed[nIndex]==FALSE);

									// this mnemonic has now been used.
									abLetterUsed[nIndex]=TRUE;
								}
							}
						}
					}
#endif
				}
			}
			pItem->m_bNeedToCalculateSizes=TRUE;
		}
		// remove bogus last separator
		if(nLastVisibleItem==nLastSeparator &&
			nLastVisibleItem!=-1)
		{
			CBMenuItem *pItem=pPopup->GetMenuItem(nLastVisibleItem);
			pItem->m_bVisible=FALSE;
		}
		pPopup->CalcMenuSize();
	}

	// A menu is visible if it has visible items, or if we're showing empty menus and it's an empty custom menu
	BOOL bVisible=(nVisibleItems>0) || (bEmptyMenus && pPopup->GetMenuItemCount()==0 && (pPopup->IsDirty() || (nIDMenu>=IDM_CUSTOMMENU_BASE && nIDMenu<=IDM_CUSTOMMENU_LAST)));

	pPopup->m_nVisibleItems=nVisibleItems;

	return bBarModified;
}

static HMENU s_hOleMenu = NULL;

void CMainGroup::ResetMenu(UINT nID, BOOL bRecurse /*=TRUE*/)
{
	// build the menu from scratch
	CBMenuPopup *pMenu=new CBMenuPopup;
	pMenu->CreateMenu();
	pMenu->SetAutoEnable(TRUE);
	BuildSingleMenu(pMenu, nID);

	// Don't need to delete the old one - cmdcache will do it for us
	theCmdCache.SetMenu(nID, pMenu);

	// prepare to recalculate visibility
	pMenu->m_nVisibleItems=-1;

	// only do submenus if requested
	if(bRecurse)
	{
		// now reset all of its children
		int nItems=pMenu->GetMenuItemCount();
		for(int iItem=0;iItem<nItems; ++iItem)
		{
			CBMenuItem *pItem=pMenu->GetMenuItem(iItem);

			if(	pItem &&
				pItem->m_pCTE &&
				pItem->m_pCTE->flags & CT_MENU)
			{
				ResetMenu(pItem->m_pCTE->id);
			}
		}
	}
}

// resets a single menu to its default state
void CMainFrame::ResetMenu(UINT nID)
{
	// In debug, check that this is only being called for a menu
#ifdef _DEBUG
	{
		CTE *pCTE=NULL;
		ASSERT((pCTE=theCmdCache.GetCommandEntry(nID))!=NULL);
		ASSERT(pCTE->flags & CT_MENU);
	}
#endif

	// reprocess all of the commands - time consuming!
	CMainGroup mainGroup;
	theCmdCache.ProcessCommands(&mainGroup, FALSE);

	mainGroup.ResetMenu(nID);

	// now apply invisibility flags to the menu, and all of its current submenus
	ApplyFlags(nID, FALSE, FALSE, FALSE);
}

// resets a single menu to its default state
void CMainFrame::ResetAllMenus()
{
	CASBar::CancelMenu();

	// reprocess all of the commands - time consuming!
	CMainGroup mainGroup;
	theCmdCache.ProcessCommands(&mainGroup, FALSE);

	// search all the menus in the command table for any menus
	for (int i = 0; i < theCmdCache.m_rgMenuCommands.GetSize() ; i++)
	{
		ASSERT(theCmdCache.m_rgMenuCommands[i]<theCmdCache.m_cCommands);

		CTE *pCTE = &theCmdCache.m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

		ASSERT(pCTE);
		ASSERT(pCTE->flags & CT_MENU);

		mainGroup.ResetMenu(pCTE->id, FALSE);
	}

	// now apply invisibility flags to the menus
	RebuildMenus();
}

// fills a list box with all commands that are missing from the menus
void CMainFrame::FillDeletedMenuItemList(CListBox *pList)
{
	// don't reprocess all of the commands until we know we need them
	CMainGroup *pMainGroup=NULL;

	// iterate over all menus
	for (int i = 0; i < theCmdCache.m_rgMenuCommands.GetSize() ; i++)
	{
		ASSERT(theCmdCache.m_rgMenuCommands[i]<theCmdCache.m_cCommands);

		CTE *pCTE = &theCmdCache.m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

		// Now work out what is missing from this menu
		CBMenuPopup *pMenuCurrent=theCmdCache.GetMenu(pCTE->id);
		ASSERT(pMenuCurrent);

		// don't bother to compare if the menu hasn't been customized
		if(pMenuCurrent->IsDirty())
		{
			// reprocess all the commands. Time consuming, but the only way to work out the defaults
			if(pMainGroup==NULL)
			{
				pMainGroup=new CMainGroup;
				theCmdCache.ProcessCommands(pMainGroup, FALSE);
			}

			// Create a 'reset' menu to compare with the current one
			CBMenuPopup *pMenuDefault=new CBMenuPopup;
			pMenuDefault->CreateMenu();
			pMainGroup->BuildSingleMenu(pMenuDefault, pCTE->id);

			if(	pMenuCurrent && // just to be safe
				pMenuDefault)
			{
				// Now we have to compare the two menus. We iterate over the default menu, searching for each command in the
				// current menu. Since the current menu has probably not changed much, we start looking for the next command
				// just after where we found the previous one. This will tend to mean that the whole comparison isn't too slow.

				// This is the item we start looking at in the current menu
				int iInitialCurrentItem=0;

				// count of items in both menus
				int nCurrentItems=pMenuCurrent->GetMenuItemCount();
				int nDefaultItems=pMenuDefault->GetMenuItemCount();

				// iterate over default menu
				for(int iDefaultItem=0; iDefaultItem<nDefaultItems; ++iDefaultItem)
				{
					UINT nDefaultId=pMenuDefault->GetMenuItemID(iDefaultItem);

					// if it's not a separator or in some other way dud.
					if(nDefaultId!=0)
					{
						// iterate over current menu
						int iCurrentItem=iInitialCurrentItem;

						BOOL bFound=FALSE;

						do
						{
							UINT nCurrentId=pMenuCurrent->GetMenuItemID(iCurrentItem);

							// if it's the same as the one in the default menu, we just found it.
							if(nCurrentId==nDefaultId)
							{
								bFound=TRUE;
							}

							// move to next item to check; wrap around, since we don't always start at 0.
							++iCurrentItem;
							if(iCurrentItem>=nCurrentItems)
							{
								iCurrentItem=0;
							}

							// if we just found it, then the current index value is the value to start at next time.
							if(bFound)
							{
								iInitialCurrentItem=iCurrentItem;
							}
						}
						while(!bFound && iCurrentItem!=iInitialCurrentItem);

						// add the missing command to the list box
						if(!bFound)
						{
							// get the command table entry for the missing command from the menu, which caches it.
							CBMenuItem *pMissingItem=pMenuDefault->GetMenuItem(iDefaultItem);

							CTE *pCTEMissing=pMissingItem->m_pCTE;
							
							// if the command is currently in one of the loaded packages
							if(pCTEMissing)
							{
								// Add the command to the list box, if it's not already in there
								LPCTSTR lpszCmdName = pCTEMissing->szCommand;
								int nOldIndex=pList->FindStringExact(0, lpszCmdName);
								if(nOldIndex==LB_ERR)
								{
									int index = pList->AddString(lpszCmdName);
									if(index!=LB_ERR)
									{
										pList->SetItemData(index, (DWORD) pCTEMissing->id);
									}
								}
							}
						}
					}
				}
			}

			delete pMenuDefault;
		}
	}	
}

// This function updates the command table top make project dependent commands
// visible or invisible depending on the set of projects currently loaded
// in the workspace.
void CMainFrame::UpdateProjectCommands(void)
{
	IProjectWorkspace *pPW = g_IdeInterface.GetProjectWorkspace();
	if(pPW == NULL)
		return;

	CADWORD Projects;
	pPW->GetLoadedProjects(&Projects);
	UINT cProj = Projects.cElems;
	
	// Let's build an array of unique GUID gathered from the current
	// list of projects.

	// We'll have at most cProj unique GUIDs
	GUID *pGuid = NULL;
	if(cProj>0)
		pGuid = new GUID[cProj];
	UINT cUniqGuid = 0;
	int i;
	for(i=0; i<cProj; i++)
	{
		GUID guid;
		((IPkgProject *)Projects.pElems[i])->GetClassID(&guid);
		((IPkgProject *)Projects.pElems[i])->Release();
		BOOL bGuidFound = FALSE;
		for(int j=0; j<cUniqGuid; j++)
		{
			if(guid == pGuid[j])
			{
				bGuidFound = TRUE;
				break;
			}
		}
		if(!bGuidFound)
			pGuid[cUniqGuid++] = guid;
	}
	CoTaskMemFree((void *)Projects.pElems);

	// Now we need to walk the list of commands and ask the package owner
	// whether or not the command should be visible given the list of
	// current GUIDs of projects loaded
	for(i = 0; i < theCmdCache.m_cCommands; i++)
	{
		CTE *pCTE = &theCmdCache.m_rgCommands[i];
		if(pCTE->flags & CT_PROJECT_DEPENDENT)
		{
			CPack *pPack = pCTE->GetPack();

			// Shared editor commands cannot be made project dependent!!!
			ASSERT(pPack != NULL && pPack->PacketID() != PACKET_SHARED);
			if(pPack)
			{
				CPackage *pPackage = pPack->GetPackage();
				ASSERT(pPackage != NULL);
				BOOL bVisible;
				bVisible = pPackage->IsVisibleProjectCommand(pCTE->id, pGuid, cUniqGuid);
				if(!bVisible)
					pCTE->flags |= CT_QUERYMENU;
				else
					pCTE->flags &= ~CT_QUERYMENU;
			}
		}

	}
	if(pGuid)
		delete [] pGuid;

	theApp.m_bProjectCommandsDirty=FALSE;
}
    
// If bAllEditors is TRUE, then all editor specific commands will be shown, independent of the current editor. Otherwise,
// only those for the current editor will be shown.
// If bAllProjects is TRUE, all project dependent commands will be shown.
// If bEmptyMenus is TRUE, then any menu which has no items (visible or invisible) will be shown
void CMainFrame::RebuildMenus(BOOL bAllEditors, BOOL bAllProjects, BOOL bEmptyMenus)
{
	// Cancel any dropped command bar
	CASBar::CancelMenu();

	// if project environment has changed, recalc project commands. Defer recalc if we're going to show them all anyway
	if(theApp.m_bProjectCommandsDirty && !bAllProjects)
	{
		UpdateProjectCommands();
	}

	hMenuWindow = NULL;
	if((m_pManager && m_pManager->IsInDocObjectMode()) && (s_hOleMenu == NULL) &&
		CDockWorker::s_pActiveDocker != NULL)
	{
		// Move the handle to a cached location so that we can
		// restore the Ole menu when the doc object gets reactivated
		s_hOleMenu = ::GetMenu(m_hWnd);
	}

	HMENU hMenuOld = m_hMenuDefault;
    m_hMenuDefault = GetCommandMenu(FALSE);

	if(m_hMenuDefault)
	{
		::SendMessage(m_hWndMDIClient, WM_MDISETMENU,
			(WPARAM) m_hMenuDefault, (LPARAM) hMenuWindow);
		::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
		DrawMenuBar();
	}

	if (hMenuOld != NULL)
		::DestroyMenu(hMenuOld);

	if(theCmdCache.GetMenu(IDM_MENU_BAR) == NULL)
	{
		// creating menus for very first time
		// unless something odd has happened, we've probably got at least one unsaved menu
		CMainGroup mainGroup;
	    theCmdCache.ProcessCommands(&mainGroup, FALSE);

		// search all the command table for any menus
		for (int i = 0; i < theCmdCache.m_rgMenuCommands.GetSize() ; i++)
		{
			ASSERT(theCmdCache.m_rgMenuCommands[i]<theCmdCache.m_cCommands);

			CTE *pCTE = &theCmdCache.m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

			ASSERT(pCTE);
			ASSERT(pCTE->flags & CT_MENU);

			CString strKey;
			wsprintf(strKey.GetBuffer(sizeof(szMenuKey) + COMMAND_ID_BUFFERSIZE), szMenuKey, pCTE->id);
			strKey.ReleaseBuffer();

			HGLOBAL hglobInit = GetRegData(CDockWorker::s_lpszLayoutSection, strKey, NULL);
			BOOL bInit=FALSE;
			CBMenuPopup *pMenu=new CBMenuPopup;
			pMenu->CreateMenu();
			pMenu->SetAutoEnable(TRUE);
    
			if(hglobInit)
			{
				if(pMenu->SetData(hglobInit))
				{
					bInit=TRUE;
				}
			}

			if(!bInit)
			{
				mainGroup.BuildSingleMenu(pMenu, pCTE->id);
			}
			theCmdCache.SetMenu(pCTE->id, pMenu);
		}

		// Now determine which packages these menus knew about
		HGLOBAL hglobOld=GetRegData(CDockWorker::s_lpszLayoutSection, szPackagesKey, NULL);
		if(hglobOld)
		{
			// data was found, so do a merge
			// allow size for the worst case, where none of the current packages are the same as before. This is theoretically
			// impossible (shell should always be there), but other than that it could happen
			WORD wSizeNew=(WORD)GlobalSize(hglobOld)-sizeof(WORD)+theApp.m_packages.GetCount()*sizeof(DWORD);

			HGLOBAL hglobNew = ::GlobalAlloc(GMEM_SHARE, wSizeNew+sizeof(WORD));

			// Save details of which packages were loaded at this time, plus those we already knew about
			int nPackages=theApp.m_packages.GetCount();
			DWORD *prgOldKnownPackages=NULL;
			DWORD *prgNewKnownPackages=NULL;

			WORD * lpWordOld = (WORD FAR*) ::GlobalLock(hglobOld);
			WORD * lpWordNew = (WORD FAR*) ::GlobalLock(hglobNew);

			// get count of stuff from registry
			WORD wSizeOld=(*lpWordOld++);
			int nOldPackages=wSizeOld/sizeof(DWORD);
			// skip 
			WORD * lpWordNewBase=lpWordNew;
			*lpWordNew++=wSizeNew;

			// copy old stuff
			memcpy(lpWordNew, lpWordOld, wSizeOld);
			lpWordNew+=wSizeOld/sizeof(WORD);
			
			// prepare for merge
			prgOldKnownPackages=(DWORD *)lpWordOld;
			prgNewKnownPackages=(DWORD *)lpWordNew;

			// find active package ids
			CPackage* pPackageEnum;
			POSITION pos = theApp.m_packages.GetHeadPosition();

			CWordArray rgUnknownPackages;

			while (pos != NULL)
			{
				pPackageEnum = (CPackage*) theApp.m_packages.GetNext(pos);
				UINT nId=pPackageEnum->PackageID();
				BOOL bFound=FALSE;

				// have we already accounted for this package
				for(int i=0;i<nOldPackages && !bFound; ++i)
				{
					if(prgOldKnownPackages[i]==nId)
					{
						bFound=TRUE;
					}
				}

				if(!bFound)
				{
					rgUnknownPackages.Add((WORD)nId);
				}

				*lpWordNew++=(WORD)nId;
			}

			CTE *pCTE=NULL;

			// merge commands from this package into the menu structure
			for (int i = 0; i < theCmdCache.m_cCommands; i++)
			{
				pCTE = &theCmdCache.m_rgCommands[i];

				if (pCTE->flags & CT_NOMENU)
					continue;

				if ((pCTE->flags & (CT_NOUI)) != 0)
					continue;

				// This command will only be merged if it belongs exclusively to the packet in question or it is shared
				// by several packages, all of which are new
				if(pCTE->GetPack()->PacketID()==PACKET_SHARED)
				{
					// If any of the packages sharing the shared command are new, then the command should be merged
					BOOL bMerge=FALSE;

					// If this package isn't unknown, we give up
					for(int i=0; i<rgUnknownPackages.GetSize() && !bMerge; ++i)
					{
						if(pCTE->FindPackage(theApp.GetPackage(rgUnknownPackages[i])))
						{
							bMerge=TRUE;
						}
					}
							
					// not from an unknown package, so continue
					if(!bMerge)
					{
						continue;
					}
						
				}
				else
				{
					int nIdPackage=pCTE->GetPack()->GetPackage()->PackageID();
					BOOL bMerge=FALSE;

					// does this command belong to an unknown package
					for(int i=0; i<rgUnknownPackages.GetSize() && !bMerge; ++i)
					{
						if(rgUnknownPackages[i]==nIdPackage)
						{
							bMerge=TRUE;
						}
					}
							
					// not from an unknown package, so continue
					if(!bMerge)
					{
						continue;
					}
				}

				// Find all groups associated with this command 
				CCmdGroupArray rgGroups;
				mainGroup.FindGroups(pCTE->group, rgGroups);

				// now iterate over them
				int nGroups=rgGroups.GetSize();
				for(int iGroup=0; iGroup<nGroups; ++iGroup)
				{
					CCmdGroup *pGroup=rgGroups[iGroup];

					// now find out the menu where this belongs
					CCmdMenu *pCmdMenu=pGroup->m_pParent;

					if(pCmdMenu)
					{
						CBMenuPopup *pMenu=theCmdCache.GetMenu(pCmdMenu->m_id);

						if(	pMenu &&
							pMenu->IsDirty()) // if the menu is dirty at this point, it must have just been loaded
						{
							// merge the commnand into the menu

							BOOL bFoundGroupStart=FALSE;
							int nInsert=-1;
							BOOL bAlreadyPresent=FALSE;

							// If there are commands from the same group already on the menu, then put it after the
							// first contiguous group of them. Otherwise, put it at the end
							for(int nItem=0;nItem<pMenu->GetMenuItemCount() && !bAlreadyPresent; ++nItem)
							{
								CBMenuItem *pItem=pMenu->GetMenuItem(nItem);
								if(	pItem &&
									pItem->m_pCTE)
								{
									if(pItem->m_pCTE->id==pCTE->id)
									{
										bAlreadyPresent=TRUE;
									}

									// have we found an item belonging to the same group as the command we want to merge?
									if(pItem->m_pCTE->group==pGroup->m_id)
									{
										bFoundGroupStart=TRUE;
									}
									else
									{
										// if we've seen the start, then we've just passed the end, so we can insert the item
										if(bFoundGroupStart)
										{
											// this causes the loop to terminate too
											nInsert=nItem;
										}
									}
								}
							}

							if(!bAlreadyPresent)
							{
								// insert 
								CBMenuItem *pNewItem=new CBMenuItem;
								pNewItem->CreateDynamic(pMenu, pCTE->id, "", TRUE, NULL);

								// if we didn't find a place, it'll go at the end of the menu, which is probably fine unless
								// it ends up the file exit command, but that's pretty unlikely.
								pMenu->AddMenuItem(nInsert, pNewItem);
							}
						}
					}
				}
			}

			// finish work
			GlobalUnlock(hglobNew);
			GlobalUnlock(hglobOld);

			// lose old
			GlobalFree(hglobOld);

			// resize new to fit
			GlobalReAlloc(hglobNew, (lpWordNew-lpWordNewBase)*sizeof(WORD),0);

			theCmdCache.m_prgKnownPackages=hglobNew;
		}
	}

	POSITION pos=theCmdCache.GetFirstMenuPosition();

	CASBar *pMenuBar=CASBar::GetMenuBar();
	BOOL bBarChanged=FALSE;

	UINT nIDMenu;
	CBMenuPopup *pPopup;
	while(pos!=NULL)
	{
		theCmdCache.GetNextMenu(pos, nIDMenu, pPopup);

		// at start, we know nothing
		pPopup->m_nVisibleItems=-1;
	}

	// now apply invisibility flags to the menu tree.
	bBarChanged|=ApplyFlags(IDM_MENU_BAR, bAllEditors, bAllProjects, bEmptyMenus);

	// finally, apply them to any menus not currently in the tree, in case they get customized into existence
	pos=theCmdCache.GetFirstMenuPosition();

	while(pos!=NULL)
	{
		theCmdCache.GetNextMenu(pos, nIDMenu, pPopup);

		// special value used to block infinite recursion, should never get here
		ASSERT(pPopup->m_nVisibleItems!=-2);

		// at start, we know nothing
		if(pPopup->m_nVisibleItems==-1)
		{
			bBarChanged|=ApplyFlags(nIDMenu, bAllEditors, bAllProjects, bEmptyMenus);
		}
	}
	CASBar::UpdateMenuBar(this);

	if(bBarChanged)
	{
		pMenuBar->RecalcLayout(pMenuBar->GetExpansionConstraint(CRect(0,0,0,0), NULL));
		pMenuBar->Invalidate();
	}

	// Restore the merged menu if we go back to the DocObject frame
	// from a docking window
	if((m_pManager && m_pManager->IsInDocObjectMode()) && CDockWorker::s_pActiveDocker == NULL)
	{
		if(s_hOleMenu != NULL)
		{
			::SendMessage(m_hWndMDIClient, WM_MDISETMENU,
				(WPARAM) s_hOleMenu, (LPARAM) NULL);
			::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
			DrawMenuBar();
		}
		s_hOleMenu = NULL;
	}

    theApp.m_bMenuDirty = FALSE;
	theApp.m_bMenuDead = FALSE;
}

void CCmdCache::SaveMenus()
{
	BOOL bSavePackages=FALSE;

	// search all the menus in the command table for any menus in the specified group, and add them
	for (int i = 0; i < m_rgMenuCommands.GetSize() ; i++)
	{
		ASSERT(m_rgMenuCommands[i]<theCmdCache.m_cCommands);

		CTE *pCTE = &m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

		ASSERT(pCTE);
		ASSERT(pCTE->flags & CT_MENU);

		CBMenuPopup *pMenu=GetMenu(pCTE->id);

		CString strKey;
		wsprintf(strKey.GetBuffer(sizeof(szMenuKey) + COMMAND_ID_BUFFERSIZE), szMenuKey, pCTE->id);
		strKey.ReleaseBuffer();
		
		if(pMenu->IsDirty())
		{
			ASSERT(CDockWorker::s_lpszLayoutSection != NULL);

			HGLOBAL hglobInit = (HGLOBAL) pMenu->GetData();

			if (hglobInit != NULL)
			{
				WriteRegData(CDockWorker::s_lpszLayoutSection, strKey, hglobInit);

				bSavePackages=TRUE;
			}
			else
			{
				DeleteRegData(CDockWorker::s_lpszLayoutSection, strKey);
			}

			::GlobalFree(hglobInit);
		}
		else
		{
			DeleteRegData(CDockWorker::s_lpszLayoutSection, strKey);
		}
	}

	if(bSavePackages)
	{
		HGLOBAL hglob = NULL;

		if(m_prgKnownPackages)
		{
			hglob=m_prgKnownPackages;
		}
		else
		{
			// Save details of which packages were loaded at this time, plus those we already knew about
			int nPackages=theApp.m_packages.GetCount();
			DWORD *prgSaveKnownPackages=NULL;

			WORD wSize=sizeof(DWORD)*nPackages;

			// allocate memory
			hglob = ::GlobalAlloc(GMEM_SHARE, wSize + sizeof(WORD));
			WORD FAR* lpWord = (WORD FAR*) ::GlobalLock(hglob);
			
			// init size info
			*lpWord++ = wSize;

			prgSaveKnownPackages=(DWORD *)lpWord;

			// save package ids
			CPackage* pPackageEnum;
			POSITION pos = theApp.m_packages.GetHeadPosition();

			while (pos != NULL)
			{
				pPackageEnum = (CPackage*) theApp.m_packages.GetNext(pos);
				*prgSaveKnownPackages++=pPackageEnum->PackageID();
			}

			GlobalUnlock(hglob);
		}

		// store in registry
		WriteRegData(CDockWorker::s_lpszLayoutSection, szPackagesKey, hglob);

		// lose the data
		GlobalFree(hglob);
		if(m_prgKnownPackages)
		{
			m_prgKnownPackages=NULL;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
//  Menu text helper

void MenuFileText(CString& str)
{
	// Double up ampersands in file names.
	if (str.Find(_T('&')) == -1)
		return;
	
	CString strBuffer;
	LPTSTR lpBuffer = strBuffer.GetBuffer(str.GetLength() * 2);
	LPCTSTR lpsz = str;

	while (*lpsz != _T('\0'))
	{
		_tccpy(lpBuffer, lpsz);

		if (*lpsz == _T('&'))
			*(++lpBuffer) = _T('&');

		lpBuffer = _tcsinc(lpBuffer);
		lpsz = _tcsinc(lpsz);
	}
	*lpBuffer = _T('\0');

	strBuffer.ReleaseBuffer();
	str = strBuffer;
}


// This code has been completely revised to deal with the new situation where the menu bar
// is built from groups and all existing concrete menu bars could have been customised (even 
// the one returned from theCmdCache.GetMenu(IDM_MENU_BAR), though that's unlikely to happen
// often.

//REVIEW: Support for a dirty command cache
BOOL CAppToolGroups::ScanCommandCache()
{
	if (m_wSyncID == theCmdCache.m_wSyncID)
		return FALSE;

	if (m_rgGroups != NULL)
		delete [] m_rgGroups;

	// get the menu bar popdesc from the appropriate package
	CTE *pCTE=theCmdCache.GetCommandEntry(IDM_MENU_BAR);
	ASSERT(pCTE);
	ASSERT(pCTE->GetPack());
	ASSERT(pCTE->GetPack()->GetPackage());
	POPDESC *pMenuBar=pCTE->GetPack()->GetPackage()->GetMenuDescriptor(IDM_MENU_BAR);

	// calculate the group structure
	CMainGroup mainGroup;
	theCmdCache.ProcessCommands(&mainGroup, FALSE, FALSE, FALSE);
	// scan the command cache for commands in the relevant groups
	// First time around we just need to know how many commands are in one of these groups

	// Count the groups for allocation.
	int iGroup;
	m_nGroups = 0;

	for(iGroup=0; pMenuBar->rgmtm[iGroup].id !=POP_NIL ; ++iGroup)
	{
		CCmdGroupArray rgGroups;

		// find first group and then stop
		if(mainGroup.FindGroups((WORD)pMenuBar->rgmtm[iGroup].id,rgGroups, TRUE))
		{
			CCmdGroup *pGroup=rgGroups[0];

			POSITION pos=pGroup->m_children.GetHeadPosition();
			while (pos != NULL)
			{
				CCmd *pItem = (CCmd*) pGroup->m_children.GetNext(pos);
				if(	pItem &&
					pItem->m_flags & CT_MENU)
				{
					m_nGroups++;
				}
			}
		}
	}

	m_rgGroups = new CToolGroup[m_nGroups];

	// Fill the groups.
	int iDestGroup = 0;
	for(iGroup=0; pMenuBar->rgmtm[iGroup].id !=POP_NIL ; ++iGroup)
	{
		CCmdGroupArray rgGroups;

		// find first group and then stop
		if(mainGroup.FindGroups((WORD)pMenuBar->rgmtm[iGroup].id,rgGroups, TRUE))
		{
			CCmdGroup *pGroup=rgGroups[0];

			POSITION pos=pGroup->m_children.GetHeadPosition();
			while (pos != NULL)
			{
				CCmd *pItem = (CCmd*) pGroup->m_children.GetNext(pos);
				if(	pItem &&
					pItem->m_flags & CT_MENU)
				{
					CTE *pMenuCTE=theCmdCache.GetCommandEntry(pItem->m_id);
					ASSERT(pMenuCTE);
					ASSERT(pMenuCTE->GetPack());
					ASSERT(pMenuCTE->GetPack()->GetPackage());
					POPDESC *pMenuPop=pMenuCTE->GetPack()->GetPackage()->GetMenuDescriptor(pMenuCTE->id);

					m_rgGroups[iDestGroup].Fill(pMenuPop, pItem->m_id);
					m_nCmds+=m_rgGroups[iDestGroup].m_nCmds;
					iDestGroup++;
				}
			}
		}
	}

	m_wSyncID = theCmdCache.m_wSyncID;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\spopup.cpp ===
// spopup.cpp : Sushi popup menu support
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// popup menus

CContextPopupMenu::CContextPopupMenu()
{
	m_pListSubMenus = NULL;
	m_idgPrev = 0;
	m_bPopup = FALSE;
	m_nPopupPos = 0;
}

CContextPopupMenu::~CContextPopupMenu()
{
	if (m_pListSubMenus != NULL)
	{
		POSITION	pos = m_pListSubMenus->GetHeadPosition();

		while (pos != NULL)
			delete m_pListSubMenus->GetNext(pos);

		delete m_pListSubMenus;
	}

	DestroyMenu();
}

void CContextPopupMenu::Create(POPDESC* ppop /*=NULL*/)
{
	CreatePopupMenu();

	if (ppop == NULL)
		return;

	UINT nID, nIDLast = POP_SEPARATOR;
	for (int i = 0; (nID = ppop->rgmtm[i].id) != POP_NIL; i++)
	{
		if (nID == POP_SEPARATOR)
		{
			// No double separators, or separators at end of popup.
			if (nIDLast != POP_SEPARATOR && ppop->rgmtm[i + 1].id != POP_NIL)
				AppendMenu(MF_SEPARATOR);
		}
		else
		{
			CString str;
			if (ppop->rgmtm[i].idString != POP_IDS_NIL)
				VERIFY(str.LoadString(ppop->rgmtm[i].idString));

			AddItem(nID, str.IsEmpty() ? NULL : (LPCTSTR) str);
		}

		nIDLast = nID;
	}
	m_bPopup = FALSE;
}

CContextPopupMenu* CContextPopupMenu::CreateNewSubPopup(CContextPopupMenu* pParent)
{
	ASSERT(pParent != NULL);

	CContextPopupMenu* pSubMenu = new CContextPopupMenu;
	pSubMenu->Create();

	if (pParent->m_pListSubMenus == NULL)
		pParent->m_pListSubMenus = new CObList;

	pParent->m_pListSubMenus->AddTail(pSubMenu);

	return pSubMenu;
}

void CContextPopupMenu::AddItem(UINT id, LPCTSTR lpszText)
{
	if (lpszText == NULL)
	{
		CTE *pCTE = theCmdCache.GetCommandEntry(id);

		// Must be found
		ASSERT( pCTE != NULL );

		if ((pCTE->flags & CT_NOUI) != 0)
			return;	// Hidden menuitem.

		theCmdCache.GetCommandString(id, STRING_MENUTEXT, &lpszText, NULL, pCTE);
	}

	LPTSTR buf = new TCHAR [_tcslen(lpszText) + 1];

	// strip out ampersands (&) since popups don't have mnemonics,
	// get any context string, and strip off any trailing tab and
	// keyboard shortcut.

	LPTSTR pchDest = buf; 
	while (*lpszText != _T('\0') && *lpszText != _T('\t'))
	{
		// check for string "(&X)" which is supported by the Japanese's system
		// and get rid of them too
		if ( (*lpszText == _T('(')) && (*(_tcsinc(lpszText)) == _T('&')) )
		{
			while (*lpszText && *lpszText != _T(')'))
				lpszText = _tcsinc(lpszText);
 			ASSERT(*lpszText != '\0');
			lpszText = _tcsinc(lpszText);
		}

		// [olympus 16870 - chauv]
		// make sure it's not NULL here. Otherwise, lpszText will be over incremented pass the NULL terminating
		if (*lpszText)
		{
			if (*lpszText != _T('&'))
			{
				_tccpy(pchDest, lpszText);
				pchDest = _tcsinc(pchDest);
			}

			lpszText = _tcsinc(lpszText);
		}
	}
	*pchDest = _T('\0');

	AppendMenu(MF_ENABLED, id, buf);

	delete [] buf;
}

void CContextPopupMenu::AddSubMenu(CContextPopupMenu* pSubMenu, LPCTSTR lpszText)
{
	AppendMenu(MF_POPUP, (UINT)pSubMenu->m_hMenu, lpszText);
}

BOOL CContextPopupMenu::TrackPopup(UINT flags, int x, int y, CWnd* pOwner)
{
	// if using popups from menu resource,
	if (m_bPopup)
	{
		CMenu * pmenu = GetSubMenu(m_nPopupPos);
		ASSERT(pmenu != NULL);
		return pmenu->TrackPopupMenu(flags, x, y, pOwner);
	}
	else
		return TrackPopupMenu(flags, x, y, pOwner);
}

BOOL CContextPopupMenu::LoadMenu(UINT nID)
{
	if (CMenu::LoadMenu(nID))
	{
		m_bPopup = TRUE;
		SetPos(0);
	}
	else 
	{
		m_bPopup = FALSE;
		m_nPopupPos = 0;
	}
	return m_bPopup;
}

void CContextPopupMenu::SetPos( int nPopupPos )
{
	ASSERT(m_bPopup == TRUE);
	ASSERT(GetSubMenu(nPopupPos)!=NULL);
	m_nPopupPos = nPopupPos;
}

void ShowContextPopupMenu(POPDESC* ppop, CPoint pt)
{
	CMainFrame* pWndCommand = (CMainFrame*) AfxGetMainWnd();
	ASSERT_VALID(pWndCommand);

	CContextPopupMenu menuPopup;
	menuPopup.Create(ppop);

	menuPopup.TrackPopup(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
		pt.x, pt.y, pWndCommand);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\spawner.cpp ===
// spawner.cpp
//
// low-level build routines to spawn tools

#include "stdafx.h"

#include "toolexpt.h"
#include "util.h"
#include "dllapi.h"
#include "resource.h"
#include "shell.h"

#include <tchar.h>
#include <string.h>
#include <bldapi.h>

#include "utilauto.h"

//REVIEW(PatBr): Moved from spawner.h because of conflicts.
#define MAX_TOOL_MACRO  16					// max length of macro name
#define MAX_LINE_SIZE   2048
#define MAX_USER_LINE   MAX_LINE_SIZE
#define TMP_STRING_SIZE MAX_LINE_SIZE + 60	// all purpose strings

struct TERROR
{
	LPLONG		lpTop;
	LPLONG		lpStack;
	LPLONG		lpEnd;
	UINT		nErrorMin;
	UINT		nErrorMax;
	KEYENTRY
};

PfnReadPipe pfnReadPipe = (GetVersion() & 0x80000000) ? FWin95ReadPipe : FWinNTReadPipe;

// characters that indicate to us that we need to spawn a command
// processor in front of tools (redirection and command chaining)
const char rgchCmdProcChar[] = "<>|";

LPSTR stristr(LPSTR szSearch, LPSTR szReqd)
{
	// case insensitive string inclusion (like _ftcsstr but insensitive)
	LPSTR pszRet = NULL;

	TCHAR *pszSrchTmp;
	TCHAR *pszReqdTmp;

	pszSrchTmp = (TCHAR *)malloc(_tcslen(szSearch)+1);
	pszReqdTmp = (TCHAR *)malloc(_tcslen(szReqd)+1);

	char *pstr;

	_ftcslwr(_ftcscpy(pszSrchTmp, szSearch));
	_ftcslwr(_ftcscpy(pszReqdTmp, szReqd));

	pstr = _ftcsstr(pszSrchTmp, pszReqdTmp);
	if (pstr)
		pszRet = (pstr - pszSrchTmp) + szSearch;

	free(pszSrchTmp);
	free(pszReqdTmp);

	return(pszRet);
}

BOOL SetDriveAndDir(LPCTSTR szPath)
{
	// this function only used to reset current drive and directory after
	// running a user-defined tool, so assume the string contains only 
	// drive and directory components--no file or extension present.
	char szTmp[_MAX_PATH];
	char szDrive[4];

	// if string is blank, get out
	if (*szPath == '\0')
		return TRUE;

	_ftcscpy(szTmp, szPath);

	// Set current drive and dir
	_splitpath(szTmp, szDrive, NULL, NULL, NULL);

	if (szDrive[0] != 0)
	{
		if (_chdrive((int)(_totupper((_TUCHAR)(szDrive[0])) - 'A' + 1)) != 0)
			return ErrorBox(IDS_ERR_CHANGE_DRIVE, (LPSTR)szDrive);
	}

	if (_chdir(szTmp) != 0)
		return ErrorBox(IDS_ERR_CHANGE_DIR, (LPSTR)szTmp);

	return TRUE;
}

LPCTSTR ParseMacroName(LPTSTR szMacro, LPCTSTR szIn, UINT cbMax)
{
	LPTSTR szOut = szMacro;

	// '$(' always single-cell characters
	if (*szIn != _T('$') || *(szIn + 1) != _T('('))
		return NULL;

	// copy the $(
	_tccpy(szOut, szIn);
	_tccpy(szOut + 1, szIn + 1);
	szOut += 2;
	szIn += 2;

	// Get possible macro name
	while (*szIn != _T(')'))
	{
		// copy char
		_tccpy(szOut, szIn);
		szOut = _tcsinc(szOut);
		szIn = _tcsinc(szIn);
	}
	ASSERT(*szIn == ')');
	ASSERT(szOut < (char*)szMacro + cbMax);
	// copy ')' char
	_tccpy(szOut, szIn);
	szOut = _tcsinc(szOut);
	szIn = _tcsinc(szIn);
	*szOut = _T('\0');

	return(szIn);
}

void RemoveTrailing(LPTSTR sz, _TCHAR ch = _T('\\'))
{
	ASSERT(sz != NULL);
	LPTSTR pch = sz + _tcslen(sz) - 1;
	while (pch > sz && *pch == ch)
	{
		if (pch - 1 > sz && !_istleadbyte(*(pch - 1)))
			*pch-- = 0;
	}
}

int GetProjectRCFile(TCHAR *lpRCFile)
{
	LPBUILDSYSTEM pBldSysIFace = g_IdeInterface.GetBuildSystem();

	if (pBldSysIFace != NULL)
	{
		// can we return a name? (can't do this for multiple .RC files!)
		CPtrList ptrlist;
		pBldSysIFace->GetResourceFileList(ptrlist, FALSE, NULL, ACTIVE_BUILDER);
		if (ptrlist.GetCount() == 1)
		{
			const CPath *pResPath = (const CPath *)ptrlist.GetHead();
			ASSERT(pResPath);
			_ftcscpy(lpRCFile, pResPath->GetFullPath());
			return _ftcslen(lpRCFile);
		}
	}
	return 0;	// no RC file...
}

BOOL ExpandToolArguments(LPSTR szArg, size_t size)
{
	char temp[TMP_STRING_SIZE];
	char szPath[_MAX_PATH], szDrive[_MAX_DRIVE], szDir[_MAX_DIR],
		 szFName[_MAX_FNAME], szExt[_MAX_EXT];
	char MacroName[MAX_TOOL_MACRO+1];
	UINT iOut;
	int i,lng;
	BOOL iRet = TRUE;
	int cb;
	BOOL bMacro;
	LPSTR szSrc;
	static BOOL bLoaded = FALSE;
	static _TCHAR Names[IDS_TOOLMACRO_Last-IDS_TOOLMACRO_First+1][MAX_TOOL_MACRO+1];

	if (!bLoaded)
	{
		for (int i = 0; i <= IDS_TOOLMACRO_Last-IDS_TOOLMACRO_First; i++)
			VERIFY(LoadString(GetResourceHandle(), i + IDS_TOOLMACRO_First, (LPTSTR)Names[i], MAX_TOOL_MACRO+1));
		bLoaded = TRUE;
	}

	ASSERT(szArg != NULL);
	szSrc = szArg;

	// we want to save one byte for the terminating '\0'
	size -= 1;

	iOut=0;
	while (*szArg != _T('\0') && (iOut + _tclen(szArg) < size) && iRet == TRUE)
	{
		bMacro = FALSE;
		// parse macro (if any) from current position
		LPCTSTR szArgNext = ParseMacroName(MacroName, szArg, MAX_TOOL_MACRO);
		if (szArgNext != NULL)
		{
			// search for macro name
			for (i = 0; i <= IDS_TOOLMACRO_Last - IDS_TOOLMACRO_First; i++)
			{
				if (!_tcsicmp(MacroName, Names[i]))
				{
					_tcscpy(MacroName, Names[i]);
					bMacro = TRUE;
					break;
				}
			}
		}

		// If no macro or not a known macro name, copy char and keep scanning
		if (!bMacro)
		{
			cb = _tclen(szArg);
			_tccpy(temp + iOut, szArg);
			iOut += cb;
			szArg += cb;
		}
		else
		{
			// advance input 
			szArg = (LPSTR)szArgNext;
			// Expand macro
			CPartView *pView = (CPartView *)CWnd::FromHandle(theApp.GetActiveView());

			switch(i)
			{
				case IDS_TOOLMACRO_RCFile-IDS_TOOLMACRO_First: // Current RC File in project
				{
					TCHAR szRC[_MAX_PATH] ;

					if (lng = GetProjectRCFile(szRC))
					{
						if (iOut+lng <size)
						{
							_ftcscpy(&temp[iOut], szRC) ;
							iOut += lng;
						}
						else
						{
							ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
							iRet = FALSE;
						}
					}
					break ;
				}

				case IDS_TOOLMACRO_FilePath-IDS_TOOLMACRO_First:	// file name (full)
				case IDS_TOOLMACRO_FileNameExt-IDS_TOOLMACRO_First:	// file base name + ext
				case IDS_TOOLMACRO_FileDir-IDS_TOOLMACRO_First:		// file directory + drive
				case IDS_TOOLMACRO_FileName-IDS_TOOLMACRO_First:	// file base name
				case IDS_TOOLMACRO_FileExt-IDS_TOOLMACRO_First:		// file extension
				{
					if (pView)
					{
						CPartDoc *pDoc = (CPartDoc *)(pView->GetDocument());
						if(pDoc)
						{
							if (pDoc->GetPathName().IsEmpty())
							{
								if (!pDoc->DoSave(pDoc->GetPathName()))
								{
									iRet = FALSE;
									break;
								}
								else	// Don't have a name, and don't want to save -- can't continue
								{
									CString strMsg;
									strMsg.LoadString(IDS_ERR_NO_DISK_IMAGE);
									MessageBox(NULL, (LPCTSTR)strMsg, NULL, MB_ICONEXCLAMATION|MB_OK);
									iRet = FALSE;
									break;
								}
							}

							_ftcscpy(szPath, (LPCTSTR)pDoc->GetPathName());

							if (i != IDS_TOOLMACRO_FilePath - IDS_TOOLMACRO_First)
							{
								_splitpath(szPath, szDrive, szDir, szFName, szExt);
								switch (i)
								{
									case IDS_TOOLMACRO_FileDir - IDS_TOOLMACRO_First:
										_ftcscpy(szPath, szDrive);
										RemoveTrailing(szDir);
										_ftcscat(szPath, szDir);
										break;

									case IDS_TOOLMACRO_FileName - IDS_TOOLMACRO_First:
										_ftcscpy(szPath, szFName);
										break;

									case IDS_TOOLMACRO_FileExt - IDS_TOOLMACRO_First:
										_ftcscpy(szPath, szExt);
										break;

									case IDS_TOOLMACRO_FileNameExt - IDS_TOOLMACRO_First:
										_ftcscpy(szPath, szFName);
										_ftcscat(szPath, szExt);
										break;
								}
							}

							lng = _ftcslen(szPath); // Get name

							if (iOut+lng < size) // is there enough space in dest string ?
							{
								_ftcscpy(&temp[iOut],szPath);
								iOut += lng;
								break;
							}
							else
							{
								ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
								iRet = FALSE;
							}
						}
					}
					break;
				}

				case IDS_TOOLMACRO_Dir		-IDS_TOOLMACRO_First:	// Current working directory
				case IDS_TOOLMACRO_WkspName	-IDS_TOOLMACRO_First:	// Workspace base name
				case IDS_TOOLMACRO_WkspDir	-IDS_TOOLMACRO_First:	// Workspace directory

					if (i == IDS_TOOLMACRO_Dir - IDS_TOOLMACRO_First)
					{
						_getcwd(szPath, _MAX_PATH);
						RemoveTrailing(szPath);
					}
					else
					{
						LPCSTR pszProjPath;
						LPBUILDSYSTEM pBldSysIFace = g_IdeInterface.GetBuildSystem();

						if ((pBldSysIFace == NULL) || (pBldSysIFace->IsActiveBuilderValid() != S_OK) || (FAILED(pBldSysIFace->GetBuilderFile(ACTIVE_BUILDER, &pszProjPath))) || (pszProjPath == NULL))
							break;

						_ftcscpy(szPath, pszProjPath);

						if ((i == IDS_TOOLMACRO_WkspDir - IDS_TOOLMACRO_First))
						{
							_splitpath(szPath, szDrive, szDir, NULL, NULL);

							_ftcscpy(szPath, szDrive);
							RemoveTrailing(szDir);
							_ftcscat(szPath, szDir);
						}
						else if ((i == IDS_TOOLMACRO_WkspName - IDS_TOOLMACRO_First))
						{
							_splitpath(szPath, NULL, NULL, szFName, NULL);

							_ftcscpy(szPath, szFName);
						}
					}

					lng = _ftcslen(szPath);

					if (lng != 0)
					{
						if((iOut+lng) < size)
						{
							_ftcsncpy(&temp[iOut],szPath,lng);
							iOut += lng;
						}
						else
						{
							ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
							iRet = FALSE;
						}
					}
					break;

				case IDS_TOOLMACRO_Line-IDS_TOOLMACRO_First:  // Line number
				case IDS_TOOLMACRO_Col-IDS_TOOLMACRO_First:   // Column number
					// don't display line number if no view active
					if (pView == NULL)
						break;
					else if (iOut + 5 < size) // is there enough space in dest string ?
					{
						LPSOURCEQUERY pSourceQuery;
						theApp.FindInterface(IID_ISourceQuery, (LPVOID FAR *)&pSourceQuery);
						if (pSourceQuery == NULL)
						{
							break;
						}
						LPSOURCEEDIT pSourceEdit;
						pSourceQuery->CreateSourceEditForActiveDoc(&pSourceEdit, FALSE);
						if (pSourceEdit == NULL)
						{
							pSourceQuery->Release();
							break;
						}
						if (i == IDS_TOOLMACRO_Line-IDS_TOOLMACRO_First)
						{
							ULONG ulLine;
							pSourceEdit->GetCaretLine(&ulLine);
							iOut += wsprintf((LPSTR)&temp[iOut], "%d", (ulLine + 1));
						}
						else
						{
							ULONG ulColumn;
							pSourceEdit->GetCaretColumn(&ulColumn);
							iOut += wsprintf((LPSTR)&temp[iOut], "%d", (ulColumn + 1));
						}
						pSourceEdit->Release();
						pSourceQuery->Release();
					}
					else
					{
						ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
						iRet = FALSE;
					}
					break;

				case IDS_TOOLMACRO_CurText-IDS_TOOLMACRO_First:  // Current text
				{
					CString str;
					if (pView == NULL || !pView->GetHelpWord(str))
						break;
					// note that str could easily be empty at this point
					if (iOut + str.GetLength() < size)
					{
						_ftcsncpy(&temp[iOut], str, str.GetLength());
						iOut += str.GetLength();
					}
					else
					{
						ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
						iRet = FALSE;
					}
					break;
				}

				case IDS_TOOLMACRO_TargetPath-IDS_TOOLMACRO_First:	// target
				case IDS_TOOLMACRO_TargetDir-IDS_TOOLMACRO_First:	// target directory
				case IDS_TOOLMACRO_TargetName-IDS_TOOLMACRO_First:	// target name
				case IDS_TOOLMACRO_TargetExt-IDS_TOOLMACRO_First:	// target name
				{
					LPTSTR pszTargPath;
					LPBUILDSYSTEM pBldSysIFace = g_IdeInterface.GetBuildSystem();

					if ((pBldSysIFace == NULL) || (pBldSysIFace->IsActiveBuilderValid() != S_OK) || (FAILED(pBldSysIFace->GetTargetFileName(ACTIVE_BUILDER, &pszTargPath))) || (pszTargPath == NULL))
						break;

					_ftcscpy(szPath, pszTargPath);
					delete [] pszTargPath;

					if (i != IDS_TOOLMACRO_TargetPath - IDS_TOOLMACRO_First)
					{
						_splitpath(szPath, szDrive, szDir, szFName, szExt);
						switch (i)
						{
						case IDS_TOOLMACRO_TargetDir - IDS_TOOLMACRO_First:
							_ftcscpy(szPath, szDrive);
							RemoveTrailing(szDir);
							_ftcscat(szPath, szDir);
							break;
						case IDS_TOOLMACRO_TargetName - IDS_TOOLMACRO_First:
							_ftcscpy(szPath, szFName);
							break;
						case IDS_TOOLMACRO_TargetExt - IDS_TOOLMACRO_First:
							_ftcscpy(szPath, szExt);
							break;
						}
					}

					lng = _ftcslen(szPath);

					if((iOut+lng) < size)
					{
						_ftcscpy(&temp[iOut], szPath);
						iOut += lng;
					}
					else
					{
						ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
						iRet = FALSE;
					}

					break;
				}

				case IDS_TOOLMACRO_TargetArgs-IDS_TOOLMACRO_First: // command line arguments
				{
					CString ProjArgs;
					LPBUILDSYSTEM pBldSysIFace = g_IdeInterface.GetBuildSystem();

					if ((pBldSysIFace == NULL) || (pBldSysIFace->IsActiveBuilderValid() != S_OK))
						break;

					pBldSysIFace->GetProgramRunArguments(ACTIVE_BUILDER, ProjArgs);

					lng = _ftcslen(LPCTSTR(ProjArgs));
					if((iOut+lng) < size)
					{
						_ftcscpy(&temp[iOut], LPCTSTR(ProjArgs));
						iOut += lng;
					}
					else
					{
						ErrorBox(IDS_ERR_EXPAND_MACRO, (LPSTR)MacroName);
						iRet = FALSE;
					}
					break;
				}
			}
		}
	}

	temp[iOut] = '\0';
	_tcscpy (szSrc, temp) ;
	return(iRet);
}

BOOL DoSaveBeforeSpawn()
{
	BOOL bPrompt = FALSE;
	// prompt before saving unsaved documents?
	LPSOURCEQUERY pInterface = g_IdeInterface.GetSourceQuery();
	if (pInterface != NULL && pInterface->IsPromptBeforeSaving() == S_OK)
		bPrompt = TRUE;

	/*
		DS96 #17352 [CFlaat]: don't record the save all, so that 'ExecuteCommand "[toolbar]"' will get recorded
	*/
	HALT_RECORDING();

	// save non-debugger files
	return(theApp.SaveAll(bPrompt, FILTER_DEBUG));
}

CDllApi::CDllApi(const _TCHAR *szDll, MPSZPFN *mpszpfn)
{
	_mpszpfn = mpszpfn;
	_tcscpy(_szDll, szDll);
	_fRoutinesOK = FALSE;
	_cRoutines = 0;

	HINSTANCE hInstance = LoadLibrary(szDll);

	if (hInstance)
	{
		_hInstance = hInstance;

		MPSZPFN *pmpszpfn;
		BOOL fRoutinesOK = TRUE;

		for (pmpszpfn = _mpszpfn; pmpszpfn->szRoutine; pmpszpfn++)
		{
			fRoutinesOK = fRoutinesOK && 
				(pmpszpfn->pfn = GetProcAddress(hInstance, pmpszpfn->szRoutine));
			_cRoutines++;
		}
		_fRoutinesOK = fRoutinesOK;
	}
}

CDllApi::~CDllApi()
{
	if (_hInstance)
		FreeLibrary(_hInstance);
	_hInstance = 0;
	_fRoutinesOK = FALSE;
}

BEGIN_MPSZPFN(Daytona)
MPSZPFN_FCN(SetProcessWorkingSetSize)
MPSZPFN_FCN(GetProcessWorkingSetSize)
END_MPSZPFN(Daytona)

#define ipfnSetWSSize  0
#define ipfnGetWSSize  1

typedef BOOL (WINAPI *PfnSetWSSize)(HANDLE, DWORD, DWORD);

#define cbTrimWorkingSet 0xffffffff

DECLARE_DLLAPI(dllApiDaytona, Daytona, kernel32.dll);

BOOL SetWorkingSetSize(DWORD cbMinWS, DWORD cbMaxWS)
{
	if (dllApiDaytona.FRoutinesLoaded())
		return PfnSetWSSize(dllApiDaytona(ipfnSetWSSize))(GetCurrentProcess(), cbMinWS, cbMaxWS);
	return FALSE;
}

//-----------------------------------------------------------------------------
// FWin95ReadPipe
//
// Necessary function to be able to always return from a ReadFile on a pipe
// when Win95 doesn't realize the pipe has been broken.  We use an auxilliary
// event to stop on.  In this case, it will be the handle to the process that
// we spawn.  When both the process handle is signalled AND the pipe is empty,
// we consider the connection broken.  Otherwise, we pseudo-block until either
// there is data to be read (and we read it) or the process is gone.
//-----------------------------------------------------------------------------
BOOL FWin95ReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE hAuxStop)
{
	DWORD cbAvail = 0;
	
	// while the pipe is still valid, we don't have data, and the aux stop event
	// is not signalled, we pseudo-block
	while (PeekNamedPipe(hpipe, NULL, 0, NULL, &cbAvail, NULL) && cbAvail == 0 &&
			WaitForSingleObject(hAuxStop, 0) == WAIT_TIMEOUT)
	{
		Sleep(10);	// give up our timeslice in a pseudo-block
	}

	cbRead = 0;
	if (cbAvail)
	{
		return(ReadFile(hpipe, pvBuf, __min(cbToRead, cbAvail), &cbRead, NULL));
	}

	// else, the only other reason to get out of the loop above is if the pipe
	// has been broken or the aux stop event is signalled.
	return FALSE;
}

//-----------------------------------------------------------------------------
// FWinNTReadPipe
//
// Thunk to ReadFile
//-----------------------------------------------------------------------------
BOOL FWinNTReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE /*hAuxStop*/)
{
	return(ReadFile(hpipe, pvBuf, cbToRead, &cbRead, NULL));
}

/////////////////////////////////////////////////////////////////////////////
// CConsoleSpawner

BOOL CConsoleSpawner::m_fUserWarned = FALSE;

// REVIEW(KPERRY) The spawner used to use the same string for 2 try's at
// launching the spawner. To minimize changes I added the NoQuote version
// of the string and left the %s in for no good reason. we can remove it
// and the coresponding blank argument to sprintf later on in the code at
// a later time.


CHAR CConsoleSpawner::m_szSpawnTool[] = "\"%svcspawn\" -e %lu %s ";
CHAR szSpawnToolNoQuote[] = "%svcspawn -e %lu %s ";

unsigned _stdcall ReadChildProcessOutput(LPVOID lpv)
{
	CConsoleSpawner::ReadChildProcessOutput2(lpv);
	_endthreadex(0);
	return 0;
}

void _cdecl CConsoleSpawner::ReadChildProcessOutput(LPVOID lpv){};

void _cdecl CConsoleSpawner::ReadChildProcessOutput2(LPVOID lpv)
{
	CConsoleSpawner *pSpawner = (CConsoleSpawner *)lpv;
	DWORD cb = 0;	// bytes in output buffer
	char rgchProcOutputBuf[cbProcOutputBuf];

	do {
		// wait until process has been spawned
		TRACE("spawner 0x%08x : waiting for process spawn event\n", pSpawner);
		WaitForSingleObject(pSpawner->m_hSpawnEvent, INFINITE);

		TRACE("spawner 0x%08x : returned from wait for process spawn event\n", pSpawner);
		if (pSpawner->m_fThreadDie)
			break;

		TRACE("spawner 0x%08x : going to read from pipe handle = 0x%08x\n", pSpawner, pSpawner->m_hReadPipe);

		// read pipe until it's empty
		while ((*pfnReadPipe)(pSpawner->m_hReadPipe, rgchProcOutputBuf, cbProcOutputBuf - 1,
						cb, pSpawner->m_procinfo.hProcess) && cb > 0)
		{
			// append '\0' to end of buffer
			// NOTE: always okay because only filled up to cbProcOutputBuf-1 bytes
			rgchProcOutputBuf[cb] = '\0';

			// write buffer to output window
			pSpawner->DisplayOutputFromConsole(rgchProcOutputBuf);
		}

		TRACE("spawner 0x%08x : GetLastError() from ReadFile = 0x%08x\n", pSpawner, GetLastError());

		// indicate that process finished output
		SetEvent(pSpawner->m_hDoneEvent);

		// send window message to main thread
		// PostMessage(hwndFrame, WM_NULL, 0, 0);
	} while (TRUE);

	TRACE("spawner 0x%08x : ReadChildProcessOutput thread committing suicide\n", pSpawner);
}

void _cdecl CConsoleSpawner::WaitChildProcessFinish(LPVOID lpv)
{
	CConsoleSpawner *pSpawner = (CConsoleSpawner *)lpv;

	// wait until process has been terminated
	TRACE("spawner 0x%08x : waiting for process to terminate\n", pSpawner);
	WaitForSingleObject(pSpawner->m_procinfo.hProcess, INFINITE);
	TRACE("spawner 0x%08x : returned from wait for process to terminate\n", pSpawner);

	GetExitCodeProcess(pSpawner->m_procinfo.hProcess, &(pSpawner->m_dwTermStatus));

	pSpawner->m_fThreadDie = TRUE;
	SetEvent(pSpawner->m_hSpawnEvent);

	TRACE("spawner 0x%08x : waiting for ReadChildProcessOutput thread to terminate\n", pSpawner);
	WaitForSingleObject(pSpawner->m_hSpawnThread, INFINITE);
	TRACE("spawner 0x%08x : returned from wait for ReadChildProcessOutput thread to terminate\n", pSpawner);
	CloseHandle(pSpawner->m_hSpawnThread);

	// if there's text in the output hold buffer (m_szOutput), flush it now
	if (pSpawner->m_ichOutput)
		pSpawner->DisplayOutputFromConsole("\r\n");

	if (pSpawner->m_hNotifyEvent != NULL)
	{
		// assume that notified owner will output termination messages
		ASSERT(pSpawner->m_hCleanEvent == NULL);
		pSpawner->m_hCleanEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		ASSERT(pSpawner->m_hCleanEvent != NULL);
		SetEvent(pSpawner->m_hNotifyEvent);
		WaitForSingleObject(pSpawner->m_hCleanEvent, INFINITE);
		ASSERT(pSpawner == *(pSpawner->m_ppSpawner));
		*(pSpawner->m_ppSpawner) = NULL;
		VERIFY(CloseHandle(pSpawner->m_hNotifyEvent));
		VERIFY(CloseHandle(pSpawner->m_hCleanEvent));
	}
	else
	{
		// check to see if we killed the process so we can put a message out
		if (WaitForSingleObject(pSpawner->m_hCancelEvent, 0) == WAIT_OBJECT_0)
		{
			pSpawner->m_strOutput.LoadString(IDS_TOOL_STOP_MSG);
		}
		else
		{
			pSpawner->m_strError.LoadString(IDS_ERR_TOOL_RETURN);
			pSpawner->m_strOutput.Format(pSpawner->m_strError, pSpawner->m_dwTermStatus);
		}
		if (theApp.m_bInvokedCommandLine)
		{
			theApp.WriteLog(pSpawner->m_strOutput, TRUE);
		}
		else
		{
			g_IdeInterface.GetOutputWindow()->OutputWindowQueueHit(pSpawner->m_nOutputWindowID, pSpawner->m_strOutput, FALSE, TRUE, FALSE);
		}
		ASSERT(pSpawner == *(pSpawner->m_ppSpawner));
		*(pSpawner->m_ppSpawner) = NULL;
	}
	
	TRACE("spawner 0x%08x : cleaning up spawner object\n", pSpawner);
	VERIFY(CloseHandle(pSpawner->m_procinfo.hThread));
	VERIFY(CloseHandle(pSpawner->m_procinfo.hProcess));
	VERIFY(CloseHandle(pSpawner->m_hNulStdin));
	VERIFY(CloseHandle(pSpawner->m_hReadPipe));
	VERIFY(CloseHandle(pSpawner->m_hCancelEvent));
	VERIFY(CloseHandle(pSpawner->m_hSpawnEvent));

	// reset flag enabling subsequent spawns
	pSpawner->m_fEnableSpawn = TRUE;

	TRACE("spawner 0x%08x : deleting spawner object\n", pSpawner);
	delete pSpawner;

	TRACE("spawner 0x%08x : WaitChildProcessFinish thread committing suicide\n", pSpawner);
	_endthread();
}

CConsoleSpawner::CConsoleSpawner(CConsoleSpawner **ppSpawner)
{
	// set up the back pointer which is set to NULL upon spawn termination
	m_ppSpawner = ppSpawner;
	// Create an error context
	m_hSpawnErrors = CreateErrorContext(SPAWN_ERROR_DEPTH, 0, 0);
	m_ichOutput = 0;
	memset((void *)&m_startinfo, 0, sizeof(STARTUPINFO));
	m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	m_sa.lpSecurityDescriptor = NULL;
	m_sa.bInheritHandle = TRUE;
	m_hDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	ASSERT(m_hDoneEvent != NULL);
	m_fEnableSpawn = TRUE;
	m_hNotifyEvent = NULL;
	m_hCleanEvent = NULL;
	m_hSpawnThread = NULL;
	m_hWaitThread = NULL;
	m_hSpawnEvent = NULL;
	m_hCancelEvent = NULL;
}

CConsoleSpawner::~CConsoleSpawner()
{
	// Destroy the error context
	DestroyErrorContext(m_hSpawnErrors);
	VERIFY(CloseHandle(m_hDoneEvent));
}

BOOL CConsoleSpawner::InitializeSpawn(LPTSTR lpszSpawnDir, UINT nOutputWindowID, BOOL bClearOutputWindow, BOOL bSaveAll /* = TRUE */, CErrorContext *pEC )
{
	// Save modified documents before spawning tool/build?
	if (bSaveAll)
	{
		LPSOURCEQUERY pInterface = g_IdeInterface.GetSourceQuery();
		if (pInterface != NULL && pInterface->IsSaveBeforeRunning() == S_OK)
			DoSaveBeforeSpawn();
	}

	m_nFileWarnings = 0;
	m_nFileErrors = 0;
	m_ichOutput = 0;

	// Set the output to redirect to the correct output window
	m_nOutputWindowID = nOutputWindowID;
	m_pEC = pEC;

	if (m_nOutputWindowID != -1)
		VERIFY(InitializeInternal(bClearOutputWindow));

	// save away the project build directory for the call to CreateProcess
	m_strSpawnDir = lpszSpawnDir;
	return TRUE;
}

BOOL CConsoleSpawner::PerformSpawn(LPTSTR lpszCommandLine, BOOL bMultipleCommand)
{
	if (m_nOutputWindowID != -1)
		return(PerformInternal(lpszCommandLine, bMultipleCommand));
	else
		return(PerformExternal(lpszCommandLine, bMultipleCommand));
}

BOOL CConsoleSpawner::PerformSpawnMultiple(CStringList *plistCommands)
{
	static const TCHAR szCmdSep[] = { chCmdSep, 0 };
	CString strCommands;
	int  nCommands = plistCommands->GetCount();
	BOOL bMultipleCommand = nCommands > 1;

	POSITION pos = plistCommands->GetHeadPosition();
	while (pos)
	{
		strCommands += plistCommands->GetNext(pos);
		if (pos)
			strCommands += szCmdSep;
	}

	if (!strCommands.IsEmpty())
		return(PerformSpawn((LPTSTR)LPCTSTR(strCommands), bMultipleCommand));

	return(FALSE);
}

void CConsoleSpawner::CancelSpawn()
{
	if (m_hCancelEvent != (HANDLE)0)
		VERIFY(SetEvent(m_hCancelEvent));
}

void CConsoleSpawner::DisplayOutputFromConsole(LPTSTR lpszText)
{
	int cb;
	LPTSTR lpszBegin = lpszText;

	// loop through all characters in string
	while (*lpszText)
	{
		// process special characters
		//
		switch (*lpszText)
		{
			case '\t':
				// if enough room, convert tabs into spaces
				if (m_ichOutput < MAX_USER_LINE)
					m_szOutput[m_ichOutput ++] = ' ';
				else
					// no room
					goto OverFlow ;
				break;

			case '\r':
				// Ignore CR
				break;

			case '\n':
				// treat LF as end of line marker
				// terminate string*
				m_szOutput[m_ichOutput] = '\0';
				// add to output window
				IsItErrorOrWarning(m_szOutput);
			//	OemToChar((LPCTSTR)m_szOutput, (LPSTR)m_szOutput);
				if( m_pEC != NULL ){
					m_pEC->AddString(m_szOutput);
				}
				else
				{
					if (theApp.m_bInvokedCommandLine)
					{
						theApp.WriteLog(m_szOutput, TRUE);
					}
					else
					{
						if (g_IdeInterface.GetOutputWindow() != NULL){
							g_IdeInterface.GetOutputWindow()->OutputWindowQueueHit(m_nOutputWindowID, m_szOutput, TRUE, TRUE, FALSE);
						}
					}
				}
				// set up for next line
				m_ichOutput = 0;
				break;

			default:
				// we have a regular character.  Save it if
				// we've got the room
				if (m_ichOutput + (cb = _ftclen(lpszText)) < MAX_USER_LINE + 1)
				{
					// olympus 1281:  The read from the pipe may have truncated
					// a double-byte character.  Make sure we don't copy a bogus
					// trail byte into the buffer.  NOTE that the input buffer *MUST*
					// be null-terminated!
					cb = (*(lpszText + 1) == '\0') ? 1 : cb;
					_ftccpy(m_szOutput + m_ichOutput, lpszText);
					m_ichOutput += cb;
				}
				else
				{
					// we don't have the room.  Terminate the
					// string here
OverFlow:
					// terminate
					//
				    m_szOutput[m_ichOutput] = '\0' ;
					// Make sure that the character we just boofed gets included
					// in the next line.  (I.e., negate the inc that happens at the
					// bottom of the loop.)
					if (lpszText > lpszBegin)
						lpszText = _ftcsdec(lpszBegin, lpszText);
					// add to output window
					IsItErrorOrWarning(m_szOutput);
				//	OemToChar((LPCTSTR)m_szOutput, (LPSTR)m_szOutput);
					if( m_pEC != NULL ){
						m_pEC->AddString(m_szOutput);
					}
					else
					{
						if (theApp.m_bInvokedCommandLine)
						{
							theApp.WriteLog(m_szOutput, TRUE);
						}
						else
						{
							if (g_IdeInterface.GetOutputWindow() != NULL) {
								g_IdeInterface.GetOutputWindow()->OutputWindowQueueHit(m_nOutputWindowID, m_szOutput, TRUE, TRUE, FALSE);
							}
						}
					}
					// set up for next line
					m_ichOutput = 0;
				}
				break;
		} // switch

		// advance to next character
		//
		// olympus 1281:  We don't know if a DBC has been split...
		cb = _ftclen(lpszText);
		cb = (*(lpszText + 1) == '\0') ? 1 : cb;
		lpszText += cb;
	} // while
}

static char szErrorString[40] = { 0 };
static char szWarningString[40] = { 0 };

BOOL CConsoleSpawner::IsItErrorOrWarning(char *pszString)
{
	LPSTR pchCur, pchError, pchWarning, pchUse, pchEnd;
	BOOL  bWarning;
	static ULONG cbError;
	static ULONG cbWarning;

	if (!szErrorString[0])
	{
		VERIFY(LoadString(GetResourceHandle(), IDS_OUTPUT_ERROR, szErrorString, sizeof(szErrorString)));
		VERIFY(LoadString(GetResourceHandle(), IDS_OUTPUT_WARNING, szWarningString, sizeof(szWarningString)));
		cbError = _tcslen(szErrorString);
		cbWarning = _tcslen(szWarningString);
	}

	// See if string contains error or warning pattern.
	pchCur = pszString;

Rescan:
	pchError = stristr(pchCur, szErrorString);
	pchWarning = stristr(pchCur, szWarningString);

	if ((pchError != NULL) && (pchWarning != NULL))
	{
		// Found both.  Use the first one (earliest in the string).
		if (pchError < pchWarning)
		{
			pchUse = pchError;
			bWarning = FALSE;
			pchEnd = pchUse + cbError;
		}
		else
		{
			pchUse = pchWarning;
			bWarning = TRUE;
			pchEnd = pchUse + cbWarning;
		}
	}
	else if ((pchError == NULL) && (pchWarning == NULL))
	{
		// Didn't find either.  Set pchUse to NULL as well.
		pchUse = NULL;
	}
	else
	{
		// Found either "error" or "warning".  Use the one we found.

		if (pchError != NULL)
		{
			pchUse = pchError;
			bWarning = FALSE;
			pchEnd = pchUse + cbError;
		}
		else
		{
			pchUse = pchWarning;
			bWarning = TRUE;
			pchEnd = pchUse + cbWarning;
		}
	}

	if (pchUse != NULL)
	{
		char FAR *lpchPrev = _ftcsdec(pszString, pchUse);

		// if error string is not the 1st word && not prepended by whitespace
		// or not followed by whitespace or a ':' we should rescan
		if (((pchUse != pszString) && (*lpchPrev != ' ') && (*lpchPrev != '\t')) ||
			 ((*pchEnd != ' ') && (*pchEnd != '\t') && (*pchEnd != ':')))
		{
			pchCur = _ftcsinc(pchUse);
			goto Rescan;	// error is probably a subdir or a filename,
							// so scan further.
		}
    }
    else
	{
    	return FALSE;
	}

	// update appropriate error counts
	if (!bWarning)
	{
		++m_nFileErrors;
		PlayDevSound(IDS_SOUND_OUTPUT_ERROR);
	}
	else
	{
		++m_nFileWarnings;
		PlayDevSound(IDS_SOUND_OUTPUT_WARNING);
	}

	return TRUE;
}

void CConsoleSpawner::GetErrorWarningCount(DWORD *pdwErrors, DWORD *pdwWarnings)
{
	ASSERT(pdwErrors != NULL);
	ASSERT(pdwWarnings != NULL);
	*pdwErrors = m_nFileErrors;
	*pdwWarnings = m_nFileWarnings;
}

BOOL CConsoleSpawner::InitializeInternal(BOOL bClearOutputWindow)
{
	// Clear the error context
	VERIFY(ClearError((LPTERROR)m_hSpawnErrors));

	if (!theApp.m_bInvokedCommandLine)
	{
		// open the error window
		DkWShowWindow(MAKEDOCKID(PACKAGE_VCPP, IDDW_OUTPUT), TRUE);

		if (bClearOutputWindow)
		{
			// mark for clear in subsequent SelectVwin call
			g_IdeInterface.GetOutputWindow()->OutputWindowVwinClear(m_nOutputWindowID);
			// note: window not actually cleared until subsequent SelectVwin call

			// selected output window is brought to the top and cleared
			g_IdeInterface.GetOutputWindow()->OutputWindowSelectVwin(m_nOutputWindowID, TRUE);

		}
	}

	// create semaphore for indicating process spawned
	if ((m_hSpawnEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
		return FALSE;	// REVIEW: UNDONE report error: could not create semaphore

	// create thread for reading output from process
	unsigned dwThreadID;
	if ((m_hSpawnThread = (HANDLE)_beginthreadex( NULL, cbThrdStack, ::ReadChildProcessOutput, this, 0, &dwThreadID )) == (HANDLE)0)
		return FALSE;	// REVIEW: UNDONE report error: could not create thread

	return TRUE;
}

BOOL CConsoleSpawner::PerformInternal(LPTSTR lpszCommandLine, BOOL bMultipleCommand)
{
	CHAR *pszCreate = NULL, *pszSpawn = NULL, *pszShell = NULL;
	BOOL fUseComspec = FALSE;
	BOOL fUtilIsShell = FALSE;
	BOOL fCreateSuccess;	// create process succeeded?
	DWORD dwError;

	char szMsvcPath[_MAX_PATH];

	if (GetModuleFileName(NULL, szMsvcPath, sizeof(szMsvcPath)))
	{
		char szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
		_splitpath(szMsvcPath, szDrive, szDir, NULL, NULL);
		_makepath(szMsvcPath, szDrive, szDir, NULL, NULL);
	}
	
	// set flag disabling subsequent spawns
	m_fEnableSpawn = FALSE;

	m_CompileState = CS_START;
	// scan lpszCommandLine for redirection characters, and
	// check utility for being the shell.
	{
		char *pchT = lpszCommandLine + _ftcscspn(lpszCommandLine, rgchCmdProcChar);
		char *pszEnv;
		if (pszEnv = getenv("COMSPEC"))
		{
			pszShell = (char *)malloc(_ftcslen(pszEnv) + 5);
			_ftcscpy(pszShell, pszEnv);
			_ftcscat(pszShell, " /c ");
			fUtilIsShell = !!stristr(lpszCommandLine, pszShell);
		}
		else
		{
			VERIFY(PushError(m_hSpawnErrors, IDS_ERR_CANNOT_SPAWN_TOOL));
			goto CleanUp;
		}
		fUseComspec = !!*pchT && !fUtilIsShell;
	}

	pszSpawn = (CHAR *)malloc(_ftcslen(m_szSpawnTool) + _ftcslen(szMsvcPath) + _ftcslen(lpszCommandLine) + _ftcslen(pszShell));

	if (pszSpawn == NULL)
	{
		VERIFY(PushError(m_hSpawnErrors, ERROR_NOT_ENOUGH_MEMORY));
		goto CleanUp;
	}

	m_CompileState = CS_CREATEALLOC;

	// initialize that process not complete
	ResetEvent(m_hDoneEvent);

	// create an event object to signal vcspawn.exe when to kill
	//  the child process tree.  note that we have the manual reset
	//  option set so that we can detect when we killed the process
	//  w/o using another flag.
	if (!(m_hCancelEvent = CreateEvent(&m_sa, TRUE, FALSE, NULL)))
	{
		VERIFY(PushError(m_hSpawnErrors, SYSTEM_ERROR | GetLastError()));
		goto CleanUp;
	}

	m_CompileState = CS_CREATEEVENT;

	// Create the spawn string with the vcspawn prepended
	sprintf(pszSpawn, m_szSpawnTool, szMsvcPath, (DWORD)m_hCancelEvent, bMultipleCommand ? szMultCmd : "");
	pszCreate = pszSpawn + _ftcslen(pszSpawn);

	// create string for combined lpUtil and lpCmdLine
	// Need a command shell?
	if (fUseComspec)
		_ftcscat(pszSpawn, pszShell);


	// form the rest of the command line
	_ftcscat(pszSpawn, lpszCommandLine);

	if (!CreatePipe(&m_hReadPipe, &m_hpipeWriteOut, &m_sa, cbPipeBuf))
	{
		VERIFY(PushError(m_hSpawnErrors, SYSTEM_ERROR | GetLastError()));
		goto CleanUp;
	}

	m_CompileState = CS_CREATEPIPE;

	// must use a different handle for stderr because some apps (like cl.exe)
	// use dup2() which closes the current target handle if open.  this has
	// the effect of closing both handles if we only pass in the one handle
	// in both hStdOutput and hStdError fields of STARTUPINFO
	m_hGeneric = GetCurrentProcess();
	if (!DuplicateHandle(
			m_hGeneric,					// source process
			m_hpipeWriteOut,			// source handle to dupe
			m_hGeneric,					// target process
			&m_hpipeWriteErr,			// new handle
			DUPLICATE_SAME_ACCESS,		// access flags
			TRUE,						// make it inheritable
			DUPLICATE_SAME_ACCESS))		// option flags
	{
		VERIFY(PushError(m_hSpawnErrors, SYSTEM_ERROR | GetLastError()));
		goto CleanUp;
	}

	m_CompileState = CS_DUPLICATEHANDLES;

	// create a handle to /dev/nul
	m_hNulStdin = CreateFile("NUL", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		&m_sa, OPEN_ALWAYS, 0, INVALID_HANDLE_VALUE);

	if (m_hNulStdin == INVALID_HANDLE_VALUE)
	{
		VERIFY(PushError(m_hSpawnErrors, SYSTEM_ERROR | GetLastError()));
		goto CleanUp;
	}

	m_CompileState = CS_CREATENULFILE;

	m_startinfo.cb = sizeof(STARTUPINFO);
	m_startinfo.lpReserved = NULL;
	m_startinfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	m_startinfo.hStdOutput = m_hpipeWriteOut;
	m_startinfo.hStdError = m_hpipeWriteErr;
	m_startinfo.hStdInput = m_hNulStdin;
	m_startinfo.wShowWindow = SW_HIDE;

	fCreateSuccess = CreateProcess(NULL, pszSpawn, NULL, NULL, TRUE,
		CREATE_NEW_CONSOLE, NULL, m_strSpawnDir, &m_startinfo, &m_procinfo);

	dwError = GetLastError();
	// GetLastError() returns ERROR_ACCESS_DENIED on NT German when path contains extended chars!
	if (!fCreateSuccess && (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_ACCESS_DENIED))
	{
		// Unable to run vcspawn with explicit path, try without...
		sprintf(pszSpawn, szSpawnToolNoQuote, "", (DWORD)m_hCancelEvent, bMultipleCommand ? szMultCmd : "");
		if (fUseComspec)
			_ftcscat(pszSpawn, pszShell);
		_ftcscat(pszSpawn, lpszCommandLine);
		fCreateSuccess = CreateProcess(NULL, pszSpawn, NULL, NULL, TRUE,
			CREATE_NEW_CONSOLE, NULL, m_strSpawnDir, &m_startinfo, &m_procinfo);
	}
	if (pszShell != NULL){
		free(pszShell);
		pszShell = NULL;
	}

	// Unable to run vcspawn (either explicitly pathed or not)...
	if (!fCreateSuccess && (GetLastError() == ERROR_FILE_NOT_FOUND))
	{
		if (!m_fUserWarned)
		{
			ReportMissingFile("VCSPAWN.EXE");
			m_fUserWarned = TRUE;
		}
	}

	if (fCreateSuccess)
	{
		// create thread which waits for process termination
		m_fThreadDie = FALSE;
		m_hWaitThread = (HANDLE)_beginthread(CConsoleSpawner::WaitChildProcessFinish, cbThrdStack, this);
		ASSERT(m_hWaitThread != (HANDLE)-1);	// REVIEW: UNDONE report error: could not create thread

		// indicate process spawned
		SetEvent(m_hSpawnEvent);
		free(pszSpawn);

		// close our copies of pipe write handles
		VERIFY(CloseHandle(m_hpipeWriteOut));
		VERIFY(CloseHandle(m_hpipeWriteErr));
		return(TRUE);
	}

CleanUp:
	dwError = GetLastError();
	VERIFY(PushError(m_hSpawnErrors, SYSTEM_ERROR | dwError));
	VERIFY(PushError(m_hSpawnErrors, IDS_ERR_CANNOT_SPAWN_TOOL));

	if (pszShell != NULL){
		free(pszShell);
		pszShell = NULL;
	}

	switch(m_CompileState)
	{
		default:
			ASSERT(FALSE);
			break;
		case CS_SUCCESSFUL:
		case CS_KILLEDPROCESS:
		case CS_CREATEPROCESS:
			// Successful CreateProcess
			VERIFY(CloseHandle(m_procinfo.hThread));
			VERIFY(CloseHandle(m_procinfo.hProcess));
		case CS_CREATENULFILE:
			// Successful CreateFile("NUL")
			VERIFY(CloseHandle(m_hNulStdin));
		case CS_DUPLICATEHANDLES:
		case CS_CREATEPIPE:
			// Successful DuplicateHandle
			// Successful CreatePipe
			VERIFY(CloseHandle(m_hReadPipe));
			m_hReadPipe = INVALID_HANDLE_VALUE;
		case CS_CREATEEVENT:
			// Successful CreateEvent
			VERIFY(CloseHandle(m_hCancelEvent));
			m_hCancelEvent = (HANDLE)0;
		case CS_CREATEALLOC:
			free(pszSpawn);
		case CS_START:
			VERIFY(CloseHandle(m_hSpawnEvent));
			break;
	}

	LPTSTR pszError = m_strError.GetBuffer(TMP_STRING_SIZE);
	int nError;
	while (nError = PopError(m_hSpawnErrors))
	{
		if(LoadError(GetResourceHandle(), nError, pszError, TMP_STRING_SIZE))
		{
			if (theApp.m_bInvokedCommandLine)
			{
				if (pszError != NULL)
				{
					theApp.WriteLog(pszError, TRUE);
				}
			}
			else
			{
				g_IdeInterface.GetOutputWindow()->OutputWindowQueueHit(m_nOutputWindowID, pszError, FALSE, TRUE, FALSE);
			}
		}
	}
	m_strError.ReleaseBuffer();

	// reset flag enabling subsequent spawns
	m_fEnableSpawn = TRUE;

	*m_ppSpawner = NULL;
	delete this;

	return(FALSE);
}

BOOL CConsoleSpawner::PerformExternal(LPTSTR lpszCommandLine, BOOL bMultipleCommand)
{
	BOOL fCreateSuccess;	// create process succeeded?

	CString strExecute;
	if (!m_fCloseWindow && !m_fGUITool)
		strExecute.Format(TEXT("%s -%c -%c %s"), szVCSpawnCmd, chToolFlag, chPauseFlag, lpszCommandLine);
//	else if (NotOnNT() && (exeType == EXE_DOS))
//		strExecute.Format(TEXT("%s -%c %s %s"), szVCSpawnCmd, chToolFlag, lpszCommandLine);
	else
		strExecute = lpszCommandLine;

	m_startinfo.cb = sizeof(STARTUPINFO);
	m_startinfo.lpReserved = NULL;

	TCHAR szPath[_MAX_PATH];
	// Preserve current directory
	if (_getcwd(szPath, _MAX_PATH) == NULL)
		return(FALSE);

	fCreateSuccess = CreateProcess(NULL, (LPSTR)(LPCTSTR)strExecute, NULL, NULL, FALSE,
		CREATE_NEW_CONSOLE, NULL, m_strSpawnDir, &m_startinfo, &m_procinfo);

	if (fCreateSuccess)
	{
		CloseHandle(m_procinfo.hProcess);
		CloseHandle(m_procinfo.hThread);
		if (m_fReloadNoPrompt && g_IdeInterface.GetEditDebugStatus() != NULL)
			// don't prompt when reloading next modified file
			g_IdeInterface.GetEditDebugStatus()->SetLoadNextFileNoPrompt(TRUE);
	}
	else
	{
		UINT idstr;

		// See if we can give a more specific reason for the failure
		switch(GetLastError())
		{
			case ERROR_DIRECTORY:
			case ERROR_INVALID_DRIVE:
			case ERROR_PATH_NOT_FOUND:
				idstr = IDS_ERR_PATH_NOT_FOUND;
				break;

			case ERROR_FILE_NOT_FOUND:
				idstr = IDS_ERR_FILE_NOT_FOUND;
				break;

			case ERROR_BAD_FORMAT:
				idstr = IDS_ERR_BAD_EXE_FORMAT;
				break;

			case ERROR_NOT_ENOUGH_MEMORY:
				idstr = IDS_ERR_NOT_ENOUGH_MEMORY;
				break;

			default:
				idstr = IDS_ERR_CANNOT_SPAWN_TOOL;
				break;
		}

		ErrorBox(idstr);
	}

	// Restore directory
	SetDriveAndDir(szPath);

	*m_ppSpawner = NULL;
	delete this;

	return(fCreateSuccess);
}

/////////////////////////////////////////////////////////////////////////////

//
// Error handling functions
//

#ifdef _DEBUG
void _KeyError(LPSTR pszFile, UINT nLine)
{
	AfxAssertFailedLine(pszFile, nLine);
}
#endif

// Create and destroy error context

LPTERROR CreateErrorContext(UINT nErrorDepth, UINT nErrorMin, UINT nErrorMax)
{
	LPTERROR lpError;

	// Allocate the context and stack and set the top pointer
	VERIFY(lpError = (LPTERROR)malloc(sizeof(TERROR)));
	VERIFY(lpError->lpStack = (LPLONG)malloc(sizeof(*lpError->lpStack) * nErrorDepth));

	lpError->lpTop = lpError->lpStack;
	lpError->lpEnd = lpError->lpStack + nErrorDepth;
	lpError->nErrorMin = nErrorMin;
	lpError->nErrorMax = nErrorMax;

	KEYSET(lpError, ERRORKEY);

	return lpError;
}

void DestroyErrorContext(LPTERROR lpError)
{
	// Deallocate the stack and context
	free(lpError->lpStack);
	free(lpError);
}

// Push the error onto the context
BOOL PushError(LPTERROR lpError, ULONG nError)
{
	KEYCHECKRET(lpError, ERRORKEY, 0);

	// Error number out of bounds
	if (lpError->nErrorMin && lpError->nErrorMax &&
		(nError < lpError->nErrorMin || nError > lpError->nErrorMax))
	{
		return FALSE;
	}

	// Topped out!
	if (lpError->lpTop >= lpError->lpEnd)
	{
		return FALSE;
	}

	*(lpError->lpTop++) = nError;
	return TRUE;
}

// Pop from the context
LONG PopError(LPTERROR lpError)
{
	KEYCHECKRET(lpError, ERRORKEY, 0);

	// Bottomed out!
	if (lpError->lpTop <= lpError->lpStack)
	{
		return 0;
	}

	(lpError->lpTop)--;

	return *(lpError->lpTop);
}

// Clear the error stack
BOOL ClearError(LPTERROR lpError)
{
	KEYCHECKRET(lpError, ERRORKEY, FALSE);

	lpError->lpTop = lpError->lpStack;
	return TRUE;
}

// Get the current stack depth

INT GetDepth(LPTERROR lpError)
{
	KEYCHECKRET(lpError, ERRORKEY, -1);

	return lpError->lpTop - lpError->lpStack;
}

// Index into the stack (positive from top)

LONG IndexError(LPTERROR lpError, UINT nIndex)
{
	INT	nStackIndex, nDepth;

	KEYCHECKRET(lpError, ERRORKEY, 0L);

	nDepth = lpError->lpTop - lpError->lpStack;
	nStackIndex =  nDepth - nIndex -1;

	if(nStackIndex < 0 || nStackIndex > nDepth)
	{
		return 0L;
	}

	return lpError->lpStack[nStackIndex];
}

//
// Load the error string into the string buffer
//	If the error is a system error use FormatMessage.
//	Else assume that the error has a string table reference associated with it
//
//	Return the number of chars copied into the string buffer
//

int LoadError(HANDLE hInstance, UINT nErrorNum, LPSTR szBuffer, size_t nBufsize)
{
	LPTSTR	lpBuffer;	// memory allocated by FormatMessage function
	int		nCharsCopied;

	if(nErrorNum & SYSTEM_ERROR)
	{
		if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
					  FORMAT_MESSAGE_IGNORE_INSERTS | 
					  FORMAT_MESSAGE_ALLOCATE_BUFFER,
					  NULL, nErrorNum & ~SYSTEM_ERROR,		//Mask syserror bit
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					  (LPTSTR)&lpBuffer, 0, NULL))
		{
			nCharsCopied = min(nBufsize, RemoveNewlines(lpBuffer));
			_ftcsncpy(szBuffer, lpBuffer, nBufsize);
			LocalFree(lpBuffer);
		}
		else
			nCharsCopied = 0;
	}
	else
	{
		nCharsCopied = LoadString((HINSTANCE)hInstance, nErrorNum, szBuffer, nBufsize);
	}

	return nCharsCopied;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\slob.cpp ===
#include "stdafx.h"

#include "slob.h"
#include "util.h"
#include "utilauto.h"
#include "prjapi.h"
#include "prjguid.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// IMPLEMENT_DYNCREATE needs real new.
#undef new
#endif

IMPLEMENT_SERIAL(CSlob, CObject, 1)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


#define theClass CSlob
PRD BASED_CODE CSlob::m_rgprd [] =
{
	{ P_BEGIN_MAP, NULL, PRD::null, "CSlob" },
	SLOB_PROP(Container)
	{ P_END_MAP, NULL, PRD::null, NULL }
};
#undef theClass

const PRD* PrdFindProp(const PRD* propMap, UINT idProp)
{
	for ( ; propMap != NULL; propMap = (PRD*)propMap[0].pbOffset)
	{
		for (int iProp = 1; propMap[iProp].nProp != P_END_MAP; iProp += 1)
		{
			if (propMap[iProp].nProp == idProp)
				return &propMap[iProp];
		}
	}

	return NULL;
}

CSlob::CSlob()
{
	m_pContainer = NULL;
	m_cDep = 0;
}

CSlob::~CSlob()
{
	InformDependants(SN_DESTROY);

	ASSERT(m_cDep >= 0 && m_cDep <= 3);	// 3 means we are using a CObList.
	if (m_cDep == 3)
		delete (CObList*) m_aDep[0];
}


// Return a list containing any contained (child) slobs.  The default
// is for slobs to not be containers.  Override for any slob that may
// contain other slobs.
//
CObList* CSlob::GetContentList()
{
	return NULL;
}


// Create a "clone" of this.  The clone should not have a container and
// some other information may not be copied (such as a symbol).  This
// is used by the Cut, Copy and Paste commands, Ctrl+Drag, and any other
// user actions that need to copy slobs...
//
// The default coppies all properties except P_Container and P_ID as well
// as all decendants of the slob.  If the slob is a CMultiSlob, all the
// slobs it references as well as their decendants are clones.
//
// Override this for slobs that have other cloning needs, but be sure to
// call this function first thing...
//
CSlob* CSlob::Clone()
{
	CRuntimeClass* pClass = GetRuntimeClass();
	CSlob* pClone = (CSlob*)pClass->CreateObject();
	ASSERT(pClone != NULL);

	CopyProps(pClone);

	// Now clone any contained slobs as well.
	//
//
// FUTURE:	This function does some really messy hacks at the end to make
//			Clone() work properly for both Slobs and MultiSlobs, cloning
//			them in the proper order such that the clone is ordered
//			identically do the original.  See the HACK comment below to
//			understand why this is needed.  It should eventually be
//			cleaned	up -- ggh 02-Sep-92
//
	// HACK:	Note that we have two different algorithms for cloning a
	// 			slob, depending on whether this is a multislob or not.
	//			This is because a MULTISLOB currently (as of v1 alpha)
	//			behaves by adding to the head instead of the tail, which
	//			would cause Clone() to reverse the list, were we not
	//			careful.  The proper long-term fix is to change the places
	//			that depend on Add doing an AddHead to expect Add to do an
	//			AddTail.  The AddHead hack is used to make selections easy
	//			to deal with (making something the head of the multislob
	//			makes it the dominant selection).	ggh 02-Sep-92

	if (GetContentList() != NULL)
	{
		if (IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		{
			CObList *plist = GetContentList();
			POSITION pos = plist->GetTailPosition();
			while (pos != NULL)
			{
				CSlob* pContentClone = ((CSlob *) plist->GetPrev(pos))->Clone();
				if (pContentClone != NULL)
					pClone->Add(pContentClone);
			}
		}
		else
	    {
			POSITION pos = GetHeadPosition();
			while (pos != NULL)
			{
				CSlob* pContentClone = GetNext(pos)->Clone();
				if (pContentClone != NULL)
				{
					pContentClone->m_pContainer = pClone;
					pClone->Add(pContentClone);
				}
			}
	    }
	}

	return pClone;
}

///////////////////////////////////////////////////////////////////////////////
//	Copy the properties for this slob, both map and bag
void CSlob::CopyProps(CSlob * pClone)
{
	ASSERT(pClone != (CSlob *)NULL);

	// Copy most of the properties...
	const PRD* rgprd = GetPropMap();
	for ( ; rgprd != NULL; rgprd = (const PRD*)rgprd[0].pbOffset)
	{
		for (int iprd = 1; rgprd[iprd].nProp != P_END_MAP; iprd += 1)
		{
			if (rgprd[iprd].pbOffset == 0)
				continue;

			switch (rgprd[iprd].nProp)
			{
			case P_Container:
			case P_ID:
				// Don't ever copy these properties!
				continue;
			}

			BYTE* pbProp = (BYTE*)this + (DWORD)rgprd[iprd].pbOffset;
			BYTE* pbCloneProp = (BYTE*)pClone + (DWORD)rgprd[iprd].pbOffset;

			switch (rgprd[iprd].nType)
			{
			case PRD::null:
			case PRD::action:
				break;

			case PRD::booln:
			case PRD::integer:
				*(int*)pbCloneProp = *(int*)pbProp;
				break;

			case PRD::longint:
				*(long*)pbCloneProp = *(long*)pbProp;
				break;

			case PRD::number:
				*(double*)pbCloneProp = *(double*)pbProp;
				break;

			case PRD::string:
				*(CString*)pbCloneProp = *(CString*)pbProp;
				break;

			case PRD::slob:
				// NOTE:  This only copies a reference to the
				// slob, it doesn't copy the slob itself!
				*(CSlob**)pbCloneProp = *(CSlob**)pbProp;
				break;

			case PRD::rect:
				*(CRect*)pbCloneProp = *(CRect*)pbProp;
				break;

			case PRD::point:
				*(CPoint*)pbCloneProp = *(CPoint*)pbProp;
				break;
			}
		}
	}

	// Clone bagged properties...
	int nBags = GetPropBagCount();
	for (int i = 0; i < nBags; i += 1)
	{
		CPropBag* pBag = GetPropBag(i);
		ASSERT(pBag != NULL);

		pClone->ClonePropBag(pBag, i);
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Clone a the property bag into 'this' CSlob's property bag for
//  nBag (-1 default)
//

void CSlob::ClonePropBag(CPropBag * pBag, int nBag, BOOL fEmpty /*=TRUE*/)
{
	CPropBag * pCloneBag = GetPropBag(nBag);

	pCloneBag->Clone(this, pBag, fEmpty) ;
}

///////////////////////////////////////////////////////////////////////////////
//	Serialize all the properties of a CSlob except P_Container.
//
//	Note that since we go through all the slob's property maps, derived classes
//	will be serialized correctly, and don not need to override Serailize just
//	to get their props saved.

void CSlob::SerializePropMap(CArchive& ar)
{
	const PRD* rgprd = GetPropMap();

	// Loop through slob's prop map and its base classes:
	for ( ; rgprd != NULL; rgprd = (const PRD*)rgprd[0].pbOffset)
	{
		for (int iprd = 1; rgprd[iprd].nProp != P_END_MAP; iprd += 1)
		{
			if (rgprd[iprd].pbOffset == 0)
				continue;

			// do we want to filter out this property id?
			if (!SerializePropMapFilter(rgprd[iprd].nProp))
				continue;

			switch (rgprd[iprd].nProp)
			{
			case P_Container:
				continue;
			}

			BYTE* pbProp = (BYTE*)this + (DWORD)rgprd[iprd].pbOffset;

			if (ar.IsStoring())
			{

				switch (rgprd[iprd].nType)
				{
				case PRD::null:
				case PRD::action:
					break;

				case PRD::booln:
				case PRD::integer:
				case PRD::longint:
					// Archive int's and long's as DWORD to avoid ambiguity:
					ar << ((DWORD) *(int*)pbProp);	
					break;
				case PRD::number:
					ar << *(double*)pbProp;
					break;

				case PRD::string:
					ar << *(CString*)pbProp;
					break;

				case PRD::slob:
					// NOTE:  This only copies a reference to the
					// slob, it doesn't copy the slob itself!
					ar << *(CSlob**)pbProp;
					break;

				case PRD::rect:
					ar << *(CRect*)pbProp;
					break;

				case PRD::point:
					ar << *(CPoint*)pbProp;
					break;
				}	// switch (rgprd[iprd].nType)
			}	// ar.IsStoring()
			else
			{

				switch (rgprd[iprd].nType)
				{
				case PRD::null:
				case PRD::action:
					break;

				case PRD::booln:
				case PRD::integer:
				case PRD::longint:
					// Archive int's and long's as DWORD to avoid ambiguity:
					ar >> ((DWORD&) *(int*)pbProp);	
					break;
				case PRD::number:
					ar >> *(double*)pbProp;
					break;

				case PRD::string:
					ar >> *(CString*)pbProp;
					break;

				case PRD::slob:
					// NOTE:  This only copies a reference to the
					// slob, it doesn't copy the slob itself!
					ar >> *(CSlob**)pbProp;
					break;

				case PRD::rect:
					ar >> *(CRect*)pbProp;
					break;

				case PRD::point:
					ar >> *(CPoint*)pbProp;
					break;
				}	// switch (rgprd[iprd].nType)

			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
//
//	MSF Serialization functions:  Prop map + content list:

void CSlob::Serialize(CArchive& ar)
{
	CObList *pObList;
	POSITION pos;


	SerializePropMap ( ar );
		
	// Content list:
	pObList = GetContentList ();
	if (pObList)
	{
		// Call serialize directly since this is really a member:
	 	pObList->Serialize (ar);

		// If we're loading, need to set containment property as well
		// FUTURE: Should we serialize manually so we can call Add for each 
		// object?
		if (ar.IsLoading())
		{
			for (pos = GetHeadPosition (); pos != NULL; )
			{
				GetNext(pos)->m_pContainer = this;
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// Return the CSlobWnd that 'this' is displayed in.  Default is to see if
// our container knows.  This must be overridden in slobs that actually are
// in windows, or at least the top-most slob in a window (for example, a
// string table needs to know, but each string doesn't).  If a slob is
// displayed in more than one CSlobWnd, this should return the first in
// a list.
//
CSlobWnd* CSlob::GetSlobWnd() const
{
	CSlob* pSlob = m_pContainer;
	while (pSlob != NULL)
	{
		CSlobWnd* pWnd = pSlob->GetSlobWnd();
		if (pWnd != NULL)
			return pWnd;
		
		pSlob = pSlob->m_pContainer;
	}
	
	return NULL;
}

CSlob* CSlob::GetRootContainer()
{
	if (m_pContainer == NULL)
	{
		return(this);
	}
	else
	{
		CSlob* pRootSlob = this;
		while (pRootSlob->m_pContainer != NULL)
		{
			pRootSlob = pRootSlob->m_pContainer;
		}
		return(pRootSlob);
	}
}

/////////////////////////////////////////////////////////////////////////////
// Drag and Drop Support

CSlob*	CSlob::DropTargetFromPoint(CPoint screenPoint)
{
 	CSlobWnd* pWnd = (CSlobWnd*)CWnd::WindowFromPoint(screenPoint);
	ASSERT(pWnd != NULL);
	
	while (pWnd != NULL && !pWnd->IsKindOf(RUNTIME_CLASS(CSlobWnd)))
		pWnd = (CSlobWnd*)pWnd->GetParent();
	
	if (pWnd == NULL)
		return NULL;

	CPoint	ptClient = screenPoint;
	pWnd->ScreenToClient(&ptClient);
	CSlob* pSlob = pWnd->DropTargetFromPoint(ptClient);
	if (pSlob != NULL && pSlob->GetContentList() == NULL)
	{
		pSlob = pSlob->GetContainer();
		if (pSlob == NULL)
			return NULL;
		
		ASSERT(pSlob->GetContentList() != NULL);
	}
	
	return pSlob;
}


// Create a CSlobDragger appropriate for dragging 'pDragObject' around over
// 'this'.  'screenPoint' is the mouse cursor position in screen coordinates.
//
CSlobDragger* CSlob::CreateDragger(CSlob *pDragObject, CPoint screenPoint)
{
	return NULL;
}


// Handle a mouse movement during a drag operation.  'pSlob' is being dragged
// over 'this' with the 'pDragger' created when the mouse first entered our
// space.
//
void CSlob::DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint)
{
}


// Called right before the undo for a drop is setup...
//
void CSlob::PrepareDrop(CDragNDrop* pInfo)
{
}


// A slob has been dropped on 'this'.  It's up to derived classes to
// decide what to do...
//
void CSlob::DoDrop(CSlob *pSlob, CSlobDragger *pDragger)
{
	// Delete this.  It won't be used, if this gets called.
	TRACE( "Failed drag-drop.  CSlob deleted.\n" );
	delete pSlob;
}


// Return an index into the cursor table for dragging this slob.
//
int CSlob::GetCursorIndex()
{
	ASSERT(FALSE); // Drag-dropable objects must define this function.
	return -4;
}


// Return a real cursor for dragging this slob.
//
HCURSOR CSlob::GetCursor(int ddcCursorStyle)
{
	TRACE("Missing a drag cursor!\n");
	return LoadCursor(NULL, IDC_ARROW);
}


/////////////////////////////////////////////////////////////////////////////
// Property Page Interface

BOOL CSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Property Bag Interface

// Get the number of property bags this CSlob has.
//
int CSlob::GetPropBagCount() const
{
	return 0;
}


// Return a specific property bag from this CSlob (index based), or 
// the "current" property bag (when nBag is -1).
//
CPropBag* CSlob::GetPropBag(int nBag /* = -1 */)
{
	ASSERT(nBag == -1);
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// Custom Undo/Redo Action Handling

void CSlob::UndoAction(CSlobSequence* pSeq, UINT idAction)
{
	switch (idAction)
	{
	default:
		ASSERT(FALSE); // Must handle custom actions in derived class!
		return;

//NYI	case A_ADDPROP:
		// FUTURE: Record a remove prop action...
//NYI		theUndoSlob.OnAddProp(this, pBag, nPropID);
//NYI		break;

//NYI	case A_REMOVEPROP:
		// FUTURE: Record an add prop action...
//NYI		switch (nType)
//NYI		{
//NYI		case integer:
//NYI			theUndoSlob.OnRemoveProp(this, pBag, nPropID, ((CIntProp*)pProp)->m_nValue);
//NYI			break;
//NYI		}
//NYI		break;
	}
}


void CSlob::DeleteUndoAction(CSlobSequence* pSeq, UINT idAction)
{
	// Default is to do nothing.
	//
	// Override this if you have defined a custom undo action and
	// need to perform any cleanup when the action is deleted.
}

void CSlob::BeginUndo(UINT nID)
{
	CSlobWnd *pWnd = GetSlobWnd();
	if(NULL != pWnd)
		pWnd->BeginUndo(nID);
}

void CSlob::EndUndo(BOOL bAbort /*= FALSE*/)
{
	CSlobWnd *pWnd = GetSlobWnd();
	if(NULL != pWnd)
		pWnd->EndUndo(bAbort);
}

/////////////////////////////////////////////////////////////////////////////


BOOL CSlob::CanAdd(CSlob* pAddSlob)
{
	if ((pAddSlob == &theClipboardSlob) ||
		(pAddSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob))) )
	{
		// It is a list of slobs, so make sure that all of them are okay
		POSITION pos = pAddSlob->GetHeadPosition();
		if (pos == NULL)
			return FALSE;

		while (pos != NULL)
		{
			if (!CanAdd(pAddSlob->GetNext(pos)))
				return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}


void CSlob::PrepareAddList(CMultiSlob* pAddList, BOOL fPasting)
{
	// Default is to do nothing

	// Override this if you need to prepare for having a list added
	// to a container.  (E.g. the dialog editor uses this to setup
	// the m_nOrder properties of the slobs to be added so the tab
	// order is correct after a drop/paste.)
}

//
// CSlob::Add(aSlob)
//
// Adds <aSlob> to the content list of this slob.  In order for this to
// work, this slob must have a content list.
//
// NOTE: 	Add, by convention, always adds to the TAIL of a slob, not
//			to the head.
//

void CSlob::Add(CSlob* pAddSlob)
{
	CObList* pContentList = GetContentList();
	ASSERT(pContentList != NULL);
	ASSERT(pContentList->Find(pAddSlob) == NULL);
	pContentList->AddTail(pAddSlob);

	InformDependants(SN_CONTENT);
	InformDependants(SN_ADD, (DWORD)pAddSlob);
}


// See if a slob can be removed from 'this'.  Return TRUE if it would
// be okay, or FALSE if it would not.  The default says no, unless the
// slob to be removed is a CMultiSlob, in which case each slob referenced
// by the CMultiSlob is checked; if they can all bew removed, TRUE is
// returned.  Note that this must be overridden if anything is ever to
// be removable.
//
// This function is usually used for things like enabling the Delete and
// Cut commands.
//
BOOL CSlob::CanRemove(CSlob* pRemoveSlob)
{
	if (pRemoveSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
	{
		// It is a list of slobs, so make sure that all of them are okay
		POSITION pos = pRemoveSlob->GetHeadPosition();
		if (pos == NULL)
			return FALSE;

		while (pos != NULL)
		{
			if (!CanRemove(pRemoveSlob->GetNext(pos)))
				return FALSE;
		}

		return TRUE;
	}

	return FALSE;
}


// Removes a slob from 'this'.  Do not call this function!  If you want to
// remove a slob, use MoveInto to move it somewhere else (or NULL to delete
// it).  MoveInto will call this to actually perform the removal.
//
// Override this in slob container classes that must perform any extra
// processing when a slob is removed from it.
//
void CSlob::Remove(CSlob* pRemoveSlob)
{
	CObList* pContentList = GetContentList();
	ASSERT(pContentList != NULL);
	POSITION pos = pContentList->Find(pRemoveSlob);
	ASSERT(pos != NULL);
	pContentList->RemoveAt(pos);
	pRemoveSlob->m_pContainer = NULL;

	InformDependants(SN_CONTENT);
	InformDependants(SN_REMOVE, (DWORD)pRemoveSlob);
}

/////////////////////////////////////////////////////////////////////////////
//	Change Notification Mechanism
//		We optimize for 2 or fewer dependencies, since that all the vast
//		majority of slobs will ever have.

// Add a dependant to 'this'.  The dependant will be notified of any
// property changes or the destruction of 'this'.
//
void CSlob::AddDependant(CSlob* newDependant)
{
	ASSERT(m_cDep >= 0 && m_cDep <= 3);	// 3 means we are using a CObList.
	if (m_cDep < 2)
	{
		if (m_cDep == 0 || m_aDep[0] != newDependant)
			m_aDep[m_cDep++] = newDependant;
	}
	else	// 3 dependants can't fit in the cache.
	{
		if (m_cDep == 2)
		{
			if (m_aDep[0] == newDependant || m_aDep[1] == newDependant)
				return;

			CObList* pExpensiveDependencies = new CObList;
			pExpensiveDependencies->AddTail(m_aDep[0]);
			pExpensiveDependencies->AddTail(m_aDep[1]);
			pExpensiveDependencies->AddTail(newDependant);
			m_aDep[0] = pExpensiveDependencies;
			m_cDep++;
		}
		else
		{
			POSITION pos = ((CObList*) m_aDep[0])->Find(newDependant);
			if (pos == NULL)
				((CObList*) m_aDep[0])->AddTail(newDependant);
		}
	}

	ASSERT(m_cDep >= 0 && m_cDep <= 3);
}


// Remove a dependant of 'this'.
//
void CSlob::RemoveDependant(CSlob* oldDependant)
{
	ASSERT(m_cDep >= 0 && m_cDep <= 3);	// 3 means we are using a CObList.
	if (m_cDep == 1 || m_cDep == 2)
	{
		if (m_aDep[0] == oldDependant)
		{
			if (m_cDep == 2)
				m_aDep[0] = m_aDep[1];

			m_cDep--;
		}
		else if (m_cDep == 2 && m_aDep[1] == oldDependant)
		{
			m_cDep--;
		}
	}
	else if (m_cDep == 3)
	{
		ASSERT(((CObList*) m_aDep[0])->GetCount() > 2);

		POSITION pos = ((CObList*) m_aDep[0])->Find(oldDependant);
		if (pos != NULL)
		{
			((CObList*) m_aDep[0])->RemoveAt(pos);
			if (((CObList*) m_aDep[0])->GetCount() == 2)
			{
				CObList* pExpensiveDependencies = (CObList*) m_aDep[0];
				m_aDep[0] = pExpensiveDependencies->RemoveHead();
				m_aDep[1] = pExpensiveDependencies->RemoveHead();
				delete pExpensiveDependencies;
				m_cDep--;
			}
		}
	}
	ASSERT(m_cDep >= 0 && m_cDep <= 3);
}


// Inform all dependants of 'this' that a change has occured.  Special
// notifications SN_DESTROY and SN_ALL indicate that this slob is being
// destroyed or that all of it's properties may have changed respectively.
// This function is also used when the validity of a property has changed
// so that dependants will find out when a property has been enabled or
// disabled.
//
#define MAX_SAFE_DEPENDANTS 128

void CSlob::InformDependants(UINT idChange, DWORD dwHint)
{
	ASSERT(m_cDep >= 0 && m_cDep <= 3);	// 3 means we are using a CObList.
	if (m_cDep == 0)
		return;
	else if (m_cDep == 1)
		((CSlob*) m_aDep[0])->OnInform(this, idChange, dwHint);
	else if (m_cDep == 2)
	{
		// Snapshot the dependants, since informing may cause changes.
		CSlob* rgSlobs[2];
		rgSlobs[0] = (CSlob*) m_aDep[0];
		rgSlobs[1] = (CSlob*) m_aDep[1];

		rgSlobs[0]->OnInform(this, idChange, dwHint);
		rgSlobs[1]->OnInform(this, idChange, dwHint);
	}
	else
	{
		CObList* pList = (CObList*) m_aDep[0];

		ASSERT(m_cDep == 3);
		ASSERT(pList->GetCount() > 2);

		POSITION pos = pList->GetHeadPosition();
		if (pList->GetCount() > MAX_SAFE_DEPENDANTS)
		{
			// Give up and do it the old less safe way.
			while (pos != NULL)
			{
				CSlob* pSlob = (CSlob*)((CObList*) m_aDep[0])->GetNext(pos);
				pSlob->OnInform(this, idChange, dwHint);
			}
		}
		else
		{
			// Snapshot the dependants, since informing may cause changes.
			int nSlobs = 0;
			CSlob* rgSlobs[MAX_SAFE_DEPENDANTS];

			while (pos != NULL)
				rgSlobs[nSlobs++] = (CSlob*)pList->GetNext(pos);

			for (int i = 0; i < nSlobs; i++)
				rgSlobs[i]->OnInform(this, idChange, dwHint);
		}
	}
}


// This should be overridden for slobs that are dependant on change
// notifcations from other slobs.  When the other slob changes, this
// function is called to indicate what slobs changed and the nature of
// the change.  By the time this is called, the change has already
// occured, so calling Get?Prop on the changed slob will yield the new
// value.
//
void CSlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
	if (idChange == SN_DESTROY)
	{
		RemoveDependant(pChangedSlob);

		CObList* pContent = GetContentList();
		if (pContent != NULL)
		{
			POSITION pos = pContent->Find(pChangedSlob);
			if (pos != NULL)
				pContent->RemoveAt(pos);
		}
	}

#ifdef VERBOSE
	CString strThisName, strChangedName;
	GetSlobName(strThisName);
	pChangedSlob->GetSlobName(strChangedName);

	TRACE4("%s was informed that property %d of %s changed (hint=%ld)\n",
		(const char*)strThisName, idChange, (const char*)strChangedName,
		dwHint);
#endif
}


/////////////////////////////////////////////////////////////////////////////
// Propery Modification Functions


BOOL CSlob::SetSlobProp(UINT idProp, CSlob* val)
{
	if (idProp == P_Container)
	{
		CSlob* pContainer = GetContainer();
		CSlob* pNewContainer = val;

		// "Delete" really means "move into the undo slob...
		if (pNewContainer == NULL)
			pNewContainer = &theUndoSlob;

		// Moving a multi-slob really means the slobs referenced by it...
		if (IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		{
			BOOL bOkay = TRUE;
			POSITION pos = GetHeadPosition();
			while (pos != NULL)
			{
				if (InEmergencyState())
				{
					bOkay = FALSE;
					break;
				}

				GetNext(pos)->MoveInto(pNewContainer);
			}

			// the items in m_objects are also on
			// our dependancy list so wee need to remove the dependencies
			// individually and then call RemoveAll

			CObList *pList = GetContentList();
			pos = pList->GetHeadPosition();
			while (pos != NULL)
			{
				CSlob *pDepSlob = (CSlob*) pList->GetNext(pos);
				pDepSlob->RemoveDependant(this);
			}

			pList->RemoveAll();

			return bOkay;
		}

		// Moving into the current container is a no-op...
		if (pNewContainer == pContainer)
			return TRUE;

		if (pContainer != NULL)
		{
			// Remove the slob from it's current container...
			pContainer->Remove(this);
		}

		// If we are moving into theUndoSlob, and it is not recording, then
		// just delete the slob.
		//
		if (pNewContainer == &theUndoSlob && !theUndoSlob.IsRecording())
		{
			m_pContainer = NULL;
			InformDependants(P_Container);
			delete this;
			return TRUE;			 // Must exit.
		}

		// Setup the new container so the symbol stuff will work...
		if (theUndoSlob.IsRecording() && pNewContainer != &theClipboardSlob)
			theUndoSlob.OnSetSlobProp(this, P_Container, pContainer);

		m_pContainer = pNewContainer;
		pNewContainer->Add(this);
	}
	else // non-container property
	{
		const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

		if (pprd == NULL)
		{
			// TRACE2("CSlob::SetSlobProp: Unhandled (%d, 0x%x)!\n", idProp, val);
			return FALSE;
		}

		ASSERT(pprd->pbOffset != NULL);
		BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

		if (pprd->nType != PRD::slob)
		{
			TRACE("Bogus SetSlobProp!\n");
			ASSERT(FALSE);
		}

		if (*(CSlob**)pbProp == (CSlob*)val)
			return TRUE;

		if (theUndoSlob.IsRecording())
			theUndoSlob.OnSetSlobProp(this, idProp, *(CSlob**)pbProp);

		*(CSlob**)pbProp = (CSlob*)val;
	}

	InformDependants(idProp);

	return TRUE;
}


BOOL CSlob::SetRectProp(UINT idProp, const CRect& val)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE("CSlob::SetRectProp: Unhandled (%d, {%d,%d,%d,%d})!\n", idProp,
			val.left, val.top, val.right, val.bottom);
		return FALSE;
	}

	ASSERT(pprd->pbOffset != NULL);
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	if (pprd->nType != PRD::rect)
	{
		TRACE("Bogus SetRectProp!\n");
		ASSERT(FALSE);
	}

	if (*(CRect*)pbProp == val)
		return TRUE;

	if (theUndoSlob.IsRecording())
		theUndoSlob.OnSetRectProp(this, idProp, *(CRect*)pbProp);

	*(CRect*)pbProp = val;

	InformDependants(idProp);

	return TRUE;
}


BOOL CSlob::SetPointProp(UINT idProp, const CPoint& val)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE3("CSlob::SetPointProp: Unhandled (%d, {%d, %d})!\n", idProp, val.x, val.y);
		return FALSE;
	}

	ASSERT(pprd->pbOffset != NULL);
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	if (pprd->nType != PRD::point)
	{
		TRACE("Bogus SetPointProp!\n");
		ASSERT(FALSE);
	}

	if (*(CPoint*)pbProp == val)
		return TRUE;

	if (theUndoSlob.IsRecording())
		theUndoSlob.OnSetPointProp(this, idProp, *(CPoint*)pbProp);

	*(CPoint*)pbProp = val;

	InformDependants(idProp);

	return TRUE;
}


BOOL CSlob::SetDoubleProp(UINT idProp, double val)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE2("CSlob::SetDoubleProp: Unhandled (%d, %f)!\n", idProp, val);
		return FALSE;
	}

	BOOL bRet = TRUE;
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	switch (pprd->nType)
	{
	case PRD::action:
		TRACE("Action properties cannot be set!\n");
		ASSERT(FALSE);

	case PRD::booln:
	case PRD::integer:
		bRet = SetIntProp(idProp, (int)val);
		break;

	case PRD::longint:
		bRet = SetLongProp(idProp, (long)val);
		break;

	case PRD::number:
		ASSERT(pprd->pbOffset != NULL);
		if (*(double*)pbProp == val)
			return TRUE;

		if (theUndoSlob.IsRecording())
			theUndoSlob.OnSetDoubleProp(this, idProp, *(double*)pbProp);

		*(double*)pbProp = val;
		break;

	case PRD::string:
		{
			char szBuf [32];
			sprintf(szBuf, "%f", val);
			bRet = SetStrProp(idProp, szBuf);
		}
		break;
	}

	if (bRet)
		InformDependants(idProp);

	return bRet;
}


BOOL CSlob::SetIntProp(UINT idProp, int val)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);
	CPropBag* pBag = NULL;
	int nType;

	if (pprd == NULL)
	{
		pBag = GetPropBag();
		if (pBag == NULL)
		{
			// TRACE2("CSlob::SetIntProp: Unhandled (%d, %d)!\n", idProp, val);
			return FALSE;
		}
		
		CProp* pProp = pBag->FindProp(idProp);
		nType = pProp != NULL ? pProp->m_nType : integer;
	}
	else
	{
		nType = pprd->nType;
	}

#ifdef VERBOSE
	CString strName;
	GetSlobName(strName);
	TRACE3("%s->SetIntProp(P_%s, %d)\n", (const char*)strName, pprd->szName, val);
#endif

	BOOL bRet = TRUE;

	switch (nType)
	{
	default:
		TRACE1("Illegal property type conversion (from %d to INT)\n", pprd->nType);
		ASSERT(FALSE);
		return FALSE;

	case PRD::action:
		TRACE("Action properties cannot be set!\n");
		ASSERT(FALSE);

	case PRD::booln:
	case PRD::integer:
#ifdef _WIN32
	case PRD::longint:
#endif
		if (pprd != NULL)
		{
			ASSERT(pprd->pbOffset != NULL);
			BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

			if (*(int*)pbProp == val)
				return TRUE;

			if (theUndoSlob.IsRecording())
				theUndoSlob.OnSetIntProp(this, idProp, *(int*)pbProp);

			*(int*)pbProp = val;
		}
		else
		{
			pBag->SetIntProp(this, idProp, val);
		}
		break;

	case PRD::number:
		bRet = SetDoubleProp(idProp, (double)val);
		break;

#ifndef _WIN32
	case PRD::longint:
		bRet = SetLongProp(idProp, (long)val);
		break;
#endif

	case PRD::string:
		{
			char szBuf [32];
			sprintf(szBuf, "%d", val);
			bRet = SetStrProp(idProp, szBuf);
		}
		break;
	}

	if (bRet)
		InformDependants(idProp);

	return bRet;
}


BOOL CSlob::SetLongProp(UINT idProp, long val)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE2("CSlob::SetLongProp: Unhandled (%d, %ld)!\n", idProp, val);
		return FALSE;
	}

#ifdef VERBOSE
	CString strName;
	GetSlobName(strName);
	TRACE3("%s->SetIntProp(P_%s, %ld)\n", (const char*)strName, pprd->szName, val);
#endif

	BOOL bRet = TRUE;
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	switch (pprd->nType)
	{
	case PRD::action:
		TRACE("Action properties cannot be set!\n");
		ASSERT(FALSE);

	case PRD::booln:
	case PRD::integer:
		bRet = SetIntProp(idProp, (int)val);
		break;

	case PRD::number:
		bRet = SetDoubleProp(idProp, (double)val);
		break;

	case PRD::longint:
		ASSERT(pprd->pbOffset != NULL);
		if (*(long*)pbProp == val)
			return TRUE;

		if (theUndoSlob.IsRecording())
			theUndoSlob.OnSetLongProp(this, idProp, *(long*)pbProp);

		*(long*)pbProp = val;
		break;

	case PRD::string:
		{
			char szBuf [32];
			sprintf(szBuf, "%d", val);
			bRet = SetStrProp(idProp, szBuf);
		}
		break;
	}

	if (bRet)
		InformDependants(idProp);

	return bRet;
}


BOOL CSlob::SetStrProp(UINT idProp, const CString& val)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);
	CPropBag* pBag = NULL;
	int nType;

	if (pprd == NULL)
	{
		pBag = GetPropBag();
		if (pBag == NULL)
		{
			TRACE2("CSlob::SetStrProp: Unhandled (%d, %d)!\n", idProp, val);
			return FALSE;
		}
		
		CProp* pProp = pBag->FindProp(idProp);
		nType = pProp != NULL ? pProp->m_nType : string;
	}
	else
	{
		nType = pprd->nType;
	}

#ifdef VERBOSE
	CString strName;
	GetSlobName(strName);
	TRACE3("%s->SetStrProp(P_%s, %s)\n", (const char*)strName, pprd->szName,
		(const char*)val);
#endif

	BOOL bRet = TRUE;

	switch (nType)
	{
	case PRD::action:
		TRACE("Action properties cannot be set!\n");
		ASSERT(FALSE);

	case PRD::booln:
	case PRD::integer:
#ifdef _WIN32
	case PRD::longint:
#endif
		bRet = SetIntProp(idProp, atoi(val));
		break;

	case PRD::number:
		bRet = SetDoubleProp(idProp, atof(val));
		break;

#ifndef _WIN32
	case PRD::longint:
		bRet = SetLongProp(idProp, atol(val));
		break;
#endif

	case PRD::string:
		
		if (pprd != NULL)
		{
			ASSERT(pprd->pbOffset != NULL);
			BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

			// P_ID and P_Value are reserved for CSymSlob's only!
			ASSERT(idProp != P_ID && idProp != P_Value);

			if (*(CString*)pbProp == val)
				return TRUE;

			if (theUndoSlob.IsRecording())
				theUndoSlob.OnSetStrProp(this, idProp, (CString*)pbProp);

			*(CString*)pbProp = val;
		}
		else
		{
			pBag->SetStrProp(this, idProp, (CString)val);
		}
		break;
	}

	if (bRet)
		InformDependants(idProp);

	return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// Property Retrieval Functions

GPT CSlob::GetSlobProp(UINT idProp, CSlob*& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		// TRACE1("CSlob::GetSlobProp: Unhandled (%d)!\n", idProp);
		return invalid;
	}

	ASSERT(pprd->pbOffset != NULL);
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	if (pprd->nType != PRD::slob)
	{
		TRACE("Bogus GetSlobProp!\n");
		ASSERT(FALSE);
	}

	valReturn = *(CSlob**)pbProp;

	return valid;
}


GPT CSlob::GetRectProp(UINT idProp, CRect& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (idProp == P_CurrentSlobRect)
	{
		IProjectWorkspaceWindow *pWorkspace = NULL;
		if (FAILED(theApp.FindInterface(IID_IProjectWorkspaceWindow, (void **)&pWorkspace)))
		{
			TRACE("IID_IProjectWorkspaceWindow not found\n");
			return invalid;
		}

		RECT rt;
		pWorkspace->GetCurrentSlobRect(&rt);
		valReturn = rt;
		return valid;
	}

	if (pprd == NULL)
	{
		TRACE1("CSlob::GetRectProp: Unhandled (%d)!\n", idProp);
		return invalid;
	}

	ASSERT(pprd->pbOffset != NULL);
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	if (pprd->nType != PRD::rect)
	{
		TRACE("Bogus GetRectProp!\n");
		ASSERT(FALSE);
	}

	valReturn = *(CRect*)pbProp;

	return valid;
}


GPT CSlob::GetPointProp(UINT idProp, CPoint& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE1("CSlob::GetPointProp: Unhandled (%d)!\n", idProp);
		return invalid;
	}

	ASSERT(pprd->pbOffset != NULL);
	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	if (pprd->nType != PRD::point)
	{
		TRACE("Bogus GetPointProp!\n");
		ASSERT(FALSE);
	}

	valReturn = *(CPoint*)pbProp;

	return valid;
}


GPT CSlob::GetDoubleProp(UINT idProp, double& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE1("CSlob::GetDoubleProp: Unhandled (%d)!\n", idProp);
		return invalid;
	}

	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	switch (pprd->nType)
	{
	case PRD::action:
		TRACE("Action properties cannot be retrieved!\n");
		ASSERT(FALSE);

	case PRD::booln:
	case PRD::integer:
		ASSERT(pprd->pbOffset != NULL);
		valReturn = *(int*)pbProp;
		break;

	case PRD::longint:
		ASSERT(pprd->pbOffset != NULL);
		valReturn = *(long*)pbProp;
		break;

	case PRD::number:
		ASSERT(pprd->pbOffset != NULL);
		valReturn = *(double*)pbProp;
		break;

	case PRD::string:

		ASSERT(pprd->pbOffset != NULL);
		valReturn = atoi(*(CString*)pbProp);
		break;
	}

	return valid;
}


GPT CSlob::GetIntProp(UINT idProp, int& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);
	CPropBag* pBag = NULL;

	if (pprd == NULL)
	{
		pBag = GetPropBag();
		if (pBag == NULL)
		{
			// TRACE1("CSlob::GetIntProp: Unhandled (%d)!\n", idProp);
			return invalid;
		}

		CProp* pProp = pBag->FindProp(idProp);
		if (pProp == NULL)
			return invalid;

		switch (pProp->m_nType)
		{
		default:
			TRACE("Illegal conversion\n");
			ASSERT(FALSE);
			return invalid;

		case integer:
		case booln:
#ifdef _WIN32
		case longint:
#endif
			valReturn = ((CIntProp*)pProp)->m_nVal;
			break;

		case string:
			valReturn = atoi(((CStringProp*)pProp)->m_strVal);
			break;
		}
	}
	else
	{
		BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

		switch (pprd->nType)
		{
		case PRD::action:
			TRACE("Action properties cannot be retrieved!\n");
			ASSERT(FALSE);

		case PRD::booln:
		case PRD::integer:
			ASSERT(pprd->pbOffset != NULL);
			valReturn = *(int*)pbProp;
			break;

		case PRD::longint:
			ASSERT(pprd->pbOffset != NULL);
			valReturn = (int) LOWORD(*(long*)pbProp);
			break;

		case PRD::number:
			ASSERT(pprd->pbOffset != NULL);
			valReturn = (int)*(double*)pbProp;
			break;

		case PRD::string:
			ASSERT(idProp != P_Value);
			ASSERT(pprd->pbOffset != NULL);
			valReturn = atoi(*(CString*)pbProp);
			break;
		}
	}

	return valid;
}


GPT CSlob::GetLongProp(UINT idProp, long& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);

	if (pprd == NULL)
	{
		TRACE1("CSlob::GetLongProp: Unhandled (%d)!\n", idProp);
		return invalid;
	}

	BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

	switch (pprd->nType)
	{
	case PRD::action:
		TRACE("Action properties cannot be retrieved!\n");
		ASSERT(FALSE);

	case PRD::booln:
	case PRD::integer:
		ASSERT(pprd->pbOffset != NULL);
		valReturn = *(int*)pbProp;
		break;

	case PRD::longint:
		ASSERT(pprd->pbOffset != NULL);
		valReturn = *(long*)pbProp;
		break;

	case PRD::number:
		ASSERT(pprd->pbOffset != NULL);
		valReturn = (int)*(double*)pbProp;
		break;

	case PRD::string:
		ASSERT(idProp != P_Value);
		ASSERT(pprd->pbOffset != NULL);
		valReturn = atoi(*(CString*)pbProp);
		break;
	}

	return valid;
}


GPT CSlob::GetStrProp(UINT idProp, CString& valReturn)
{
	const PRD* pprd = PrdFindProp(GetPropMap(), idProp);
	CPropBag* pBag = NULL;

	if (pprd == NULL)
	{
		pBag = GetPropBag();
		if (pBag == NULL)
		{
			TRACE1("CSlob::GetStrProp: Unhandled (%d)!\n", idProp);
			return invalid;
		}

		CProp * pProp = pBag->FindProp(idProp);
		if (pProp == NULL)
			return invalid;

		switch (pProp->m_nType)
		{
			case integer:
			{
				char szBuf [16];	// a long int is +/- 2,147,483,648  
				valReturn = _itoa(((CBoolProp *)pProp)->m_bVal, szBuf, 10);
				break;
			}

			case booln:
			{
				char szBuf [16];	// a long int is +/- 2,147,483,648  
				valReturn = _itoa(((CIntProp *)pProp)->m_nVal, szBuf, 10);
				break;
			}

			case string:
				valReturn = ((CStringProp *)pProp)->m_strVal;
				break;

			default:
				TRACE("Illegal conversion\n");
				ASSERT(FALSE);
				return invalid;
		}
	}
	else
	{
		BYTE* pbProp = (BYTE*)this + (DWORD)pprd->pbOffset;

		switch (pprd->nType)
		{
		case PRD::action:
			TRACE("Action properties cannot be retrieved!\n");
			ASSERT(FALSE);

		case PRD::booln:
		case PRD::integer:
			{
				int num;
				char szBuf [32];
				GPT gpt = GetIntProp(idProp, num);
				if (gpt != valid)
					return gpt;

				sprintf(szBuf, "%d", num);
				valReturn = szBuf;
			}
			break;

		case PRD::longint:
			{
				long num;
				char szBuf [32];
				GPT gpt = GetLongProp(idProp, num);
				if (gpt != valid)
					return gpt;

				sprintf(szBuf, "%8ld", num);
				valReturn = szBuf;
			}
			break;

		case PRD::number:
			{
				double num;
				char szBuf [32];
				GPT gpt = GetDoubleProp(idProp, num);
				if (gpt != valid)
					return gpt;

				sprintf(szBuf, "%f", num);
				valReturn = szBuf;
			}
			break;

		case PRD::rect:
			{
				CRect rc;
				char szBuf [32];
				GPT gpt = GetRectProp(idProp, rc);
				if(gpt != valid)
					return gpt;

				sprintf(szBuf, "%d,%d,%d,%d", rc.left, rc.top,
					rc.right, rc.bottom);
				valReturn = szBuf;
			}
			break;

		case PRD::point:
			{
				CPoint pt;
				char szBuf [32];
				GPT gpt =GetPointProp(idProp, pt);
				if (gpt != valid)
					return gpt;

				sprintf(szBuf, "%d,%d", pt.x, pt.y);
				valReturn = szBuf;
			}
			break;

		case PRD::string:
			ASSERT(idProp != P_Value);
			ASSERT(pprd->pbOffset != NULL);
			valReturn = *(CString*)pbProp;
			break;
		}
	}

	return valid;
}

// Add any files associated with this slob. By default, this is nothing
// but files associated with contained slobs.
int CSlob::GetAssociatedFiles(CStringArray & saFiles)
{
	int nFiles = 0;
	if (GetContentList() != NULL)
	{
		CObList *plist = GetContentList();
		POSITION pos = plist->GetHeadPosition();
		while (pos != NULL)
		{
			nFiles += ((CSlob *) plist->GetNext(pos))->GetAssociatedFiles(saFiles);
		}
	}
	return nFiles;
}

#ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Debugging Functions

void CSlob::AssertValid() const
{
	CObject::AssertValid();
	
	ASSERT(m_pContainer == NULL || 
		m_pContainer->IsKindOf(RUNTIME_CLASS(CSlob)));
}


// Retrieve the name of a slob.  Default is to just format the address
// as a string.  Override for classes that actually have names, or more
// interesting things to use.
//
void CSlob::GetSlobName(CString& strName) const
{
	char szBuf [32];
	sprintf(szBuf, "0x%08lx", this);
	strName = szBuf;
}

#endif

/////////////////////////////////////////////////////////////////////////////


CClipboardSlob theClipboardSlob;

IMPLEMENT_DYNAMIC(CClipboardSlob, CSlob)

CClipboardSlob::CClipboardSlob() : m_objects()
{
}

CClipboardSlob::~CClipboardSlob()
{
	ClearContents();
}

void CClipboardSlob::Copy(CSlob* pCopySlob)
{
	if (pCopySlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
	{
		POSITION pos = pCopySlob->GetHeadPosition();
		while (pos != NULL)
		{
			Copy(pCopySlob->GetNext(pos));

			if (InEmergencyState())
				break;
		}
		return;
	}

	if (pCopySlob->GetContainer()->CanRemove(pCopySlob))
	{
		CSlob* pClone = pCopySlob->Clone();
		if (pClone != NULL)
			pClone->MoveInto(this);
	}
}

BOOL CClipboardSlob::CanAct(ACTION_TYPE action)
{
	// FUTURE: needs to find out what slob will accept the clipboard
	// if a paste were to occur and ask it if it can deal with the stuff
	// in there...
	if (action == act_paste)
		return !m_objects.IsEmpty();

	return CSlob::CanAct(action);
}

void CClipboardSlob::Paste(CSlob* pDestSlob, CMultiSlob* pSelection, BOOL bClearSelection)
{
	// Give the destination slob a final chance to refuse a paste.
	if (!pDestSlob->PreAct(act_paste))
		return;

	CWaitCursor waitCursor;

	CMultiSlob clones;
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CSlob* pSlob = GetNext(pos);

		if (pSlob->CanAct(act_paste))
		{
			CSlob* pClone = pSlob->Clone();
			if (pClone != NULL)
				clones.Add(pClone);
		}
	}

	pDestSlob->PrepareAddList(&clones, TRUE);

	if ((pSelection != NULL) && bClearSelection)
		pSelection->Clear();

	pos = clones.GetHeadPosition();
	while (pos != NULL)
	{
		CSlob* pSlob = clones.GetNext(pos);

		if (pDestSlob->CanAdd(pSlob))
		{
			pSlob->MoveInto(pDestSlob);

			if (InEmergencyState())
				break;

			if (pSelection != NULL)
				pSelection->Add(pSlob);
		}
		else
		{
			// couldn't add the slob, so delete it to prevent leaks
			pSlob->MoveInto(NULL);
		}
	}
}

void CClipboardSlob::ClearContents()
{
	// go through the list removing and deleting slobs
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
		delete GetNext(pos);
	m_objects.RemoveAll();
}


///////////////////////////////////////////////////////////////////////////////
// CProjSlob

//IMPLEMENT_SERIAL(CProjSlob, CSlob, 1)

IMPLEMENT_DYNAMIC(CProjSlob, CSlob)

CProjSlob::CProjSlob()
{
}

CProjSlob::~CProjSlob()
{
}

void CProjSlob::GetGlyphTipText(CString &strTip)
{
	if (GetStrProp(P_Title, strTip) != valid)
		strTip = "";
}

int CProjSlob::CompareSlob(CSlob *pCompareSlob)
{
	// if pCompareSlob < this, return -1.
	// if pCompareSlob == this, return 0.
	// if pCompareSlob > this, return 1.

	// default behavior is to compare title properties.
	// override this behavior if different sorting mechanism is desired.
	CString strThis, strCompare;

	if ((GetStrProp(P_Title, strThis) != valid) ||
		(pCompareSlob->GetStrProp(P_Title, strCompare) != valid))
	{
		// Since one or other slob has no title property, we have no
		// basis for comparison, so just return that they're equal.
		ASSERT(FALSE);	// Really pretty bogus.
		return(0);
	}

	return(strThis.CompareNoCase(strCompare));
}

// Normally we will look in the Property Map to find the Verbs and
// commands supported by a slob.  The arrays contain the Cmd IDS
// of the verbs and cmds to be supported.
void CProjSlob::GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds)
{
#ifdef _DEBUG
	aVerbs.AssertValid();
	aCmds.AssertValid();
#endif

	const PRD* propMap = GetPropMap();
	for ( ; propMap != NULL; propMap = (PRD*)propMap[0].pbOffset)
	{
		for (int iProp = 1; propMap[iProp].nProp != P_END_MAP; iProp += 1)
		{
			if (propMap[iProp].nType == verb)
				aVerbs.Add((WORD)propMap[iProp].pbOffset);
			else if (propMap[iProp].nType == command)
				aCmds.Add((WORD)propMap[iProp].pbOffset);
		}
	}
}

// Standard Display routine.  Used when various controls try to display
// the slob, for example when the project window displays a slob.
// If FALSE is returned the control will draw its own glyph for the slob.
BOOL CProjSlob::DrawGlyph(CDC* pDC, LPCRECT lpRect)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\slobwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//	SLOBWND.CPP

#include "stdafx.h"

#include "slob.h"

// used for wizard bar invalidation in selection
#include <clvwapi.h>
#include <clvwguid.h>
#include "toolexpt.h"


IMPLEMENT_DYNAMIC(CSlobWnd, CView)

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern UINT NEAR WM_GETUNDOSTRING;
extern UINT NEAR WM_GETREDOSTRING;

CObList NEAR CSlobWnd::c_slobWnds;

POSITION CSlobWnd::GetHeadSlobWndPosition()
{
	return c_slobWnds.GetHeadPosition();
}

CSlobWnd* CSlobWnd::GetNextSlobWnd(POSITION& pos)
{
	return (CSlobWnd*)c_slobWnds.GetNext(pos);
}

CSlobWnd::CSlobWnd()
{
	m_pUndoStack = new CUndoStack;

    c_slobWnds.AddHead(this);
}

CSlobWnd::~CSlobWnd()
{
	delete m_pUndoStack;

    POSITION pos = c_slobWnds.Find(this);
    ASSERT(pos != NULL);
    c_slobWnds.RemoveAt(pos);
}

BEGIN_MESSAGE_MAP(CSlobWnd, CView)
	ON_WM_DESTROY()
	ON_WM_RBUTTONUP()
	ON_COMMAND(IDM_WINDOW_SHOWPROPERTIES, CmdShowProp)
	ON_COMMAND(IDMX_IDPROP, CmdIDProp)
	ON_COMMAND(IDMX_PROPGENERAL, CmdGeneralPage)
	ON_COMMAND(IDMX_PROPSTYLES, CmdStylesPage)
	ON_REGISTERED_MESSAGE(WM_GETUNDOSTRING, OnGetUndoString)
	ON_REGISTERED_MESSAGE(WM_GETREDOSTRING, OnGetRedoString)
END_MESSAGE_MAP()

BOOL CSlobWnd::PreTranslateMessage(MSG* pMsg)
{
	// Shift + F10 show popup menu.  (Like Word and Excel).
	if (((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
		  (pMsg->wParam == VK_F10) &&		// it's F10
		  (GetKeyState(VK_SHIFT) & ~1) &&   //   and Shift is down
		  !(GetKeyState(VK_CONTROL) & ~1) ) //   but not Ctrl (DevStudio96 #7532)
		  ||                                // OR
		 (pMsg->message == WM_CONTEXTMENU)  //   Natural keyboard key
		)
	{
		CRect rect;
		GetClientRect(rect);
		ClientToScreen(rect);

		CPoint point = rect.TopLeft();
		point.Offset(5, 5);
		ShowContextPopupMenu(point);

		return TRUE;
	}

	return CView::PreTranslateMessage(pMsg);
}

void CSlobWnd::OnDestroy()
{
	// So we don't GP Fault on deleted action slobs.
	FlushUndo();

	// HACK: NT is supposed to do this for us!
	CWnd* pParent = GetParent();
	if (pParent != NULL)
		pParent->SendMessage(WM_PARENTNOTIFY, WM_DESTROY, (LPARAM)(LPVOID)m_hWnd);
	
	CView::OnDestroy();
}

void CSlobWnd::OnRButtonUp(UINT nFlags, CPoint point)
{
	if (GetActiveSlobWnd() != this)
		return;

	ClientToScreen(&point);
	ShowContextPopupMenu(point);
}

void CSlobWnd::PostNcDestroy()
{
	delete this;
}

void CSlobWnd::ObscureSprites(BOOL bObscure)
{
}

void CSlobWnd::ShowSprites(BOOL bShow)
{
}

void CSlobWnd::ShowContextPopupMenu(CPoint pt)
{
}

/////////////////////////////////////////////////////////////////////////////
// Property sheet Support

void CSlobWnd::CmdGeneralPage()
{
	if (GetCapture() || IsIconic())
		return; // ignore if in drag op

	GetPropertyBrowser()->FlipToPage(IDS_GENERAL);
}

void CSlobWnd::CmdStylesPage()
{
	if (GetCapture() || IsIconic())
		return; // ignore if in drag op

	GetPropertyBrowser()->FlipToPage(IDS_STYLES);
}
 
void CSlobWnd::CmdIDProp()
{
	// Command to turn the property browser on and select the ID field
	
	if (GetCapture() || IsIconic())
		return; // ignore if in drag op
	
	if (BeginPropertyBrowserEdit(P_ID))
		ActivatePropertyBrowser();
}

void CSlobWnd::CmdShowProp()
{
	// Command to turn the property browser on
	
	if (GetCapture())
		return; // ignore if in drag op
	
	ActivatePropertyBrowser();
}

/////////////////////////////////////////////////////////////////////////////
// Undo/Redo Support

BOOL CSlobWnd::EnableUndo()
{
	// Override this implementation only if you want to
	// *DISABLE* undo/redo handling in your CSlobWnd.
	return TRUE;
}

void CSlobWnd::BeginUndo(const char* szAction)
{
	theUndoSlob.BeginUndo(szAction, this);
}

void CSlobWnd::BeginUndo(UINT nID)
{
	theUndoSlob.BeginUndo(nID, this);
}

void CSlobWnd::EndUndo(BOOL bAbort /*=FALSE*/)
{
	theUndoSlob.EndUndo(bAbort);
}

void CSlobWnd::FlushUndo()
{
	EndUndo(TRUE);	// Abort any recording.
	m_pUndoStack->Flush();
}

BOOL CSlobWnd::CanUndo()
{
	return m_pUndoStack->m_nRedoSeqs < m_pUndoStack->m_seqs.GetCount();
}

BOOL CSlobWnd::CanRedo()
{
	return m_pUndoStack->m_nRedoSeqs > 0;
}

void CSlobWnd::DoUndo()
{
	if (!CanUndo())
		return;

	CSheetWnd * pPropSheet = GetPropertyBrowser();
    if (pPropSheet != NULL && pPropSheet->UndoPendingValidate())
        return;

    // NOTE:  We need to obscure any sprites as well because we may
	// be about to change the selection and/or show objects.

    ObscureSprites(TRUE);

	theUndoSlob.DoUndo(this);
}

void CSlobWnd::DoRedo()
{
	if (!CanRedo())
		return;
	
    // NOTE:  We need to obscure any sprites as well because we may
	// be about to change the selection and/or show objects.
	
    ObscureSprites(TRUE);

	theUndoSlob.DoRedo(this);
}

LRESULT CSlobWnd::OnGetUndoString(WPARAM nLevel, LPARAM lpstr)
{
	CString str;
	theUndoSlob.GetUndoString(str, nLevel);
	lstrcpy((LPSTR)lpstr, str);
	
	return !str.IsEmpty();
}

LRESULT CSlobWnd::OnGetRedoString(WPARAM nLevel, LPARAM lpstr)
{
	CString str;
	theUndoSlob.GetRedoString(str, nLevel);
	lstrcpy((LPSTR)lpstr, str);
	
	return !str.IsEmpty();
}


/////////////////////////////////////////////////////////////////////////////
// Selection Management

void CSlobWnd::Select(CSlob* pSlob, BOOL bAdd /* = FALSE */ )
{
	CMultiSlob* pSelection = (CMultiSlob*)GetSelection();
	ASSERT(pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)));

	if (pSlob == NULL)
		pSelection->Clear();	
	else if (bAdd)
		pSelection->Add(pSlob);
	else
		pSelection->Single(pSlob);

	// Invalidate Wizard Bar only if it is tracking in current view

	LPWIZARDBAR lpwbIFace =	g_IdeInterface.GetWizBarIFace();
	if (lpwbIFace != NULL)
	{
		HRESULT hr;
		ULONG wbFlags;
		hr = lpwbIFace->GetWizBarFlags(&wbFlags, FALSE /* fCreateIfNone */);

		if (hr == S_OK && (wbFlags & mskWBTrackedByView))
		{
			ASSERT((wbFlags & mskWBExists));
			lpwbIFace->WizBarInvalidate();
		}
	}

}

void CSlobWnd::Deselect(CSlob* pSlob)
{
	CMultiSlob* pSelection = (CMultiSlob*)GetSelection();
	ASSERT(pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)));
	
	pSelection->Remove(pSlob);
}

BOOL CSlobWnd::IsSelected(CSlob* pSlob)
{
	CMultiSlob* pSelection = (CMultiSlob*)GetSelection();
	ASSERT(pSelection != NULL);
	
	if (!pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		return pSlob == pSelection;
	
	return pSelection->IsSelected(pSlob);
}

BOOL CSlobWnd::IsOnlySelected(CSlob* pSlob)
{
	CMultiSlob* pSelection = (CMultiSlob*)GetSelection();
	ASSERT(pSelection != NULL);
	
	if (!pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		return pSlob == pSelection;
	
	return pSelection->IsOnlySelected(pSlob);
}

BOOL CSlobWnd::IsDominantSelected(CSlob* pSlob)
{
	CMultiSlob* pSelection = (CMultiSlob*)GetSelection();
	ASSERT(pSelection != NULL);
	
	if (!pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		return pSlob == pSelection;
	
	return pSelection->IsDominantSelected(pSlob);
}


CSlob* CSlobWnd::DropTargetFromPoint(const POINT& point)
{
	return GetEditSlob();
}

void CSlobWnd::OnSelChange()
{
}

void CSlobWnd::OnDraw(CDC* pDC)
{
}

void CSlobWnd::OnActivateView(BOOL bActivate, CView* pActivateView,
	CView* pDeactiveView)
{
	CView::OnActivateView(bActivate, pActivateView, pDeactiveView);

	if (bActivate)
	{
		CMDIChildWnd* pFrame = (CMDIChildWnd*) GetParentFrame();
		if (pFrame != NULL &&
				pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWnd)) &&
				pFrame->IsIconic())
			theApp.m_theAppSlob.SetSlobProp(P_CurrentSlob, NULL);
		else
			theApp.m_theAppSlob.SetSlobProp(P_CurrentSlob, GetSelection());
	}
}

/////////////////////////////////////////////////////////////////////////////

CSlobWnd* GetActiveSlobWnd()
{
	HWND hWnd = theApp.GetActiveView();

	if (hWnd == NULL)
		return NULL;
	
	CSlobWnd* pWnd = (CSlobWnd*)CWnd::FromHandle(hWnd);
	ASSERT(pWnd != NULL);
	
	if (!pWnd->IsKindOf(RUNTIME_CLASS(CSlobWnd)))
		return NULL;
	
	return pWnd;
}

void ActivateSlobWnd(CSlobWnd* pWnd)
{
	ASSERT(pWnd->GetSafeHwnd() != NULL);
	ASSERT(pWnd->IsKindOf(RUNTIME_CLASS(CSlobWnd)));
	
	theApp.SetActiveView(pWnd->m_hWnd);
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//		are changed infrequently
//

#ifndef _WIN32
#define AFX_EXT_DATA	 __based(__segname("_DATA"))
#define AFX_EXT_DATADEF AFX_APP_DATA
#endif

#if _MSC_VER >= 800
#pragma warning(disable:4200) // (C8) 'zero sized array in struct/union'
#pragma warning(disable:4062) // (C8) 'enumerate in switch not handled'
#pragma warning(disable:4065) // (C8) 'switch statement contains only default'
#endif

#ifdef _NTWIN
#pragma warning(disable:4165) // '__stdcall function can't take variable number of arguments'
#endif

#include <guiddef.h>
#define OEMRESOURCE // to get oem bitmap id's
#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxpriv.h>
#include <afxctl.h>
#ifdef _WIN32
#include <tchar.h>
#else
#include <ctype.h>
#endif

extern "C" {
#include "limits.h"
};

#include <cmpmgr.h>
#include <docobj.h>
#include <oleipc.h>
#include "oleimpl2.h"	// where COleFrameHook is implemented, need to negotiate w/ the MFC group to move this 
						// class to Afxole.h.  InPlace Component implementation CIPCompFrameHook needs to 
						// derive from this class.
#include "oleref.h"

#include <html_old.h>

#include "main.h"
#include "ids.h"
#include "slob.h"
#include "shlmenu.h"
#include "shlbar.h"
#include "shldocs.h"
#include "shlfutr_.h"
#include "shlsrvc.h"
#include "cmdtable.h"
#include "util.h"
#include "utilbld_.h"
#include "utilctrl.h"
#include "package.h"
#include "path.h"

#include "mainfrm.h"
#include "cmdcache.h"
#include "dockman.h"
#include "dockwnds.h"
#include "barcust.h"
#include "sheet.h"
#include "proppage.h"
#include "dlgbase.h"

#pragma warning(default:4242)

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\stgfile.cpp ===
// stgfile.cpp : implementation of the COLEStorage class
//

#include "stdafx.h"
#include "malloc.h"
#include "objbase.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define new DEBUG_NEW
#endif

// From olestrm.cpp: (MFC internal)
void FillFileExceptionFromScode(CFileException* pError, SCODE sc);
void ThrowFileExceptionFromScode(SCODE sc);


/////////////////////////////////////////////////////////////////////////////
// COLEStorage
#define AS_IStorage(pi) ((IStorage*) pi)

COLEStorage::COLEStorage(BOOL bReadOnly /*= TRUE*/)
	: m_pStorage(NULL), m_grfMode(bReadOnly ? STGM_READ : STGM_READWRITE)
{
}

COLEStorage::~COLEStorage()
{
	if (m_pStorage != NULL)
		AS_IStorage(m_pStorage)->Release();
}

LPCTSTR COLEStorage::GetName()
{
	static CString strName;

	ASSERT(m_pStorage != NULL);
	STATSTG stgStat;
	HRESULT hrc = AS_IStorage(m_pStorage)->Stat(&stgStat, STATFLAG_DEFAULT);
	if (FAILED(hrc))
	{
		// These are bugs
		ASSERT(hrc != STG_E_INVALIDFLAG);
		ASSERT(hrc != STG_E_INVALIDPOINTER);

		return NULL;
	}

	// Get the name
	strName = stgStat.pwcsName;

	// Free the name
	CoTaskMemFree(stgStat.pwcsName);

	return strName;
}

void COLEStorage::Open(LPCTSTR lpszPath)
{
	USES_CONVERSION;

	IStorage* pStorage = AS_IStorage(m_pStorage);
	HRESULT hrc = StgOpenStorage(A2CW(lpszPath), NULL, STGM_DIRECT | STGM_SHARE_DENY_WRITE | m_grfMode, NULL, 0, &pStorage);
	if (FAILED(hrc))
	{
		// These return values are bugs
		ASSERT(hrc != STG_E_INVALIDPOINTER);
		ASSERT(hrc != STG_E_INVALIDFLAG);
		ASSERT(hrc != STG_E_INVALIDFUNCTION);

		// Throw an exception
		ThrowFileExceptionFromScode(GetScode(hrc));
	}

	m_pStorage = pStorage;
}

void COLEStorage::Create(LPCTSTR lpszPath)
{
	USES_CONVERSION;

	IStorage* pStorage = AS_IStorage(m_pStorage);
	HRESULT hrc = StgCreateDocfile(A2CW(lpszPath), STGM_CREATE | STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pStorage);
	if (FAILED(hrc))
	{
		// These return values are bugs
		ASSERT(hrc != STG_E_INVALIDPOINTER);
		ASSERT(hrc != STG_E_INVALIDFLAG);

		// Throw an exception
		ThrowFileExceptionFromScode(GetScode(hrc));
	}

	m_pStorage = pStorage;
}

void COLEStorage::OpenStream(LPCTSTR lpszName, COleStreamFile* pStream)
{
	ASSERT_VALID(pStream);
	ASSERT(m_pStorage != NULL);

	CFileException e;
	if (pStream->OpenStream(AS_IStorage(m_pStorage), lpszName, CFile::modeRead | CFile::shareExclusive, &e))
		return;

	AfxThrowFileException(e.m_cause, e.m_lOsError);
}

void COLEStorage::CreateStream(LPCTSTR lpszName, COleStreamFile* pStream)
{
	ASSERT_VALID(pStream);
	ASSERT(m_pStorage != NULL);

	CFileException e;
	if (pStream->CreateStream(AS_IStorage(m_pStorage), lpszName, CFile::modeReadWrite | CFile::shareExclusive | CFile::modeCreate, &e))
		return;

	AfxThrowFileException(e.m_cause, e.m_lOsError);
}

void COLEStorage::OpenStorage(LPCTSTR lpszName, COLEStorage* pStorage)
{
	USES_CONVERSION;

	ASSERT(pStorage != NULL);
	ASSERT(m_pStorage != NULL);

	IStorage* pIStorage = AS_IStorage(pStorage->m_pStorage);
	HRESULT hrc = AS_IStorage(m_pStorage)->OpenStorage(A2CW(lpszName), NULL, STGM_DIRECT | STGM_SHARE_EXCLUSIVE | m_grfMode, NULL, 0, &pIStorage);
	if (FAILED(hrc))
	{
		// These return values are bugs
		ASSERT(hrc != STG_E_INVALIDPOINTER);
		ASSERT(hrc != STG_E_INVALIDFLAG);
		ASSERT(hrc != STG_E_INVALIDFUNCTION);
		ASSERT(hrc != STG_E_INVALIDNAME);

		// Throw an exception
		ThrowFileExceptionFromScode(GetScode(hrc));
	}

	pStorage->m_pStorage = pIStorage;
}

void COLEStorage::CreateStorage(LPCTSTR lpszName, COLEStorage* pStorage)
{
	USES_CONVERSION;

	ASSERT(pStorage != NULL);
	ASSERT(m_pStorage != NULL);

	IStorage* pIStorage;
	HRESULT hrc = AS_IStorage(m_pStorage)->CreateStorage(A2CW(lpszName), STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_READWRITE, 0, 0, &pIStorage);
	if (FAILED(hrc))
	{
		// These return values are bugs
		ASSERT(hrc != STG_E_INVALIDPOINTER);
		ASSERT(hrc != STG_E_INVALIDFLAG);
		ASSERT(hrc != STG_E_INVALIDPARAMETER);
		ASSERT(hrc != STG_E_INVALIDNAME);

		// Throw an exception
		ThrowFileExceptionFromScode(GetScode(hrc));
	}

	pStorage->m_pStorage = pIStorage;
}


/////////////////////////////////////////////////////////////////////////////
// Helpers
void FillFileExceptionFromScode(CFileException* pError, SCODE sc)
{
	ASSERT(pError != NULL);
	ASSERT(FAILED(sc));

	int cause;  // portable CFileException.m_cause

	// error codes 255 or less are DOS/Win32 error codes
	if (SCODE_SEVERITY(sc) == SEVERITY_ERROR &&
		SCODE_FACILITY(sc) == FACILITY_STORAGE &&
		SCODE_CODE(sc) < 0x100)
	{
		ASSERT(SCODE_CODE(sc) != 0);

		// throw an exception matching to the DOS error
		//  (NOTE: only the DOS error part of the SCODE becomes m_lOsError)
		cause = CFileException::OsErrorToException(SCODE_CODE(sc));
		sc = (SCODE)SCODE_CODE(sc);
	}
	else
	{
		// attempt some conversion of storage specific error codes to generic
		//  CFileException causes...
		switch (sc)
		{
		case STG_E_INUSE:
		case STG_E_SHAREREQUIRED:
			cause = CFileException::sharingViolation;
			break;

		case STG_E_NOTCURRENT:
		case STG_E_REVERTED:
		case STG_E_CANTSAVE:
		case STG_E_OLDFORMAT:
		case STG_E_OLDDLL:
			cause = CFileException::generic;
			break;

		default:
			cause = CFileException::generic;
			break;
		}
	}

	// fill in pError
	pError->m_cause = cause;
	pError->m_lOsError = (LONG)sc;
}

void ThrowFileExceptionFromScode(SCODE sc)
{
	CFileException e;
	FillFileExceptionFromScode(&e, sc);

	AfxThrowFileException(e.m_cause, e.m_lOsError);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\stdfont.cpp ===
////////////////////////////////////////////////////////////////////////////
//
// Standard font handling
//

#include "stdafx.h"
#include "main.h"
#include "tchar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////

struct FontEntry
{
	TCHAR szName[LF_FACESIZE];
	int iSize;
	BOOL bAdjustSize;	// if true use -MulDiv(iSize, LOGPIXELSY, 72)
};

static BASED_CODE const char szFonts[] = "Fonts";
static BASED_CODE FontEntry FontNames[4][3] =
{
	{
		{ "MS Sans Serif",		 8, TRUE  },
		{ "lr oSVbN",		 9, TRUE  },
		{ "System",  			10, TRUE  },
	}, {
		{ "Small Fonts",		-9, FALSE },
		{ "Small Fonts",		-9, FALSE },
		{ "Terminal",			-9, FALSE },
	}, {
		{ "Courier",			14, FALSE },
		{ "FixedSys",			14, FALSE },
		{ "FixedSys",			14, FALSE }
	}, {
		{ "MS Sans Serif",			14, TRUE },
		{ "MS Sans Serif",			14, TRUE },
		{ "MS Sans Serif",			14, TRUE }
	}
};

static BOOL ParseFontString( LPCTSTR lpsz, FontEntry *lpfe )
{
	ASSERT( lpfe );
	ASSERT( lpsz );
	int nLen = lstrlen( lpsz );

	if ( !nLen )
		return FALSE;

	// Search for a comma
	LPCTSTR lpszTmp = _tcschr( lpsz, _T(',') );
	if (lpszTmp == NULL || lpszTmp == lpsz) // not found, or in first position
		return FALSE;

	// Pick the font name out of the string
	if ((lpszTmp - lpsz) >= LF_FACESIZE)	// too long for our buffer
		return FALSE;

	// We've got a font name
	_tcsncpy( lpfe->szName, lpsz, lpszTmp - lpsz );
	lpfe->szName[LF_FACESIZE-1] = _T('\0');

	// Look for the integer size (could be minus!)
	lpszTmp++;	// skip over the comma
	while (lpszTmp && *lpszTmp && _istspace(*lpszTmp))
		lpszTmp = _tcsinc( lpszTmp );

	if (!lpszTmp || !*lpszTmp)
		return FALSE;

	// convert lpszTmp to a number
	lpfe->iSize = (int) _tcstol( lpszTmp, NULL, 10 );
	if (lpfe->iSize == 0)
		return FALSE;

	// see if we should use points or device units
	lpfe->bAdjustSize = (_tcsstr( lpszTmp, _T("pt") ) != NULL);
	return TRUE;
}

static FontEntry* GetStdFontInfo(int iType, int* pnCharset = NULL)
{
	ASSERT(iType >= 0 && iType < font_count);

	int iFacename, nCharset;

	nCharset = theApp.GetCharSet (&iFacename);
	
	if (pnCharset != NULL)
		*pnCharset = nCharset;

	static FontEntry fe;
	CString strValName;
	switch (iType/3)
	{
		case 0:
			strValName = "Normal";
			break;
		case 1:
			strValName = "Small";
			break;
		case 2:
			strValName = "Fixed";
			break;
		case 3:
			strValName = "Large";
			break;
		default:
			// An invalid font type
			ASSERT( 0 );
	}

	CString strReg = GetRegString( szFonts, strValName );
	// Parse strReg, then fill out and return fe.
	BOOL bValid;
	strReg.MakeLower();
	bValid = ParseFontString( strReg, &fe );

	if (!bValid)
		fe = FontNames[iType/3][iFacename];

	return &fe;
}


void GetStdFontInfo(int iType, CString& strFace, int& ptSize)
{
	FontEntry* pfe = GetStdFontInfo(iType);
	strFace = pfe->szName;
	ptSize = pfe->iSize;
}


// NOTE: The LOGFONT returned by this function is temporary!
const LOGFONT* GetStdLogfont( const int iType, CDC *pDC /* = NULL */ )
{
	static LOGFONT lf;
	
	int nCharset;
	FontEntry* pfe = GetStdFontInfo(iType, &nCharset);

	if (!pDC)
	{
		CWindowDC dc(NULL);
		lf.lfHeight = pfe->bAdjustSize ? 
				-MulDiv(pfe->iSize, dc.GetDeviceCaps(LOGPIXELSY), 72) :
				pfe->iSize;
	}
	else
	{
		lf.lfHeight = pfe->bAdjustSize ? 
				-MulDiv(pfe->iSize, pDC->GetDeviceCaps(LOGPIXELSY), 72) :
				pfe->iSize;
	}
	lf.lfWidth = 0;
	lf.lfEscapement = 0;
	lf.lfOrientation = 0;
	// [chauv] looks like we want to use BOLD where appropriate for MBCS platforms after all
	// for consistency with US and other FarEast platforms.
	// lf.lfWeight = ((iType % 3 == 1) && !theApp.m_fOEM_MBCS) ? FW_BOLD : FW_NORMAL;
	lf.lfWeight = (iType % 3 == 1) ? FW_BOLD : FW_NORMAL;
	lf.lfItalic = (iType % 3 == 2);
	lf.lfUnderline = FALSE;
	lf.lfStrikeOut = FALSE;
	lf.lfCharSet = (BYTE)nCharset;
	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	lf.lfQuality = DEFAULT_QUALITY;
	lf.lfPitchAndFamily = DEFAULT_PITCH | FW_DONTCARE;
	lstrcpy( lf.lfFaceName, pfe->szName );

	return &lf;
}


CFont* GetStdFont(const int iType)
{
	static CFont fonts [font_count];
	
	ASSERT(iType >= 0 && iType < font_count);
	
	if (fonts[iType].m_hObject == NULL)
		VERIFY(fonts[iType].CreateFontIndirect(GetStdLogfont(iType)));
	
	return &fonts[iType];
}


UINT CTheApp::GetCharSet (int * piFaceName) const
{
int iFacename, nCharset;

	switch (theApp.GetCP())
	{
	case OEM_JAPAN:
		iFacename = 1;
		nCharset = SHIFTJIS_CHARSET;
		break;

	case OEM_PRC:
		iFacename = 2;
		nCharset = GB2312_CHARSET;
		break;

	case OEM_TAIWAN:
		iFacename = 2;
		nCharset = CHINESEBIG5_CHARSET;
		break;

	case OEM_KOR_WANGSUNG:
	case OEM_KOR_JOHAB:
		iFacename = 2;
		nCharset = DEFAULT_CHARSET;
		break;

	default:
		iFacename = 0;
		nCharset = ANSI_CHARSET;
		break;
	}

	if (piFaceName)
		*piFaceName = iFacename;

	return nCharset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\test.cpp ===
// Testing Support
//
// The _TEST flag is defined for non-release/non-debug builds.  These builds
// do not have _DEBUG defined, but still have some additional functionality
// beyond the shipping build.
//

#include "stdafx.h"

#include "errno.h"
#include "toolexpt.h"

#include <bldapi.h>
#include <bldguid.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _TEST
LRESULT CMainFrame::OnGetProp(WPARAM nPropID, LPARAM)
{

	TRACE1("Remote GetProp: %d\n", nPropID);
	CString str;

	CSlobWnd* pSlobWnd = GetActiveSlobWnd();
	if (pSlobWnd == NULL)
	{
		TRACE("  ** no active slob!\n");
		return FALSE;
	}


	if (pSlobWnd->GetSelection()->GetStrProp(nPropID, str) != valid)
	{
		TRACE("  ** Unknown property!\n");
		return FALSE;
	}

	ATOM atom = GlobalAddAtom((LPCSTR)str);
	TRACE1("Added Global Atom: %u\n", atom);

	return (LONG)atom;
}

LRESULT CMainFrame::OnSetProp(WPARAM nPropID, LPARAM lAtom)
{
	char szBuf[256];
	VERIFY(GlobalGetAtomName((ATOM)lAtom, szBuf, 255));

	TRACE2("Remote SetProp: %d = %s\n", nPropID, szBuf);

	CSlobWnd* pSlobWnd = GetActiveSlobWnd();
	if (pSlobWnd == NULL)
	{
		TRACE("  ** no current slob!\n");
		return FALSE;
	}

	pSlobWnd->GetSelection()->SetStrProp(nPropID, (LPSTR)szBuf);

	return TRUE;
}

// help for OnHeapUse - caller should have szBuf point to at leaset a 256 TCHAR buffer
// return TRUE only if normal termination - false indicates error
BOOL FillBufHeapUse(TCHAR *szBuf)
{
	size_t sizeUsed, sizeFree;

	BOOL fRet = FALSE;

	_HEAPINFO hinfo;
	int heapstatus;
	hinfo._pentry = NULL;
	sizeUsed = 0;
	sizeFree = 0;
	while (( heapstatus = _heapwalk( &hinfo)) == _HEAPOK)
	{
		if (hinfo._useflag == _USEDENTRY)
			sizeUsed += hinfo._size;
		else
			sizeFree += hinfo._size;
	}

	switch( heapstatus )
	{
	default:
		wsprintf(szBuf, "Heap: ERROR - unexpected return\n");
		break;
	case _HEAPEMPTY:
		wsprintf(szBuf, "Heap: ERROR - Empty heap\n");
		break;
	case _HEAPEND:
		wsprintf(szBuf, "Heap: Used = 0x%x(%d); Free = 0x%x(%d)\n",(int) sizeUsed, (int) sizeUsed, (int)sizeFree, (int)sizeFree);
		fRet = TRUE;
		break;
	case _HEAPBADPTR:
		wsprintf(szBuf, "Heap: ERROR - bad pointer to heap\n");
		break;
	case _HEAPBADBEGIN:
		wsprintf(szBuf, "Heap: ERROR -  bad start of heap\n");
		break;
	case _HEAPBADNODE:
		wsprintf(szBuf, "Heap: ERROR -  bad node in heap\n");
		break;
	}

	if (errno == ENOSYS)  // override other info
	{
		wsprintf(szBuf, "Heap: ERROR - _heapwalk not supported, no heap information available\n");
		fRet = FALSE;
	}
	
	return fRet;

}


LRESULT CMainFrame::OnHeapUse(WPARAM, LPARAM)
{
	TCHAR szBuf[256];
	FillBufHeapUse(szBuf);

	ATOM atom = GlobalAddAtom(szBuf);
	TRACE1("Added Global Atom: %u\n", atom);

	return (LONG)atom;
}


LRESULT CMainFrame::OnTestDockable(WPARAM nWorkerID, LPARAM)
{
	CDockWorker* pDocker = m_pManager->WorkerFromID(nWorkerID);
	if (pDocker == NULL)
		return (LRESULT) NULL;
	else
		return (LRESULT) (LPVOID*) pDocker->m_pWnd->GetSafeHwnd();
}

LRESULT CMainFrame::OnIsBuildPossible(WPARAM nPropID, LPARAM lpstrBuf)
{
	LPBUILDSTATUS pInterface = NULL;
	if (FAILED(theApp.FindInterface(IID_IBuildStatus, (LPVOID FAR *)&pInterface)) || (pInterface == NULL))
		return((LONG)FALSE);
	BOOL fCanBuild = pInterface->IsBuildPossible() == S_OK;
	pInterface->Release();
	return((LONG)fCanBuild);
}

LRESULT CMainFrame::OnGetErrorCount(WPARAM nPropID, LPARAM lpstrBuf)
{
	static DWORD dwErrCnt;
	LPBUILDSTATUS pInterface = NULL;
	if (FAILED(theApp.FindInterface(IID_IBuildStatus, (LPVOID FAR *)&pInterface)) || (pInterface == NULL))
		return(0L);
	pInterface->GetErrorCount(&dwErrCnt);
	pInterface->Release();
	return((LONG)dwErrCnt);
}

LRESULT CMainFrame::OnGetWarningCount(WPARAM nPropID, LPARAM lpstrBuf)
{
	static DWORD dwWarnCnt;
	LPBUILDSTATUS pInterface = NULL;
	if (FAILED(theApp.FindInterface(IID_IBuildStatus, (LPVOID FAR *)&pInterface)) || (pInterface == NULL))
		return(0L);
	pInterface->GetWarningCount(&dwWarnCnt);
	pInterface->Release();
	return((LONG)dwWarnCnt);
}

LRESULT CMainFrame::OnGetProjPath(WPARAM ui, LPARAM lng)
{		// Returns a full project path.
	LPBUILDSYSTEM pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace);
	if (pBldSysIFace == NULL)
		return 0L;

  	LPCSTR pszPath = NULL;
	if (pBldSysIFace->IsActiveBuilderValid() == S_OK)
		pBldSysIFace->GetBuilderFile(ACTIVE_BUILDER, &pszPath);
	pBldSysIFace->Release();
	if (pszPath == NULL)
		return 0L;

  	CString str = pszPath;
	ATOM atom = GlobalAddAtom((LPCSTR)((const char  *) str)) ;
	TRACE1("Added Global Atom: %u\n", atom) ;
	return  (LONG)atom ;
}

LRESULT CMainFrame::OnGetItemProp(WPARAM nPropID, LPARAM lpstrBuf)
{

	TRACE1("Remote GetProp: %d\n", nPropID);
	CString str;
	int iProp ;

  	CMultiSlob *pMultiSlob;
	CSlob *pSlob = NULL;
    
    CSlobWnd * pActiveSlob = (CSlobWnd *)GetActiveSlobWnd();
    if (pActiveSlob == NULL)
    {
        TRACE("  ** no active slobwnd!\n");
        return FALSE;
    }

	pMultiSlob = (CMultiSlob *) (pActiveSlob->GetSelection()) ;

	if (pMultiSlob == NULL ||
		!pMultiSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)) ||
		pMultiSlob->GetContentList() == NULL ||
		pMultiSlob->GetContentList()->GetCount() == 0)
	{
	
		TRACE("  ** invalid selection!\n");
		return FALSE;
	}

   	pSlob = (CSlob *)pMultiSlob->GetDominant();

    if (pSlob == NULL)
    {
        TRACE(" ** no active slob!\n");
        return FALSE;
    }

	if (pSlob->GetStrProp(nPropID, str) != valid)
	{
	  // Attempt getting an INT property.
	   char sz[20] ; 

		if (pSlob->GetIntProp(nPropID, iProp) != valid)
		{
			CRect rct;

			if (pSlob->GetRectProp(nPropID, rct) != valid)
			{
				TRACE("  ** Unknown property!\n") ;
				return FALSE; 
			}
			else
			{
				_itoa(rct.top, sz, 10);
				str  = sz;
				str += _T(',');
	
				_itoa(rct.left, sz, 10);
				str += sz;
				str += _T(',');

				_itoa(rct.bottom, sz, 10);
				str += sz;
				str += _T(',');

				_itoa(rct.right, sz, 10);
				str += sz;
			}
		}
		else
		{
			_itoa(iProp,sz ,10) ;
		   str = sz ;
		}
	}
			
	ATOM atom = GlobalAddAtom((LPCSTR)str);
	TRACE1("Added Global Atom: %u\n", atom);

	return (LONG)atom;
}

LRESULT CMainFrame::OnSetItemProp(WPARAM nPropID, LPARAM lAtom)
{
	char szBuf[256];
	VERIFY(GlobalGetAtomName((ATOM)lAtom, szBuf, 255));

	TRACE2("Remote SetProp: %d = %s\n", nPropID, szBuf);

	CSlobWnd* pSlobWnd = GetActiveSlobWnd();
	if (pSlobWnd == NULL)
	{
		TRACE("  ** no current slob!\n");
		return FALSE;
	}

	pSlobWnd->GetSelection()->SetStrProp(nPropID, (LPSTR)szBuf);

	return TRUE;
}
#endif  // _TEST

void NYI()
{
	AfxMessageBox("Sorry, that has not been implemented yet!",
		MB_OK | MB_ICONSTOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tap.cpp ===
// tap.cpp : implementation file
//

#include "stdafx.h"
#include "tap.h"
#include "imeutil.h"

// The V4,x implementation of this control barred many keys from being entered
// These keys included standard windows keys, and other general-purpose keys.
// For Orion, we are allowing all keys to be customised except:
//
// Unshifted backspace (needed to remove items from the control)
// Double tab
//
// Because users without mice will want to use tab to move out of the control,
// we define that tab will move us out of the control when there is something in
// the control, but insert a tab otherwise. This allows single tab to be customised.
//
// This means that while the focus is in this control almost all standard 
// windows navigation keys are disabled. But the user can always use tab to
// get out of the control, at which point all the controls become enabled 
// again.
// martynl 12Mar96

/////////////////////////////////////////////////////////////////////////////
// CTap control

CTap::CTap()
{
	m_accel.fVirt = FVIRTKEY;	// by default, I prefer to deal with VirtKeys
	m_accel.key = 0;
	m_accel.cmd = 0;
	m_chord.fVirt = FVIRTKEY;
	m_chord.key = 0;
	m_chord.cmd = 0;
	m_fState = FVIRTKEY;
}

CTap::~CTap()
{
}


BEGIN_MESSAGE_MAP(CTap, CWnd)
	//{{AFX_MSG_MAP(CTap)
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_WM_GETDLGCODE()
	ON_WM_MENUCHAR()
	ON_WM_SYSKEYDOWN()
	ON_WM_SYSKEYUP()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_SYSCOMMAND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTap message handlers

void CTap::ResetAll()
{
	m_accel.fVirt = m_fState;
	m_accel.key = 0;
	m_accel.cmd = 0;

	ResetChord();
}

void CTap::ResetChord()
{
	m_chord.fVirt = FVIRTKEY;
	m_chord.key = 0;

	InvalidateContent();
}

void CTap::SetAccel(ACCEL& accel)
{
	m_accel = accel;
	InvalidateContent();
	NotifyParent(TAPN_CHANGE);
}

void CTap::SetChord(ACCEL& chord)
{
	m_chord = chord;
	InvalidateContent();
	NotifyParent(TAPN_CHANGE);
}

void CTap::InvalidateContent(BOOL bErase /* = TRUE */)
{
	CRect rc;
	GetClientRect( rc );

	rc.InflateRect( -3, -3 );
	rc.OffsetRect( 1, 1 );
	InvalidateRect( rc, FALSE/*bErase*/ );
}

BOOL CTap::Create(const char* szName, const RECT& rc, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
	CRect rect(rc);
	rect.InflateRect(1, 1); // to accomodate border...
	return CWnd::Create( NULL,		// m_szClassName ?
						 szName, 
						 WS_TABSTOP | WS_VISIBLE | WS_CHILD,
						 rc, pParentWnd, nID, pContext );

}

BOOL CTap::PreTranslateMessage( MSG *pMsg )
{
	switch (pMsg->message)
	{
	case WM_SYSCHAR:
		return TRUE;
	default:
		return FALSE;
	}
}

UINT CTap::OnGetDlgCode()
{
	ASSERT(CWnd::OnGetDlgCode() == 0);	// I'm asserting that I don't care about the base class function
	return DLGC_WANTALLKEYS | DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB;
}

BOOL CTap::SuppressKey(UINT nChar) const
{
	return FALSE;
	// V4.x supressed:VK_TAB, VK_ESCAPE, VK_RETURN, VK_BACK, VK_SPACE
}

void CTap::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if((nFlags & 0x4000) != 0) // ignore repeats to prevent flashing
		return;

	if(IsChordSet() &&		// we had a full chord, so this must be from scratch
	   !SuppressKey(nChar))
			ResetAll();			// clear everything

	switch(nChar)
	{
	case VK_CONTROL:
		SetControl(!IsKeySet());
		break;

	case VK_SHIFT:
		SetShift(!IsKeySet());
		break;

	case VK_MENU:
		SetAlt(!IsKeySet());
		break;

	case VK_TAB:
		if(IsKeySet())
		{
			if(m_fState & FSHIFT) {
				ClearShift(!IsKeySet());
			}
			SymTab();
		}
		else
		{
			goto KDefault;
		}
		break;

	case VK_BACK:
		// delete is delete if it is unshifted, or if in second position
		if (IsKeySet() || (!IsKeySet() && !IsAlt() && !IsControl() && !IsShift())) {
			if(IsChordSet())
				ResetChord();
			else
				ResetAll();
			break;
		}
		// DELIBERATE FALL THROUGH


	default:
	KDefault:
		if (!IsKeySet())
		{
			m_accel.key = (WORD)nChar;
#if 0 //BC
			if (nChar >= 0x80 && (nFlags & 0x80) == 0)		// user typed a non-virtkey punctuation
			{											
				m_accel.key = VkToAscii(nChar, nFlags, m_accel);	// get Ascii char, not non-standard VirtKey
				SetAscii(!IsKeySet());								// flip to ascii so it is displayed ok
				ClearShift(!IsKeySet());							// and forget SHIFT, since the char is shown shifted
			}
#endif
		}
		else	// create chord
		{
			ASSERT(!IsChordSet());
			m_chord.key = (WORD)nChar;
#if 0 //BC
			if (nChar >= 0x80 && (nFlags & 0x80) == 0)		// user typed a non-virtkey punctuation
			{											
				m_chord.key = VkToAscii(nChar, nFlags, m_chord);	// get Ascii char, not non-standard VirtKey
			}
#endif
			ASSERT((m_chord.key & 0xff00) == 0 || (m_chord.key & 0xff00) == 0xff00);
			m_chord.key &= 0x00ff;
			m_chord.fVirt = m_fState;
		}
		break;
#if 0
	// used in 4.x to handle other special characters
	case VK_ESCAPE:
		SymExit();
		break;

	case VK_RETURN:
		SymOk();
		break;

	case VK_SPACE:
		break;		// do nothing - alt+space and ctrl+space still enabled
#endif

	}
	InvalidateContent();
	NotifyParent(TAPN_CHANGE);

//	CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CTap::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(nRepCnt > 1)
		return;

	switch(nChar)
	{
		case VK_CONTROL:
			ClearControl(!IsKeySet());
			break;
		case VK_SHIFT:
			ClearShift(!IsKeySet());
			break;
		case VK_MENU:
			ClearAlt(!IsKeySet());
			break;
	}
	InvalidateContent();
	NotifyParent(TAPN_CHANGE);

	CWnd::OnKeyUp(nChar, nRepCnt, nFlags);
}

void CTap::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(nRepCnt > 1 || (nFlags & 0x4000))
		return;

	if(IsChordSet() &&						// we had a full chord, so this must be from scratch
	   !SuppressKey(nChar))
			ResetAll();			// clear everything

	switch(nChar)
	{
	case VK_CONTROL:
		SetControl(!IsKeySet());
		break;

	case VK_SHIFT:
		SetShift(!IsKeySet());
		break;

	case VK_MENU:
		SetAlt(!IsKeySet());
		break;

	case VK_BACK:
		// delete is delete if it is unshifted, or if in second position
		if (IsKeySet()) {
			if(IsChordSet())
				ResetChord();
			else
				ResetAll();
			break;
		}
		// DELIBERATE FALL THROUGH

	default:
#if 0
LDefault:
#endif
		if(!IsKeySet())
		{
			m_accel.key = (WORD)nChar;
		}
		else	// create chord
		{
			ASSERT(!IsChordSet());
			m_chord.key = (WORD)nChar;
		}
		break;

#if 0
	// used in V4.x to handle special characters
	case VK_RETURN:
	case VK_SPACE:
		if (!IsAlt() && !IsControl() && !IsShift())
			goto LDefault;
		// FALL THROUGH

	case VK_TAB:
	case VK_ESCAPE:
	case VK_F1:
		break;			// suppress these keys, as they can't be used in valid accels
#endif

	}
	InvalidateContent();
	NotifyParent(TAPN_CHANGE);
}

void CTap::OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(nRepCnt > 1)
		return;

	switch(nChar)
	{
		case VK_CONTROL:
			ClearControl(!IsKeySet());
			break;
		case VK_SHIFT:
			ClearShift(!IsKeySet());
			break;
		case VK_MENU:
			ClearAlt(!IsKeySet());
			break;
	}
	InvalidateContent();
	NotifyParent(TAPN_CHANGE);
	
	CWnd::OnSysKeyUp(nChar, nRepCnt, nFlags);
}

void CTap::OnSysCommand(UINT nID, LPARAM lParam)
{
	if((nID == SC_KEYMENU) || (nID == SC_HOTKEY))
		return;
	
	CWnd::OnSysCommand(nID, lParam);
}

LRESULT CTap::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu)
{
	ASSERT(m_accel.fVirt & FALT);	// if this isn't true,
	ASSERT(m_accel.key == nChar);	// I suppose I should make it true

	// tell windows we are eating the character
	// however, to do that, we must provide a dlgitem, so how about ourselves
	return MAKELRESULT(GetDlgCtrlID(),2);
}

void CTap::DrawFrame( CDC &dc, LPCRECT lprc )
{
	// FUTURE: Remove this function.
	ASSERT(FALSE);
}


void CTap::OnPaint()
{
	CString strKey = MakeAccelName(m_accel);
	if (IsChordSet())
	{
		strKey += ", ";
		strKey += MakeAccelName(m_chord);
	}

	CRect rc;
	GetClientRect(&rc);
	CPaintDC dc(this);

	dc.Draw3dRect(rc, GetSysColor(COLOR_BTNSHADOW), GetSysColor(COLOR_BTNHIGHLIGHT));
	rc.InflateRect(-1, -1);
	dc.Draw3dRect(rc, GetSysColor(COLOR_WINDOWFRAME), GetSysColor(COLOR_BTNFACE));
	rc.InflateRect(-1, -1);

	CFont* pOldFont = dc.SelectObject(GetStdFont(font_Normal));

	dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
	dc.SetBkColor(GetSysColor(COLOR_WINDOW));
	dc.ExtTextOut(rc.left + 2, rc.top + 1, ETO_OPAQUE | ETO_CLIPPED, rc, strKey, strKey.GetLength(), NULL);

	if (GetFocus() == this)
	{
		CPoint pt;
		pt.x = rc.left + 2;
		pt.y = rc.top + 1;

		if (!strKey.IsEmpty())
			pt.x += dc.GetTextExtent(strKey, strKey.GetLength()).cx;
		SetCaretPos(pt);
	}

	dc.SelectObject(pOldFont);
}

CString CTap::MakeAccelName(ACCEL& accel)
{
	CString str;

	if(accel.fVirt & FCONTROL)
		str += CKeymap::c_szCtrl;
	if(accel.fVirt & FALT)
		str += CKeymap::c_szAlt;
	if(accel.fVirt & FSHIFT)
		str += CKeymap::c_szShift;

	if(accel.key != 0)
	{
		if(accel.fVirt & FVIRTKEY)
		{
			const char* psz = GetNameFromVK(accel.key);
			if(psz != NULL)
				str += psz;
			else
				str += (char)accel.key;
		}
		else
			str += (char)accel.key;
	}

	return str;
}

// FUTURE: VkToAscii is not currently used anywhere.  But this is such beastly
//   code, that I figured I'd hang onto it in case I needed it again -- DG.

WORD CTap::VkToAscii(UINT nChar, UINT nFlags, ACCEL& accel) const
{
	WORD wTransKey = 0;	// was a DWORD in Win16
	UINT oemScan = LOBYTE(nFlags);
	
	BYTE kbdState[256] = {0};
//	memset(kbdState, 0, 256);
	kbdState[oemScan] |= 0x80;

	if(accel.fVirt & FSHIFT)
		kbdState[VK_SHIFT] |= 0x80;
	if(accel.fVirt & FCONTROL)
		kbdState[VK_CONTROL] |= 0x80;
	
	int fAscii = ToAscii(nChar, oemScan, kbdState, &wTransKey, 0);
	ASSERT(!(DWORD)fAscii == !wTransKey);		// they should both be 0, or both non-0

	if(fAscii = 1)
		return wTransKey;
	else if (fAscii = 2)
	{
		ASSERT(FALSE);	// FUTURE: I need to handle this case too.
		return 0;
	}
	else
		return 0;
}

BOOL CTap::IsAccelLegal() const
{
	return TRUE;
#if 0
		// These were used in V4.x to handle special cases
	if (!IsKeySet())
		return TRUE; // Empty key is building towards legal accel

	if (IsVirtKey())
	{
		switch (m_accel.key)
		{
		case VK_TAB:
			return FALSE;

		case VK_F1:
			return FALSE;

		case VK_F2:
			if (IsAlt())
				return FALSE;
			break;

#if 0	// olympus 10464 : kherold per suggestion of rkern.  The user has other
		// ways to shut down the app, etc.
		case VK_F4:
			if (IsAlt() != IsControl() && !IsShift())
				return FALSE;
			break;
#endif

		case VK_F6:
			if (!IsAlt() && IsControl())
				return FALSE;
			break;

		case VK_DELETE:
			if (!IsBase() && !IsShift() && IsControl() && IsAlt())
				return FALSE;
			break;

		case VK_RETURN:
			if (!IsShift() && !IsControl() && !IsAlt())
				return FALSE;
			break;

		case VK_ESCAPE:
			return FALSE;
		}
	}

	return TRUE;
#endif

/*			
	switch (m_accel.key)
	{
	case VK_F2:
		// can have any F2 except Alt+F2
		return IsVirtKey() && (IsAlt() ? (IsShift() || IsControl()) : TRUE);
		
	case VK_F4:
		// Can have any F4 except Alt+F4 and Ctrl+F4
		return IsVirtKey() && (IsAlt() == IsControl() || IsShift());
		
	case VK_INSERT:
	case VK_ADD:
	case VK_SUBTRACT:
	case VK_MULTIPLY:
	case VK_DIVIDE:
		// can have any Insert, or Numpad /,*,-,+
		return IsVirtKey();
	
	case VK_DELETE:
		// can have any shifted Delete except Ctrl+Alt+Del
		return IsVirtKey() && (IsBase() || IsShift() ||
			(!IsControl() || !IsAlt()));
	}
	
	// Invalid F2-F12 were handled in the switch above
	if (m_accel.key >= VK_F2 && m_accel.key <= VK_F12)
		return IsVirtKey();
	
	// can have any Alt or Control modified A-Z, 0-9, or Space
	if ((m_accel.key >= 'A' && m_accel.key <= 'Z') ||
		(m_accel.key >= '0' && m_accel.key <= '9') ||
		(m_accel.key == VK_SPACE))
		return IsAlt() || IsControl();
	
	// [Alt, Ctrl] + [Numpad0 - Numpad9]
	if (m_accel.key >= VK_NUMPAD0 && m_accel.key <= VK_NUMPAD9)
		return IsVirtKey() && (IsAlt() || IsControl());
	
	// everything else is NOT legal for customized Accelerators
	return FALSE;
*/
}

BOOL CTap::IsChordLegal() const
{
	return TRUE;
/*
	// This wasn't even used in 4.x
	// Looser rules on second characters, because no shifting
	
	if(!IsChordSet())
		return TRUE; // No chord is certainly legal
	
	if( (m_chord.key >= VK_F2) && (m_chord.key <= VK_F12) )          
		return IsVirtKeyC();								// F2 - F12
			
	if( (m_chord.key >= 'A' && m_chord.key <= 'Z') ||
		(m_chord.key >= '0' && m_chord.key <= '9') ||
		(m_chord.key == VK_SPACE) )
		return TRUE;										// A-Z, 0-9, Space
			
	if( (m_chord.key == VK_INSERT) ||
		(m_chord.key == VK_DELETE) ||
		(m_chord.key == VK_ADD) ||
		(m_chord.key == VK_SUBTRACT) ||
		(m_chord.key == VK_MULTIPLY) ||
		(m_chord.key == VK_DIVIDE) )
		return IsVirtKeyC();								// Insert, Delete, or Numpad /,*,-,+

	return FALSE; // everything else is NOT legal for customized Accelerators' chords
*/
}

void CTap::OnLButtonDown(UINT nFlags, CPoint point)
{
	SetFocus();
	
	CWnd::OnLButtonDown(nFlags, point);
}

void CTap::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);
	
	HideCaret();
	::DestroyCaret();
	if (!IsKeySet())
	{
		ClearControl( TRUE );
		ClearAlt( TRUE );
		ClearShift( TRUE );
	}
	Invalidate(FALSE);	// so as to redraw border

	imeEnableIME( NULL, TRUE );
}

void CTap::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);
	
//	UpdateStateFlags();

	CRect rc;
	GetWindowRect(&rc);
	CreateSolidCaret(1, rc.Height() - 6);
	::SetCaretPos(4, 3);
	ShowCaret();

	Invalidate(FALSE);	// so as to redraw border

	imeEnableIME( NULL, FALSE );
}

void CTap::UpdateStateFlags()
{
	BYTE kbdState[256] = {0};		// while focus was away, we probably got out of sync
	GetKeyboardState(kbdState);		// so get m_fState back in sync

	m_fState = FVIRTKEY;
	if(kbdState[VK_SHIFT] & 0x80)
		SetShift(FALSE);
	if(kbdState[VK_CONTROL] & 0x80)
		SetControl(FALSE);
	if(kbdState[VK_MENU] & 0x80)
		SetAlt(FALSE);

	if(!IsKeySet())
	{
		ResetAll();		// might as well do sync all at once
		Invalidate(FALSE);
		NotifyParent(TAPN_CHANGE);
	}
}

CWnd *GetTabWnd( const CWnd *pStartingControl, UINT nCmd )
{
	CWnd *pWnd = (CWnd *)pStartingControl;

	do
	{
		pWnd = pWnd->GetWindow(nCmd);
	} while ( pWnd && ((pWnd->GetStyle() & (WS_TABSTOP | WS_DISABLED)) != WS_TABSTOP) );
	return pWnd;
}

void CTap::SymTab(void) const
{
	// simulate the parent dialog tabbing around controls
	CWnd* pNext;
	if(m_fState & FSHIFT)	// shift+tab to previous control
		pNext = GetTabWnd( this, GW_HWNDPREV );
	else
		pNext = GetTabWnd( this, GW_HWNDNEXT );

	if(pNext != NULL)
		pNext->SetFocus();
}

#if 0
// These are no longer required, as the keys that go with these commands 
// are allowed to be customised
void CTap::SymExit() const
{
	GetParent()->SendMessage(WM_CLOSE,0,0);
}

void CTap::SymOk() const
{
	UINT idDef = ((CDialog*)GetParent())->GetDefID();
	CWnd* pDef = GetDlgItem(idDef);
	if (pDef != NULL)
		GetParent()->SendMessage(WM_COMMAND,MAKELPARAM(idDef,BN_CLICKED),(LPARAM)pDef->m_hWnd);
}
#endif

/////////////////////////////////////////////////////////////////////////////

static VirtKey VKList[] =
{
    VK_LBUTTON,    _T("LBUTTON"),	
    VK_RBUTTON,    _T("RBUTTON"),	
    VK_CANCEL,     _T("Break"),	
    VK_MBUTTON,    _T("MBUTTON"),	
    VK_BACK,       _T("Backspace"),	
    VK_TAB,        _T("Tab"),		
    VK_CLEAR,      _T("NumPad Clear"),
    VK_RETURN,     _T("Enter"),	
    VK_SHIFT,      _T("SHIFT"),	
    VK_CONTROL,    _T("CONTROL"),	
    VK_MENU,       _T("ALT"),	
    VK_PAUSE,      _T("Pause"),	
    VK_CAPITAL,    _T("Caps Lock"),	
    VK_ESCAPE,     _T("Esc"),	
    VK_SPACE,      _T("Space"),	
    VK_PRIOR,      _T("Page Up"),	
    VK_NEXT,       _T("Page Down"),	
    VK_END,        _T("End"),		
    VK_HOME,       _T("Home"),	
    VK_LEFT,       _T("Left Arrow"),	
    VK_UP,         _T("Up Arrow"),		
    VK_RIGHT,      _T("Right Arrow"),	
    VK_DOWN,       _T("Down Arrow"),	
    VK_SELECT,     _T("Select"),	
    VK_PRINT,      _T("Print"),	
    VK_EXECUTE,    _T("Execute"),	
    VK_SNAPSHOT,   _T("Snapshot"),	
    VK_INSERT,     _T("Ins"),	
    VK_DELETE,     _T("Del"),	
    VK_HELP,       _T("Help"),	
    VK_NUMPAD0,    _T("Num 0"),
    VK_NUMPAD1,    _T("Num 1"),	
    VK_NUMPAD2,    _T("Num 2"),	
    VK_NUMPAD3,    _T("Num 3"),	
    VK_NUMPAD4,    _T("Num 4"),	
    VK_NUMPAD5,    _T("Num 5"),	
    VK_NUMPAD6,    _T("Num 6"),	
    VK_NUMPAD7,    _T("Num 7"),	
    VK_NUMPAD8,    _T("Num 8"),	
    VK_NUMPAD9,    _T("Num 9"),	
    VK_MULTIPLY,   _T("Num *"),	
    VK_ADD,        _T("Num +"),		
    VK_SEPARATOR,  _T("Separator"),
    VK_SUBTRACT,   _T("Num -"),
    VK_DECIMAL,    _T("Num ."),
    VK_DIVIDE,     _T("Num /"),
    VK_F1,         _T("F1"),
    VK_F2,         _T("F2"),
    VK_F3,         _T("F3"),
    VK_F4,         _T("F4"),
    VK_F5,         _T("F5"),
    VK_F6,         _T("F6"),
    VK_F7,         _T("F7"),
    VK_F8,         _T("F8"),
    VK_F9,         _T("F9"),
    VK_F10,        _T("F10"),
    VK_F11,        _T("F11"),		
    VK_F12,        _T("F12"),		
    VK_F13,        _T("F13"),		
    VK_F14,        _T("F14"),		
    VK_F15,        _T("F15"),		
    VK_F16,        _T("F16"),		
    VK_F17,        _T("F17"),		
    VK_F18,        _T("F18"),		
    VK_F19,        _T("F19"),		
    VK_F20,        _T("F20"),
    VK_F21,        _T("F21"),		
    VK_F22,        _T("F22"),		
    VK_F23,        _T("F23"),		
    VK_F24,        _T("F24"),		
    VK_NUMLOCK,    _T("Num Lock"),	
    VK_SCROLL,     _T("Scroll Lock"),
    VK_LWIN,       _T("Left Windows"),
    VK_RWIN,       _T("Right Windows"),
    VK_APPS,       _T("Application"),
	0,			   _T("")
};

const char* GetNameFromVK(WORD n)
{
	static TCHAR szBuf [40];

	if (n >= 'A' && n <= 'Z' || n >= '0' && n <= '9')
	{
		szBuf[0] = (TCHAR)n;
		szBuf[1] = '\0';
		return szBuf;
	}

	int vk = 0;
	do
	{
		if(VKList[vk].key == n)
			return VKList[vk].name;
	}
	while(VKList[vk++].key != 0);

	// If we don't have a name for it, try the keyboard driver...
	GetKeyNameText(MAKELONG(0, MapVirtualKey(n, 0)), 
		szBuf, sizeof (szBuf) / sizeof (TCHAR) - 1);
	return szBuf;
}

// advances iOffset over any whitespace until we hit non-whitespace, or end of string
static void SkipWhitespace(LPCTSTR pszName, int *iOffset)
{
	ASSERT(pszName!=NULL);
	ASSERT(iOffset!=NULL);
	ASSERT(iOffset>=0);

	TCHAR c;

	while(c=pszName[*iOffset], c!=(TCHAR)0 && _istspace(c))
	{
		++(*iOffset);
	}
}

// returns true (and advances iOffset) if pszName begins with pszMatch.
static BOOL BeginsWith(LPCTSTR pszName, int *iOffset, LPCTSTR pszMatch)
{
	ASSERT(pszName!=NULL);
	ASSERT(iOffset!=NULL);
	ASSERT(iOffset>=0);
	ASSERT(pszMatch!=NULL);

	int iNewOffset=*iOffset;

	int nMatchLen=_tcslen(pszMatch);

	// though everything does, conceptually, begin with nothing, it's more likely that
	// this is an indication of a coding bug higher up
	ASSERT(nMatchLen!=0);

	SkipWhitespace(pszName, &iNewOffset);

	// does it begin with match?
	if(_tcsnicmp(pszName+iNewOffset, pszMatch, nMatchLen)==0)
	{
		// skip it
		*iOffset=iNewOffset+nMatchLen;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

// returns true (and advances iOffset) if pszName begins with pszMatch, followed by a plus sign,
// ignoring spaces.
static BOOL BeginsAndPlus(LPCTSTR pszName, int *iOffset, LPCTSTR pszMatch)
{
	ASSERT(pszName!=NULL);
	ASSERT(iOffset!=NULL);
	ASSERT(iOffset>=0);
	ASSERT(pszMatch!=NULL);

	int iNewOffset=*iOffset;

	if(BeginsWith(pszName, &iNewOffset, pszMatch))
	{
		// skip following spaces
		SkipWhitespace(pszName, &iNewOffset);

		// is there a plus?
		if(pszName[iNewOffset]==_T('+'))
		{
			*iOffset=iNewOffset+1;
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}


WORD GetKeyCodeFromName(LPCTSTR pszName, int *iOffset)
{
	ASSERT(pszName!=NULL);
	ASSERT(iOffset!=NULL);
	ASSERT(iOffset>=0);

	WORD wKeyCode=0;
	int iNewOffset=*iOffset;

	// check for prefixes
	// The spec states that these *must* appear in the order ctrl, alt, shift

	// BUGBUG DevStudio 96 Bug 6242...This code used BeginAndPlus, however it was passing in
	// CKeymap::c_szCtrl etc which already have the plus. We would like to allow whitespace
	// between the plus, so we will remove the plus before we pass in the string.

	// Make sure that the last character is a +...otherwise the code may break.
	ASSERT(CKeymap::c_szCtrl[_tcslen(CKeymap::c_szCtrl)-1] ==_T('+')) ;
	ASSERT(CKeymap::c_szAlt[_tcslen(CKeymap::c_szAlt)-1] ==_T('+')) ;
	ASSERT(CKeymap::c_szShift[_tcslen(CKeymap::c_szShift)-1] ==_T('+')) ;

	CString strPrefix(CKeymap::c_szCtrl) ;	
	if(BeginsAndPlus(pszName, &iNewOffset, strPrefix.SpanExcluding(_T("+")))) 
	{
		wKeyCode|=KCF_CONTROL; 
	}

	strPrefix = CKeymap::c_szAlt ;
	if(BeginsAndPlus(pszName, &iNewOffset, 	strPrefix.SpanExcluding(_T("+"))))
	{
		wKeyCode|=KCF_ALT;
	}

	strPrefix = CKeymap::c_szShift ;
	if(BeginsAndPlus(pszName, &iNewOffset, 	strPrefix.SpanExcluding(_T("+"))))
	{
		wKeyCode|=KCF_SHIFT;
	}

	SkipWhitespace(pszName, &iNewOffset);

	// can't end yet!
	if(pszName[iNewOffset]==_T('\0'))
	{
		return 0;
	}

	// check for a virtual key
	int vk = 0;
	BOOL bFound=FALSE;
	while(VKList[vk].key!=0 && !bFound)
	{
		ASSERT(VKList[vk].name!=NULL);

		if(BeginsWith(pszName, &iNewOffset, VKList[vk].name))
		{
			bFound=TRUE;
		}
		else
		{
			// BUGBUG DevStudio 96 Bug 6242...the index was getting incremented,
			// after the key was found.
			++vk; 
		}
	}

	if(bFound)
	{
		// found a virtkey
		wKeyCode+=VKList[vk].key;
	}
	else
	{
		// assume that it's an ordinary kind of key
		if(pszName[iNewOffset]!=_T('\0'))
		{
			wKeyCode+=pszName[iNewOffset];
			iNewOffset++;
			bFound=TRUE;
		}
	}

	if(bFound)
	{
		// at this point, we have a single valid keystroke, but we need to check that there isn't 
		// unexpected garbage at the end of it. We can tolerate whitespace, end of string markers, 
		// and anything following a comma
		SkipWhitespace(pszName, &iNewOffset);

		if(pszName[iNewOffset]==_T(','))
		{
			// skip the comma, so parsing can continue just after
			++iNewOffset;

			// we must ensure that the comma is followed by something
			SkipWhitespace(pszName, &iNewOffset);

			// we can now accept anything except a string terminator, which implies a 
			// comma followed by nothing
			if(pszName[iNewOffset]==_T('\0'))
			{
				bFound=FALSE;
			}
		}
		else
		{
			// without the comma, the only thing we will allow is end of string
			if(pszName[iNewOffset]!=_T('\0'))
			{
				bFound=FALSE;
			}
		}
	}

	if(bFound)
	{
		*iOffset=iNewOffset;
		return wKeyCode;
	}
	else
	{
		return 0;
	}
}

void CTap::NotifyParent(UINT idNotify)
{
#ifdef _WIN32
	GetParent()->SendMessage(WM_COMMAND, MAKEWPARAM((WORD)GetDlgCtrlID(), (WORD)idNotify), (LPARAM)m_hWnd);
#else
	GetParent()->SendMessage(WM_COMMAND, (WPARAM)GetDlgCtrlID(), MAKELONG((WORD)m_hWnd, idNotify));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tabdlg.cpp ===
// tabdlg.cpp : implementation file
//

#include "stdafx.h"

#include "shell.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


CLastTabMap CTabbedDialog::m_DialogMap;

CLastTabMap::~CLastTabMap()
{
	POSITION pos = GetStartPosition();
	while (pos != (POSITION)NULL)
	{
		WORD wKey; CObject * pStr;
		GetNextAssoc(pos, wKey, pStr);
		delete (CString *)pStr;
	}	
}

////////////////////////////////////////////////////////////////////////////
// CDlgTab -- one page of a tabbed dialog

BEGIN_MESSAGE_MAP(CDlgTab, CDialog)
	//{{AFX_MSG_MAP(CDlgTab)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CDlgTab, CDialog)

CDlgTab::CDlgTab()
{
	m_nOrder = 0;
}

CDlgTab::CDlgTab(UINT nIDTemplate, UINT nIDCaption)
{
	m_strCaption.LoadString(nIDCaption);
	m_lpszTemplateName = MAKEINTRESOURCE(nIDTemplate);
	m_nIDHelp = LOWORD(nIDTemplate);

	m_nOrder = 0;
}

CDlgTab::CDlgTab(LPCSTR lpszTemplateName, UINT nIDCaption)
{
	m_strCaption.LoadString(nIDCaption);
	m_lpszTemplateName = lpszTemplateName;

	m_nOrder = 0;
}

void CDlgTab::OnOK()
{
	// Overide for OK processing, but do NOT call EndDialog!
	
	// NB. don't use SendMessage here
	m_pParentWnd->PostMessage(WM_COMMAND, IDOK);
}

void CDlgTab::OnCancel()
{
	// Overide for Cancel processing, but do NOT call EndDialog!
	
	// NB. don't use SendMessage here
	m_pParentWnd->PostMessage(WM_COMMAND, IDCANCEL);
}

void CDlgTab::OnContextMenu(CWnd* pWnd, CPoint pt) 
{	
	// Orion Bug 17216 - There are dialogs within dialogs. Use
	// the window which you are passed instead of this.
	//DoHelpContextMenu(this, m_nIDHelp, pt);
	DoHelpContextMenu(pWnd, m_nIDHelp, pt) ;
}

BOOL CDlgTab::OnHelpInfo(HELPINFO* pInfo) 
{
	return DoHelpInfo(this, m_nIDHelp, pInfo);
}

void CDlgTab::CancelTab()
{
}

BOOL CDlgTab::ValidateTab()
{
	return TRUE;
}

void CDlgTab::CommitTab()
{
	ASSERT(GetSafeHwnd() != NULL);

	VERIFY( UpdateData(TRUE) );
}

BOOL CDlgTab::PreTranslateMessage(MSG* pMsg)
{
	if (((CTabbedDialog*)m_pParentWnd)->MessageStolenByTabbedDialog(pMsg))
		return TRUE;

	return CDialog::PreTranslateMessage(pMsg);
}

BOOL CDlgTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	m_pParentWnd = pParentWnd;
	
	if (m_hWnd == NULL)
	{
#ifdef MUNGE_DLG_FONTS
		C3dDialogTemplate dt;
		if (dt.Load(m_lpszTemplateName))
			SetStdFont(dt);
		if (!CreateIndirect(dt.GetTemplate(), pParentWnd))
			return FALSE; // Create() failed...
#else
		if (!Create(m_lpszTemplateName, pParentWnd))
			return FALSE; // Create() failed...
#endif
		// Must be a child for obvious reasons, and must be disabled to prevent
		// it from taking the focus away from the tab area during initialization...	
		ASSERT((GetStyle() & (WS_DISABLED | WS_CHILD)) == (WS_DISABLED | WS_CHILD));
	}

	// DEBUG - Setting the window text allows our sniff tests to determine
	//         which DlgTab is currently active with a simple WM_GETTEXT
	//         message.  This line of code is otherwise unnecessary.
	SetWindowText(m_strCaption);

	SetWindowPos(&wndTop, position.x, position.y, 0, 0, 
		SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOCOPYBITS);
	ShowWindow(SW_SHOWNOACTIVATE);
	EnableWindow(TRUE);

	return TRUE;
}

void CDlgTab::Deactivate(CTabbedDialog* pParentWnd)
{
	ASSERT(pParentWnd == m_pParentWnd);
}

// call to enable or disable a button in a tabbed dialog
BOOL CDlgTab::EnableButton(CWnd *pButWnd, BOOL bEnable)
{
	if(bEnable==FALSE)
	{
		// ensure that this really is a button
		ASSERT((pButWnd->SendMessage(WM_GETDLGCODE) & (DLGC_DEFPUSHBUTTON|DLGC_UNDEFPUSHBUTTON))!=0);

		// remember focus status
		BOOL bHadFocus=(GetFocus() == pButWnd);

		// if we disable a default, it should no longer be the default
		CButton *pBut=(CButton *)pButWnd;

		// remove default style
		DWORD dwStyle=pBut->GetButtonStyle();
		if((dwStyle & 0x0f)==BS_DEFPUSHBUTTON)
		{
			pBut->SetButtonStyle(dwStyle - BS_DEFPUSHBUTTON + BS_PUSHBUTTON);

			// give it to the parent
			CTabbedDialog *pParent=(CTabbedDialog *)GetParent();

			// try ok
			CButton *pNewDefault=(CButton *)pParent->GetDlgItem(IDOK);

			// if it's not there, or not enabled, use close instead
			if(pNewDefault!=NULL && pNewDefault->IsWindowEnabled())
			{
				// make it the default
				DWORD dwStyle=pNewDefault->GetButtonStyle();

				if((dwStyle & 0x0f)==BS_PUSHBUTTON)
				{
					pNewDefault->SetButtonStyle(dwStyle - BS_PUSHBUTTON + BS_DEFPUSHBUTTON);
				}

				if(bHadFocus)
				{
					pNewDefault->SetFocus();
				}
			}
		}
	}
	return pButWnd->EnableWindow(bEnable);
}

#ifdef _DEBUG
void CDlgTab::EndDialog(int nID)
{
	// Do NOT call EndDialog for a tab!  Coordinate with the parent
	// for termination (you can post WM_COMMAND with IDOK or IDCANCEL
	// do handle those cases).
	
	ASSERT(FALSE);
}
#endif

BOOL IsTabNextFocus(CDialog* pDlg, UINT nCmd)
{
	if ((pDlg->SendMessage(WM_GETDLGCODE) &
		(DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
	{
		CWnd* pCtl = CWnd::GetFocus();
		if (pDlg->IsChild(pCtl))
		{
			// Get top level child for controls with children, like combo.
			while (pCtl->GetParent() != pDlg)
			{
				pCtl = pCtl->GetParent();
				ASSERT_VALID(pCtl);
			}

			do
			{
				if ((pCtl = pCtl->GetWindow(nCmd)) == NULL)
					return TRUE;
			}
			while ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
		}
	}

	return FALSE;
}

// CTabRecord: an object representing one graphical tab
//
CTabRecord::CTabRecord(const TCHAR* szCaption, int nWidth, int nOrder, DWORD dw)
{
	m_strCaption = szCaption;
	m_nWidth = nWidth;
	m_nOrder = nOrder;
	m_dw = dw;

	m_rect.SetRectEmpty();
}


////////////////////////////////////////////////////////////////////////////
// CTabs -- implementation for a generic row of tabs along the top of dialog

CTabRow::CTabRow()
{
	m_rowRect.SetRectEmpty();
	m_scrollRect.SetRectEmpty();

	m_curTab = m_firstTab = 0;
	m_bHasFocus = FALSE;
	m_nScrollState = SCROLL_NULL;

	m_pWndOwner = NULL;
}

CTabRow::~CTabRow()
{
	for (int i = 0 ; i <= MaxTab() ; i++)
		delete m_tabs[i];
}

void CTabRow::ResetContent()
{
	for (int i = 0 ; i <= MaxTab() ; i++)
		delete m_tabs[i];

	m_curTab = 0;
	m_firstTab = 0;
	m_nScrollState = SCROLL_NULL;

	m_tabs.SetSize(0);
	m_pWndOwner->InvalidateRect(&m_rowRect);
}

void CTabRow::AddTab(CString& strCaption, CDC* pDC, int nOrder, DWORD dw)
{
	ASSERT(pDC);

	// Calculate the required width of the tab based on the text
	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Normal));

	CSize text = pDC->GetTextExtent(strCaption, strCaption.GetLength());
	int nWidth = text.cx + cxTabTextMargin * 2;

	pDC->SelectObject(pOldFont);

	CTabRecord* pTabRecord = new CTabRecord(strCaption, nWidth, nOrder, dw);
	for (int i = 0; ; i += 1)
	{
		if (i == m_tabs.GetSize())
		{
			m_tabs.Add(pTabRecord);
			break;
		}
		
		if (nOrder < ((CTabRecord*)m_tabs[i])->m_nOrder)
		{
			m_tabs.InsertAt(i, pTabRecord);
			break;
		}
		
		ASSERT(i < m_tabs.GetSize());
	}
			
	SetFirstTab(0);

	if (!m_rowRect.IsRectEmpty())
		m_pWndOwner->InvalidateRect(&m_rowRect);
}

void CTabRow::SetPos(CRect rect)
{
	// rect is in client coordinates of the owning window, of course
	m_rowRect = rect;
	m_scrollRect.SetRect(m_rowRect.right - cxScrollSize, m_rowRect.bottom - 1 - cyScrollSize,
	                     m_rowRect.right, m_rowRect.bottom - 1);
	SetFirstTab(m_firstTab);	// recalc all tab positions
	ScrollIntoView(m_curTab);	// make sure current selection still in view
}

int CTabRow::DesiredHeight(CDC* pDC)
{
	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Bold));

	// Our desired height is the height of a tall character plus the
	// required margin space, plus the amount by which selection
	// increases the height of a tab.
	int height = pDC->GetTextExtent("M", 1).cy + cyTabTextMargin * 2 + cySelectedTab * 2;

	pDC->SelectObject(pOldFont);
	return height;
}

int CTabRow::SetActiveTab(int nTab)
{
	if (nTab < 0 || nTab > MaxTab())
		return -1;
	if (nTab == m_curTab)
		return nTab;

	InvalidateTab(m_curTab);
	InvalidateTab(nTab);

	m_curTab = nTab;

	ScrollIntoView(nTab);

	return nTab;
}

int CTabRow::SetActiveTab(const CString& str)
{
	for (int i = 0 ; i <= MaxTab() ; i++)
	{
		if (str == GetTabString(i))
			return SetActiveTab(i);
	}

	return -1;
}

void CTabRow::PutFocus(BOOL bTabsHaveFocus)
{
	if (m_bHasFocus == bTabsHaveFocus)
		return;

	m_bHasFocus = bTabsHaveFocus;
	if ((m_curTab != -1) && (m_curTab <= MaxTab()))
		InvalidateTab(m_curTab);
}

void CTabRow::DrawTab(CDC* pDC, int nTab, BOOL bCurTab)
{
	CRect rc = GetTab(nTab)->m_rect;
	int  nWidth = GetTab(nTab)->m_nWidth;
	BOOL bClipped = GetTab(nTab)->m_bClipped;

	if (bCurTab)
		rc.InflateRect(cxSelectedTab, cySelectedTab);

	CPen pen;

	// Draw white line along left and top of tab
	COLORREF cr = GetSysColor(COLOR_BTNHIGHLIGHT);
	if (!pen.CreatePen(PS_SOLID, 1, cr))
		return;

	CPen* pOldPen = pDC->SelectObject(&pen);

	pDC->MoveTo(rc.left, rc.bottom - 1);
	pDC->LineTo(rc.left, rc.top + 2);
	pDC->LineTo(rc.left + 2, rc.top);
	pDC->LineTo(rc.right - 1, rc.top);

	pDC->SelectObject(pOldPen);
	pen.DeleteObject();

	// if the tab following this one is the selected tab, or if it is
	// clipped by the right edge, don't draw the right border lines.
	if ((m_curTab != nTab + 1) || !IsTabVisible(m_curTab))
	{
		cr = GetSysColor(COLOR_BTNSHADOW);
		if (!pen.CreatePen(PS_SOLID, 1, cr))
			return;

		pOldPen = pDC->SelectObject(&pen);

		// Depending on whether this tab is clipped or not, we draw either
		// the "torn" dark gray edge, or else the standard gray+black line
		// on the right-side border.
		if (!bClipped)
		{
		//	pDC->MoveTo(rc.right - 1, rc.top);		already there
			pDC->LineTo(rc.right - 1, rc.bottom);

			pDC->SelectObject(pOldPen);
			pen.DeleteObject();

			// Now do the second (black) line down right side
			cr = GetSysColor(COLOR_WINDOWFRAME);
			if (!pen.CreatePen(PS_SOLID, 1, cr))
				return;

			pOldPen = pDC->SelectObject(&pen);

			pDC->MoveTo(rc.right, rc.top + 2);
			pDC->LineTo(rc.right, rc.bottom);
		}
		else
		{
			// draw dark gray "torn" edge for a clipped tab
			for (int i = rc.top ; i < rc.bottom ; i += 3)
			{
				// This nifty (but obscure-looking) equation will draw
				// a jagged-edged line.
				int j = ((6 - (i - rc.top) % 12) / 3) % 2;
				pDC->MoveTo(rc.right + j, i);
				pDC->LineTo(rc.right + j, min(i + 3, rc.bottom));
			}
		}

		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
	}

	// Finally, draw the tab's text
	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Normal));
	COLORREF rgbOld = pDC->SetTextColor (GetSysColor (COLOR_BTNTEXT));
	CString strCaption = GetTabString(nTab);

	CSize text = pDC->GetTextExtent(strCaption, 
		strCaption.GetLength());
	pDC->ExtTextOut(rc.left + nWidth / 2 - text.cx / 2, 
		rc.top + rc.Height() / 2 - text.cy / 2, ETO_CLIPPED, &rc,
		strCaption, strCaption.GetLength(), NULL);

	pDC->SelectObject(pOldFont);
	pDC->SetTextColor (rgbOld);
}

void CTabRow::Draw(CDC* pDC)
{
	// Draw all the tabs that are currently within view
	for (int i = MaxTab() ; i >= 0 ; i--)
		if (IsTabVisible(i))
			DrawTab(pDC, i, i == m_curTab);

	// Draw the line underneath all the tabs
	CPen pen;
	COLORREF cr = GetSysColor(COLOR_BTNHIGHLIGHT);
	if (pen.CreatePen(PS_SOLID, 1, cr))
	{
		CRect rc(0, 0, 0, 0);
		if (m_curTab <= MaxTab())
			rc = GetTab(m_curTab)->m_rect;
		CPen* pOldPen = pDC->SelectObject(&pen);

		pDC->MoveTo(m_rowRect.left, m_rowRect.bottom - 1);
		if (!rc.IsRectNull())
		{
			// this leaves a gap in the line if the currently selected
			// tab is within view.
			pDC->LineTo(rc.left - cxSelectedTab, m_rowRect.bottom - 1);
			pDC->MoveTo(rc.right + cxSelectedTab + 1, m_rowRect.bottom - 1);
		}
		pDC->LineTo(m_rowRect.right, m_rowRect.bottom - 1);

		pDC->SelectObject(pOldPen);
		pen.DeleteObject();
	}

	if (CanScroll())
		DrawScrollers(pDC);

	if (m_bHasFocus && (m_pWndOwner->GetFocus() == m_pWndOwner))
		DrawFocusRect(pDC);
}

void CTabRow::DrawFocusRect(CDC* pDC)
{
	if (MaxTab() < 0)
		return;

	CRect rc;
	rc = GetTab(m_curTab)->m_rect;

	// Setting the Fore and Back colors this way
	// makes the focus rect come out right.
	COLORREF rgbText = pDC->SetTextColor (GetSysColor (COLOR_BTNTEXT));
	COLORREF rgbBack = pDC->SetBkColor (GetSysColor (COLOR_BTNFACE));

	pDC->DrawFocusRect(&rc);

	pDC->SetTextColor (rgbText);
	pDC->SetBkColor (rgbBack);
}

void CTabRow::DrawScrollers(CDC* pDC)
{
	int idb;

	// Choose bitmap depending on scroll state
	if (IsTabVisible(0, FALSE))
		idb = IDB_SCROLL_LD;
	else if (IsTabVisible(MaxTab(), FALSE))
		idb = IDB_SCROLL_RD;
	else
		idb = IDB_SCROLL;

	if (!m_bScrollPause)
	{
		if (m_nScrollState == SCROLL_LEFT)
			idb = IDB_SCROLL_L;
		else if (m_nScrollState == SCROLL_RIGHT)
			idb = IDB_SCROLL_R;
	}

	// now load and draw it
	HINSTANCE hInstance = GetResourceHandle();

	HRSRC hRsrc = ::FindResource(hInstance, MAKEINTRESOURCE(idb), RT_BITMAP);
	HBITMAP hBitmap = AfxLoadSysColorBitmap(hInstance, hRsrc);

	if (hBitmap == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	HDC hdcTemp = ::CreateCompatibleDC(pDC->m_hDC);
	HGDIOBJ hOldBitmap = SelectObject(hdcTemp, hBitmap);

	BitBlt(pDC->m_hDC, m_scrollRect.left, m_scrollRect.top, m_scrollRect.Width(),
	            m_scrollRect.Height(), hdcTemp, 0, 0, SRCCOPY);

	SelectObject(hdcTemp, hOldBitmap);
	::DeleteObject(hBitmap);
	::DeleteDC(hdcTemp);
}

void CTabRow::DrawPageRect(CDC* pDC, const CRect& rectPage)
{
	CRect rect;
	rect.left = min(m_rowRect.left - 1, rectPage.left);
	rect.top = m_rowRect.bottom - 2;
	rect.right = max(m_rowRect.right, rectPage.right);
	rect.bottom = rectPage.bottom;

	// black line along right and bottom side
	COLORREF cr = GetSysColor(COLOR_WINDOWFRAME);
	pDC->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(), cr);
	pDC->FillSolidRect(rect.left, rect.bottom - 1, rect.Width() - 1, 1, cr);

	rect.InflateRect(-1, -1);
	// draw white line along left of page, and top where not covered by
	// the tabs.
	cr = GetSysColor(COLOR_BTNHIGHLIGHT);

	if (rect.left < m_rowRect.left)
	{
		pDC->FillSolidRect(rect.left, rect.top,
			m_rowRect.left - rect.left, 1, cr);
	}

	if (rect.right > m_rowRect.right)
	{
		pDC->FillSolidRect(m_rowRect.right, rect.top,
			rect.right - m_rowRect.right - 1, 1, cr);
	}

	pDC->FillSolidRect(rect.left, rect.top + 1,	1, rect.Height() - 2, cr);

	// dark gray line along right and bottom side
	cr = GetSysColor(COLOR_BTNSHADOW);
	pDC->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(), cr);
	pDC->FillSolidRect(rect.left, rect.bottom - 1, rect.Width() - 1, 1, cr);

}

void CTabRow::SetFirstTab(int nTab)
{
	// This function recalcs the positions of all the tabs, assuming the
	// specified tab is the first (leftmost) visible tab.

	if (nTab < 0 || MaxTab() < nTab)
		return;

	int x = m_rowRect.left + cxSelectedTab;

	// everything before the first tab is not visible
	for (int i = 0 ; i < nTab ; i++)
		GetTab(i)->m_rect.SetRectEmpty();

	// calculate locations for all other tabs
	for (i = nTab ; i <= MaxTab() ; i++)
	{
		GetTab(i)->m_rect.SetRect(x, m_rowRect.top + cySelectedTab,
		                          x + GetTab(i)->m_nWidth, m_rowRect.bottom - cySelectedTab);
		x += GetTab(i)->m_nWidth + cxSelectedTab;
		GetTab(i)->m_bClipped = FALSE;
	}

	// do they all fit?
	x = m_rowRect.right - (nTab == 0 ? 0 : (cxScrollMargin + cxScrollSize));
	i = MaxTab();
	while ((i >= 0) && (GetTab(i)->m_rect.right > x))
	{
		x = m_rowRect.right - (cxScrollMargin + cxScrollSize);
		if (GetTab(i)->m_rect.left < x)
		{
			GetTab(i)->m_bClipped = TRUE;
			GetTab(i)->m_rect.right = x;
		}
		else
			GetTab(i--)->m_rect.SetRectEmpty();
	}

	m_firstTab = nTab;
}

BOOL CTabRow::IsTabVisible(int nTab, BOOL bPartials)
{
	if (GetTab(nTab)->m_rect.IsRectNull())
		return FALSE;

	return bPartials || !GetTab(nTab)->m_bClipped;
}

void CTabRow::Scroll(int nDirection)
{
	ASSERT(nDirection == SCROLL_LEFT || nDirection == SCROLL_RIGHT);
	ASSERT(CanScroll());

	BOOL bRepaintScrollers = ((nDirection == SCROLL_LEFT) && IsTabVisible(MaxTab(), FALSE))
			|| ((nDirection == SCROLL_RIGHT) && IsTabVisible(0, FALSE));

	switch(nDirection)
	{
		case SCROLL_LEFT:
			if (m_firstTab == 0)
				return;

			SetFirstTab(m_firstTab - 1);
			break;

		case SCROLL_RIGHT:
			if (IsTabVisible(MaxTab(), FALSE))
				return;

			SetFirstTab(m_firstTab + 1);
			break;
	}

	// repaint all tabs, and (if their enable state has changed) the scroll
	// buttons as well.
	CRect rc = m_rowRect;
	if (!bRepaintScrollers)
		rc.right = m_scrollRect.left - 1;
	m_pWndOwner->InvalidateRect(&rc);
}

void CTabRow::ScrollIntoView(int nTab)
{
	if (nTab < 0 || nTab > MaxTab() || IsTabVisible(nTab, FALSE) ||
			m_rowRect.IsRectEmpty())
		return;

	// do we need to scroll left, or right?
	int increment = (nTab > m_firstTab) ? 1 : -1;

	while (!IsTabVisible(nTab, FALSE))
		SetFirstTab(m_firstTab + increment);

	m_pWndOwner->InvalidateRect(&m_rowRect);
}

BOOL CTabRow::CanScroll()
{
	// if either the first or the last tab is not visible, it's scrollable
	return MaxTab() >= 0 && (!IsTabVisible(0, FALSE) || !IsTabVisible(MaxTab(), FALSE));
}

void CTabRow::OnMouseMove(CPoint pt)
{
	ASSERT((m_nScrollState == SCROLL_LEFT) || (m_nScrollState == SCROLL_RIGHT));

	int nNewState = TabFromPoint(pt);
	BOOL bPause = !(nNewState == m_nScrollState);

	if (bPause == m_bScrollPause)
		return;

	if (bPause)
		m_pWndOwner->KillTimer(TIMER_ID);
	else
	{
		VERIFY( m_pWndOwner->SetTimer(TIMER_ID, TIMER_DELAY, NULL) == TIMER_ID );
		Scroll(m_nScrollState);
	}

	m_bScrollPause = bPause;
	InvalidateTab(m_nScrollState);
}

void CTabRow::OnLButtonUp(CPoint pt)
{
	Capture(SCROLL_NULL);
}

void CTabRow::OnTimer()
{
	ASSERT((m_nScrollState == SCROLL_LEFT) || (m_nScrollState == SCROLL_RIGHT));
	ASSERT(!m_bScrollPause);

	Scroll(m_nScrollState);
}

void CTabRow::Capture(int nDirection)
{
	ASSERT((m_nScrollState == SCROLL_LEFT) || (m_nScrollState == SCROLL_RIGHT) ||
	       (m_nScrollState == SCROLL_NULL));

	switch(nDirection)
	{
		case SCROLL_LEFT:
		case SCROLL_RIGHT:
			m_pWndOwner->SetCapture();
			VERIFY( m_pWndOwner->SetTimer(TIMER_ID, TIMER_DELAY, NULL) == TIMER_ID );
			InvalidateTab(nDirection);
			break;

		case SCROLL_NULL:
			::ReleaseCapture();
			m_pWndOwner->KillTimer(TIMER_ID);
			InvalidateTab(m_nScrollState);
			break;
	}

	m_nScrollState = nDirection;
	m_bScrollPause = FALSE;
}

void CTabRow::InvalidateTab(int nTab, BOOL bInflate)
{
	CRect rc;
	
	switch (nTab)
	{
		case SCROLL_LEFT:
			rc = m_scrollRect;
			rc.right -= (rc.Width() / 2 - 1);
			break;

		case SCROLL_RIGHT:
			rc = m_scrollRect;
			rc.left += (rc.Width() / 2 - 1);
			break;

		default:
			rc = GetTab(nTab)->m_rect;
			if (bInflate)
			{
				rc.left -= cxSelectedTab;
				rc.right += cxSelectedTab + 1;
				rc.top = m_rowRect.top;
				rc.bottom = m_rowRect.bottom;
			}
			if (GetTab(nTab)->m_bClipped)
				rc.right += 1;
	}

	ASSERT(m_pWndOwner);
	m_pWndOwner->InvalidateRect(&rc, nTab >= 0);
}

int CTabRow::TabFromPoint(CPoint pt)
{
	// are we on the scroll buttons?
	if (CanScroll() && m_scrollRect.PtInRect(pt))
	{
		if (pt.x < m_scrollRect.left + (m_scrollRect.Width() / 2))
			return IsTabVisible(0, FALSE) ? -1 : SCROLL_LEFT;
		else
			return IsTabVisible(MaxTab(), FALSE) ? -1 : SCROLL_RIGHT;
	}

	// are we on a tab?
	for (int i = 0 ; i <= MaxTab() ; i++)
		if (GetTab(i)->m_rect.PtInRect(pt))
			return i;

	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CTabbedDialog -- a tabbed "dialog" (really a popup-window)

IMPLEMENT_DYNAMIC(CTabbedDialog, CWnd)

CTabbedDialog::CTabbedDialog(UINT nIDCaption, CWnd* pParent /*=NULL*/,
                             UINT iSelectTab /*=-1*/, COMMIT_MODEL commitModel /*=commitOnOk*/, DLGPOSITION pos /*=POS_APPCENTER*/)
{
	m_pParentWnd = pParent == NULL ? AfxGetApp()->m_pMainWnd : pParent;

	nCaptionID = nIDCaption;
	m_nTabCur = iSelectTab;

	m_tabRow.SetParent(this);
	m_tabRow.PutFocus(TRUE);
	m_hFocusWnd = 0;
	m_strCaption.LoadString( nIDCaption );
	m_commitModel = commitModel;
	m_iDefBtnIndex = 0;	// ie. the first one (usually 'OK')
	m_buttonSize = CSize(0, 0);
	m_position=pos;
}

BOOL CTabbedDialog::PreTranslateMessage(MSG* pMsg)
{
	CWnd* pWnd;

	// If the standard tabbed-dialog pretranslate code knows how to handle
	// this message, let it.
	if (MessageStolenByTabbedDialog(pMsg))
		return TRUE;

	switch (pMsg->message)
	{
	case WM_KEYDOWN:

		switch ((char) pMsg->wParam)
		{
			case VK_ESCAPE:
				PostMessage(WM_COMMAND, IDCANCEL);
				return TRUE;

			case VK_RETURN:
				pWnd = GetFocus();
				if ((pWnd == NULL) || !IsButton(pWnd->GetSafeHwnd()))
					pWnd = GetButtonFromIndex(0);
				PostMessage(WM_COMMAND, pWnd->GetDlgCtrlID());
				return TRUE;

			default:
				::TranslateMessage( pMsg );
				::DispatchMessage( pMsg );
				return TRUE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}

void CTabbedDialog::BuildTabItemList(CObList& list, CMapWordToOb& map, CWnd* pWndCur)
{
	int i;
	CString str;
	char cAccel = 0;

	if (pWndCur == NULL)
	{
		ASSERT(list.IsEmpty());
		ASSERT(map.IsEmpty());
		pWndCur = GetWindow(GW_CHILD);
	}

	while (pWndCur != NULL)
	{
		if (pWndCur->IsKindOf( RUNTIME_CLASS(CDialog) ))
		{
			if (pWndCur->IsWindowVisible())
			{
				// if it's a tabbed dialog, include an entry for the tab row
				if (pWndCur->IsKindOf( RUNTIME_CLASS(CDlgTab) ))
					list.AddTail(this);

				// recursively process all dialogs to get a list of tab stops
				CWnd* pWndChild = pWndCur->GetWindow(GW_CHILD);
				ASSERT(pWndChild);
				BuildTabItemList(list, map, pWndChild);
			}
		}
		else
		{
			DWORD dwStyle = pWndCur->GetStyle();
			if ((dwStyle & (WS_DISABLED | WS_VISIBLE)) == WS_VISIBLE)
			{
				// We don't want to look at text from edit fields, 
				// combo boxes or list boxes, since it might have
				// an '&'.
				// FUTURE: There has *got* to be a better way to do this!
				//
				char szClassName[9];
				if (::GetClassName (pWndCur->m_hWnd, szClassName, sizeof szClassName)
					&&	_stricmp (szClassName, "Edit")
					&&	_stricmp (szClassName, "Combobox")
					&&	_stricmp (szClassName, "Listbox") )
				{
					int nLen = ::GetWindowTextLength(pWndCur->m_hWnd);
					if (nLen < 1)
						str.Empty();
					else
					{
						::GetWindowText(pWndCur->m_hWnd,
							str.GetBufferSetLength(nLen), nLen+1);
						str.ReleaseBuffer();
					}

DoubleAmpersand:
					if ((i = str.Find('&')) != -1)
					{
						ASSERT(str.GetLength() > i+1);	// & can't be last char
						if (str[i + 1] == '&')
						{
							str = str.Right(str.GetLength() - (i + 2));
							goto DoubleAmpersand;
						}
						cAccel = str[i + 1];
					}
				}

				if (dwStyle & WS_TABSTOP)
				{
					list.AddTail(pWndCur);
					if (cAccel != 0)
					{
						map.SetAt((WORD)toupper(cAccel), pWndCur);
						cAccel = 0;
					}
				}
			}
		}

		pWndCur = pWndCur->GetWindow(GW_HWNDNEXT);
	}
}

CWnd* CTabbedDialog::FindControl(CWnd* pWndFocus, CObList& list, FC fc)
{
	POSITION pos;

	if (fc == FC_FIRST)
	{	// pWndFocus is the dialog
		// The following MFC call should work, but doesn't:
		//
		//pWndFocus = pWndFocus->GetNextDlgTabItem (pWndFocus);
		//
		// So, we use the Win32 equivalent instead:

		HWND hWnd = ::GetNextDlgTabItem (pWndFocus->m_hWnd, pWndFocus->m_hWnd, FALSE);
		pWndFocus = FromHandle (hWnd);
	}

	pos = list.Find(pWndFocus);
	while (pos == NULL)
	{
		// possibly the current focus window is a child of some window
		// in the list?
		pWndFocus = pWndFocus->GetParent();
		if (pWndFocus == NULL)
		{
			ASSERT(fc == FC_THIS || fc == FC_FIRST);	// Never happens otherwise?
			return NULL;
		}

		pos = list.Find(pWndFocus);
	}


	// Handle wrapping off the top or bottom of the dialog.
	switch (fc)
	{
		case FC_NEXT:
			list.GetNext(pos);
			if (pos == NULL)
				return (CWnd*) list.GetHead();
			break;

		case FC_PREVIOUS:
			list.GetPrev(pos);
			if (pos == NULL)
				return (CWnd*) list.GetTail();
			break;


		case FC_FIRST:
		case FC_THIS:
			if (pos == NULL)
				return NULL;
			break;

#ifdef _DEBUG
		default:
			ASSERT(FALSE);
			break;
#endif
	}

	ASSERT(pos != NULL);
	return (CWnd*) list.GetAt(pos);
}

void CTabbedDialog::SetFocusToControl(CWnd* pControl, CObList* pList, BOOL bSetSel)
{
	ASSERT(pControl);
	CWnd* pOldDefault = NULL;
	CObList list;
	CMapWordToOb map;

	if (pList == NULL)
	{
		BuildTabItemList(list, map);
		pList = &list;
	}

	// If it's not in the list, it can't take the focus.  This catches user
	// clicks on subdialogs.
	CWnd* pListItem = FindControl(pControl, *pList, FC_THIS);
	if ((pListItem == NULL) || ((pListItem != pControl) && (pListItem == this)))
		return;

	// Now set the focus...
	m_tabRow.PutFocus(pControl == this);
	pControl->SetFocus();

	// if this control handles SETSEL messages, select the entire contents
	if (bSetSel && pControl->SendMessage(WM_GETDLGCODE) & DLGC_HASSETSEL)
		pControl->SendMessage(EM_SETSEL, 0, -1);

	// Now that the new control has had a chance to request a different
	// default button, we can set the correct button.

	// First, figure out who currently has the default button style...
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL)
	{
		CWnd * pWnd = (CWnd*) pList->GetNext(pos);
		if (pWnd->SendMessage(WM_GETDLGCODE) & DLGC_DEFPUSHBUTTON)
		{
			pOldDefault = pWnd;
			break;
		}
	}

	// ...now figure out who ought to have the default button style...
	CWnd* pNewDefault = (CWnd *)NULL;
	if (m_iDefBtnIndex != -1)
	{
		pNewDefault = GetButtonFromIndex(m_iDefBtnIndex);
		if (pControl->SendMessage(WM_GETDLGCODE) & (DLGC_DEFPUSHBUTTON | DLGC_UNDEFPUSHBUTTON))
			pNewDefault = pControl;

		ASSERT(pNewDefault);
		if (pNewDefault->m_hWnd == NULL)
			return;
	}

 	// ...no new default button if new equals old...
	if (pNewDefault == pOldDefault)
		return;

	// ...but if the default button needs to change, cancel the old one...
	if (pOldDefault != NULL)
	{
		::SetWindowLong(pOldDefault->GetSafeHwnd(), GWL_STYLE, 
			GetWindowLong(pOldDefault->GetSafeHwnd(), GWL_STYLE) & ~BS_DEFPUSHBUTTON);
		pOldDefault->Invalidate();
	}

	// ...and set the new one.
	if (pNewDefault != NULL)
	{
		::SetWindowLong(pNewDefault->GetSafeHwnd(), GWL_STYLE, 
			GetWindowLong(pNewDefault->GetSafeHwnd(), GWL_STYLE) | BS_DEFPUSHBUTTON);
		pNewDefault->Invalidate();
	}
}

void CTabbedDialog::HandleTab(BOOL bShift, BOOL bControl)
{
	if (bControl)
	{
		int nNewTab = m_nTabCur;

		if (bShift)
			nNewTab--;
		else
			nNewTab++;

		int nLastTab = m_tabs.GetSize() - 1;

		if (nNewTab < 0)
			nNewTab = nLastTab;
		else
		if (nNewTab > nLastTab)
			nNewTab = min(0, nLastTab);

		SelectTab ( nNewTab, GetFocus() == this ? FALSE : TRUE );
	}
	else
	{
		CObList list;
		CMapWordToOb map;

		BuildTabItemList(list, map);

		CWnd* pWndNext = FindControl(GetFocus(), list, bShift ? FC_PREVIOUS : FC_NEXT);
		ASSERT(pWndNext != NULL);

		if (pWndNext != NULL)
			SetFocusToControl(pWndNext, &list);
	}
}

BOOL CTabbedDialog::HandleAcceleratorKey(char ch)
{
	CObList list;
	CMapWordToOb map;

	BuildTabItemList(list, map);

	CObject* pObject;
	if (!map.Lookup(ch, pObject))
		return FALSE;

	CWnd* pWnd = (CWnd*)pObject;
	ASSERT(pWnd->IsKindOf( RUNTIME_CLASS(CWnd) ));

	SetFocusToControl(pWnd, &list);

	// Automatically push buttons and twiddle checkboxes
	if (pWnd->SendMessage(WM_GETDLGCODE) & DLGC_BUTTON)
	{
		CButton* pButton = (CButton*)pWnd;
		DWORD dwStyle = pButton->GetStyle();

		// [marklam] Dolphin 9492,9488 need to set check and then send button clicked message.
		// Random.
		if ((dwStyle & BS_AUTOCHECKBOX) == BS_AUTOCHECKBOX)
		{
			pButton->SetCheck(1 - pButton->GetCheck());
			pButton->GetParent()->SendMessage(WM_COMMAND, (WPARAM)(pWnd->GetDlgCtrlID() | (BN_CLICKED<<16)), (LPARAM)pWnd->GetSafeHwnd());
		}
		else if ((dwStyle & BS_AUTO3STATE) == BS_AUTO3STATE)
		{
			pButton->SetCheck((pButton->GetCheck() + 1) % 3);
			pButton->GetParent()->SendMessage(WM_COMMAND, (WPARAM)(pWnd->GetDlgCtrlID() | (BN_CLICKED<<16)), (LPARAM)pWnd->GetSafeHwnd());
		}
		else
		{									   
			pButton->SendMessage(WM_LBUTTONDOWN, (WPARAM)0, (LPARAM)0);
			pButton->SendMessage(WM_LBUTTONUP, (WPARAM)0, (LPARAM)0);
		}
	}

	return TRUE;
}

BOOL CTabbedDialog::HandleTabRowKey(char ch)
{
	if (!_istalnum(ch))
		return FALSE;

	// Starting from current position + 1, cycle through all the dlgtabs
	// looking for one whose caption starts with the requested character.
	CDlgTab* pTab;
	int i = m_nTabCur + 1;

	while (i != m_nTabCur)
	{
		if ((pTab = GetTab(i++)) == NULL)
		{
			i = 0;
			continue;
		}

		if (pTab->m_strCaption.GetLength() < 1)
		{
			ASSERT(FALSE);	// shouldn't have captionless dlgtabs
			continue;
		}

		if (pTab->m_strCaption[0] == ch)
		{
			SelectTab(i - 1, FALSE);
			return TRUE;
		}
	}

	return FALSE;
}


// MessageStolenByTabbedDialog
//
// This function should be called during PreTranslateMessage by the DlgTab
// or by any subdialog contained within the DlgTab.
//
// If the function returns TRUE, the tabbed dialog has processed the
// message and no further action is required by the DlgTab.
//

// Be cautious not to simply capture keys in this procedure by spotting and acting
// WM_KEYDOWN or WM_SYSKEYDOWN messages. Because the Keyboard customisation dialog
// is a tabbed dialog, it doesn't expect to lose any keys upstream. To indicate this,
// it returns dlgCode will all the DLGC_WANTxxx flags set. Ensure you pay attention to 
// these flags when deciding whether to do special parsing in this routine
// martynl 13Mar96
BOOL CTabbedDialog::MessageStolenByTabbedDialog(MSG* pMsg)
{
	LRESULT dlgCode;

	switch (pMsg->message)
	{
		case WM_SYSKEYDOWN:

			if ((char) pMsg->wParam == VK_MENU)
				break;

			// Unless there is a current focus item that wants all its own
			// keys, process accelerators here.
			dlgCode = (GetFocus() == NULL) ? (LRESULT)0 : GetFocus()->SendMessage(WM_GETDLGCODE);

			if (! (dlgCode & DLGC_WANTALLKEYS) &&
			    HandleAcceleratorKey((char) pMsg->wParam))
			{
				return TRUE;
			}

			break;

		case WM_KEYDOWN:

			dlgCode = (GetFocus() == NULL) ? (LRESULT)0 : GetFocus()->SendMessage(WM_GETDLGCODE);

			switch(pMsg->wParam)
			{
				case VK_TAB:
					// Note that we do tab handling here even if the control
					// with the current focus has DLGC_WANTALLKEYS set.
					
					// However, we do not handle tabs if the control has specifically asked
					// for them. This is required, to allow the keyboard customisation
					// tab to handle its own tabs. martynl 13Mar96
					if(dlgCode & DLGC_WANTTAB)
					{
						break;
					}
					else
					{
						HandleTab(GetKeyState(VK_SHIFT) < 0, GetKeyState(VK_CONTROL) < 0);
						return TRUE;
					}

				case VK_NEXT:
					// Note that we do not check for DLGC_WANTALLKEYS--this prevents
					// Ctrl+PgDn from working in Build.Settings dialog.  Instead we
					// check for same condition we use for VK_TAB above.
					if (dlgCode & DLGC_WANTTAB)
					{
						break;
					}
					else
					{
						if (GetKeyState(VK_CONTROL) < 0)
						{
							SelectNextTab();
							return TRUE;
						}
					}
					break;

				case VK_PRIOR:
					// Note that we do not check for DLGC_WANTALLKEYS--this prevents
					// Ctrl+PgUp from working in Build.Settings dialog.  Instead we
					// check for same condition we use for VK_TAB above.
					if (dlgCode & DLGC_WANTTAB)
					{
						break;
					}
					else
					{
						if (GetKeyState(VK_CONTROL) < 0)
						{
							SelectPreviousTab();
							return TRUE;
						}
					}
					break;

//				case VK_F1:
//					if (dlgCode & DLGC_WANTALLKEYS)
//						break;
//
//					OnHelp();
//					return TRUE;

				default:
					// Hitting keys with the focus on the tab row should go
					// through normal key processing.
					if (m_tabRow.HasFocus())
						break;

					// If the current focus window doesn't respond to character
					// input, then hitting a key should be handled as an
					// accelerator in accordance with Windows standards.
					if (! (dlgCode & (DLGC_WANTCHARS | DLGC_WANTALLKEYS))
						&& HandleAcceleratorKey((char) pMsg->wParam))
					{
						return TRUE;
					}

					break;
			}
			break;

		// In VC 4.x, it was possible for two buttons in a tabbed dialog to become
		// the default button at the same time. 
		// To fix this problem, we spot here where the user is pressing a button
		// and take the focus away from our default button. martynl 14Mar96
		case WM_LBUTTONDOWN: 
			// since this routine is called by our own PreTranslateMessage
			// we have to check whether this message is really for one of our 
			// children
			if(GetSafeHwnd()!=pMsg->hwnd)
			{
				CWnd * pWndButton=CWnd::FromHandle(pMsg->hwnd);

				// is the new click on a button?
				dlgCode = pWndButton->SendMessage(WM_GETDLGCODE);

				// and is that thing enabled
				BOOL bEnabled=pWndButton->IsWindowEnabled();

				// if both, then we should stop being a default button
				if((dlgCode & DLGC_UNDEFPUSHBUTTON)!=0 && bEnabled) {
					// determine which window is the default
					// start by getting the first child of the tabbed dialog
					CWnd *pWnd=GetWindow(GW_CHILD);
					BOOL bFound=FALSE;

					// loop thru all children, checking for default
					while(!bFound && pWnd!=NULL && pWnd->GetParent()->GetSafeHwnd()==GetSafeHwnd()) 
					{
						dlgCode=pWnd->SendMessage(WM_GETDLGCODE);
						if(dlgCode & DLGC_DEFPUSHBUTTON)
						{
							bFound=TRUE;
						}
						else
						{
							pWnd=pWnd->GetWindow(GW_HWNDNEXT);
						}
					}						

					// remove default status
					if(bFound) {
						CButton *btn=(CButton *)pWnd;
						
						btn->SetButtonStyle(btn->GetButtonStyle() - BS_DEFPUSHBUTTON + BS_PUSHBUTTON);
					}
				}
			}
			break;
	}

	return FALSE;
}

int CTabbedDialog::DoModal()
{
	int nResult = IDABORT;

	// cannot call DoModal on a dialog already constructed as modeless
	ASSERT(m_hWnd == NULL);

	PreModalWindow();

	// allow OLE servers to disable themselves
	AfxGetApp()->EnableModeless(FALSE);

	// disable parent before creating or MFC will disable us.
	m_pParentWnd->EnableWindow(FALSE);

	if (Create())
	{	

		ASSERT(IsWindowEnabled());	// should not be disabled to start!
		SetActiveWindow();

		m_nID = -1;
		while (m_hWnd != NULL && AfxGetApp()->PumpMessage() && m_nID == -1)
			;
	
		nResult = m_nID;
	}

	// allow OLE servers to enable themselves
	AfxGetApp()->EnableModeless(TRUE);

	// enable top level parent window again
	m_pParentWnd->EnableWindow(TRUE);

	PostModalWindow();

	return nResult;
}

BOOL CTabbedDialog::Create()
{
	if (!CreateEx(WS_EX_DLGMODALFRAME | WS_EX_CONTEXTHELP,
		AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW,
							LoadCursor(NULL, IDC_ARROW),
							(HBRUSH)(COLOR_BTNFACE + 1)), 
		m_strCaption,
		WS_SYSMENU | WS_POPUP | WS_CAPTION | WS_VISIBLE | WS_CAPTION | DS_MODALFRAME,
		50, 50, 400, 200, m_pParentWnd->m_hWnd, NULL))
	{
		return FALSE;
	}

	SetActiveWindow();
	(void) ActivateTab(m_nTabCur, TRUE);	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////

BOOL CTabbedDialog::ClearAllTabs()
{
	if (m_tabs.GetSize() != 0)
	{
		// de-select the current
		SelectTab(-1, TRUE);

		// tab still active?
		if (m_nTabCur != -1)
			return FALSE;	// clear failed

		// delete our existing tabs
		int nTabs = m_tabs.GetSize();
		for (int i = 0; i < nTabs; i++)
			delete m_tabs[i];
		m_tabs.SetSize(0);

		// reset the tab row to reflect this clear
		m_tabRow.ResetContent();
	}

	return TRUE;	// success
}

////////////////////////////////////////////////////////////////////////////

void CTabbedDialog::AddTab(CDlgTab* pDlgTab)
{
	// FUTURE this uses the screen DC rather than the tabbed dialog DC
	// in the normal case, because the tabbed dialog's DC will often be
	// NULL at this point.  This was an oversight in the code, not
	// discovered until shortly before ship -- we should probably calc
	// tab sizes when the dialog is created, like MFC does.
	CDC* pDC = CDC::FromHandle(::GetDC(m_hWnd));

	for (int i = 0; ; i += 1)
	{
		if (i == m_tabs.GetSize())
		{
			m_tabs.Add(pDlgTab);
			break;
		}
		
		if (pDlgTab->m_nOrder < ((CDlgTab*)m_tabs[i])->m_nOrder)
		{
			m_tabs.InsertAt(i, pDlgTab);
			break;
		}
		
		ASSERT(i < m_tabs.GetSize());
	}
	
	m_tabRow.AddTab(pDlgTab->m_strCaption, pDC, pDlgTab->m_nOrder);
	::ReleaseDC(m_hWnd, pDC->m_hDC);
}

BEGIN_MESSAGE_MAP(CTabbedDialog, CWnd)
	//{{AFX_MSG_MAP(CTabbedDialog)
	ON_WM_PAINT()
	ON_WM_NCCREATE()
	ON_WM_CREATE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_TIMER()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_ACTIVATE()
	ON_WM_KEYDOWN()
	ON_WM_CLOSE()
	ON_WM_SIZE()
	ON_WM_KEYDOWN()
	ON_WM_PARENTNOTIFY()
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
	ON_COMMAND(IDOK, OnOK)
	ON_COMMAND(IDCANCEL, OnCancel)
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabbedDialog message handlers

BOOL CTabbedDialog::OnNcCreate(LPCREATESTRUCT lpcs)
{
	if (!CWnd::OnNcCreate(lpcs))
		return FALSE;

//	SubclassDlg3d();	// add CTL3D effects, if loaded
	return TRUE;
}

int CTabbedDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Fix-up the system menu so this looks like a dialog box
	CMenu* pSysMenu = GetSystemMenu(FALSE);
	ASSERT(pSysMenu != NULL);
	pSysMenu->DeleteMenu(7, MF_BYPOSITION);
	pSysMenu->DeleteMenu(5, MF_BYPOSITION);
	pSysMenu->DeleteMenu(SC_SIZE, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_TASKLIST, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);
	pSysMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
		  
	// do we have a tab ready to select?
	if (m_nTabCur == -1)
	{
		CString strTabCaption;
		if (m_DialogMap.LookupTab( (WORD)nCaptionID, strTabCaption))
			for (int i = 0 ; i <= m_tabRow.MaxTab() ; i++)
				if (m_tabRow.GetTabString(i) == strTabCaption)
				{
					m_nTabCur = i; break;
				}

		// did we find a remembered tab?
		if (m_nTabCur == -1)
			m_nTabCur = 0;
	}

	if (ActivateTab(m_nTabCur, FALSE))
		m_tabRow.SetActiveTab(m_nTabCur);
	else
		m_nTabCur = -1;	// no tab selected

	// send notification of this initial tab
	OnSelectTab(m_nTabCur);

	return 0;
}

void CTabbedDialog::OnContextMenu(CWnd* pWnd, CPoint pt) 
{
	ASSERT(m_nTabCur >=0) ;
	if( m_nTabCur < 0 )
		return;

	// use current tab's dialog help id (determines helpfile used)
	DoHelpContextMenu(this, ((CDlgTab*)m_tabs[m_nTabCur])->GetHelpID(), pt);
}

BOOL CTabbedDialog::OnHelpInfo(HELPINFO* pInfo) 
{
	if (m_nTabCur < 0)
	{
		return TRUE ;
	}

	// use current tab's dialog help id (determines helpfile used)
	return DoHelpInfo(this, ((CDlgTab*)m_tabs[m_nTabCur])->GetHelpID(), pInfo);
}

void CTabbedDialog::OnPaint()
{
	CPaintDC dc(this);
	dc.SetBkMode(TRANSPARENT);

	// the tabs know how to draw themselves
	m_tabRow.Draw(&dc);

	CRect rectPage, margins;
	GetClientRect(rectPage);
	GetMargins(margins);

	rectPage.left += margins.left;
	rectPage.right -= margins.right;
	rectPage.bottom -= margins.bottom;

	m_tabRow.DrawPageRect(&dc, rectPage);
}

void CTabbedDialog::SelectTab(int nTab, BOOL bGoToControl)
{
	CDlgTab *pTab;

	ASSERT(nTab == -1 || (nTab >= 0 && nTab < m_tabs.GetSize()));

	if (nTab == m_nTabCur)
		return;

	if (m_hWnd == NULL)
	{
		// Selecting tabs is really easy if nothing's been shown yet
		m_nTabCur = nTab;
		return;
	}

	int nPrevTab = m_nTabCur;
	if (m_nTabCur != -1)
	{
		pTab = GetTab(m_nTabCur);
		if (!pTab->ValidateTab())
		{
			TRACE("Tab %s refused deactivation!\n", 
				(const char*)GetTab(m_nTabCur)->m_strCaption);
			return;
		}
		pTab->Deactivate(this);
	}

	if (nTab != -1 && !ActivateTab(nTab, bGoToControl))
	{
		TRACE("Could not activate tab %s!\n", 
			(const char*)GetTab(nTab)->m_strCaption);
		return;
	}

	if (nPrevTab != -1)
		pTab->ShowWindow(SW_HIDE);

	m_nTabCur = nTab;

	if (nTab != -1)
	{
		m_tabRow.SetActiveTab(nTab);

		// send notification of this tab change
		OnSelectTab(nTab);
	}
}

void CTabbedDialog::SelectTab(const CString& strCaption, BOOL bGoToControl)
{
	CString str;
	for (int i = 0 ; i < strCaption.GetLength() ; i++)
	{
		if (strCaption[i] != '&')
			str += strCaption[i];
	}

	for (int nTab = 0 ; nTab < m_tabs.GetSize() ; nTab++)
		if (GetTab(nTab)->m_strCaption.Compare(str) == 0)
		{
			SelectTab(nTab, bGoToControl);
			return;
		}
}

void CTabbedDialog::SelectNextTab()
{
	int nTab = m_nTabCur + 1;
	if (nTab >= m_tabs.GetSize())
		nTab = min(0, m_tabs.GetSize()-1);
	if (nTab != m_nTabCur)
		SelectTab(nTab, TRUE);
}

void CTabbedDialog::SelectPreviousTab()
{
	int nTab = m_nTabCur - 1;
	if (nTab < 0)
		nTab = m_tabs.GetSize() - 1;
	if (nTab != m_nTabCur)
		SelectTab(nTab, TRUE);
}

void CTabbedDialog::GetMargins(CRect& rect)
{
	if (m_buttonSize.cx == 0)
	{
		// Calculate the proper size of the buttons, based on average character
		// width and height of the font.  If it's a variable pitch font,
		// calculate the average pitch (code copied from editor.cpp)
		//
		LONG cxChar;
		CDC* pDC = GetDC();
		CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Normal));

	    TEXTMETRIC tm;
	    pDC->GetTextMetrics(&tm);

	    if (tm.tmPitchAndFamily & 0x01)
	    {
	        CHAR szAveCharWidth[52];        // array to hold A-Z and a-z

	        for (int i = 0; i < 26; i++)
	        {
	            szAveCharWidth[i] = (CHAR)(i + 'a');
	            szAveCharWidth[i + 26] = (CHAR)(i + 'A');
	        }

			CSize sizeExtent = pDC->GetTextExtent(szAveCharWidth, 52);
			cxChar = ((sizeExtent.cx / 26) + 1) / 2;
	    }
	    else
	    {
	        cxChar = tm.tmAveCharWidth;
	    }

		pDC->SelectObject(pOldFont);
		ReleaseDC(pDC);

		int duWidth = duButtonWidth;
		if (theApp.m_fOEM_MBCS)
			duWidth += 10;	// Need a little extra space for japanese.

		m_buttonSize.cx = cxChar * duWidth / 4;
		m_buttonSize.cy = tm.tmHeight * duButtonHeight / 8;
		m_cxBetweenButtons = cxChar * duBetweenButtons / 4;
	}

	// Override to specify left, right, top and bottom margins around the tabs
	rect.SetRect(cxTabMargin, cyTabMargin, cxTabMargin, cyTabMargin);

	// If we have any buttons, leave space for them at the bottom
	if (GetButtonFromIndex(0) != NULL)
		rect.bottom += cyBottomMargin + m_buttonSize.cy;
}


// Return a rect covering the entire row of buttons.
void CTabbedDialog::GetButtonExtent(CSize& size)
{
	CButton * pButton;
	size.cx  = 0;
	for (int iButton = 0; pButton = GetButtonFromIndex(iButton); iButton++)
	{
		size.cx += m_buttonSize.cx + m_cxBetweenButtons;
	}

	if (iButton)
		size.cx -= m_cxBetweenButtons;

	size.cy = m_buttonSize.cy;
}

void CTabbedDialog::OnLButtonDown(UINT nFlags, CPoint point)
{
	int nTab = m_tabRow.TabFromPoint(point);
	switch(nTab)
	{
		default:
			BOOL bTabFocus;
			bTabFocus = GetFocus() == this || m_nTabCur == nTab;
			ASSERT(nTab >= 0);
			SetFocusToControl(this);
			SelectTab(nTab, !bTabFocus);
			break;

		case CTabRow::SCROLL_LEFT:
		case CTabRow::SCROLL_RIGHT:
			m_tabRow.Scroll(nTab);
			m_tabRow.Capture(nTab);
			break;

		case -1:
			break;
	}
}

void CTabbedDialog::OnTimer(UINT nTimerID)
{
	if (m_tabRow.HasCapture())
	{
		ASSERT(nTimerID == CTabRow::TIMER_ID);
		m_tabRow.OnTimer();
	}
	else
		CWnd::OnTimer(nTimerID);
}

void CTabbedDialog::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_tabRow.HasCapture())
		m_tabRow.OnMouseMove(point);
	else
		CWnd::OnMouseMove(nFlags, point);
}

void CTabbedDialog::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_tabRow.HasCapture())
		m_tabRow.OnLButtonUp(point);
	else
		CWnd::OnLButtonUp(nFlags, point);
}

void CTabbedDialog::DrawFocusRect()
{
	if (!m_tabRow.HasFocus())
		return;		

	CDC* pDC = GetDC();
	m_tabRow.DrawFocusRect(pDC);
	ReleaseDC(pDC);
}

void CTabbedDialog::OnSetFocus(CWnd* pOldWnd)
{
	CWnd* pWnd = NULL;
	if (IsWindow(m_hFocusWnd) && !m_tabRow.HasFocus())
		pWnd = CWnd::FromHandle(m_hFocusWnd);
	if (pWnd == NULL)
		DrawFocusRect();
	else
		SetFocusToControl(pWnd, NULL, FALSE);
}

void CTabbedDialog::OnKillFocus(CWnd* pNewWnd)
{
	if (IsWindowVisible() && m_tabRow.HasFocus())
		DrawFocusRect();
}

void CTabbedDialog::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	// Changed this routine to use m_hFocusWnd instead of m_pFocusWnd
	if (nState == WA_INACTIVE)
	{
		m_hFocusWnd = ::GetFocus();
		m_tabRow.PutFocus(m_hFocusWnd == GetSafeHwnd());
	}
	else
	{
		// Focus is either in the CTabRow or belongs to a control.
		if (m_nTabCur != -1)
		{
			CWnd* pWnd = NULL;
			if (IsWindow(m_hFocusWnd) && !m_tabRow.HasFocus())
				pWnd = CWnd::FromHandle(m_hFocusWnd);
			if (pWnd != NULL)
				SetFocusToControl(pWnd, NULL, FALSE);
			else
			{
				SetFocusToControl(this);
				m_tabRow.InvalidateTab(m_nTabCur);
			}
		}

		return;
	}
	
	CWnd::OnActivate(nState, pWndOther, bMinimized);
}

void CTabbedDialog::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	int nTab = m_nTabCur;

	switch (nChar)
	{
		case VK_ESCAPE:
			PostMessage(WM_COMMAND, IDCANCEL);
			break;

		case VK_LEFT:
		case VK_UP:
			nTab -= 1;
			break;

		case VK_RIGHT:
		case VK_DOWN:
			nTab += 1;
			break;

#ifdef _DEBUG
		case VK_RETURN:
		case VK_TAB:
			ASSERT(FALSE);
			break;
#endif // _DEBUG

		default:
			HandleTabRowKey((TCHAR)nChar);
			return;
	}

	if (nTab != m_nTabCur)
	{
		// if we have other arrow keys pending, coalesce
		MSG msg;
		while (::PeekMessage(&msg, GetSafeHwnd(), WM_KEYDOWN, WM_KEYDOWN, PM_NOREMOVE)
		       && (msg.wParam == VK_LEFT || msg.wParam == VK_RIGHT))
		{
			// remove the message and increment tab as necessary
			::PeekMessage(&msg, GetSafeHwnd(), WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE);
			nTab += (msg.wParam == VK_RIGHT ? 1 : -1);
		}

		// make sure new tab is in legal range
		while (nTab < 0)
			nTab += max(m_tabs.GetSize(), 1);
		
		if (m_tabs.GetSize() > 0)
			nTab %= m_tabs.GetSize();
		else
			nTab = -1; // no valid tabs

		SelectTab(nTab, FALSE);
	}
}

void CTabbedDialog::EndDialog(int nEndID)
{
	if (m_nTabCur != -1)
	{
		CString strCaption = m_tabRow.GetTabString(m_nTabCur);
		m_DialogMap.RememberTab((WORD)nCaptionID, strCaption);
	}

	m_nID = nEndID;
	m_pParentWnd->EnableWindow(TRUE);
	SetWindowPos(NULL, 0, 0, 0, 0,
  		SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOMOVE |
  		SWP_NOSIZE | SWP_NOZORDER);

	// Destroy all the tabs. We do it here, so that the toolbar
	// customiz dialog can reenable the MDIClient before we reset the
	// active window.
	int nTabs = m_tabs.GetSize();
	for (int i = 0; i < nTabs; i++)
	{
		delete m_tabs[i];	// We have delete responsibility.
		m_tabs[i] = NULL;
	}

	m_pParentWnd->SetActiveWindow();	// SetFocus messes up dock workers.
	DestroyWindow();
}

void CTabbedDialog::OnOK()
{
	if (m_nTabCur != -1)
	{
		CDlgTab* pTab = GetTab(m_nTabCur);
		if (!pTab->ValidateTab())
		{
			TRACE("Tab %s refused deactivation!\n", 
				(const char*)GetTab(m_nTabCur)->m_strCaption);
			return;
		}

		pTab->Deactivate(this);
	}

	// At this point, all tabs must be valid.  We commit all changes.
	for (int nTab = 0 ; nTab < m_tabs.GetSize() ; nTab++)
		if (GetTab(nTab)->GetSafeHwnd() != NULL)
			GetTab(nTab)->CommitTab();

	EndDialog(IDOK);
}

void CTabbedDialog::OnCancel()
{
	if (m_commitModel == commitOnTheFly)
	{
		// commit-on-the-fly means no cancel capability, so we do OnOK instead
		OnOK();
		return;
	}

	if (m_nTabCur != -1)
	{
		CDlgTab* pTab = GetTab(m_nTabCur);
		pTab->Deactivate(this);
	}

	// Cancel changes on all tabs.
	for (int nTab = 0 ; nTab < m_tabs.GetSize() ; nTab++)
		if (GetTab(nTab)->GetSafeHwnd() != NULL)
			GetTab(nTab)->CancelTab();

	EndDialog(IDCANCEL);
}

void CTabbedDialog::OnHelp()
{
	// If there is a current popup, give it the first chance to handle
	// this help request.
	CWnd* pWnd = GetTopLevelParent();
	HWND hWnd = ::GetLastActivePopup(pWnd->GetSafeHwnd());

	if (::SendMessage(hWnd, WM_COMMANDHELP, 0, 0))
		return;

	// Otherwise, let the current DlgTab process the help request.
	if (m_nTabCur != -1)
		GetTab(m_nTabCur)->OnCommandHelp(0, 0);
}

void CTabbedDialog::OnClose()
{
	// just like cancel
	OnCancel();
}

void CTabbedDialog::OnSize(UINT nType, int cx, int cy)
{
	// We adjust the size a bit in here, so we must block recursion
	static BOOL bInHere;
	if (bInHere)
		return;

	CRect subject; // "page" dialog size
	CRect margins;  // "margin" sizes
	GetTabSize(subject);
	GetMargins(margins);

	CClientDC dc(this);
	int nTabHeight = m_tabRow.DesiredHeight(&dc);
	int nWidth = subject.Width() + margins.left + margins.right + 3;
	int nHeight = subject.Height() + margins.top + margins.bottom + nTabHeight + 3;

	// calculate our required width and height to accom. this tab size
	CRect rectClient(0, 0, nWidth, nHeight);
	CRect dialog = rectClient;
	AdjustWindowRectEx(dialog, GetStyle(), FALSE, GetExStyle());

	bInHere = TRUE;
	SetWindowPos(NULL, 0, 0, dialog.Width(), dialog.Height(), 
		SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	bInHere = FALSE;

	BOOL bCenter=TRUE;

	// center the tabbed dialog in the main window
	if(m_position!=POS_APPCENTER)
	{
		// try to avoid covering bars
		int cyMax= ::GetSystemMetrics(SM_CYMAXIMIZED) ;
		int cxMax= ::GetSystemMetrics(SM_CXMAXIMIZED) ;

		if(cyMax<=600)
		{
			// small screen (800x600 or less) => put dialog at bottom of screen
			CWnd *pWndApp=AfxGetApp()->m_pMainWnd;
			if(pWndApp->IsZoomed())
			{
				SetWindowPos(NULL, (cxMax-dialog.Width())/2, cyMax-dialog.Height(), dialog.Width(), dialog.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
				bCenter=FALSE;
			}
		}
	}

	if(bCenter)
	{
	    CenterWindow(AfxGetApp()->m_pMainWnd);
	}

	// set up the size/position of the tab row
	CPoint pt = GetDlgTabPos();
	m_tabRow.SetPos(CRect(pt.x - 1, pt.y - nTabHeight, pt.x + subject.Width() + 2, pt.y));

	// create our buttons and move them into place
	CreateButtons();

	CSize sizeButtons;
	GetButtonExtent (sizeButtons);

	int nBottomBorder = dialog.bottom - rectClient.bottom;
	MoveButtons(dialog.left + dialog.right - margins.right - sizeButtons.cx,
		dialog.bottom - (margins.bottom + nBottomBorder) / 2);
}

void CTabbedDialog::GetTabSize(CRect & rect)
{
	// *must* have a tab to do the initial sizing!
	CDlgTab * pTab = GetTab(m_nTabCur);
	ASSERT(pTab != (CDlgTab *)NULL);
	pTab->GetWindowRect(rect);
}

void CTabbedDialog::CreateButtons()
{
	// Create the OK, Cancel, and Help buttons (or Close and Help, if the
	// dialog prefers that commit model).
	//
	// This function also creates the buttons if necessary.  While it might
	// seem preferable to create the buttons in CTabbedDialog::Create, that
	// actually doesn't work, since this function will be called in the
	// middle of the tabbed dialog's creation.

	if (m_btnOk.GetSafeHwnd() != NULL)
		return;

	CString str;
	CRect rcEmpty;
	rcEmpty.SetRectEmpty();

	str.LoadString((m_commitModel == commitOnOk) ? IDS_TABDLG_OK : IDS_TABDLG_CLOSE);
	m_btnOk.Create(str, WS_CHILD | WS_TABSTOP | BS_DEFPUSHBUTTON, rcEmpty, this, IDOK);

	str.LoadString(IDS_TABDLG_CANCEL);
	m_btnCancel.Create(str, WS_CHILD | WS_TABSTOP, rcEmpty, this, IDCANCEL);
}

void CTabbedDialog::MoveButtons(int nLeft, int nCenter)
{
	// Position the buttons along the bottom of the dialog
	// centered in the bottom margin.
	int y = nCenter - m_buttonSize.cy / 2;
	int x = nLeft;
	int index = 0;

	CButton* pButton;
	CButton* pButtonPrev = NULL;

	// Cycle through all the buttons, positioning them along the bottom
	for (pButton = GetButtonFromIndex(index) ; pButton != NULL ;
	     pButton = GetButtonFromIndex(++index) )
	{
		pButton->SetFont(GetStdFont(font_Normal));

		pButton->SetWindowPos(pButtonPrev == NULL ? &wndBottom : pButtonPrev,
		                      x, y, m_buttonSize.cx, m_buttonSize.cy, SWP_NOACTIVATE);
		pButton->ShowWindow(SW_SHOW);

		x += m_buttonSize.cx + m_cxBetweenButtons;
		pButtonPrev = pButton;
	}
}

//
// Note that this changes which button _ought_ to be the default.
// If a button other than m_iDefBtnIndex happens to temporarily be
// the default (i.e. SetFocusToControl changed it), this may or may
// not change the button that is _actually_ the default.  We assume in
// this case that we are being called in the middle of SFTC(), which will
// fix things up.
void CTabbedDialog::SetDefButtonIndex(int index)
{
	CButton* pbtnDef;
	
	if (m_iDefBtnIndex != -1)
	{
		pbtnDef = GetButtonFromIndex(m_iDefBtnIndex);
		ASSERT(pbtnDef != (CWnd *)NULL);

		// remove the default style bit
		WPARAM wStyle = ::GetWindowLong(pbtnDef->GetSafeHwnd(), GWL_STYLE);
		if (wStyle & BS_DEFPUSHBUTTON)
			pbtnDef->SendMessage(BM_SETSTYLE, wStyle & ~BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));
	}

	if (index != -1)
	{
		pbtnDef = GetButtonFromIndex(index);
		ASSERT(pbtnDef != (CWnd *)NULL);

		// add the default style bit
		WPARAM wStyle = ::GetWindowLong(pbtnDef->GetSafeHwnd(), GWL_STYLE);
		if (!(wStyle & BS_DEFPUSHBUTTON))
			pbtnDef->SendMessage(BM_SETSTYLE, wStyle | BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));
	}
	
	// remember this
	m_iDefBtnIndex = index;
}

BOOL CTabbedDialog::IsButton(HWND hWnd)
{
	int i = 0;
	CButton* pButton;

	while ((pButton = GetButtonFromIndex(i++)) != NULL)
		if (pButton->GetSafeHwnd() == hWnd)
			return TRUE;

	return FALSE;
}

CButton* CTabbedDialog::GetButtonFromIndex(int index)
{
	// Default is either OK/Cancel/Help or Close/Help, depending on
	// commit model.  Derived classes may override this, of course.
	if (m_commitModel != commitOnOk && (index > 0))
		index++;

	switch (index)
	{
		case 0:
			return &m_btnOk;

		case 1:
			return &m_btnCancel;

		default:
			return NULL;
	}
}

BOOL CTabbedDialog::ActivateTab(int nTab, BOOL bGoToControl)
{
	CDlgTab *pTab;

	// activating no tab (or a tab that doesn't exist) is a no-op
	if (nTab == -1 || (pTab = GetTab(nTab)) == (CDlgTab *)NULL)
		return FALSE;

	if (pTab->Activate(this, GetDlgTabPos()))
	{
		CWnd* pWndNext = NULL;

		if (bGoToControl)
		{
			CObList list;
			CMapWordToOb map;

			BuildTabItemList(list, map);

			CWnd* pWndNext = FindControl(pTab, list, FC_FIRST);

			if (pWndNext != NULL)
			{
				SetFocusToControl(pWndNext, &list);
				return TRUE;
			}
		}

		SetFocusToControl(this);
		return TRUE;
	}

	return FALSE;
}

CPoint CTabbedDialog::GetDlgTabPos()
{
	CRect margins;
	GetMargins(margins);

	int nTabHeight;
	CRect rect = m_tabRow.GetRect();
	if (rect.IsRectEmpty())
	{
		CClientDC dc(this);
		nTabHeight = m_tabRow.DesiredHeight(&dc);
	}
	else
	{
		nTabHeight = rect.Height();
	}

	return CPoint(margins.left + 1, margins.top + 1 + nTabHeight);
}

void CTabbedDialog::OnParentNotify(UINT message, LPARAM lParam) 
{
	CWnd::OnParentNotify(message, lParam);

	// We have to move the focus and default button state to the
	// proper button whenever focus changes in the dialog.
	if (message == WM_LBUTTONDOWN)
	{
		CPoint pt = CPoint(LOWORD(lParam), HIWORD(lParam));
		ClientToScreen(&pt);
		CWnd* pControl = WindowFromPoint(pt);
		if (pControl != NULL)
			SetFocusToControl(pControl, NULL, FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\textpat.cpp ===
// textpat.cpp
//
// Created June 13, 1996 by paulde - Paul Chase Dempsey
//
// Text pattern recognition routines
//

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////
// Find regular expression
//
BOOL FREMatch( LPCTSTR sz, LPCTSTR szPat, ULONG & ibStart, ULONG & ibEnd )
{
    struct patType * ppat = RECompile((LPSTR)szPat, FALSE, reUnix);
    ASSERT(ppat);
    ibStart = ibEnd = 0;
    BOOL bLineMatch = FALSE;
    BOOL fFound = FALSE;

    fFound = RESearch(sz, &ibStart, &ibEnd, ppat, szPat, &bLineMatch);
    free(ppat);
    return fFound;
}


//////////////////////////////////////////////////////////////////////////

struct cbsz {
	int _cb;
	LPTSTR _sz;
	bool Match(LPCTSTR sz, int cb)
	{
		return (0 == _tcsnicmp(sz, _sz, _cb));
	}
};


// FUTURE: use registry, so protocol list can be customized/expanded
// INVESTIGATE: 
// Maybe there's a way to ask the system for a list of protocols
// It appears you could enumerate the keys in HKEY_CLASSES_ROOT 
// and collect the names of all keys with "URL Protocol" values.
//
// Another approach is to parse a candidate protocol, then query the registry
// for the existence of an "HKCR/<protocol>/URL Protocol" value.
//
// I found most of these in 
//   http://www.acl.lanl.gov/URI/archive/uri-94q3.messages/150.html
// which gives BNF for the content part of an URL.
//

cbsz rgzProtocols[] =
{
	// sorted in ascending order of length
	{ 3, _T("mk:")       }, // MoniKer

	{ 4, _T("ftp:")      }, // File Transfer Protocol
	{ 4, _T("mid:")      }, // Message ID (mail)
	{ 4, _T("cid:")      }, // Content ID (for MIME mail parts)
	{ 4, _T("afs:")      }, // Andrew File System

	{ 5, _T("file:")     },
	{ 5, _T("http:")     }, // HyperText Transfer Protocol
	{ 5, _T("nntp:")     }, // Network News Transfer Protocol
	{ 5, _T("news:")     }, // News
	{ 5, _T("wais:")     }, // Wide Area Information Search

	{ 6, _T("shell:")    }, // e.g. shell:desktop invokes the desktop docobject
	{ 6, _T("https:")    }, // HTTP Secure
	{ 6, _T("shttp:")    }, // Secure HTTP

	{ 7, _T("mailto:")   },
	{ 7, _T("gopher:")   },
	{ 7, _T("telnet:")   },
	{ 7, _T("tn3270:")   }, // This appears in the registry w/ IE 3 installed - terminal emulation session

	{ 8, _T("outlook:")  }, // Outlook (REN) -- Office's PIM/lightweight mail client

	{ 9, _T("prospero:") },

	{ 0, 0 }
};

// index of range by length
int rgiProtocols[] =
{
//	 1	 2	 3	 4	 5	 6	 7	 8	 9
	-1, -1,  0,  1,  5, 10, 13, 17, 18
};

#define CEL(rg) (sizeof rg/sizeof rg[0])

cbsz* IsProtocol(LPCTSTR rgb, int cb)
{
	if (cb < rgzProtocols[0]._cb ||
		cb > rgzProtocols[CEL(rgzProtocols) - 2]._cb)
		return NULL;

	int i = rgiProtocols[cb-1];
	if (i < 0)
		return NULL;
	for (; cb == rgzProtocols[i]._cb; i++)
	{
		if (rgzProtocols[i].Match(rgb, cb))
			return &rgzProtocols[i];
	}
	return NULL;
}

#ifdef _DEBUG
bool IsValidProtocolTable()
{
	bool bValid = true;
	// check rgzProtocols
	int cbLast = 0;
	int cbThis;
	for (int i = 0; cbThis = rgzProtocols[i]._cb; i++)
	{
		if (cbThis != cbLast)
		{
			if (rgiProtocols[cbThis-1] != i)
			{
				TRACE("IsValidProtocolTable: invalid index [%i]\n", cbThis-1);
				bValid = false;
			}
		}
		cbLast = cbThis;
		int cbActual = _tcsnbcnt(rgzProtocols[i]._sz, INT_MAX);
		if (cbThis != cbActual)
		{
			TRACE("IsValidProtocolTable: invalid entry [%i] <_cb %i, _sz '%s'> actual: %i\n",
				i, cbThis, rgzProtocols[i]._sz, cbActual );
			bValid = false;
		}
		if ((0 != rgzProtocols[i+1]._cb) && (cbThis > rgzProtocols[i+1]._cb))
		{
			TRACE("IsValidProtocolTable: entry [%i] out of order\n", i);
			bValid = false;
		}
	}
	return bValid;
}
#endif

//////////////////////////////////////////////////////////////////////////

BOOL FFindURL(LPCTSTR sz, ULONG ibAt, ULONG & ibStart, ULONG & ibEndProtocol, ULONG & ibEnd)
{
	ASSERT(IsValidProtocolTable());
	if (!*sz) // empty line
		return FALSE;
	ASSERT(ibStart <= _tcsnbcnt(sz, INT_MAX));
	ASSERT(ibAt == NO_HITTEST || ibAt < _tcsnbcnt(sz, INT_MAX));

    LPCTSTR szOpen  = _T("\"'<([{");
	LPCTSTR szClose = _T("\"'>)]}");
	_TCHAR chClose;

	LPCTSTR pchHit = (ibAt == NO_HITTEST) ? NULL : sz + ibAt;
	LPCTSTR pchStart;
	LPCTSTR pchScan;
	LPCTSTR pchColon;

	pchStart = sz + ibStart;

	for (;*pchStart;)
	{
		// starting past hit?
		if (pchHit && pchHit < pchStart)
			return FALSE;

		// find protocol part of URL
		for (;;)
		{
			chClose = 0;

			// Urls must contain a colon
			if (NULL == (pchColon = _tcschr(pchStart, _T(':'))))
				return FALSE;

			// ASSUME: smallest protocol name is 2 bytes
			if (pchColon - pchStart < 2)
				return FALSE;

			// Find possible start of protocol.
			// Scan left from colon for first nonprotocol char
			// According to the RFC, protocols never include multibyte 
			// chars, so it's safe to decrement by one.
			for (pchScan = pchColon -1; pchScan >= pchStart; pchScan--)
			{
				// valid protocol chars: a-z + - .
				if (!(_istalnum(*pchScan) || *pchScan == _T('-') || *pchScan == _T('.') || *pchScan == _T('+')))
				{
					// If the delimiting char is in our open quote set,
					//   set the matching close character.
					LPCTSTR pchOpen;
					if ((NULL != (pchOpen = _tcschr(szOpen, *pchScan))) &&
						(pchScan == pchStart || !_ismbblead(*(pchStart-1)))
						)
						chClose = szClose[pchOpen - szOpen];
					break;
				}
			}
			pchScan++; // beginning of protocol
			if (IsProtocol(pchScan, pchColon - pchScan + sizeof _T(':')))
				break; // found protocol!

			// look for next colon
			pchStart = pchColon+1;
		}

		// check if we're past the hit
		if (pchHit && (pchHit < pchScan))
			return FALSE;

		// set start of URL
		pchStart = pchScan;
		if (chClose)
			pchStart--; // include quote char in scanned string

		// scan remaining portion from the colon
		pchScan = pchColon + 1;
		if (chClose) // we're quoted
		{
			// just look for the closing char
			pchScan = _tcschr(pchScan, chClose);
			if (pchScan == NULL)
			{
				// didn't find a close quote -- try for an unquoted URL
				// reset scan pointer
				pchScan = pchColon + 1;
				// fall through to unquoted scan below
			}
			else
			{
				// found an URL!
				if ((NULL == pchHit) || (pchStart <= pchHit && pchHit <= pchScan))
				{
					// return extents of unquoted part
					ibStart = pchStart - sz + 1;
					ibEnd = pchScan - sz;
					ibEndProtocol = pchColon - sz + 1;
					return TRUE;
				}
				else
				{
					// keep looking
					pchStart = pchColon + 1;
					continue;
				}
			}
		}

		// not quoted. scan a token delimited by whitespace
		while (*pchScan && !_istspace(*pchScan))
			pchScan++;

		pchScan--;
		
		// trim trailing punctuation (interior punctuation ok)
		while (pchScan > pchColon && _istpunct(*pchScan))
		{
			pchScan = _tcsdec(pchColon, pchScan);
		}
		pchScan = _tcsinc(pchScan);

		// need at least one char past colon for a valid URL
		if (!(pchScan > pchColon + 1))
		{
			pchStart = pchColon + 1;
			continue;
		}

		// hittest if necessary
		if ((NULL == pchHit) || (pchStart <= pchHit && pchHit <= pchScan))
		{
			ibStart = pchStart - sz;
			ibEnd = pchScan - sz;
			ibEndProtocol = pchColon - sz + 1;
			return TRUE;
		}

		// not found -- restart scan at one char past the colon
		pchStart = pchColon + 1;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tbeditcb.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	TBEDITCB.CPP
//		Contains implementation for a generic editable combo on a bar
//

#include "stdafx.h"
#include "shlbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

HWND CreateToolbarEditCombo(CToolbarEditCombo *pCombo, DWORD dwStyle, RECT* lpRect, HWND hwndParent, UINT nID)
{
	if (!pCombo->Create(dwStyle, *lpRect, CWnd::FromHandle(hwndParent), nID))
	{
		TRACE0("Failed to create toolbar combo.\n");

		return NULL;
	}
	
	pCombo->SetExtendedUI();
	return pCombo->m_hWnd;
}

///////////////////////////////////////////////////////////////////////////////
//	CToolbarEditComboEdit
//

IMPLEMENT_DYNAMIC(CToolbarEditComboEdit, CWnd)

WNDPROC* CToolbarEditComboEdit::GetSuperWndProcAddr()
{
	static WNDPROC NEAR pfnSuper;
	return &pfnSuper;
}

//	CToolbarEditComboEdit::WindowProc
//		Call DkPreHandleMessage, and disable SetCursor if we are in customize
//		mode.

LRESULT CToolbarEditComboEdit::WindowProc(UINT message, WPARAM wParam,	LPARAM lParam)
{
	LONG lResult;

	if (DkPreHandleMessage(GetSafeHwnd(),
		message, wParam, lParam, &lResult))
		return lResult;

	CToolbarEditCombo* pParent = (CToolbarEditCombo*) GetParent();
	ASSERT(pParent != NULL);

	switch (message)
	{
	case WM_SETFOCUS:
		pParent->OnEditSetFocus();
		break;

	case WM_KILLFOCUS:
		pParent->OnEditKillFocus();
		break;

	case WM_HELP:	// forward these to the Find Combo
		return pParent->OnEditHelp();
	}

	return CWnd::WindowProc(message, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
//	CToolbarEditCombo
//

IMPLEMENT_DYNAMIC(CToolbarEditCombo, CComboBox) // not the direct base class, but the next one with rtti.

CToolbarEditCombo::CToolbarEditCombo()
{
}

CToolbarEditCombo::~CToolbarEditCombo()
{
}

BOOL CToolbarEditCombo::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	if (!CToolbarCombo::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	m_nId = nID;
	SetFont(GetStdFont(1));
	UpdateView();

	return TRUE;
}

CWnd* CToolbarEditCombo::SubclassEdit()
{
	// HACK: We have used this way of finding Edit control since
	// v2.0, and it still works on Win95.  This is not likely to
	// change.

	CWnd* pWnd = GetDlgItem(1001);
	if (pWnd != NULL)
	{
		m_pChildEdit = new CToolbarEditComboEdit;
		m_pChildEdit->SubclassWindow(pWnd->GetSafeHwnd());
		return m_pChildEdit;
	}

	return NULL;
}

void CToolbarEditCombo::PostNcDestroy()
{
	delete m_pChildEdit;
	delete this;
}

BOOL CToolbarEditCombo::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN)
		return FALSE;
	
	switch (pMsg->wParam)
	{
	default:
		return FALSE;

	case 'Z':
	case 'X':
	case 'C':
	case 'V':
		if (GetKeyState(VK_CONTROL) >= 0 || GetKeyState(VK_SHIFT) < 0 || GetKeyState(VK_MENU) < 0)
			return FALSE;
		break;
		
	case VK_DELETE:
		if (GetKeyState(VK_CONTROL) < 0 || GetKeyState(VK_MENU) < 0)
			return FALSE;
		break;
		
	case VK_INSERT:
		if (GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_SHIFT) >= 0)
			return FALSE;
		break;
		
	case VK_BACK:
	case VK_UP:
	case VK_DOWN:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
		break;

	case VK_ESCAPE:				
		// revert the contents of the find item to what it used to be
		UpdateView();
		break;	// let DkPreHandleMessage set focus.

	}
	
	TranslateMessage(pMsg);
	DispatchMessage(pMsg);
	return TRUE;
}

BEGIN_MESSAGE_MAP(CToolbarEditCombo, CToolbarCombo)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tap.h ===
// tag.h : header file
//

#ifndef __TAP_H__
#define __TAP_H__

/////////////////////////////////////////////////////////////////////////////
// CTap control

class CTap : public CWnd
{
// Construction
public:
	CTap();

// Data members
protected:
	ACCEL m_accel;	// accelerator gleaned from the tap
	ACCEL m_chord;	// second accelerator to make chord - only key is used
	BYTE m_fState;	// state of shift keys, because m_accel can lose track

// Attributes
public:
	ACCEL GetAccel() const;
	ACCEL GetChord() const;

	BOOL IsKeySet() const;
	BOOL IsChordSet() const;
	BOOL IsShift() const;
	BOOL IsControl() const;
	BOOL IsAlt() const;
	BOOL IsBase() const;
	BOOL IsVirtKey() const;
	BOOL IsVirtKeyC() const;

	BOOL IsAccelLegal() const;
	BOOL IsChordLegal() const;

// Operations
public:
	void ResetAll();
	void ResetChord();
	void SetAccel(ACCEL& accel);
	void SetChord(ACCEL& chord);
	void InvalidateContent(BOOL bErase = TRUE);

	void SetShift(BOOL bAccel = TRUE);
	void SetControl(BOOL bAccel = TRUE);
	void SetAlt(BOOL bAccel = TRUE);
	void SetVirtKey(BOOL bAccel = TRUE);
	void SetAscii(BOOL bAccel = TRUE);
	void SetAccelState(BOOL bAccel = TRUE);
	void ClearShift(BOOL bAccel = TRUE);
	void ClearControl(BOOL bAccel = TRUE);
	void ClearAlt(BOOL bAccel = TRUE);

	void UpdateStateFlags();

	void NotifyParent(UINT idNotify);

// Implementation
public:
	virtual ~CTap();

	virtual BOOL Create(const char* szName, const RECT& rc, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage( MSG *pMsg );

	// Generated message map functions
protected:
	DECLARE_MESSAGE_MAP()
	//{{AFX_MSG(CTap)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg UINT OnGetDlgCode();
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	//}}AFX_MSG

// Helper functions
public:
	static CString MakeAccelName(ACCEL& accel);
	WORD VkToAscii(UINT nChar, UINT nFlags, ACCEL& accel) const;
	BOOL SuppressKey(UINT nChar) const;

	void SymTab() const;
#if 0
	void SymExit() const;
	void SymOk() const;
#endif

	void DrawFrame( CDC &dc, LPCRECT lprc );
};


inline ACCEL CTap::GetAccel() const
	{	return m_accel;	}
	
inline ACCEL CTap::GetChord() const
	{	return m_chord;	}

inline BOOL CTap::IsKeySet() const
	{	return m_accel.key != 0;	}
	
inline BOOL CTap::IsChordSet() const
	{	return m_chord.key != 0;	}
	
inline BOOL CTap::IsShift() const
	{	return (m_accel.fVirt & FSHIFT) != 0;	}
	
inline BOOL CTap::IsControl() const
	{	return (m_accel.fVirt & FCONTROL) != 0;	}
	
inline BOOL CTap::IsAlt() const
	{	return (m_accel.fVirt & FALT) != 0;	}
	
inline BOOL CTap::IsBase() const
	{	return (m_accel.fVirt & (FCONTROL | FALT | FSHIFT)) == 0;	}
	
inline BOOL CTap::IsVirtKey() const
	{	return (m_accel.fVirt & FVIRTKEY) != 0;	}
	
inline BOOL CTap::IsVirtKeyC() const
	{	return (m_chord.fVirt & FVIRTKEY) != 0;	}

inline void CTap::SetShift(BOOL bAccel)
	{	m_fState |= FSHIFT;		SetAccelState(bAccel);	}
	
inline void CTap::SetControl(BOOL bAccel)
	{	m_fState |= FCONTROL;	SetAccelState(bAccel);	}
	
inline void CTap::SetAlt(BOOL bAccel)
	{	m_fState |= FALT;		SetAccelState(bAccel);	}
	
inline void CTap::SetVirtKey(BOOL bAccel)
	{	m_fState |= FVIRTKEY;	SetAccelState(bAccel);	}
	
inline void CTap::SetAscii(BOOL bAccel)
	{	m_fState &= ~FVIRTKEY;	SetAccelState(bAccel);	}
	
inline void CTap::ClearShift(BOOL bAccel)
	{	m_fState &= ~FSHIFT;	SetAccelState(bAccel);	}
	
inline void CTap::ClearControl(BOOL bAccel)
	{	m_fState &= ~FCONTROL;	SetAccelState(bAccel);	}
	
inline void CTap::ClearAlt(BOOL bAccel)
	{	m_fState &= ~FALT;		SetAccelState(bAccel);	}
	
inline void CTap::SetAccelState(BOOL bAccel)
	{	if(bAccel) m_accel.fVirt = m_fState;	}

	
// TAP control notifications
//
#define TAPN_CHANGE		0

/////////////////////////////////////////////////////////////////////////////

// CString MakeAccelName(ACCEL& accel);		// utility function also used outside of CTap

/////////////////////////////////////////////////////////////////////////////

typedef struct tagVirtKey
{
	WORD key;
	LPTSTR name;
} VirtKey;

LPCTSTR GetNameFromVK(WORD n);
// given a string containing the textual name of the key, this will convert it
// to a key code, and updated offset, which is the portion of the string that
// has been parsed. Returns 0 if there is no appropriate key code
WORD GetKeyCodeFromName(LPCTSTR pszKeyName, int *iOffset);

#endif	// __TAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tipctrl.h ===
// TipCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTipCtrl window

class CTipCtrl : public CWnd
{
// Construction
public:
	CTipCtrl();

// Attributes
public:

// Operations
public:
	void SetTip( const CString & sTip );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTipCtrl)
public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTipCtrl();

protected:
	int m_margin;
	CString m_sDidya;
	CBitmap m_bitmap;
	CString m_sTip;
	CRect m_rectText;
	void CalcTextRect();

protected:
	// Generated message map functions
	//{{AFX_MSG(CTipCtrl)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tipctrl.cpp ===
// TipCtrl.cpp : implementation file
//

#include "stdafx.h"

#include "tipctrl.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTipCtrl

CTipCtrl::CTipCtrl()
: m_rectText(0,0,0,0)
{
	m_margin = MulDiv(3,GetSystemMetrics(SM_CXFRAME),2);
	VERIFY(m_sDidya.LoadString(IDS_DIDYA));
	VERIFY(m_bitmap.LoadBitmap(IDB_TIPOFTHEDAY));
}

CTipCtrl::~CTipCtrl()
{
}

BEGIN_MESSAGE_MAP(CTipCtrl, CWnd)
	//{{AFX_MSG_MAP(CTipCtrl)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTipCtrl message handlers
void CTipCtrl::CalcTextRect()
{
	if (m_rectText.IsRectNull())
	{
		GetClientRect(m_rectText);
		m_rectText.InflateRect(-2*m_margin,-2*m_margin);
		BITMAP bitmap;
		m_bitmap.GetObject(sizeof (BITMAP), &bitmap);
		m_rectText.top += m_margin + 43;
		m_rectText.left += bitmap.bmWidth + 3*m_margin;
	}
}

int CharSet()
{
	switch (theApp.GetCP())
	{
	case OEM_JAPAN:
		return SHIFTJIS_CHARSET;
	case OEM_PRC:
		return GB2312_CHARSET;
	case OEM_TAIWAN:
		return CHINESEBIG5_CHARSET;
	case OEM_KOR_WANGSUNG:
	case OEM_KOR_JOHAB:
		return DEFAULT_CHARSET;
	default:
		return ANSI_CHARSET;
	}
}

LPCTSTR SerifFace()
{
	switch (theApp.GetCP())
	{
	case OEM_JAPAN:
		return _TEXT("lr o"); // MS Proportional (roman?)
	case OEM_PRC:
		return 0;
	case OEM_TAIWAN:
		return 0;
	case OEM_KOR_WANGSUNG:
	case OEM_KOR_JOHAB:
		return 0;
	default:
		return _TEXT("Times New Roman");
	}
}

LPCTSTR SansFace()
{
	switch (theApp.GetCP())
	{
	case OEM_JAPAN:
		return _TEXT("lr oSVbN"); // "MS Proportional Gothic"
	case OEM_PRC:
	case OEM_TAIWAN:
	case OEM_KOR_WANGSUNG:
	case OEM_KOR_JOHAB:
		return 0;
	default:
		return _TEXT("Arial");
	}
}

void CTipCtrl::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	dc.SetBkMode( TRANSPARENT );
	dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	dc.SetBkColor(::GetSysColor(COLOR_WINDOW));
	CBrush brWindow(::GetSysColor(COLOR_WINDOW));
	CRect rectFrame;
	GetClientRect(rectFrame);
	dc.Draw3dRect(&rectFrame, GetSysColor(COLOR_3DSHADOW), GetSysColor(COLOR_3DHIGHLIGHT));
	rectFrame.InflateRect(-1,-1);

	CalcTextRect();
	COLORREF coPanel = ::GetSysColor(COLOR_APPWORKSPACE);
	if (coPanel == ::GetSysColor(COLOR_WINDOW))
		coPanel = ::GetSysColor(COLOR_ACTIVECAPTION);
	if (coPanel == ::GetSysColor(COLOR_WINDOW))
		coPanel = RGB(128,128,255);
	CBrush brPanel(coPanel);
	CBrush * pbrushOld = dc.SelectObject(&brPanel);
	dc.PatBlt( m_rectText.left - m_margin, m_rectText.top - 2*m_margin,
		m_rectText.Width() + 3*m_margin, 1, PATCOPY );

	BITMAP bitmap;
	m_bitmap.GetObject(sizeof (BITMAP), &bitmap);
	{
		CRect r(rectFrame.left, rectFrame.top,
				rectFrame.left + bitmap.bmWidth + 4*m_margin, rectFrame.bottom
			);
		dc.FillRect(r,&brPanel);

		int x = rectFrame.left + 2*m_margin;
		int y = rectFrame.top + 2*m_margin;
		CDC memDC;
		memDC.CreateCompatibleDC(&dc);
		CBitmap* pOldBitmap = memDC.SelectObject(&m_bitmap);
		dc.BitBlt(x, y, bitmap.bmWidth, bitmap.bmHeight, &memDC, 0, 0, SRCCOPY);
		memDC.SelectObject(pOldBitmap);
		dc.ExtFloodFill( x, y, dc.GetPixel(x,y), FLOODFILLSURFACE );
	}

	dc.SelectObject(&brWindow);

	CRect rectDidya(
		rectFrame.left + 5*m_margin + bitmap.bmWidth,
		rectFrame.top  + 3*m_margin,
		rectFrame.left + 5*m_margin + bitmap.bmWidth + 100,
		rectFrame.top  + 4*m_margin + 36
		);

	CFont * pfontOld;
	CFont Font;
	int nFontHeight = MulDiv(14, dc.GetDeviceCaps(LOGPIXELSY), 72);
	Font.CreateFont(-nFontHeight, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
		(BYTE)CharSet(), OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY, VARIABLE_PITCH | FF_ROMAN, SerifFace());
	pfontOld = dc.SelectObject(&Font);

	dc.DrawText( m_sDidya, -1, rectDidya, DT_NOCLIP | DT_NOPREFIX | DT_SINGLELINE );
	dc.SelectObject(pfontOld);

	Font.DeleteObject();
	nFontHeight = MulDiv(10, dc.GetDeviceCaps(LOGPIXELSY), 72);
	Font.CreateFont(-nFontHeight, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
		(BYTE)CharSet(), OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS | TMPF_TRUETYPE, SansFace());
	pfontOld = dc.SelectObject(&Font);

	dc.DrawText( m_sTip, -1, m_rectText, DT_EXPANDTABS | DT_NOPREFIX | DT_WORDBREAK );
	dc.SelectObject(pfontOld);

	dc.SelectObject(pbrushOld);
}

void CTipCtrl::SetTip( const CString & sTip )
{
	m_sTip = sTip;
	CalcTextRect();
	InvalidateRect(m_rectText,TRUE);
}


BOOL CTipCtrl::OnEraseBkgnd(CDC* pDC) 
{
	CBrush brush(::GetSysColor(COLOR_WINDOW));
	CRect r;
	GetClientRect(r);
	pDC->FillRect(r, &brush);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tipdlg.cpp ===
// tipdlg.cpp : implementation file
//

#include "stdafx.h"

#include "shell.h"
#include "resource.h"
#include "tipdlg.h"
#include "totd.h"
#include "tipmgr.h"

#include "shell.hid" // Help IDs for tip control

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
static const char szGeneralKey[] = "General";
static const char szTotD[] = "Tip of the Day";

void CVshellPackage::OnHelpTip()
{
	TipOfTheDay(FALSE);
}

// Tip of the Day
BOOL TipOfTheDay( BOOL fStartup )
{
	if (fStartup)
	{
		// Don't show tip if we're run from automation (invisibly)
		//  or the user doesn't want tips
		if (theApp.m_bRunInvisibly || !GetRegInt(szGeneralKey, szTotD, 1)) 
			return FALSE;
	}
	CTipFileManager TipData;
	if (!TipData.isTipAvailable())
	{
		if (!fStartup)
			::MessageBeep(0);
		return FALSE;
	}
//ShowDlg:
	CTipDlg Tips(TipData);
	Tips.DoModal();
/*
	switch (Tips.DoModal())
	{
	case IDC_TIP_MORE:
		{
			CMoreTipsDlg2 MoreTips;
			MoreTips.DoModal();
		}
		break;

	case IDC_TIP_ADD:
		{
			CAddTipDlg AddTip;
			AddTip.DoModal();
		}
		goto ShowDlg;
		break;

	default:
		break;
	}
*/
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void Draw3dFrame(CDC* pDC, const CRect& rect, BOOL bIn)
{
	CBrush brush;
	COLORREF crShadow, crHighlight;
	crShadow = ::GetSysColor(COLOR_BTNSHADOW);
	crHighlight = ::GetSysColor(COLOR_BTNHIGHLIGHT);
	brush.CreateSolidBrush(bIn ? crShadow : crHighlight);
	CBrush* pOldBrush = pDC->SelectObject(&brush);
	pDC->PatBlt(rect.left-1,  rect.top-1,    rect.Width()+3, 1, PATCOPY);
	pDC->PatBlt(rect.left,    rect.bottom,   rect.Width(),   1, PATCOPY);
	pDC->PatBlt(rect.left-1,  rect.top,      1,  rect.Height()+1, PATCOPY);
	pDC->PatBlt(rect.right,   rect.top+1,    1,  rect.Height(),   PATCOPY);

	pDC->SelectObject(pOldBrush);
	brush.DeleteObject();

	brush.CreateSolidBrush(bIn ? crHighlight : crShadow);
	pOldBrush = pDC->SelectObject(&brush);
	pDC->PatBlt(rect.left,   rect.top,      rect.Width()+1, 1, PATCOPY);
	pDC->PatBlt(rect.left-1, rect.bottom+1, rect.Width()+2, 1, PATCOPY);
	pDC->PatBlt(rect.left,   rect.top,    1,  rect.Height(),   PATCOPY);
	pDC->PatBlt(rect.right+1,rect.top,    1,  rect.Height()+2, PATCOPY);

	pDC->SelectObject(pOldBrush);
}


/////////////////////////////////////////////////////////////////////////////
// CTipDlg dialog


CTipDlg::CTipDlg(CTipManager & ATipManager, CWnd* pParent /*=NULL*/ )
	: C3dDialog(CTipDlg::IDD, pParent), m_Tip(ATipManager)
{
	//{{AFX_DATA_INIT(CTipDlg)
	m_bShowTipsAtStartup = !!GetRegInt(szGeneralKey, szTotD, 1);
	//}}AFX_DATA_INIT
}


void CTipDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTipDlg)
	DDX_Control(pDX, IDC_TIP_NEXT, m_BNext);
	DDX_Check(pDX, IDC_TIP_SHOW, m_bShowTipsAtStartup);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTipDlg, C3dDialog)
	//{{AFX_MSG_MAP(CTipDlg)
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_TIP_NEXT, OnTipNext)
	ON_WM_DESTROY()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTipDlg message handlers

BOOL CTipDlg::OnInitDialog() 
{
	C3dDialog::OnInitDialog();
	int xmargin, ymargin;
//	margin = MulDiv(5,GetSystemMetrics(SM_CXFRAME),2);

	CRect r;
	HWND hwnd;

 	// set m_rectFrame from pos of OK button 
	VERIFY(hwnd = ::GetDlgItem(m_hWnd,IDOK));
	::GetWindowRect(hwnd, r);
	::ScreenToClient(m_hWnd,&r.BottomRight());
	// inset m_rectFrame from dialog
	GetClientRect(&m_rectFrame);
	xmargin = m_rectFrame.right- r.right;
	ymargin = m_rectFrame.bottom - r.bottom;
	m_rectFrame.InflateRect(-xmargin, -ymargin);
	VERIFY(hwnd = ::GetDlgItem(m_hWnd,IDOK));
	::GetWindowRect(hwnd, r);
	::ScreenToClient(m_hWnd,&r.TopLeft());
	m_rectFrame.bottom = r.top - ymargin;

	m_TipCtrl.Create((LPCTSTR)0, (LPCTSTR)0, WS_CHILD | /*WS_BORDER |*/ WS_VISIBLE, 
		m_rectFrame, this, IDC_TIP_CTRL/*1*/ );

	// Set Context Help ID for this control.
	m_TipCtrl.SetWindowContextHelpId(HIDC_TIP_CTRL) ;

	if (m_Tip.Status() == Exhausted)
	{
		m_Tip.Reset();
		m_sTip.LoadString(IDS_LAST_TIP);
	}
	else
		m_Tip.Tip(m_sTip);
	m_TipCtrl.SetTip(m_sTip);
	return TRUE;
}

LRESULT CTipDlg::OnCommandHelp(WPARAM,LPARAM) { return TRUE; }

void CTipDlg::OnPaint() 
{
	CPaintDC dc(this);
/*
	// Draw 3d line above Close (OK) button
	int margin = MulDiv(5,GetSystemMetrics(SM_CXFRAME),2);
	int L, R, Y;

	CRect r;
	HWND hwnd;
	VERIFY(hwnd = ::GetDlgItem(m_hWnd,IDOK));
	::GetWindowRect(hwnd, r);
	::ScreenToClient(m_hWnd,&r.TopLeft());
	::ScreenToClient(m_hWnd,&r.BottomRight());

	L = r.left - margin/2;
	R = r.right + margin/2;
	Y = r.top - margin;

	CBrush brush;
	COLORREF crShadow, crHighlight;
	crShadow = ::GetSysColor(COLOR_BTNSHADOW);
	crHighlight = ::GetSysColor(COLOR_BTNHIGHLIGHT);

	brush.CreateSolidBrush(crHighlight);
	CBrush* pOldBrush = dc.SelectObject(&brush);
	dc.PatBlt(L, Y, R-L, 1, PATCOPY);

	dc.SelectObject(pOldBrush);
	brush.DeleteObject();
	brush.CreateSolidBrush(crShadow);
	dc.SelectObject(&brush);
	dc.PatBlt(L, Y-1, R-L, 1, PATCOPY);

	dc.SelectObject(pOldBrush);
*/
}

void CTipDlg::OnTipNext() 
{
	switch (m_Tip.Next())
	{
	case Ok:
		m_Tip.Tip(m_sTip);
		m_TipCtrl.SetTip(m_sTip);
		break;

	case Exhausted:
		m_Tip.Reset();
		m_sTip.LoadString(IDS_LAST_TIP);
		m_TipCtrl.SetTip(m_sTip);
		break;

	case Invalid:
	default:
		::MessageBeep(0);
	}
}

/*
void CTipDlg::OnTipAdd() 
{
	EndDialog( IDC_TIP_ADD );
}

void CTipDlg::OnTipMore() 
{
	EndDialog( IDC_TIP_MORE );
}
*/

void CTipDlg::OnDestroy() 
{
	WriteRegInt( szGeneralKey, szTotD, m_bShowTipsAtStartup );
	C3dDialog::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tipmgr.cpp ===
// tipmgr.cpp

#include "stdafx.h"
#include "resource.h"
#include "main.h"
#include "totd.h"
#include "tipmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

static const char BASED_CODE szTipStateKey[] = "Help\\Tips";

#define MAX_TIP_LINE 1024
//#define MAX_TIP_FILES 50 // restrict # of tip files

/////////////////////////////////////////////////////////////////////////////
BOOL isTipAvailable()
{
	CTipFileManager TipData;
	return TipData.isTipAvailable();
}

#define KEY_START (_T('{'))
#define KEY_END   (_T('}'))
#define KEY_SEP   (_T(':'))

/////////////////////////////////////////////////////////////////////////////
//  Escape
//  Copy Src to Dst, translating escape sequences and command keys
//
//  Returns: FALSE if a command was found which was not assigned to a key,
//			and TRUE otherwize.
//
//  Beware of aliasing: Src may also be Dst
#pragma optimize( "a", off)
static BOOL Escape( LPTSTR Dst, LPCTSTR Src, UINT cbMax )
{
	BOOL fRet = TRUE;
	ASSERT(Dst!=NULL);
	ASSERT(Src!=NULL);
	UINT cb = 0;
	while (*Src && cb < cbMax)
	{
		if( *Src == _T('\\') )
		{
			++Src;
			switch( *Src )
			{
			//  Octal
			case _T('0'): case _T('1'): case _T('2'): case _T('3'):
			case _T('4'): case _T('5'): case _T('6'): case _T('7'):
				*Dst++ = (_TCHAR)_tcstoul(Src, (LPTSTR*)&Src, 8);
				cb++;
				continue;
			//  Hex
			case _T('x'):
				Src++;
				*Dst++ = (_TCHAR)_tcstoul(Src, (LPTSTR*)&Src, 16);
				cb++;
				continue;
			case _T('a') : *Dst++ = _T('\a'); Src++; continue;
			case _T('b') : *Dst++ = _T('\b'); Src++; continue;
			case _T('f') : *Dst++ = _T('\f'); Src++; continue;
			case _T('n') : *Dst++ = _T('\n'); Src++; continue;
			case _T('r') : *Dst++ = _T('\r'); Src++; continue;
			case _T('t') : *Dst++ = _T('\t'); Src++; continue;
			case _T('v') : *Dst++ = _T('\v'); Src++; continue;
			case _T('\0'): goto EndEscape;
			default:
				//any other character is literal
				goto CopyChar;
				break;
			}
		}
		else if (*Src == KEY_START)
		{
			// {[<id>:][<command>]}
			// <id>		  Command ID #
			// <command>  Command name (case sensitive)
			LPTSTR pch, pchEnd;
			CString strName;

			if ((pch = _tcschr(Src, KEY_END)) == 0)
				goto CopyChar;
			pchEnd = _tcsinc(pch);
			_TCHAR szCmdName[65];
			_tcsncpy(szCmdName, Src+1, pch - (Src+1));
			szCmdName[pch - (Src+1)] = _T('\0');
			
			UINT nId = 0;
			pch = szCmdName;
			if (_istdigit(*pch))
			{
				nId = _tcstoul(pch, &pch, 0);
				if (*pch == KEY_SEP)
					pch = _tcsinc(pch);
			}
			if (nId || theCmdCache.GetCommandID(pch, &nId))
			{
				// Get key string
				CString strKey;
				if (GetCmdKeyStringAll( nId, strKey ))
				{
					cb += strKey.GetLength();
					if (cb >= cbMax) goto EndEscape;
					ASSERT(!strKey.IsEmpty());
					_tcscpy(Dst,strKey);
					Dst = _tcsninc(Dst,_tcslen(strKey));
					Src = pchEnd;
					continue;
				}
				else
				{
					// unassigned
					fRet = FALSE;
					goto EndEscape;
// [fabriced] Turned off if the command is not assigned, the tip will not show up.
#if 0
					if (*pch)
					{
						// use name in syntax, (might be wrong)
CopyName:				// copy command name
						cb += 2*(sizeof KEY_START) + strlen(pch);
						if (cb >= cbMax) goto EndEscape;
						*Dst = KEY_START; Dst = _tcsinc(Dst);
						_tcscpy(Dst,pch); Dst = _tcsninc(Dst,_tcslen(pch));
						*Dst = KEY_END;   Dst = _tcsinc(Dst);
						Src = pchEnd;
						continue;
					}
					else if (nId)
					{
						// id but no command name: look up name
						LPCTSTR pchConst;

						if (theCmdCache.GetCommandString(nId, STRING_COMMAND, &pchConst))
						{
							// should not hold onto return value, so for safety, copy into local cstring bobz
							strName = pchConst;
							pch = (LPTSTR)(LPCTSTR)strName;	// we don't change it, really

							goto CopyName;
						}
					}
#endif //0
				}
			}
		}
CopyChar:
		//copy any other character
		cb += _tclen(Dst);
		if (cb >= cbMax) goto EndEscape;
		_tccpy(Dst,Src);
		Dst = _tcsinc(Dst);
		Src = _tcsinc(Src);
	}
EndEscape:
	*Dst = _T('\0');
	return fRet;

}
#pragma optimize( "", on )


/////////////////////////////////////////////////////////////////////////////
// CTipState
// Handles persistent state for an individual Tip file
//

BOOL CTipState::Read( const CFile & f, BOOL bIsFileOpen )
{
	CFileStatus status;
	if (CFile::GetStatus(f.GetFilePath(), status))
	{
		m_dwCheck = status.m_size;
		if (bIsFileOpen)
			m_dwPos = f.GetPosition();
//		SetStatus(Ok);
		return TRUE;
	}
	else
	{
		SetStatus(Invalid);
		return FALSE;
	}
}

BOOL CTipState::Read( LPCTSTR szName )
{
	ASSERT(szName != 0);
	ASSERT(*szName != 0);
	BOOL bRet = TRUE;
	HGLOBAL hg = NULL;
	hg = GetRegData(szTipStateKey, szName, hg);
	if (hg == NULL)
	{
		SetStatus(Invalid);
		return FALSE;
	}
	LPVOID pData = ::GlobalLock(hg);
	if (pData != NULL && (*((WORD*)pData) == sizeof CTipState))
	{
		memcpy(this, (LPBYTE)pData+sizeof(WORD), sizeof CTipState);
	}
	else
	{
		SetStatus(Invalid);
		bRet = FALSE;
	}
	::GlobalUnlock(hg);
	::GlobalFree(hg);
	return bRet;
}

BOOL CTipState::Write( LPCTSTR szName )
{
	ASSERT(szName != 0);
	ASSERT(*szName != 0);
	HGLOBAL hg = ::GlobalAlloc(GMEM_MOVEABLE, sizeof CTipState + sizeof(WORD));
	if (hg == NULL)
		return FALSE;
	LPVOID pData = ::GlobalLock(hg);
	if (pData == NULL)
		return FALSE;
	*((WORD*)pData) = (WORD)(sizeof CTipState);
	memcpy((LPBYTE)pData+sizeof(WORD), this, sizeof CTipState);
	BOOL bRet = WriteRegData(szTipStateKey, szName, hg);
	::GlobalUnlock(hg);
	::GlobalFree(hg);
	return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// CTipFile

TipStatus CTipFile::Close()
{
	SaveState();
	if (m_bIsFileOpen)
	{
		m_File.Close();
		m_bIsFileOpen = FALSE;
	}
	return Status();
}

TipStatus CTipFile::Init(LPCTSTR szFile)
{
	ASSERT(szFile != NULL);
	ASSERT(*szFile);

	m_File.SetFilePath(szFile);
	m_State.Read(m_File, m_bIsFileOpen);

	_TCHAR szFName[_MAX_FNAME];
	_tsplitpath(szFile, 0, 0, szFName, 0);
	CTipState tsRegState;
	if (tsRegState.Read(szFName) && CheckState(tsRegState, m_State))
	{
		// The state is in the registry and checks ok against the file, so
		//   we use the saved state.
		m_State = tsRegState;
	}
	else
	{
		// The state was not in registry or doesn't match the file, so
		//  we load the file and save the state
		Next();
		if (Status() == Exhausted)
			// no tips found
			m_State.SetStatus(Invalid);
		SaveState();
	}
	return Status();
}


enum LineType { ltUnknown, ltError, ltBlank, ltComment, ltCommand, ltCategory, ltTip };

#define CHAR_TIP_SEP _T(',')
#define CHAR_CMD_SEP _T('=')
#define CHAR_SPACE   _T(' ')
#define CHAR_COMMENT _T(';')
#define CHAR_COMMAND _T('#')
// commands/categories forced to lowercase for case-insensitivity
#define CMD_PRIORITY _TEXT("priority")
//#define PRI_NORMAL _TEXT("normal")

LineType ParseTipFileLine( CString & sLine, CString & sCmd, CString & sText )
{
	LineType lt = ltUnknown;
	sLine.TrimLeft();
	if (sLine.IsEmpty()) return ltBlank;
	if (sLine[0] == CHAR_COMMENT) return ltComment;
	if (sLine[0] == CHAR_COMMAND)
	{
		sLine = sLine.Mid(1);
		lt = ltCommand;
	}
	int scan;
	for (scan = 0; scan < sLine.GetLength(); scan++)
	{
		switch (sLine[scan])
		{
		case CHAR_CMD_SEP:
			if (lt == ltUnknown) lt = ltCategory;
			goto Parsed;
			break;

		case CHAR_TIP_SEP:
			if (lt == ltUnknown) lt = ltTip;
			goto Parsed;
			break;

		case CHAR_SPACE:
			if (lt != ltCommand) return ltError;
			goto Parsed;
			break;

		default:
			if ((_TUCHAR)sLine[scan] < 32) // control char in all sbcs and dbcs sets
			return ltError;
		}
	}
Parsed:

	if (lt == ltUnknown) return ltError;

	sCmd = sLine.Left(scan);
	sCmd.TrimLeft(); sCmd.TrimRight();
	sCmd.MakeLower();

	scan++;
	if (scan < sLine.GetLength())
	{
 		sText = sLine.Mid(scan);
		sText.TrimLeft(); sText.TrimRight();
		_TCHAR t[MAX_TIP_LINE + sizeof(wchar_t)];
		if(Escape(t,sText,MAX_TIP_LINE))
			sText = t;
		else
			lt = ltBlank;
	}
	return lt;
}

void CTipFile::DoCommand( const CString & sCmd, const CString & sArg )
{
	if (sCmd == CMD_PRIORITY)
	{
		Priority_t pri = DefaultPriority;
		if (!sArg.IsEmpty())
		{
			pri = (Priority_t) _ttoi(sArg);
			if (pri == 0)
			{
				if (!_istdigit(sArg[0]))
					// text arg, just set default priority
					pri = DefaultPriority;
			}
			else
			{
				// restrict to range
				pri = __min(MAX_PRIORITY,pri);
				pri = __max(MIN_PRIORITY,pri);
			}
		}
		m_State.m_nPriority = pri;
	}
	else
		ASSERT(0); // unrecognized command
}

TipStatus CTipFile::Next()
{
	if (Status() == Invalid || Status() == Exhausted)
		return Status();

	try {
		if (!m_bIsFileOpen)
		{
			if (m_File.Open(m_File.GetFilePath(), 
					CFile::shareDenyWrite | CFile::modeNoInherit) == 0)
				return m_State.SetStatus(Invalid);
			else
				m_bIsFileOpen = TRUE;
		}

		CString sCmd;
		_TCHAR szLine[MAX_TIP_LINE];
		LineType lt;
		m_File.Seek(m_State.m_dwPos, CFile::begin);
		while (m_File.ReadString(szLine,MAX_TIP_LINE-1) != NULL)
		{
			lt = ParseTipFileLine(CString(szLine), sCmd, m_sTip);
			switch(lt)
			{
			default:
				ASSERT(0);
			case ltError:
				m_State.SetStatus(Invalid);
				Close();
				m_sTip.LoadString(IDS_SORRY_NO_TIP);
				return Invalid;
				break;

			case ltBlank:
			case ltComment:
			case ltCategory:
				break;

			case ltCommand:
				DoCommand( sCmd, m_sTip );
				break;

			case ltTip:
				return m_State.SetStatus(Ok);
				break;
			}
			// save seek position of line we're about to read
			m_State.m_dwPos = m_File.GetPosition();
		}
	}
	catch( CFileException * pExcept )
	{
		pExcept->Delete();
		Close();
		m_sTip.LoadString(IDS_SORRY_NO_TIP);
		return m_State.SetStatus(Invalid);
	}
	m_sTip.LoadString(IDS_SORRY_NO_TIP);
	return m_State.SetStatus(Exhausted);
}


BOOL CTipFile::SaveState()
{
	_TCHAR szFName[_MAX_FNAME];
	_tsplitpath(m_File.GetFilePath(), 0, 0, szFName, 0);
	return m_State.Write(szFName);
}

BOOL CTipFile::isTipAvailable()
{
	switch (Status())
	{
	case Unknown:
		Next();
		if (Status() == Exhausted)
			Next();
		return Status() == Ok;
		break;

	case Invalid:
		return FALSE;
		break;

	case Exhausted:
	case Ok:
		return TRUE;
		break;

	default:
		ASSERT(0);
		return FALSE;
	}
}

TipStatus CTipFile::Tip( CString & sTip )
{
	if (!m_bIsFileOpen)
		Next();
	if (Status() == Ok)
		m_State.m_dwPos = m_File.GetPosition();
	sTip = m_sTip;
	return Status();
}


/////////////////////////////////////////////////////////////////////////////
//  CTipFileQueue

CTipFileQueue::~CTipFileQueue()
{
	if (m_rgptf)
	{
		// requeue first item
		if (m_bDirty) Add(Get());
		for(; m_nLast >= 0; m_nLast--)
		{
			m_rgptf[m_nLast]->SetOrder(m_nLast);
			delete m_rgptf[m_nLast];
		}
	}
	delete [] m_rgptf;
}

BOOL CTipFileQueue::Create( int nSize )
{
	m_rgptf = new CTipFile *[nSize];
	if (m_rgptf == NULL)
		return FALSE;
	m_nMax = nSize;
	for (int nIndex = 0; nIndex < m_nMax; nIndex++)
		m_rgptf[nIndex] = NULL;
	return TRUE;
}

TipStatus CTipFileQueue::Init(CPtrList & lptf)
{
	// asssume the list contains valid CFile *'s

	if (lptf.IsEmpty()) return Invalid;

	if (m_rgptf == NULL)
		if (!Create(lptf.GetCount()))
		{
			// destroy members of list
			while (!lptf.IsEmpty())
				delete lptf.RemoveHead();
			return Invalid;
		}

	while (!lptf.IsEmpty())
	{
		CTipFile* ptf = (CTipFile *)lptf.RemoveHead();
		ptf->Next(); // kickstart it
		AddByOrder(ptf);
	}
	ASSERT(!IsEmpty());
	return Peek()->Status();
}

CTipFile * CTipFileQueue::Get()
{
	if (IsEmpty()) return 0;

	m_bDirty = TRUE;
	CTipFile * ptf = m_rgptf[0];

	if (m_nLast == 1)
		m_rgptf[0] = m_rgptf[1];
	else if (m_nLast > 0)
		memmove( &m_rgptf[0], &m_rgptf[1], (m_nLast)*(sizeof ptf) );

	m_rgptf[m_nLast--] = 0;
	return ptf;
}

// Add by rank
void CTipFileQueue::Add( CTipFile * ptf )
{
	ASSERT(ptf != NULL);
	ASSERT(m_rgptf != NULL);
	ASSERT(m_nLast < m_nMax); // full

	int scan = m_nLast;
	int nRank = ptf->Rank();
	while (scan >= 0 && m_rgptf[scan]->Rank() < nRank)
		scan--;
	// adjust to insert before or after matched item
	if (scan < 0 || m_rgptf[scan]->Rank() >= nRank)
		scan++;
	memmove(&m_rgptf[scan+1], &m_rgptf[scan], (m_nLast-scan + 1)*(sizeof ptf) );
	m_rgptf[scan] = ptf;
	m_nLast++;
}

// Add by order
void CTipFileQueue::AddByOrder( CTipFile * ptf )
{
	ASSERT(ptf != NULL);
	ASSERT(m_rgptf != NULL);
	ASSERT(m_nLast < m_nMax); // full

	int scan = m_nLast;
	int nOrder = ptf->RankOrder();
	while (scan >= 0 && m_rgptf[scan]->RankOrder() < nOrder)
		scan--;
	// adjust to insert before or after matched item
	if (scan < 0 || m_rgptf[scan]->RankOrder() >= nOrder)
		scan++;
	memmove(&m_rgptf[scan+1], &m_rgptf[scan], (m_nLast-scan + 1)*(sizeof ptf) );
	m_rgptf[scan] = ptf;
	m_nLast++;
}

CTipFile * CTipFileQueue::operator[](int nIndex)
{
	if (m_rgptf == NULL || nIndex < 0 || nIndex > m_nLast)
		return 0;
	return m_rgptf[nIndex];
}

/////////////////////////////////////////////////////////////////////////////
// CTipFileManager

TipStatus CTipFileManager::Init()
{
	LPTSTR pchPoke;
	_TCHAR szTipPattern[_MAX_PATH];
	_TCHAR szTipPath[_MAX_PATH];
	// Get the directory of the IDE executable
	{
		_TCHAR szPath[_MAX_PATH];
		_TCHAR szDir[_MAX_DIR];
		GetModuleFileName(NULL, szPath, _MAX_PATH);
		_tsplitpath(szPath, szTipPattern, szDir, NULL, NULL);
		_tcscat(szTipPattern, szDir);
	}
	// Append default extension dir (if any)
	LPCTSTR szExtension = theApp.GetExeString(DefaultExtensionDir);
	if (szExtension != NULL)
	{
		_tcscat( szTipPattern, szExtension );
		pchPoke = _tcschr(szTipPattern, _T('\0'));
		*pchPoke++ = _T('\\');
		*pchPoke   = _T('\0');
	}
	_tcscpy(szTipPath,szTipPattern);
	// find end of path to poke filename into
	pchPoke = _tcschr(szTipPath, _T('\0'));

	// make Tip file find pattern
	_tcscat( szTipPattern, "*.TIP" );

	// Read list of tip files
	CPtrList lptf;
	int nFiles = 0;
	WIN32_FIND_DATA wfd;
	HANDLE hFind = FindFirstFile( szTipPattern, &wfd );
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
				_TCHAR szFName[_MAX_FNAME];
				_TCHAR szExt[_MAX_EXT];
				_tsplitpath(wfd.cFileName, NULL, NULL, szFName, szExt);
				_tcscpy(pchPoke,szFName);
				_tcscat(pchPoke,szExt);
				CTipFile* ptf = new CTipFile(szTipPath);
				if (ptf == NULL)
					break;
				lptf.AddTail(ptf);
				nFiles++;
			}
		} while (/*nFiles < MAX_TIP_FILES &&*/ FindNextFile( hFind, &wfd ));
		FindClose(hFind);
	}
	return m_Status = m_qptf.Init(lptf);
}

CTipFileManager::~CTipFileManager()
{
}

BOOL CTipFileManager::isTipAvailable()
{
	if (m_Status == Unknown)
		Init();
	if (m_Status == Invalid || m_qptf.IsEmpty())
		return FALSE;
	else
		// Only need to peek at first in the queue
		//  because elements with available tips have 
		//  priority over those without.
		return m_qptf.Peek()->isTipAvailable();
}

BOOL CTipFileManager::SaveState()
{
	if (m_qptf.IsEmpty()) return FALSE;

	int scan;
	CTipFile *ptf;
	for (scan = 0; (ptf = m_qptf[scan]) != NULL; scan++)
		ptf->SaveState();

	return TRUE;
}

void CTipFileManager::Reset()
{	
	if (m_qptf.IsEmpty()) return;
	int nSize = m_qptf.Size();
	CTipFile **rgptf = new CTipFile *[nSize];
	if (rgptf == NULL)
	{
		m_Status = Invalid;
		return;
	}
	int pos;
	for (pos = 0; pos < nSize; pos++)
	{
		rgptf[pos] = m_qptf.Get();
		ASSERT(rgptf[pos]!=NULL);
		rgptf[pos]->Reset();
	}
	ASSERT(m_qptf.IsEmpty());
	for (pos = 0; pos < nSize; pos++)
	{
		m_qptf.Add(rgptf[pos]);
	}
	delete [] rgptf;
	m_Status = m_qptf.Peek()->Status();
}

TipStatus CTipFileManager::Next()
{
	if (m_Status != Ok) return m_Status;

	CTipFile * ptf = m_qptf.Get();
	if (ptf == NULL)
		return m_Status = Invalid;
	else
	{
		ptf->Next();
		m_qptf.Add(ptf);
		return m_Status = m_qptf.Peek()->Status();
	}
}

TipStatus CTipFileManager::Tip( CString & sTip )
{
	if (m_Status != Ok || m_qptf.IsEmpty())
	{
		sTip.LoadString( IDS_SORRY_NO_TIP );
		return m_Status;
	}
	else
		return m_Status = m_qptf.Peek(1)->Tip(sTip);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tipmgr.h ===
// TipMgr.h
// Abstract Tip manager class

#ifndef __TIPMGR_H__
#define __TIPMGR_H__

enum TipStatus
{
	Unknown   = -3, // unknown state
	Invalid   = -2, // tip data is invalid/corrupt
	Exhausted = -1, // all tips have been shown
	Ok = 0 
};

/////////////////////////////////////////////////////////////////////////////
// CTipManager
// pure abstract base class

class CTipManager
{
public:
	virtual BOOL isTipAvailable() = 0;
	virtual BOOL SaveState() = 0;
	virtual TipStatus Status() = 0;
	virtual TipStatus Next() = 0;
	virtual TipStatus Tip( CString & sTip ) = 0;
	virtual void Reset() = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CTipState
// Persistent state for an individual Tip file

typedef signed char PersistTipStatus;
typedef signed char Priority_t;
const Priority_t DefaultPriority = 50;
const Priority_t MAX_PRIORITY = 100;
const Priority_t MIN_PRIORITY = 0;
typedef short Order_t;
const Order_t DEFAULT_ORDER = (Order_t)MIN_PRIORITY-1;
const Order_t ORDER_STATUS_BASE = SHRT_MIN+10; // +10 is room for TipStatus offset

struct CTipState
{
	friend BOOL CheckState(const CTipState & A, const CTipState & B);

	CTipState();
	CTipState( const CFile & f, BOOL bIsFileOpen );
	CTipState( LPCTSTR szName );
	CTipState( const CTipState & ts );

// data
	PersistTipStatus m_Status;
	Priority_t m_nPriority;
	DWORD m_dwCheck;
	DWORD m_dwPos;
	Order_t m_nOrder;

// access
	int Rank() { return m_Status < 0 ? (int)m_Status : (int)m_nPriority; }
	int RankOrder();
	TipStatus Status() { return (TipStatus)m_Status; }

// operations
	TipStatus SetStatus( TipStatus t );
	int SetOrder(int nOrder) { m_nOrder = (Order_t)nOrder; return nOrder; }
	BOOL Read( LPCTSTR szName );
	BOOL Read( const CFile & f, BOOL bIsFileOpen );
	BOOL Write( LPCTSTR szName );
	CTipState & operator=( const CTipState & rhs );
};

inline int CTipState::RankOrder()
{
	if (m_Status < 0)
		return ORDER_STATUS_BASE + (int)m_Status;
	else
	{
		if (m_nOrder == DEFAULT_ORDER)
			return (int)m_nPriority;
		else
			return DEFAULT_ORDER - (int)m_nOrder;
	}
}

inline BOOL CheckState(const CTipState & A, const CTipState & B) { return A.m_dwCheck == B.m_dwCheck; }

inline CTipState::CTipState()
:	m_Status((PersistTipStatus)Unknown), m_nPriority(DefaultPriority),
	m_dwCheck(0), m_dwPos(0), m_nOrder(DEFAULT_ORDER)
{}

inline CTipState::CTipState( const CFile & f, BOOL bIsFileOpen )
:	m_Status((PersistTipStatus)Unknown), m_nPriority(DefaultPriority),
	m_dwCheck(0), m_dwPos(0), m_nOrder(DEFAULT_ORDER)
{
	Read(f,bIsFileOpen);
}

inline CTipState::CTipState( LPCTSTR szName )
:	m_Status((PersistTipStatus)Unknown), m_nPriority(DefaultPriority),
	m_dwCheck(0), m_dwPos(0), m_nOrder(DEFAULT_ORDER)
{
	Read(szName);
}

inline CTipState::CTipState( const CTipState & ts )
{
	memcpy((CTipState*)this, &ts, sizeof CTipState);
}

inline CTipState & CTipState::operator=( const CTipState & ts )
{
	memcpy((CTipState*)this, &ts, sizeof CTipState);
	return *this;
}

inline TipStatus CTipState::SetStatus( TipStatus t )
{
//	if (t==Invalid)
//		m_dwCheck = m_dwPos = 0;
	m_Status = (PersistTipStatus)t;
	return t;
}


/////////////////////////////////////////////////////////////////////////////
// CTipFile

class CTipFile : public CTipManager
{
public:
	~CTipFile() { Close(); }
	CTipFile( LPCTSTR szFile ) : m_bIsFileOpen(FALSE) { Init(szFile); }

// access
	BOOL isTipAvailable();
	int Rank() { return m_State.Rank(); }
	int RankOrder() { return m_State.RankOrder(); }
	int SetOrder(int nOrder) { return m_State.SetOrder(nOrder); }
	TipStatus Status() { return m_State.Status(); }
	Priority_t Priority() { return m_State.m_nPriority; }
	TipStatus Tip( CString & sTip );
	CString GetFilePath() { return m_File.GetFilePath(); }
	CString GetFileName() { return m_File.GetFileName(); }

// operations
	TipStatus Next();
	BOOL SaveState();
	void Reset();
	TipStatus Close();
	TipStatus Init(LPCTSTR szFile);

protected:
	void DoCommand( const CString & sCmd, const CString & sArg );
	CStdioFile m_File;
	BOOL m_bIsFileOpen;
	CString m_sTip;
	CTipState m_State;
};

inline void CTipFile::Reset() { m_State.m_dwPos = 0; m_State.SetStatus(Unknown); Next(); }

/////////////////////////////////////////////////////////////////////////////
// CTipFileQueue

class CTipFileQueue
{
public:
	CTipFileQueue( ) : m_rgptf(0), m_nMax(0), m_nLast(-1), m_bDirty(FALSE) {}
	~CTipFileQueue();

	BOOL Create( int nSize );
	TipStatus Init(CPtrList & lptf);

	int Size() { return m_nMax; }
	BOOL IsEmpty() { return m_nLast < 0; }
	void Add( CTipFile * ptf );
	CTipFile * Get();
	CTipFile * Peek(BOOL bMakeDirty = FALSE);
	CTipFile * operator[](int nIndex);

protected:
	void AddByOrder( CTipFile * ptf );
	CTipFile **m_rgptf;
	int m_nLast;
	int m_nMax;
	BOOL m_bDirty;
};

inline CTipFile * CTipFileQueue::Peek(BOOL bDirty)
{
	ASSERT(m_rgptf != NULL);
	if (bDirty)
		m_bDirty = TRUE;
	return m_rgptf[0];
}

/////////////////////////////////////////////////////////////////////////////
// CTipFileMgr

class CTipFileManager : public CTipManager
{
public:
	CTipFileManager();
	~CTipFileManager();
	TipStatus Status() { return m_Status; }
	isTipAvailable();
	BOOL SaveState();
	TipStatus Next();
	TipStatus Tip( CString & sTip );
	void Reset();
	TipStatus Init();

protected:
	CTipFileQueue m_qptf;
	TipStatus m_Status;
};

inline CTipFileManager::CTipFileManager()
: m_Status(Unknown)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tipdlg.h ===
// TipDlg.h : header file
//

#include "tipmgr.h"
#include "tipctrl.h"
#include "totd.h"

/////////////////////////////////////////////////////////////////////////////
// CTipDlg dialog

class CTipDlg : public C3dDialog
{
// Construction
public:
	CTipDlg( CTipManager & ATipManager, CWnd* pParent = NULL );

// Dialog Data
	//{{AFX_DATA(CTipDlg)
	enum { IDD = IDD_TIPOFTHEDAY };
	CButton	m_BNext;
	BOOL	m_bShowTipsAtStartup;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTipDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CTipManager & m_Tip;
	CTipCtrl m_TipCtrl;
	CRect m_rectFrame;
	int m_margin;
	CString	m_sTip;

	// Generated message map functions
	//{{AFX_MSG(CTipDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg void OnTipNext();
	afx_msg void OnDestroy();
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\toolcust.cpp ===
// toolcust.cpp : implementation of the CCustomizeToolsDialog class
//

#include "stdafx.h"

#include "shell.h"
#include "toolcust.h"
#include "toolexpt.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);

/////////////////////////////////////////////////////////////////////////////
// CToolsGrid

CToolsGrid::CToolsGrid() : CStringListGridWnd(GRIDLIST_NONEWSELONADD)
{
	EnableSort(FALSE);
	EnableAutoSort(FALSE);
	m_pClipboardTool = NULL;
}

CToolsGrid::~CToolsGrid()
{
	if (m_pClipboardTool != NULL)
		delete m_pClipboardTool;
}

BEGIN_MESSAGE_MAP(CToolsGrid, CStringListGridWnd)
	//{{AFX_MSG_MAP(CToolsGrid)
	ON_BN_CLICKED(ID_GRD_NEW, OnGridNew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CToolsGrid::OnGridNew() 
{
	if (GetRowCount() == MAXTOOLIST)
	{
		CString strMsg;
		MsgBox(Error, MsgText(strMsg, IDS_TOOL_MAX_REACHED, MAXTOOLIST));
	}
	else
	{
		CStringListGridWnd::OnGridNew();
	}
}

void CToolsGrid::DoCut()
{
	int nCurSel = m_pDlg->m_ToolGrid.GetCurSel();
	if (m_pDlg->m_ToolList.GetTool(nCurSel) == NULL)
	{
		MessageBeep(0);
		return;
	}
	if (m_pClipboardTool != NULL)
		delete m_pClipboardTool;
	m_pClipboardTool = new CTool;
	*m_pClipboardTool = *(m_pDlg->m_ToolList.GetTool(nCurSel));
	m_pDlg->m_ToolList.DeleteTool(nCurSel);
	m_pDlg->FillGrid(nCurSel);
}

void CToolsGrid::DoCopy()
{
	int nCurSel = m_pDlg->m_ToolGrid.GetCurSel();
	if (m_pDlg->m_ToolList.GetTool(nCurSel) == NULL)
	{
		MessageBeep(0);
		return;
	}
	if (m_pClipboardTool != NULL)
		delete m_pClipboardTool;
	m_pClipboardTool = new CTool;
	*m_pClipboardTool = *(m_pDlg->m_ToolList.GetTool(nCurSel));
	m_pClipboardTool->m_nOutputWindowID = INVALID_OUTPUT_WINDOW;
}

void CToolsGrid::DoPaste()
{
	if(!m_pClipboardTool)
	{
		MessageBeep(0);
		return;
	}

	int nCurSel = m_pDlg->m_ToolGrid.GetCurSel();
	int nTools = m_pDlg->m_ToolList.NumTools();
	if (nCurSel < nTools)
	{
		// replacing an existing tool
		delete m_pDlg->m_ToolList.m_toolArray[nCurSel];
		CTool *pTool = new CTool;
		*pTool = *m_pClipboardTool;
		m_pDlg->m_ToolList.m_toolArray[nCurSel] = pTool;
		m_pDlg->FillGrid(nCurSel);
	}
	else
	{
		// adding a tool to end of list
		CTool *pTool = new CTool;
		*pTool = *m_pClipboardTool;
		m_pDlg->m_ToolList.AddTool(pTool);
		m_pDlg->FillGrid(nCurSel);
	}

	m_pClipboardTool->m_nOutputWindowID = INVALID_OUTPUT_WINDOW;
}

BOOL CToolsGrid::ProcessKeyboard(MSG* pMsg, BOOL bPreTrans /*= FALSE*/)
{
	if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
	{
		switch (pMsg->wParam)
		{
			case 'X':
				// Ctrl+X is cut
				if (m_pActiveElement != NULL)
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));
				if (GetKeyState(VK_CONTROL) >= 0)
					break;
				DoCut();
				return TRUE;

			case 'C':
				// Ctrl+C is copy
				if (m_pActiveElement != NULL)
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));
				if (GetKeyState(VK_CONTROL) >= 0)
					break;
				DoCopy();
				return TRUE;

			case 'V':
				// Ctrl+V is paste
				if (m_pActiveElement != NULL)
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));
				if (GetKeyState(VK_CONTROL) >= 0)
					break;
				DoPaste();
				return TRUE;

			case VK_DELETE:
				// Shift+Delete is cut
				if (m_pActiveElement != NULL)
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));
				if (GetKeyState(VK_SHIFT) >= 0)
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));
				DoCut();
				return TRUE;

			case VK_INSERT:
				// Ctrl+Insert is copy, Shift+Insert is paste
				if (m_pActiveElement != NULL)
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));
				if (GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_SHIFT) >= 0)
					break;
				if (GetKeyState(VK_CONTROL) < 0)
					DoCopy();
				else if (GetKeyState(VK_SHIFT) < 0)
					DoPaste();
				return TRUE;

			case VK_UP:
			case VK_DOWN:
				return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));

			case VK_ESCAPE:
				if (m_pControlWnd == NULL && !m_bDragRow)
				{
					m_pDlg->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
					return TRUE;
				}
				else
					return(CStringListGridWnd::ProcessKeyboard(pMsg, bPreTrans));

			case VK_RETURN:
				// if no active element, return should close dialog
				if (m_pActiveElement == NULL)
					return(CGridWnd::ProcessKeyboard(pMsg, bPreTrans));

				CGridControlWnd::CloseActiveElement();
				return TRUE;

			case VK_TAB:
				// control-tab is dialog tab switching
				if (GetKeyState(VK_CONTROL) < 0)
					break;

				CGridControlWnd::CloseActiveElement();
				CWnd* pParent = GetParent();
				if (pParent != NULL)
				{
					pMsg->hwnd = pParent->m_hWnd;
					return CWnd::PreTranslateMessage(pMsg);
				}
				return TRUE;
		}
	}

	return(CGridControlWnd::ProcessKeyboard(pMsg, bPreTrans));
}

BOOL CToolsGrid::BeginDrag(UINT nFlags, const CPoint& point)
{
	// don't allow dragging of the new row!
	CGridElement* pElement = ElementFromPoint(point);
	CGridRow* pLastRow = GetRowAt(m_rows.GetTailPosition());

	if ((pElement == pLastRow) && (m_pNewRow != NULL))
	{
		m_bDragSelecting = FALSE;
		m_bDragRow = FALSE;
		m_pDropRow = NULL;
		return TRUE;
	}
	else
	{
		return(CGridWnd::BeginDrag(nFlags, point));
	}
}

void CToolsGrid::AddNewRow(BOOL bSelect /*= TRUE*/)
{
	if (GetRowCount() == MAXTOOLIST)
		m_pNewRow = NULL;
	else
		CStringListGridWnd::AddNewRow(bSelect);
}

void CToolsGrid::DoMove(int nToIndex)
{
	// virtually the same as CStringListGridWnd::DoMove(), but handling 
	// of reinsertion of moved rows differs when the new row is NULL.
	ASSERT(!IsFlag(GRIDLIST_NOORDER));

	if ((nToIndex > GetCount()) || ((nToIndex == GetCount()) && (m_pNewRow != NULL)))
		return;

	if (nToIndex < 0)
		return;

	ASSERT(m_selection.GetCount() == 1);

	// Notify the grid owner of these moves
	SORTABLEROW* pSelRows;
	pSelRows = new SORTABLEROW[m_selection.GetCount()];
	int cMove = 0;

	POSITION posSel = GetHeadSelPosition();
	int nDest = nToIndex;
	while (posSel != NULL)
	{
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posSel);
		if (pSelRow->IsNewRow())
		{
			delete [] pSelRows;
			return;
		}
		else
		{
			int nSrc = GetRowIndex(pSelRow);

			if (!OnMove(nSrc, nDest++))
			{
				Deselect(pSelRow);
				nDest--;
			}
			else
			{
				pSelRows[cMove].m_pRow = pSelRow;
				pSelRows[cMove++].m_nRow = nSrc;
			}
		}
	}

	// Remove the select rows
	posSel = GetHeadSelPosition();
	while (posSel != NULL)
	{
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posSel);

		// Remove the row from the grid
		POSITION pos = m_rows.Find(pSelRow);
		ASSERT(pos != NULL);

		// Update m_posTopVisibleRow if needed
		if (m_posTopVisibleRow == pos)
		{
			GetPrevRow(m_posTopVisibleRow);
			if (m_posTopVisibleRow != NULL && (GetRowAt(m_posTopVisibleRow) == GetCaptionRow()))
			{
				m_posTopVisibleRow = NULL;
				m_cyScroll = 0;
			}
		}
		m_rows.RemoveAt(pos);
	}

	// Sort the row list
	qsort(pSelRows, cMove, sizeof(SORTABLEROW), CompareRowIDs);

	// Now move each row from our temp list into the grid's list of rows
	POSITION posTarget = NULL;
	for (int iCur = 0; iCur < cMove; iCur++)
	{
		// Where should we insert the row?
		if (posTarget == NULL)
		{
			if (nToIndex >= GetCount())
			{
				if (m_pNewRow != NULL)
					posTarget = m_rows.InsertBefore(m_rows.Find(m_pNewRow), pSelRows[iCur].m_pRow);
				else
					posTarget = m_rows.InsertAfter(m_rows.FindIndex(nToIndex), pSelRows[iCur].m_pRow);
			}
			else if (nToIndex <= 0)
			{
				posTarget = m_rows.InsertAfter(m_rows.GetHeadPosition(), pSelRows[iCur].m_pRow);
			}
			else
			{
				posTarget = m_rows.InsertAfter(m_rows.FindIndex(nToIndex), pSelRows[iCur].m_pRow);
			}
		}
		else
		{
			posTarget = m_rows.InsertAfter(posTarget, pSelRows[iCur].m_pRow);
		}
	}
	delete [] pSelRows;

	AdjustTopVisible();
	ResetSize(); // INEFFICIENT
	Invalidate(FALSE); // INEFFICIENT
	ResetScrollBars();

	// Make sure the primary selection is still visible
	if (!m_selection.IsEmpty())
	{
		CGridElement* pSelElement = (CGridElement*)m_selection.GetHead();
		if (pSelElement != NULL)
		{
			CGridRow* pRow = pSelElement->GetRow();
			ASSERT(pRow != NULL);

			ScrollIntoView(pRow);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCustomizeToolsDialog

IMPLEMENT_DYNAMIC(CCustomizeToolsDialog, CDlgTab);

CCustomizeToolsDialog::CCustomizeToolsDialog() : CDlgTab(IDDP_CUSTOMIZE_TOOLSMENU, IDS_TOOLS)
{
	m_bOutputWindowAvailable = FALSE;
 	m_ToolList = toolList;
	m_nDeletedOutputWindows = 0;
}

BOOL CCustomizeToolsDialog::OnInitDialog()
{
	CEdit *pEdit = (CEdit *)GetDlgItem(IDC_TM_COMMAND);
	pEdit->LimitText(MAXPATHNAME);
	pEdit = (CEdit *)GetDlgItem(IDC_TM_INITDIR);
	pEdit->LimitText(MAXINITDIR);
	pEdit = (CEdit *) GetDlgItem(IDC_TM_ARGUMENTS);
	pEdit->LimitText(MAXARGUMENT);

	// FUTURE: temporary workaround [patbr]
	// if SRC package not available, disable the 'redirect to output window'
	// checkbox, because the output window still lives in the SRC package.
	if (theApp.GetPackage(PACKAGE_VCPP))
		m_bOutputWindowAvailable = TRUE;

	// create the tools grid.
	VERIFY(m_ToolGrid.ReplaceControl(this, IDC_TM_PLACEHOLDER, IDC_TM_TOOLSGRID,
		WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP, WS_EX_CLIENTEDGE, GRIDWND_TB_ALL));
	m_ToolGrid.m_pDlg = this;
	FillGrid();
	m_ToolGrid.SetFocus();

	m_mbtnArgMacros.SubclassDlgItem(IDC_TM_ARGMACROS, this);
	m_mbtnDirMacros.SubclassDlgItem(IDC_TM_DIRMACROS, this);
	VERIFY(m_mbtnArgMacros.LoadMenu(IDR_TOOL_MACRO));
	VERIFY(m_mbtnDirMacros.LoadMenu(IDR_TOOL_MACRO));
	m_mbtnDirMacros.SetPos(1); // Use second menu for dirs
	return TRUE;
}

void CCustomizeToolsDialog::FillGrid(int nSelectRow)
{
	m_ToolGrid.ResetContent();

	for (int i = 0; i < m_ToolList.NumTools(); i++)
	{
		CTool *pTool = m_ToolList.GetTool(i);
		ASSERT(pTool != NULL);
		m_ToolGrid.AddString((const TCHAR *)pTool->m_strMenuName);

		if (m_ToolGrid.GetCount() == MAXTOOLIST)
		{
			POSITION pos = m_ToolGrid.m_rows.Find(m_ToolGrid.m_pNewRow);
			if (pos != NULL)
			{
				delete m_ToolGrid.m_pNewRow;
				m_ToolGrid.m_pNewRow = NULL;
			}
		}
	}

	// set the current selection in the tools list.
	nSelectRow = min(nSelectRow, m_ToolGrid.GetCount());  // OK to select new item.
	m_ToolGrid.SetCurSel(nSelectRow);
	m_ToolList.SetCurTool(nSelectRow);
	ShowToolInfo();

	EnableControls();
}

void CCustomizeToolsDialog::OnMacroItem(UINT nId)
{
	if (IDS_TOOLMACRO_First <= nId && nId <= IDS_TOOLMACRO_Last)
	{
		CString strMacro;
		VERIFY(strMacro.LoadString(nId));
		CEdit *pwnd = (CEdit *)GetDlgItem(IDC_TM_ARGUMENTS);
		pwnd->ReplaceSel(strMacro);
		pwnd->SetFocus();
	}
	else if (IDS_TOOLMACRODIR_First <= nId && nId <= IDS_TOOLMACRODIR_Last)
	{
		CString strMacro;
		int nStrId;
		switch (nId)
		{
			case IDS_TOOLMACRODIR_FileDir:
				nStrId = IDS_TOOLMACRO_FileDir; break;
			case IDS_TOOLMACRODIR_FileName:
				nStrId = IDS_TOOLMACRO_FileName; break;
			case IDS_TOOLMACRODIR_Dir:
				nStrId = IDS_TOOLMACRO_Dir; break;
			case IDS_TOOLMACRODIR_TargetDir:
				nStrId = IDS_TOOLMACRO_TargetDir; break;
			case IDS_TOOLMACRODIR_TargetName:
				nStrId = IDS_TOOLMACRO_TargetName; break;
			case IDS_TOOLMACRODIR_WkspDir:
				nStrId = IDS_TOOLMACRO_WkspDir; break;
			case IDS_TOOLMACRODIR_WkspName:
				nStrId = IDS_TOOLMACRO_WkspName; break;
		}
		VERIFY(strMacro.LoadString(nStrId));
		CEdit *pwnd = (CEdit *)GetDlgItem(IDC_TM_INITDIR);
		pwnd->ReplaceSel(strMacro);
		pwnd->SetFocus();
	}
	else
		ASSERT(0);
}

BOOL CCustomizeToolsDialog::ValidateTab()
{
	int nCurSel = m_ToolGrid.GetCurSel();
	int nTools = m_ToolList.NumTools();
	if ((nCurSel < nTools) && !GetToolInfo())
		return FALSE;

	CVshellPackage *pPackage = (CVshellPackage *)theApp.GetPackage(PACKAGE_SUSHI);
	LPOUTPUTWINDOW pInterface = g_IdeInterface.GetOutputWindow();

	int nID;
	for (nID = IDM_USERTOOLS_BASE; nID <= IDM_USERTOOLS_LAST; nID++)
	{
		CTool *pCurTool;
		if ((pCurTool = m_ToolList.GetTool(nID-IDM_USERTOOLS_BASE)) != NULL)
		{
			pPackage->SetVisibleMenuItem(nID, TRUE);

			if (pCurTool->m_strPathName.Find(" /") != -1)
			{
				MsgBox(Error, IDS_NO_ARGS_IN_PATH);
				goto HandleError;
			}

			CPath pathTemp;

			// now validate the paths entered by the user...
			if (!pathTemp.Create(pCurTool->m_strPathName))
			{
				MsgBox(Error, IDS_FEXCEP_BADPATH);
				goto HandleError;
			}

			TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
			_splitpath((const TCHAR *)pCurTool->m_strPathName, szDrive, szDir, NULL, NULL);

			if (*szDrive || *szDir)
			{
				// if path entered by user contains drive or dir, treat it as full path.
				if (!pathTemp.ExistsOnDisk())  
				{
					CString strMsg;

					if (MsgBox(Question, MsgText(strMsg, IDS_TOOL_PATH_INVALID, pathTemp.GetFullPath(), pCurTool->m_strMenuName), MB_YESNO) != IDNO)
						goto HandleError;
					else
					{
						pCurTool->m_strPathName = pathTemp.GetFullPath();
						pCurTool->m_fUseSearchPath = FALSE;
						pCurTool->m_fGUITool = FALSE;
					}
				}
				else
				{
					pCurTool->m_strPathName = pathTemp.GetFullPath();
					pCurTool->m_fUseSearchPath = FALSE;
					pCurTool->m_fGUITool = IsFileGUIExe((LPSTR)(const TCHAR *)pathTemp);
				}
			}
			else
			{
				// otherwise, user simply entered the filename--check along the path for it.
				TCHAR szFullPath[_MAX_PATH], *psz;
				if ((SearchPath(NULL, pCurTool->m_strPathName, ".EXE", _MAX_PATH, szFullPath, &psz)) ||
					(SearchPath(NULL, pCurTool->m_strPathName, ".COM", _MAX_PATH, szFullPath, &psz)) ||
					(SearchPath(NULL, pCurTool->m_strPathName, ".BAT", _MAX_PATH, szFullPath, &psz)) ||
					(SearchPath(NULL, pCurTool->m_strPathName, ".CMD", _MAX_PATH, szFullPath, &psz)))
				{
					pCurTool->m_fUseSearchPath = TRUE;
					pCurTool->m_strPathName = psz;
					pCurTool->m_fGUITool = IsFileGUIExe((LPSTR)szFullPath);
				}
				else
				{
					CString strMsg;

					if (MsgBox(Question, MsgText(strMsg, IDS_TOOL_PATH_INVALID, pCurTool->m_strPathName, pCurTool->m_strMenuName), MB_YESNO) != IDNO)
						goto HandleError;
					else
					{
						pCurTool->m_fUseSearchPath = TRUE;
						pCurTool->m_fGUITool = FALSE;
					}
				}
			}

			if (pInterface != NULL)
			{
				if (pCurTool->m_nOutputWindowID != INVALID_OUTPUT_WINDOW)
				{
					// user tools should only have output window tabs if either 
					// 'Ask for Arguments' or 'Redirect to Output Window' checked.
					if (pCurTool->m_fGUITool || (!pCurTool->m_fAskArguments && !pCurTool->m_fOutputRedirectDefault))
					{
						m_rgnDeletedOutputWindows[m_nDeletedOutputWindows++] = pCurTool->m_nOutputWindowID;
						pCurTool->m_nOutputWindowID = INVALID_OUTPUT_WINDOW;
					}
					else
					{
						pInterface->OutputWindowModifyVwin(pCurTool->m_nOutputWindowID, (LPSTR)(const TCHAR *)pCurTool->m_strMenuName, (UINT *)&(pCurTool->m_nOutputWindowID));
					}
				}
				else
				{
					// user tools should only have output window tabs if either 
					// 'Ask for Arguments' or 'Redirect to Output Window' checked.
					if (!pCurTool->m_fGUITool && (pCurTool->m_fAskArguments || pCurTool->m_fOutputRedirectDefault))
					{
						pInterface->OutputWindowAddVwin((LPSTR)(const TCHAR *)pCurTool->m_strMenuName, FALSE, (UINT *)&(pCurTool->m_nOutputWindowID));
					}		  
				}
			}
		}
		else
			pPackage->SetVisibleMenuItem(nID, FALSE);
	}

	if (pInterface != NULL)
	{
		for (int i = 0; i < m_nDeletedOutputWindows; i++) 
			pInterface->OutputWindowDeleteVwin(m_rgnDeletedOutputWindows[i]);
	}
	// set count back to zero
	m_nDeletedOutputWindows = 0;

	toolList = m_ToolList;
	return TRUE;

HandleError:
	m_ToolGrid.SetCurSel(nID - IDM_USERTOOLS_BASE);
	m_ToolList.SetCurTool(nID - IDM_USERTOOLS_BASE);
	ShowToolInfo();
	EnableControls();
	((CEdit *)GetDlgItem(IDC_TM_COMMAND))->SetFocus();
	((CEdit *)GetDlgItem(IDC_TM_COMMAND))->SetSel((DWORD)0xFFFF0000, TRUE);
	return(FALSE);
}

void CCustomizeToolsDialog::CancelTab()
{
	CDlgTab::CancelTab();
}

BEGIN_MESSAGE_MAP (CCustomizeToolsDialog, CDlgTab)
	//{{AFX_MSG_MAP (CCustomizeToolsDialog)
	ON_EN_KILLFOCUS(IDC_TM_COMMAND, OnPathNameKillFocus)
	ON_BN_CLICKED(IDC_TM_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_TM_REDIRECTOUTPUT, OnRedirect)
	ON_SELCHANGE(IDC_TM_TOOLSGRID, OnGridSelChange)
	ON_ADDSTRING(IDC_TM_TOOLSGRID, OnGridAddString)
	ON_DELETESTRING(IDC_TM_TOOLSGRID, OnGridDeleteString)
	ON_SETFOCUS(IDC_TM_TOOLSGRID, OnGridSetFocus)
	ON_KILLFOCUS(IDC_TM_TOOLSGRID, OnGridKillFocus)
	ON_ACTIVATE_CTL(IDC_TM_TOOLSGRID, OnGridActivate)
	ON_ACCEPT_CTL(IDC_TM_TOOLSGRID, OnGridAccept)
	ON_COMMAND_RANGE(IDS_TOOLMACRO_First, IDS_TOOLMACRODIR_Last, OnMacroItem)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CCustomizeToolsDialog::OnPathNameKillFocus()
{
	CEdit *pEdit = (CEdit *)GetDlgItem(IDC_TM_COMMAND);
	CTool *pTool = m_ToolList.GetTool(m_ToolGrid.GetCurSel());
	CString pathName;

	if (pTool == NULL) return;

	pEdit->GetWindowText(pathName);

	// create path, but don't verify at this point.
	pTool->m_strPathName = pathName;

	TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
	_splitpath((const TCHAR *)pathName, szDrive, szDir, NULL, NULL);

	if (*szDrive || *szDir)
	{
		// if path entered by user contains drive or dir, treat it as full path.
		CPath pathVerify;
		if (pathVerify.Create(pathName))
		{
			if (pathVerify.ExistsOnDisk())  
			{
				// check for GUI executable.
				pTool->m_fGUITool = IsFileGUIExe((LPSTR)(const TCHAR *)pathVerify);
				EnableRedirection();
			}
		}
	}
	else
	{
		// otherwise, user simply entered the filename--check along the path for it.
		TCHAR szFullPath[_MAX_PATH], *psz;
		if ((SearchPath(NULL, pathName, ".EXE", _MAX_PATH, szFullPath, &psz)) ||
			(SearchPath(NULL, pathName, ".COM", _MAX_PATH, szFullPath, &psz)) ||
			(SearchPath(NULL, pathName, ".BAT", _MAX_PATH, szFullPath, &psz)) ||
			(SearchPath(NULL, pathName, ".CMD", _MAX_PATH, szFullPath, &psz)))
		{
			// check for GUI executable.
			pTool->m_fGUITool = IsFileGUIExe((LPSTR)szFullPath);
			EnableRedirection();
		}
	}
}

void CCustomizeToolsDialog::EnableControls()
{
	CTool *pTool = m_ToolList.GetTool(m_ToolGrid.GetCurSel());
	if (pTool != NULL)
	{
		GetDlgItem(IDC_TM_COMMAND)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_BROWSE)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_ARGUMENTS)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_INITDIR)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_COMMAND_LABEL)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_ARGUMENTS_LABEL)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_INITDIR_LABEL)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_PROMPTFORARGS)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_ARGMACROS)->EnableWindow(TRUE);
		GetDlgItem(IDC_TM_DIRMACROS)->EnableWindow(TRUE);
		EnableRedirection();
	}
	else
	{
		GetDlgItem(IDC_TM_COMMAND)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_BROWSE)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_ARGUMENTS)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_INITDIR)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_COMMAND_LABEL)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_ARGUMENTS_LABEL)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_INITDIR_LABEL)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_PROMPTFORARGS)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_REDIRECTOUTPUT)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_CLOSEONEXIT)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_ARGMACROS)->EnableWindow(FALSE);
		GetDlgItem(IDC_TM_DIRMACROS)->EnableWindow(FALSE);
	}
}

void CCustomizeToolsDialog::EnableRedirection()
{
	CTool *pTool = m_ToolList.GetTool(m_ToolGrid.GetCurSel());
	if (m_ToolList.NumTools() == 0 || pTool == NULL)
	{
 		GetDlgItem(IDC_TM_REDIRECTOUTPUT)->EnableWindow(FALSE);		
		GetDlgItem(IDC_TM_CLOSEONEXIT)->EnableWindow(FALSE);
	}
	else if (pTool->m_fGUITool)
	{
		GetDlgItem(IDC_TM_REDIRECTOUTPUT)->EnableWindow(FALSE);		
		GetDlgItem(IDC_TM_CLOSEONEXIT)->EnableWindow(FALSE);
	}		
	else
	{
		GetDlgItem(IDC_TM_REDIRECTOUTPUT)->EnableWindow(m_bOutputWindowAvailable);		
		GetDlgItem(IDC_TM_CLOSEONEXIT)->EnableWindow(!IsDlgButtonChecked(IDC_TM_REDIRECTOUTPUT));
	}
}

void CCustomizeToolsDialog::ShowToolInfo()
{
	CTool *pTool = m_ToolList.GetCurToolObject();
	if (pTool != NULL)
	{
		SetDlgItemText(IDC_TM_COMMAND, pTool->m_strPathName);
		SetDlgItemText(IDC_TM_ARGUMENTS, pTool->m_strDefaultArgs);
		SetDlgItemText(IDC_TM_INITDIR, pTool->m_strInitialDir);
		CheckDlgButton(IDC_TM_PROMPTFORARGS, pTool->m_fAskArguments);
		CheckDlgButton(IDC_TM_REDIRECTOUTPUT, pTool->m_fOutputRedirectDefault);
		CheckDlgButton(IDC_TM_CLOSEONEXIT, pTool->m_fCloseWindow);
		EnableRedirection();
	}
	else
	{
		SetDlgItemText(IDC_TM_COMMAND, NULL);
		SetDlgItemText(IDC_TM_ARGUMENTS, NULL);
		SetDlgItemText(IDC_TM_INITDIR, NULL);
		CheckDlgButton(IDC_TM_PROMPTFORARGS, FALSE);
		CheckDlgButton(IDC_TM_REDIRECTOUTPUT, FALSE);
		CheckDlgButton(IDC_TM_CLOSEONEXIT, FALSE);
	}
}

BOOL CCustomizeToolsDialog::GetToolInfo()
{
	if (m_ToolList.NumTools() == 0)
		return TRUE;

	CEdit *pEdit;
	CTool *pTool = m_ToolList.GetCurToolObject();
	if (pTool == NULL)
		return FALSE;

	CString pathName;
	pEdit = (CEdit *)GetDlgItem(IDC_TM_COMMAND);
	pEdit->GetWindowText(pathName);
	pTool->m_strPathName = (const TCHAR *)pathName;
	// don't validate paths here--do at ValidateTab() instead.

	CString strInitDir;
	pEdit = (CEdit *)GetDlgItem(IDC_TM_INITDIR);
	pEdit->GetWindowText(strInitDir);
	pTool->m_strInitialDir = (const TCHAR *)strInitDir;
	// FUTURE: check for existence of directory
	
	CString strArguments;
	pEdit = (CEdit *)GetDlgItem(IDC_TM_ARGUMENTS);
	pEdit->GetWindowText(strArguments);
	pTool->m_strDefaultArgs = (const TCHAR *)strArguments;

	// Check buttons
	pTool->m_fAskArguments = IsDlgButtonChecked(IDC_TM_PROMPTFORARGS);
	pTool->m_fOutputRedirectDefault = IsDlgButtonChecked(IDC_TM_REDIRECTOUTPUT);
	pTool->m_fCloseWindow = IsDlgButtonChecked(IDC_TM_CLOSEONEXIT);

	return TRUE;
}

void CCustomizeToolsDialog::OnBrowse()
{
	CString strDefExt, strFilter, strTitle;

	// instantiating a CCurDir here preserves the current directory across
	// the browse dialog call, so browse will not cause dir to be changed.
	CCurDir cd;

	strDefExt = "exe";
	strFilter.LoadString(IDS_FILE_TYPE_DLG);
	strTitle.LoadString(IDS_ADDTOOL_DLG_TITLE);

	C3dFileDialog dlgBrowse(TRUE, strDefExt, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, strFilter, this, IDD_ADDTOOL_FILE_OPEN);
	dlgBrowse.m_iddWin95 = dlgBrowse.m_iddWinNT = 0x0;
	dlgBrowse.m_ofn.hwndOwner = _SushiGetSafeOwner(NULL);
	dlgBrowse.m_ofn.lpstrTitle = strTitle;

	if (dlgBrowse.DoModal() == IDOK)
	{
		CString strPath = dlgBrowse.GetPathName();
		((CEdit *)GetDlgItem(IDC_TM_COMMAND))->SetWindowText(strPath);
	}
}

void CCustomizeToolsDialog::OnRedirect()
{
	GetDlgItem(IDC_TM_CLOSEONEXIT)->EnableWindow(!IsDlgButtonChecked(IDC_TM_REDIRECTOUTPUT));
}

BOOL CCustomizeToolsDialog::OnAddTool(int nIndex)
{
	if (m_ToolList.NumTools() == MAXTOOLIST)
	{
		CString strMsg;
		MsgBox(Error, MsgText(strMsg, IDS_TOOL_MAX_REACHED, MAXTOOLIST));
		return FALSE;
	}

	CTool *pTool = new CTool;

	VERIFY(m_ToolGrid.GetText(nIndex, pTool->m_strMenuName));
	pTool->m_strPathName.Empty();
	pTool->m_strDefaultArgs.Empty();
	pTool->m_strInitialDir.Empty();
	pTool->m_fAskArguments = FALSE;
	pTool->m_fOutputRedirectDefault = FALSE;
	pTool->m_fCloseWindow = FALSE;
	pTool->m_nOutputWindowID = INVALID_OUTPUT_WINDOW;
	pTool->m_fGUITool = FALSE;
	pTool->m_fUseSearchPath = TRUE;
	pTool->m_fVisibleOnMenu = TRUE;
	pTool->m_fReloadNoPrompt = FALSE;
	m_ToolList.SetCurTool(m_ToolList.AddTool(pTool) - 1);

	ShowToolInfo();
	EnableControls();

	return TRUE;
}

BOOL CCustomizeToolsDialog::OnDelTool(int nIndex)
{
	int nCurSel = m_ToolGrid.GetCurSel();

	CTool *pTool = m_ToolList.GetTool(nCurSel);
	if (pTool->m_nOutputWindowID != INVALID_OUTPUT_WINDOW)
		m_rgnDeletedOutputWindows[m_nDeletedOutputWindows++] = pTool->m_nOutputWindowID;
	m_ToolList.DeleteTool(nCurSel);

	ShowToolInfo();
	EnableControls();

	return TRUE;
}

BOOL CCustomizeToolsDialog::OnChangeTool(int nIndex)
{
	CTool *pTool = m_ToolList.GetCurToolObject();
	VERIFY(m_ToolGrid.GetText(nIndex, pTool->m_strMenuName));
	return TRUE;
}

BOOL CCustomizeToolsDialog::OnMoveTool(int nSrcIndex, int nDestIndex)
{
	if (nSrcIndex > nDestIndex)
	{
		while (nSrcIndex > nDestIndex)
		{
			m_ToolList.SwapTool(nSrcIndex, nSrcIndex-1);
			nSrcIndex--;
		}
	}
	else
	{
		while (nSrcIndex < nDestIndex)
		{
			m_ToolList.SwapTool(nSrcIndex, nSrcIndex+1);
			nSrcIndex++;
		}
	}
	m_ToolList.SetCurTool(nDestIndex);
	return TRUE;
}

void CCustomizeToolsDialog::OnGridSelChange()
{
	// register any changes made to the current tool
	GetToolInfo();

	// select the new current tool
	m_ToolList.SetCurTool(m_ToolGrid.GetCurSel());
	ShowToolInfo();
	EnableControls();

	return;
}

void CCustomizeToolsDialog::OnGridAddString()
{
	GetDlgItem(IDC_TM_COMMAND)->SetFocus();
}

void CCustomizeToolsDialog::OnGridDeleteString()
{
	// refill the grid
	FillGrid(m_ToolGrid.GetCurSel());

	// may have deleted new row if grid was full
	if (m_ToolGrid.m_pNewRow == NULL)
		((CStringListGridWnd *)&m_ToolGrid)->AddNewRow(FALSE);
}

void CCustomizeToolsDialog::OnGridSetFocus()
{
}

void CCustomizeToolsDialog::OnGridKillFocus()
{
	if (m_ToolGrid.m_pActiveElement != NULL)
		((CGridControlWnd *)&m_ToolGrid)->CloseActiveElement();
}

void CCustomizeToolsDialog::OnGridActivate()
{
}

void CCustomizeToolsDialog::OnGridAccept()
{
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\toolexpt.h ===
//////////////////////////////////////////////////////////////////
//	toolexpt.H
//
//			Inteface for importing functions from VCPP
//
//////////////////////////////////////////////////////////////////
#ifndef _TOOLEXPT_H_
#define _TOOLEXPT_H_

#include "tools.h"

#include <srcapi.h>
#include <srcguid.h>
#include <bldapi.h>
#include <bldguid.h>
#include <prjapi.h>
#include <prjguid.h>
#include <clvwapi.h>
#include <clvwguid.h>

// Class CIdeInterface:	Class to interface to the IDE

class CIdeInterface 
{
	friend class CSpawner;

public:
	CIdeInterface();
	~CIdeInterface();
	
	BOOL Initialize();
	void Terminate();

	// cache the spawner interface
	LPEDITDEBUGSTATUS GetEditDebugStatus()
	{
		if (m_pEditDebugStatus == NULL)
			theApp.FindInterface(IID_IEditDebugStatus, (LPVOID FAR *)&m_pEditDebugStatus);
		return(m_pEditDebugStatus);
	}

	void ReleaseEditDebugStatus()
	{
		if (m_pEditDebugStatus != NULL)
			m_pEditDebugStatus->Release();
	}

	// cache the source query interface
	LPSOURCEQUERY GetSourceQuery()
	{
		if (m_pSourceQuery == NULL)
			theApp.FindInterface(IID_ISourceQuery, (LPVOID FAR *)&m_pSourceQuery);
		return(m_pSourceQuery);
	}

	void ReleaseSourceQuery()
	{
		if (m_pSourceQuery != NULL)
			m_pSourceQuery->Release();
	}

	// Cache the project workspace interface
	LPPROJECTWORKSPACE GetProjectWorkspace()
	{
		if(m_pProjectWorkspace == NULL)
			theApp.FindInterface(IID_IProjectWorkspace, (void **)&m_pProjectWorkspace);
		return m_pProjectWorkspace;
	}

	void ReleaseProjectWorkspace()
	{
		if(m_pProjectWorkspace != NULL)
			m_pProjectWorkspace->Release();
		m_pProjectWorkspace = NULL;
	}


	// cache the output window interface
	LPOUTPUTWINDOW GetOutputWindow()
	{
		if (m_pOutputWindow == NULL)
			theApp.FindInterface(IID_IOutputWindow, (LPVOID FAR *)&m_pOutputWindow);
		return(m_pOutputWindow);
	}

	void ReleaseOutputWindow()
	{
		if (m_pOutputWindow != NULL)
			m_pOutputWindow->Release();
	}

	// cache the build system interface
	LPBUILDSYSTEM GetBuildSystem()
	{
		if (m_pBuildSystem == NULL)
			theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&m_pBuildSystem);
		return(m_pBuildSystem);
	}

	void ReleaseBuildSystem()
	{
		if (m_pBuildSystem != NULL)
			m_pBuildSystem->Release();
	}

	// cache the wizard bar interface
	LPWIZARDBAR GetWizBarIFace()
	{
		if (NULL == m_pWizBarIFace && !m_fTriedWizBarIFace)
		{
			theApp.FindInterface(IID_IWizardBar, (LPVOID FAR *)&m_pWizBarIFace);
			m_fTriedWizBarIFace = TRUE;	  // more efficient if iface is NOT found
		}
		return m_pWizBarIFace;
	}

	void ReleaseWizBarIFace()
	{
		if (m_pWizBarIFace != NULL)
		{
			m_pWizBarIFace->Release();
			m_pWizBarIFace = NULL;
			m_fTriedWizBarIFace = FALSE;
		}
	}



private:
	LPEDITDEBUGSTATUS	m_pEditDebugStatus;
	LPSOURCEQUERY		m_pSourceQuery;
	LPPROJECTWORKSPACE	m_pProjectWorkspace;
	LPOUTPUTWINDOW		m_pOutputWindow;
	LPBUILDSYSTEM		m_pBuildSystem;
	LPWIZARDBAR			m_pWizBarIFace;
	BOOL				m_fTriedWizBarIFace;

};

extern CIdeInterface g_IdeInterface;

#endif	 // _TOOLEXPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\toolexpt.cpp ===
//////////////////////////////////////////////////////////////////
//	toolexpt.CPP
//
//		Definition of interfaces defined in toolexpt.H
//		Import functions from VCPP
///////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop
#include "toolexpt.h"
#include "tools.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------- CIdeInterface ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

CIdeInterface::CIdeInterface()
{ 
	m_pEditDebugStatus = NULL;
	m_pSourceQuery = NULL;
	m_pProjectWorkspace = NULL;
	m_pOutputWindow = NULL;
	m_pBuildSystem = NULL;

	m_pWizBarIFace = NULL;
	m_fTriedWizBarIFace = FALSE;
}

CIdeInterface::~CIdeInterface()
{ 
}

///////////////////////////
//
// CIdeInterface::Initialize()
//
//	must be called in the beginning of the program
////////////////////////////

BOOL CIdeInterface::Initialize()
{
	ASSERT(this == &g_IdeInterface);

	GetEditDebugStatus();
	GetSourceQuery();
	GetOutputWindow();
	GetBuildSystem();

	return((m_pEditDebugStatus != NULL) && (m_pSourceQuery != NULL) &&
			(m_pOutputWindow != NULL) && (m_pBuildSystem != NULL));
}

void CIdeInterface::Terminate()
{
	ASSERT(this == &g_IdeInterface);

	ReleaseEditDebugStatus();
	ReleaseSourceQuery();
	ReleaseProjectWorkspace();
	ReleaseOutputWindow();
	ReleaseBuildSystem();

	ReleaseWizBarIFace();
}

CIdeInterface g_IdeInterface;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tools.cpp ===
//////////////////////////
//	class : CTool
//	purpose : keep information about command tool  
//////////////////////////

//////////////////////////
// include files
//////////////////////////
#include "stdafx.h"

#include "tools.h"
#include "toolexpt.h"
#include "find.h" // for CButtonEdit
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////

extern BOOL ExpandToolArguments(LPSTR szArg, size_t size);

// wrapper for ExpandToolArguments(char*, size_t)
inline BOOL ExpandToolArguments(CString &strArgs)
{
	BOOL fRet = ExpandToolArguments(strArgs.GetBuffer(MAXARGUMENT), MAXARGUMENT);
	strArgs.ReleaseBuffer();
	return fRet;
}

///////////////////////////////////////////////////////////////////

class CDialogArg: public C3dDialog
{
// Construction
public:
	CDialogArg (CTool *pTool, CWnd* pParent = NULL) ; // standard constructor

// Dialog Data
	//{{AFX_DATA(CDialogArg)
	enum { IDD = IDD_TOOLARGUMENTS } ;
	CString m_strArguments;
	BOOL	m_fRedirect;
	//}}AFX_DATA
	CMenuBtn m_mbtnMacros;
	CButtonEdit m_btedEdit;
// Implementation
protected:
	BOOL m_fGUITool ;
	virtual void DoDataExchange(CDataExchange* pDX);   // DDX/DDV support

	virtual BOOL OnInitDialog();
	// Generated message map functions
	//{{AFX_MSG(CDialogArg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	void OnMacroItem(UINT nId);
};

///////////////////////////////////////////////////////////////////

UINT CTool::Spawn()
{
	UINT nRet;
	CString strArguments, strDirectory;
	if (m_fAskArguments)
	{
		CDialogArg dlg(this);
		if (dlg.DoModal() != IDOK)
		{
			// user canceled the tool arguments dialog, so abort
			return(0);
		}
		else 
		{
			m_fOutputRedirect = dlg.m_fRedirect;
			strArguments = dlg.m_strArguments;
		}
	}
	else
	{
		strArguments = m_strDefaultArgs;
		m_fOutputRedirect = m_fOutputRedirectDefault;
	}

	strDirectory = m_strInitialDir;

	if (!strArguments.IsEmpty() && !ExpandToolArguments(strArguments))
		return(0);
	if (!strDirectory.IsEmpty() && !ExpandToolArguments(strDirectory))
		return(0);

	// if necessary, set a default directory in which to spawn the tool
	if (strDirectory.IsEmpty() || _access(strDirectory, 00)==-1)
		strDirectory = ".";
	
	m_pSpawner = new CConsoleSpawner(&m_pSpawner);
	m_pSpawner->m_fCloseWindow = m_fCloseWindow;
	m_pSpawner->m_fGUITool = m_fGUITool;
	m_pSpawner->m_fReloadNoPrompt = m_fReloadNoPrompt;
	m_pSpawner->InitializeSpawn((LPTSTR)LPCTSTR(strDirectory), m_fOutputRedirect ? m_nOutputWindowID : -1, TRUE);
	CString strCommandLine;
	if(m_strPathName.Find(' ')!=-1)
		strCommandLine = "\"" + m_strPathName + "\" " + strArguments;
	else
		strCommandLine = m_strPathName + " " + strArguments;

	nRet = m_pSpawner->PerformSpawn((LPTSTR)LPCTSTR(strCommandLine), FALSE);
	// m_pSpawner is self-deleting! no need to delete it!
	return(nRet);
}

void CTool::CancelSpawn()
{
	ASSERT(m_pSpawner != NULL);
	m_pSpawner->CancelSpawn();
}

////////////////////////////
// Member function :
//
// operator = 
////////////////////////////
const CTool & CTool::operator = (const CTool& toolSrc)
{
	m_strMenuName = toolSrc.m_strMenuName;
	m_strPathName = toolSrc.m_strPathName;
	m_strDefaultArgs = toolSrc.m_strDefaultArgs;
	m_strCurrentArgs = toolSrc.m_strCurrentArgs;
	m_strInitialDir = toolSrc.m_strInitialDir;
	m_fAskArguments = toolSrc.m_fAskArguments;
	m_fGUITool = toolSrc.m_fGUITool;
	m_fOutputRedirectDefault = toolSrc.m_fOutputRedirectDefault;
	m_fOutputRedirect = toolSrc.m_fOutputRedirect;
	m_nOutputWindowID = toolSrc.m_nOutputWindowID;
	m_fCloseWindow = toolSrc.m_fCloseWindow;
	m_fUseSearchPath = toolSrc.m_fUseSearchPath;
	m_fVisibleOnMenu = toolSrc.m_fVisibleOnMenu;
	m_fReloadNoPrompt = toolSrc.m_fReloadNoPrompt;
	return *this;
}

//////////////////////////////
// class:  CToolList
// purpose : a list of CTool objects	
//////////////////////////////

///////////////////////
// Destructor 
///////////////////////
CToolList::~CToolList()
{
	DestroyContent();
}

///////////////////////
// CToolList::destroyContent
// 
// 	delete all CTool objects in the list
///////////////////////

void CToolList::DestroyContent() 
{
	int iTool = 0;
	m_nCurTool = -1;
	for (iTool = 0; iTool < m_nTools; iTool++)
	{
		delete m_toolArray[iTool];
		m_toolArray[iTool] = NULL;
	}
	m_nTools = 0;
}

//////////////////////////
// CToolList::addTool
//
//	adding CTool to the list
///////////////////////////
int CToolList::AddTool(CTool *newTool)
{
	int pos = 0;

	if (m_nTools > MAXTOOLIST)
		return -1;
	m_toolArray[m_nTools] = newTool;
	m_nCurTool = m_nTools;
	m_nTools++;
	return m_nTools;
}

///////////////////////////
// CToolList::deleteTool
//
//	delete the CTool pointed by the index
////////////////////////////
void CToolList::DeleteTool(int nIndex) 
{
	if (nIndex >= m_nTools)
		return;
	delete m_toolArray[nIndex];
	while (nIndex < (m_nTools - 1))
	{
		m_toolArray[nIndex] = m_toolArray[nIndex+1];
		nIndex++;
	}
	m_toolArray[nIndex] = NULL;
	if (m_nCurTool == (m_nTools - 1))
		m_nCurTool--;
	m_nTools--;
}

///////////////////////////
// CToolList::swapTool
//
//	swaps the positions of the tools with the given indices
////////////////////////////
void CToolList::SwapTool(int nIndex1, int nIndex2)
{
	CTool *ptoolTemp;

	ASSERT(nIndex1 >= 0 && nIndex1 < m_nTools);
	ASSERT(nIndex2 >= 0 && nIndex2 < m_nTools);
	ptoolTemp = m_toolArray[nIndex2];
	m_toolArray[nIndex2] = m_toolArray[nIndex1];
	m_toolArray[nIndex1] = ptoolTemp;
} 

///////////////////////////
// CToolList::getTool
//
//	get the CTool object given the index number
///////////////////////////
CTool *CToolList::GetTool(int nIndex)
{
	if (nIndex < 0 || nIndex >= m_nTools)
		return NULL;
	else
		return m_toolArray[nIndex];
}

//////////////////////////
// CToolList::getCurToolObject
//
//	get the current CTool object from the list
//	curTool is an index to a particular CTool object 
//////////////////////////
CTool *CToolList::GetCurToolObject()
{
	if (m_nTools == 0 || m_nCurTool >= m_nTools || m_nCurTool < 0)
		return NULL;
	else
		return m_toolArray[m_nCurTool];
}


///////////////////////////
// CToolList::operator =
//
//	copy CToolList objects
//	actual copying is done (no sharing)
///////////////////////////
CToolList & CToolList::operator = (CToolList& toolListSrc) 
{
	DestroyContent();
	m_nTools = toolListSrc.NumTools();
	m_nCurTool = toolListSrc.GetCurTool();
	for (int i = 0; i < m_nTools; i++)
	{
		m_toolArray[i] = new CTool;
		*m_toolArray[i] = *toolListSrc.GetTool(i);
	}
	
	return *this;
}

////////////////////////////
// Global variables defined
////////////////////////////

CToolList  toolList;
CToolList  toolListBackup;

/////////////////////////////
// Save and load toolList to/from ini file
// SaveToolListSetting()
// LoadToolListSetting()
/////////////////////////////
//
// Strings used for ini files 
// should this be in resource file ?
//
//////////////////////////////

static char szTools[] = "Tools" ;
static char szNumTool[] = "NumTools" ;
static char szMenuName[] = "MenuName" ;
static char szPathName[] = "PathName" ;
static char szDefaultArgs[] = "DefaultArguments" ;
static char szInitialDir[] = "InitialDirectory" ;
static char szAskArguments[] = "AskArgument" ;
static char szGUITool[] = "GUITool" ;
static char szOutputRedirectDefault[] = "OutputRedirect" ;
static char szCloseWindow[] = "CloseWindow" ;
static char szUseSearchPath[] = "UseSearchPath" ;
static char szVisibleOnMenu[] = "VisibleOnMenu" ;
static char szReloadNoPrompt[] = "ReloadNoPrompt" ;

void SaveToRegStr (TCHAR * szData, int index, const TCHAR * szString) 
{
	CString  szBuffer ;
	char szNum[2] ;
	szBuffer = szData ;
	szBuffer += '#' ;
	szBuffer += _itoa(index, szNum, 10) ;
	WriteRegString (szTools, (TCHAR *)(const TCHAR *)szBuffer, szString) ;
}

void SaveToRegInt (TCHAR * szData, int index, int value) 
{
	CString  szBuffer ;
	char szNum[2] ;
	szBuffer = szData ;
	szBuffer += "#" ;
	szBuffer += _itoa(index, szNum, 10) ;
	WriteRegInt (szTools, (TCHAR *)(const TCHAR *)szBuffer, value) ;
}

void SaveToolListSetting () 
{
	int i ;
	int numTools ;
	CTool *pTool ;

	// clean out the existing registry key so we start fresh
	CString strKeyMain = GetRegistryKeyName();
	RegDeleteKey(HKEY_CURRENT_USER, strKeyMain + chKeySep + _T("Tools"));

	// write the number of tools defined 
	numTools = min(toolList.NumTools(), MAXTOOLIST);
	WriteRegInt (szTools, szNumTool, numTools) ;

	// For each tool, save info
	for (i = 0 ; i < numTools ; i++)
	{
		pTool = toolList.GetTool(i) ;
		ASSERT (pTool != NULL) ;
		SaveToRegStr(szMenuName, i, (const TCHAR *) pTool->m_strMenuName);
		SaveToRegStr(szPathName, i, (const TCHAR *)pTool->m_strPathName);
		SaveToRegStr(szDefaultArgs, i, (const TCHAR *)pTool->m_strDefaultArgs);
		SaveToRegStr(szInitialDir, i, (const TCHAR *)pTool->m_strInitialDir);
		SaveToRegInt(szAskArguments, i, pTool->m_fAskArguments);
		SaveToRegInt(szGUITool, i, pTool->m_fGUITool);
		SaveToRegInt(szOutputRedirectDefault, i, pTool->m_fOutputRedirectDefault);
		SaveToRegInt(szCloseWindow, i, pTool->m_fCloseWindow);
		SaveToRegInt(szUseSearchPath, i, pTool->m_fUseSearchPath);
		SaveToRegInt(szVisibleOnMenu, i, pTool->m_fVisibleOnMenu);
		SaveToRegInt(szReloadNoPrompt, i, pTool->m_fReloadNoPrompt);
	}
}


CString LoadFromRegStr (TCHAR * szData, int i) 
{

	CString  szBuffer ;
	char szNum[2] ;
	szBuffer = szData ;
	szBuffer += "#" ; 
	szBuffer += _itoa(i, szNum, 10) ;
	return GetRegString (szTools, (TCHAR *)(const TCHAR *)szBuffer);
}

UINT LoadFromRegInt (TCHAR * szData, int i) 
{

	CString  szBuffer ;
	char szNum[2] ;
	szBuffer = szData ;
	szBuffer += "#" ; 
	szBuffer += _itoa(i, szNum, 10) ;
	return GetRegInt (szTools, (TCHAR *)(const TCHAR *)szBuffer, FALSE);
}

void LoadToolListSetting()
{
	int i;
	int numTools ;
	CTool *pTool ;

	// get the number of tools defined
	numTools = GetRegInt (szTools, szNumTool, FALSE) ;
	numTools = min(numTools, MAXTOOLIST);

	toolList.DestroyContent();
	// For each tool, create info
	for (i = 0 ; i < numTools ; i++) {
		pTool = new CTool ;
		ASSERT (pTool != NULL) ;
		pTool->m_strMenuName = LoadFromRegStr(szMenuName, i);
		pTool->m_strPathName = LoadFromRegStr(szPathName, i);

		// dolphin 2364 [patbr] allow tools without full paths
		pTool->m_fUseSearchPath = (BOOL)LoadFromRegInt(szUseSearchPath, i);
#ifdef CHECK_VALID_TOOL_PATH
		if (!pTool->m_fUseSearchPath)
		{
			CPath pathVerify;
			if (!pathVerify.Create((const TCHAR *) LoadFromRegStr (szPathName,i))) {
				// File does not exist anymore so, skip this one 
				delete pTool ;
				continue ;
			}
		}
		else
		{
			// should we search path now or just tell the user when tool fails to run?
		}
#endif	// CHECK_VALID_TOOL_PATH
		pTool->m_strDefaultArgs = LoadFromRegStr(szDefaultArgs, i);
		pTool->m_strInitialDir = LoadFromRegStr(szInitialDir, i);
		pTool->m_fAskArguments = LoadFromRegInt(szAskArguments, i);
		pTool->m_fGUITool = IsFileGUIExe((LPSTR)(const char *)pTool->m_strPathName);
		if (!pTool->m_fGUITool)
		{
			pTool->m_fOutputRedirectDefault = (BOOL)LoadFromRegInt(szOutputRedirectDefault, i);
			pTool->m_fCloseWindow = (BOOL)LoadFromRegInt(szCloseWindow, i);
			// user tools should only have output window tabs if either 
			// 'Ask for Arguments' or 'Redirect to Output Window' checked.
			if ((g_IdeInterface.GetOutputWindow() != NULL) && (pTool->m_fAskArguments || pTool->m_fOutputRedirectDefault))
				g_IdeInterface.GetOutputWindow()->OutputWindowAddVwin((LPSTR)(const TCHAR *)pTool->m_strMenuName, FALSE, (UINT *)&(pTool->m_nOutputWindowID));
			else
				pTool->m_nOutputWindowID = INVALID_OUTPUT_WINDOW ;
		}
		else
		{
			pTool->m_fOutputRedirectDefault = FALSE;
			pTool->m_fCloseWindow = FALSE;
			pTool->m_nOutputWindowID = INVALID_OUTPUT_WINDOW;
		}
		pTool->m_fVisibleOnMenu = (BOOL)LoadFromRegInt(szVisibleOnMenu, i);
		pTool->m_fReloadNoPrompt = (BOOL)LoadFromRegInt(szReloadNoPrompt, i);
		toolList.AddTool(pTool);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDialogArg

CDialogArg::CDialogArg (CTool * pTool, CWnd* pParent /*=NULL*/)
		: C3dDialog(CDialogArg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDialogArg)
	m_fRedirect = pTool->m_fOutputRedirectDefault;
	m_strArguments = pTool->m_strDefaultArgs;
	//}}AFX_DATA_MAP
	m_fGUITool = pTool->m_fGUITool;
}

void CDialogArg::DoDataExchange(CDataExchange * pDX)
{
	C3dDialog::DoDataExchange(pDX) ;
	//{{AFX_DATA_MAP(CDialogArg)
	DDX_Check(pDX, IDC_TOOLARGUMENTS_REDIRECT, m_fRedirect);
	DDX_Text(pDX, IDC_TOOLARGUMENTS_ARGS, m_strArguments);
	//}}AFX_DATA_MAP
}

BOOL CDialogArg::OnInitDialog()
{
	C3dDialog::OnInitDialog();
	VERIFY(m_btedEdit.SubclassDlgItem(IDC_TOOLARGUMENTS_ARGS, this));
	m_btedEdit.LimitText(MAXARGUMENT);
	// FUTURE: temporary workaround [patbr]
	// if SRC package not available, disable the 'redirect to output window'
	// checkbox, because the output window still lives in the SRC package.
	if (m_fGUITool || !theApp.GetPackage(PACKAGE_VCPP))
		GetDlgItem(IDC_TOOLARGUMENTS_REDIRECT)->EnableWindow(FALSE);
	else
		GetDlgItem(IDC_TOOLARGUMENTS_REDIRECT)->EnableWindow(TRUE);
	VERIFY(m_mbtnMacros.SubclassDlgItem(IDC_TOOLARGUMENTS_MACROS, this));
	VERIFY(m_mbtnMacros.LoadMenu(IDR_TOOL_MACRO));
	return TRUE ;
}

BEGIN_MESSAGE_MAP(CDialogArg,C3dDialog)
	//{AFX_MSG_MAP(CDialogArg)
	//}}AFX_MSG_MAP
	ON_COMMAND_RANGE(IDS_TOOLMACRO_FilePath, IDS_TOOLMACRO_WkspName, OnMacroItem)
END_MESSAGE_MAP()

void CDialogArg::OnMacroItem(UINT nId)
{
	if (IDS_TOOLMACRO_First <= nId && nId <= IDS_TOOLMACRO_Last)
	{
		CString strMacro;
		VERIFY(strMacro.LoadString(nId));
		m_btedEdit.ReplaceSel(strMacro);
		m_btedEdit.SetFocus();
	}
	else
		ASSERT(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\toolcust.h ===
// toolcust.h : header file for CToolsGrid, CCustomizeToolsDialog
//

#ifndef __TOOLCUST_H__
#define __TOOLCUST_H__

#include "tools.h"
#include "resource.h"
#include "utilctrl.h"

class CCustomizeToolsDialog;

/////////////////////////////////////////////////////////////////////////////
// CToolsGrid

class CToolsGrid : public CStringListGridWnd
{
// Construction
public:
	CToolsGrid();
	~CToolsGrid();

// Attributes
public:
	class CCustomizeToolsDialog* m_pDlg;

// Overrides
protected:
	virtual inline BOOL OnAddString(int nIndex);
	virtual inline BOOL OnDeleteString(int nIndex);
	virtual inline BOOL OnChange(int nIndex);
	virtual inline BOOL OnMove(int nSrcIndex, int nDestIndex);

	void DoCut();
	void DoCopy();
	void DoPaste();

	virtual void DoMove(int nToIndex);

// Implementation
public:
	virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
	virtual BOOL BeginDrag(UINT nFlags, const CPoint& point);

	virtual void AddNewRow(BOOL bSelect = TRUE);

protected:
	afx_msg void OnGridNew();			//  New button pressed 

private:
	CTool *m_pClipboardTool;

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CCustomizeToolsDialog

class CCustomizeToolsDialog : public CDlgTab
{
// Construction
public:
	
// Dialog data
	//{{AFX_DATA(CCustomizeToolsDialog)
	enum { IDD = IDDP_CUSTOMIZE_TOOLSMENU };
	//}}AFX_DATA

	CCustomizeToolsDialog();

	BOOL OnAddTool(int nIndex);
	BOOL OnDelTool(int nIndex);
	BOOL OnChangeTool(int nIndex);
	BOOL OnMoveTool(int nSrcIndex, int nDestIndex);

protected:
	//{{AFX_MSG(CCustomizeToolsDialog)
	virtual BOOL	OnInitDialog();
	virtual BOOL	ValidateTab();
	virtual void	CancelTab();
	afx_msg void	OnPathNameKillFocus();
	afx_msg void	OnBrowse();
	afx_msg void	OnRedirect();
	afx_msg void	OnMacroItem(UINT nId);
	afx_msg void	OnGridSelChange();
	afx_msg void	OnGridAddString();
	afx_msg void	OnGridDeleteString();
	afx_msg void	OnGridSetFocus();
	afx_msg void	OnGridKillFocus();
	afx_msg void	OnGridActivate();
	afx_msg void	OnGridAccept();
	//}}AFX_MSG	

	// our message map functions
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CCustomizeToolsDialog)

public:
	CToolsGrid m_ToolGrid;
	CToolList  m_ToolList;

private:
	CMenuBtn m_mbtnArgMacros;
	CMenuBtn m_mbtnDirMacros;
	BOOL     m_bOutputWindowAvailable;

	int  m_nDeletedOutputWindows;
	UINT m_rgnDeletedOutputWindows[MAXTOOLIST];

public:
	void ShowToolInfo();
	BOOL GetToolInfo();
	void FillGrid(int nSelectRow = 0);
	void EnableControls();
	void EnableRedirection();
};

/////////////////////////////////////////////////////////////////////////////
// CToolsGrid inlines

inline BOOL CToolsGrid::OnAddString(int nIndex)
{
	return(m_pDlg->OnAddTool(nIndex));
}

inline BOOL CToolsGrid::OnDeleteString(int nIndex)
{
	return(m_pDlg->OnDelTool(nIndex));
}

inline BOOL CToolsGrid::OnChange(int nIndex)
{
	return(m_pDlg->OnChangeTool(nIndex));
}

inline BOOL CToolsGrid::OnMove(int nSrcIndex, int nDestIndex)
{
	return(m_pDlg->OnMoveTool(nSrcIndex, nDestIndex));
}

/////////////////////////////////////////////////////////////////////////////

#endif	// __TOOLCUST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\totd.h ===
// totd.h -- Tip of the Day

#ifndef __TOTD_H__
#define __TOTD_H__

BOOL TipOfTheDay( BOOL fShow = FALSE );
BOOL isTipAvailable();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\transbut.h ===
#ifndef _transbut_h
#define _transbut_h

#include "btnextra.h"

class CToolBarProxy;

// Callback for destroying toolbar transfer data.
typedef void (FAR PASCAL *TRANSDATA_CALLBACK)(DWORD dwData);

struct TRANSFER_TBBUTTON
{
	// This one is used when the transfer is sourced from another bar. This includes
	// transfers from the button wells in the customize toolbars dialog, as this dialog
	// contains real CCustomBars.
	TRANSFER_TBBUTTON(CToolBarProxy* pBar, int nIndex, BOOL bDeleting);
	// These constructors are used where there isn't a source bar.
	// This one, for a new textual button
	TRANSFER_TBBUTTON(int nCommand, CString *text, BOOL bCustomText);
	// This one, for a new button with a custom glyph
	TRANSFER_TBBUTTON(int nCommand, HBITMAP hbmCustom, BOOL bLarge);
	// This one, for a new button with a custom glyph
	TRANSFER_TBBUTTON(int nCommand, HBITMAP hbmCustom, int nIndex, BOOL bLarge);
	// This one for a new button which is going to use its own inbuilt glyph
	TRANSFER_TBBUTTON(int nCommand);
	// glyph plus text button in a new button with no default glyph
	TRANSFER_TBBUTTON(int nCommand, CString *text, HBITMAP hbmCustom, BOOL bLarge, BOOL bCustomText);
	~TRANSFER_TBBUTTON();

	// Used once we know the destination of a transfer, to load the appropriate bitmap. Also, if the bitmap is
	// non-custom and is the wrong size we toss that and get the right one.
	void LoadCommandBitmap(BOOL bLarge);

	UINT nID;
	UINT nStyle;
	int iImage;
	CSize sizeImage;

	BOOL bDel;
	HBITMAP hbmImageWell;
	TBBUTTON_EXTRA extra;

	// Extra data added by the toolbar derived class.
	DWORD dwData;
	TRANSDATA_CALLBACK lpDataCallback;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\tools.h ===
/////////////////////////////
// 
// tools.h
// 
// class definition for CTools which maintain option.tool data structure
//
//	CTool	 : option.tool data structure
//	CToolList: tool manager, manages a list of Tools
//
//////////////////////////////
#ifndef __TOOLS_H__

#define __TOOLS_H__

////////////////////////////
// include files
////////////////////////////
#ifndef __PATH_H_
#include "path.h"
#endif

#ifndef __IDS_H_
#include "ids.h"
#endif

class CConsoleSpawner;

// FUTURE: Should MAXTOOLMENU be smaller, say 16, so as to assure small menu?
#define MAXTOOLMENU	30
#define MAXPATHNAME 	_MAX_PATH
#define MAXINITDIR	_MAX_PATH
#define MAXARGUMENT 	_MAX_PATH
#define INVALID_OUTPUT_WINDOW	-1
////////////////////////////
// CTool : Class definition
////////////////////////////

class CTool: public CObject
{
// Construction
public:
	CTool() { m_pSpawner = NULL; }
	~CTool() { }

// Implementation
	BOOL CanSpawn() { return(m_pSpawner == NULL); }
	UINT Spawn();
	void CancelSpawn();

// define operator
	const CTool &operator = (const CTool &toolSrc);

public:
	CString		m_strMenuName;		// Menu name in Tool menu
	CString		m_strPathName;		// Full path name of file
	CString		m_strDefaultArgs;	// Default command line args
	CString		m_strCurrentArgs;	// Current command line args
	CString		m_strInitialDir;	// Default directory
	BOOL 		m_fAskArguments;	// Ask for arguments
	BOOL 		m_fGUITool;			// Is this tool a GUI app?
	BOOL 		m_fOutputRedirectDefault;	// Default Redirect to output window
	BOOL 		m_fOutputRedirect;	// Redirect to output window
	INT  		m_nOutputWindowID;	// Output window ID
	BOOL 		m_fCloseWindow;		// Close window after task complete
	BOOL		m_fUseSearchPath;	// FALSE if path to tool is hard-coded; TRUE if we should use the PATH
	BOOL		m_fVisibleOnMenu;	// TRUE if the user has checked the box in Tools.Customize.Tools
	BOOL		m_fReloadNoPrompt;	// TRUE if the tool will modify a single file and we want the IDE
									// to reload the file without prompting

	CConsoleSpawner *m_pSpawner;
};

///////////////////////
// class CToolList
///////////////////////
#define MAXTOOLIST	(IDM_USERTOOLS_LAST - IDM_USERTOOLS_BASE + 1)

class CToolList: public CObject
{
protected:
	int		m_nTools;
	int		m_nCurTool;
public:
	CTool  *m_toolArray[MAXTOOLIST];

	CToolList() { m_nTools = 0; m_nCurTool = -1; }
	~CToolList();
	int		AddTool(CTool *newTool);
	void 	DeleteTool(int nIndex);
	void	SwapTool(int nIndex1, int nIndex2 );
	void	DestroyContent();
	CTool  *GetTool(int nIndex);
	CTool  *GetCurToolObject();
	int		GetCurTool() { return m_nCurTool; };
	void	SetCurTool(int nIndex) { m_nCurTool = nIndex; }
	CToolList&  operator = (CToolList& toolListSrc);
	int		NumTools() { return m_nTools; }
} ;

extern CToolList toolList;
extern CToolList toolListBackup;

extern void SaveToolListSetting();
extern void LoadToolListSetting();

#endif	// __TOOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\transbut.cpp ===
#include "stdafx.h"

#include "transbut.h"

#include "barglob.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// This constructor is always used when a button is being dragged from an existing toolbar
TRANSFER_TBBUTTON::TRANSFER_TBBUTTON(CToolBarProxy* pBar, int nIndex, BOOL bDeleting)
{
	ASSERT_VALID(pBar->GetWindow());

	lpDataCallback = NULL;

	pBar->GetButtonInfo(nIndex, nID, nStyle, iImage);

	// get button details
	if(pBar->HasExInfo(nIndex))
	{
		HWND hControl;
		CString strText;
		HBITMAP hImage;
		pBar->GetButtonInfoEx(nIndex, hControl, strText, hImage);

		extra.Create(hControl, &strText, hImage);
	}
	else
	{
		extra.Create();
	}

	sizeImage = pBar->GetImageSize();

	if(nStyle & TBBS_CUSTOMBITMAP)
	{
		// as below, make a copy if the original is about to go away
		if(bDeleting)
		{
			extra.SetGlyph(GLOBAL_DATA::DuplicateBitmap(pBar->GetWindow(), extra.GetGlyph()));
		}
	}

	if(nStyle & TBBS_TEXTUAL)
	{
		if((nStyle & TBBS_CUSTOMTEXT)==0)
		{
			LPCTSTR pszText;
			CString strCommand;
			// gett the default string for this item
			theCmdCache.GetCommandString(nID, STRING_MENUTEXT, &pszText);
			if (pszText == NULL || pszText[0] == _T('\0'))
			{
				theCmdCache.GetCommandString(nID, STRING_COMMAND, &pszText);
				// (bobz, paranoia:) we do not want to hold onto the return string from GetCommandString
				// (could be dynamic string held in single global CString). So even though current code
				// would be ok - (InsertMenu below copies the string), I am copying to a local CString
				// to ensure no weird future problems

				strCommand = pszText;
				pszText = (LPCTSTR)strCommand;
			}
			extra.SetLabel(pszText);
			
		}
		else
		{
			// as below, make a copy if the original is about to go away
			if(bDeleting)
			{
				extra.SetLabel(extra.GetLabel());
			}
		}
	}

	pBar->GetButtonTransferInfo(nIndex, dwData, &lpDataCallback);

	bDel = bDeleting;

	if (!bDel)
	{
		extra.SetControl(NULL);
		hbmImageWell = pBar->GetImageWell(nIndex);
	}
	else
	{
		// When deleting the image well must be copied, since the deletion
		// may cause the toolbar to be destroyed.
		hbmImageWell=GLOBAL_DATA::DuplicateBitmap(pBar->GetWindow(), pBar->GetImageWell(nIndex),
			pBar->GetImageSize(),  CPoint(pBar->GetImageSize().cx*iImage,0));
		iImage = 0;
	}
}

// Constructor for transfer of a command button with a custom bitmap object
/* For use only when the button has just been created as a result of dragging
a new button which doesn't have a default bitmap

To simplify the destination's task, we pretend that the custom bitmap is an
image well with only one button inside it
*/
TRANSFER_TBBUTTON::TRANSFER_TBBUTTON(int nCommand, HBITMAP hbmCustom, BOOL bLarge)
{
	ASSERT(nCommand!=0);
	ASSERT(hbmCustom!=NULL);

	lpDataCallback = NULL;

	nStyle=TBBS_CUSTOMBITMAP | TBBS_GLYPH;
	nID=nCommand;

	bDel = FALSE;
	extra.Create();

	sizeImage=CCustomBar::GetDefaultBitmapSize(bLarge);

	// fake the image well as the custom bitmap bitmap
	iImage=0;
	hbmImageWell = hbmCustom;
}

// Constructor for transfer of a command button with a known bitmap in another well
/* For use only when the button has just been created as a result of dragging
a new button which doesn't have a default bitmap

To simplify the destination's task, we pretend that the custom bitmap is an
image well with only one button inside it
*/
TRANSFER_TBBUTTON::TRANSFER_TBBUTTON(int nCommand, HBITMAP hbmCustom, int nIndex, BOOL bLarge)
{
	ASSERT(nCommand!=0);
	ASSERT(hbmCustom!=NULL);

	lpDataCallback = NULL;

	nStyle=TBBS_CUSTOMBITMAP | TBBS_GLYPH;
	nID=nCommand;

	bDel = FALSE;
	extra.Create();

	sizeImage=CCustomBar::GetDefaultBitmapSize(bLarge);

	// !!! handle scaling when sizes are wrong?

	// fake the image well as the custom bitmap bitmap
	iImage=nIndex;
	hbmImageWell = hbmCustom;
}

// Constructor for transfer of a command button which will use the package's
// default bitmap
/* For use only when the button has just been created as a result of dragging
a new button which has a default bitmap
*/
TRANSFER_TBBUTTON::TRANSFER_TBBUTTON(int nCommand)
{
	// slighly hacky way to do separators
	if(nCommand==ID_SEPARATOR)
	{
		nStyle=TBBS_SEPARATOR;
		iImage=-1;
		sizeImage=CSize(0,0);
		hbmImageWell=NULL;
	}
	else
	{
		CPackage *pPackage;
		// copy the package info 
		nStyle=theApp.GetCommandBtnInfo(nCommand, &pPackage);
		if(nStyle & TBBS_TEXTUAL)
		{
			LPCTSTR pText=NULL;
			theCmdCache.GetCommandString(nCommand, STRING_MENUTEXT, &pText);
			if (!pText || *pText=='\0')
			{
				theCmdCache.GetCommandString(nCommand, STRING_COMMAND, &pText);
			}

			CString text=pText;
			extra.Create(NULL, &text, NULL);
		}
		else
		{
			extra.Create();
		}

		ASSERT(pPackage!=NULL);

		// don't get the glyph until we know what the destination is
		sizeImage.cx=sizeImage.cy=0;
		hbmImageWell=NULL;
		iImage=-1;
	}

	lpDataCallback = NULL;

	nID=nCommand;

	bDel = FALSE;
}

// Constructor for transfer of a command button which will use a text string
/* For use only when the button has just been created as a result of dragging
a new button which doesn't have a default bitmap
*/
TRANSFER_TBBUTTON::TRANSFER_TBBUTTON(int nCommand, CString *text, BOOL bCustomText)
{
	ASSERT(nCommand!=0);
	ASSERT(!text->IsEmpty()); // although an empty string won't cause crashes, it's 
							 // probably useful to spot it here in case validation
							 // failed upstream

	lpDataCallback = NULL;

	nStyle=TBBS_TEXTUAL;
	if(bCustomText)
	{
		nStyle |= TBBS_CUSTOMTEXT;
	}
	iImage=0;
	nID=nCommand;
	extra.Create(NULL, text, NULL);

	bDel = TRUE; // always delete this one

	hbmImageWell = NULL;
	sizeImage.cx=sizeImage.cy=0;
}

// Constructor for transfer of a command button with a text and custom bitmap 
/* For use only when the button has just been created as a result of dragging
a new button which doesn't have a default bitmap

To simplify the destination's task, we pretend that the custom bitmap is an
image well with only one button inside it
*/
TRANSFER_TBBUTTON::TRANSFER_TBBUTTON(int nCommand, CString *text, HBITMAP hbmCustom, BOOL bLarge, BOOL bCustomText)
{
	ASSERT(!text->IsEmpty()); // although an empty string won't cause crashes, it's 
							 // probably useful to spot it here in case validation
							 // failed upstream
	ASSERT(nCommand!=0);
	ASSERT(hbmCustom!=NULL);

	lpDataCallback = NULL;

	nStyle=TBBS_CUSTOMBITMAP | TBBS_TEXTUAL | TBBS_GLYPH;
	if(bCustomText)
	{
		nStyle |= TBBS_CUSTOMTEXT;
	}
	nID=nCommand;
	iImage=0;
	bDel = FALSE;
	extra.Create(NULL, new CString(*text), NULL);

	sizeImage=CCustomBar::GetDefaultBitmapSize(bLarge);

	// fake the image well as the custom bitmap bitmap
	iImage=0;
	hbmImageWell = hbmCustom;
}

void TRANSFER_TBBUTTON::LoadCommandBitmap(BOOL bLarge)
{
	if((nStyle & TBBS_GLYPH) &&
		nID!=0)
	{
		if(hbmImageWell!=NULL &&
			iImage!=-1)
		{
			// first decide whether what we've got now is fine
			if(nStyle & TBBS_CUSTOMBITMAP)
			{
				return;
			}

			CSize sizeNewImage=CCustomBar::GetDefaultBitmapSize(bLarge);

			if(sizeNewImage==sizeImage)
			{
				return;
			}

			sizeImage=sizeNewImage;

			if(bDel)
			{
				::DeleteObject(hbmImageWell);
			}

			hbmImageWell=NULL;
			iImage=-1;
		}
		
		// at this point, we know we want to try to get one from the command table
		if(theApp.GetCommandBitmap(nID, &hbmImageWell, &iImage, bLarge))
		{
			return;
		}
		
		// should never reach here, since we shouldn't be tbbs glyph if we don't have one.
		ASSERT(FALSE);
	}
}

TRANSFER_TBBUTTON::~TRANSFER_TBBUTTON()
{
	if (bDel && hbmImageWell != NULL)
		::DeleteObject(hbmImageWell);

	if (bDel)
	{
		// we need to delete the transient items (bitmaps, strings), but the window
		// is always retained to save unnecessary recreation.
		extra.SetControl(NULL);
		extra.Destroy();
	}

	if (lpDataCallback != NULL)
		(*lpDataCallback)(dwData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\undoctl.cpp ===
// undoctl.cpp : implementation of undo/redo controls
//

#include "stdafx.h"
#include "undoctl.h"
#include "util.h"
#include "resource.h"
#include "ctl3d.h"
#include "bardockx.h"
#include <process.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// These two WM_ messages are sent to the current active frame in
// order to get the strings used for filling the dropdown list for
// the undo/redo controls.
UINT NEAR WM_GETUNDOSTRING = RegisterMessage("GetUndoString");
UINT NEAR WM_GETREDOSTRING = RegisterMessage("GetRedoString");
UINT NEAR WM_DESTROYSELF = RegisterMessage("DestroySelf");

/////////////////////////////////////////////////////////////////////////////
// CDropControl

BEGIN_MESSAGE_MAP(CDropControl, CWnd)
	//{{AFX_MSG_MAP(CDropControl)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_TIMER()
	ON_WM_KILLFOCUS()
	ON_WM_ENABLE()
	ON_REGISTERED_MESSAGE(DSM_BARSIZECHANGING,OnBarSizeChanging)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CDropControl, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CDropControl construction/destruction

CDropControl::CDropControl()
{
	m_buttonState = BS_DEFAULT;
	m_bShowList = FALSE;
	m_pMainWnd = NULL;

	// adopt correct initial sizes
	SetButtonSize(theApp.m_bLargeToolBars);
}

CDropControl::~CDropControl()
{
}

BOOL CDropControl::Create(DWORD dwStyle, const RECT& rect,
                          CWnd* pParentWnd, UINT nID,
                          CCreateContext* pContext)
{
	CRect rc = CRect(rect.left, rect.top, rect.left + m_width, rect.top + m_height);

	if (! CWnd::Create(NULL, "", dwStyle, rc, pParentWnd, nID, pContext))
		return FALSE;

	m_pMainWnd = pParentWnd;
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDropControl drawing
void CDropControl::OnPaint()
{
	CRect rc;
	GetUpdateRect(&rc);
	if (rc.IsRectEmpty())	// happens when UpdateWindow called.
		return;
	
	CPaintDC dc(this); // device context for painting
	int offset = 3;
	BOOL bEnabled = IsWindowEnabled();
	
	UINT idButton;
	if ((m_buttonState == BS_LCLICK) && PointOnControl(m_mousePos))
	{
		if(m_bLarge) {
			idButton = theApp.m_bWin4 ? IDB_DROPCL95LARGE : IDB_DROPCLLARGE;
		} else {
			idButton = theApp.m_bWin4 ? IDB_DROPCL95 : IDB_DROPCL;
		}
	}
	else if ((m_buttonState == BS_RCLICK) && PointOnControl(m_mousePos))
	{
		if(m_bLarge) {
			idButton = theApp.m_bWin4 ? IDB_DROPCR95LARGE : IDB_DROPCRLARGE;
		} else {
			idButton = theApp.m_bWin4 ? IDB_DROPCR95 : IDB_DROPCR;
		}
	}
	else if (bEnabled)
	{
		if(m_buttonState == BS_EXTRUDED)
		{
			if(m_bLarge) {
				idButton = theApp.m_bWin4 ? IDB_DROP95LARGE : IDB_DROPLARGE;
			} else {
				idButton = theApp.m_bWin4 ? IDB_DROP95 : IDB_DROP;
			}
		}
		else
		{
			if(m_bLarge) {
				idButton = theApp.m_bWin4 ? IDB_DROP95LARGEFLAT : IDB_DROPLARGEFLAT;
			} else {
				idButton = theApp.m_bWin4 ? IDB_DROP95FLAT : IDB_DROPFLAT;
			}
		}
	}
	else
	{
		if(m_bLarge) {
			idButton = theApp.m_bWin4 ? IDB_DROPDISABLED95LARGE : IDB_DROPDISABLEDLARGE;
		} else {
			idButton = theApp.m_bWin4 ? IDB_DROPDISABLED95 : IDB_DROPDISABLED;
		}
	}

	// Stolen and adapted from MFC CToolBar::LoadBitmap [marklam 1-20-95]
	HINSTANCE hInstImageWell = AfxFindResourceHandle(MAKEINTRESOURCE(idButton), RT_BITMAP);
	HRSRC hRsrcImageWell = ::FindResource(hInstImageWell, MAKEINTRESOURCE(idButton), RT_BITMAP);
	HBITMAP hbitmap = AfxLoadSysColorBitmap(hInstImageWell, hRsrcImageWell);
	
	CDC dcTemp;
	dcTemp.CreateCompatibleDC(&dc);
	CBitmap* pOldBitmap = dcTemp.SelectObject(CBitmap::FromHandle(hbitmap));
	dc.BitBlt(rc.left, rc.top, rc.right, rc.bottom, &dcTemp, rc.left, rc.top, SRCCOPY);
	dcTemp.SelectObject(pOldBitmap);
	::DeleteObject(hbitmap);
	
	DrawArrow(dc, dcTemp, offset, offset, bEnabled);
}

void CDropControl::DrawArrow(CDC& dc, CDC& dcTemp, int xdest, int ydest, BOOL bEnabled)
{
	UINT idButton;
	if(m_bLarge) {
		idButton=bEnabled ? m_idLargeEnabledButton : m_idLargeDisabledButton;
	} else {
		idButton=bEnabled ? m_idSmallEnabledButton : m_idSmallDisabledButton;
	}

	// Stolen and adapted from MFC CToolBar::LoadBitmap [marklam 1-21-95]
	HINSTANCE hInstImageWell = AfxFindResourceHandle(MAKEINTRESOURCE(idButton), RT_BITMAP);
	HRSRC hRsrcImageWell = ::FindResource(hInstImageWell, MAKEINTRESOURCE(idButton), RT_BITMAP);
	HBITMAP hbitmap = AfxLoadSysColorBitmap(hInstImageWell, hRsrcImageWell);
	
	CBitmap* pOldBitmap = dcTemp.SelectObject(CBitmap::FromHandle(hbitmap));
	dc.BitBlt(xdest, ydest, m_bLarge ? largeImageWidth : smallImageWidth, 
							m_bLarge ? largeImageHeight : smallImageHeight,
							&dcTemp, 0, 0, SRCCOPY);
	dcTemp.SelectObject(pOldBitmap);
	::DeleteObject(hbitmap);
}

/////////////////////////////////////////////////////////////////////////////
// CDropControl message handlers

LRESULT CDropControl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LONG lResult;

	if (DkPreHandleMessage(GetSafeHwnd(),
		message, wParam, lParam, &lResult))
	{
		return lResult;
	}
	
	return CWnd::WindowProc(message, wParam, lParam);
}

void CDropControl::OnLButtonDown(UINT nFlags, CPoint point)
{
	ASSERT(PointOnControl(point));
	ASSERT(m_buttonState != BS_LCLICK);
	ASSERT(m_buttonState != BS_RCLICK);

	if (m_buttonState == BS_DEFAULT ||
		m_buttonState == BS_EXTRUDED)
	{
		// user clicks on control; enter LCLICK or RCLICK state as appropriate
		if (PointOnLeft(point))
			SetState(BS_LCLICK);
		else
			SetState(BS_RCLICK);
	}
	else
	{
		// user clicks on control while in drop state; collapse dropdown
		ASSERT(m_buttonState == BS_DROP);
		SetState(BS_EXTRUDED);
	}
	
	m_mousePos = point;
}

void CDropControl::OnLButtonUp(UINT nFlags, CPoint point)
{
	switch(m_buttonState)
	{
		case BS_DEFAULT:
			break;

		case BS_LCLICK:
			if (PointOnControl(point))
				UndoEvents(1);
			break;
		
		case BS_RCLICK:
			if (PointOnControl(point))
			{
				SetState(BS_DROP);
				InvalidateRight();
				return;
			}
			
			// user released the mouse somewhere other than on the control
			// while the dropdown was shown.  We may need to undo a bunch
			// of items.
			if (! (PointOnScrollDown(point) || PointOnScrollUp(point)))
				UndoEvents(CalcSel(point) + 1);
			else
				UndoEvents(m_undoList.GetSel() + 1);
			break;
		
		case BS_DROP:
			// if our mode cancellation code is working, this can't happen
			break;

		case BS_EXTRUDED:
			return;
	}

	SetState(BS_EXTRUDED);
}

void CDropControl::OnEnable(BOOL bEnable)
{
	if(!bEnable)
	{
		if(m_buttonState != BS_DEFAULT)
		{
			SetState(BS_DEFAULT);
		}
	}
}

void CDropControl::OnMouseMove(UINT nFlags, CPoint point)
{
	switch (m_buttonState)
	{
		case BS_LCLICK:
			if (PointOnControl(point) != PointOnControl(m_mousePos))
				InvalidateLeft();
			break;
			
		case BS_RCLICK:
			if (PointOnControl(point) != PointOnControl(m_mousePos))
				InvalidateRight();
			
			if (! (PointOnScrollDown(point) || PointOnScrollUp(point)))
				m_undoList.SetSel(CalcSel(point));
			
			break;
		
		case BS_DROP:
			break;

		case BS_DEFAULT:
			{
				if (theApp.ShouldExtrude())
				{
					SetState(BS_EXTRUDED);
				}
			}
			break;

		case BS_EXTRUDED:
			if(IsWindowEnabled())
			{
				CPoint screenPoint=point;
				ClientToScreen(&point);
				if(CWnd::WindowFromPoint(point)!=this)
				{
					// time to be unextruded
					SetState(BS_DEFAULT);
				}
			}
			break;
		
		default:
			ASSERT(FALSE);
	}
	
	m_mousePos = point;
}

void CDropControl::OnListBoxLButtonDown(UINT nFlags, CPoint point)
{
	ASSERT(m_buttonState == BS_DROP);
	
	// called when the user clicks directly on the listbox.
	SetState(BS_RCLICK);
	m_undoList.SetSel(CalcSel(point));
	m_mousePos = point;
}

void CDropControl::OnListBoxLButtonUp(UINT nFlags, CPoint point)
{
	// FUTURE - if our mode cancellation stuff is working, this should
	// never happen because any LButtonDown event not on one of our
	// windows should collapse the dropdown.
	ASSERT(m_buttonState == BS_DROP);
	CancelModes();
}

LRESULT CDropControl::OnBarSizeChanging(WPARAM wParam, LPARAM lParam)
{
	if(lParam==_getpid())
	{
		SetButtonSize(wParam);

		// resize the window
		SetWindowPos(NULL,0,0,m_width,m_height,SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOREDRAW);
	}

	return 0;
}

void CDropControl::SetButtonSize(BOOL bLarge)
{
	m_bLarge=bLarge;
	if(bLarge) {
		m_width=largeWidth;
		m_height=largeHeight;
		m_leftWidth=largeLeftWidth;
	} else {
		m_width=smallWidth;
		m_height=smallHeight;
		m_leftWidth=smallLeftWidth;
	}
}

int CDropControl::GetExpectedWidth(void)
{
	return(theApp.m_bLargeToolBars ? largeWidth : smallWidth);
}

int CDropControl::GetExpectedHeight(void)
{
	return(theApp.m_bLargeToolBars ? largeHeight : smallHeight);
}

BOOL CDropControl::PointOnControl(CPoint point)
{
	return ((point.x <= m_width) && (point.x >= 0) &&
	        (point.y <= m_height) && (point.y >= 0));
}

BOOL CDropControl::PointOnLeft(CPoint point)
{
	return (point.x <= m_leftWidth);
}

BOOL CDropControl::PointOnListBox(CPoint point)
{
	if (!m_bShowList)
		return FALSE;
	
	CRect rc;
	m_undoList.m_listBox.GetWindowRect(&rc);
	ScreenToClient(&rc);
	
	return rc.PtInRect(point);
}

BOOL CDropControl::PointOnScrollDown(CPoint point)
{
	if (!m_bShowList)
		return FALSE;
	
	CRect rc, rcListBox;
	m_undoList.m_listBox.GetWindowRect(&rcListBox);
	m_undoList.GetWindowRect(&rc);

	ClientToScreen(&point);
	
	return (rc.PtInRect(point) && (point.y >= rcListBox.bottom));
}

BOOL CDropControl::PointOnScrollUp(CPoint point)
{
	if (!m_bShowList)
		return FALSE;
	
	CRect rc, rcListBox;
	m_undoList.m_listBox.GetWindowRect(&rcListBox);
	m_undoList.GetWindowRect(&rc);
	
	// fudge factor to provide a good-sized upwards scroll region
	rc.top = rc.top - CUndoList::STATUSHEIGHT - CUndoList::BORDERSIZE * 2;

	ClientToScreen(&point);
	return (rc.PtInRect(point) && (point.y < rcListBox.top));
}

int CDropControl::CalcSel(CPoint point)
{
	ASSERT (m_bShowList);
	
	ClientToScreen(&point);
	return m_undoList.CalcSel(point);
}

void CDropControl::OnTimer(UINT nIDEvent)
{
	ASSERT(nIDEvent == ID_TIMER);

	if (PointOnScrollDown(m_mousePos))
		m_undoList.ScrollDown();
	else if (PointOnScrollUp(m_mousePos) && !PointOnControl(m_mousePos))
		m_undoList.ScrollUp();
}

void CDropControl::UndoEvents(int n)
{
	// Send an appropriate number of ID_EDIT_UNDO or ID_EDIT_REDO
	// commands to the main frame.
	while (n-- > 0)
		m_pMainWnd->SendMessage(WM_COMMAND, GetDlgCtrlID(), 0);
}

void CDropControl::SetState(int bsState)
{
	// if the dropdown is collapsing, give the focus back to the current
	// active window.
//	FUTURE: No, this will cause a CancelMode in CDropControl::OnKillFocus.
//	if (m_buttonState == BS_DROP)
//		::SetFocus(::GetActiveWindow());
	
	// now adjust the mouse capture, timer state, and show/hide of the
	// dropdown list as appropriate for the new state.

	switch (bsState)
	{
		case BS_LCLICK:
			ASSERT((m_buttonState == BS_DEFAULT) || (m_buttonState == BS_EXTRUDED));
			SetCapture();
			SetTimer(ID_TIMER, MSEC_TIMER, NULL);
			InvalidateLeft();
			break;

		case BS_RCLICK:
			ASSERT((m_buttonState == BS_DEFAULT) || (m_buttonState == BS_EXTRUDED) || (m_buttonState == BS_DROP));
			ShowList(TRUE);
			SetCapture();
			SetTimer(ID_TIMER, MSEC_TIMER, NULL);
			InvalidateRight();
			break;

		case BS_DROP:
			ASSERT(m_buttonState == BS_RCLICK);
			if(GetCapture()==this)
			{
				::ReleaseCapture();
			}
			KillTimer(ID_TIMER);
			m_undoList.SetSel(0);	// select first item by default
			SetFocus();
			break;

		case BS_DEFAULT:
			if ((m_buttonState == BS_DROP) || (m_buttonState == BS_RCLICK))
				ShowList(FALSE);
			
			if ((m_buttonState == BS_LCLICK) || (m_buttonState == BS_RCLICK) || (m_buttonState == BS_EXTRUDED))
			{
				if(GetCapture()==this)
				{
					::ReleaseCapture();
				}
			}

			if ((m_buttonState == BS_LCLICK) || (m_buttonState == BS_RCLICK))
			{
				KillTimer(ID_TIMER);
			}

			BOOL fWasExtruded;
			fWasExtruded = (m_buttonState == BS_EXTRUDED); // order is everything! bobz 
			m_buttonState = bsState;
			if (!fWasExtruded)  // no focus change just turning extruded off
				::SetFocus(theApp.GetActiveView());
			
			Invalidate();
			break;

		case BS_EXTRUDED:
			if ((m_buttonState == BS_DROP) || (m_buttonState == BS_RCLICK))
				ShowList(FALSE);

			if ((m_buttonState == BS_LCLICK) || (m_buttonState == BS_RCLICK))
			{
				KillTimer(ID_TIMER);
			}

			m_buttonState = bsState;
			SetCapture();
			Invalidate();
			break;
		
		default:
			ASSERT(FALSE);
	}
	
	m_buttonState = bsState;
}

void CDropControl::ShowList(BOOL bShow)
{
	if (bShow == m_bShowList)
		return;

	if (bShow)
	{
		CRect rc;
		GetWindowRect(&rc);
		rc.top = rc.bottom + 1;
		rc.bottom = rc.top + 100;
		rc.right = rc.left + 150;
		m_undoList.ShowList(TRUE, rc, this);
		m_bShowList = TRUE;
		SetFocus();
	}
	else
	{
		m_undoList.ShowList(FALSE, CRect(0,0,0,0), NULL);
		m_bShowList = FALSE;
	}
}

void CDropControl::InvalidateLeft()
{
	CRect rc = CRect(0, 0, m_leftWidth, m_height);
	InvalidateRect(&rc);
}

void CDropControl::InvalidateRight()
{
	CRect rc = CRect(m_leftWidth, 0, m_width, m_height);
	InvalidateRect(&rc);
}

void CDropControl::OnKillFocus(CWnd* pNewWnd)
{
	CancelModes();
	CWnd::OnKillFocus(pNewWnd);
}

UINT CDropControl::OnGetDlgCode()
{
	return DLGC_BUTTON | DLGC_WANTARROWS;
}

void CDropControl::CancelModes()
{
//	May be caused by a focus change in UndoEvents.
//	ASSERT(m_buttonState != BS_LCLICK);
//	ASSERT(m_buttonState != BS_RCLICK);
	
	if (m_buttonState != BS_DEFAULT)
		SetState(BS_DEFAULT);
}


BOOL CDropControl::PreTranslateMessage(MSG* pMsg)
{
	if ((pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_SYSKEYDOWN))
	{
		switch (pMsg->wParam)
		{
			case VK_ESCAPE:
				CancelModes();
				return TRUE;
			
			case VK_RETURN:
				UndoEvents(m_undoList.GetSel() + 1);
				CancelModes();
				return TRUE;

			case VK_UP:
				m_undoList.SetSel(m_undoList.GetSel() - 1);
				return TRUE;
			
			case VK_DOWN:
				m_undoList.SetSel(m_undoList.GetSel() + 1);
				return TRUE;

			case VK_PRIOR:
				m_undoList.PageUp();
				return TRUE;

			case VK_NEXT:
				m_undoList.PageDown();
				return TRUE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}

void CDropControl::PostNcDestroy()
{
	delete this;
}

/////////////////////////////////////////////////////////////////////////////
// CUndoControl and CRedoControl
//
// The generic DropControl class obviously handles nearly everything, but
// there are a few things related to user interface display which must be
// done differently for the Undo and Redo buttons.

BEGIN_MESSAGE_MAP(CUndoControl, CDropControl)
	//{{AFX_MSG_MAP(CUndoControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CRedoControl, CDropControl)
	//{{AFX_MSG_MAP(CRedoControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUndoControl and CRedoControl construction/destruction

CUndoControl::CUndoControl()
{ 
	m_idSmallEnabledButton = IDB_UNDO;
	m_idSmallDisabledButton = IDB_UNDODISABLED;
	m_idLargeEnabledButton = IDB_UNDOLARGE;
	m_idLargeDisabledButton = IDB_UNDODISABLEDLARGE;
}

CUndoControl::~CUndoControl()
{ }

CRedoControl::CRedoControl()
{ 
	m_idSmallEnabledButton = IDB_REDO;
	m_idSmallDisabledButton = IDB_REDODISABLED;
	m_idLargeEnabledButton = IDB_REDOLARGE;
	m_idLargeDisabledButton = IDB_REDODISABLEDLARGE;
}

CRedoControl::~CRedoControl()
{ }

/////////////////////////////////////////////////////////////////////////////
// CUndoControl and CRedoControl drawing

void CUndoControl::GetStatusString(int i, CString& str)
{
	switch (i)
	{
		case 0:
			str.LoadString(IDS_UNDO_CANCEL);
			return;
		
		case 1:
			str.LoadString(IDS_UNDO_ONE);
			return;
		
		default:
			{
				CString strTemp;
				strTemp.LoadString(IDS_UNDO_N);
				
				sprintf(str.GetBufferSetLength(strTemp.GetLength() + 4),
				        strTemp, i);
				str.ReleaseBuffer();

				return;
			}
	}
}

void CRedoControl::GetStatusString(int i, CString& str)
{
	switch (i)
	{
		case 0:
			str.LoadString(IDS_UNDO_CANCEL);
			return;
		
		case 1:
			str.LoadString(IDS_REDO_ONE);
			return;
		
		default:
			{
				CString strTemp;
				strTemp.LoadString(IDS_REDO_N);
				
				sprintf(str.GetBufferSetLength(strTemp.GetLength() + 4),
				        strTemp, i);
				str.ReleaseBuffer();

				return;
			}
	}
}

void CUndoControl::FillUndoList(CListBox& listBox)
{
	// Get the full list of undo strings and put them in the specified
	// listbox.
	HWND hwndActive = theApp.GetActiveView();

	char szBuf [256];
	int nLevel = 0;
	
	while ((BOOL) ::SendMessage(hwndActive, WM_GETUNDOSTRING,
	                            nLevel++, (LPARAM)(LPSTR)&szBuf))
	{
		listBox.AddString(szBuf);
	}
}

void CRedoControl::FillUndoList(CListBox& listBox)
{
	// Get the full list of undo strings and put them in the specified
	// listbox.
	HWND hwndActive = theApp.GetActiveView();

	char szBuf [256];
	int nLevel = 0;
	
	while ((BOOL) ::SendMessage(hwndActive, WM_GETREDOSTRING,
	                            nLevel++, (LPARAM)(LPSTR)&szBuf))
	{
		listBox.AddString(szBuf);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CUndoList
//
// This is the dropdown window.  It contains a single listbox plus the
// "status rectangle" which has the "Undo n actions" text in it.

const char* v_pchDropWndClass = NULL;

CUndoList::CUndoList()
{
	if (v_pchDropWndClass == NULL)
		v_pchDropWndClass = AfxRegisterWndClass(CS_DBLCLKS | CS_SAVEBITS);
	
	ASSERT(v_pchDropWndClass != NULL);
}

CUndoList::~CUndoList()
{
}

void CUndoList::ShowList(BOOL bShow, CRect rc, CDropControl* pParent)
{
	if (bShow)
	{
		CString strUndoList;
		VERIFY(strUndoList.LoadString(IDS_UNDOLIST));

		DWORD dwBorder = (theApp.m_bWin4 ? 0L : WS_BORDER);
		DWORD dwEdge = WS_EX_TOPMOST |
			(theApp.m_bWin4 ? WS_EX_DLGMODALFRAME : 0L);

		CreateEx(dwEdge, v_pchDropWndClass, strUndoList, WS_POPUP | dwBorder,
			rc.left, rc.top, rc.Width(), rc.Height(), pParent->GetSafeHwnd(), NULL);

		m_listBox.Create(LBS_EXTENDEDSEL | LBS_NOTIFY | WS_VISIBLE |
			WS_CHILD | WS_VSCROLL | dwBorder,
			CRect(BORDERSIZE, BORDERSIZE, BORDERSIZE, BORDERSIZE),
			this, 0, pParent);

		if (theApp.m_bWin4)
			m_listBox.ModifyStyleEx(0L, WS_EX_CLIENTEDGE);
		else
			m_listBox.SubclassCtl3d(CTL3D_LISTBOX_CTL);

		pParent->FillUndoList(m_listBox);

		int nHeight = m_listBox.GetItemHeight(0);
		CRect rcList(0, 0, 0, nHeight * 6);
		AdjustWindowRectEx(rcList, m_listBox.GetStyle(), FALSE,
			m_listBox.GetExStyle());
		m_listBox.SetWindowPos(NULL, 0, 0,
			rc.Width() - BORDERSIZE * 2, rcList.Height(),
			SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);

		rc.bottom = rc.top + rcList.Height() + BORDERSIZE * 3 + STATUSHEIGHT;

		AdjustWindowRectEx(rc, GetStyle(), FALSE, GetExStyle());

		CDockWorker::LockWorker(TRUE);
		SetWindowPos(NULL, 0, 0, rc.Width(), rc.Height(),
			SWP_NOZORDER | SWP_NOMOVE | SWP_SHOWWINDOW);

		UpdateWindow();
	}
	else
	{
		m_listBox.DestroyWindow();
		PostMessage(WM_DESTROYSELF);
	}
}

BEGIN_MESSAGE_MAP(CUndoList, CWnd)
	//{{AFX_MSG_MAP(CUndoList)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_REGISTERED_MESSAGE(WM_DESTROYSELF, OnDestroySelf)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUndoList message handlers

void CUndoList::OnPaint()
{
	// we have to allow for the fact that this message might be delivered after the window has been deleted
	if(GetSafeHwnd()!=NULL)
	{
		CPaintDC dc(this); // device context for painting
		
		// calculate rects for window and status box
		CRect rc;
		GetClientRect(&rc);
		CRect rcStatus = CalcStatusRect(rc);
		
		dc.FillRect(&rc, GetSysBrush(COLOR_BTNFACE));
		dc.Draw3dRect(rcStatus, GetSysColor(COLOR_BTNSHADOW),
			GetSysColor(COLOR_BTNHIGHLIGHT));
		rcStatus.InflateRect(-1, -1);
		
		// draw appropriate text in the status box
		if(m_listBox.GetSafeHwnd()!=NULL)
		{
			int i = m_listBox.GetSelCount();
			ASSERT(i != LB_ERR);
			dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
			dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
			CFont* pFont = dc.SelectObject(GetStdFont(font_Normal));
			
			CString str;
			m_listBox.m_pDropControl->GetStatusString(i, str);
			dc.DrawText(str, -1, &rcStatus,
				DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
			dc.SelectObject(pFont);
		}
	}
}

// CalcStatusRect
//
// This calculates the rect used for drawing the status text.  The
// border around the status box is drawn one pixel outside this rect.
CRect CUndoList::CalcStatusRect(CRect rc)
{
	return CRect(rc.left + BORDERSIZE, rc.bottom - STATUSHEIGHT - BORDERSIZE,
				 rc.right - BORDERSIZE, rc.bottom - BORDERSIZE);
}

void CUndoList::SetSel(int index)
{
	int indexMax = m_listBox.GetCount() - 1;
	index = max(min(index, indexMax), -1);
	
	if (index == GetSel())
		return;

	if (index == 0)
		m_listBox.SetSel(0);
	else if (index > 0)
		m_listBox.SelItemRange(TRUE, 0, index);
	
	if (index < indexMax)
		m_listBox.SelItemRange(FALSE, index + 1, indexMax);
	
	// if we must scroll the listbox to keep the max selected
	// item in view, do so.
	if (index > m_listBox.GetBottomIndex())
		m_listBox.SetTopIndex(m_listBox.GetTopIndex() + index - m_listBox.GetBottomIndex());
	else if (index < m_listBox.GetTopIndex())
		m_listBox.SetTopIndex(index);

	// invalidate the status box
	CRect rc;
	GetClientRect(&rc);
	CRect rcStatus = CalcStatusRect(rc);
	rcStatus.InflateRect(-1, -1);
	InvalidateRect(&rcStatus);
}

int CUndoList::GetSel()
{
	return m_listBox.GetSelCount() - 1;
}

// CalcSel
//
// Takes a point (in screen coordinates) and returns the index of the
// indicated item.  A -1 means that no item is currently selected.
int CUndoList::CalcSel(CPoint point)
{
	CRect rc;
	m_listBox.GetWindowRect(&rc);
	
	if (! rc.PtInRect(point))
		return -1;

	// point is definitely in the listbox, compute the index
	int cPixels = point.y - rc.top;
	ASSERT(cPixels >= 0);
	ASSERT(cPixels <= rc.Height());
	
	int itemHeight = m_listBox.GetItemHeight(0);	// height in pixels
	ASSERT(itemHeight != LB_ERR);

	int index = (cPixels / itemHeight) + m_listBox.GetTopIndex();
	int count = m_listBox.GetCount();
	if (index > count - 1)
		index = count - 1;
	return index;
}

void CUndoList::ScrollDown()
{
	// Remember that "SetSel" scrolls the listbox to keep the current
	// selection in view.
	SetSel(m_listBox.GetBottomIndex() + 1);
}

void CUndoList::ScrollUp()
{
	SetSel(m_listBox.GetTopIndex() - 1);
}
// FUTURE: We already filter WM_LBUTTONDOWNS in PreTranslateMessge.  We will
//		  never get this message.
//
void CUndoList::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_listBox.m_pDropControl->CancelModes();
	return;
}

void CUndoList::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_listBox.m_pDropControl->CancelModes();
	return;
}

void CUndoList::PageDown()
{
	// find the index for the bottommost item, scroll it to
	// the top and select it.
	int index = m_listBox.GetBottomIndex();
	m_listBox.SetTopIndex(index);
	SetSel(index);
}

void CUndoList::PageUp()
{
	// find the index for the topmost item, scroll it to
	// the bottom and select the new topmost item.
	int bottomIndex = m_listBox.GetBottomIndex();
	int cRows = bottomIndex - m_listBox.GetTopIndex();
	
	int newTopIndex = max(m_listBox.GetTopIndex() - cRows, 0);
	
	m_listBox.SetTopIndex(newTopIndex);
	SetSel(newTopIndex);
}

LRESULT CUndoList::OnDestroySelf(WPARAM wParam, LPARAM lParam)
{
	DestroyWindow();
	CDockWorker::LockWorker(FALSE);

	return 0L;
}


/////////////////////////////////////////////////////////////////////////////
// CGhostListBox
//
// An almost-normal listbox which forwards all mouse events to its
// owner and won't accept the focus.

IMPLEMENT_DYNAMIC(CGhostListBox, CListBox)

CGhostListBox::CGhostListBox()
{
}

CGhostListBox::~CGhostListBox()
{
}

BOOL CGhostListBox::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID, CDropControl* pDropControl)
{
	m_pDropControl = pDropControl;
	
	if (!CListBox::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	SetFont(GetStdFont(font_Normal));
	return TRUE;
}

BEGIN_MESSAGE_MAP(CGhostListBox, CListBox)
	//{{AFX_MSG_MAP(CGhostListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGhostListBox message handlers

void CGhostListBox::OnLButtonDown(UINT nFlags, CPoint point)
{
	// convert to DropControl client coordinates
	ClientToScreen(&point);
	m_pDropControl->ScreenToClient(&point);
	m_pDropControl->OnListBoxLButtonDown(nFlags, point);
}

void CGhostListBox::OnLButtonUp(UINT nFlags, CPoint point)
{
	// convert to DropControl client coordinates
	ClientToScreen(&point);
	m_pDropControl->ScreenToClient(&point);
	m_pDropControl->OnListBoxLButtonUp(nFlags, point);
}

int CGhostListBox::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	// we don't want the listbox to steal activation away from the
	// DropControl when the user clicks on it.
	return MA_NOACTIVATE;
}

int CGhostListBox::GetBottomIndex()
{
	// Just like the standart CListBox::GetTopIndex function.
	// The bottom index is the top index plus the total number
	// of rows in the listbox.
	CRect rc;
	GetWindowRect(&rc);

	int itemHeight = GetItemHeight(0);	// height in pixels
	ASSERT(itemHeight != LB_ERR);

	int index = (rc.Height() / itemHeight) + GetTopIndex() - 1;
	index = min(index, GetCount());
	return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\undo.cpp ===
#include "stdafx.h"
#include "slob.h"
#include "util.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

CUndoSlob AFX_DATA theUndoSlob;


/////////////////////////////////////////////////////////////////////////////
//
// A CSlobSequence is a packed array of slob property changes or custom
// actions.  Each record contains a property or action id, a pointer to
// a slob, a property type, and a value (depending on the type).
//
// These sequences are used to store undo/redo information in theUndoSlob.
// Each undo/redo-able thing is contained in one CSlobSequence.
//


CSlobSequence::CSlobSequence() : CByteArray(), m_strDescription()
{
	SetSize(0, 100); // increase growth rate
	m_nCursor = 0;
}


CSlobSequence::~CSlobSequence()
{
	Cleanup();
}


// Pull an array of bytes out of the sequence.
//
void CSlobSequence::Retrieve(BYTE* rgb, int cb)
{
	for (int ib = 0; ib < cb; ib += 1)
		*rgb++ = GetAt(m_nCursor++);
}


// Pull a string out the sequence.
//
void CSlobSequence::RetrieveStr(CString& str)
{
	int nStrLen;
	RetrieveInt(nStrLen);
	if (nStrLen == 0)
	{
		str.Empty();
	}
	else
	{
		BYTE* pb = (BYTE*)str.GetBufferSetLength(nStrLen);
		for (int nByte = 0; nByte < nStrLen; nByte += 1)
			*pb++ = GetAt(m_nCursor++);
		str.ReleaseBuffer(nStrLen);
	}
}


// Traverse the sequence and remove any slobs that are contained within.
//
void CSlobSequence::Cleanup()
{
	m_nCursor = 0;
	while (m_nCursor < GetSize())
	{
		CUndoRecord rec;
		RetrieveRecord(rec);

		switch (rec.m_op)
		{
		default:
			TRACE1("Illegal undo opcode (%d)\n", rec.m_op);
			ASSERT(FALSE);

		case CUndoSlob::opAction:
			{
				int cbUndoRecord;
				RetrieveInt(cbUndoRecord);
				int ib = m_nCursor;
				rec.m_pSlob->DeleteUndoAction(this, rec.m_nPropID);
				m_nCursor = ib + cbUndoRecord;
			}
			break;

		case CUndoSlob::opIntProp:
		case CUndoSlob::opBoolProp:
			{
				int val;
				RetrieveInt(val);
			}
			break;

		case CUndoSlob::opLongProp:
			{
				long val;
				RetrieveLong(val);
			}
			break;

		case CUndoSlob::opDoubleProp:
			{
				double num;
				RetrieveNum(num);
			}
			break;

		case CUndoSlob::opStrProp:
			{
				CString str;
				RetrieveStr(str);
			}
			break;

		case CUndoSlob::opSlobProp:
			{
				CSlob* pSlobVal;
				RetrievePtr(pSlobVal);
			}
			break;

		case CUndoSlob::opRectProp:
			{
				CRect rcVal;
				RetrieveRect(rcVal);
			}
			break;

		case CUndoSlob::opPointProp:
			{
				CPoint ptVal;
				RetrievePoint(ptVal);
			}
			break;
		}
	}
}


// Start looking right after the begin op for ops we really need to keep.
// If none are found, the entire record is discarded below.  (For now, we
// only throw away records that are empty or consist only of selection
// change ops.)
//
BOOL CSlobSequence::IsUseful(CSlob*& pLastSlob, int& nLastPropID)
{
	CUndoRecord rec;

	m_nCursor = 0;
	while (m_nCursor < GetSize())
	{
		RetrieveRecord(rec);
		if (rec.m_op != CUndoSlob::opAction)
			break;

		int cbActionRecord;
		RetrieveInt(cbActionRecord);

		if (rec.m_nPropID != A_PreSel && rec.m_nPropID != A_PostSel)
		{
			// Back cursor up to the opcode...
			m_nCursor -= sizeof (int) + sizeof (CUndoRecord);
			break;
		}

		m_nCursor += cbActionRecord;
	}

	if (m_nCursor == GetSize())
		return FALSE; // sequnce consists only of selection changes


	// Now check if we should throw this away because it's just
	// modifying the same string or rectangle property as the last
	// undoable operation...  This is an incredible hack to implement
	// a "poor man's" Multiple-Consecutive-Changes-to-a-Property-as-
	// One-Operation feature.

	if (rec.m_op == CUndoSlob::opStrProp || rec.m_op == CUndoSlob::opRectProp)
	{
		if (rec.m_nPropID == (WORD) nLastPropID && rec.m_pSlob == pLastSlob &&
			rec.m_nPropID != P_ID && rec.m_nPropID != P_Value)
		{
			return FALSE; // not useful
		}

		nLastPropID = rec.m_nPropID;
		pLastSlob = rec.m_pSlob;
	}

	m_nCursor = 0;
	return TRUE;
}


// Perform the property changes and actions listed in the sequence.
//
void CSlobSequence::Apply()
{
	m_nCursor = 0;
	while (m_nCursor < GetSize())
	{
		CUndoRecord rec;
		RetrieveRecord(rec);

		switch (rec.m_op)
		{
		default:
			TRACE1("Illegal undo opcode (%d)\n", rec.m_op);
			ASSERT(FALSE);

		case CUndoSlob::opAction:
			rec.m_pSlob->UndoAction(this, rec.m_nPropID);
			break;

		case CUndoSlob::opIntProp:
		case CUndoSlob::opBoolProp:
#ifdef _WIN32
		case CUndoSlob::opLongProp:
#endif
			{
				int val;
				RetrieveInt(val);
				if (rec.m_pBag != NULL)
				{
					rec.m_pBag->SetIntProp(rec.m_pSlob, rec.m_nPropID, val);
					rec.m_pSlob->InformDependants(rec.m_nPropID);
				}
				else
				{
					rec.m_pSlob->SetIntProp(rec.m_nPropID, val);
				}
			}
			break;

#ifndef _WIN32
		case CUndoSlob::opLongProp:
			{
				long val;
				RetrieveLong(val);
				rec.m_pSlob->SetLongProp(rec.m_nPropID, val);
			}
			break;
#endif

		case CUndoSlob::opDoubleProp:
			{
				double num;
				RetrieveNum(num);
				rec.m_pSlob->SetDoubleProp(rec.m_nPropID, num);
			}
			break;

		case CUndoSlob::opStrProp:
			{
				CString str;
				RetrieveStr(str);
				rec.m_pSlob->SetStrProp(rec.m_nPropID, str);
			}
			break;

		case CUndoSlob::opSlobProp:
			{
				CSlob* pSlobVal;
				RetrievePtr(pSlobVal);
				rec.m_pSlob->SetSlobProp(rec.m_nPropID, pSlobVal);
			}
			break;

		case CUndoSlob::opRectProp:
			{
				CRect rcVal;
				RetrieveRect(rcVal);
				rec.m_pSlob->SetRectProp(rec.m_nPropID, rcVal);
			}
			break;

		case CUndoSlob::opPointProp:
			{
				CPoint ptVal;
				RetrievePoint(ptVal);
				rec.m_pSlob->SetPointProp(rec.m_nPropID, ptVal);
			}
			break;
		}
	}
}



/////////////////////////////////////////////////////////////////////////////

CUndoStack::CUndoStack()
{
	m_nRedoSeqs = 0;
	m_nMaxLevels = theUndoSlob.GetMaxLevels();
}

CUndoStack::~CUndoStack()
{
	Flush();
	
	if (theUndoSlob.m_pStack == this)
		theUndoSlob.m_pStack = NULL;
}

void CUndoStack::Flush()
{
	POSITION pos = m_seqs.GetHeadPosition();
	while (pos != NULL)
		delete m_seqs.GetNext(pos);
	m_seqs.RemoveAll();
	
	pos = m_objects.GetHeadPosition();
	while (pos != NULL)
		delete m_objects.GetNext(pos);
	m_objects.RemoveAll();
	
	m_nRedoSeqs = 0;
}

void CUndoStack::FlushRedo()
{
	while (m_nRedoSeqs > 0)
	{
		delete m_seqs.RemoveHead();
		m_nRedoSeqs -= 1;
	}
}

void CUndoStack::Truncate()
{
	POSITION pos = m_seqs.FindIndex(m_nRedoSeqs + m_nMaxLevels);
	while (pos != NULL)
	{
#ifdef _DEBUG
	if (GetLogUndoFlag())
		TRACE("Undo record fell off the edge...\n");
#endif
		POSITION posRemove = pos;
		delete m_seqs.GetNext(pos);
		m_seqs.RemoveAt(posRemove);
	}
}

/////////////////////////////////////////////////////////////////////////////


IMPLEMENT_DYNAMIC(CUndoSlob, CSlob)


CUndoSlob::CUndoSlob() : CSlob()
{
	ASSERT(this == &theUndoSlob); // only one of these is allowed!

	m_nRecording = 0;
	m_nMaxLevels = DEFAULT_UNDO_LEVELS;
	m_pLastSlob = NULL;
	m_nLastPropID = 0;
	m_nPauseLevel = 0;
	m_pSel = NULL;
	m_nSerial = 0;
	m_bFlushAtEnd = FALSE;
}


CUndoSlob::~CUndoSlob()
{
}


CObList* CUndoSlob::GetContentList()
{
	if (m_pStack == NULL)
		return NULL;
	
	return &m_pStack->m_objects;
}


// Is there something to undo in the active CSlobWnd?
//
BOOL CUndoSlob::CanUndo() const
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	if (pWnd == NULL)
		return FALSE;
	
	return pWnd->CanUndo();
}


// Is there something to redo in the active CSlobWnd?
//
BOOL CUndoSlob::CanRedo() const
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	if (pWnd == NULL)
		return FALSE;
	
	return pWnd->CanRedo();
}


// Set the maximum number of sequences that can be held at once.
//
void CUndoSlob::SetMaxLevels(int nLevels)
{
	if (nLevels < 1)
		return;

	m_nMaxLevels = nLevels;
	
	// ISSUE: Should this trim the stacks in open windows?
}


// Returns the maximum number of sequences that can be held at once.
//
int CUndoSlob::GetMaxLevels() const
{
	return m_nMaxLevels;
}


// Call this to after a sequence is recorded to prevent the next
// sequence from being coalesced with it.
//
void CUndoSlob::FlushLast()
{
	m_pLastSlob = NULL;
	m_nLastPropID = 0;
}


// Call this at the start of an undoable user action.  Calls may be nested
// as long as each call to BeginUndo is balanced with a call to EndUndo.
// Only the "outermost" calls actually have any affect on the undo buffer.
//
// The szCmd parameter should contain the text that you want to appear
// after "Undo" in the Edit menu.
//
// The pSelection parameter should point to the selection (CMultiSlob) that
// the operation will affect (pass the "source" selection when two selections
// are involved, or NULL if no selection changes should be recorded).
//
// The bResetCursor parameter is only used internally to modify behaviour
// when recording redo sequences and you should NOT pass anything for this
// parameter.
//
void CUndoSlob::BeginUndo(const char* szCmd,
	CSlobWnd* pSlobWnd /* = NULL */, BOOL bResetCursor /* = TRUE*/)
{
#ifdef _DEBUG
	if (GetLogUndoFlag())
		TRACE2("BeginUndo: %s (%d)\n", szCmd, m_nRecording);
#endif

	if (pSlobWnd == NULL)
		pSlobWnd = GetActiveSlobWnd();

	if ((pSlobWnd == NULL) || (!pSlobWnd->EnableUndo()))
		return;
	
	// Handle nesting
	m_nRecording += 1;
	if (m_nRecording != 1)
		return;
	
	ASSERT(m_pStack == NULL || m_pStack == pSlobWnd->m_pUndoStack);
	m_pStack = pSlobWnd->m_pUndoStack;

	if (bResetCursor) // this is the default case
	{
		// Disable Redo for non-Undo/Redo commands...
		m_pStack->FlushRedo();
	}

	m_pCurSeq = new CSlobSequence;
	m_pCurSeq->m_strDescription = szCmd;
	m_pCurSeq->m_nSerial = m_nSerial++;

	m_pSel = NULL;

	if (pSlobWnd != NULL && !InUndoRedo())
	{
		CMultiSlob* pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
		if (pSelection != NULL &&
			pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		{
			OnPreSel(pSelection);
			m_pSel = pSelection;
		}
	}

	m_pDragDropObject = NULL;
	
	m_bFlushAtEnd = FALSE;
}

void CUndoSlob::BeginUndo(UINT nID,
	CSlobWnd* pSlobWnd /* = NULL */, BOOL bResetCursor /* = TRUE*/)
{
	CString str;

	VERIFY( str.LoadString( nID ) );
	BeginUndo( str, pSlobWnd, bResetCursor );
}

// Call this at the end of an undoable user action to cause the sequence
// since the BeginUndo to be stored in the undo buffer.
//
void CUndoSlob::EndUndo(BOOL bAbort /*=FALSE*/)
{
#ifdef _DEBUG
	if (GetLogUndoFlag())
		TRACE1("EndUndo: %d\n", m_nRecording - 1);
#endif

	if (m_nRecording == 0)
		return;

	if (bAbort)
		m_nRecording = 0;
	// Handle nesting
	else if (--m_nRecording != 0)
		return;
	
	if (bAbort || m_pCurSeq == NULL ||
		!m_pCurSeq->IsUseful(m_pLastSlob, m_nLastPropID))
	{
		// Remove empty or otherwise useless undo records!
		delete m_pCurSeq;
		m_pCurSeq = NULL;
		m_pStack = NULL;
		return;
	}

	if (m_pSel != NULL && !InUndoRedo())
		OnPostSel(m_pSel);

	// We'll keep it, add it to the list...
	if (m_pStack->m_nRedoSeqs > 0)
	{
		// Add AFTER any redo sequences we have but before any undo's
		POSITION pos = m_pStack->m_seqs.FindIndex(m_pStack->m_nRedoSeqs - 1);
		ASSERT(pos != NULL);
		m_pStack->m_seqs.InsertAfter(pos, m_pCurSeq);
	}
	else
	{
		// Just add before any other undo sequences
		m_pStack->m_seqs.AddHead(m_pCurSeq);
	}
	
	m_pCurSeq = NULL;
	
	m_pStack->Truncate(); // Make sure the undo buffer doesn't get too big!
	m_pStack = NULL;
	
	if (m_bFlushAtEnd)
		Flush();
	
	if (m_pDragDropObject != NULL)
	{
		CSlobWnd* pSourceWnd = m_pDragDropObject->GetSlobWnd();
		m_nRecording = 1;
		m_pStack = pSourceWnd->m_pUndoStack;
		
		m_pStack->FlushRedo();
		
		m_pCurSeq = new CSlobSequence;
		VERIFY( m_pCurSeq->m_strDescription.LoadString( IDS_MOVETO ) );
		m_pCurSeq->m_nSerial = m_nSerial++;
		
		m_pSel = NULL;
		m_bFlushAtEnd = FALSE;
		
		m_pDragDropObject = NULL;
	}
}


// Core of both the undo and the redo commands.  Returns TRUE if the
// undo stack is still around so a reversing record was generated.
//
BOOL CUndoSlob::DoUndoRedo(CSlobWnd* pSlobWnd)
{
	CWaitCursor waitCursor;

	ASSERT(m_pStack == NULL || m_pStack == pSlobWnd->m_pUndoStack);
	m_pStack = pSlobWnd->m_pUndoStack;
	
	if (m_pStack->m_nRedoSeqs == m_pStack->m_seqs.GetCount())
	{
		m_pStack = NULL;
		return FALSE; // nothing to undo!
	}

	m_bPerformingUndoRedo = TRUE;

	POSITION pos = m_pStack->m_seqs.FindIndex(m_pStack->m_nRedoSeqs);
	ASSERT(pos != NULL);
	CSlobSequence* pSeq = (CSlobSequence*)m_pStack->m_seqs.GetAt(pos);

	BeginUndo(pSeq->m_strDescription, pSlobWnd, FALSE); // Setup Redo

	// Remove this sequence after BeginUndo so the one inserted
	// there goes to the right place...
	m_pStack->m_seqs.RemoveAt(pos);
	
	pSeq->Apply(); // this may delete m_pStack and set it to NULL
	
	CUndoStack* pStack = m_pStack; // will get set to NULL in EndUndo
	FlushLast();
	EndUndo();
	FlushLast();
	m_pStack = pStack; // caller still needs this

	m_bPerformingUndoRedo = FALSE;

	delete pSeq;
	
	return pStack != NULL;
}


// Call this to perform an undo command.
//
void CUndoSlob::DoUndo(CSlobWnd* pWnd)
{
	ASSERT(pWnd != NULL);
	
	CUndoStack* pStack = pWnd->m_pUndoStack;
	if (pStack->m_nRedoSeqs == pStack->m_seqs.GetCount())
		return;
	
	POSITION pos = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs);
	long nSerial = ((CSlobSequence*)pStack->m_seqs.GetAt(pos))->m_nSerial;

	pWnd->EnableUpdates(FALSE);
	BOOL bSuccess = DoUndoRedo(pWnd);
	pWnd->EnableUpdates(TRUE);

	if (bSuccess)
	{
		// Do not bump the redo count if the undo flushed the buffer!  (This
		// happens when a resource is pasted/dropped, then opened, then a
		// property in it changes, and the user undoes back to before the
		// paste.)
		
		ASSERT(m_pStack != NULL);
		if (m_pStack->m_seqs.GetCount() != 0)
			m_pStack->m_nRedoSeqs += 1;
	
		m_pStack = NULL;
	}
	
	ASSERT(m_pStack == NULL);
	
	
	// Handle undo in linked windows...
	pos = CSlobWnd::GetHeadSlobWndPosition();
	while (pos != NULL)
	{
        CSlobWnd* pSlobWnd = CSlobWnd::GetNextSlobWnd(pos);
		
		pStack = pSlobWnd->m_pUndoStack;
		POSITION pos2 = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs);
		if (pos2 != NULL &&
			nSerial == ((CSlobSequence*)pStack->m_seqs.GetAt(pos2))->m_nSerial)
		{
			Link();
			DoUndo(pSlobWnd);
		}
	}
}


// Call this to perform a redo command.
//
void CUndoSlob::DoRedo(CSlobWnd* pWnd)
{
	ASSERT(pWnd != NULL);
	
	CUndoStack* pStack = pWnd->m_pUndoStack;
	
	if (pStack->m_nRedoSeqs == 0)
		return; // nothing in redo buffer
	
	POSITION pos = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs - 1);
	long nSerial = ((CSlobSequence*)pStack->m_seqs.GetAt(pos))->m_nSerial;
TRACE1("Redoing action %ld\n", nSerial);
	
	pStack->m_nRedoSeqs -= 1;
	
	pWnd->EnableUpdates(FALSE);
	DoUndoRedo(pWnd);
	pWnd->EnableUpdates(TRUE);
	
	m_pStack = NULL;
	
	
	// Handle redo in linked windows...
	pos = CSlobWnd::GetHeadSlobWndPosition();
	while (pos != NULL)
	{
        CSlobWnd* pSlobWnd = CSlobWnd::GetNextSlobWnd(pos);
		
		pStack = pSlobWnd->m_pUndoStack;
		if (pStack->m_nRedoSeqs < 1)
			continue;
		POSITION pos2 = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs - 1);
		if (pos2 != NULL &&
			nSerial == ((CSlobSequence*)pStack->m_seqs.GetAt(pos2))->m_nSerial)
		{
			Link();
			DoRedo(pSlobWnd);
		}
	}
}


// Generate a string appropriate for the undo menu command.
//
void CUndoSlob::GetUndoString(CString& strUndo, int nLevel)
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	ASSERT(pWnd != NULL);
	CUndoStack* pStack = pWnd->m_pUndoStack;
	
	if (pStack->m_nRedoSeqs + nLevel >= pStack->m_seqs.GetCount())
	{
		strUndo.Empty();
		return;
	}
	
	POSITION pos = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs + nLevel);
	strUndo = ((CSlobSequence*)pStack->m_seqs.GetAt(pos))->m_strDescription;
	
#if 0 // FUTURE: move undo formatting to shell
	// FUTURE: NYI: if nLevel > 0, return string for undo control
	
	static CString NEAR strUndoTemplate;
	
	if (strUndoTemplate.IsEmpty())
		VERIFY(strUndoTemplate.LoadString(IDS_UNDO));
	
	CString strUndoCmd;
	
	if (CanUndo())
	{
		CSlobWnd* pWnd = GetActiveSlobWnd();
		ASSERT(pWnd != NULL);
		CUndoStack* pStack = pWnd->m_pUndoStack;

		POSITION pos = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs);
		strUndoCmd = ((CSlobSequence*)
			pStack->m_seqs.GetAt(pos))->m_strDescription;
	}

	int cchUndo = strUndoTemplate.GetLength() - 2; // less 2 for "%s"
	sprintf(strUndo.GetBufferSetLength(cchUndo + strUndoCmd.GetLength()),
		strUndoTemplate, (const char*)strUndoCmd);
	strUndo.ReleaseBuffer();
#endif
}


// Generate a string appropriate for the redo menu command.
//
void CUndoSlob::GetRedoString(CString& strRedo, int nLevel)
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	ASSERT(pWnd != NULL);
	CUndoStack* pStack = pWnd->m_pUndoStack;
	
	if (nLevel >= pStack->m_nRedoSeqs)
	{
		strRedo.Empty();
		return;
	}
	
	POSITION pos = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs - 1 - nLevel);
	strRedo = ((CSlobSequence*)pStack->m_seqs.GetAt(pos))->m_strDescription;
	
#if 0 // FUTURE: move undo formatting to shell
	static CString NEAR strRedoTemplate;

	if (strRedoTemplate.IsEmpty())
		VERIFY(strRedoTemplate.LoadString(IDS_REDO));

	CString strRedoCmd;

	if (CanRedo())
	{
		CSlobWnd* pWnd = GetActiveSlobWnd();
		ASSERT(pWnd != NULL);
		CUndoStack* pStack = pWnd->m_pUndoStack;

		POSITION pos = pStack->m_seqs.FindIndex(pStack->m_nRedoSeqs - 1);
		strRedoCmd = ((CSlobSequence*)
			pStack->m_seqs.GetAt(pos))->m_strDescription;
	}

	int cchRedo = strRedoTemplate.GetLength() - 2; // less 2 for "%s"
	sprintf(strRedo.GetBufferSetLength(cchRedo + strRedoCmd.GetLength()),
		strRedoTemplate, (const char*)strRedoCmd);
	strUndo.ReleaseBuffer();
#endif
}


// Call this to completely empty the undo buffer.
//
void CUndoSlob::Flush()
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	ASSERT(pWnd != NULL);
	
	pWnd->EndUndo(TRUE);	// Abort any recording.
	pWnd->m_pUndoStack->Flush();
	
	m_bFlushAtEnd = TRUE;
}


//
// The following functions are used by the CSlob code to insert commands
// into the undo/redo sequence currently being recorded.  All of the On...
// functions are used to record changes to the various types of properties
// and are called by the CSlob::Set...Prop functions exclusively.
//


// Insert an array of bytes.
//
UINT CUndoSlob::Insert(const void* pv, int cb)
{
	ASSERT(m_pCurSeq != NULL);

	BYTE* rgb = (BYTE*)pv;

	m_pCurSeq->InsertAt(0, 0, cb);

	for (int ib = 0; ib < cb; ib += 1)
		m_pCurSeq->SetAt(ib, *rgb++);

	return cb;
}


// Insert a string.
//
UINT CUndoSlob::InsertStr(const char* sz)
{
	ASSERT(m_pCurSeq != NULL);

	BYTE* pb = (BYTE*)sz;
	int nStrLen = lstrlen(sz);

	InsertInt(nStrLen);
	if (nStrLen > 0)
	{
		m_pCurSeq->InsertAt(sizeof (int), 0, nStrLen);
		for (int nByte = 0; nByte < nStrLen; nByte += 1)
			m_pCurSeq->SetAt(sizeof (int) + nByte, *pb++);
	}
	return nStrLen + sizeof (int);
}


void CUndoSlob::OnSetIntProp(CSlob* pChangedSlob, UINT nPropID, UINT nOldVal, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	CIntUndoRecord undoRecord;
	undoRecord.m_op = opIntProp;
	undoRecord.m_nPropID = (WORD)nPropID;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nOldVal = nOldVal;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		pChangedSlob->GetSlobName(strName);
		TRACE("Undo: SetIntProp(%s, %d, %d, 0x%08lx)\n",
			(const char*)strName, nPropID, nOldVal, pBag);
	}
#endif
}


void CUndoSlob::OnSetLongProp(CSlob* pChangedSlob, UINT nPropID, long nOldVal, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	CLongUndoRecord undoRecord;
	undoRecord.m_op = opLongProp;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nPropID = (WORD)nPropID;
	undoRecord.m_nOldVal = nOldVal;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		pChangedSlob->GetSlobName(strName);
		TRACE3("Undo: SetLongProp(%s, %d, %ld)\n",
			(const char*)strName, nPropID, nOldVal);
	}
#endif
}


void CUndoSlob::OnSetDoubleProp(CSlob* pChangedSlob, UINT nPropID,
	double numOldVal, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	CDoubleUndoRecord undoRecord;
	undoRecord.m_op = opDoubleProp;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nPropID = (WORD)nPropID;
	undoRecord.m_numOldVal = numOldVal;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		pChangedSlob->GetSlobName(strName);
		TRACE3("Undo: SetDoubleProp(%s, %d, %f)\n",
			(const char*)strName, nPropID, numOldVal);
	}
#endif
}


void CUndoSlob::OnSetStrProp(CSlob* pChangedSlob, UINT nPropID,
	const CString* pStrOldVal, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	InsertStr(((CString*)pStrOldVal)->GetBuffer(0));

	CUndoRecord undoRecord;
	undoRecord.m_op = opStrProp;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nPropID = (WORD)nPropID;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		pChangedSlob->GetSlobName(strName);
		if (strName.GetLength() > 80)
		{
			strName = strName.Left(80);
			strName += "...";
		}
		CString strOldName = *pStrOldVal;
		if (strOldName.GetLength() > 80)
		{
			strOldName = strOldName.Left(80);
			strOldName += "...";
		}
		TRACE3("Undo: SetStrProp(%s, %d, %s)\n",
			(const char*)strName, nPropID, (const char*)strOldName);
	}
#endif
}


void CUndoSlob::OnSetSlobProp(CSlob* pChangedSlob, UINT nPropID,
	const CSlob* pOldSlob, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	CSlobUndoRecord undoRecord;
	undoRecord.m_op = opSlobProp;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nPropID = (WORD)nPropID;
	undoRecord.m_pOldVal = pOldSlob;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		CString strOldName;
		pChangedSlob->GetSlobName(strName);
		if (pOldSlob == NULL)
			strOldName = "NULL";
		else
			pOldSlob->GetSlobName(strOldName);
		TRACE3("Undo: SetSlobProp(%s, %d, %s)\n",
			(const char*)strName, nPropID, (const char*)strOldName);
	}
#endif
}


void CUndoSlob::OnSetRectProp(CSlob* pChangedSlob, UINT nPropID,
	const CRect& rcOldVal, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	CRectUndoRecord undoRecord;
	undoRecord.m_op = opRectProp;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nPropID = (WORD)nPropID;
	undoRecord.m_rectOldVal = rcOldVal;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		pChangedSlob->GetSlobName(strName);
		TRACE3("Undo: SetRectProp(%s, %d, (%d,%d,%d,%d))\n",
			(const char*)strName, nPropID, rcOldVal);
	}
#endif
}


void CUndoSlob::OnSetPointProp(CSlob* pChangedSlob, UINT nPropID,
	const CPoint& ptOldVal, CPropBag* pBag)
{
	ASSERT(m_nRecording != 0);

	CPointUndoRecord undoRecord;
	undoRecord.m_op = opPointProp;
	undoRecord.m_pSlob = pChangedSlob;
	undoRecord.m_pBag = pBag;
	undoRecord.m_nPropID = (WORD)nPropID;
	undoRecord.m_ptOldVal = ptOldVal;
	Insert(&undoRecord, sizeof (undoRecord));
	pChangedSlob->AddDependant(this);

#ifdef _DEBUG
	if (GetLogUndoFlag())
	{
		CString strName;
		pChangedSlob->GetSlobName(strName);
		TRACE3("Undo: SetPointProp(%s, %d, (%d,%d,%d,%d))\n",
			(const char*)strName, nPropID, ptOldVal);
	}
#endif
}


void CUndoSlob::OnMultiRemove(CMultiSlob* pMultiSlob, CSlob* pRemoveSlob)
{
	InsertPtr(pRemoveSlob);
	InsertInt(sizeof (CSlob*));

	CUndoRecord rec;
	rec.m_op = opAction;
	rec.m_nPropID = A_PreSel;
	rec.m_pSlob = pMultiSlob;
	rec.m_pBag = NULL;
	Insert(&rec, sizeof (CUndoRecord));

#ifdef _DEBUG
	if (GetLogUndoFlag())
		TRACE1("Undo: Remove from selection: 0x%08lx\n", pRemoveSlob);
#endif
}

void CUndoSlob::OnAddProp(CSlob* pSlob, CPropBag* pBag, UINT nPropID)
{
	// NYI
	TRACE("NYI CUndoSlob::OnAddProp() - undo for prop bags");
}

void CUndoSlob::OnRemoveIntProp(CSlob* pSlob, CPropBag* pBag,
	UINT nPropID, int nOldVal)
{
	// NYI
	ASSERT(FALSE);
}


void CUndoSlob::InsertSel(UINT nAction, CMultiSlob* pMultiSlob,
	CObList* pItems)
{
	ASSERT(m_pCurSeq != NULL);
	if (m_pCurSeq->GetSize() > 0 && m_pCurSeq->GetAt(0) == opAction &&
		*(UNALIGNED UINT*)&m_pCurSeq->ElementAt(1 + sizeof (CSlob*)) == nAction)
	{
#ifdef _DEBUG
		if (GetLogUndoFlag())
			TRACE("Ignoring duplicate OnPreSel...\n");
#endif
		return;
	}

	if (pMultiSlob->m_objects.IsEmpty())
		return;

	if (pItems == NULL)
		pItems = pMultiSlob->GetContentList();
	ASSERT(pItems != NULL);

	int nPtrs = 0;
	POSITION pos = pItems->GetHeadPosition();
	while (pos != NULL)
	{
		CSlob *pSlob = (CSlob *)pItems->GetNext (pos);
		ASSERT (pSlob->IsKindOf (RUNTIME_CLASS (CSlob)));

		// Ask the slob if it likes being inserted
		// into the undo slob. Slobs that can go away
		// spontaneously (dependency container's build slobs)
		// should refuse this.

		if (pSlob->CanAct (act_insert_into_undo_slob))
		{
			InsertPtr (pSlob);
			nPtrs += 1;
		}
	}
	InsertInt(sizeof (CSlob*) * nPtrs);

	CUndoRecord rec;
	rec.m_op = opAction;
	rec.m_nPropID = (WORD)nAction;
	rec.m_pSlob = pMultiSlob;
	rec.m_pBag = NULL;
	Insert(&rec, sizeof (CUndoRecord));
}


void CUndoSlob::OnPreSel(CMultiSlob* pMultiSlob)
{
	InsertSel(A_PreSel, pMultiSlob);

#ifdef _DEBUG
	if (GetLogUndoFlag())
		TRACE("Undo: OnPreSel\n");
#endif
}


void CUndoSlob::OnPostSel(CMultiSlob* pMultiSlob)
{
	InsertSel(A_PostSel, pMultiSlob);
}


#ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
// Undo related debugging aids
//

void CSlobSequence::Dump()
{
	m_nCursor = 0;
	while (m_nCursor < GetSize())
	{
		CUndoRecord rec;

		RetrieveRecord(rec);

		switch (rec.m_op)
		{
		default:
			TRACE1("Illegal undo opcode (%d)\n", rec.m_op);
			ASSERT(FALSE);

		case CUndoSlob::opAction:
			{
				int cbUndoRecord;
				RetrieveInt(cbUndoRecord);
				m_nCursor += cbUndoRecord;

				TRACE3("opAction: pSlob = 0x%08lx, nActionID = %d, "
					"nBytes = %d\n", rec.m_pSlob, rec.m_nPropID, cbUndoRecord);
			}
			break;

		case CUndoSlob::opIntProp:
		case CUndoSlob::opBoolProp:
			{
				int val;
				RetrieveInt(val);
				TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %d\n",
					rec.m_pSlob, rec.m_nPropID, val);
			}
			break;

		case CUndoSlob::opLongProp:
			{
				long val;
				RetrieveLong(val);
				TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %ld\n",
					rec.m_pSlob, rec.m_nPropID, val);
			}
			break;

		case CUndoSlob::opDoubleProp:
			{
				double num;
				RetrieveNum(num);
				TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %f\n",
					rec.m_pSlob, rec.m_nPropID, num);
			}
			break;

		case CUndoSlob::opStrProp:
			{
				CString str;
				RetrieveStr(str);
				if (str.GetLength() > 80)
				{
					str = str.Left(80);
					str += "...";
				}
				TRACE3("opStr: pSlob = 0x%08lx, nPropID = %d, val = %s\n",
					rec.m_pSlob, rec.m_nPropID, (const char*)str);
			}
			break;

		case CUndoSlob::opSlobProp:
			{
				CSlob* pSlobVal;
				RetrievePtr(pSlobVal);
				TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, "
					"val = 0x%08lx\n", rec.m_pSlob, rec.m_nPropID, pSlobVal);
			}
			break;

		case CUndoSlob::opRectProp:
			{
				CRect rcVal;
				RetrieveRect(rcVal);
				TRACE3("opRect: pSlob = 0x%08lx, nPropID = %d, "
					"val = %d,%d,%d,%d\n", rec.m_pSlob, rec.m_nPropID, rcVal);
			}
			break;

		case CUndoSlob::opPointProp:
			{
				CPoint ptVal;
				RetrievePoint(ptVal);
				TRACE3("opPoint: pSlob = 0x%08lx, nPropID = %d, "
					"val = %d,%d,%d,%d\n", rec.m_pSlob, rec.m_nPropID, ptVal);
			}
			break;
		}
	}
}


void CUndoSlob::Dump()
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	if (pWnd == NULL)
	{
		TRACE("No undo buffer to dump!\n");
		return;
	}
	
	CUndoStack* pStack = pWnd->m_pUndoStack;
	
	int nRecord = 0;
	POSITION pos = pStack->m_seqs.GetHeadPosition();
	while (pos != NULL)
	{
		CSlobSequence* pSeq = (CSlobSequence*)pStack->m_seqs.GetNext(pos);
		TRACE2("Record (%d) %s:\n", nRecord,
			nRecord < pStack->m_nRedoSeqs ? "redo" : "undo");
		pSeq->Dump();
		nRecord += 1;
	}
}


extern "C" void DumpUndo()
{
	theUndoSlob.Dump();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\util.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <macimage.h>
#include <ppcimage.h>

#include "shell.h"
#include "util.h"
#include "resource.h"
#include "barglob.h"
#include "image.h"

#include <bldapi.h>

// [multimon] 11 mar 97 - der
#include "mmonitor.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
BOOL bChicagoLookOnNT = FALSE;
inline BOOL OnChicago() { return theApp.m_bWin4 || bChicagoLookOnNT; }
#else
inline BOOL OnChicago() { return theApp.m_bWin4; }
#endif

///////////////////////////////////////////////////////////////////////////////
//	CLockDC
//		Tries to lock its window for drawing.

CLockDC::CLockDC(CWnd* pWnd)
{
	m_hWnd = pWnd->GetSafeHwnd();
	if (m_hWnd == NULL)
		m_hWnd = ::GetDesktopWindow();
	::LockWindowUpdate(m_hWnd);

	if (!Attach(::GetDCEx(m_hWnd, NULL,
			DCX_WINDOW | DCX_CACHE | DCX_LOCKWINDOWUPDATE)))
		AfxThrowResourceException();
}

CLockDC::~CLockDC()
{
	ASSERT(m_hDC != NULL);
	::ReleaseDC(m_hWnd, Detach());
	::LockWindowUpdate(NULL);
}

/////////////////////////////////////////////////////////////////////////////
//
// The following code manages a cache of GDI brushes and pens that correspond
// to the system defined colors.  The cache is flushed when the user changes
// any of the system colors using the control panel.  Using GetSysBrush() or
// GetSysPen to get a system colored brush or pen will be more efficient than 
// creating the brushes and pens yourself.
//

#define nSysBrushes 25
#define nOurBrushes 4
static CBrush NEAR g_rgSysBrushes[nSysBrushes];
static CPen NEAR g_rgSysPens[nSysBrushes];

/* ResetSysBrush
 *	Deletes all of the system-colored brushes AND pens.
 */
void ResetSysBrushes()
{
    //NOTE: we don't include our extensions to the "system" brushes, because
    //  often the brush handle is used as hbrBackground for a Window class!

	for (UINT nBrush = 0; nBrush < nSysBrushes - nOurBrushes; nBrush++)
	{
		g_rgSysBrushes[nBrush].DeleteObject();
		g_rgSysPens[nBrush].DeleteObject();
	}
}

COLORREF MyGetSysColor(UINT nSysColor)
{
    if (nSysColor < CMP_COLOR_HILITE)
        return ::GetSysColor(nSysColor);

    static COLORREF rgColors[nOurBrushes] =
    {
        CMP_RGB_HILITE, CMP_RGB_LTGRAY, CMP_RGB_DKGRAY, CMP_RGB_BLACK,
    };

    ASSERT(nSysColor - CMP_COLOR_HILITE >= 0);
    ASSERT(nSysColor - CMP_COLOR_HILITE < nOurBrushes);
    return rgColors[nSysColor - CMP_COLOR_HILITE];
}

CBrush* GetSysBrush(UINT nSysColor)
{
    ASSERT(nSysColor < nSysBrushes);

    if (g_rgSysBrushes[nSysColor].m_hObject == NULL)
    {
        COLORREF cr = MyGetSysColor(nSysColor);
        if (!g_rgSysBrushes[nSysColor].CreateSolidBrush(cr))
        {
            // Woa!  GDI is really low on memory!  Flush our cache and
            // try again...

            ResetSysBrushes();

            if (!g_rgSysBrushes[nSysColor].CreateSolidBrush(cr))
            {
                TRACE("GetSysBrush failed!\n");
#ifdef _COMPOSER
                ((CTheApp*) AfxGetApp())->SetPaintEmergency();
#endif
            }
        }
    }

    return &g_rgSysBrushes[nSysColor];
}

CPen* GetSysPen(UINT nSysColor)
{
	ASSERT( nSysColor < nSysBrushes );

	if( g_rgSysPens[nSysColor].m_hObject == NULL )
	{
		COLORREF cr = MyGetSysColor(nSysColor);
		if( !g_rgSysPens[nSysColor].CreatePen(PS_SOLID, 0, cr) )
		{
			// Woa!  GDI is really low on memory!  Flush our cache and
			// try again...

			ResetSysBrushes();

			if( !g_rgSysPens[nSysColor].CreatePen(PS_SOLID, 0, cr) )
			{
				TRACE("GetSysPen failed!\n");
#ifdef _COMPOSER
			((CTheApp*) AfxGetApp())->SetPaintEmergency();
#endif
			}
		}
	}

	return &g_rgSysPens[nSysColor];
}

///////////////////////////////////////////////////////////////////////////////
//	Drawing helpers

void DrawSplitter(CDC* pdc, CRect rect, BOOL bVert)
{
	COLORREF colorLt = GetSysColor(COLOR_BTNHIGHLIGHT);
	COLORREF colorDk = GetSysColor(COLOR_BTNSHADOW);

	if (!OnChicago())
	{
		pdc->FrameRect(rect, GetSysBrush(COLOR_WINDOWFRAME));	// Faster with FillSolidRect().

		rect.InflateRect(-1, -1);

		if (bVert)
		{
			pdc->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(), colorDk);
			pdc->FillSolidRect(rect.left, rect.top, 1, rect.Height(), colorLt);
		}
		else
		{
			pdc->FillSolidRect(rect.left, rect.bottom - 1, rect.Width(), 1, colorDk);
			pdc->FillSolidRect(rect.left, rect.top, rect.Width(), 1, colorLt);
		}
	}
	else
	{
		if (bVert)
		{
			// Cap the ends.
			pdc->FillSolidRect(rect.left, rect.top - 1, rect.Width(), 1, colorDk);
			pdc->FillSolidRect(rect.left, rect.bottom - 1, rect.Width(), 1, colorDk);
			pdc->FillSolidRect(rect.left, rect.top, rect.Width(), 1, colorLt);
			pdc->FillSolidRect(rect.left, rect.bottom, rect.Width(), 1, colorLt);

			// 3d edges.
			rect.InflateRect(0, -1);
			pdc->FillSolidRect(rect.left, rect.top, 1, rect.Height(), colorLt);
			pdc->FillSolidRect(rect.right - 2, rect.top, 1, rect.Height(), colorDk);
			pdc->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(),
				GetSysColor(COLOR_WINDOWFRAME));
			
			// Fill center.
			rect.InflateRect(-1, 0);
			pdc->FillSolidRect(rect.left, rect.top,	rect.Width() - 1, rect.Height(),
				GetSysColor(COLOR_BTNFACE));
		}
		else
		{
			// Cap the ends.
			pdc->FillSolidRect(rect.left - 1, rect.top, 1, rect.Height(), colorDk);
			pdc->FillSolidRect(rect.right - 1, rect.top, 1, rect.Height(), colorDk);
			pdc->FillSolidRect(rect.left, rect.top, 1, rect.Height(), colorLt);
			pdc->FillSolidRect(rect.right, rect.bottom, 1, rect.Height(), colorLt);

			// 3d edges.
			rect.InflateRect(-1, 0);
			pdc->FillSolidRect(rect.left, rect.top, rect.Width(), 1, colorLt);
			pdc->FillSolidRect(rect.left, rect.bottom - 2, rect.Width(), 1, colorDk);
			pdc->FillSolidRect(rect.left, rect.bottom - 1, rect.Width(), 1,
				GetSysColor(COLOR_WINDOWFRAME));

			// Fill center.
			rect.InflateRect(0, -1);
			pdc->FillSolidRect(rect.left, rect.top, rect.Width(), rect.Height() - 1,
				GetSysColor(COLOR_BTNFACE));
		}
	}
}

#define CX_GAP (4)

HBITMAP CreateButtonBitmap(CWnd* pWnd, UINT nStyle,	LPCRECT lpRect,
	CBitmap* pbmGlyph /*=NULL*/, LPCTSTR lpszText /*=NULL*/, BOOL bAddArrow /*=FALSE*/)
{
	CWindowDC dcWnd(pWnd);

	CDC dc;
	if (!dc.CreateCompatibleDC(&dcWnd))
		return NULL;

	CRect rect(0, 0, 24, 22);
	if (theApp.m_bWin4)
		rect.right = 23;

	if (lpRect != NULL)
		rect = *lpRect;

	rect.OffsetRect(-rect.left, -rect.top);

	CBitmap bm;
	if (!bm.CreateCompatibleBitmap(&dcWnd, rect.Width(), rect.Height()))
		return NULL;

	CBitmap* pbmOld = dc.SelectObject(&bm);

#define BPR(clr)	dc.FillSolidRect(rect.left, rect.top,\
						rect.Width(), rect.Height(), GetSysColor(clr))

	if (!theApp.m_bWin4)
	{
		BPR(COLOR_WINDOWFRAME);

		::SetPixelV(dc.m_hDC, rect.left, rect.top, GetSysColor(COLOR_BTNFACE));
		::SetPixelV(dc.m_hDC, rect.left, rect.bottom - 1, GetSysColor(COLOR_BTNFACE));
		::SetPixelV(dc.m_hDC, rect.right - 1, rect.top, GetSysColor(COLOR_BTNFACE));
		::SetPixelV(dc.m_hDC, rect.right - 1, rect.bottom - 1, GetSysColor(COLOR_BTNFACE));

		rect.InflateRect(-1, -1);
	}

	if (nStyle & (TBBS_PRESSED | TBBS_CHECKED))
	{
		if (theApp.m_bWin4)
		{
			dc.Draw3dRect(rect, GetSysColor(COLOR_WINDOWFRAME),
				GetSysColor(COLOR_BTNHIGHLIGHT));
			rect.InflateRect(-1, -1);
			dc.Draw3dRect(rect, GetSysColor(COLOR_BTNSHADOW),
				GetSysColor(COLOR_BTNFACE));
			rect.InflateRect(-1, -1);
		}
		else
		{
			BPR(COLOR_BTNSHADOW);
			rect.left += 1; rect.top += 1;
		}

		if (nStyle & TBBS_PRESSED)
		{
			BPR(COLOR_BTNFACE);
		}
		else
		{
			CBrush* pbrOld = dc.SelectObject(CDC::GetHalftoneBrush());
			dc.SetTextColor(GetSysColor(COLOR_BTNHIGHLIGHT));
			dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
			dc.PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY);
			dc.SelectObject(pbrOld);
		}

		if (!theApp.m_bWin4)
			rect.InflateRect(-1, -1);	// for glyph positioning.
		else
		{
			rect.left++; rect.top++;
			rect.right++; rect.bottom++;
		}
	}
	else
	{
		if (theApp.m_bWin4)
		{
			dc.Draw3dRect(rect, GetSysColor(COLOR_BTNHIGHLIGHT),
				GetSysColor(COLOR_WINDOWFRAME));
			rect.InflateRect(-1, -1);
			dc.Draw3dRect(rect, GetSysColor(COLOR_BTNFACE),
				GetSysColor(COLOR_BTNSHADOW));
			rect.InflateRect(-1, -1);
		}
		else
		{
			BPR(COLOR_BTNSHADOW);
			rect.right--; rect.bottom--;
			BPR(COLOR_BTNHIGHLIGHT);
			rect.left++; rect.top++;
			BPR(COLOR_BTNSHADOW);
			rect.right--; rect.bottom--;
		}
		BPR(COLOR_BTNFACE);
	}

	if (lpszText != NULL)
	{
		int nLen = lstrlen(lpszText);

		dc.SetBkMode(TRANSPARENT);

		CFont* pFontOld = dc.SelectObject(GetStdFont(font_Normal));
		if (bAddArrow)
		{
			// get the ID of the arrow
			UINT idArrow;
			if (nLen <= 0) {
				idArrow = (nStyle & TBBS_DISABLED) ? IDB_MENUBTN_NOTEXT_ARROWD : IDB_MENUBTN_NOTEXT_ARROW;
			}
			else {
				idArrow = (nStyle & TBBS_DISABLED) ? IDB_MENUBTN_ARROWD : IDB_MENUBTN_ARROW;
			}
			// load the bitmap
			HINSTANCE hInstance = AfxFindResourceHandle(MAKEINTRESOURCE(idArrow), RT_BITMAP);
			ASSERT( hInstance != NULL );
			HRSRC hRsrc = ::FindResource(hInstance, MAKEINTRESOURCE(idArrow), RT_BITMAP);
			HBITMAP hBitmap = AfxLoadSysColorBitmap(hInstance, hRsrc);
			CBitmap bmpArrow;
			bmpArrow.Attach(hBitmap);

			// figure the size of the bitmap
			BITMAP bmp;
			bmpArrow.GetObject(sizeof(bmp), &bmp);
			int xBitmap = bmp.bmWidth;
			int yBitmap = bmp.bmHeight;

			int cx = dc.GetTextExtent(lpszText, nLen).cx;
			cx += xBitmap;
			if (nLen > 0)
				cx += CX_GAP;

			rect.left += (rect.Width() - cx) / 2;

			// olympus 15814
			// text on disabled menu buttons not visible when bkgrnd color
			// matches gray text color
			// draw text on the button
			if (nStyle & TBBS_DISABLED) {
				// draw disabled text
				if (theApp.m_bWin4) {
					// on Win95, disabled text is drawn with a highlight under
					// and a shadow over
					dc.SetTextColor(GetSysColor(COLOR_BTNHIGHLIGHT));
					rect.OffsetRect(1, 1);
					dc.DrawText(lpszText, nLen, rect, DT_SINGLELINE | DT_VCENTER);
					dc.SetTextColor(GetSysColor(COLOR_BTNSHADOW));
					rect.OffsetRect(-1, -1);
					dc.DrawText(lpszText, nLen, rect, DT_SINGLELINE | DT_VCENTER);
				}
				else {
					DWORD dwGrayText = GetSysColor(COLOR_GRAYTEXT);
					if (dwGrayText == GetSysColor(COLOR_BTNFACE)) {
						// choose RGB(128, 128, 128) unless the button
						// face is RGB(128, 128, 128)
						dwGrayText = RGB(128, 128, 128);
						if (dwGrayText == GetSysColor(COLOR_BTNFACE)) {
							dwGrayText = RGB(192, 192, 192);
						}
					}
					dc.SetTextColor(dwGrayText);
					dc.DrawText(lpszText, nLen, rect, DT_SINGLELINE | DT_VCENTER);
				}
			}
			else {
				// draw normal text
				dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
				dc.DrawText(lpszText, nLen, rect, DT_SINGLELINE | DT_VCENTER);
			}

			// draw the arrow

			// create a DC and select the bitmap
			CDC dc2;
			dc2.CreateCompatibleDC( &dc );
			CBitmap *pOldBitmap = dc2.SelectObject(&bmpArrow);

			// draw the arrow
			int x = rect.left + cx - xBitmap;
			int y = rect.top + rect.Height() / 2 - yBitmap / 2;
			// move the arrow up one pixel if we're on Win95 and there's no text
			if (nLen <= 0 && theApp.m_bWin4)
				y--;
			dc.BitBlt(x, y, xBitmap, yBitmap, &dc2, 0, 0, SRCCOPY);

			dc2.SelectObject( pOldBitmap );

			// FUTURE: Random focus style value
			if (nStyle & 0x80)
			{
				CRect rcFocus(rect);
				rcFocus.left -= 2;
				rcFocus.right = rcFocus.left + cx + 4;
				//rcFocus.top -= 1;

				dc.DrawFocusRect(rcFocus);
			}
		}
		else
		{
			dc.DrawText(lpszText, -1, rect,
				DT_SINGLELINE | DT_CENTER | DT_VCENTER);
		}
		dc.SelectObject(pFontOld);
	}
	else if (pbmGlyph != NULL)
	{
		CDC dcMask, dcMem;
		if (!dcMask.CreateCompatibleDC(&dcWnd) || !dcMem.CreateCompatibleDC(&dcWnd))
			goto leave_function;

		BITMAP bms;
		pbmGlyph->GetObject(sizeof (BITMAP), &bms);

		// Restrict blt to rect given.
		bms.bmWidth = min(bms.bmWidth, rect.Width());
		bms.bmHeight = min(bms.bmHeight, rect.Height());

		CBitmap bmMask;
		if (!bmMask.CreateBitmap(bms.bmWidth, bms.bmHeight, 1, 1, NULL))
			goto leave_function;

		CBitmap* pbmOldMask = dcMask.SelectObject(&bmMask);
		CBitmap* pbmOldMem = dcMem.SelectObject(pbmGlyph);

		// Calculate the mask (based on light gray).
		COLORREF oldBkColor = dcMem.SetBkColor(RGB(192, 192, 192));
		dcMask.BitBlt(0, 0, bms.bmWidth, bms.bmHeight, 
			&dcMem, 0, 0, NOTSRCCOPY);
		dcMem.SetBkColor(oldBkColor);

		// Paint the glyph.
		dc.SetBkColor(RGB(255, 255, 255));
		dc.SetTextColor(RGB(0, 0, 0));

		dc.BitBlt(rect.left + (rect.Width() - bms.bmWidth) / 2,
			rect.top + (rect.Height() - bms.bmHeight) / 2,
			bms.bmWidth, bms.bmHeight, &dcMem, 0, 0, DSx);

		dc.BitBlt(rect.left + (rect.Width() - bms.bmWidth) / 2,
			rect.top + (rect.Height() - bms.bmHeight) / 2,
			bms.bmWidth, bms.bmHeight, &dcMask, 0, 0, DSna);

		dc.BitBlt(rect.left + (rect.Width() - bms.bmWidth) / 2,
			rect.top + (rect.Height() - bms.bmHeight) / 2,
			bms.bmWidth, bms.bmHeight, &dcMem, 0, 0, DSx);

		dcMask.SelectObject(pbmOldMask);
		dcMem.SelectObject(pbmOldMem);
	}

leave_function:

	dc.SelectObject(pbmOld);

	return (HBITMAP) bm.Detach();
}

// Draws a bitmap without glyph suitable for use in a bar
HBITMAP CreateBarBitmap(CWnd* pWnd, UINT nStyle, LPCRECT lpRect, CSize sizeButton, CSize sizeImage)
{
	CWindowDC dcWnd(pWnd);

	CDC dc;
	if (!dc.CreateCompatibleDC(&dcWnd))
		return NULL;

	ASSERT(lpRect!=NULL);

	CRect rect = *lpRect;

	rect.OffsetRect(-rect.left, -rect.top);

	CBitmap bm;
	if (!bm.CreateCompatibleBitmap(&dcWnd, rect.Width(), rect.Height()))
		return NULL;

	CBitmap* pbmOld = dc.SelectObject(&bm);

	int dx = sizeButton.cx;
	int dy = sizeButton.cy;

	// interior grey
	dc.FillSolidRect(0, 0, dx, dy, globalData.clrBtnFace);

	// determine offset of bitmap (centered within button)
	CPoint ptOffset;
	ptOffset.x = (dx - sizeImage.cx - 1) / 2;
	ptOffset.y = (dy - sizeImage.cy) / 2;

	if (nStyle & (TBBS_PRESSED | TBBS_CHECKED))
	{
		// pressed in or checked
		dc.Draw3dRect(0, 0, dx, dy,
			globalData.clrBtnShadow, globalData.clrBtnHilite);

		// for any depressed button, add one to the offsets.
		ptOffset.x += 1;
		ptOffset.y += 1;
	}
	else if (nStyle & TBBS_EXTRUDED)
	{
		// regular button look
		dc.Draw3dRect(0, 0, dx, dy,
			globalData.clrBtnHilite, globalData.clrBtnShadow);
	}

	dc.SelectObject(pbmOld);

	return (HBITMAP) bm.Detach();
}



///////////////////////////////////////////////////////////////////////////////
//
// ForceRectOnScreen
// [multimon] 11 mar 97 - der : This function was updated to handle multiple monitors.
//
void ForceRectOnScreen(CRect& rect)
{
	// Get the boundary rectangle of the screen which contains most of the past in
	// rectangles.
	CRect screenRect ;
	// Get monitor rect.
	multiMonitorRectFromRect(rect, &screenRect, c_fWork) ;

	// Check left and right boundaries.
	if (rect.left < screenRect.left)
	{
		rect.right += screenRect.left - rect.left;
		rect.left = screenRect.left ;
	}
	else if (rect.right > screenRect.right)
	{
		rect.left -= rect.right - screenRect.right;
		rect.right = screenRect.right;
	}

	// Check top and bottom boundaries.
	if (rect.top < screenRect.top)
	{
		rect.bottom += screenRect.top - rect.top;
		rect.top = screenRect.top ;
	}
	else if (rect.bottom > screenRect.bottom)
	{
		rect.top -= rect.bottom - screenRect.bottom;
		rect.bottom = screenRect.bottom;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// ForceRectBelowTop 
// [multimon] 11 mar 97 - der : This function was updated to handle multiple monitors.
//
void ForceRectBelowTop(CRect& rect)
{
	// Get monitor rect.
	RECT rectMonitor ;
	multiMonitorRectFromRect(rect, &rectMonitor, c_fWork) ;

	// Move below top of screen.
	if (rect.top < rectMonitor.top)
	{
		rect.bottom += rectMonitor.top - rect.top;
		rect.top = rectMonitor.top;
	}
}

SCREEN_METRIC g_mt;

void InitMetrics()
{
	extern void InitPaletteBorders();

	InitPaletteBorders();

    g_mt.cxBorder = GetSystemMetrics(SM_CXBORDER);
    g_mt.cyBorder = GetSystemMetrics(SM_CYBORDER);
    g_mt.cxFrame = GetSystemMetrics(SM_CXFRAME);
    g_mt.cyFrame = GetSystemMetrics(SM_CYFRAME);
    g_mt.cxToolBorder = 6;
    g_mt.cyToolBorder = 3;

	// use small caption buttons if screen is small
	int cyScreen= ::GetSystemMetrics(SM_CYSCREEN);
	int cxScreen= ::GetSystemMetrics(SM_CXSCREEN);

	g_mt.cxToolCaption = 6;
	g_mt.cyToolCaption = 6;
	// If we're in less than 800x600, use smaller caption buttons. Why am I using test values of less than 800x600? Sometimes
	// some versions of Windows want to return just less than the actual value for these values; perhaps because some utility
	// stole some screen area.
	if(	cyScreen<550 ||
		cxScreen<750)
	{
		g_mt.cxToolCapBorder = 2;
		g_mt.cyToolCapBorder = 2;
		g_mt.cxToolCapGap = 2;
		g_mt.cyToolCapGap = 2;
		g_mt.cxToolCapButton = 8;
		g_mt.cyToolCapButton = 8;
	}
	else
	{
		g_mt.cxToolCapBorder = 6;
		g_mt.cyToolCapBorder = 6;
		g_mt.cxToolCapGap = 2;
		g_mt.cyToolCapGap = 2;
		g_mt.cxToolCapButton = 12;
		g_mt.cyToolCapButton = 12;
	}
    g_mt.nSplitter = 4;
}

BOOL PollForMouseChange(CPoint& pt, BOOL bYield, BOOL& bCancel, BOOL bAllowPaint /*=FALSE */)
{
	MSG msg;
	BOOL bNewMessage;
	
    if (bNewMessage = ::PeekMessage(&msg, ::GetCapture(), 0, 0,
        (bYield ? PM_REMOVE : PM_NOYIELD | PM_REMOVE)))
	{
		if (msg.message == WM_LBUTTONUP)
		{
	        return TRUE;
	    }
	    else if (msg.message == WM_RBUTTONDOWN || ::GetCapture() == NULL ||
	            (GetAsyncKeyState(VK_ESCAPE) & 0x8000))
	    {
			HWND wnd=::GetCapture();
	        // Cancel the drag.
	        bCancel = TRUE;
	        return TRUE;
	    }
	    else if (msg.message != WM_MOUSEMOVE)
	    {
	        return FALSE;
	    }
		else	// NewMouse with MOUSEMOVE message.            
	    {
			pt = CPoint(msg.lParam);
	        ASSERT(::GetCapture() != NULL);
	    	::ClientToScreen(::GetCapture(), &pt);
		}
	}
	else if(bAllowPaint)
	{
		::RedrawWindow(AfxGetMainWnd()->GetSafeHwnd(),NULL, NULL, RDW_UPDATENOW|RDW_ALLCHILDREN);
	}
	
	return FALSE;
}

void FlushKeys()
{
	MSG msg;

    while (::PeekMessage(&msg, NULL,
    	WM_KEYFIRST, WM_KEYLAST, PM_NOYIELD | PM_REMOVE))
		;
}

/*** GETEXETYPE
 *
 * PURPOSE: Given an open handle to file determine it's executable type if any.
 *
 * INPUT:
 *      hFile - Handle to an open file
 *
 * OUTPUT:
 *      EXT   - EXecutable Type in return value
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 *      This function will save the file pointer and restore it on exit.
 *      A return type of EXE_NONE indicates either an error occured while
 *      seeking/reading or the file wasn't of any recognized EXE type.
 *
 *		If the EXE type is EXE_NT, then *pwSubsystem will indicate
 *		the subsystem type (IMAGE_SUBSYSTEM_...).  If the EXE type is
 *		NOT EXE_NT, the value *pwSubsystem on return is meaningless.
 *
 *		You can pass NULL for pwSubsystem, in which case no value will
 *		be returned through that pointer.
 *
 ****************************************************************************/
#define NE_UNKNOWN	0x0
#define NE_OS2		0x1
#define NE_WINDOWS	0x2
#define NE_DOS		0x3

EXT GetExeType
(
	LPCTSTR	lpstrEXEFilename,
	WORD *	pwSubsystem
)
{
    IMAGE_DOS_HEADER        doshdr;
    IMAGE_OS2_HEADER        os2hdr;
    IMAGE_NT_HEADERS        nthdr;
	HANDLE					hFile;
	BOOL					fGotNE = FALSE;
	DWORD					dwBytesRead;

	/*
	** open up our EXE
	*/
	hFile = CreateFile(
				lpstrEXEFilename,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, 
				NULL
			);
	if (hFile == INVALID_HANDLE_VALUE) {
		return EXE_FAIL;
	}

    /*
    ** Try to read a an MZ header
    */
    ReadFile(hFile, &doshdr, sizeof (IMAGE_DOS_HEADER),	&dwBytesRead, NULL);

	if (dwBytesRead != sizeof (IMAGE_DOS_HEADER))
    {
		CloseHandle(hFile);
        return EXE_NONE;
    }

    /*
    ** If it was an MZ header and if the address of the relocation table
    ** isn't 0x0040 then it is a DOS non segmented executable.
    */
    if (doshdr.e_magic == IMAGE_DOS_SIGNATURE)
    {
    	if (doshdr.e_lfarlc != 0x0040)
    	{
			CloseHandle(hFile);
			return EXE_DOS;
		}
		else
			fGotNE = TRUE;
    }

    /*
	** Seek now to either the beginning of the file if there was no MZ stub or
	** to the new header specified in the MZ header.
    */
    if (SetFilePointer(hFile, fGotNE ? doshdr.e_lfanew : 0L, NULL, FILE_BEGIN) == 0xFFFFFFFF)
	{
		CloseHandle(hFile);
        return EXE_NONE;
	}

    ReadFile(hFile, &os2hdr, sizeof (IMAGE_OS2_HEADER), &dwBytesRead, NULL);
	if (dwBytesRead != sizeof (IMAGE_OS2_HEADER))
	{
		CloseHandle(hFile);
        return EXE_NONE;
    }

    if (os2hdr.ne_magic == IMAGE_OS2_SIGNATURE)
    {
		EXT	ext;

		switch(os2hdr.ne_exetyp)
		{
			case NE_OS2:
				ext = EXE_OS2_NE;
				break;

			case NE_WINDOWS:
				ext = EXE_WIN;
				break;

			case NE_DOS:
				ext = EXE_DOS;
				break;

			default:
				ext = EXE_NONE;
				break;
		}

		CloseHandle(hFile);
        return ext;
    }
    else if (os2hdr.ne_magic == IMAGE_OS2_SIGNATURE_LE)
    {
		EXT ext;

		ext = (os2hdr.ne_exetyp == NE_UNKNOWN) ? EXE_NONE : EXE_OS2_LE;

		CloseHandle(hFile);
        return EXE_OS2_LE;
    }


    /*
    ** Re-seek to the header, read it as an NT header and check for PE exe.
    */

    if (SetFilePointer(hFile, doshdr.e_lfanew, NULL, FILE_BEGIN) == 0xFFFFFFFF)
	{
		CloseHandle(hFile);
        return EXE_NONE;
    }

    ReadFile(hFile, &nthdr, sizeof (IMAGE_NT_HEADERS), &dwBytesRead, NULL);
	if (dwBytesRead != sizeof (IMAGE_NT_HEADERS))
    {
		CloseHandle(hFile);
        return EXE_NONE;
    }

    if (nthdr.Signature == IMAGE_NT_SIGNATURE)
    {
		// Return the subsystem as well.
		//
		// [CUDA 3557: 4/21/93 mattg]
		if (pwSubsystem != NULL)
		{
			if (nthdr.FileHeader.SizeOfOptionalHeader < IMAGE_SIZEOF_NT_OPTIONAL_HEADER)
				*pwSubsystem = IMAGE_SUBSYSTEM_UNKNOWN;
			else
				*pwSubsystem = nthdr.OptionalHeader.Subsystem;
		}
		CloseHandle(hFile);
        return EXE_NT;
    }


    /*
    ** Well, It isn't an Executable type that we know about....
    */

	CloseHandle(hFile);

    return EXE_NONE;

} /* GetExeType */

/*** GETEXEPLATFORM
 *
 * PURPOSE: Given the name of an executable file, return the associated 
 *			platform ID (win32x86, macppc, mac68k, etc)
 *
 * INPUT:
 *      szExeName - executable file whose platform ID will be returned
 *
 * RETURN:
 *      The platform ID of strExeName
 ****************************************************************************/
UINT GetExePlatform(LPCTSTR szExeName)
{
	HANDLE hfile;
	DWORD dwBytes;
	IMAGE_DOS_HEADER doshdr;
	IMAGE_FILE_HEADER PEHeader;
	DWORD dwMagic;

	if ((hfile = CreateFile(szExeName, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, NULL, NULL)) == INVALID_HANDLE_VALUE)
		return unknown_platform;

	ReadFile(hfile, (LPVOID) &doshdr, sizeof(IMAGE_DOS_HEADER), &dwBytes, NULL);
	if (dwBytes != sizeof(IMAGE_DOS_HEADER))
	{
		CloseHandle(hfile);
		return unknown_platform;
	}

	SetFilePointer(hfile, doshdr.e_lfanew, NULL, FILE_BEGIN);
	ReadFile(hfile, (LPVOID) &dwMagic, sizeof(dwMagic), &dwBytes, NULL);
	if (dwBytes != sizeof(dwMagic) || dwMagic != IMAGE_NT_SIGNATURE)
	{
		CloseHandle(hfile);
		return unknown_platform;
	}

	ReadFile(hfile, (LPVOID) &PEHeader, sizeof(IMAGE_FILE_HEADER), &dwBytes, NULL);
	if (dwBytes != sizeof(IMAGE_FILE_HEADER))
	{
		CloseHandle(hfile);
		return unknown_platform;
	}

	CloseHandle(hfile);

	switch (PEHeader.Machine)
	{
		case IMAGE_FILE_MACHINE_I386:
			return win32x86;

		case IMAGE_FILE_MACHINE_M68K:
			return mac68k;

		case IMAGE_FILE_MACHINE_R3000:
		case IMAGE_FILE_MACHINE_R4000:
			return win32mips;
			
		case IMAGE_FILE_MACHINE_ALPHA:
			return win32alpha;

		case IMAGE_FILE_MACHINE_MPPC_601:
			return macppc;
			
		case IMAGE_FILE_MACHINE_UNKNOWN:
		default:
			return unknown_platform;
			break;
	}
}

BOOL IsFileGUIExe(LPSTR szFileName)
{
	BOOL		fRet;
	IMAGE_INFO	ImageInfo;
	
	TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_DIR];
	_splitpath((const TCHAR *)szFileName, szDrive, szDir, NULL, szExt);

	if (!*szDrive && !*szDir)
	{
		TCHAR szFullPath[_MAX_PATH], *psz;
		// check along the path for it.
		if (*szExt && SearchPath(NULL, szFileName, szExt, _MAX_PATH, szFullPath, &psz))
		{
			szFileName = szFullPath;
		}
	}

	fRet = FALSE;
	ImageInfo.Size = sizeof (ImageInfo);

	if (GetImageInfo (szFileName, &ImageInfo)) {

		if (ImageInfo.ImageType == IMAGE_TYPE_WIN32 &&
			ImageInfo.u.Win32.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {

			fRet = TRUE;
		}
	}

	return fRet;
}


BOOL
IsExecutableFile(
	const TCHAR*	pszFileName
	)
/*++

Routine Description:

	This function will return TRUE if the file named by pszFileName is an NT
	style executable file (or DLL).  If specifically does not check to see
	if the file is compatible with the running installation of NT.

	Note: for our purposes a CrashDump file is considered an executable.  This
	used to accept Java .class files as executables -- it does so no more.

--*/
{
	BOOL		ret = FALSE;
	IMAGE_INFO	ImageInfo = {0};

	ImageInfo.Size = sizeof (ImageInfo);

	if (GetImageInfo (pszFileName, &ImageInfo)) {

		if (IS_WIN32_SUBSYSTEM_IMAGE (ImageInfo) ||
			ImageInfo.ImageType == IMAGE_TYPE_CRASHDUMP) {

			ret = TRUE;
		}
	}

	if(!ret) {
		/* Check for XBE file -- must have XBE extension and have XE
		 * signature */
		const TCHAR *pch;
		for(pch = pszFileName; *pch; ++pch);
		if(pch - pszFileName >= 4 && !_strnicmp(pch-4, ".xbe", 4)) {
			HANDLE hImage = CreateFile (pszFileName, GENERIC_READ,
				FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
				NULL);
			if(INVALID_HANDLE_VALUE != hImage) {
				DWORD dwSig;
				DWORD cbRead;
				if(ReadFile(hImage, &dwSig, 4, &cbRead, NULL) && cbRead ==
						4 && dwSig == 0x48454258)
					ret = TRUE;
				CloseHandle(hImage);
			}
		}
	}

	return ret;
}




//////////////////////////////////////////////////////////////////////////////
// PlayDevSound
//  Plays the sound, if any, found in the registry event named by idsEvent.
//  Under Win95, this is assumed to be in a the subkey MSDev.

// Registry names are not localized?
#define WIN95_SOUND_LABELS			"AppEvents\\EventLabels"
#define WIN95_SOUND_APPS			"AppEvents\\Schemes\\Apps"
#define WIN95_SOUND_IDE				"MSDev"
#define WIN95_SOUND_IDE2			"Microsoft Developer"
#define WIN95_SOUND_CURRENT			".Current"
#define WINNT_SOUND_PREFIX			"MSDev: "
#define WINNT_SOUNDS				"Control Panel\\Sounds"

BOOL PlayDevSound(UINT idsEvent, DWORD dwFlags)
{
	if( idsEvent == 0 )
		return FALSE;
	CString str;
	str.LoadString(idsEvent);
	return PlayDevSound(str, dwFlags);
}

BOOL PlayDevSound(const char* szEvent, DWORD dwFlags)
{
	if( (szEvent == NULL) || (*szEvent == '\0') )
		return FALSE;

	if( theApp.m_bWin4 )
	{
		// Under Win95, you can have subkeys of sounds.  However, the names in 
		// those sub-keys are not accessable using sndPlaySound, so we get the
		// value from the sub-key ourselves, and call it by its filename.
		CString strKey = WIN95_SOUND_APPS;
		strKey += '\\';
		strKey += WIN95_SOUND_IDE;
		strKey += '\\';
		strKey += szEvent;
		strKey += '\\';
		strKey += WIN95_SOUND_CURRENT;

		BOOL bRet = FALSE;
		HKEY hKey;
		if( RegOpenKeyEx(HKEY_CURRENT_USER, (char*)(const char*)strKey, 0, 
			KEY_READ, &hKey) == ERROR_SUCCESS )
		{
			unsigned char abBuf[512];
			DWORD dwcb = 511;
			DWORD dwType = REG_SZ;
			if( (RegQueryValueEx(hKey, NULL, NULL, &dwType, abBuf, &dwcb)
				== ERROR_SUCCESS) && (dwcb > 0) )
			{
				bRet = ShsndPlaySound((char*)abBuf, dwFlags);
			}
			RegCloseKey(hKey);
		}
		return bRet;
	}
	else
	{
		// the NT 3.5 version of this API has a bug causing it to return TRUE 
		// *always* based on the existence of a sound driver (+card), so we'll
		// make a pre-check to see if the registry is set up with these sounds.
		BOOL fPreCheckOk = TRUE;
		if (!theApp.m_bWin4) 
		{
			// form our key
			HKEY hkey;
			fPreCheckOk = (RegOpenKeyEx(HKEY_CURRENT_USER, (LPCTSTR)"Control Panel\\Sounds", 0, KEY_READ, &hkey) == ERROR_SUCCESS);
			if (fPreCheckOk)
			{
				DWORD dwType, dwSize;
				fPreCheckOk = (RegQueryValueEx(hkey, (LPTSTR)szEvent, NULL, &dwType, (LPBYTE)NULL, &dwSize) == ERROR_SUCCESS);
				RegCloseKey(hkey);
			}
		}

		return fPreCheckOk && ShsndPlaySound(szEvent, dwFlags);
	}
}

static HMODULE h_winmm = NULL;
typedef BOOL (WINAPI *FPPLAYSOUND)(LPCTSTR,HMODULE,DWORD);
static FPPLAYSOUND ThePlaySound = NULL;

BOOL MyPlaySound(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound)
{
	if (h_winmm == NULL)
	{
		h_winmm = ::LoadLibrary("winmm.dll");
		if (h_winmm == NULL)
			return FALSE;
	}

	if (ThePlaySound == NULL)
	{
		ThePlaySound = (FPPLAYSOUND)::GetProcAddress(h_winmm, "PlaySoundA");
		if (ThePlaySound == NULL)
			return FALSE;
	}

	return ThePlaySound(pszSound, hmod, fdwSound);
}


typedef BOOL (WINAPI *FPSNDPLAYSOUND)(LPCTSTR,UINT);
static FPSNDPLAYSOUND TheSndPlaySound = NULL;

BOOL ShsndPlaySound(LPCSTR lpszSound, UINT fuSound)
{
	if (h_winmm == NULL)
	{
		h_winmm = ::LoadLibrary("winmm.dll");
		if (h_winmm == NULL)
			return FALSE;
	}

	if (TheSndPlaySound == NULL)
	{
		TheSndPlaySound = (FPSNDPLAYSOUND)::GetProcAddress(h_winmm, "sndPlaySoundA");
		if (TheSndPlaySound == NULL)
			return FALSE;
	}

	return TheSndPlaySound(lpszSound, fuSound);
}

//////////////////////////////////////////////////////////////////////////////
// RegisterDevSoundEvent
//	Adds a location in the registry of either Win95 or WinNT, that will show
//	up in the Control Panel's Sound utility.
//		idsEventName:		string ID of symbol used in registry
//		idsFriendlyName:	friendlier name that is displayed in the Sound util

BOOL RegisterDevSoundEvent(UINT idsEventName, UINT idsFriendlyName)
{
	CString strEvent, strFriendly;
	VERIFY( strEvent.LoadString(idsEventName) );
	VERIFY( strFriendly.LoadString(idsFriendlyName) );
	return RegisterDevSoundEvent(strEvent, strFriendly);
}

BOOL RegisterDevSoundEvent(const char* szEvent, const char* szFriendly)
{
	if( theApp.m_bWin4 )
	{
		// Open existing Labels keys
		HKEY hKeyLabels;
		long lResult = RegOpenKeyEx(HKEY_CURRENT_USER, WIN95_SOUND_LABELS, 0, KEY_ALL_ACCESS/*NULL*/, &hKeyLabels) ;
		if ( lResult != ERROR_SUCCESS )
		{			
			return FALSE;
		}

		// Create a subkey under the Labels with the name of this event
		HKEY hKeyEvent;
		lResult = RegOpenKeyEx(hKeyLabels, szEvent, 0, KEY_ALL_ACCESS/*NULL*/, &hKeyEvent) ;
		if( lResult != ERROR_SUCCESS )
		{
			DWORD dw;
			lResult = RegCreateKeyEx(hKeyLabels, szEvent, 0, NULL, 0, KEY_ALL_ACCESS/*NULL*/, NULL, &hKeyEvent, &dw) ;
			if (lResult	!= ERROR_SUCCESS )
			{
				RegCloseKey(hKeyLabels);
				return FALSE;
			}
			VERIFY(RegSetValueEx(hKeyEvent, NULL, 0, REG_SZ, 
					(const unsigned char*)szFriendly, strlen(szFriendly) + 1) == ERROR_SUCCESS) ;
		}
		else
		{
			RegCloseKey(hKeyEvent);
		}
		RegCloseKey(hKeyLabels);

		// Open existing Apps keys
		HKEY hKeyApps;
		lResult = RegOpenKeyEx(HKEY_CURRENT_USER, WIN95_SOUND_APPS, 0, KEY_ALL_ACCESS/*NULL*/, &hKeyApps) ;
		if(lResult != ERROR_SUCCESS )
		{
			return FALSE;
		}

		// Create a subkey under the Apps for Developer
		HKEY hKeyDev;
		lResult = RegOpenKeyEx(hKeyApps, WIN95_SOUND_IDE, 0, KEY_ALL_ACCESS/*NULL*/, &hKeyDev) ;
		if( lResult != ERROR_SUCCESS )
		{
			DWORD dw;
			lResult = RegCreateKeyEx(hKeyApps, WIN95_SOUND_IDE, 0, NULL, 0, KEY_ALL_ACCESS/*NULL*/, NULL, &hKeyDev, &dw) ;
			if( lResult != ERROR_SUCCESS )
			{
				RegCloseKey(hKeyApps);
				return FALSE;
			}
			const char szIdeName[] = WIN95_SOUND_IDE2 ;
			lResult = RegSetValueEx(hKeyDev, NULL, 0, REG_SZ, 
									(const unsigned char*)szIdeName, strlen(szIdeName) + 1) ;
			ASSERT(lResult == ERROR_SUCCESS) ;
		}

		// Create a subkey under Developer for this Event
		lResult = RegOpenKeyEx(hKeyDev, szEvent, 0, KEY_ALL_ACCESS/*NULL*/, &hKeyEvent) ;
		if (lResult	!= ERROR_SUCCESS )
		{
			DWORD dw;
			lResult = RegCreateKeyEx(hKeyDev, szEvent, 0, NULL, 0, KEY_ALL_ACCESS/*NULL*/, NULL, &hKeyEvent, &dw) ;
			if ( lResult != ERROR_SUCCESS )
			{
				RegCloseKey(hKeyApps);
				RegCloseKey(hKeyDev);
				return FALSE;
			}
			lResult = RegSetValueEx(hKeyEvent, NULL, 0, REG_SZ, 
					(const unsigned char*)szFriendly, strlen(szFriendly) + 1);
			ASSERT( lResult == ERROR_SUCCESS) ;
			
		}
		else
		{
			RegCloseKey(hKeyEvent);
		}

		RegCloseKey(hKeyDev);
		RegCloseKey(hKeyApps);
	}
	else		// NT
	{
		HKEY hKeySounds;
		if( RegOpenKeyEx(HKEY_CURRENT_USER, WINNT_SOUNDS, 0,
				KEY_ALL_ACCESS, &hKeySounds) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		// Create a value under the Sounds with the name of this event
		DWORD dwType = REG_SZ;
		BYTE acData[256];
		DWORD dwcb = 256;
		if( RegQueryValueEx(hKeySounds, (char*)(const char*)szEvent, NULL, 
			&dwType, acData, &dwcb) != ERROR_SUCCESS )
		{
			CString strValue = ",";	// nothing before the comma means no sound
			strValue += WINNT_SOUND_PREFIX;		// add prefix to our name, to group and flag them
			strValue += szFriendly;
			if( RegSetValueEx(hKeySounds, szEvent, NULL, REG_SZ, 
				(const BYTE*)(const char*)strValue, (DWORD)strValue.GetLength() + 1)
				!= ERROR_SUCCESS )
			{
				RegCloseKey(hKeySounds);
				return FALSE;
			}
		}
		RegCloseKey(hKeySounds);
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

BOOL InEmergencyState()
{
	return FALSE;
}

#ifdef _DEBUG
BOOL GetLogUndoFlag()
{
	return FALSE;
}
#endif

////////////////////////////////////////////////////////////////////////////
// Global utility functions
// True if the CCmdui is for any kind of context menu
BOOL IsContextMenu(CCmdUI* pCmdUI)
{

	if (pCmdUI->m_pMenu != NULL && pCmdUI->m_pMenu == pCmdUI->m_pParentMenu)
	{
		// this is a menu which is its own parent, which means
		// that it's a context menu.
		//
		return TRUE;
	}
	else if (pCmdUI->m_pOther != NULL)
	{
		// If this is a command bar popup but not a drop down,
		// then treat it as a context menu.
		//
		if (CBMenuPopup::IsCBMenuCmdUI(pCmdUI))
		{
			CBMenuPopup* pCBMenu = (CBMenuPopup*)pCmdUI->m_pOther;
	
			if (!pCBMenu->IsDropDown() && !pCBMenu->IsSubPopup())
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

// TRUE if this is the ccmdui for a menu
BOOL IsMenu(CCmdUI* pCmdUI)
{
	return	(pCmdUI->m_pParentMenu != NULL || pCmdUI->m_pMenu != NULL ||
			(pCmdUI->m_pOther != NULL && pCmdUI->m_pOther->IsKindOf(RUNTIME_CLASS(CBMenuPopup))));

}

void UpdateMenuCommand(CCmdUI *pCmdUI)
{
    // menus are enabled if they have any visible items
    CBMenuPopup *pMenu=theCmdCache.GetMenu(pCmdUI->m_nID);
    if(     pMenu &&
            pMenu->m_nVisibleItems>0)
    {
            pCmdUI->Enable(TRUE);
    }
    else
    {
            pCmdUI->Enable(FALSE);
    }
}

// convert the windows ansi code page to the iso code page
// used by the htmx and htm packages for the code page
// meta data html tag
BOOL AnsiCodePageToIsoCodePage(/*[in]*/ LPCTSTR szAnsi, /*[out]*/ CString *pstrIso)
{
	ASSERT(NULL != szAnsi && NULL != pstrIso);
	if(NULL == szAnsi || NULL == pstrIso)
		return FALSE;

	BOOL bReturn = TRUE;
	LPTSTR szUnused;

	// Convert to a number for comparison
	DWORD dwLocale = _tcstoul(szAnsi, (LPTSTR*)&szUnused, 10);
	switch(dwLocale)
	{
		case 1252:	// windows latin 1
			*pstrIso = _T("iso-8859-1");
			break;
		case 1250:	// windows latin 2 (eastern europe)
			*pstrIso = _T("windows-1250");
			break;
		case 1251:	// cyrillic (slavic)
			*pstrIso = _T("windows-1251");
			break;
		case 1253:	// greek
			*pstrIso = _T("windows-1253");
			break;
		case 1254:	// latin 5 (turkish) 
			*pstrIso = _T("windows-1254");
			break;
		case 1255:	// hebrew
			*pstrIso = _T("iso-8859-8");
			break;
		case 1256:	// arabic
			*pstrIso = _T("iso-8859-6");
			break;
		case 1257:	// latin4 or baltic
			*pstrIso = _T("windows-1257");
			break;
//		case 874:	// thai
//			break;
		case 932:	// japanese (shift jis)
			*pstrIso = _T("x-sjis");
			break;
		case 936:	// simplified chinese
			*pstrIso = _T("gb_2312-80");
			break;
		case 949:	// korean
			*pstrIso = _T("ks_c_5601-1987");
			break;
		case 950:	// traditional chinese
			*pstrIso = _T("x-x-big5");
			break;
		case 1200:
			*pstrIso = _T("unicode-1-1-utf-8");
//			*pstrIso = _T("unicode-2-0-utf-8");
			break;
		default:
			// unknown code page
			*pstrIso = _T("unknown");
			bReturn = FALSE;
			break;
	}
	return bReturn;
}

/////////////////////////////////////////////////////////////////////////////
//
//	GetFirstChildWindowWithID
//
//	This is a breath-first search for the particular ID.
//  It was created by modifying CWnd::GetDescendantWindow.
//
//

CPartView* GetFirstChildWindowWithID(HWND hWnd, int nID, BOOL bOnlyPerm)
{
	// GetDlgItem recursive (return first found)

	// use GetDlgItem since it is a fast USER function
	CPartView* pWndChild;
	HWND hWndChild = ::GetDlgItem(hWnd, nID) ;
	if (hWndChild != NULL)
	{
		if (bOnlyPerm)
		{
			// Return permanent handles only.
			pWndChild = (CPartView*)CWnd::FromHandlePermanent(hWndChild);
		}
		else
		{
			// Return temporary or permanent handles.
			pWndChild = (CPartView*)CWnd::FromHandle(hWndChild);
		}

		// Only return the window if it is a CPartView.
		if (pWndChild != NULL && pWndChild->IsKindOf(RUNTIME_CLASS(CPartView)))
		{
			return pWndChild;
		}
	}

	// walk each child
	for (hWndChild = ::GetTopWindow(hWnd); 
		hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		pWndChild = GetFirstChildWindowWithID(hWndChild, nID, bOnlyPerm);
		if (pWndChild != NULL)
		{
			return pWndChild;
		}
	}
	return NULL;    // not found
}

#if 0
CWnd* CheckNextLevel(HWND* hWnds, int count, int nID, int iLevel, BOOL bOnlyPerm) ;

CWnd* GetFirstChildWindowWithID(HWND hWnd, int nID, BOOL bOnlyPerm)
{
	CWnd* pWndChild = CheckNextLevel(&hWnd, 1, nID, 1, bOnlyPerm) ;
	return pWndChild ;
}

//
//
//
CWnd* CheckNextLevel(HWND* hWnds, int count, int nID, int iLevel, BOOL bOnlyPerm) 
{
	//TRACE("---> DESCENDING TO LEVEL %d.\r\n", iLevel) ;

	ASSERT(count>0) ;
	ASSERT(iLevel>0) ;

	HWND hWndChild = NULL ;
	CWnd* pWndChild = NULL ;

	// Check each window for the ID.
	for (int i = 0 ; i < count ; i++)
	{
		hWndChild = ::GetDlgItem(hWnds[i], nID) ;
		if ( hWndChild != NULL )
		{
			if (!bOnlyPerm)
			{
				pWndChild = CWnd::FromHandle(hWndChild);
			}
			else
			{
				pWndChild = CWnd::FromHandlePermanent(hWndChild);
			}

			// Only return the window if it is a CPartView.
			if (pWndChild != NULL && pWndChild->IsKindOf(RUNTIME_CLASS(CPartView)))
			{
				//* ---Start Cut
				//if (iLevel != 1)
					//TRACE("----> FOUND AT LEVEL %d.\r\n", iLevel) ;
				// *---End Cut
				return pWndChild;
			}
		}
	}

	// Build an array containing the children for each of these windows.
	const int cMaxIndex = 512 ;
	HWND hWndsNextLevel[cMaxIndex] ;
	int index = 0 ;

	for (i = 0 ; i < count && index < cMaxIndex ; i++)
	{
		for (	hWndChild = ::GetTopWindow(hWnds[i]); 
				hWndChild != NULL && index < cMaxIndex; 
				hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			hWndsNextLevel[index++] = hWndChild ;
		}
	}

	ASSERT(index < cMaxIndex) ;

	if (index >0)
	{
		// Check the next level		
		return CheckNextLevel(hWndsNextLevel, index, nID, iLevel+1, bOnlyPerm) ;
	}
	else
	{
		// Done
		//TRACE0("----> WINDOW NOT FOUND!\r\n") ;
		return NULL ;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\treectl.cpp ===
// treectl.cpp : implementation file
//

#include "stdafx.h"
#include "util.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

int CTreeCtl::c_cyBorder = GetSystemMetrics(SM_CYBORDER);
int CTreeCtl::c_cyBorderX2 = c_cyBorder * 2;

// This image well contains: +box, -box, closed-folder, open-folder
CImageWell CTreeCtl::c_imageWell;
#define nPlusImage		0
#define nMinusImage		1
#define nClosedImage	2
#define nOpenImage		3

// width&height of the boxed + and - images
#define cxExpandBox 11
#define cyExpandBox 11

// size of the folder images
#define cxFolder	16
#define cyFolder	15

// NOTE: We invert the standard MFC GetHalftoneBrush since this code was
// written to line up dots based on our old GetHalftoneBrush which was
// one off from MFC's...
#define NOTPATCOPY 0x000F0001	// Pn

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl

CTreeCtl::CTreeCtl(BOOL bIsMultiSelection /*= FALSE*/, BOOL bKeepSelectionRect /*=FALSE*/)
{
	if (!c_imageWell.IsOpen())
	{
		VERIFY(c_imageWell.Load(IDB_TREECTL, CSize(16, 16)));
		VERIFY(c_imageWell.Open());
		VERIFY(c_imageWell.CalculateMask());
	}
	
	m_bIsMultiSelection = bIsMultiSelection;
	m_bKeepSelectionRect= bKeepSelectionRect;
	m_nNextInsertIndex = -1;	// cached next insert index is not valid yet...
	m_EnableUpdates = 0;
	m_bEnableDragDrop = FALSE;
	m_bShowContextPopup = FALSE;
	m_bShowProperties = FALSE;
	m_bSortRootNodes = TRUE;
	m_bVertLineAction = FALSE;
	m_bPopupClippedText = FALSE;
	m_timeLastKey = 0;
	m_cxOffset = 0;
}

CTreeCtl::~CTreeCtl()
{
	if (m_hWnd != NULL)
		DestroyWindow();
}

BOOL CTreeCtl::PreCreateWindow(CREATESTRUCT& cs)
{
	if (cs.lpszClass == NULL)
		cs.lpszClass = AfxRegisterWndClass(0);
			
	return TRUE;
}

IMPLEMENT_DYNAMIC(CTreeListBox, CWnd)

BEGIN_MESSAGE_MAP(CTreeListBox, CWnd)
	//{{AFX_MSG_MAP(CTreeListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_TIMER()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_CHAR()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CTreeCtl, CWnd)

BEGIN_MESSAGE_MAP(CTreeCtl, CWnd)
	//{{AFX_MSG_MAP(CTreeCtl)
	ON_WM_CHARTOITEM()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_WM_VKEYTOITEM()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_SETFONT, OnSetFont)
	ON_MESSAGE(WM_GETFONT, OnGetFont)
	ON_LBN_DBLCLK(IDCW_TREELISTBOX, OnLbDblClk)
	ON_LBN_SELCHANGE(IDCW_TREELISTBOX, OnLbSelChange)
	ON_LBN_SETFOCUS(IDCW_TREELISTBOX, InvalSelection)
	ON_LBN_KILLFOCUS(IDCW_TREELISTBOX, InvalSelection)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CTreeCtl::SetContextHelpID(DWORD dwContextHelpId)
{
	SetWindowContextHelpId(dwContextHelpId);
	m_pListBox->SetWindowContextHelpId(dwContextHelpId);
}

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl message handlers

int CTreeCtl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	CreateListBox();

	CClientDC dc(this);
	ResetSizes(&dc);
	
	m_pListBox->m_pTree = this;
	if (!m_pListBox->Create(WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER |
		LBS_NOTIFY | LBS_OWNERDRAWFIXED | LBS_NOINTEGRALHEIGHT |
		LBS_WANTKEYBOARDINPUT | ( (m_bIsMultiSelection) ? LBS_EXTENDEDSEL : 0),
		CRect(0, 0, 0, 0), this, IDCW_TREELISTBOX))
	{
		return -1;
	}
	
	SetFont(GetStdFont(font_Normal));

	return 0;
}

void CTreeCtl::OnDestroy()
{
	FreeAllTreeData();

	delete m_pListBox;
}

void CTreeCtl::OnPaint()
{
	// we want to search through the tree control
	// for any dirty nodes, if we find one of these
	// we want to update it's contents
	RefreshAllRoots();		// refresh from our roots down

	CWnd::OnPaint();	// pass on to our base instance
}

void CTreeCtl::ResetSizes(CDC* pDC)
{
	m_sizeM = pDC->GetTextExtent("M", 1);
	// Make sure this is even so our brush lines up when we scroll:
	m_cyNode = (max(m_sizeM.cy, cyFolder) + 2) & ~1;
		
	m_cxExtent = 0; // not calculated yet...
}

void CTreeCtl::RecalcHorizontalExtent ()
{
	m_cxExtent = 0;
	int nIndex = m_pListBox->GetCount();
	while (--nIndex >= 0)
	{
		CNode * pNode = (CNode *)m_pListBox->GetItemDataPtr(nIndex);
		if (pNode->m_nWidth > m_cxExtent) m_cxExtent = pNode->m_nWidth;
	}

	// If the listbox fits, set the scroll position to 0 to make sure
	// the scroll bar goes away:
	CRect rcWindow;
	m_pListBox->GetClientRect(rcWindow);
	if (m_cxExtent <= rcWindow.right && m_pListBox->GetScrollPos(SB_HORZ))
		m_pListBox->SendMessage(WM_HSCROLL, SB_TOP);

	m_pListBox->SetHorizontalExtent(m_cxExtent);

}
	
LPARAM CTreeCtl::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	CFont* pFont = CFont::FromHandle((HFONT)wParam);

	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(pFont);
	ResetSizes(&dc);
	dc.SelectObject(pOldFont);

	m_pListBox->SetFont(pFont);
	m_pListBox->SetItemHeight(0, m_cyNode);
	
	return 0;
}

LPARAM CTreeCtl::OnGetFont(WPARAM wParam, LPARAM lParam)
{
	return m_pListBox->SendMessage(WM_GETFONT, wParam, lParam);
}

void CTreeCtl::OnSetFocus(CWnd* pOldWnd)
{
	m_pListBox->SetFocus();
}

void CTreeCtl::InvalItem(int nItem)
{
	CRect rect;
	m_pListBox->GetItemRect(nItem, rect);
	m_pListBox->InvalidateRect(rect);
}

void CTreeCtl::InvalSelection()
{
	if (m_bIsMultiSelection)
	{
		CRect client;
		m_pListBox->GetClientRect(client);
		for (int nItem = m_pListBox->GetTopIndex(); nItem != -1; nItem += 1)
		{
			CRect rect;
			if (m_pListBox->GetItemRect(nItem, &rect) == LB_ERR || rect.top >= client.bottom)
				break;
			
			if (m_pListBox->GetSel(nItem))
				m_pListBox->InvalidateRect(rect);
		}
	}
	else
	{
		InvalItem(GetCurSel());
	}
}

void CTreeCtl::OnSize(UINT nType, int cx, int cy)
{
	if (GetParent()->IsIconic())
		return;

	// Put the client area of the listbox in the client area of the tree.
	CRect rectNew, rectCurrent;
	GetClientRect(rectNew);
	::AdjustWindowRect(rectNew, m_pListBox->GetStyle(), FALSE);

	m_pListBox->GetWindowRect(rectCurrent);
	ScreenToClient(rectCurrent);

	if (rectNew == rectCurrent)
		return;
		
	m_pListBox->MoveWindow(rectNew.left, rectNew.top,
		rectNew.Width(), rectNew.Height());
		
	int iMax = GetCurSel();
	if (iMax >= 0)
	{
		int top, bottom;
			
		m_pListBox->GetClientRect(rectCurrent);
		top = m_pListBox->GetTopIndex();
		bottom = top + rectCurrent.bottom / m_cyNode;
		if (iMax < top || iMax > bottom)
			m_pListBox->SetTopIndex(iMax - (bottom - top) / 2);
	}
	RecalcHorizontalExtent();
}

int CTreeCtl::OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex)
{
	// On 6/15/94, I deleted a bunch of code in this function which appears
	// to be obsolete.  If the assertion below ever fires, please send an
	// exact repro case to me (ALANE) and I'll put it back.
	//
	ASSERT((GetCurSel() < 0) || ((nChar & 0xff) <= 0x20));
	return -2;
}

BOOL CTreeCtl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN || GetParentFrame()->IsIconic())
		return FALSE;
		
	switch (pMsg->wParam)
	{
	case VK_UP:
	case VK_DOWN:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_PRIOR:
	case VK_NEXT:
	case VK_BACK:
	case VK_RETURN:
	case VK_ADD:
	case VK_SUBTRACT:
	case VK_MULTIPLY:
		// Make sure we get the keys we handle in OnKeyDown!
		::TranslateMessage(pMsg);
		::DispatchMessage(pMsg);
		return TRUE;
	}
	
	return FALSE;
}

// OnKeyDown and OnChar
//
// These two functions are called as the listbox receives keyboard input,
// and give you a chance to add specific keyboard processing for your
// tree.
//
// Note that you will receive both an OnKeyDown AND an OnChar for character
// input.
//
// Return TRUE if you handle this message, FALSE if you want default listbox
// handling to occur.
//
BOOL CTreeCtl::OnKeyDown(UINT nChar)
{
	int i = GetCurSel();
	int iSave = i;		
	if (i < 0)
		return TRUE;

	int j = 1;
	CNode* pNode = GetNode(i);
	CNode* pNodeT;

	switch (nChar)
	{
	case VK_LEFT:
		if (((pNode->m_nFlags & TF_EXPANDABLE) != 0) && ((pNode->m_nFlags & TF_EXPANDED) != 0))
		{
			OnCollapse();
			return TRUE;
		}
		else
		{
			while ((pNodeT = GetNode(--i)) != NULL)
			{
				if (pNodeT == pNode->m_pParent)
				{
					KeySetSel(i);
					return TRUE;
				}
			}
		}
		goto LSameSelection;
		
	case VK_RIGHT:
		if (((pNode->m_nFlags & TF_EXPANDABLE) != 0) && ((pNode->m_nFlags & TF_EXPANDED) == 0))
		{
			OnExpand();
			return TRUE;
		}
		else
		{
			if ((pNodeT = GetNode(i + 1)) != NULL && pNodeT->m_pParent == pNode)
			{
				KeySetSel(i + 1);
				return TRUE;
			}
		}
		goto LSameSelection;
		
	case VK_UP:
		j = -1;
		// FALL THROUGH
		
	case VK_DOWN:
		if (GetKeyState(VK_CONTROL) >= 0)
		{
			ClearSearchBuffer();
			return FALSE;
		}

		while ((i += j) >= 0 && (pNodeT = GetNode(i)) != NULL)
		{
			if (pNodeT->m_pParent == pNode->m_pParent)
			{
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SetSel(iSave, TRUE);
					while ((iSave += j) != i)
						SetSel(iSave, TRUE);
					SetSel(i, TRUE);
					OnLbSelChange();
				}
				else
					KeySetSel(i);
				return TRUE;
			}
		}
LSameSelection:
		MessageBeep(0);
		return TRUE;
		
	case VK_BACK:
		{
			if (i <= 0)
				return TRUE;
			
			int nStartLevel = pNode->m_nLevels;
			do
			{
				pNodeT = GetNode(--i);
			}
			while (i > 0 && pNodeT->m_nLevels >= nStartLevel);
			
			KeySetSel(i);
			return TRUE;
		}
		
	case VK_RETURN:
		OnPrimary();
		return TRUE;

	case VK_ADD:
		OnExpand();
		return TRUE;
		
	case VK_SUBTRACT:
		OnCollapse();
		return TRUE;
		
	case VK_MULTIPLY:
		if (GetKeyState(VK_CONTROL) < 0)
			OnExpandAll();
		else
			OnExpandBranch();
		return TRUE;
	}

	return FALSE;
}

BOOL CTreeCtl::OnChar(UINT nChar)
{
	switch (nChar)
	{
	case '+':
		if (GetKeyState(VK_ADD) >= 0)		// check keystate to avoid repeating expand
			OnExpand();
		return TRUE;
		
	case '-':
		if (GetKeyState(VK_SUBTRACT) >= 0)	// check keystate to avoid repeating collapse
			OnCollapse();
		return TRUE;
		
	case '*':
		if (GetKeyState(VK_MULTIPLY) >= 0)	// check keystate to avoid repeating expand
		{
			if (GetKeyState(VK_CONTROL) < 0)
				OnExpandAll();
			else
				OnExpandBranch();
		}
		return TRUE;

	case 129:		// '+' from old IME
	case 123:		// '+' from new IME
		if (imeIsOpen())		// check keystate to avoid repeating expand
			OnExpand();
		return TRUE;
		
	case 91:		// '-' from old IME
	case 124:		// '-' from new IME
		if (imeIsOpen())	// check keystate to avoid repeating expand
			OnCollapse();
		return TRUE;
		
	case 150:		// '*' from IME
		if (imeIsOpen())	// check keystate to avoid repeating expand
		{
			if (GetKeyState(VK_CONTROL) < 0)
				OnExpandAll();
			else
				OnExpandBranch();
		}
		return TRUE;
	}
	
	// if enough time has elapsed, or the user hits a control key (e.g.
	// backspace) zero the string.
	time_t timeNow = time(NULL);
	
	// need a place to store the lead byte of a DBC
	static TCHAR cLead;
	BOOL fNextNode = TRUE;

	if (iscntrl(nChar) || (timeNow - m_timeLastKey > LIST_ALPHA_SEARCH_DELAY))
		ClearSearchBuffer();
	else
		fNextNode = FALSE;

	// process the key
	if ((m_pListBox->GetCount() == 0) || iscntrl(nChar))
		return FALSE;

	if (cLead)
	{
		TCHAR szTmp[3];
		szTmp[0] = cLead;
		szTmp[1] = (TCHAR) nChar;
		szTmp[2] = _T('\0');
		
		cLead = 0;
		m_strSearch += CString( szTmp );
	}
	else
	{
		if (IsDBCSLeadByte( (char) nChar ))
		{
			cLead = (TCHAR) nChar;
			return TRUE;
		}

		m_strSearch += CString((char)nChar);
	}
	
	m_timeLastKey = timeNow;

	// look for a match
	CString str;
	int index, indexStart;

	if (fNextNode)
	{
		int nCurSel = GetCurSel();
		if (nCurSel == m_pListBox->GetCount() - 1)
			index = indexStart = 0;
		else
			index = indexStart = nCurSel + 1;
	}
	else
	{
		index = indexStart = max(GetCurSel(), 0);
	}

	do
	{
		GetNodeTitle(GetNode(index), str);
		if (m_strSearch.CompareNoCase(str.Left(m_strSearch.GetLength())) == 0)
		{
			// found a match
			KeySetSel(index, FALSE);
			return TRUE;
		}

		if (++index >= m_pListBox->GetCount())
			index = 0;
	} while (index != indexStart);

	// no match found, but we did handle the key
	return TRUE;
}

void CTreeCtl::KeySetSel(int nIndex, BOOL bClearSearchBuffer)
{
	// called when user selects a specific item with the keyboard
	if (bClearSearchBuffer)
		ClearSearchBuffer();

	if (!m_bIsMultiSelection)
		SetCurSel(nIndex);
	else
	{
		SetSel(-1, FALSE);
		SetSel(nIndex, TRUE);
	}

	OnLbSelChange();
}

void CTreeCtl::ClearSearchBuffer()
{
	m_strSearch.Empty();
}



////////////////////////////////////////////////////////////////////////////
// Outline "command" handlers...

void CTreeCtl::OnPrimary()
{
	if (m_pListBox->GetCaretIndex() != -1)
		OnOpen(m_pListBox->GetCaretIndex());
	ClearSearchBuffer();
}

void CTreeCtl::OnExpand()
{
	CNode* pNode = GetNode();
	if (pNode != NULL && (pNode->m_nFlags & TF_EXPANDABLE) != 0 && !IsExpanded())
		Expand();
	ClearSearchBuffer();
}

void CTreeCtl::OnCollapse()
{
	CNode* pNode = GetNode();
	int nItem = m_pListBox->GetCurSel();
	
	if (pNode != NULL && (pNode->m_nFlags & TF_EXPANDABLE) == 0)
	{
		if (nItem <= 0)
			return;
		
		int nStartLevel = pNode->m_nLevels;
		do
		{
			pNode = GetNode(--nItem);
		}
		while (nItem > 0 && pNode->m_nLevels >= nStartLevel);
	}
	
	if (pNode != NULL && IsExpanded(nItem))
		Collapse(nItem);
		
	ClearSearchBuffer();
}

void CTreeCtl::OnExpandBranch()
{
	int nIndex = GetCurSel();
	if (nIndex != LB_ERR)
		Expand(nIndex, TRUE);
	ClearSearchBuffer();
}

void CTreeCtl::OnExpandAll()
{
	// UNDONE: these cases could be consolidated
	SetCurSel(0);	// work-around for #2909
	ExpandAll();
	ClearSearchBuffer();
}

////////////////////////////////////////////////////////////////////////////


void CTreeCtl::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	lpMeasureItemStruct->itemHeight = m_cyNode;
}

void CTreeCtl::DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt)
{
	// Override this function to provide custom glyphs for folders or other nodes...
	
	c_imageWell.DrawImage(pDC, pt, (pNode->m_nFlags & TF_EXPANDED) != 0 ? 
		nOpenImage : nClosedImage);
}

void CTreeCtl::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	// [patbr] tree control faults with empty list box
	if (lpDrawItemStruct->itemData == NULL || lpDrawItemStruct->itemData == (UINT)-1)
	{
		// list box is empty, so indicate that list box has focus.
		// DrawFocusRect(lpDrawItemStruct->hDC, &(lpDrawItemStruct->rcItem));
		return;								 
	}

	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CNode* pNode = (CNode*)lpDrawItemStruct->itemData;
	CFont* pOldFont = pDC->SelectObject(pNode->GetFont());
	CString strText;
	GetDisplayText(pNode, strText);
	int cchText = strText.GetLength();
	
	CSize sizeText = pDC->GetTextExtent(strText, cchText);

	// make sure that m_cxOffset is even
//	m_cxOffset &= ~1;

	// our drawing starting point for this node from left and top
	CPoint	pt(c_cyBorderX2 + pNode->m_nLevels * m_sizeM.cx * 2 - m_cxOffset, lpDrawItemStruct->rcItem.top);

	// our focus/highlight rectangle for the text
	CRect rect;
	rect.top = lpDrawItemStruct->rcItem.top;
	rect.left = pt.x + 2 * m_sizeM.cx + pNode->GetGlyphWidth() + c_cyBorderX2;
	rect.bottom = lpDrawItemStruct->rcItem.bottom;
	rect.right = rect.left + sizeText.cx + 4 * c_cyBorderX2;
	
	if (lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT))
	{
		int x = pt.x + m_sizeM.cx;	// initial drawing starting position
	//	x &= ~1;	// Make even;
		int y = pt.y + m_cyNode / 2; 
		int yp = y | 1; 

		BOOL bDrawSelected = (lpDrawItemStruct->itemState & ODS_SELECTED) != 0 ||
			(pNode->m_nFlags & TF_DROPTARGET) != 0;
		BOOL bHasFocus = ::GetFocus() == lpDrawItemStruct->hwndItem ||
			(pNode->m_nFlags & TF_DROPTARGET) != 0;
		COLORREF rgbText, rgbBackground;

		// First see if we have tested for expandability yet
		if (!((pNode->m_nFlags & TF_EXPANDABLE) || (pNode->m_nFlags & TF_NOT_EXPANDABLE)))
		{
			if (NodeIsExpandable(pNode))
				pNode->m_nFlags |= TF_EXPANDABLE;
			else
			{
				pNode->m_nFlags |= TF_NOT_EXPANDABLE;
				pNode->m_nFlags &= ~TF_EXPANDED;
			}
		}
		
		// Draw the dotted lines...
		// olympus 6359 [patbr]
		// use system color (button shadow) for tree control dotted lines (as in Windows95)
		COLORREF rgbForeground = pDC->SetTextColor(GetSysColor(COLOR_BTNSHADOW));
		CBrush* pOldBrush = pDC->SelectObject(CDC::GetHalftoneBrush());

		if (pNode->m_pParent != NULL || (pNode->m_nFlags & TF_EXPANDABLE) != 0)
		{
			// Draw the horizontal line over the (possible) folder
			pDC->PatBlt (x, yp, m_sizeM.cx, 1, PATCOPY);
		}
		
		if (pNode->m_pParent != NULL)
		{
			// Draw the top part of the vertical line
			pDC->PatBlt (x, rect.top, 1, m_cyNode / 2, PATCOPY); 
			
			// If not the end of a node, draw the bottom part
			if ((pNode->m_nFlags & TF_LASTLEVELENTRY) == 0)
			{
				pDC->PatBlt (x, y + c_cyBorder, 1, m_cyNode / 2, PATCOPY); 
			}

			// Draw the verticals on the left connecting other nodes
			int nLevel = pNode->m_nLevels;
			for (CNode* pNodeT = pNode->m_pParent; pNodeT != NULL; pNodeT = pNodeT->m_pParent)
			{
				nLevel -= 1;

				if (!(pNodeT->m_nFlags & TF_LASTLEVELENTRY) && (pNodeT->m_pParent != NULL))
				{
					int	x = (nLevel + 1) * m_sizeM.cx * 2 + c_cyBorderX2 - m_sizeM.cx - m_cxOffset;
				//	x &= ~1;	// Make even;
					pDC->PatBlt(x, rect.top, 1, m_cyNode, PATCOPY); 
				}
			}
		}
		
		pDC->SetTextColor(rgbForeground);
		pDC->SelectObject(pOldBrush);
		
		
		// Draw the boxed plus/minus sign if appropriate...
		
		if ((pNode->m_nFlags & TF_EXPANDABLE) != 0)
		{
			// Draw the box	[+] or [-]
			c_imageWell.DrawImage(pDC, 
				CPoint(x - cxExpandBox / 2, yp - cyExpandBox / 2), 
				(pNode->m_nFlags & TF_EXPANDED) ? nMinusImage : nPlusImage);

			// olympus 6359 [patbr]
			// use system color (button shadow) for plus/minus sign frames (as in Windows95)
			COLORREF rgbForeground = GetSysColor(COLOR_BTNSHADOW);
			CBrush br(rgbForeground);
			pOldBrush = pDC->SelectObject(&br);

			pDC->PatBlt(x - cxExpandBox / 2 + 1, yp - cyExpandBox / 2 + 1, cxExpandBox - 2, 1, PATCOPY); 
			pDC->PatBlt(x - cxExpandBox / 2 + 1, yp + cyExpandBox / 2 - 1, cxExpandBox - 2, 1, PATCOPY); 
			pDC->PatBlt(x - cxExpandBox / 2 + 1, yp - cyExpandBox / 2 + 1, 1, cyExpandBox - 2, PATCOPY); 
			pDC->PatBlt(x + cxExpandBox / 2 - 1, yp - cyExpandBox / 2 + 1, 1, cyExpandBox - 2, PATCOPY); 
	
			pDC->SelectObject(pOldBrush);
		}
		
		
		// Draw the glyph...
		
		DrawNodeGlyph(pDC, pNode, bDrawSelected && bHasFocus,
			CPoint(x + m_sizeM.cx + c_cyBorder, y - (cyFolder / 2) - 1));
		
		
		// Draw the text...
		
		if ((bHasFocus || m_bKeepSelectionRect) && bDrawSelected)
		{
			rgbText = pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			rgbBackground = pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}
		
		pDC->ExtTextOut(rect.right - sizeText.cx - c_cyBorderX2 * 2,
			y - (m_sizeM.cy / 2), ETO_OPAQUE, &rect, strText, cchText, NULL);
		
		if (bDrawSelected)
		{
			if (bHasFocus || m_bKeepSelectionRect)
			{
				pDC->SetTextColor(rgbText);
				pDC->SetBkColor(rgbBackground);
			}
			else
			{
				// Highlight is a frame when we don't have the focus...
				CBrush brush;
				if (brush.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)))
					pDC->FrameRect(&rect, &brush);
			}
		}
	}
	
	if (lpDrawItemStruct->itemAction == ODA_FOCUS)
		pDC->DrawFocusRect(&rect);
	
	pDC->SelectObject(pOldFont);
}


void CTreeCtl::Collapse(CNode* pNode, int nIndex)
{
	CNode* pParentNode = pNode;
	int nIndexT = nIndex;
	int cDeleted = 0;
	int iTop = m_pListBox->GetTopIndex();
	int iCurSel = m_pListBox->GetCurSel();

	m_nNextInsertIndex = -1;	// cached next insert index is no longer valid...
	
	m_pListBox->SetRedraw(FALSE);
	
	nIndexT += 1;
	
	for (;;)
	{
		if ((pNode = GetNode(nIndexT)) == NULL)
			break;
		
		if (pNode->m_nLevels <= pParentNode->m_nLevels)
			break;

		DeleteNode(pNode);
		cDeleted++;
		
		m_pListBox->DeleteString(nIndexT);
	}

	pParentNode->m_nFlags &= ~TF_EXPANDED;

	if (iCurSel > nIndex)
	{
		// selection/focus needs was after the collapsed item,
		// need to adjust...

		if (iCurSel <= nIndex + cDeleted)
		{
			// selection/focus was inside the block of deleted
			// items, make the top level node the selected node
			iCurSel = nIndex;

		}
		else
		{
			// selection/focus was after the block of deleted
			// items, move the selection up by the number of
			// deleted items

			iCurSel -= cDeleted;
		}

		m_pListBox->SetCurSel(iCurSel);

		if (m_bIsMultiSelection)
		{
			m_pListBox->SetCaretIndex(iCurSel);
			m_pListBox->SetSel(iCurSel, TRUE);
		}

		OnLbSelChange();	
	}
	
	m_pListBox->SetTopIndex(iTop);

	if (m_EnableUpdates == 0) 
	{
		m_pListBox->SetRedraw (TRUE);
		m_pListBox->Invalidate();
	}
}

void CTreeCtl::Refresh(CNode *pParentNode, int nIndex)
{
	CNode * pNextNode;
	int nIndexT;

	// is this node dirty?
	if (pParentNode->m_nFlags & TF_DIRTY_CONTENT)
	{
		// reset this node dirty bit
		pParentNode->m_nFlags &= ~TF_DIRTY_CONTENT;

		// if is is expanded? then collapse it
		if (pParentNode->m_nFlags & TF_EXPANDED)
			Collapse(nIndex);

		// reset the expandablity of this node
		pParentNode->m_nFlags &= ~(TF_EXPANDABLE | TF_NOT_EXPANDABLE);
		pParentNode->m_nFlags |= NodeIsExpandable(pParentNode) ? TF_EXPANDABLE : TF_NOT_EXPANDABLE;
		// is it potentially expandable?
		if (pParentNode->m_nFlags & TF_EXPANDABLE)
		{
			Expand(nIndex, FALSE);
		}
	}
	// if we have children and we are expanded
	// then perform this function on each of the children first
	else if (pParentNode->m_nFlags & (TF_HASCHILDREN | TF_EXPANDED))
	{
		nIndexT = nIndex + 1;
		for (;;)
		{
			if ((pNextNode = GetNode(nIndexT)) == NULL)
				break;	// do we have a child? ie. not end of list
		
			if (pNextNode->m_nLevels <= pParentNode->m_nLevels)
				break;	// is this one of our siblings?

			if (pNextNode->m_nLevels == (pParentNode->m_nLevels + 1))
				Refresh(pNextNode, nIndexT);	// refresh this child

			nIndexT++;
		}
	}


	if (pParentNode->m_nFlags & TF_DIRTY_ITEM)
	{
		// reset this node dirty bit
		pParentNode->m_nFlags &= ~TF_DIRTY_ITEM;

		// get the (possibly new) text for this node
		CString	strTitle;
		GetNodeTitle(pParentNode, strTitle);

		// [patbr] only reinitialize m_szText if it was non-NULL previously
		if (pParentNode->m_szText != NULL)
		{
			delete [] pParentNode->m_szText;
			pParentNode->m_szText = new char[strTitle.GetLength() + 1];
			_tcscpy(pParentNode->m_szText, strTitle);
		}

		// reset the expandablity of this node
		pParentNode->m_nFlags &= ~(TF_EXPANDABLE | TF_NOT_EXPANDABLE);
		pParentNode->m_nFlags |= NodeIsExpandable(pParentNode) ? TF_EXPANDABLE : TF_NOT_EXPANDABLE;
	}
}

void CTreeCtl::FreeAllTreeData()
{
	int nIndex = m_pListBox->GetCount();
	while (--nIndex >= 0)
	{
		CNode * pNode = (CNode *)m_pListBox->GetItemDataPtr(nIndex);

		DeleteNode(pNode);
	}
	m_pListBox->ResetContent();
}

int CTreeCtl::CompareData(const CNode* pNode1, const CNode* pNode2)
{
	if (pNode1 == pNode2)
		return 0;
	
	int ret = CompareData(pNode1->m_pParent, pNode2->m_pParent);
	
	if (ret == 0)
	{
		// if m_szText fields are NULL then derived class should have CompareData()
		ASSERT(pNode1->m_szText != NULL && pNode2->m_szText != NULL);
		ret = _tcsicmp (pNode1->m_szText, pNode2->m_szText);

		// if we have a match then compare the data
		if (ret == 0 && (pNode1->m_dwData != 0 || pNode2->m_dwData != 0))
		{
			if (pNode1->m_dwData == pNode2->m_dwData)
				ret = 0;
			else
				ret = (int) (pNode1->m_dwData - pNode2->m_dwData);
		}
	}
	
	return ret;
}

int CTreeCtl::CompareNodes(const CNode* pNode1, const CNode* pNode2)
{
	const CNode* pSav1;
	const CNode* pSav2;
	
	pSav1 = pNode1;
	pSav2 = pNode2;
	
	while (pNode1->m_nLevels > pNode2->m_nLevels)
		pNode1 = pNode1->m_pParent;
		
	while (pNode2->m_nLevels > pNode1->m_nLevels)
		pNode2 = pNode2->m_pParent;

	int ret = CompareData(pNode1, pNode2);

	if (ret == 0)
		ret = pSav1->m_nLevels - pSav2->m_nLevels;
	
	return ret;
}

int CTreeCtl::FindNode(DWORD dwData)
{
	int nCount = m_pListBox->GetCount();
	for (int i = 0; i < nCount; i += 1)
	{
		if (GetNode(i)->m_dwData == dwData)
			return i;
	}
	
	return LB_ERR;
}

int CTreeCtl::FindNode(const TCHAR * szText, DWORD & dwData, BOOL fMatchCase)
{
	int nCount = m_pListBox->GetCount();
	for (int i = 0; i < nCount; i += 1)
	{
		CNode * pNode = GetNode(i); ASSERT(pNode != (CNode *)NULL);

		// if m_szText field is NULL then derived class should have FindNode()
		ASSERT(pNode->m_szText != NULL);
		if ((fMatchCase && !_tcsicmp(pNode->m_szText, szText) || !_tcscmp(pNode->m_szText, szText)))
		{
			dwData = pNode->m_dwData;
			return i;	// success, return index of node and assoc. data
		}
	}

	return LB_ERR;	// not found
}

int CTreeCtl::InsertNode(int iParentNode, const char* szName, DWORD dwData)
{
	CNode * pNode;
	int iNode;
	
	if (!InsertNode(GetNode(iParentNode), iParentNode, szName, dwData, pNode, iNode))
		return LB_ERR;
	
	return iNode;
}

void CTreeCtl::DirtyNode(int iNode, WORD tf, BOOL bInvalItem)
{
	CRect rect;
	CNode * pNode = GetNode(iNode);
	ASSERT(pNode != NULL);
	pNode->m_nFlags |= tf;
	InvalItem(iNode);
//	Invalidate();
}

void CTreeCtl::ClearNode(int iNode, WORD tf, BOOL bInvalItem)
{
	CRect rect;
	CNode * pNode = GetNode(iNode);
	ASSERT(pNode != NULL);
	pNode->m_nFlags &= ~tf;
	InvalItem(iNode);
//	Invalidate();
}

void CTreeCtl::RemoveNode(int iNode, BOOL bUpdateSel /* = TRUE*/)
{
	CRect rect,rect1;
	CNode* pNode = GetNode(iNode), *pNode1;
	int i;
	ASSERT(pNode != NULL);
	if ((pNode->m_nFlags & TF_EXPANDED) != 0)
		Collapse(pNode, iNode);

	m_nNextInsertIndex = -1;	// cached next insert index is no longer valid...

	// Don't know anymore if parent is expandable or not:
	if (pNode->m_pParent != NULL)
		pNode->m_pParent->m_nFlags &= ~(TF_EXPANDABLE | TF_NOT_EXPANDABLE);

	if ((pNode->m_nFlags & TF_LASTLEVELENTRY) && (iNode > 0))
	{
		m_pListBox->GetItemRect(iNode, &rect);
		i = iNode - 1;
		do
		{
			pNode1 = GetNode(i);
			m_pListBox->GetItemRect(i, &rect1);
			rect.UnionRect (rect, rect1);
			i--;
		}
		while (i >= 0 && pNode1->m_nLevels != pNode->m_nLevels);

		if (pNode1->m_nLevels == pNode->m_nLevels)
			pNode1->m_nFlags |= TF_LASTLEVELENTRY;
		m_pListBox->InvalidateRect(&rect);
	}

	int iCurSel = m_pListBox->GetCurSel();
	m_pListBox->DeleteString(iNode);
	DeleteNode(pNode);

	if (bUpdateSel && iCurSel == iNode)
	{
		int nCount = m_pListBox->GetCount();
		if (iCurSel > nCount - 1)
			iCurSel = nCount - 1;


		if (!m_bIsMultiSelection)
			m_pListBox->SetCurSel(iCurSel);
		else
		{
			m_pListBox->SetSel(-1, FALSE);
			m_pListBox->SetCaretIndex(iCurSel);
			m_pListBox->SetSel(iCurSel, TRUE);
		}

		OnLbSelChange();
	}
}

BOOL CTreeCtl::InsertNode(CNode* pParentNode, int iParentNode, const char* szName,
		DWORD dwData, CNode*& rpNodeRet, int& riNodeRet, BOOL bUseNodeRet /*=FALSE*/)
{
	CClientDC dc(this);
	dc.SelectObject(GetStdFont(font_Normal));
	
	CNode* pNode = CreateNode(dwData);
	
 	pNode->m_pParent = pParentNode;

#ifdef _DEBUG
	// make sure that the parent links are valid CNode address
	// (we'd use ASSERT_VALID, but CNode is not a CObject)
	CNode * pTemp = pNode;
	while ((pTemp = pTemp->m_pParent) != NULL)
	{	
		ASSERT(AfxIsValidAddress(pTemp, sizeof(CNode)));
	}
#endif

	pNode->m_nLevels = pParentNode != NULL ? (pParentNode->m_nLevels + 1) : 0;
	pNode->m_dwData = dwData;
	pNode->m_nFlags = TF_CHILD_SORT_ALPHA;

	// [patbr] szName can be passed in NULL if the node's title will always be
	// obtained some other way besides pNode->szText (e.g., in project window).
	if (szName != NULL)
	{
		int len = _tcslen(szName);
		pNode->m_szText = new char[len + 1];
		_tcscpy(pNode->m_szText, szName);
	}
		
	if (pParentNode != NULL)
	{
		pParentNode->m_nFlags |= TF_HASCHILDREN | TF_EXPANDED | TF_EXPANDABLE;
	 	pParentNode->m_nFlags &= ~TF_NOT_EXPANDABLE;
	}
	
	CString strText;
	GetDisplayText(pNode, strText);

	CFont* pOldFont = dc.SelectObject(pNode->GetFont());
	pNode->m_nWidth = dc.GetTextExtent(strText, strText.GetLength()).cx + 
		(2 * (pNode->m_nLevels + 1)) * m_sizeM.cx + 
		pNode->GetGlyphWidth() + c_cyBorderX2 * 6;
	dc.SelectObject(pOldFont);

	int iMax;

	if (bUseNodeRet)
		iMax = riNodeRet;
	else
	{
		if ((pParentNode == NULL && !m_bSortRootNodes) ||
			(pParentNode != NULL && pParentNode->m_nFlags & TF_CHILD_SORT_NONE))
		{
			if (m_nNextInsertIndex != -1 && iParentNode == m_nLastParentIndex)
			{
				// use cached insertion point
				iMax = m_nNextInsertIndex++;
			}
			else
			{
				if (pParentNode == NULL || iParentNode == m_pListBox->GetCount() - 1)
					iMax = m_pListBox->GetCount();	// insert at bottom of listbox
				else
				{
					iMax = iParentNode + 1;
					while (iMax < m_pListBox->GetCount())
					{
						CNode* pNodeT = GetNode(iMax);
						if (pNodeT->m_nLevels <= pParentNode->m_nLevels)
							break;
						iMax++;
					}
				}
				// set up cache indices so if next insert is also in this parent
				// node the insertion point can be quickly calculated.
				m_nLastParentIndex = iParentNode;
				m_nNextInsertIndex = iMax + 1;
			}
		}
		else
		{
			m_nNextInsertIndex = -1;	// cached next insert index is no longer valid...

			// Find the insert point with a binary search	
			iMax = m_pListBox->GetCount();
			if (iMax > 0)
			{
				int iMin = iParentNode + 1;
				if (iMin < iMax)
				{
					CNode *pNodeMin = GetNode(iMin);

					if (pParentNode != NULL && pNodeMin->m_nLevels <= pParentNode->m_nLevels)
					{
						iMax = iMin;
					}
					else
					{
						iMax = iParentNode + 1;
						while (iMax < m_pListBox->GetCount())
						{
							CNode* pNodeT = GetNode(iMax);
							if (pParentNode != NULL && pNodeT->m_nLevels <= pParentNode->m_nLevels)
								break;
							iMax++;
						}
								
						do
						{
							int iMid = (iMax + iMin) / 2;
							
							CNode* pMid = GetNode(iMid);
#ifdef _DEBUG
							CNode * pTemp = pMid;
							while ((pTemp = pTemp->m_pParent) != NULL)
							{	
								ASSERT(AfxIsValidAddress(pTemp, sizeof(CNode)));
							}
#endif

							if (CompareNodes(pNode, pMid) > 0)
								iMin = iMid + 1;
							else
								iMax = iMid - 1;
						}
						while (iMax > iMin);

						// can't compare to our parent? (we are at the root if iMax < 0)
						if (iMax >= 0)
						{
							if (iMax < m_pListBox->GetCount())
							{
								CNode* pNodeT = GetNode(iMax);
								if ((pNodeT == pParentNode) || (pNodeT->m_nLevels >= pNode->m_nLevels && CompareNodes(pNode, pNodeT) > 0))
									iMax += 1;
							}
						}
						else
						{
							iMax = 0;	// insert at front
						}
					}
				}
			}
		}
	}
			
	// look for the first node on this level above us and turn off its
	// TFD_LASTLEVELENTRY flag so it gets a line down to this node
	
	int i = iMax - 1;
	while (i >= 0)
	{
		CNode* pNodeT = GetNode(i--);
		if (pNodeT->m_nLevels == pNode->m_nLevels)
		{
			pNodeT->m_nFlags &= ~TF_LASTLEVELENTRY;
			break;
		}
		
		if (pNodeT->m_nLevels < pNode->m_nLevels)
			break;
	}
	
	CNode* pNodeT;
	if ((pNodeT = GetNode(iMax)) == NULL ||
		pNodeT->m_nLevels < pNode->m_nLevels)
	{
		pNode->m_nFlags |= TF_LASTLEVELENTRY;
	}
	
    rpNodeRet = pNode;
	riNodeRet = m_pListBox->InsertString(iMax, (LPSTR)pNode);
		
	return TRUE;
}

BOOL CTreeCtl::InsertLevel(CNode* pParentNode, int nParentIndex, BOOL bExpandAll)
{
	// NOTE: This function must be overridden for a CTreeCtl to be useful,
	// this is a template of what a real one should look like.
	/*
	for (each item in pParentNode)
	{
		CNode* pNode;
		int iNode;
		if (!InsertNode(pParentNode, nParentIndex, "string", 0, pNode, iNode))
		{
			TRACE("CTreeCtl::InsertLevel: call to InsertNode failed!\n");
			return FALSE;
		}
		
		if (pNode has children && bExpandAll && !InsertLevel(pNode, iNode, TRUE))
			return FALSE;
	}
	*/

	ASSERT(FALSE);
	
	return TRUE;
}

CNode* CTreeCtl::GetNode(int nIndex)
{
	if (nIndex == -1 && (nIndex = GetCurSel()) == LB_ERR)
		return NULL;
	
	CNode* pNode = (CNode*)m_pListBox->GetItemData(nIndex);
	if (pNode == (CNode*)LB_ERR)
		return NULL;
	
	return pNode;
}

BOOL CTreeCtl::NodeIsExpandable(CNode *)
{
	// NOTE: This function must be overridden for a CTreeCtl to be useful,
	ASSERT (FALSE);

	return FALSE;
}

void CTreeCtl::Expand(int nIndex, BOOL bWholeBranch)
{
	if (nIndex == -1)
	{
		nIndex = GetCurSel();
		if (nIndex == LB_ERR)	// ignore if no current selection
			return;
	}
	else if (bWholeBranch && GetCurSel() != LB_ERR && nIndex != GetCurSel())
	{
		SetCurSel(nIndex);
	}
	
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::Expand: %d invalid index!\n", nIndex);
		return;
	}

	// Update the nodes expandable/unexpandable bit.  Then see if we can
	// really expand this node:
	if (!((pNode->m_nFlags & TF_EXPANDABLE) || (pNode->m_nFlags & TF_NOT_EXPANDABLE)))
	{
		if (NodeIsExpandable(pNode))
			pNode->m_nFlags |= TF_EXPANDABLE;
		else
		{
			pNode->m_nFlags |= TF_NOT_EXPANDABLE;
			pNode->m_nFlags &= ~TF_EXPANDED;
			return;
		}
	}
	
	if ((pNode->m_nFlags & TF_EXPANDED) && (!bWholeBranch))  // [KRS:2020]
		return;			// nothing to do unless recursive
	
	CWaitCursor waitCursor;

	m_pListBox->SetRedraw(FALSE);
	
	// FUTURE: there appears to be no logic here for handling multiple-selection??
	int iCurrentIndex = GetCurSel();
	int iNumExpanded = m_pListBox->GetCount();
	int iTopIndex = m_pListBox->GetTopIndex();
	CRect rc; m_pListBox->GetClientRect(&rc);
	int iBottomIndex = iTopIndex + (rc.bottom + 1) / m_cyNode;

	// this is a really bad hack and it complicates the logic
	// for figuring out how to adjust the selection as a result
	// of doing an expand.  The problem is that this might be
	// an expand-all operation in which case we want the whole
	// tree to appear but we don't have code to do that if
	// the tree is already partly expanded so we do this collapse
	// and then expand thing... swell... [rm]
	
	if (pNode->m_nFlags & TF_EXPANDED) // [KRS:2020]
	{
		ASSERT(bWholeBranch);
		// PDC hack: collapse tree before expanding to avoid having
		// to deal with partially expanded branches
		Collapse(pNode,nIndex);
		m_pListBox->SetRedraw(FALSE);
	}

	// must get the state after the possible delete above because
	// the selection and count may have changed...  I know this
	// is redundant but until the above code can be deleted
	// we can't use the variables that are already available [rm]

	int iCurSel = m_pListBox->GetCurSel();	// sel after possible collapse above
	BOOL bSelCurSel = TRUE;
	if (m_bIsMultiSelection)
		bSelCurSel = m_pListBox->GetSel(iCurSel) > 0;

	int cItemsNew = m_pListBox->GetCount();  // kinda redundant with iNumExpanded

	InsertLevel(pNode, nIndex, bWholeBranch);
	
	int iExpandInView = iBottomIndex - iCurrentIndex;
	iNumExpanded = m_pListBox->GetCount() - iNumExpanded;

	cItemsNew = m_pListBox->GetCount() - cItemsNew;

	if (iCurSel > nIndex)
	{
		// selection was after the expand point, must adjust...

		iCurSel += cItemsNew;

		m_pListBox->SetCurSel(iCurSel);

		if (m_bIsMultiSelection)
		{
			m_pListBox->SetCaretIndex(iCurSel);
			m_pListBox->SetSel(iCurSel, bSelCurSel);
		}

		OnLbSelChange();
	}
	
	if (iNumExpanded >= iExpandInView)
	{
		m_pListBox->SetTopIndex(min(nIndex, iTopIndex + iNumExpanded - iExpandInView + 1));
	}
	
	RecalcHorizontalExtent ();
	if (m_EnableUpdates == 0) 
	{
		m_pListBox->SetRedraw (TRUE);
		if (iNumExpanded != 0)
			m_pListBox->Invalidate();
	}
	
}

void CTreeCtl::ExpandAll()
{
	int nIndex = 0;
	CNode * pNode;

	HoldUpdates();

	while ((pNode = GetNode(nIndex)) != (CNode *)NULL)
	{
		// root node?
		if (pNode->m_nLevels == 0)
			Expand(nIndex, TRUE);
		nIndex++;
	}
	SetCurSel(0);

	EnableUpdates();
}

void CTreeCtl::Collapse(int nIndex)
{
	if (nIndex == -1)
		nIndex = GetCurSel();
	
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::Collapse: %d invalid index!\n", nIndex);
		return;
	}
	
	if ((pNode->m_nFlags & TF_EXPANDED) == 0)
		return;
	
	Collapse(pNode, nIndex);
	RecalcHorizontalExtent ();
}

void CTreeCtl::RefreshAllRoots()
{
	if (m_EnableUpdates > 0) return;

	int nIndex = 0;
	CNode * pNode;
	while ((pNode = GetNode(nIndex)) != (CNode *)NULL)
	{
		// root node?
		if (pNode->m_nLevels == 0)
			Refresh(pNode, nIndex);
		nIndex++;
	}
}

void CTreeCtl::Refresh(int nIndex)
{
	if (m_EnableUpdates > 0) return;

	if (nIndex == -1)
		nIndex = GetCurSel();
	
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::Refresh: %d invalid index!\n", nIndex);
		return;
	}
	
	Refresh(pNode, nIndex);
}

BOOL CTreeCtl::IsExpanded(int nIndex)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::IsExpanded: %d invalid index!\n", nIndex);
		return FALSE;                             
	}
	
	return (pNode->m_nFlags & TF_EXPANDED) != 0;
}

BOOL CTreeCtl::HasChildren(int nIndex /*= -1*/ )
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::HasChildren: %d invalid index!\n", nIndex);
		return FALSE;                             
	}
	
	return (pNode->m_nFlags & TF_HASCHILDREN) != 0;
}

DWORD CTreeCtl::GetData(int nIndex)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
		return NULL;
	return pNode->m_dwData;
}

void CTreeCtl::SetData(int nIndex, DWORD dwData)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode == NULL)
	{
		TRACE("CTreeCtl::SetData %d invalid index\n", nIndex);
		return;
	}
	
	pNode->m_dwData = dwData;
}


CTreeCtl::HIT_ZONE CTreeCtl::HitTest(int nItem, int x)
{
	CNode* pNode = GetNode(nItem);
	ASSERT(pNode != NULL);
	
	CRect client;
	GetClientRect(client);
	
	if (m_cxExtent > client.right)
	{
		if (m_cxOffset)
			x += m_cxOffset;
		else
			x += m_pListBox->GetScrollPos(SB_HORZ) * (m_cxExtent - client.right) / 100;
	}

	int xLeft = c_cyBorderX2 + pNode->m_nLevels * m_sizeM.cx * 2;

	if ((m_bVertLineAction) && (x < xLeft) && (pNode->m_nLevels > 0) &&
		((x % (m_sizeM.cx * 2)) == (c_cyBorderX2 + m_sizeM.cx)))
	{
		return vertline;
	}

	if ((pNode->m_nFlags & TF_EXPANDABLE) != 0)
	{
		if (x < xLeft)
			return left;
		if (x < xLeft + 2 * m_sizeM.cx)
			return expand;
	}
#if 0
	else
	{
		if (x < xLeft)
			return left;
		if (x == xLeft + m_sizeM.cx)
			return vertline;
	}
#endif	
	xLeft += 2 * m_sizeM.cx;
	if (x < xLeft)
		return left;
	
	xLeft += cxFolder + c_cyBorderX2;
	if (x < xLeft)
		return glyph;
	
	CClientDC dc(this);
	dc.SelectObject(pNode->GetFont());

	// Extra area between primary glyph and text is in the text zone...
	xLeft += pNode->GetGlyphWidth() - cxFolder;
	
	CString strText;
	GetDisplayText(pNode, strText);
	xLeft += dc.GetTextExtent(strText, strText.GetLength()).cx +
		4 * c_cyBorderX2;
	if (x < xLeft)
		return text;
	
	return right;
}

/////////////////////////////////////////////////////////////////////////////
// CTreeListBox -- the actual list box inside a tree control

int CTreeListBox::iSlobPixels = 5;
CPoint CTreeListBox::mouseDownPt;

CTreeListBox::CTreeListBox()
{
	m_pTree = NULL;
    m_bGotMouseDown = FALSE;
    m_bDeferedDeselection = FALSE;
	m_bStdMouse = TRUE;
}

int CTreeListBox::ItemFromPoint(const CPoint& point)
{
    CRect client;
    GetClientRect(&client);

    if (!client.PtInRect(point))
        return LB_ERR;

    CRect itemRect;
    GetItemRect(0, &itemRect);

	int nItem = (GetTopIndex() + (point.y / itemRect.Height()));
	return nItem < GetCount() ? nItem : LB_ERR;
}

void CTreeListBox::OnLButtonDown(UINT nFlags, CPoint pt)
{
	BOOL bPassOn = TRUE;

	SetFocus();
	SetCapture();

	m_bStdMouse = TRUE;
	
	int nItem = ItemFromPoint(pt);
	if (nItem != LB_ERR)
	{
		int nCurSel = GetCurSel();
		int nCount = GetCount();

		CTreeCtl::HIT_ZONE hitZone = m_pTree->HitTest(nItem, pt.x);

		if (hitZone == CTreeCtl::vertline)
		{
			// user clicked on vertical line down from a
			// node--find that node and collapse it.
			CRect rectClient;
			GetClientRect(rectClient);
			int x = pt.x;
			if (m_pTree->GetHorzExtent() > rectClient.right)
			{
				if (m_pTree->GetHorzOffset())
					x += m_pTree->GetHorzOffset();
				else
					x += GetScrollPos(SB_HORZ) * (m_pTree->GetHorzExtent() - rectClient.right) / 100;
			}

			CNode* pNode = m_pTree->GetNode(nItem);
			int nLevelCollapse = (x - GetSystemMetrics(SM_CYBORDER) - m_pTree->GetSizeM().cx) / (m_pTree->GetSizeM().cx * 2);
			int nItemCollapse = nItem;
			while (--nItemCollapse >= 0)
			{
				CNode *pNodeCollapse = m_pTree->GetNode(nItemCollapse);
				if (pNodeCollapse->m_nLevels == nLevelCollapse)
				{
					m_pTree->Collapse(nItemCollapse);
					SetCurSel(nItemCollapse);
					return;
				}
			}
		}
		
		if (hitZone == CTreeCtl::expand)
		{
			// Inside the expand/collapse box...
		
			m_pTree->DoOpenItem(nItem);

			if (nItem < nCurSel)
			{
				if (GetCount() > nCount)
				{
					// did expand, change selection accordingly
					SetCurSel(nCurSel + GetCount() - nCount);
				}
				else if (GetCount() < nCount)
				{
					// did collapse, change selection accordingly
					if (nCurSel > (nItem + (nCount - GetCount())))
					{
						// previous selection not in collapsed area, reset selection
						SetCurSel(nCurSel + GetCount() - nCount);
					}
					else
					{
						// previous selection in collapsed area, set selection to collapsed node
						SetCurSel(nItem);
					}
				}
			}

			// don't change selection unless we just cleared in
			// by collapsing the tree...
			if (GetSelCount() != 0)
				return;
		}
	
		if (m_pTree->m_bEnableDragDrop && 
			(hitZone == CTreeCtl::glyph || hitZone == CTreeCtl::text))
		{
			// Inside glyph or text and D&D is enabled...
		
			m_bStdMouse = FALSE;
		    m_bGotMouseDown = TRUE;
		    mouseDownPt = pt;

		    if ((nFlags & MK_SHIFT) == 0 && GetSel(nItem))
			{
		        // don't deselect yet, wait for either a mouse up or a drag and drop
		        m_bDeferedDeselection = TRUE;
		        m_nDeferedItem = nItem;
				return;
			}
			else
			{
				if ((nFlags & MK_SHIFT) != 0)
				{
					// Shift held down - so select a range, but do not pass on.
					int nCurrentSel;

					SetSel(-1, FALSE);
					nCurrentSel = GetCaretIndex();
					if (nCurrentSel > nItem)
						SelItemRange(TRUE, nItem, nCurrentSel);
					else
						SelItemRange(TRUE, nCurrentSel, nItem);
 				}
				else
				{
 					// Only clear selection if CONTROL key not pressed
					if ((nFlags & MK_CONTROL) == 0)
						SetSel(-1, FALSE);
			    	SetSel(nItem, TRUE);
				}
				bPassOn = FALSE;
			}
		}
	}
	else
	{
		// clear the selection for Chicago-consistent behavior.
		SetSel(-1, FALSE);
		// the caret should not be moved so that any action (up, down, etc.)
		// will start from the previous caret location.
	}

	if (bPassOn)
		CListBox::OnLButtonDown(nFlags, pt);	// pass on

	if (m_pTree->m_bEnableDragDrop)
	{
#ifdef _WIN32
	    GetParent()->SendMessage(WM_COMMAND, 
			MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());
#else
	    GetParent()->SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	        MAKELPARAM(GetSafeHwnd(), LBN_SELCHANGE));
#endif
	}
}

void CTreeListBox::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int nItem = ItemFromPoint(point);
	if (nItem != LB_ERR)
	{
		switch (m_pTree->HitTest(nItem, point.x))
		{
		case CTreeCtl::expand:
			// Treat as single click...
			m_pTree->DoOpenItem(nItem);
			return;
			
		case CTreeCtl::left:
		case CTreeCtl::right:
			// Ignore the double click...
			return;
		
		case CTreeCtl::glyph:
		case CTreeCtl::text:
			break;
		}
	}

	CListBox::OnLButtonDblClk(nFlags, point);
}

void CTreeListBox::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bStdMouse || !m_pTree->m_bEnableDragDrop)
	{
		CListBox::OnMouseMove(nFlags, point);
		return;
	}

    // Nasty hack here because Windows sends a continuous stream of
    // WM_MOUSEMOVE messages when a button is held down...
    static CPoint NEAR lastPoint;
    if ((point == lastPoint) || (GetCount() == 0))
        return;

    lastPoint = point;

    CPoint offsetPoint (abs(mouseDownPt.x - point.x),
                        abs(mouseDownPt.y - point.y));

    if (m_bGotMouseDown && offsetPoint.x + offsetPoint.y > iSlobPixels && GetSelCount() > 0)
    {
		// Begin a drag...
		m_pTree->BeginDragDrop();

        m_bGotMouseDown = FALSE;
        m_bDeferedDeselection = FALSE;
    }
}

BOOL CTreeListBox::PreTranslateMessage(MSG *pMsg)
{
	return CListBox::PreTranslateMessage(pMsg);
}

void CTreeListBox::OnLButtonUp(UINT nFlags, CPoint pt)
{
	if (!m_bStdMouse && m_pTree->m_bEnableDragDrop)
	{
		m_bGotMouseDown = FALSE;

		if (m_bDeferedDeselection)
		{
		    if (nFlags & MK_CONTROL)
		    {
		        SetSel(m_nDeferedItem, FALSE);
		    }
		    else
		    {
		        SetSel(-1, FALSE);
		        SetSel(m_nDeferedItem, TRUE);
		    }
		    m_bDeferedDeselection = FALSE;
#ifdef _WIN32
	        GetParent()->SendMessage(WM_COMMAND, 
				MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());
#else
	        GetParent()->SendMessage(WM_COMMAND, (WPARAM) GetDlgCtrlID(),
	            MAKELPARAM(GetSafeHwnd(), LBN_SELCHANGE));
#endif
		}
    }

    // need to call Windows so notifications get sent
    CListBox::OnLButtonUp(nFlags, pt);
	ReleaseCapture();
}

void CTreeListBox::OnRButtonDown(UINT nFlags, CPoint pt)
{
	SetFocus();
	SetCapture();

	m_bStdMouse = TRUE;

	int nItem = ItemFromPoint(pt);
	if (nItem != LB_ERR)
	{
		int nCurSel = GetCurSel();
		int nCount = GetCount();

		CTreeCtl::HIT_ZONE hitZone = m_pTree->HitTest(nItem, pt.x);

		if (m_pTree->m_bEnableDragDrop && 
			(hitZone == CTreeCtl::glyph || hitZone == CTreeCtl::text))
		{
			m_bStdMouse = FALSE;
			m_bGotMouseDown = TRUE;
			mouseDownPt = pt;

		    if (GetSel(nItem))
			{
		        // don't deselect yet, wait for either a mouse up or a drag and drop
		        m_bDeferedDeselection = TRUE;
		        m_nDeferedItem = nItem;
				return;
			}
			SetSel(-1, FALSE);
	    	SetSel(nItem, TRUE);

		}
	}


	CListBox::OnRButtonDown(nFlags, pt);	// pass on

	CWnd *	pwnd = GetParent();

	ASSERT(pwnd->IsKindOf(RUNTIME_CLASS(CTreeCtl)));

	// inform the tree control of this
	((CTreeCtl *)pwnd)->OnRightButtonDown(nFlags, pt);

}

void CTreeListBox::OnRButtonUp(UINT nFlags, CPoint pt)
{
	SetFocus();

	CSlobWnd* pWnd = GetActiveSlobWnd();
	if (!(m_pTree->m_bShowContextPopup && pWnd->IsChild(this)))
		return;
	
	int nItem = ItemFromPoint(pt);
	if (nItem != LB_ERR)
	{
		if (!GetSel(nItem))
		{
	        if (SetSel(-1, FALSE) == LB_ERR || SetSel(nItem, TRUE) == LB_ERR)
				SetCurSel(nItem);
		}
		else
		{
			SetCaretIndex(nItem);
		}
	}
	else
	{
		// clear the selection so that the 'window' properties can be viewed.
		// this done primarily for the project window so pane properties can
		// be obtained with a simple right-click over empty portion of tree.
		SetSel(-1, FALSE);
		// the caret should not be moved so that when focus returns to the tree
		// any action (up, down, etc.) will start from the previous caret location.
	}

	m_bGotMouseDown = FALSE;
	m_bDeferedDeselection = FALSE;

	GetParent()->SendMessage(WM_COMMAND, MAKELONG(GetDlgCtrlID(), LBN_SELCHANGE), (LPARAM)GetSafeHwnd());

	UpdateWindow();	// So we don't blow save bits.

	ClientToScreen(&pt);
	pWnd->ShowContextPopupMenu(pt);
}

void CTreeListBox::OnKeyDown(UINT nChar, UINT nRepCount, UINT nFlags)
{
	if (m_pTree->OnKeyDown(nChar))
		return;

	CListBox::OnKeyDown(nChar, nRepCount, nFlags);
}

void CTreeListBox::OnChar(UINT nChar, UINT nRepCount, UINT nFlags)
{
	if (m_pTree->OnChar(nChar))
		return;

	CListBox::OnChar(nChar, nRepCount, nFlags);
}

void CTreeCtl::OnRightButtonUp(UINT, CPoint)
{
	// do nothing .. derived class implementation is more useful
}

void CTreeCtl::OnRightButtonDown(UINT, CPoint)
{
	// do nothing .. derived class implementation is more useful
}

void CTreeCtl::OnLbDblClk()
{	
	// CHICAGO: Move property activation to rbutton.
	if (m_bShowProperties && (GetKeyState(VK_MENU) & ~1) != 0)
	{
		ActivatePropertyBrowser();
		return;
	}

	OnPrimary();
}

void CTreeCtl::OnLbSelChange()
{
	OnSelect(GetCurSel());
}

void CTreeCtl::OnOpen(int nIndex)
{
	// if it's decided that 'Enter' and left-mouse-double-click should
	// not expand/collapse folders then remove the code below [patbr].
	CNode* pNode = GetNode(nIndex);
	if (pNode != NULL)
	{
		if (IsExpanded(nIndex))
			Collapse(nIndex);
		else if (pNode->m_nFlags & TF_EXPANDABLE)
			Expand(nIndex);
	}
}

void CTreeCtl::DoOpenItem(int nIndex)
{
	CNode* pNode = GetNode(nIndex);
	if (pNode != NULL)
	{
		if (IsExpanded(nIndex))
			Collapse(nIndex);
		else if (pNode->m_nFlags & TF_EXPANDABLE)
			Expand(nIndex);
	}
}

void CTreeCtl::OnSelect(int nIndex)
{
	// Make sure expandable state has been set.
	CNode* pNode = GetNode(nIndex);
	if (!((pNode->m_nFlags & TF_EXPANDABLE) || (pNode->m_nFlags & TF_NOT_EXPANDABLE)))
	{
		if (NodeIsExpandable(pNode))
			pNode->m_nFlags |= TF_EXPANDABLE;
		else
		{
			pNode->m_nFlags |= TF_NOT_EXPANDABLE;
			pNode->m_nFlags &= ~TF_EXPANDED;
		}
	}
}


struct TreeData
{
	WORD	wSize;
	int 	nCurSel;
	int		nLastSel;
	int		nTopIndex;
	int		nExpandedNodes[1];
};

BYTE* CTreeCtl::GetInitData()
{
	// Create a block of intit data for workspace saving.  This should enable the
	// reconstruct its state in ReadInitData.

	int nIndex = m_pListBox->GetCount(), nExpanded = 0, i, nDataSize;
	int *pint = new int[nIndex];
	TreeData *pdata;
	ASSERT (nIndex);
	for (i=0; i < nIndex; i++)
	{
		CNode * pNode = (CNode *) m_pListBox->GetItemDataPtr(i);
		if (pNode->m_nFlags & TF_EXPANDED) pint[nExpanded++] = i;
	}

	nDataSize = sizeof (TreeData) + max (nExpanded -1,0) * sizeof (int);

	pdata = (TreeData *) new BYTE[ nDataSize ];
	pdata->wSize = nDataSize - sizeof ( WORD );

	pdata->nTopIndex = m_pListBox->GetTopIndex ();

	if (nExpanded > 0)
		memcpy ( pdata->nExpandedNodes, pint, nExpanded * sizeof (int));
	else pdata->nExpandedNodes[0] = -1;

	if (m_bIsMultiSelection)
	{
		pdata->nLastSel = m_pListBox->GetSelItems (m_pListBox->GetCount(), pint);
		pdata->nCurSel = *pint;
		pdata->nLastSel += *pint;
	}
	else pdata->nCurSel = m_pListBox->GetCurSel ();

	delete [] (pint);
	return (BYTE *) pdata;
}						 	

void CTreeCtl::ReadInitData (CPartFrame *pFrame)
{
	int i,j, nItems, nItemsBox;
	CNode *pNode;
	ASSERT (pFrame->IsKindOf ( RUNTIME_CLASS ( CPartFrame )));
	TreeData  *pdata = (TreeData  *) pFrame->GetCurData ();

	if (pdata == NULL) return;

	RefreshAllRoots();

	if (pdata->nExpandedNodes[0] != -1)
	{
		nItems = (pdata->wSize + sizeof (WORD) - sizeof ( TreeData ))
					 / sizeof (int) + 1;
		nItemsBox = m_pListBox->GetCount();
		Expand (0);
		i=0; j=0;
		while ( i < nItems && j < nItemsBox)
		{
			while (j < pdata->nExpandedNodes[i] )
			{
				if ((pNode = (CNode *) m_pListBox->GetItemDataPtr(j))
									== (CNode *) -1 )
				{
					TRACE ("Tree control state read failed.\n");
					return;
				}
				if (pNode->m_nFlags & TF_EXPANDED)
				{
					Collapse (j);
					nItemsBox = m_pListBox->GetCount();
				}
				j++;
			}
			if ((pNode = (CNode *) m_pListBox->GetItemDataPtr(j))
									== (CNode *) -1 )
			{
				TRACE ("Tree control state read failed.\n");
				return;
			}
			if ( !(pNode->m_nFlags & TF_EXPANDED) ) 
			{
				Expand (j);
				nItemsBox = m_pListBox->GetCount();
			}
			j++;
			i++;	
		}
		// Collaps any remaining nodes: 
		while (j < nItemsBox) 
		{
			VERIFY ((pNode =  (CNode *) m_pListBox->GetItemDataPtr(j))
									!= (CNode *) -1 );
			if (pNode->m_nFlags & TF_EXPANDED)
			{
				Collapse (j);
				nItemsBox = m_pListBox->GetCount();
			}
			j++;
		}

	}
	else Collapse (0);

	if (m_bIsMultiSelection)
	{
		for (i = pdata->nCurSel; i < pdata->nLastSel; i++)
			m_pListBox->SetSel (i, TRUE);
	}
	else m_pListBox->SetCurSel (pdata->nCurSel);

	m_pListBox->SetTopIndex (pdata->nTopIndex);	
}

void CTreeCtl::SizeViewToTree ( CPartFrame *pFrame )
{
	CRect rcView, rcListBox, rcParent;
	int dl, curWidth, cxm, cxe;
	BOOL bIsMax;

	RefreshAllRoots();

	// If the MDI child is maximized, then don't do anything:
	pFrame->GetMDIFrame()->MDIGetActive ( &bIsMax );
	if (bIsMax) return;

	m_pListBox->GetWindowRect (rcListBox);	 
	pFrame->GetWindowRect   (rcView);
	curWidth = rcView.Width (); 
	cxe = m_cxExtent + GetSystemMetrics (SM_CXHSCROLL) * 2;
	cxm = m_sizeM.cx << 5;
	dl = curWidth - rcListBox.Width () + max (cxe, cxm);
	// If we're make the window bigger, don't make it too big:
	if (dl > rcView.Width () )
	{
		pFrame->GetParent()->GetWindowRect   (rcParent);
		cxe = rcParent.Width() * 2 / 3;
		cxm = max (curWidth, cxe); 
		dl = min (dl, cxm);
	}
	pFrame->SetWindowPos (
						NULL, 
						0,
						0,
						dl,
						rcView.Height (),
						SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE	
						);

	if (m_bIsMultiSelection) m_pListBox->SetSel (0, TRUE);
	else m_pListBox->SetCurSel (0);
	m_pListBox->SetTopIndex (0);	
}

void  CTreeCtl::HoldUpdates ()
{
	if (m_EnableUpdates == 0) m_pListBox->SetRedraw (FALSE);
	m_EnableUpdates++;
}
void  CTreeCtl::EnableUpdates ()
{
	m_EnableUpdates--;
	if (m_EnableUpdates == 0)
	{
		m_pListBox->SetRedraw (TRUE);
		m_pListBox->Invalidate();
	}

	ASSERT (m_EnableUpdates >= 0);
}

void CTreeCtl::GetNodeTitle(CNode* pNode, CString& strTitle)
{
	strTitle = pNode->m_szText;
}

void CTreeCtl::GetDisplayText(CNode* pNode, CString& strDisplayText)
{
	strDisplayText = pNode->m_szText;
}

CNode* CTreeCtl::CreateNode(DWORD dwData)
{
	return new CNode(dwData);
}

void CTreeCtl::DeleteNode(CNode* pNode)
{
	delete pNode;
}

void CTreeCtl::BeginDragDrop()
{
	TRACE("Must override CTreeCtl::BeginDragDrop for drag/drop functionality!\n");
}

int CNode::m_nGlyphWidth = 0; // static

CNode::CNode(DWORD dwData)
{
	m_szText = NULL;
	m_dwData = dwData;
	if (m_nGlyphWidth==0)  // init only once
	{
		// FUTURE: no longer variable
		m_nGlyphWidth = cxFolder;
	}
}

CNode::~CNode()
{
	delete [] m_szText;
}

CFont* CNode::GetFont() const
{
	return GetStdFont(font_Normal);
}

int CNode::GetGlyphWidth()
{
	return m_nGlyphWidth;
}

int CNode::GetGlyphHeight()
{
	return cyFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\undoctl.h ===
// undoctl.h : undo/redo controls
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __UNDOCTL_H__
#define __UNDOCTL_H__

class CDropControl;

/////////////////////////////////////////////////////////////////////////////
// CGhostListBox control

class CGhostListBox : public CListBox
{
// Construction
public:
	CGhostListBox();

// Attributes
public:

// Operations
public:

// Implementation
public:
	virtual ~CGhostListBox();

	BOOL	Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CDropControl* pDropControl);
	
	CDropControl*	m_pDropControl;	// drop control to send all mouse msgs
	int 	GetBottomIndex();

	// Generated message map functions
protected:
	//{{AFX_MSG(CGhostListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CGhostListBox)
};


/////////////////////////////////////////////////////////////////////////////
// CUndoList window

class CUndoList : public CWnd
{
public:
	enum {
		BORDERSIZE = 3,
		STATUSHEIGHT = 16
	};
	
// Construction
public:
	CUndoList();

// Attributes
public:

// Operations
public:
	void	ShowList(BOOL bShow, CRect rc, CDropControl* pParent);
	CRect	CalcStatusRect(CRect rc);
	void	SetSel(int index);
	int 	GetSel();
	int 	CalcSel(CPoint point);
	void	ScrollDown();
	void	ScrollUp();
	void	PageDown();
	void	PageUp();

// Implementation
public:
	virtual ~CUndoList();
	
	CGhostListBox	m_listBox;

	// Generated message map functions
protected:
	//{{AFX_MSG(CUndoList)
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg LRESULT OnDestroySelf(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CDropControl : public CWnd
{
public:
	DECLARE_DYNAMIC(CDropControl)
	
	enum {
		BS_DEFAULT = 0,
		BS_LCLICK = 1,
		BS_RCLICK = 2,
		BS_DROP = 3,
		BS_EXTRUDED=4,
		smallWidth = 37,
		smallHeight = 22,
		smallLeftWidth = 22,
		smallImageWidth=16,
		smallImageHeight=15,
		largeWidth = 53,
		largeHeight = 38,
		largeLeftWidth = 38,
		largeImageWidth=32,
		largeImageHeight=32,
		ID_TIMER = 89,
		MSEC_TIMER = 90
	};

			CDropControl();
	virtual	~CDropControl();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	                    UINT nID, CCreateContext* pContext = NULL);
	void	CancelModes();

// Implementation
public:
	virtual void DrawArrow(CDC& dc, CDC& dcTemp, int xdest, int ydest, BOOL bEnabled);
	virtual void GetStatusString(int i, CString& str) = 0;
	virtual void FillUndoList(CListBox&) = 0;

	static int GetExpectedWidth(void);
	static int GetExpectedHeight(void);
		// use these functions to determine what size the control would be, if it were 
		// created now

	BOOL	PointOnControl(CPoint);
	BOOL	PointOnLeft(CPoint);
	BOOL	PointOnListBox(CPoint);
	BOOL	PointOnScrollDown(CPoint);
	BOOL	PointOnScrollUp(CPoint);
	void	UndoEvents(int n);
	void	SetState(int bsState);
	void	ShowList(BOOL bShow = TRUE);
	int 	CalcSel(CPoint point);
	void	InvalidateLeft();
	void	InvalidateRight();
	void	OnListBoxLButtonDown(UINT nFlags, CPoint point);
	void	OnListBoxLButtonUp(UINT nFlags, CPoint point);

	BOOL	m_bLarge;				// TRUE if currently using the large bitmaps
	int		m_width;				// current width of the control
	int		m_height;				// current height of the control
	int		m_leftWidth;			// current width of the left half of the control
	int 	m_buttonState;
	BOOL	m_bShowList;		// is the drop list currently shown?
	CPoint	m_mousePos;
	CWnd*	m_pMainWnd; 		// window to dispatch undo commands
	CUndoList	m_undoList;		// valid only when list is shown

// Generated message map functions
protected:
	void	SetButtonSize(BOOL bLarge);
		// internal call used to set up sizes of the window areas. Does not perform
		// any redraw
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void PostNcDestroy();
	//{{AFX_MSG(CDropControl)
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg UINT OnGetDlgCode();
	afx_msg LRESULT OnBarSizeChanging(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEnable(BOOL bEnable);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	UINT m_idSmallEnabledButton;
	UINT m_idSmallDisabledButton;
	UINT m_idLargeEnabledButton;
	UINT m_idLargeDisabledButton;
};

class CUndoControl : public CDropControl
{
public:
	CUndoControl();
	virtual ~CUndoControl();

// Implementation
public:
	virtual	void GetStatusString(int i, CString& str);
	virtual void FillUndoList(CListBox&);

// Generated message map functions
protected:
	//{{AFX_MSG(CUndoControl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CRedoControl : public CDropControl
{
public:
	CRedoControl();
	virtual ~CRedoControl();

// Implementation
public:
	virtual	void GetStatusString(int i, CString& str);
	virtual void FillUndoList(CListBox&);

// Generated message map functions
protected:
	//{{AFX_MSG(CRedoControl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif // __UNDOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\workspc.h ===
///////////////////////////////////////////////////////////////////////////////
//      WORKSPC.H
//              Header file for Workspace options tab.
//

#ifndef __WORKSPC_H__
#define __WORKSPC_H__

#include "resource.h"
#include "utilctrl.h"

class CDockManager;
class CDockWorker;

#define WORKSPACE_VERSION 6

/////////////////////////////////////////////////////////////////////////////
// CWorkspaceDlg dialog

//      CWorkspaceCheckList control.
//              Override CCheckList for check notification to the dialog.

class CWorkspaceCheckList : public CCheckList
{
public:
	virtual void SetCheck(int nItem, BOOL bCheck);
};

class CWorkspaceDlg : public CDlgTab
{
// Construction
public:
	CWorkspaceDlg(CDockManager* pManager, CWnd* pParent = NULL);

	void UpdateMDIState(int nItem);
	CDockWorker* GetWorker(int nIndex = LB_ERR);

	virtual void CommitTab();
	virtual BOOL ValidateTab();
	
// Dialog Data
	//{{AFX_DATA(CWorkspaceDlg)
	enum { IDD = IDDP_OPTIONS_WORKSPACE };
	BOOL    m_bAuto;
	BOOL    m_bStatusbar;
	BOOL    m_bAutosave;
	int         m_iInterval;
	BOOL    m_bClock;
	BOOL    m_bReloadProject;
	int             m_nFiles;
	int             m_nProjects;
	int             m_nWindows;
	BOOL    m_bWindowsSort;
	BOOL    m_bMRUSubmenu;
	BOOL	m_bTraditionalMenu;
	//}}AFX_DATA

	CWorkspaceCheckList m_lbViews;

	CDockManager* m_pManager;
	CObArray m_aViewWorkers;

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);        // DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CWorkspaceDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
#ifdef ENABLE_FILE_AUTOSAVES
	afx_msg void OnClickedAutosaveEnable();
#endif  // ENABLE_FILE_AUTOSAVES
	DECLARE_MESSAGE_MAP()
};

#endif  // __WORKSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\widgetsb.cpp ===
// widgetsb.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "utilctrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// defines

#define cxBitmap 8
#define cxTabOverhead 8
#define cxButton 17
#define cxBorder 1
#define cyBorder 1
#define cxSplitter 5
#define msRepeatDelay 250
#define msRepeatRate 100
#define cxMinScrollBarWidth 48

#define DIVIDER_INACTIVE         (0)
#define DIVIDER_INACTIVE_LEFT1   (2)
#define DIVIDER_INACTIVE_RIGHT1  (1)
#define DIVIDER_ACTIVE_LEFT      (6)
#define DIVIDER_ACTIVE_RIGHT		 (4)
#define DIVIDER_ACTIVE_LEFT1		 (5)
#define DIVIDER_ACTIVE_RIGHT1		 (3)

/////////////////////////////////////////////////////////////////////////////
// CWidgetScrollBar static members

CBitmap CWidgetScrollBar::c_bmpArrows;
CBitmap CWidgetScrollBar::c_bmpDividers;
int CWidgetScrollBar::c_cyBitmap = 0;
CFont /*CWidgetScrollBar::*/c_widgetFontNormal;
CFont /*CWidgetScrollBar::*/c_widgetFontBold;
int /*CWidgetScrollBar::*/c_cyHeightPrev = 0;

/////////////////////////////////////////////////////////////////////////////
// CWidgetScrollBar

CWidgetScrollBar::CWidgetScrollBar(BOOL bAlwaysShowScrollBar /*=FALSE*/)
{
	m_bShowScrollBar = TRUE;
	m_bAlwaysShowScrollBar = bAlwaysShowScrollBar;
	m_nSplitterPref = 0; // reset to half of window width on first resize
	m_nWidgetWidth = 2 * cxButton - 2 * cxBorder;
	m_captureZone = none;
	m_bButtonIn = TRUE;
	m_xScrollPos = 0;
	m_cxScrollExtent = cxBitmap;
	m_nActiveTab = -1;	// so first tab added can be activated properly
}

CWidgetScrollBar::~CWidgetScrollBar()
{
	ResetTabs();
}

void CWidgetScrollBar::ResetTabs()
{
	m_cxScrollExtent = cxBitmap;
	m_xScrollPos = 0;
	m_nActiveTab = -1;
	while (!m_tabs.IsEmpty())
		delete (CWidgetTab*) m_tabs.RemoveHead();

	if (m_hWnd != NULL)
		InvalidateRect(CRect(2 * cxButton - 2 * cxBorder, 0, m_nWidgetWidth, 100), FALSE);
}

BOOL CWidgetScrollBar::PreCreateWindow(CREATESTRUCT& cs)
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	if (c_bmpArrows.m_hObject == NULL)
		c_bmpArrows.LoadBitmap(IDB_WIDGETBAR_ARROWS);
//	if (c_bmpDividers.m_hObject == NULL)
//		OnSysColorChange();		// will load dividers using sys colors

	cs.lpszClass = AfxRegisterWndClass(0);
	return TRUE;
}

void CWidgetScrollBar::AddTab(const char* szCaption, DWORD dwUser, BOOL bAdjustSplitter)
{
	CClientDC dc(this); // okay if 'this' doesn't have an hWnd yet...
	CFont* pOldFont = dc.SelectObject(&c_widgetFontBold);
	CWidgetTab* pTab = new CWidgetTab;
	pTab->m_str = szCaption;
	pTab->m_dwUser = dwUser;
	pTab->m_cxWidth = cxTabOverhead + (c_cyBitmap + 1) / 2 + dc.GetTextExtent(pTab->m_str, pTab->m_str.GetLength()).cx;
	m_tabs.AddTail(pTab);
	dc.SelectObject(pOldFont);
	m_cxScrollExtent += pTab->m_cxWidth;

	if (bAdjustSplitter)
	{
		// add cxSplitter here because it's immediately subtracted in SetSplitterPos()
		CRect rect;
		GetClientRect(rect);
		SetSplitterPos(rect.right - cxBorder - 4 * GetSystemMetrics(SM_CXVSCROLL) + cxSplitter);
		m_nSplitterPref = m_nWidgetWidth;
	}
}

void CWidgetScrollBar::AddTabAt(int nPosition, const char* szCaption, DWORD dwUser, BOOL bAdjustSplitter)
{
	CClientDC dc(this); // okay if 'this' doesn't have an hWnd yet...
	CFont* pOldFont = dc.SelectObject(&c_widgetFontBold);
	CWidgetTab* pTab = new CWidgetTab;
	pTab->m_str = szCaption;
	pTab->m_dwUser = dwUser;
	pTab->m_cxWidth = cxTabOverhead + (c_cyBitmap + 1) / 2 + dc.GetTextExtent(pTab->m_str, pTab->m_str.GetLength()).cx;

	// ADD TAB AT SPECIFIED POSITION!
	POSITION pos = m_tabs.FindIndex(nPosition);
	if (pos == NULL)
		m_tabs.AddTail(pTab);
	else
		m_tabs.InsertBefore(pos, pTab);

	dc.SelectObject(pOldFont);
	m_cxScrollExtent += pTab->m_cxWidth;

	if (bAdjustSplitter)
	{
		// add cxSplitter here because it's immediately subtracted in SetSplitterPos()
		CRect rect;
		GetClientRect(rect);
		SetSplitterPos(rect.right - cxBorder - 4 * GetSystemMetrics(SM_CXVSCROLL) + cxSplitter);
		m_nSplitterPref = m_nWidgetWidth;
	}
}

void CWidgetScrollBar::RemoveTab(int nTab)
{
	POSITION pos = m_tabs.FindIndex(nTab);
	ASSERT(pos != NULL);
	CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetAt(pos);
	ASSERT(pTab != NULL);

	m_tabs.RemoveAt(pos);
	m_cxScrollExtent -= pTab->m_cxWidth;
	delete pTab;

	if (m_tabs.IsEmpty())
	{
		m_nActiveTab = -1;
	}
	else if (m_nActiveTab > nTab)
	{
		int nCurTab = m_nActiveTab - 1;
		m_nActiveTab = -1;
		ActivateTab(nCurTab);
	}
	else if (m_nActiveTab == nTab)
	{
		int nLastTab = m_tabs.GetCount() - 1;
		m_nActiveTab = -1;
		ActivateTab(nTab <= nLastTab ? nTab : nLastTab);
	}

	Invalidate(FALSE);	// force repaint of widget bar
}

void CWidgetScrollBar::ChangeTabCaption(int nTab, const char* szNewCaption)
{
	POSITION pos = m_tabs.FindIndex(nTab);
	ASSERT(pos != NULL);
	CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetAt(pos);
	ASSERT(pTab != NULL);

	CClientDC dc(this); // okay if 'this' doesn't have an hWnd yet...
	CFont* pOldFont = dc.SelectObject(&c_widgetFontBold);

	int cxOldWidth = pTab->m_cxWidth;

	pTab->m_str = szNewCaption;
	pTab->m_cxWidth = cxTabOverhead + (c_cyBitmap + 1) / 2 + dc.GetTextExtent(pTab->m_str, pTab->m_str.GetLength()).cx;
	dc.SelectObject(pOldFont);
	m_cxScrollExtent += pTab->m_cxWidth - cxOldWidth;

	Invalidate(FALSE);	// force repaint of widget bar
}


BEGIN_MESSAGE_MAP(CWidgetScrollBar, CWnd)
	//{{AFX_MSG_MAP(CWidgetScrollBar)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_TIMER()
	ON_WM_CREATE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_WININICHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWidgetScrollBar message handlers

CWidgetScrollBar::HIT_ZONE CWidgetScrollBar::HitTest(CPoint point)
{
	if (point.x < cxButton)
		return left;

	if (point.x < cxButton + cxButton)
		return right;

	if (m_bShowScrollBar && point.x > m_nWidgetWidth)
		return splitter;

	int x = point.x - 2 * cxButton - 2 * cxBorder + m_xScrollPos;
	POSITION pos = m_tabs.GetHeadPosition();
	int nTab = 0;
	while (pos != NULL)
	{
		CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetNext(pos);
		if (x < pTab->m_cxWidth)
			return (HIT_ZONE)(firstTab + nTab);
		x -= pTab->m_cxWidth;
		nTab += 1;
	}

	return none;
}


void CWidgetScrollBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_captureZone = HitTest(point);

	switch (m_captureZone)
	{
	case none:
		return;

	case left:
	case right:
		Scroll(m_captureZone == left ? -cxButton : cxButton);
		SetTimer(0, msRepeatDelay, NULL);
		m_bButtonIn = TRUE;
		InvalidateRect(CRect(0, 0, cxButton * 2 - cxBorder, 100), FALSE); // redraw buttons
		break;

	case splitter:
		break;

	default:
		// must be in a tab...
		ActivateTab(m_captureZone - firstTab);
		break;
	}

	SetCapture();
}


UINT WSB_CHANGETAB = RegisterMessage("WSB_CHANGETAB");

void CWidgetScrollBar::ActivateTab(int nTab)
{
	if (nTab >= m_tabs.GetCount())
		nTab = m_tabs.GetCount() - 1;

	if (nTab != m_nActiveTab)
	{
		CRect rect;

		if (m_nActiveTab != -1)
		{
			GetTabRect(m_nActiveTab, rect);
			InvalidateRect(rect, FALSE);
		}

		m_nActiveTab = nTab;

		GetTabRect(m_nActiveTab, rect);
		InvalidateRect(rect, FALSE);

		if (rect.left < 2 * cxButton - cxBorder)
			Scroll(rect.left - (2 * cxButton - cxBorder));
		else if (rect.right > m_nWidgetWidth)
			Scroll(rect.right - m_nWidgetWidth);

		UpdateWindow();

		POSITION pos  = m_tabs.GetHeadPosition();
		CWidgetTab* pTab = NULL;
		for (int i = 0; i < nTab + 1; i += 1)
		{
			pTab = (CWidgetTab*)m_tabs.GetNext(pos);
			if (i == nTab)
			{
				// set window text of widget scroll bar so QA
				// can check if correct tab is activated...
				SetWindowText(pTab->m_str);
			}
		}
		ASSERT(pTab != NULL);

		GetParent()->SendMessage(WSB_CHANGETAB, nTab, pTab->m_dwUser);
	}
}

void CWidgetScrollBar::GetTabRect(int nTab, CRect& rect)
{
	ASSERT(nTab >= 0 && nTab < m_tabs.GetCount());

	GetClientRect(rect);
	rect.InflateRect(-cxBorder, -cyBorder);

	rect.left += 2 * cxButton - 2 * cxBorder;
	POSITION pos  = m_tabs.GetHeadPosition();
	for (int i = 0; i < nTab; i += 1)
	{
		CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetNext(pos);
		rect.left += pTab->m_cxWidth;
	}

	ASSERT(pos != NULL);
	CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetNext(pos);
	rect.right = rect.left + pTab->m_cxWidth + cxTabOverhead + (c_cyBitmap + 1) / 2;
	rect.OffsetRect(-m_xScrollPos, 0);
	rect.InflateRect(cxBorder, cyBorder);
}

void CWidgetScrollBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (GetCapture() != this)
		return;

	ReleaseCapture();
	KillTimer(0);
	m_captureZone = none;
	m_bButtonIn = FALSE;
	InvalidateRect(CRect(0, 0, cxButton * 2 - cxBorder, 100), FALSE); // redraw buttons
}

void CWidgetScrollBar::OnMouseMove(UINT nFlags, CPoint point)
{
	if (GetCapture() == NULL)
	{
		m_captureZone = none;

		HCURSOR hCursor;
		switch (HitTest(point))
		{
		default:
			hCursor = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
			break;

		case splitter:
			hCursor = AfxLoadCursor(AFX_IDC_HSPLITBAR);
			break;
		}

		SetCursor(hCursor);
	}
	else
	{
		switch (m_captureZone)
		{
		default:
			break;

		case left:
		case right:
			{
				CRect rect;
				GetClientRect(rect);
				rect.InflateRect(-cxBorder, -cyBorder);

				if (m_captureZone == left)
				{
					rect.left = rect.left - cxBorder;
					rect.right = rect.left + cxButton;
				}
				else
				{
					rect.left = rect.left + cxButton - 2 * cxBorder;
					rect.right = rect.left + cxButton;
				}

				if (rect.PtInRect(point))
				{
					if (!m_bButtonIn)
					{
						// Moved back into the button area
						m_bButtonIn = TRUE;
						InvalidateRect(rect, FALSE);
						SetTimer(0, msRepeatRate, NULL);
					}
				}
				else
				{
					if (m_bButtonIn)
					{
						// Moved out of the button area
						m_bButtonIn = FALSE;
						KillTimer(0);
						InvalidateRect(rect, FALSE);
					}
				}
			}
			break;

		case splitter:
			SetSplitterPos(point.x);
			m_nSplitterPref = m_nWidgetWidth;
			break;
		}
	}
}

void CWidgetScrollBar::SetSplitterPos(int xPos)
{
	xPos -= cxSplitter;

	CRect rect;
	GetClientRect(rect);
	rect.InflateRect(-cxBorder, -cyBorder);

	if (xPos < 2 * (cxButton - cxBorder))
		xPos = 2 * (cxButton - cxBorder);
	if (m_bShowScrollBar && xPos > rect.right - cxSplitter - cxMinScrollBarWidth)
		xPos = rect.right - cxSplitter - cxMinScrollBarWidth;

	if (xPos > m_nWidgetWidth)
		InvalidateRect(CRect(m_nWidgetWidth, 0, xPos + cxSplitter, rect.bottom));
	else
		InvalidateRect(CRect(xPos, 0, xPos + cxSplitter, rect.bottom));
	
	if (m_nWidgetWidth == xPos)
		return;

	m_nWidgetWidth = xPos;

	if (m_xScrollPos > 0 && xPos > 2 * (cxButton - cxBorder) + m_cxScrollExtent - m_xScrollPos)
	{
		// If the user enlarges the tab area and the tabs are scrolled, scroll
		// back so more of the tabs are visible
		Scroll(xPos - (2 * (cxButton - cxBorder) + (m_cxScrollExtent - m_xScrollPos)));
	}

	RecalcLayout();
	UpdateWindow();
}

void CWidgetScrollBar::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
#ifdef _WIN32
	GetParent()->SendMessage(WM_HSCROLL, MAKEWPARAM(nSBCode, nPos), (LPARAM)pScrollBar->m_hWnd);
#else
	GetParent()->SendMessage(WM_HSCROLL, nSBCode, MAKELPARAM(nPos, pScrollBar->m_hWnd));
#endif
	
	CWnd::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CWidgetScrollBar::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CWnd::OnVScroll(nSBCode, nPos, pScrollBar);
}

void DrawButton(CDC* pDC, CDC* pButtonDC, int nButton, const CRect& rect, BOOL bIn, BOOL bDisabled)
{
	if (bDisabled)
		bIn = FALSE;

	CBrush* pbrBorder = GetSysBrush(COLOR_BTNTEXT);
	CBrush* pbrHighlight = GetSysBrush(COLOR_BTNHIGHLIGHT);
	CBrush* pbrShadow = GetSysBrush(COLOR_BTNSHADOW);
	CBrush* pbrFace = GetSysBrush(COLOR_BTNFACE);

	CBrush* pOldBrush = pDC->SelectObject(pbrBorder);
	pDC->PatBlt(rect.left, rect.top, rect.Width(), cyBorder, PATCOPY);
	pDC->PatBlt(rect.left, rect.top + cyBorder, cxBorder, rect.Height() - 2 * cyBorder, PATCOPY);
	pDC->PatBlt(rect.right - cxBorder, rect.top + cyBorder, cxBorder, rect.Height() - 2 * cyBorder, PATCOPY);
	pDC->PatBlt(rect.left, rect.bottom - cyBorder, rect.Width(), cyBorder, PATCOPY);

	pDC->SelectObject(bIn ? pbrShadow : pbrHighlight);
	pDC->PatBlt(rect.left + cxBorder, rect.top + cyBorder, rect.Width() - (bIn ? 2 : 3) * cxBorder, cyBorder, PATCOPY);
	pDC->PatBlt(rect.left + cxBorder, rect.top + cyBorder * 2, cxBorder, rect.Height() - (bIn ? 3 : 4) * cyBorder, PATCOPY);

	if (!bIn)
	{
		pDC->SelectObject(pbrShadow);
		pDC->PatBlt(rect.right - 2 * cxBorder, rect.top + cyBorder, cxBorder, rect.Height() - cyBorder * 4, PATCOPY);
		pDC->PatBlt(rect.right - 3 * cxBorder, rect.top + 2 * cyBorder, cxBorder, rect.Height() - cyBorder * 5, PATCOPY);
		pDC->PatBlt(rect.left + 2 * cxBorder, rect.bottom - 3 * cyBorder, rect.Width() - 3 * cxBorder, cyBorder, PATCOPY);
		pDC->PatBlt(rect.left + cxBorder, rect.bottom - 2 * cyBorder, rect.Width() - 2 * cxBorder, cyBorder, PATCOPY);
	}
	
	pDC->SelectObject(pbrFace);
	pDC->PatBlt(rect.left + 2 * cxBorder, rect.top + 2 * cyBorder, 
		rect.Width() - ((bIn ? 3 : 5) * cxBorder), rect.Height() - ((bIn ? 3 : 5) * cyBorder), PATCOPY);

	pDC->SelectObject(pOldBrush);

	// determine size of glyph
	int yGlyph = 4 + bIn;
	int xGlyph = 6 + bIn;
	int cyGlyph = max(min(9, rect.Height() - 8), 3);
	if( (yGlyph + cyGlyph) >= rect.Height() )
		yGlyph = max(0, (rect.Height() - cyGlyph) / 2 + 1);
	int cxGlyph = (cyGlyph + 1) / 2;	// 5x9, 4x7or8, 3x5or6, or 2x3or4
	cyGlyph = cxGlyph * 2 - 1;			// 5x9, 4x7, 3x5, or 2x3

	// Draw the glyph...
	pDC->SetTextColor(bDisabled ? GetSysColor(COLOR_BTNSHADOW) : 
		GetSysColor(COLOR_BTNTEXT));
	pDC->SetBkColor(GetSysColor(COLOR_BTNFACE));
	pDC->BitBlt(rect.left + xGlyph, rect.top + yGlyph, cxGlyph, cyGlyph, 
		pButtonDC, (nButton == 1) ? (10 - cxGlyph) : 0, (9 - cyGlyph) / 2, SRCCOPY);
}

/* DrawDivider
 *	Draws one of the 7 divider glyphs
 */
enum
{
	DIVIDER_X_I,	// left-side of first tab on left, which is inacitve
	DIVIDER_I_X,	// right-side of last tab on right, which is inacitve
	DIVIDER_X_A,	// left-side of first tab on left, which is acitve
	DIVIDER_A_X,	// right-side of last tab on right, which is acitve
	DIVIDER_I_A,	// divider between active tab on right, and inactive on left
	DIVIDER_A_I,	// divider between active tab on left, and inactive on right
	DIVIDER_I_I,	// divider between two inactive tabs
};

#define DIVIDER_IMG_WIDTH		17
#define DIVIDER_IMG_HEIGHT		23

void CWidgetScrollBar::DrawDivider(CDC* pDC, int nImage, const CPoint& pt)
{
	CDC dcMem;
	dcMem.CreateCompatibleDC(pDC);
	CBitmap* pOldBitmap = dcMem.SelectObject(&c_bmpDividers);
	int cxDivider = (c_cyBitmap + 1) / 2;
	pDC->BitBlt(pt.x, pt.y, cxDivider, c_cyBitmap,
		&dcMem, cxDivider * nImage, 0, SRCCOPY);
	dcMem.SelectObject(pOldBitmap);
}

void CWidgetScrollBar::OnPaint()
{
	CRect client;
	GetClientRect(client);

	if (!m_bShowScrollBar != !m_scrollBar.IsWindowVisible())
	{
		Invalidate(FALSE);

		if (!m_bAlwaysShowScrollBar)
			m_bShowScrollBar = !m_bShowScrollBar;
		else
			m_bShowScrollBar = TRUE;
		if (m_bShowScrollBar)
			m_nWidgetWidth = m_nSplitterPref;
		RecalcLayout();
		if (m_bAlwaysShowScrollBar)
			m_scrollBar.ShowWindow(m_bShowScrollBar);
	}

	CPaintDC dc(this);
	
	CRect rect;

	CBrush* pbrWindowFrame = GetSysBrush(COLOR_WINDOWFRAME);
	CBrush* pbrWindow = GetSysBrush(COLOR_WINDOW);
	CBrush* pbrBtnText = GetSysBrush(COLOR_BTNTEXT);
	CBrush* pbrBtnHighlight = GetSysBrush(COLOR_BTNHIGHLIGHT);
	CBrush* pbrBtnShadow = GetSysBrush(COLOR_BTNSHADOW);
	CBrush* pbrBtnFace = GetSysBrush(COLOR_BTNFACE);

	// Draw tab scroll buttons...
	CDC memDC;
	memDC.CreateCompatibleDC(&dc);
	CBitmap* pOldBitmap = memDC.SelectObject(&c_bmpArrows);
	rect.SetRect(0, 0, cxButton, client.bottom);
	DrawButton(&dc, &memDC, 0, rect, m_captureZone == left && m_bButtonIn, m_xScrollPos == 0);
	rect.OffsetRect(cxButton - cxBorder, 0);
	DrawButton(&dc, &memDC, 1, rect, m_captureZone == right && m_bButtonIn, m_xScrollPos >= m_cxScrollExtent - (m_nWidgetWidth - 2 * cxButton - 2 * cxBorder));
	rect.OffsetRect(cxButton, 0);
	memDC.SelectObject(pOldBitmap);

	CBrush* pOldBrush = dc.SelectObject(pbrWindowFrame);
	dc.PatBlt(m_nWidgetWidth, client.top + cyBorder, cxBorder, client.Height() - 2 * cyBorder, PATCOPY);

	// Draw the border at the bottom.
	dc.PatBlt(rect.left, client.bottom - cyBorder, m_nWidgetWidth - rect.left + cxBorder, cyBorder, PATCOPY); 

	if (m_tabs.IsEmpty())
	{
		// if there are no tabs in the tab bar then paint the remainder and return
		dc.PatBlt(rect.left, client.top, m_nWidgetWidth - rect.left + cxBorder, cyBorder, PATCOPY); 
		dc.SelectObject(pbrBtnFace);
		dc.PatBlt(rect.left, client.top + cyBorder, m_nWidgetWidth, client.Height() - 2 * cyBorder, PATCOPY);
		dc.SelectObject(pOldBrush);
		return;
	}

	if (m_bShowScrollBar)
	{
		// Draw splitter box...
		dc.PatBlt(m_nWidgetWidth + cxSplitter - cxBorder, client.top + cyBorder, cxBorder, client.Height() - 2 * cyBorder, PATCOPY);
		dc.PatBlt(m_nWidgetWidth, client.top, cxSplitter, cyBorder, PATCOPY);
		dc.PatBlt(client.left, client.bottom - cyBorder, client.Width(), cyBorder, PATCOPY);
		dc.SelectObject(pbrBtnHighlight);
		dc.PatBlt(m_nWidgetWidth + cxBorder, client.top + cyBorder, cxBorder, client.Height() - 2 * cyBorder, PATCOPY);
		dc.SelectObject(pbrBtnShadow);
		dc.PatBlt(m_nWidgetWidth + cxSplitter - 2 * cxBorder, client.top + cyBorder, cxBorder, client.Height() - 2 * cyBorder, PATCOPY);
		dc.SelectObject(pbrBtnFace);
		dc.PatBlt(m_nWidgetWidth + cxBorder * 2, client.top + cyBorder, cxSplitter - 4 * cxBorder, client.Height() - 2 * cyBorder, PATCOPY);
	}
	

	// Draw tabs...
	CRect tabArea(rect.left, client.top, m_nWidgetWidth, client.bottom);
	if (dc.IntersectClipRect(tabArea) == NULLREGION)
	{
		dc.SelectObject(pOldBrush);
		return;
	}

	UINT nDivider = DIVIDER_X_I;	// first left-side divider

	// minimum width is 7, at which the height is between 7 and 13
	// at heights > 13, the width needs to grow by the same amount
	// maximum height is 23
	int cyDivider = client.Height() - 2;
	int cxDivider = (cyDivider + 1) / 2;
//	int cxDivider = 7;
//	if( cyDivider > 13 )
//		cxDivider += ((cyDivider - 13 + 1) / 2) * 2;	// will keep cx an odd number

	int x = tabArea.left - m_xScrollPos;
	int y = tabArea.top + cyBorder;
	int yText = y;
	CFont* pBoldFont = &c_widgetFontBold;
	CFont* pNormalFont = &c_widgetFontNormal;
	CFont* pOldFont = dc.SelectObject(pNormalFont);

	dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
	dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
	dc.SetBkMode(OPAQUE);

	dc.SelectObject(pbrBtnShadow);

	POSITION pos = m_tabs.GetHeadPosition();
	int nTab = 0;
	CWidgetTab* pActiveTab = NULL;
	int xActive = 0;
	while (pos != NULL)
	{
		CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetNext(pos);

		// recalc width here, based on current font
//		pTab->m_cxWidth = cxTabOverhead + dc.GetTextExtent(pTab->m_str, pTab->m_str.GetLength()).cx;

		if (nTab == m_nActiveTab)
		{
			dc.SelectObject(pBoldFont);
			dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
			dc.SetBkColor(GetSysColor(COLOR_WINDOW));
			nDivider = (nTab == 0) ? DIVIDER_X_A : DIVIDER_I_A;

			pActiveTab = pTab;
			xActive = x;
		}

		DrawDivider(&dc, nDivider, CPoint(x, y));
//			c_imgDividers.DrawImage(&dc, CPoint(x,y), nDivider, SRCCOPY);
	
		rect.SetRect(x + cxDivider, tabArea.top + cyBorder, 
			x + pTab->m_cxWidth, tabArea.bottom - 2 * cyBorder);
		int cxTextWidth = dc.GetTextExtent(pTab->m_str, pTab->m_str.GetLength()).cx;
		dc.ExtTextOut(x + cxDivider + (rect.Width() - cxTextWidth) / 2,
			 yText, ETO_OPAQUE, rect, pTab->m_str, pTab->m_str.GetLength(), NULL);
		dc.PatBlt(x + cxDivider, tabArea.bottom - 2 * cyBorder, pTab->m_cxWidth - cxDivider, cyBorder, PATCOPY);

		x += pTab->m_cxWidth;

		if (nTab == m_nActiveTab)
		{
			nDivider = DIVIDER_A_I;		// divider between active and inactive tabs
			dc.SelectObject(pNormalFont);
			dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
			dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
		}
		else
			nDivider = DIVIDER_I_I;		// divider between inactive tabs

		nTab += 1;
	}
	
	if( !m_tabs.IsEmpty() )
	{
		CPoint pt(x, y);
		if( nTab != m_nActiveTab + 1 )
			DrawDivider(&dc, DIVIDER_I_X, pt);
		else
			DrawDivider(&dc, DIVIDER_A_X, pt);

		// draw top border to left and right of active tab.
		ASSERT( pActiveTab != NULL );
		dc.SelectObject(pbrBtnText);	// You'd think it should be WindowFrame, but Excel uses BtnText
		dc.PatBlt(client.left, client.top, xActive - client.left, cyBorder, PATCOPY);
		dc.PatBlt(xActive + pActiveTab->m_cxWidth + cxDivider, client.top, 
			client.right - xActive + pActiveTab->m_cxWidth + cxDivider, cyBorder, 
			PATCOPY);
		dc.SelectObject(pbrWindow);
		dc.PatBlt(xActive, client.top, pActiveTab->m_cxWidth + cxDivider, cyBorder, 
			PATCOPY);
		dc.SelectObject(pbrBtnShadow);

	}

	dc.SelectObject(pbrBtnFace);
	dc.PatBlt(x + cxDivider, tabArea.top + cyBorder, tabArea.Width(), tabArea.Height() - 2 * cyBorder, PATCOPY);

	dc.SelectObject(pOldFont);
	dc.SelectObject(pOldBrush);
}

void CWidgetScrollBar::OnSysColorChange()
{
	CWnd::OnSysColorChange();

	UpdateDividerBitmap(c_cyBitmap, TRUE);

	Invalidate();
}

void CWidgetScrollBar::OnWinIniChange(LPCSTR lpszSection)
{
	CWnd::OnWinIniChange(lpszSection);

	RecalcLayout();

	Invalidate();
}

void CWidgetScrollBar::OnTimer(UINT nIDEvent)
{
	ASSERT(m_captureZone == left || m_captureZone == right);
	
	Scroll(m_captureZone == left ? -cxButton : cxButton);
	SetTimer(nIDEvent, msRepeatRate, NULL);
}

int CWidgetScrollBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (m_scrollBar.Create(WS_HSCROLL | WS_VISIBLE | WS_CHILD, CRect(0, 0, 0, 0), 
		this, AFX_IDW_HSCROLL_FIRST) == -1)
	{
		return -1;
	}
	
	return 0;
}

void CWidgetScrollBar::RecalcLayout()
{
	CRect client;
	GetClientRect(client);
	if (!m_bAlwaysShowScrollBar && !m_bShowScrollBar)
		m_nWidgetWidth = client.right - cxBorder;

	int xScrollBar = m_nWidgetWidth + cxSplitter - cxBorder;
	m_scrollBar.MoveWindow(xScrollBar, 0, client.Width() - xScrollBar, client.Height());
}

void CWidgetScrollBar::OnSize(UINT nType, int cx, int cy)
{
	if (c_cyHeightPrev != cy)
	{
		c_cyHeightPrev = cy;
		
		LOGFONT logfont = *GetStdLogfont(font_Normal);
		logfont.lfHeight = (cy - 3 * cyBorder);
		logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
		// [olympus 10955 - chauv] I decided to not zero out the lfFaceName below because
		// our standard package gives the appropriate facename for some platforms we support
		// specifically US and Japanese. BradCh mentioned that by zero out the facename, we
		// are relying for the OS to supply the appropriate FF_SWISS family font and therefore
		// we will get smoother font as scrollbar height is changed. However we both agreed
		// that we are going to use our standardfont package supplies by GetStdLogFont()
		// in order for the widget control to display readable text (instead of pixel blocks).

		// [chauv - 7/11/95] Oh well, MS Sans Serif is not a True Type font so for US and other
		// FE other than Japanese, we just clear the face name and let the OS give us the default.
		// For Japanese, we use "MS P Gothic" and it's a TrueType so we do want to keep the
		// facename from GetStdLogfont().
		if (_getmbcp() != 932)	// check for Japanese codepage 932 here
			logfont.lfFaceName[0] = 0;
		c_widgetFontNormal.DeleteObject();
		c_widgetFontNormal.CreateFontIndirect(&logfont);
		
		logfont = *GetStdLogfont(font_Bold);
		logfont.lfHeight = (cy - 3 * cyBorder);
		logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
		// [olympus 10955 - chauv] see comment above...
		if (_getmbcp() != 932)	// check for Japanese codepage 932 here
			logfont.lfFaceName[0] = 0;
		c_widgetFontBold.DeleteObject();
		c_widgetFontBold.CreateFontIndirect(&logfont);

		UpdateDividerBitmap(cy - 2);

		CClientDC dc(this);
		CFont* pOldFont = dc.SelectObject(&c_widgetFontBold);
		
		m_cxScrollExtent = 0;
		POSITION pos = m_tabs.GetHeadPosition();
		while (pos != NULL)
		{
			CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetNext(pos);

			// recalc width here, based on current font and divider size
			pTab->m_cxWidth = cxTabOverhead + (c_cyBitmap + 1) / 2 + dc.GetTextExtent(pTab->m_str, pTab->m_str.GetLength()).cx;
			m_cxScrollExtent += pTab->m_cxWidth;

		}
		
		dc.SelectObject(pOldFont);
	}
	
	if (m_nSplitterPref == 0)
		m_nSplitterPref = cx / 2;

	SetSplitterPos(m_nSplitterPref);

	if (m_nWidgetWidth > cx - cxSplitter - cxMinScrollBarWidth)
		m_nWidgetWidth = cx - cxSplitter - cxMinScrollBarWidth;

	RecalcLayout();
}

// The dividers need to have a specific look to them, going down 2, over 1
void DrawDiagonal(CDC* pDC, int x, int y, int dx, int cyBottom)
{
	for( ; y < cyBottom; y += 2, x += dx )
	{
		pDC->MoveTo(x, y);
		pDC->LineTo(x, y + 2);
	}
}

void CWidgetScrollBar::UpdateDividerBitmap(int cy, BOOL bForce)
{
	if( ((cy == c_cyBitmap) && !bForce) || (cy == -1 ) )
		return;

	c_cyBitmap = cy;
	int cx = (cy + 1) / 2;
	int cxBmp = cx * 7;

	if( c_bmpDividers.m_hObject != NULL )
		c_bmpDividers.DeleteObject();

	CWindowDC dcWindow(this);
	CDC dcMem;
	VERIFY( dcMem.CreateCompatibleDC(&dcWindow) );
	c_bmpDividers.CreateCompatibleBitmap(&dcWindow, cxBmp, c_cyBitmap);
	CBitmap* pOldBitmap = dcMem.SelectObject(&c_bmpDividers);

	// fill bitmap with gray
	CBrush* pOldBrush = dcMem.SelectObject(GetSysBrush(COLOR_BTNFACE));
	dcMem.PatBlt(0, 0, cxBmp, c_cyBitmap, PATCOPY);

	// paint active area white
	dcMem.SelectObject(GetSysBrush(COLOR_WINDOW));
	for( int y = 0; y < c_cyBitmap; y++ )
	{
		dcMem.PatBlt(cx * 2 + (y / 2) + 1, y, cx * 2 - ((y / 2) * 2) - 2, 1, 
			PATCOPY);
		dcMem.PatBlt(cx * 4 + (y / 2) + 1, y, cx * 2 - ((y / 2) * 2) - 2, 1, 
			PATCOPY);
	}

	int cyHalf = (cy + 1) / 2;
	
	// draw shadows first, because they might overwrite lines if drawn later
	CPen* pOldPen = dcMem.SelectObject(GetSysPen(COLOR_BTNSHADOW));
	DrawDiagonal(&dcMem, 2 * cx - 2, 0, -1, cy);
	DrawDiagonal(&dcMem, 9 * cx / 2 - 1, cyHalf, -1, cy);
	DrawDiagonal(&dcMem, 13 * cx / 2 - 1, cyHalf, -1, cy);
	dcMem.SetPixel(cx * 6 - 1, cy - 1, GetSysColor(COLOR_BTNSHADOW));

	// draw divider borders
	dcMem.SelectObject(GetSysPen(COLOR_BTNTEXT));
	DrawDiagonal(&dcMem, 0, 0, 1, cy);
	DrawDiagonal(&dcMem, 2 * cx - 1, 0, -1, cy);
	DrawDiagonal(&dcMem, 2 * cx, 0, 1, cy);
	DrawDiagonal(&dcMem, 4 * cx - 1, 0, -1, cy);
	DrawDiagonal(&dcMem, 4 * cx, 0, 1, cy);
	DrawDiagonal(&dcMem, 9 * cx / 2, cyHalf, -1, cy);
	DrawDiagonal(&dcMem, 6 * cx - 1, 0, -1, cy);
	DrawDiagonal(&dcMem, 6 * cx - 1 - (cx / 2), cyHalf, 1, cy);
	DrawDiagonal(&dcMem, 6 * cx, 0, 1, cy);
	DrawDiagonal(&dcMem, 13 * cx / 2, cyHalf, -1, cy);

	dcMem.SelectObject(pOldPen);
	dcMem.SelectObject(pOldBrush);
	dcMem.SelectObject(pOldBitmap);
}

void CWidgetScrollBar::Scroll(int cxScroll)
{
	// Adjust cxScroll to something within acceptable limits...
	if (m_xScrollPos + cxScroll > m_cxScrollExtent - (m_nWidgetWidth - 2 * cxButton - 2 * cxBorder))
		cxScroll = m_cxScrollExtent - (m_nWidgetWidth - 2 * cxButton - 2 * cxBorder) - m_xScrollPos;
	if (m_xScrollPos + cxScroll < 0)
		cxScroll = -m_xScrollPos;

	if (cxScroll == 0)
		return;

	CRect rect;
	GetClientRect(rect);

	rect.left += 2 * cxButton - cxBorder;
	rect.right = m_nWidgetWidth;
	rect.bottom -= cyBorder;

	UpdateWindow();
	ScrollWindow(-cxScroll, 0, rect, rect);

	m_xScrollPos += cxScroll;
}

int CWidgetScrollBar::FindTab(DWORD dwUser)
{
	POSITION pos = m_tabs.GetHeadPosition();
	int nTab = 0;
	while (pos != NULL)
	{
		CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetNext(pos);
		if (pTab->m_dwUser == dwUser)
			return nTab;
		nTab += 1;
	}

	return -1;
}

DWORD CWidgetScrollBar::GetTabData(int nTab)
{
	POSITION pos = m_tabs.FindIndex(nTab);
	ASSERT(pos != NULL);
	CWidgetTab* pTab = (CWidgetTab*)m_tabs.GetAt(pos);
	ASSERT(pTab != NULL);

	return pTab->m_dwUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\awiface.h ===
//
// CAppWizIFace
//
// AppWizard Interface to New/Insert Project dialog
//
// [davbr]
//

#ifndef _INCLUDE_APPWIZIFACE_H
#define _INCLUDE_APPWIZIFACE_H

// Size of m_pnPlatforms array in build system's CPromptDlg.  This represents the
//  maximum number of platforms we can display at once.
#define MAX_PLATFORMS 8

#ifndef VS_PACKAGE
#include "utilctrl.h"
#endif	// VS_PACKAGE

enum {APPWIZTERMTYPE_CANCEL, APPWIZTERMTYPE_EMPTYPROJ, APPWIZTERMTYPE_APPWIZPROJ, APPWIZTERMTYPE_RERUNPROMPTDLG};

#ifndef VS_PACKAGE
class CProjTypeList;
#endif	// VS_PACKAGE

#ifdef VS_PACKAGE
#include <bldapi.h>
#endif

class CAppWizIFace
{
public:

	// Each time the new/insert project dialog pops up, call this before
	//  calling any of the other APIs.
#ifdef VS_PACKAGE
	virtual void InitAppWiz(HWND hWnd, IServiceProvider *pSp);

	IServiceProvider *m_pSp ;
	IBuildWizardX *m_pBldWizX ;
	IBuildPlatformsX *m_pBldPlatsX;

	void ReleasePtrs(void)
	{
		if (m_pBldPlatsX)
		{
			m_pBldPlatsX->Release() ;
			m_pBldPlatsX = NULL ;
		}

		if (m_pBldWizX)
		{
			m_pBldWizX->Release() ;
			m_pBldWizX = NULL ;
		}

		if (m_pSp)
		{
			m_pSp->Release() ;
			m_pSp = NULL ;
		}
	}

	CAppWizIFace() 
	{ 
		m_pSp = NULL; 
		m_pBldPlatsX = NULL ;
		m_pBldWizX = NULL ;
	}

	~CAppWizIFace() 
	{ 
		ReleasePtrs();
	}
#else
	virtual void InitAppWiz(HWND hWnd);
#endif

	// This takes the projtype list box, and fills it with the standard appwiz
	//  project types.  Returns number of appwiz types.

#ifndef VS_PACKAGE	
	virtual int AddAppWizProjectTypesAtTop(CListBox* pList);
	virtual int AddAppWizProjectTypesAtTop(CProjTypeList* pList);

	// This takes the projtype list box, and fills it with any custom appwiz's it finds.
	//  It returns whether number of custom AppWizards
	virtual int AddCustomAppWizProjectTypesAtBottom(CListBox* pList);
	virtual int AddCustomAppWizProjectTypesAtBottom(CProjTypeList* pList);

	// Fills the platforms checklist with platforms supported by the indicated
	//  custom AppWizard
	virtual void FillPlatformsListFromCustomAppWizType
		(LPCTSTR szExtName, CCheckList* pChklstPlatforms);
	virtual void FillPlatformsListFromCustomAppWizType
		(LPCTSTR szExtName, CStringArray* pChklstPlatforms);

	// Fills the platforms checklist with platforms supported by the indicated
	//  AppWizard type (its index into the project type combo box).
	virtual void FillPlatformsListFromAppWizType
		(int nProjType, CCheckList* pChklstPlatforms);
	virtual void FillPlatformsListFromAppWizType
		(int nProjType, CStringArray* pChklstPlatforms);
#endif

	// After the user clicks "Create" with an appwiz type selected, but before
	//  you call RunAppWizSteps, call this and make sure it returns TRUE.  Otherwise,
	//  don't dismiss new/insert project.
	virtual BOOL CanRunAppWizSteps(LPCTSTR szProj, LPCTSTR szProjDir, int* pnPlatforms);

	// This runs the wizard.  It returns one of the APPWIZTERMTYPE_ values.
	// TODO: These values are currently defined in ide\include\appwzshd.h.  They
	//  need to moved here after the build system starts using this interface and
	//  no longer uses appwzshd.h.
	virtual int RunAppWizSteps();

	// If RunAppWizSteps was successful, the caller should create & pass a new HBUILDER if
	//  a new workspace is being created, otherwise the current HBUILDER if this is
	//  from insert project.  This function takes the HBUILDER and adds the AppWizard
	//  targets.
	virtual void AddAppWizTargets(HBUILDER hBld);

	virtual BOOL GetAppWizDialog( CString &strDialog );

	// Call this so AppWizard deallocates stuff.  If you run appwiz steps, call after
	//  AddAppWizTargets.  Otherwise, call after the new/insert project dialog is
	//  dismissed.
	virtual void ExitAppWiz();
};	


#define GETAPPWIZIFACE  (MAKEINTRESOURCE(1))
typedef CAppWizIFace* (WINAPI* PGETAPPWIZIFACE)();

#ifdef VS_PACKAGE
extern CAppWizIFace g_AppWizIFace;
#endif

#endif // _INCLUDE_APPWIZIFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\workspc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// WORKSPC.CPP
//

// comment at end of file explains how to generate new layouts for MSDEV.

#include "stdafx.h"

#include "workspc.h"
#include "about.h"
#include "bardockx.h"

#include <srcapi.h>
#include <srcguid.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern void EnableClock(BOOL bEnable);
extern BOOL IsClockEnabled();

BOOL g_bReloadProject = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CWorkspaceDlg dialog

//	CWorkspaceCheckList::SetCheck
//		Override CCheckList for check notification to the dialog.

void CWorkspaceCheckList::SetCheck(int nItem, BOOL bCheck)
{
	CCheckList::SetCheck(nItem, bCheck);
}

CWorkspaceDlg::CWorkspaceDlg(CDockManager* pManager, CWnd* pParent /*=NULL*/)
	: CDlgTab(CWorkspaceDlg::IDD, IDS_WORKSPACE)
{
	m_pManager = pManager;
	m_nOrder = 100;

	//{{AFX_DATA_INIT(CWorkspaceDlg)
	m_bAuto = (theApp.m_bWorkspaceAuto != 0);
	m_bStatusbar = (theApp.m_bStatusbar != 0);
	m_bAutosave = gAutosaver.IsEnabled();
	m_iInterval = gAutosaver.GetInterval();
	m_bClock = IsClockEnabled();
	m_bReloadProject = g_bReloadProject;
	m_nFiles = theApp.GetRecentFileListSize();
	m_nProjects = theApp.GetRecentProjectListSize();
	m_nWindows = theApp.m_nWindowMenuItems;
	m_bWindowsSort = theApp.m_bWindowMenuSorted;
	m_bMRUSubmenu = !theApp.m_bMRUOnFileMenu;
	m_bTraditionalMenu=!Menu::IsInCmdBarMode();
	//}}AFX_DATA_INIT
}

void CWorkspaceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWorkspaceDlg)
	DDX_Check(pDX, IDC_AUTO_WORKSPACE, m_bAuto);
	DDX_Check(pDX, IDC_STATUSBAR, m_bStatusbar);
	DDX_Check(pDX, IDC_MENU_TRADITIONAL, m_bTraditionalMenu);
	DDX_Check(pDX, IDC_MRU_SUBMENU, m_bMRUSubmenu);
	DDX_Text(pDX, IDC_AUTOSAVE_INTERVAL, m_iInterval);
	DDX_Check(pDX, IDC_CLOCK, m_bClock);
	DDX_Check(pDX, IDC_RELOAD_PROJECT, m_bReloadProject);
	DDX_Text(pDX, IDC_FILES_COUNT, m_nFiles);
	DDV_MinMaxInt(pDX, m_nFiles, 1, 15);
	DDX_Text(pDX, IDC_PROJECTS_COUNT, m_nProjects);
	DDV_MinMaxInt(pDX, m_nProjects, 1, 15);
	DDX_Text(pDX, IDC_WINDOWS_COUNT, m_nWindows);
	DDV_MinMaxInt(pDX, m_nWindows, 1, 31);
	DDX_Check(pDX, IDC_WINDOWS_SORT, m_bWindowsSort);
	//}}AFX_DATA_MAP
#ifdef ENABLE_FILE_AUTOSAVES
	DDX_Check(pDX, IDC_AUTOSAVE_ENABLE, m_bAutosave);
#endif	// ENABLE_FILE_AUTOSAVES
}

//	CWorkspaceDlg::UpdateMDIState
//		For real time MDI switching of views in synch with checkboxes.

void CWorkspaceDlg::UpdateMDIState(int nItem)
{
	ASSERT(nItem >= 0 && nItem < m_aViewWorkers.GetSize());

	CDockWorker* pDocker = GetWorker(nItem);

	// Low overhead if check and visible same
	pDocker->SetMDIState(!m_lbViews.GetCheck(nItem));
}

//	CWorkspaceDlg::GetWorker
//  	Gets the CDockWorker for the given index from m_aViewWorkers, or for
//		the current selection if no index is given.

CDockWorker* CWorkspaceDlg::GetWorker(int nIndex)
{
	if (nIndex < 0 || nIndex >= m_aViewWorkers.GetSize())
		return NULL;
	else
		return (CDockWorker*) m_aViewWorkers.GetAt(nIndex);
}

BEGIN_MESSAGE_MAP(CWorkspaceDlg, CDlgTab)
	//{{AFX_MSG_MAP(CWorkspaceDlg)
	//}}AFX_MSG_MAP
#ifdef ENABLE_FILE_AUTOSAVES
	ON_BN_CLICKED(IDC_AUTOSAVE_ENABLE, OnClickedAutosaveEnable)
#endif	// ENABLE_FILE_AUTOSAVES
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWorkspaceDlg message handlers

BOOL CWorkspaceDlg::OnInitDialog()
{
	// Initialize the listbox and corresponding worker array.
	m_pManager->ArrayOfType(dtEdit, &m_aViewWorkers);

	VERIFY(m_lbViews.SubclassDlgItem(IDC_VIEWS, this));
	m_lbViews.SetRedraw(FALSE);

	CString str;
	int nViews = m_aViewWorkers.GetSize();
	CDockWorker* pDocker;

	for (int i = 0; i < nViews; i++)
	{
		pDocker = GetWorker(i);

		pDocker->GetText(str);
		m_lbViews.AddString(str);
		m_lbViews.SetCheck(i, pDocker->GetDock() != dpMDI);
	}

	m_lbViews.SetRedraw(TRUE);

#ifdef ENABLE_FILE_AUTOSAVES
	((CStatic *)GetDlgItem(IDC_AUTOSAVETEXT1))->EnableWindow(m_bAutosave);
	((CEdit *)GetDlgItem(IDC_AUTOSAVE_INTERVAL))->EnableWindow(m_bAutosave);
	((CStatic *)GetDlgItem(IDC_AUTOSAVETEXT2))->EnableWindow(m_bAutosave);
#endif

	CEdit *pFiles=(CEdit *)GetDlgItem(IDC_FILES_COUNT);
	CEdit *pProjects=(CEdit *)GetDlgItem(IDC_PROJECTS_COUNT);
	CEdit *pWindows=(CEdit *)GetDlgItem(IDC_WINDOWS_COUNT);

	ASSERT(pFiles);
	ASSERT(pProjects);
	ASSERT(pWindows);
	pFiles->SetLimitText(2);
	pProjects->SetLimitText(2);
	pWindows->SetLimitText(2);

	// Initialize listbox first to avoid flashing.
	CDlgTab::OnInitDialog();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

BOOL CWorkspaceDlg::ValidateTab()
{
	if(UpdateData(TRUE))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CWorkspaceDlg::CommitTab()
{
	CDlgTab::CommitTab();

	theApp.m_bWorkspaceAuto = (m_bAuto != 0);
	theApp.m_bStatusbar = m_bStatusbar;
	EnableClock(m_bClock);
	g_bReloadProject = m_bReloadProject;
	ShowStatusBar(m_bStatusbar);

	m_pManager->m_pFrame->RecalcLayout();

	// HACK: Yes locking, and redrawing the window is ugly, but it is the
	//       easiest way to batch these commands into one paint, so we can
	//		 allow cancel.

	CDockWorker* pDocker;
	BOOL bDocking, bChecked;
	BOOL bUpdate = FALSE;

	int nViews = m_aViewWorkers.GetSize();
	for (int i = 0; i < nViews; i++)
	{
		pDocker = GetWorker(i);
		bDocking = (pDocker->GetDock() != dpMDI);
		bChecked = m_lbViews.GetCheck(i);
		if (pDocker->IsVisible() &&
			((bChecked && !bDocking) || (!bChecked && bDocking)))
		{
			// We only need to do this hacky update, if we are changing
			// the state of a visible window.
			bUpdate = TRUE;
			break;
		}
	}

	CWnd* pMainWnd = AfxGetApp()->m_pMainWnd;
	if (bUpdate)
		pMainWnd->SetRedraw(FALSE);

	for (i = 0; i < nViews; i++)
		UpdateMDIState(i);

	if(m_bTraditionalMenu==Menu::IsInCmdBarMode())
	{
		Menu::UseHMENU(m_bTraditionalMenu); // make it permanent
		Menu::UpdateMode(FALSE); // and update the mode next time we're idle
	}

	if (bUpdate)
	{
		pMainWnd->SetRedraw(TRUE);
	    pMainWnd->RedrawWindow(NULL, NULL,
	        RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_UPDATENOW);
	}

	// set recently used list sizes
	theApp.SetRecentFileListSize(m_nFiles);
	theApp.SetRecentProjectListSize(m_nProjects);

	if(theApp.m_bMRUOnFileMenu==m_bMRUSubmenu)
	{
		// state is changing, so update menus. This will alone handle traditional menus
		theApp.m_bMenuDirty=TRUE;

		// Set up state so that any rebuild required will be right
		theApp.m_bMRUOnFileMenu=!m_bMRUSubmenu;

		CBMenuPopup *pMenuFile=theCmdCache.GetMenu(IDM_MENU_FILE);

		CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();

		if(pMenuFile)
		{
			if(!pMenuFile->IsDirty())
			{
				// just reset the file menu
				pFrame->ResetMenu(IDM_MENU_FILE);
			}
			else
			{
				// scan the menu, to find what is already there
				int nFileMRUIndex=-1;
				int nProjMRUIndex=-1;
				int nFileMenuIndex=-1;
				int nProjMenuIndex=-1;
				int nExitIndex=-1;

				for(int i=0; i<pMenuFile->GetMenuItemCount(); ++i)
				{
					CBMenuItem *pItem=pMenuFile->GetMenuItem(i);
					if(pItem)
					{
						int nId=pItem->GetCmdID();
						if(	nId>= ID_FILE_MRU_FIRST &&
							nId<= ID_FILE_MRU_LAST &&
							nFileMRUIndex==-1)
						{
							// find the first one of these on the menu
							nFileMRUIndex=i;
						}

						if(	nId>= ID_PROJ_MRU_FIRST &&
							nId<= ID_PROJ_MRU_LAST &&
							nProjMRUIndex==-1)
						{
							// find the first one of these on the menu
							nProjMRUIndex=i;
						}

						if( nId==IDM_MENU_FILEMRU)
						{
							// but find the last one of these
							nFileMenuIndex=i;
						}

						if( nId==IDM_MENU_WKSMRU)
						{
							// but find the last one of these
							nProjMenuIndex=i;
						}

						if(nId==ID_APP_EXIT)
						{
							// and obviously the last one of these
							nExitIndex=i;
						}
					}
				}

				// calculate insertion points
				// insert file mru submenu
				int nFileInsertIndex=-1;

				// there's not already one on the file menu
				if(nFileMRUIndex!=-1)
				{
					nFileInsertIndex=nFileMRUIndex;
				}
				else if(nFileMenuIndex!=-1)
				{
					nFileInsertIndex=nFileMenuIndex;
				}
				else if(nExitIndex!=-1)
				{
					nFileInsertIndex=nExitIndex;
				}
				else if(nProjMRUIndex!=-1)
				{
					nFileInsertIndex=nProjMRUIndex;
				}
				else if(nProjMenuIndex!=-1)
				{
					nFileInsertIndex=nProjMenuIndex;
				}
				else 
				{
					// this is ok, since -1 is a valid insert point
				}

				int nProjInsertIndex=-1;

				// there's not already one on the file menu
				if(nProjMRUIndex!=-1)
				{
					nProjInsertIndex=nProjMRUIndex;
				}
				else if(nProjMenuIndex!=-1)
				{
					nProjInsertIndex=nProjMenuIndex;
				}
				else if(nExitIndex!=-1)
				{
					nProjInsertIndex=nExitIndex;
				}
				else if(nFileMRUIndex!=-1)
				{
					nProjInsertIndex=nFileMRUIndex;
				}
				else if(nFileMenuIndex!=-1)
				{
					nProjInsertIndex=nFileMenuIndex;
				}
				else 
				{
					// this is ok, since -1 is a valid insert point
				}

				// now do the insertions and deletions
				if(m_bMRUSubmenu)
				{
					if(	nProjMenuIndex==-1)
					{
						// insert the file submenu
						pMenuFile->InsertMenu(nProjInsertIndex, MF_BYPOSITION|MF_POPUP, IDM_MENU_WKSMRU);
					}

					if(	nFileMenuIndex==-1)
					{
						// insert the file submenu
						pMenuFile->InsertMenu(nFileInsertIndex, MF_BYPOSITION|MF_POPUP, IDM_MENU_FILEMRU);
					}

					BOOL bDeleteSeparators=FALSE;

					// Now iterate deleting all the standard MRU items, and any separators after file
					for(int i=0; i<pMenuFile->GetMenuItemCount();)
					{
						CBMenuItem *pItem=pMenuFile->GetMenuItem(i);
						if(pItem)
						{
							int nId=pItem->GetCmdID();
							if(	nId>= ID_FILE_MRU_FIRST &&
								nId<= ID_FILE_MRU_LAST)
							{
								pMenuFile->DeleteMenu(i, MF_BYPOSITION);
								bDeleteSeparators=TRUE;

							} 
							else if(	nId>= ID_PROJ_MRU_FIRST &&
										nId<= ID_PROJ_MRU_LAST)
							{
								pMenuFile->DeleteMenu(i, MF_BYPOSITION);
								bDeleteSeparators=FALSE;
							} 
							else if(pItem->GetItemType()==CBMenuItem::MIT_Separator)
							{
								if(bDeleteSeparators)
								{
									pMenuFile->DeleteMenu(i, MF_BYPOSITION);
								}
								else
								{
									++i;
								}
							}
							else
							{
								bDeleteSeparators=FALSE;
								++i;
							}
						}
					}
				}
				else
				{
					if(	nProjMRUIndex==-1)
					{
						// insert the wks item
						pMenuFile->InsertMenu(nProjInsertIndex, MF_BYPOSITION, ID_PROJ_MRU_FIRST);
					}

					if(	nFileMRUIndex==-1)
					{
						// insert the file item
						pMenuFile->InsertMenu(nFileInsertIndex, MF_BYPOSITION|MF_SEPARATOR);
						pMenuFile->InsertMenu(nFileInsertIndex, MF_BYPOSITION, ID_FILE_MRU_FIRST);
						pMenuFile->InsertMenu(nFileInsertIndex, MF_BYPOSITION|MF_SEPARATOR);
					}

					// Now iterate deleting all the submenu items
					for(int i=0; i<pMenuFile->GetMenuItemCount();)
					{
						CBMenuItem *pItem=pMenuFile->GetMenuItem(i);
						if(pItem)
						{
							int nId=pItem->GetCmdID();
							if(	nId== IDM_MENU_FILEMRU)
							{
								pMenuFile->DeleteMenu(i, MF_BYPOSITION);
							} 
							else if(nId== IDM_MENU_WKSMRU)
							{
								pMenuFile->DeleteMenu(i, MF_BYPOSITION);
							} 
							else
							{
								++i;
							}
						}
					}
				}
			}
		}
	}

	// update the number of mnemonics
	theApp.CalculateRecentMnemonics();

	theApp.m_nWindowMenuItems=m_nWindows;
	theApp.m_bWindowMenuSorted=m_bWindowsSort;

#ifdef ENABLE_FILE_AUTOSAVES
	if (m_bAutosave)
		gAutosaver.Enable(m_iInterval);
	else
		gAutosaver.Disable();
#endif
}

#ifdef ENABLE_FILE_AUTOSAVES
void CWorkspaceDlg::OnClickedAutosaveEnable()
{
	int iCheckState;

	iCheckState = ((CButton *)GetDlgItem(IDC_AUTOSAVE_ENABLE))->GetCheck();
	((CStatic *)GetDlgItem(IDC_AUTOSAVETEXT1))->EnableWindow(iCheckState);
	((CEdit *)GetDlgItem(IDC_AUTOSAVE_INTERVAL))->EnableWindow(iCheckState);
	((CStatic *)GetDlgItem(IDC_AUTOSAVETEXT2))->EnableWindow(iCheckState);

	// dolphin 4640 [patbr]
	// MFC will validate entry field even if it is disabled, so put value in
	// entry field as we are disabling it so that UpdateData() will succeed.
	//
	// if we are enabling the field because the accompanying check box has
	// been checked, move the focus to the entry field for user convenience.
	if (iCheckState)
		((CEdit *)GetDlgItem(IDC_AUTOSAVE_INTERVAL))->SetFocus();
	else
		((CEdit *)GetDlgItem(IDC_AUTOSAVE_INTERVAL))->SetWindowText("15");
}
#endif	// ENABLE_FILE_AUTOSAVES

///////////////////////////////////////////////////////////////////////////////
//	CMainFrame
//		Workspace handling members.

static char BASED_CODE szLayoutVersion[] = "Version";
static char BASED_CODE szLayoutKey[] = "Layout%d";
static char BASED_CODE szStatusbar[] = "Statusbar";
static char BASED_CODE szClock[] = "Clock";
static char BASED_CODE szReloadProject[] = "ReloadProject";
static char BASED_CODE szDisableFileDep[] = "DisableFileDep";
static char BASED_CODE szWorkspaceDocs[] = "Documents";

#define RT_LAYOUT MAKEINTRESOURCE(IDRT_LAYOUT)

void CMainFrame::LoadLayout()
{
#ifdef _WIN32
	int nVer = GetRegInt(CDockWorker::s_lpszLayoutSection, szLayoutVersion, 0);
	if (nVer != LAYOUT_VERSION)
	{
		CString strKeyMain = GetRegistryKeyName();
		RegDeleteKey(HKEY_CURRENT_USER, strKeyMain + chKeySep + CDockWorker::s_lpszLayoutSection);
		// olympus 947 [patbr] removed return statement here which
		// was preventing us from executing any of the code below.
	}

	CString str;

	for (int i = 0; i < MANAGER_STATES; i++)
	{
		wsprintf(str.GetBuffer(_MAX_PATH + 1), szLayoutKey, i);
		str.ReleaseBuffer();

		m_ahManagerStates[i] = GetRegData(CDockWorker::s_lpszLayoutSection, str, NULL);
	}

	theApp.m_bStatusbar = GetRegInt(CDockWorker::s_lpszLayoutSection, szStatusbar, TRUE);
	EnableClock(GetRegInt(CDockWorker::s_lpszLayoutSection, szClock, !theApp.m_bWin4));

	// setting the file dependency scanning here. We need to do it here, instead
	// of in one of the packages, since later on we will write it out in the 
	// SaveLayout();
	theApp.m_nDisableFileDep = GetRegInt (CDockWorker::s_lpszLayoutSection, szDisableFileDep, FILEDEP_DISABLE_IFUPTODATE);
	TRACE ("CMainFrame::LoadLayout: DisableFileDep = %d\n", theApp.m_nDisableFileDep);

	// olympus 13617 [patbr]
	// if emulation is set to VC20 and no 'reload project' setting found,
	// then set 'Reload last project on startup' to TRUE (i.e., like VC20).

	BOOL bEmulationIsVC20 = FALSE;
	LPSOURCEQUERY pInterface;
	if (SUCCEEDED(theApp.FindInterface(IID_ISourceQuery, (LPVOID FAR *)&pInterface)))
	{
		ASSERT(pInterface != NULL);
		bEmulationIsVC20 = (pInterface->IsEmulationVC20() == S_OK);
		pInterface->Release();
	}

	g_bReloadProject = GetRegInt(CDockWorker::s_lpszLayoutSection, szReloadProject, bEmulationIsVC20);

	m_FS.LoadFromReg (CDockWorker::s_lpszLayoutSection);
#endif
}

void CMainFrame::SaveLayout()
{
// REVIEW: Why is this in #ifdef _WIN32? What are we worried about? WIN64? ;)
#ifdef _WIN32
	CString str;

	CString strKeyMain = GetRegistryKeyName();
	WriteRegInt(CDockWorker::s_lpszLayoutSection, szLayoutVersion, LAYOUT_VERSION);

	// Save current manager to a layout buffer.
	SaveManager();
	m_pManager->SaveWorkers();

	// Save the layout buffers.
	for (int i = 0; i < MANAGER_STATES; i++)
	{
		wsprintf(str.GetBuffer(_MAX_PATH + 1), szLayoutKey, i);
		str.ReleaseBuffer();

		if (m_ahManagerStates[i] != NULL)
			WriteRegData(CDockWorker::s_lpszLayoutSection, str, m_ahManagerStates[i]);
	}

	if (m_nManagerState < MANAGER_STATES && m_ahManagerStates[m_nManagerState] != NULL)
	{
		::GlobalFree(m_ahManagerStates[m_nManagerState]);
		m_ahManagerStates[m_nManagerState] = NULL;
	}

	WriteRegInt(CDockWorker::s_lpszLayoutSection, szStatusbar, theApp.m_bStatusbar);

	WriteRegInt(CDockWorker::s_lpszLayoutSection, szClock, IsClockEnabled());
	WriteRegInt(CDockWorker::s_lpszLayoutSection, szReloadProject, g_bReloadProject);
	WriteRegInt (CDockWorker::s_lpszLayoutSection, szDisableFileDep, theApp.m_nDisableFileDep);
	m_FS.SaveToReg (CDockWorker::s_lpszLayoutSection);

	theCmdCache.SaveMenus();
#endif
}

BOOL CMainFrame::LoadManager()
{
	CDockManager* pManagerOld = m_pManager;
	BOOL bSuccess = FALSE;
	int nMaxFails = 2;

#ifdef _EXPORT_LAYOUT
	// If we are building new resource files then we don't want to
	// read from the old ones.
	//
	if (theApp.m_bExportLayout)
		nMaxFails = 1;
#endif

	CInitFile fileInit;

	for (int nFailure = 0; nFailure < nMaxFails && !bSuccess; nFailure++)
	{
		if (nFailure == 0)
		{
			if (m_ahManagerStates[m_nManagerState] == NULL)
				continue;

			fileInit.SetBuffer(m_ahManagerStates[m_nManagerState]);
			m_ahManagerStates[m_nManagerState] = NULL;	// CInitFile is delete responsible.
		}
		else
		{
			if (!fileInit.Open(RT_LAYOUT,
					MAKEINTRESOURCE(m_nManagerState + 1),
					CFile::modeRead, CInitFile::dataResource))
				continue;
		}

		CArchive loadArchive(&fileInit,
			CArchive::load | CArchive::bNoFlushOnDelete);
		TRY
		{
			// Need to load into m_pManager for Create() to work.
			//
			loadArchive >> m_pManager;
			loadArchive.Close();
			fileInit.Close();

		    if (!m_pManager->Create(this, m_pWndMDIClient, pManagerOld))
		    	delete m_pManager;
		    else
		    {
				if (pManagerOld != NULL)
		    		delete pManagerOld;

				MapDockingCmds();
		    
				bSuccess = TRUE;
		    }
		}
		CATCH_ALL(e)
		{
			fileInit.Abort(); // will not throw an exception

			// Don't delete m_pManager, as it may be trash in this case,
			// causing the destructor to crash us.
		}
		END_CATCH_ALL
	}

	if (!bSuccess)
	{
		m_pManager = pManagerOld;
		if (m_pManager != NULL)
			m_pManager->SetAvailableWndDirty();
	}

	return bSuccess;
}

BOOL CMainFrame::SaveManager()
{
	// If we are in DocObject mode
	// we don't want to save or load the DocObject mode state.
	if(m_pManager->IsInDocObjectMode())
		return TRUE;

	CInitFile fileInit;
	fileInit.Open((LPCSTR) NULL, (LPCSTR) NULL, CFile::modeWrite);

	CArchive saveArchive(&fileInit,
		CArchive::store | CArchive::bNoFlushOnDelete);
	TRY
	{
		saveArchive << m_pManager;
		saveArchive.Close();	// flush the archive

		ASSERT(m_ahManagerStates[m_nManagerState] == NULL);	// Otherwise we leak.
		m_ahManagerStates[m_nManagerState] = fileInit.GetInitData();
		fileInit.Close();
	}
	CATCH_ALL(e)
	{
		fileInit.Abort(); // will not throw an exception

		return FALSE;
	}
	END_CATCH_ALL

#ifdef _EXPORT_LAYOUT
	if (theApp.m_bExportLayout)
	{
		CString str;
		wsprintf(str.GetBuffer(_MAX_PATH + 1), theApp.m_pszLayoutFilePath,
			m_nManagerState);
		str.ReleaseBuffer();

		CFile fileExport;
		CFileException fe;

		if (!fileExport.Open(str, CFile::modeCreate | CFile::modeReadWrite |
			CFile::shareExclusive, &fe))
			return FALSE;
		else
		{
			CArchive saveArchive(&fileExport, CArchive::store |
				CArchive::bNoFlushOnDelete);
			TRY
			{
				saveArchive << m_pManager;
				saveArchive.Close();
				fileExport.Close();
			}
			CATCH_ALL(e)
			{
				fileExport.Abort(); // will not throw an exception

				return FALSE;
			}
			END_CATCH_ALL
		}
	}
#endif

	return TRUE;
}

BOOL CMainFrame::SerializeWorkspaceLayout(CStateSaver& stateSave)
{
	BOOL bReturn = TRUE;
	BOOL bSave = stateSave.IsStoring();

	CInitFile fileInit;
	if (!stateSave.OpenStream(fileInit, szWorkspaceDocs))
	{
		if (bSave) 
			SetFileError(CFileException::generic);
		return FALSE;
	}

	UINT nMode = CArchive::bNoFlushOnDelete |
		(bSave ? CArchive::store : CArchive::load);
	CArchive ar(&fileInit, nMode);
	TRY
	{
		if (bSave)
			bReturn = SaveWorkspace(ar);
		else
			bReturn = LoadWorkspace(ar);

		ar.Close();	// flush the archive
		fileInit.Close();
	}
	CATCH_ALL(e)
	{
		if (bSave)
		{
			if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
				SetFileError(((CFileException*) e)->m_cause);
			else
				SetFileError(CFileException::generic);
		}
		
		fileInit.Abort(); // will not throw an exception
		bReturn = FALSE;
	}
	END_CATCH_ALL

	return bReturn;
}

BOOL CMainFrame::LoadWorkspace(CArchive& ar)
{
	ASSERT(ar.IsLoading());

	BOOL bFailed = FALSE, bCancel = FALSE, bLock = FALSE;
	int i, iProj = -1;

	WORD wCount = 0;
	CWnd** aWnd = NULL;
	CDocument** aDoc = NULL;
	UINT* anShow = NULL;

	TRY
	{
		// If it's the wrong version, just blow out.
		WORD wVer;
		ar >> wVer;
		if (wVer != WORKSPACE_VERSION)
			return FALSE;

		WORD wZTemp;
		int iZ;

		WORD wMaximizeDoc;
		ar >> wMaximizeDoc >> wCount;

		if (wCount == 0)
		{
			theApp.m_bMaximizeDoc = (wMaximizeDoc != 0);
			return TRUE;		         
		}

		aWnd = new CWnd*[(int) wCount];
		aDoc = new CDocument*[(int) wCount];
		anShow = new UINT[(int) wCount];

		// NULL out window pointers.  If an exception is thrown reading
		// the workspace, we want to destroy all the windows created.
		memset(aWnd, '\0', wCount * sizeof(CWnd*));

		// Check to make sure the screen size has not shrunk since we wrote
		// the workspace.  If it has, do not place the window; use default
		// cascade.
		BOOL bPlace = TRUE;
		WORD wMetric;
		ar >> wMetric;
		if (wMetric > GetSystemMetrics(SM_CXSCREEN))
			bPlace = FALSE;
		ar >> wMetric;
		if (wMetric > GetSystemMetrics(SM_CYSCREEN))
			bPlace = FALSE;

		bLock = !CPartFrame::IsWorkspaceLocked();	// Don't lock if we already are.
		if (bLock)
			CPartFrame::LockWorkspace(TRUE);

		CString strComment;
		VERIFY( strComment.LoadString( IDS_LOADINGWRKSPC ) );
		StatusBeginPercentDone( strComment );

		theApp.m_bMaximizeDoc = FALSE;

		// Don't load windows if escape is down.  This call to GetAsyncKeyState
		// also primes the pump for future calls which will check the least
		// significant bit (set if the user has pressed Esc since last call).
		//
		if ((GetAsyncKeyState(VK_ESCAPE) & ~1) != 0)
			bCancel = TRUE;
		else
		{
			// Create and place the document windows.
			for (i = 0; i < (int) wCount; i++)
			{
				// Read z-order and store it for a later DeferWindowPos.
				ar >> wZTemp;
				iZ = (int) wZTemp;

				ASSERT(iZ >= 0 && iZ < wCount);

				aWnd[iZ] = LoadWorkspaceWindow(ar, bPlace, &aDoc[iZ], &anShow[iZ]);
										    
				StatusPercentDone(((i + 1) * 100) / (wCount + 1));

				// If user pressed escape, stop loading windows.
				if ((GetAsyncKeyState(VK_ESCAPE) & 1) != 0)
				{
					bCancel = TRUE;
					break;
				}
			}
		}

		if (wMaximizeDoc != 0)
		{
			theApp.m_bMaximizeDoc = TRUE;

			for (i = 0; i < (int) wCount && aWnd[i] == NULL; i++)
				;

			if (i < wCount)
				anShow[i] = SW_SHOWMAXIMIZED;
		}

		StatusPercentDone(100);	// Let the user see this.
		ShowSplashScreen(FALSE);

		if (bLock)
			CPartFrame::LockWorkspace(FALSE);

		m_pWndMDIClient->ShowWindow(SW_HIDE);

		// Z-order, and show the windows.
		HWND hwndCurrent, hwndAfter = HWND_TOP;
		UINT dwFlags = 0;
		HDWP hdwp = ::BeginDeferWindowPos((int) wCount);
		ASSERT(hdwp != NULL);

		for (i = 0; i < (int) wCount; i++)
		{
			if (aWnd[i] == NULL)
				continue;

			aWnd[i]->ShowWindow(anShow[i]);

			// Make sure the window is in the right z-order.
			hwndCurrent = ((CWnd*) aWnd[i])->m_hWnd;
			ASSERT(hwndCurrent != NULL);

			hdwp = ::DeferWindowPos(hdwp, hwndCurrent,
				hwndAfter, 0, 0, 0, 0,
				SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | dwFlags);

			hwndAfter = hwndCurrent;
			dwFlags = SWP_NOACTIVATE;	// Only activate first window.
		}

		::EndDeferWindowPos(hdwp);

		m_pWndMDIClient->ShowWindow(SW_SHOWNA);

		// Now that all the windows are visible, we need to update the
		// document frame counts, and titles.
		for (i = 0; i < (int) wCount; i++)
		{
			if (aWnd[i] == NULL)
				bFailed = TRUE;
			else
			{
				ASSERT(aDoc[i] != NULL);
				aDoc[i]->UpdateFrameCounts();
				ASSERT(aWnd[i]->IsKindOf(RUNTIME_CLASS(CPartFrame)));
				((CPartFrame*) aWnd[i])->OnUpdateFrameTitle(TRUE);
			}
		}

		m_pWndMDIClient->UpdateWindow();
	}
	CATCH_ALL(e)
	{
		bFailed = TRUE;

		for (i = 0; i < (int) wCount; i++)
		{
			ASSERT(aWnd != NULL);

			if (i != iProj && aWnd[i] != NULL)
			{
				aWnd[i]->DestroyWindow();
				delete aWnd[i];
				aWnd[i] = NULL;
			}
		}

		if (bLock)
			CPartFrame::LockWorkspace(FALSE);

		StatusEndPercentDone();

		delete [] aWnd;
		delete [] aDoc;
		delete [] anShow;

		THROW_LAST();
	}
	END_CATCH_ALL

	delete [] aWnd;
	delete [] aDoc;
	delete [] anShow;

	StatusEndPercentDone();

	FlushKeys();

	if (bFailed && !bCancel)
		InformationBox(ERR_Workspace_Window);

	return TRUE;
}

CPartFrame* CMainFrame::LoadWorkspaceWindow(CArchive& ar,
	BOOL bPlace /*=TRUE*/, CDocument** hDoc /*=NULL*/,	
    UINT* pnCmdShow /*=NULL*/)
{
	BOOL bSingle = !CPartFrame::IsWorkspaceLocked();
	if (bSingle)
		CPartFrame::LockWorkspace(TRUE);

	ASSERT(!bSingle || (pnCmdShow != NULL && hDoc != NULL));

	// Read view init data, and store it in CPartFrame static to
	// allow efficient initialization during OpenDocumentFile().
	WORD wSize;
	ar >> wSize;

	if (wSize == 0)
		CPartFrame::SetInitData(NULL);
	else
	{
		LPBYTE lpData = new BYTE[wSize + sizeof(WORD)];
		LPWORD lpwSize = (LPWORD) lpData;

		*lpwSize = wSize;
		ar.Read(lpwSize + 1, (int) wSize);

		CPartFrame::SetInitData(lpData);
	}

	// Read file open moniker.
	CString strMoniker;
	ar >> strMoniker;

	// Some kinds of monikers append to the path some details of how to open themselves.
	// For example, dialogs are saved  as .\project.rc<newline>Dialog IDD_DIALOG1 [English [US]]
	// We need to get the full path, but on Windows 95, the full path code won't allow an embedded
	// newline in the path, despite what the documentation says.
	// martynl 16Dec96

	{ // context to hide pathMoniker from everyone else, because it isn't a full representation

		// first cut off the internal part of the moniker
		int nMonikerIndex=strMoniker.Find(chMonikerSep);
		CString strInternal;

		if(nMonikerIndex!=-1)
		{
			// cut off the internal piece
			strInternal=strMoniker.Right(strMoniker.GetLength()-nMonikerIndex);
			strMoniker=strMoniker.Left(nMonikerIndex);
		}

		// determine the full path to the external piece
		CPath pathMoniker;
		pathMoniker.Create(strMoniker);

		// give strMoniker the full path, and re-add the internal piece, if it exists
		strMoniker = pathMoniker.GetFullPath()+strInternal;
	}

	// Read DocTemplate runtime class, and create the document window.
	CPartFrame* pFrame = NULL;
	CDocTemplate* pTemplate = NULL;
	CDocument* pDoc = NULL;

	//BLOCK:
	{
		USES_CONVERSION;

		CString strClsid;
		ar >> strClsid;

		CLSID clsid;
		if (CLSIDFromString(A2W(strClsid), &clsid) == S_OK)
			pTemplate = theApp.GetTemplate(clsid);
	}

	// Read the saved value of CFrameWnd::m_nWindow.
	WORD wWindow;
	ar >> wWindow;

	// If we don't have that class any more, then don't try to
	// open the file.
	if (pTemplate != NULL)
	{
		// If opening multiple doc's don't try to open the file if it
		// doesn't exist.  We want to minimize the number of error messages
		// the user might get.
		//
		BOOL bTry = FALSE;
		if (bSingle || strMoniker.Find(chMonikerSep) != -1 ||
			FileExists(strMoniker))
		{
			bTry = TRUE;
		}

		if (bTry)
		{
			CDocTemplate* pOpenTemplate;
			pFrame = theApp.GetOpenFrame(strMoniker, pOpenTemplate, pDoc);

			if (pFrame == NULL)
			{
				pDoc = pTemplate->OpenDocumentFile(strMoniker);
				if (pDoc != NULL)	// GetWorkspaceWnd invalid if we failed.
					pFrame = CPartFrame::GetWorkspaceWnd();
			}
			else
			{
				if (pTemplate != pOpenTemplate)
					CPartFrame::SetInitData(NULL);
				else if (wWindow != 0)
				{
					// This was a multiple frame window before, so it is okay
					// to create a new frame now.
					pFrame = (CPartFrame*)
						pTemplate->CreateNewFrame(pDoc, pFrame);
				}

				pTemplate = pOpenTemplate;

				if (pFrame != NULL)
				{
					ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));
					pTemplate->InitialUpdateFrame(pFrame, pDoc);
				}
			}
		}
	}

	if (hDoc != NULL)
		*hDoc = pDoc;

	if (bSingle)
		CPartFrame::LockWorkspace(FALSE);


	// Read and set window placement.  Save  the showCmd for later, since
	// we want the windows to stay invisible during creation.
	WINDOWPLACEMENT place;
	ar.Read(&place, sizeof(WINDOWPLACEMENT));
	place.length = sizeof(WINDOWPLACEMENT);	// Fix for NT bug.

	if (!bPlace || pFrame == NULL)
	{
		if (!bSingle)
			*pnCmdShow = SW_SHOW;
	}
	else
	{
		if (!bSingle)
		{
			*pnCmdShow = place.showCmd;
			place.showCmd = SW_HIDE;
		}

		pFrame->SetWindowPlacement(&place);
	}

	if (pFrame != NULL)
	{
		// This is usually done in CPartTemplate::InitialUpdateFrame,
		// but with workspaces we want the window to be sized before
		// it is required to initialize itself.

		pFrame->SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE);

		// These handlers should use the data from CPartFrame::GetCurData().
		pFrame->OnLoadWorkspace();
	}

	// Delete the initialization data.
	CPartFrame::SetInitData(NULL);

	return pFrame;
}

BOOL CMainFrame::SaveWorkspace(CArchive& ar)
{
	ASSERT(ar.IsStoring());

	CPartFrame* pFrame;
	WORD wCount = 0, wMaximizeDoc = (WORD)theApp.m_bMaximizeDoc;

	WORD wZOrderProj = WORD(-1);

	// Count the number of windows we will be saving.
	for (CWnd* pWndNext = MDIGetActive(); pWndNext != NULL;
		pWndNext = pWndNext->GetWindow(GW_HWNDNEXT))
	{
		if(!IsValidMDICycleMember(pWndNext))
			continue;

		pFrame = (CPartFrame*) pWndNext;
		ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));
		if (!pFrame->IsInWorkspace())
			continue;

		wCount++;
	}

	ar << (WORD) WORKSPACE_VERSION << wMaximizeDoc << wCount;

    if (wCount == 0)
        return TRUE;

	ar << (WORD) GetSystemMetrics(SM_CXSCREEN)
		<< (WORD) GetSystemMetrics(SM_CYSCREEN);

	BOOL bSavedDocWnds = FALSE, bSavedDependents = FALSE;

	while (!bSavedDocWnds || !bSavedDependents)
	{
		pWndNext = MDIGetActive();
		WORD wZOrder = wCount;

		// Write out the per window data in reverse Z-order, so that we can
		// load them in the right order.
		for (pWndNext = pWndNext->GetWindow(GW_HWNDLAST); pWndNext != NULL;
			pWndNext = pWndNext->GetWindow(GW_HWNDPREV))
		{
			if(!IsValidMDICycleMember(pWndNext))
				continue;

			pFrame = (CPartFrame*) pWndNext;
			ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)));
			if (!pFrame->IsInWorkspace())
				continue;

			wZOrder--;

			// Save non-dependents in first loop, and dependents
			// the second.
			if (bSavedDocWnds ? !pFrame->IsDependent() : pFrame->IsDependent())
				continue;

			// Write ZOrder.
			ar << wZOrder;
			SaveWorkspaceWindow(ar, pFrame, TRUE);
		}

		ASSERT(wZOrder == 0);	// Missing some windows?

		bSavedDependents = bSavedDocWnds;
		bSavedDocWnds = TRUE;
	}

	return TRUE;
}

void CMainFrame::SaveWorkspaceWindow(CArchive& ar, CPartFrame* pFrame,
	BOOL bRelative /*=FALSE*/)
{
	ASSERT_VALID(pFrame);

	// Write frame initialization data.
	LPBYTE lpData = pFrame->GetInitData();
	if (lpData == NULL)
		ar << (WORD) 0;
	else
	{
		LPWORD lpwSize = (LPWORD) lpData;
		int nSize = *lpwSize + sizeof(WORD);	// First word is data size.
		ASSERT(nSize > 0);	// Hey! no data.

		ar.Write(lpData, nSize);

		delete [] lpData;
	}

	// Write the file open moniker.
	CString strMoniker = pFrame->GetWorkspaceMoniker(bRelative);
	ASSERT(!strMoniker.IsEmpty());
	ar << strMoniker;

	// Write template CLSID.
	CDocument* pDoc = pFrame->GetActiveDocument();
	ASSERT_VALID(pDoc);
	CPartTemplate* pTemplate = (CPartTemplate*) pDoc->GetDocTemplate();
	ASSERT(pTemplate != NULL && pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));

	CString strClsid;

	LPWSTR lpwsz;
	if (StringFromCLSID(pTemplate->GetTemplateClsid(), &lpwsz) == NOERROR)
	{
		USES_CONVERSION;

		strClsid = W2A(lpwsz);
		AfxFreeTaskMem(lpwsz);
	}

	ar << strClsid;

	// Write window number.
	ar << (WORD) pFrame->m_nWindow;

	// Write window placement.
	WINDOWPLACEMENT place;
	place.length = sizeof(WINDOWPLACEMENT);
	pFrame->GetWindowPlacement(&place);
	ar.Write(&place, sizeof(WINDOWPLACEMENT));
}

/*
Generating new layouts for MSDEVD.EXE:
======================================
Follow directions in dev\ide\exes\dev\layouts.doc.  Make changes if necessary.
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\advanced.cpp ===
// advanced.cpp : implementation file
//

#include "stdafx.h"
#include "mfcappwz.h"
#include "symbols.h"
#include "advanced.h"
#include "ddxddv.h"
#include "lang.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL IsValidTitle(const char* szTitle);

/////////////////////////////////////////////////////////////////////////////
// CAdvancedDlg dialog

CAdvancedDlg::CAdvancedDlg(CWnd* pParent)
	: CTabbedDialog(IDS_ADVANCED, pParent, UINT(-1), CTabbedDialog::commitOnTheFly)
{
	CDocStringsDlg* pDocStringsDlg = NULL;
	if (!DoesSymbolExist("NODOCVIEW"))
	{
		pDocStringsDlg = new CDocStringsDlg;
		AddTab((CDlgTab*) pDocStringsDlg);
	}

	CFrameStylesDlg* pFrameStylesDlg = new CFrameStylesDlg;
	AddTab((CDlgTab*) pFrameStylesDlg);

	/*if (IsMDI())
	{
		CChildFrameStylesDlg* pChildFrameStylesDlg = new CChildFrameStylesDlg;
#ifdef VS_PACKAGE
		AddPage(pChildFrameStylesDlg);
#else
		AddTab((CDlgTab*) pChildFrameStylesDlg);
#endif	// VS_PACKAGE
	}*/

	CString tmp;
	if (DoesSymbolExist("TARGET_MAC"))
	{
		CMacDlg* pMacDlg = new CMacDlg;
		AddTab((CDlgTab*) pMacDlg);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFrameStylesDlg dialog

CFrameStylesDlg::CFrameStylesDlg()
	: CDlgTab(CFrameStylesDlg::IDD, IDS_FRAME_STYLES)
{
	m_nIDHelp = CFrameStylesDlg::IDD;
	//{{AFX_DATA_INIT(CFrameStylesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

void CFrameStylesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFrameStylesDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFrameStylesDlg, CDlgTab)
	//{{AFX_MSG_MAP(CFrameStylesDlg)
	ON_BN_CLICKED(IDC_MAXIMIZE, OnMaximize)
	ON_BN_CLICKED(IDC_MINIMIZE, OnMinimize)
	ON_BN_CLICKED(IDC_CHILD_MINIMIZE, OnChildMinimize)
	ON_BN_CLICKED(IDC_CHILD_MAXIMIZE, OnChildMaximize)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFrameStylesDlg message handlers

BOOL CFrameStylesDlg::ValidateTab()
{
	// Record splitter
	CButton* pCheck = (CButton*) GetDlgItem(IDC_MAIN_SPLITTER);
	ASSERT(pCheck != NULL);
	if (pCheck->GetCheck())
	{
		if (!CanViewClassBeUsedWithSplitter(projOptions.m_names.strBaseClass[classView]))
		{
			CString strMessageText;
			AfxFormatString1(strMessageText, IDP_EDITVIEW_THEN_SPLITTER,
				projOptions.m_names.strBaseClass[classView]);
			int nResult = AfxMessageBox(strMessageText, MB_OKCANCEL);
			if (nResult == IDCANCEL)
				return FALSE;
			projOptions.m_names.strBaseClass[classView] = "CView";
			SetBaseViewSymbols();
		}
		projOptions.m_bSplitter = TRUE;
	}
	else
		projOptions.m_bSplitter = FALSE;
	
	// Record main frame styles
	projOptions.m_nFrameStyles = 0;
	for (int i = FRAME_STYLES_START; i <= FRAME_STYLES_END; i++)
	{
		CButton* pCheck = (CButton*) GetDlgItem(i);
		ASSERT(pCheck != NULL);
		if (pCheck->GetCheck())
			projOptions.m_nFrameStyles |= (1 << (i - FRAME_STYLES_START));
	}

	// Record child frame styles.
	projOptions.m_nChildFrameStyles = 0;
	for (i = CHILD_FRAME_STYLES_START; i <= CHILD_FRAME_STYLES_END; i++)
	{
		CButton* pCheck = (CButton*) GetDlgItem(i);
		ASSERT(pCheck != NULL);
		if (pCheck->GetCheck())
			projOptions.m_nChildFrameStyles |= (1 << (i - CHILD_FRAME_STYLES_START));
	}

	return TRUE;
}

void CFrameStylesDlg::CommitTab()
{
	ValidateTab();
}

BOOL CFrameStylesDlg::OnInitDialog()
{
	CDlgTab::OnInitDialog();

	// Display main frame styles
	for (int i = FRAME_STYLES_START; i <= FRAME_STYLES_END; i++)
	{
		CButton* pCheck = (CButton*) GetDlgItem(i);
		ASSERT(pCheck != NULL);
		if (projOptions.m_nFrameStyles & (1 << (i - FRAME_STYLES_START)))
			pCheck->SetCheck(TRUE);
		else
			pCheck->SetCheck(FALSE);
	}
	OnMaximize();
	OnMinimize();

	CWnd *pWndTemp;

	// Display child frame styles
	if (IsMDI())
	{
		// We're MDI, so display the current child frame style settings
		for (int i = CHILD_FRAME_STYLES_START; i <= CHILD_FRAME_STYLES_END; i++)
		{
			CButton* pCheck = (CButton*) GetDlgItem(i);
			ASSERT(pCheck != NULL);
			if (pCheck != NULL)
			{
				pCheck->EnableWindow(TRUE);
				if (projOptions.m_nChildFrameStyles & (1 << (i - CHILD_FRAME_STYLES_START)))
					pCheck->SetCheck(TRUE);
				else
					pCheck->SetCheck(FALSE);
			}
		}

		pWndTemp = GetDlgItem(IDC_CHILD_STATIC);
		if (pWndTemp != NULL)
			pWndTemp->EnableWindow(TRUE);

		OnChildMaximize();
		OnChildMinimize();
		// Hide note about SDI main frame Minimized and Maximized styles

		pWndTemp = GetDlgItem(IDC_NOTE);
		if (pWndTemp != NULL)
			pWndTemp->ShowWindow(SW_HIDE);

		pWndTemp = GetDlgItem(IDC_NOTE_NOMINMAX);
		if (pWndTemp != NULL)
			pWndTemp->ShowWindow(SW_HIDE);
	}
	else
	{
		// We're SDI so disable all the child frame style controls
		for (int i = CHILD_FRAME_STYLES_START; i <= CHILD_FRAME_STYLES_END; i++)
		{
			CButton* pCheck = (CButton*) GetDlgItem(i);
			ASSERT(pCheck != NULL);
			pCheck->EnableWindow(FALSE);
		}

		pWndTemp = GetDlgItem(IDC_CHILD_STATIC);
		if (pWndTemp != NULL)
			pWndTemp->EnableWindow(FALSE);
	}

	// Display splitter option
	CButton* pCheck = (CButton*) GetDlgItem(IDC_MAIN_SPLITTER);
	ASSERT(pCheck != NULL);
	if (pCheck != NULL)
	{
		if (projOptions.m_bNoDocView)
		{
			projOptions.m_bSplitter = FALSE;
			pCheck->EnableWindow(FALSE);
		} else {
			pCheck->EnableWindow(TRUE);
		}

		if (projOptions.m_bSplitter)
			pCheck->SetCheck(TRUE);
		else
			pCheck->SetCheck(FALSE);
	}

	return TRUE;
}

// These prohibit the user from selecting Minimize & Maximize simultaneously.

void CFrameStylesDlg::OnMaximize()
{
	if (IsDlgButtonChecked(IDC_MAXIMIZE))
		GetDlgItem(IDC_MINIMIZE)->EnableWindow(FALSE);
	else
		GetDlgItem(IDC_MINIMIZE)->EnableWindow(TRUE);
}

void CFrameStylesDlg::OnMinimize()
{
	if (IsDlgButtonChecked(IDC_MINIMIZE))
		GetDlgItem(IDC_MAXIMIZE)->EnableWindow(FALSE);
	else
		GetDlgItem(IDC_MAXIMIZE)->EnableWindow(TRUE);
}

void CFrameStylesDlg::OnChildMinimize()
{
	if (IsDlgButtonChecked(IDC_CHILD_MINIMIZE))
		GetDlgItem(IDC_CHILD_MAXIMIZE)->EnableWindow(FALSE);
	else
		GetDlgItem(IDC_CHILD_MAXIMIZE)->EnableWindow(TRUE);
}

void CFrameStylesDlg::OnChildMaximize()
{
	if (IsDlgButtonChecked(IDC_CHILD_MAXIMIZE))
		GetDlgItem(IDC_CHILD_MINIMIZE)->EnableWindow(FALSE);
	else
		GetDlgItem(IDC_CHILD_MINIMIZE)->EnableWindow(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// CDocStringsDlg dialog

CDocStringsDlg::CDocStringsDlg()
	: CDlgTab(CDocStringsDlg::IDD, IDS_DOC_STRINGS)
{
	m_nCurrLang = 0;
	m_nIDHelp = CDocStringsDlg::IDD;
	//{{AFX_DATA_INIT(CDocStringsDlg)
	//}}AFX_DATA_INIT
}

void CDocStringsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDocStringsDlg)
	//}}AFX_DATA_MAP
	DDX_Text(pDX, IDC_DOC_TYPE, m_strDocTag);
	m_strDocTag.ReleaseBuffer();
	DDV_SymbolCanBeginWithNumber(pDX, m_strDocTag);
	DDV_MaxChars(pDX, m_strDocTag, MAX_TAG);
	
	DDX_Text(pDX, IDC_DOC_EXT, m_strDocFileExt);
	m_strDocFileExt.ReleaseBuffer();
	if (!m_strDocFileExt.IsEmpty())
	{
		DDV_FileName(pDX, m_strDocFileExt, NULL);
	}
	
	DDX_Text(pDX, IDC_FILE_NEW, m_strDocFileNew);
	m_strDocFileNew.ReleaseBuffer();
	DDV_MaxChars(pDX, m_strDocFileNew, MAX_OLE_SHORT);
	
	DDX_Text(pDX, IDC_FILTER, m_strDocFilter);
	m_strDocFilter.ReleaseBuffer();
	DDV_MaxChars(pDX, m_strDocFilter, MAX_FILTER);
	
	DDX_Text(pDX, IDC_REG_ID, m_strDocRegID);
	m_strDocRegID.ReleaseBuffer();
	DDV_ProgID(pDX, m_strDocRegID);
	DDV_MaxChars(pDX, m_strDocRegID, MAX_PROGID);
	
	DDX_Text(pDX, IDC_REG_NAME, m_strDocRegName);
	m_strDocRegName.ReleaseBuffer();
	DDV_MaxChars(pDX, m_strDocRegName, MAX_LONGNAME);

	DDX_Text(pDX, IDC_APP_TITLE, m_strTitle);
	m_strTitle.ReleaseBuffer();
	DDV_Title(pDX, m_strTitle);
}

BEGIN_MESSAGE_MAP(CDocStringsDlg, CDlgTab)
	//{{AFX_MSG_MAP(CDocStringsDlg)
	ON_EN_CHANGE(IDC_DOC_TYPE, OnChangeDocType)
	ON_EN_CHANGE(IDC_DOC_EXT, OnChangeDocExt)
	ON_EN_CHANGE(IDC_FILE_NEW, OnChangeFileNew)
	ON_EN_CHANGE(IDC_FILTER, OnChangeFilter)
	ON_EN_CHANGE(IDC_REG_ID, OnChangeRegId)
	ON_EN_CHANGE(IDC_REG_NAME, OnChangeRegName)
	//}}AFX_MSG_MAP
	// FUTURE: Multiple langs:
	//ON_CBN_SELCHANGE(IDC_LANG_COMBO, OnSelchangeLangCombo)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDocStringsDlg message handlers

BOOL CDocStringsDlg::OnInitDialog()
{
	CDlgTab::OnInitDialog();

	// Fill in lang combo box
	// FUTURE: Multiple langs:
	/*CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_LANG_COMBO);
	ASSERT_VALID(pCombo);
	pCombo->SetRedraw(FALSE);
	int nSize = langDlls.GetSize();
	for (int i = 0; i < nSize && !langDlls.m_astrNameLang[i].IsEmpty(); i++)
		pCombo->AddString(langDlls.m_astrNameLang[i]);
	pCombo->SetRedraw(TRUE);
	pCombo->SetCurSel(m_nCurrLang);*/
	GetDlgItem(IDC_LANG_COMBO)->SetWindowText(langDlls.m_astrNameLang[0]);

	// Display the current (first) language's strings
	DisplayCurrLang();
	return TRUE;
}

BOOL CDocStringsDlg::ValidateTab()
{
	return ValidateCurrLang();
}

// FUTURE: Multiple Langs:
/*void CDocStringsDlg::OnSelchangeLangCombo() 
{
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_LANG_COMBO);
	ASSERT_VALID(pCombo);

	int nNewSel = pCombo->GetCurSel();

	if (nNewSel == m_nCurrLang)
		// When this fcn calls SetCurSel, this will be the case, and
		//  don't want to recurse!
		return;

	if (!ValidateCurrLang())
	{
		// Data not validated correctly.  Restore previous combo selection
		pCombo->SetCurSel(m_nCurrLang);
		return;
	}

	// Data validated OK, so change to new lang
	m_nCurrLang = nNewSel;
	DisplayCurrLang();
}*/

BOOL CDocStringsDlg::ValidateCurrLang()
{
	// Do validation for all fields
	if (!UpdateData(TRUE))
		return FALSE;

	// Record nonlocalized strings
	projOptions.m_names.strDocFileExt = m_strDocFileExt;
	projOptions.m_names.strDocRegID = m_strDocRegID;

	// Record localized strings
	langDlls.m_astrTitle[m_nCurrLang] = m_strTitle;
	langDlls.m_astrDocTag[m_nCurrLang] = m_strDocTag;
	langDlls.m_astrDocFileNew[m_nCurrLang] = m_strDocFileNew;
	langDlls.m_astrDocFilter[m_nCurrLang] = m_strDocFilter;
	langDlls.m_astrDocRegName[m_nCurrLang] = m_strDocRegName;

	return TRUE;
}

void CDocStringsDlg::DisplayCurrLang()
{
	// Unlocalized strings
	m_strDocFileExt = projOptions.m_names.strDocFileExt;
	m_strDocRegID = projOptions.m_names.strDocRegID;

	// Localized strings
	m_strTitle = langDlls.m_astrTitle[m_nCurrLang];
	m_strDocTag = langDlls.m_astrDocTag[m_nCurrLang];
	m_strDocFileNew = langDlls.m_astrDocFileNew[m_nCurrLang];
	m_strDocFilter = langDlls.m_astrDocFilter[m_nCurrLang];
	m_strDocRegName = langDlls.m_astrDocRegName[m_nCurrLang];

	UpdateData(FALSE);
}

void CDocStringsDlg::CommitTab()
{
	ValidateTab();
}

void CDocStringsDlg::UpdateDocFields()
{
	if (m_strDocFileExt.Left(1) == ".")
		m_strDocFileExt = m_strDocFileExt.Right(m_strDocFileExt.GetLength()-1);

	// Special case: update Filter for ALL langs, since it tracks the extension,
	//  which is constant over all langs
	int nSize = langDlls.GetSize();
	for (int i = 0; i < nSize && langDlls.IsValidEntry(i); i++)
	{
		if (langDlls.m_abUpdateFilter[i])
		{
			if (m_strDocFileExt.IsEmpty() || langDlls.m_astrDocTag[i].IsEmpty())
				langDlls.m_astrDocFilter[i].Empty();
			else
			{
				if (langDlls.m_abFilesAfter[i])
					langDlls.m_astrDocFilter[i] = langDlls.m_astrDocTag[i] + " "
						+ langDlls.m_astrFiles[i];
				else
					langDlls.m_astrDocFilter[i] = langDlls.m_astrFiles[i] + " "
						+ langDlls.m_astrDocTag[i];
				langDlls.m_astrDocFilter[i] += " (*." + m_strDocFileExt + ")";
			}
			if (i == m_nCurrLang)
				m_strDocFilter = langDlls.m_astrDocFilter[i];
		}
	}

	if (m_strDocTag == "")
	{
		if (langDlls.m_abUpdateFileNew[m_nCurrLang])
			m_strDocFileNew = "";
		if (projOptions.m_bUpdateRegID)
			m_strDocRegID = "";
		if (langDlls.m_abUpdateRegName[m_nCurrLang])
			m_strDocRegName = "";
	}
	else
	{
		if (langDlls.m_abUpdateFileNew[m_nCurrLang])
			m_strDocFileNew = m_strDocTag;
		if (langDlls.m_abUpdateRegName[m_nCurrLang])
			m_strDocRegName = m_strDocTag + " Document";
	}
}

void CDocStringsDlg::OnChangeDocType()
{
	// Read doc tag field
	GetDlgItem(IDC_DOC_TYPE)->GetWindowText(m_strDocTag);
	m_strDocTag.ReleaseBuffer();

	// Update other fields accordingly
	UpdateDocFields();
	UpdateData(FALSE);
}

void CDocStringsDlg::OnChangeDocExt()
{
	// Read file extension field
	GetDlgItem(IDC_DOC_EXT)->GetWindowText(m_strDocFileExt);
	m_strDocFileExt.ReleaseBuffer();

	// Update other fields accordingly
	UpdateDocFields();
	UpdateData(FALSE);
}

// Four functions below: If user alters these fields, cease their
//  tracking.  Also, read the value so a future UpdateData(FALSE)
//  works as expected.

void CDocStringsDlg::OnChangeFileNew()
{
	langDlls.m_abUpdateFileNew[m_nCurrLang] = FALSE;
	GetDlgItem(IDC_FILE_NEW)->GetWindowText(m_strDocFileNew);
	m_strDocFileNew.ReleaseBuffer();
}

void CDocStringsDlg::OnChangeFilter()
{
	langDlls.m_abUpdateFilter[m_nCurrLang] = FALSE;
	GetDlgItem(IDC_FILTER)->GetWindowText(m_strDocFilter);
	m_strDocFilter.ReleaseBuffer();
}

void CDocStringsDlg::OnChangeRegId()
{
	projOptions.m_bUpdateRegID = FALSE;
	GetDlgItem(IDC_REG_ID)->GetWindowText(m_strDocRegID);
	m_strDocRegID.ReleaseBuffer();
}

void CDocStringsDlg::OnChangeRegName()
{
	langDlls.m_abUpdateRegName[m_nCurrLang] = FALSE;
	GetDlgItem(IDC_REG_NAME)->GetWindowText(m_strDocRegName);
	m_strDocRegName.ReleaseBuffer();
}


/////////////////////////////////////////////////////////////////////////////
// CMacDlg dialog


CMacDlg::CMacDlg()
	: CDlgTab(CMacDlg::IDD, IDS_MAC)
{
	m_nIDHelp = CMacDlg::IDD;
	//{{AFX_DATA_INIT(CMacDlg)
	//}}AFX_DATA_INIT
	m_strDocFileCreator = projOptions.m_names.strDocFileCreator;
	m_strDocFileType = projOptions.m_names.strDocFileType;
	m_strDocFilter = projOptions.m_names.strMacFilter;
	m_bTrackFilter = TRUE;
}

void CMacDlg::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMacDlg)
	//}}AFX_DATA_MAP
	DDX_Text(pDX, IDC_DOC_CREATOR, m_strDocFileCreator);
	DDV_MaxChars(pDX, m_strDocFileCreator, 4);
	DDX_Text(pDX, IDC_FILE_TYPE, m_strDocFileType);
	DDV_MaxChars(pDX, m_strDocFileType, 4);
	DDX_Text(pDX, IDC_FILTER, m_strDocFilter);
}

BEGIN_MESSAGE_MAP(CMacDlg, CDlgTab)
	//{{AFX_MSG_MAP(CMacDlg)
	ON_EN_CHANGE(IDC_FILE_TYPE, OnChangeFileType)
	ON_EN_CHANGE(IDC_FILTER, OnChangeFilter)
	ON_EN_CHANGE(IDC_DOC_CREATOR, OnChangeDocCreator)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMacDlg message handlers

BOOL CMacDlg::ValidateTab()
{
	if (!UpdateData(TRUE))
		return FALSE;
	
	projOptions.m_names.strDocFileCreator = m_strDocFileCreator;
	projOptions.m_names.strDocFileType = m_strDocFileType;
	projOptions.m_names.strMacFilter = m_strDocFilter;
	projOptions.m_names.strDocFileCreator.MakeUpper();
	projOptions.m_names.strDocFileType.MakeUpper();

	return TRUE;
}

void CMacDlg::CommitTab()
{
	ValidateTab();
}

void CMacDlg::OnChangeFileType() 
{
	if (!m_bTrackFilter)
		return;
	
	GetDlgItem(IDC_FILE_TYPE)->GetWindowText(m_strDocFileType);
	m_strDocFileType.ReleaseBuffer();
	
	// TODO: Use langDlls
/*	if (projOptions.m_bFilesAfter)
		m_strDocFilter = m_strDocFileType + " "
			+ projOptions.m_strFiles;
	else
		m_strDocFilter = projOptions.m_strFiles + " "
			+ m_strDocFileType;*/

	UpdateData(FALSE);
}

void CMacDlg::OnChangeFilter() 
{
	m_bTrackFilter = FALSE;	
	GetDlgItem(IDC_FILTER)->GetWindowText(m_strDocFilter);
}

void CMacDlg::OnChangeDocCreator() 
{
	GetDlgItem(IDC_DOC_CREATOR)->GetWindowText(m_strDocFileCreator);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\xboxhelp.h ===
#include "keywords.h"
#include <htmlhelp.h>

#ifndef _XBOXHELP_H_
#define _XBOXHELP_H_

BOOL DoXboxHelp(LPCTSTR lpszKeyword);

#endif  // _XBOXHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\awiface.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "symbols.h"
#include "lang.h"
#include "ddxddv.h"
#include "platname.h"
#include "utilbld_.h"
#include "awiface.h"
#ifndef VS_PACKAGE
#include <utilctrl.h>
#endif	// VS_PACKAGE

#include <initguid.h>
#include <bldguid.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef VS_PACKAGE
	static const TCHAR* szModuleSubdir1 = "\\";
#else
	#ifdef _DEBUG
		static const TCHAR* szModuleSubdir1 = "\\ided\\";
	#else
		static const TCHAR* szModuleSubdir1 = "\\ide\\";
	#endif //_DEBUG
#endif //VS_PACKAGE

#ifdef _DEBUG
static char BASED_CODE szCtlWiz[] = "mfctlwzd.awx";
#else
static char BASED_CODE szCtlWiz[] = "mfctlwz.awx";
#endif //_DEBUG

static const TCHAR* szModuleSubdir2 = "Template";
static char BASED_CODE szMacSubsection[] = "\\Platforms\\Macintosh";
static char BASED_CODE szMacOleKey[] = "OLE present";
static char BASED_CODE szMacODBCKey[] = "ODBC present";
static char BASED_CODE szMacWOSAKey[] = "WOSA present";

//extern char BASED_CODE szMSVCSection[];

// This maps the extension title to the DLL-name.  It's here to remember what
//  extensions AppWizard has inserted into CPromtpDlg
static CMapStringToString g_CustomAppWizards;

extern CPlatNameConvert g_PlatNameConvert;

// This function is defined in miscdlgs.cpp, and is used in OnPromptDlgOK()
BOOL ScanForLangDll();

//  Defined in mfcappwz.cpp
BOOL DoesFileExist(const char* szFile);

CAppWizIFace g_AppWizIFace;	// one 'n' only appwiz interface
//CAppWizIFace AFX_EXT_DATA* g_pAppWizIFace;	// exported pointer to 'this'

extern HINSTANCE GetResourceHandle();

extern "C" CAppWizIFace* WINAPI GetAppWizIFace()
{
	return &g_AppWizIFace;
}


BOOL IsReadOnly(const char* szFile)
{
	struct _stat st;
	if (_stat(szFile, &st) == 0)
		return (!(st.st_mode & _S_IWRITE));
	else
		return FALSE;
}

BOOL CheckIsReadOnly(const char* szFile)
{
	CString strPrompt;
	AfxFormatString1(strPrompt, IDP_FILE_IS_READONLY, szFile);
	while (IsReadOnly(szFile))
	{
		if (AfxMessageBox(strPrompt, MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
			return FALSE;
	}
	return TRUE;
}


/*BOOL RegMacSectionKeyExists(TCHAR* szKey)
{
	CString strSection = szMSVCSection;
	strSection += szMacSubsection;
	HKEY hkey;
	if (RegOpenKeyEx(HKEY_CURRENT_USER, strSection, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
		return FALSE;

	BOOL bReturn = (RegQueryValueEx(hkey, szKey, NULL, NULL, NULL, NULL)
						== ERROR_SUCCESS);

	RegCloseKey(hkey);
	return bReturn;
}*/


BOOL IsMacOle()
{
	/*static BOOL bFirstTime = TRUE;
	static BOOL bIsMacOle = FALSE;
	
	if (bFirstTime)
	{
		bFirstTime = FALSE;
		bIsMacOle = RegMacSectionKeyExists(szMacOleKey);
	}
	return bIsMacOle;*/
	return TRUE;
}

BOOL IsMacOcx()
{
	return TRUE;
}

BOOL IsMacODBC()
{
	/*static BOOL bFirstTime = TRUE;
	static BOOL bIsMacODBC = FALSE;
	
	if (bFirstTime)
	{
		bFirstTime = FALSE;
		bIsMacODBC = RegMacSectionKeyExists(szMacODBCKey);
	}
	return bIsMacODBC;*/
	return TRUE;
}



BOOL IsMacWOSA()
{
	/*static BOOL bFirstTime = TRUE;
	static BOOL bIsMacWOSA = FALSE;
	
	if (bFirstTime)
	{
		bFirstTime = FALSE;
		bIsMacWOSA = RegMacSectionKeyExists(szMacWOSAKey);
	}
	return bIsMacWOSA;*/
	return FALSE;
}

// If the project name is different from before, then we re-run FillDefaultNames.
void UpdateNamesIfNecessary(NAMES& names, const char* pszRoot)
{
	if (CreateSymbol("root") == pszRoot)
		return;
		
	names.m_bUpdateNames = TRUE;
	SetSymbol("ROOT", Upper(pszRoot));
	SetSymbol("root", pszRoot);
	SetSymbol("Root", pszRoot);

	// need an OEM version of root for bat files...
	CString strRootOEM = pszRoot;
	strRootOEM.AnsiToOem();
	SetSymbol("root_oem", strRootOEM);

	FillDefaultNames(names, pszRoot);
}


/////////////////////////////////////////////////////////////////////////////
// Functions to find & apply USER EXTENSIONS

// Given a filename, this function determines whether it's a valid user extension
BOOL IsUserExtension(const TCHAR* tszFileName)
{
	return TRUE;
}



BOOL GetExtensionDescription(CString& rstrDescription, const CString& strExtension, HICON& hIcon)
{
	UINT dwDummySize;
	LPVOID lpBuffer;
	DWORD dwHandle;

	// NT can be an idiot sometimes; versioninfo APIs won't take a const string
	CString strCopyExtension = strExtension;

	DWORD dwSize = GetFileVersionInfoSize((LPTSTR) (LPCTSTR) strCopyExtension, &dwHandle);
	if (dwSize == 0)
		return FALSE;
	CString strBuffer;
	LPTSTR szBuf = strBuffer.GetBuffer(dwSize);
	if (!GetFileVersionInfo((LPTSTR) (LPCTSTR) strCopyExtension, dwHandle, dwSize, szBuf)
		|| !VerQueryValue(szBuf, "\\VarFileInfo\\Translation", &lpBuffer, &dwDummySize)
		|| dwSize == 0 || dwDummySize == 0)
	{
		strBuffer.ReleaseBuffer();
		return FALSE;
	}

	// We've successfully read the versioninfo stuff.  Now translate the
	//  the langid into a localized string of the language name

	char szName[512];
	wsprintf(szName, "\\StringFileInfo\\%04x%04x\\ProductName",
		*((WORD*)lpBuffer), *((WORD*)lpBuffer+1));
	if (!VerQueryValue(szBuf, szName, &lpBuffer, &dwDummySize))
	{
		strBuffer.ReleaseBuffer();
		return FALSE;
	}
	
	rstrDescription = (char*) lpBuffer;
	strBuffer.ReleaseBuffer();

	hIcon = ExtractIcon(GetResourceHandle(), strCopyExtension, 0);

	return TRUE;
}

// All TARGET_ macros should be set by the time this is called.
void FillTruncatedDefaultNames(LPCTSTR pszRoot)
{
	CString filebase = pszRoot;

	// Now set all filenames that must be abbreviated
	if (DoesSymbolExist("TARGET_MAC"))
	{
		// Because hc35 doesn't accept long file names, everyone has to suffer
		//  when we target the MAC for a help app.  In particular, the .hm
		//  file can't exceed 8.3
		filebase = filebase.Left(8);
	}
	SetSymbol("HM_FILE", filebase);
	CString filebaseOEM = filebase;

	// batch files use the OEM character set.  Everything else uses the ANSI character
	// set.  If we've got upper ASCII, there is a difference between the two.
	filebaseOEM.AnsiToOem();
	SetSymbol("HM_FILE_OEM", filebaseOEM);
	if (filebase.Compare(filebaseOEM))	
		SetSymbol("HM_NOTE", "1");	// we have upper ASCII, so need a note about why all the
									// file names looks wierd in makehelp.bat
	else
		RemoveSymbol("HM_NOTE");

	filebase = filebase.Left(5);
	SetSymbol("mac_hpj", filebase + "Mac");
}

// Helper used in RecordPlatforms.  Takes longname of single platform, and updates
//  g_PlatformsSelected as it sets the appropriate symbols.
void SetAppWizSymbolsForPlatform(LPCTSTR szPlatformLong)
{			
	if (szPlatformLong == NULL)
		// This happens if an extension supports "no" platforms.  In that case,
		//  we default to supporting Win32.
		szPlatformLong = szPlatforms[WIN];

	CString strValue;
	SetSymbol(szPlatformLong, "1");	// Set symbol w/ platform name

	if (g_PlatformsSelected.Lookup(szPlatformLong, strValue))
	{
		// This platform is stored in our g_PlatformsSelected map.
		if (strValue != "1")
		{
			// There's an abbreviation stored for it ("TARGET_68KMAC",
			//  etc.) so set the abbreviation as well
			SetSymbol(strValue, "1");
		}
	}
	else
	{
		// The platform wasn't stored, so we must store it now.
		//  That way, next time around, we'll know to remove its
		//  corresponding symbol.
		g_PlatformsSelected[szPlatformLong] = "1";
	}
}

// This is called from CPromptDlg's OnOK.  It takes a look at what
//  the user checked in the platforms list, and sets the appropriate symbols.
//  g_PlatformsSelected is used & updated as appropriate
void RecordPlatforms(int* pnPlatforms)
{
	// First, remove platform symbols previously checked.  We use
	//  g_PlatformsSelected as our guide
	POSITION pos = g_PlatformsSelected.GetStartPosition();
	while (pos != NULL)
	{
		CString strKey, strValue;
		g_PlatformsSelected.GetNextAssoc(pos, strKey, strValue);
		RemoveSymbol(strKey);
		RemoveSymbol(strValue);
	}

	// Now, go through the checklist, and set the checked platforms, using
	//  g_PlatformsSelected as our guide, and updating it along the way
	int nCount = g_strlPlatformsDisplayed.GetCount();
	ASSERT (nCount <= MAX_PLATFORMS);
	if (nCount == 0)
	{
		// We have an extension that displayed no platforms
		SetAppWizSymbolsForPlatform(NULL);
	}
	else
	{
		// There exist platforms; thus we will have made sure something was selected
		POSITION pos = g_strlPlatformsDisplayed.GetHeadPosition();
		int i=0;
		while (pos != NULL)
		{
			CString strPlatform = g_strlPlatformsDisplayed.GetNext(pos);
			// We only give a hoot if the user checked the platform
			if (pnPlatforms[i++] == 1)
			{
				g_PlatNameConvert.UItoLong(strPlatform, strPlatform);
				SetAppWizSymbolsForPlatform(strPlatform);
			}
		}
	}

	// If either mac is selected, set TARGET_MAC.
	if (DoesSymbolExist("TARGET_68KMAC") || DoesSymbolExist("TARGET_POWERMAC"))
		SetSymbol("TARGET_MAC", "1");
	else
		RemoveSymbol("TARGET_MAC");

	// Set name macros which depend on target
	FillTruncatedDefaultNames(projOptions.m_strProj);
}

// This prevents naming conflicts caused by project names such "xxxxxdoc"
//  The check is extra conservative.  We don't know what appwiz options
//  the user will choose, so we don't know what files may conflict.  So,
//  we check ALL possible conflicts.  If, instead, we waited until we DO know,
//  that would cause the warning to be displayed just before creation,
//  which is pretty late in the game and darned annoying for the user.
static BOOL InterfereWithDefaults(const char* szFile, BOOL bMacSelected, BOOL bExtwiz)
{
	CString strFile = szFile;
	strFile.MakeLower();
	int nLength = strFile.GetLength();
 	CString strThree = strFile.Right(3);
	
	return (strFile == "mainfrm"
		|| strFile == "childfrm"
		|| strFile == "ipframe"
		|| strFile == "cntritem"
		|| strFile == "srvritem"
		|| strFile == "stdafx"
		|| strFile == "resource"
		|| (bMacSelected && nLength == 8 && strThree == "mac")
		|| (bExtwiz && (strFile == "custom" || strFile == "debug" || strFile == "chooser")));
}
static BOOL InterfereWithDefaultsOCX(LPCTSTR szFile)
{
	CString strFile = szFile;
	strFile.MakeLower();
	int nLength = strFile.GetLength();
	
	return (strFile == "stdafx"
		|| strFile == "resource");
}



// GLOBAL APPWIZ APIS

#ifdef VS_PACKAGE
void CAppWizIFace::InitAppWiz(HWND hWnd, IServiceProvider *pSp)
{
	ReleasePtrs();

	ASSERT(pSp);

	m_pSp = pSp ;
	m_pSp->AddRef() ;

	VERIFY(SUCCEEDED(pSp->QueryService(SID_SBuildService, IID_IBuildWizardX, (LPVOID *) &m_pBldWizX)));
	VERIFY(SUCCEEDED(pSp->QueryService(SID_SBuildService, IID_IBuildPlatformsX, (LPVOID *) &m_pBldPlatsX)));

	theDLL.InitAppWiz(hWnd);
}
#else
void CAppWizIFace::InitAppWiz(HWND hWnd)
{
	theDLL.InitAppWiz(hWnd);
}
#endif

int CAppWizIFace::RunAppWizSteps()
{
	return theDLL.RunAppWizSteps();
}

// This is implemented in mfcappwz.cpp
void CreateProject(HBUILDER hBld);
extern AppWizTermStatus g_TermStatus;

void CAppWizIFace::AddAppWizTargets(HBUILDER hBld)
{
    pTermStatus = &g_TermStatus;
    do
    {
        CreateProject(hBld);
        pTermStatus = pTermStatus->nextAppWizTermStatus;
    } while (pTermStatus);  
}

BOOL CAppWizIFace::GetAppWizDialog( CString &strDialog )
{
	GetSymbol("APPWIZ_INITIAL_DIALOG", strDialog );
	return !strDialog.IsEmpty();
}

void CAppWizIFace::ExitAppWiz()
{
	theDLL.ExitAppWiz();
    
    // delete all the newly added stuff for multiple projects
    pTermStatus = g_TermStatus.nextAppWizTermStatus;
    while (pTermStatus) {
        AppWizTermStatus *pPrevAppWizTermStatus;
        pPrevAppWizTermStatus = pTermStatus;
        pTermStatus = pTermStatus->nextAppWizTermStatus;
        delete (pPrevAppWizTermStatus);
    }
    memset(g_TermStatus.szFullName, '\0', MAX_PATH);

#ifdef VS_PACKAGE

	ReleasePtrs() ;

#endif
}


#ifndef VS_PACKAGE
// CPROMPTDLG HOOKS

int CAppWizIFace::AddAppWizProjectTypesAtTop(CListBox* pList)
{
	CString strPTEntry;
	strPTEntry.LoadString(IDS_APPWIZ_EXE);
	pList->InsertString(0, strPTEntry);
	pList->SetItemData(0, (DWORD)LoadIcon(GetResourceHandle(), MAKEINTRESOURCE(IDR_MFCAPPWIZARD)));

	strPTEntry.LoadString(IDS_APPWIZ_DLL);
	pList->InsertString(1, strPTEntry);
	pList->SetItemData(1, (DWORD)LoadIcon(GetResourceHandle(), MAKEINTRESOURCE(IDR_MFCAPPWIZARDDLL)));

	// If we can find ControlWizard, then add the ControlWizard choice
	//  as well.
	CString strCtlWizFull = (theDLL.m_strAppwizDir + szModuleSubdir1) + szCtlWiz;

	DWORD dwCtlWizAttr = GetFileAttributes(strCtlWizFull);
	if (dwCtlWizAttr != 0xffffffff && !(dwCtlWizAttr & FILE_ATTRIBUTE_DIRECTORY))
	{
		strPTEntry.LoadString(IDS_CTLWIZ_TITLE);
		pList->InsertString(2, strPTEntry);
		//pList->SetItemData(2, (DWORD)LoadIcon(GetResourceHandle(), MAKEINTRESOURCE(IDR_OLECONTROL)));
		pList->SetItemData(2, (DWORD)ExtractIcon(GetResourceHandle(), strCtlWizFull, 0));
		return NUM_PROJECTS;
	}
	else
		return NUM_PROJECTS-1;
}

int CAppWizIFace::AddAppWizProjectTypesAtTop(CProjTypeList* pList)
{
	CString strPTEntry;
	strPTEntry.LoadString(IDS_APPWIZ_EXE);
	pList->InsertString(0, strPTEntry);
	pList->SetItemDataPtr(0, (void *)LoadIcon(GetResourceHandle(), MAKEINTRESOURCE(IDR_MFCAPPWIZARD)));

	strPTEntry.LoadString(IDS_APPWIZ_DLL);
	pList->InsertString(1, strPTEntry);
	pList->SetItemDataPtr(1, (void *)LoadIcon(GetResourceHandle(), MAKEINTRESOURCE(IDR_MFCAPPWIZARDDLL)));

	// If we can find ControlWizard, then add the ControlWizard choice
	//  as well.
	CString strCtlWizFull = (theDLL.m_strAppwizDir + szModuleSubdir1) + szCtlWiz;
	DWORD dwCtlWizAttr = GetFileAttributes(strCtlWizFull);
	if (dwCtlWizAttr != 0xffffffff && !(dwCtlWizAttr & FILE_ATTRIBUTE_DIRECTORY))
	{
		strPTEntry.LoadString(IDS_CTLWIZ_TITLE);
		pList->InsertString(2, strPTEntry);
		pList->SetItemDataPtr(2, (void *)ExtractIcon(GetResourceHandle(), strCtlWizFull, 0));
		return NUM_PROJECTS;
	}
	else
		return NUM_PROJECTS-1;
}

static int AddCAWsFromHandle(CListBox* pList, HANDLE hSearch, WIN32_FIND_DATA& ffd,
	CString& strDir)
{
	int nReturn = 0;
	ASSERT(hSearch != INVALID_HANDLE_VALUE);
	do
	{
		CString strDescription;
		CString strDllName = strDir + ffd.cFileName;
		if (ffd.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY
			&& IsUserExtension(strDllName))
		{
			HICON hIcon = NULL;
			if (GetExtensionDescription(strDescription, strDllName, hIcon))
			{
				// TODO: Take this if out once mfcctlwz.dll is dropped into bin
				if (_tcsicmp(ffd.cFileName, szCtlWiz))
				{
					int nItem = pList->AddString(strDescription);
					pList->SetItemData(nItem, (DWORD)hIcon);

					nReturn++;
					g_CustomAppWizards[strDescription] = strDllName;
				}
				else
					g_CustomAppWizards[szCtlWiz] = strDllName;
			}
			else
			{
				int nItem = pList->AddString(ffd.cFileName);
				pList->SetItemData(nItem, (DWORD)hIcon);
				nReturn++;
				g_CustomAppWizards[ffd.cFileName] = strDllName;
			}
		}
	}
	while (::FindNextFile(hSearch, &ffd));
	return nReturn;
}

static int AddCAWsFromHandle(CProjTypeList* pList, HANDLE hSearch, WIN32_FIND_DATA& ffd,
	CString& strDir)
{
	int nReturn = 0;
	ASSERT(hSearch != INVALID_HANDLE_VALUE);
	do
	{
		CString strDescription;
		CString strDllName = strDir + ffd.cFileName;
		if (ffd.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY
			&& IsUserExtension(strDllName))
		{
			HICON hIcon = NULL;
			if (GetExtensionDescription(strDescription, strDllName, hIcon))
			{
				// TODO: Take this if out once mfcctlwz.dll is dropped into bin
				if (_tcsicmp(ffd.cFileName, szCtlWiz))
				{
					int nItem = pList->AddString(strDescription);
					pList->SetItemDataPtr(nItem, (void *)hIcon);

					nReturn++;
					g_CustomAppWizards[strDescription] = strDllName;
				}
				else
					g_CustomAppWizards[szCtlWiz] = strDllName;
			}
			else
			{
				int nItem = pList->AddString(ffd.cFileName);
				pList->SetItemDataPtr(nItem, (void *)hIcon);
				nReturn++;
				g_CustomAppWizards[ffd.cFileName] = strDllName;
			}
		}
	}
	while (::FindNextFile(hSearch, &ffd));
	return nReturn;
}

// This takes the projtype combo box, and fills it with any custom appwiz's it finds.
//  It returns whether it found any custom AppWiz's.
int CAppWizIFace::AddCustomAppWizProjectTypesAtBottom(CListBox* pList)
{
	int nReturn = 0;			// Counts number of custom appwizzes we put in the combo
	g_CustomAppWizards.RemoveAll();
	WIN32_FIND_DATA ffd;
	CString strDir;

	// Search \msvc30\bin\ide(d) dir for setup-installed CAWs
	strDir = theDLL.m_strAppwizDir + szModuleSubdir1;
	HANDLE hSearch = ::FindFirstFile(strDir + "*.AWX", &ffd);
	if (hSearch	!= INVALID_HANDLE_VALUE)
		nReturn += AddCAWsFromHandle(pList, hSearch, ffd, strDir);
	::FindClose(hSearch);

	// Search \msvc30\Template dir for user-created CAWs
	CDir dir;
	dir.CreateFromString(theDLL.m_strAppwizDir);		// \msvc30\bin
	dir.RemoveLastSubdirName();							// \msvc30
	dir.AppendSubdirName(szModuleSubdir2);				// \msvc30\Template
	strDir = (LPCTSTR) dir;
	if (*_tcsdec((LPCTSTR) strDir, (LPCTSTR) strDir + strDir.GetLength()) != '\\')
		strDir += '\\';
	hSearch = ::FindFirstFile(strDir + "*.AWX", &ffd);
	if (hSearch	!= INVALID_HANDLE_VALUE)
		nReturn += AddCAWsFromHandle(pList, hSearch, ffd, strDir);
	::FindClose(hSearch);
	
	return nReturn;
}


// Same but using a CProjTypeIconList* 
int CAppWizIFace::AddCustomAppWizProjectTypesAtBottom(CProjTypeList* pList)
{
	int nReturn = 0;			// Counts number of custom appwizzes we put in the combo
	g_CustomAppWizards.RemoveAll();
	WIN32_FIND_DATA ffd;
	CString strDir;

	// Search \msvc30\bin\ide(d) dir for setup-installed CAWs
	strDir = theDLL.m_strAppwizDir + szModuleSubdir1;
	HANDLE hSearch = ::FindFirstFile(strDir + "*.AWX", &ffd);
	if (hSearch	!= INVALID_HANDLE_VALUE)
		nReturn += AddCAWsFromHandle(pList, hSearch, ffd, strDir);
	::FindClose(hSearch);

	// Search \msvc30\Template dir for user-created CAWs
	CDir dir;
	dir.CreateFromString(theDLL.m_strAppwizDir);		// \msvc30\bin
	dir.RemoveLastSubdirName();							// \msvc30
	dir.AppendSubdirName(szModuleSubdir2);				// \msvc30\Template
	strDir = (LPCTSTR) dir;
	if (*_tcsdec((LPCTSTR) strDir, (LPCTSTR) strDir + strDir.GetLength()) != '\\')
		strDir += '\\';
	hSearch = ::FindFirstFile(strDir + "*.AWX", &ffd);
	if (hSearch	!= INVALID_HANDLE_VALUE)
		nReturn += AddCAWsFromHandle(pList, hSearch, ffd, strDir);
	::FindClose(hSearch);
	
	return nReturn;
}

void CAppWizIFace::FillPlatformsListFromCustomAppWizType(LPCTSTR szExtName, CCheckList* pChklstPlatforms)
{
	// Update the list with what the extension allows us to.  First,
	//  load the extension.
	
	// Start by converting description (szExtName) to the DLL name
	CString strDllName;
	VERIFY(g_CustomAppWizards.Lookup(szExtName, strDllName));

	// Then load 'er up!
	if (!projOptions.m_UserExtension.Attach(strDllName))
		AfxThrowUserException();
	// Special case: if ControlWizard, use "MFC AppWizard" as title; otherwise, use
	//  what the awx gave us.
	if (!_tcsicmp(szExtName, szCtlWiz))
	{
		projOptions.m_UserExtension.m_strExtensionTitle.LoadString(IDS_CTLWIZ_TITLE);
		projOptions.m_UserExtension.m_bCtlWiz = TRUE;
	}
	else
		projOptions.m_UserExtension.m_strExtensionTitle = szExtName;

	// Next, get all available platforms
	LPBUILDPLATFORMS pPlatforms;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&pPlatforms)));
	const CStringList* pPlatformsLong;
	pPlatforms->GetAvailablePlatforms(&pPlatformsLong, NULL, FALSE);
	pPlatforms->Release();
	// Copy to a new list the extension can write to.  If this extension makes
	//  a DLL, be sure not to include the 68K Mac platform.
	BOOL bIsDLL = (DoesSymbolExist("PROJTYPE_DLL") || DoesSymbolExist("PROJTYPE_OCX"));
    BOOL bIsXbox = DoesSymbolExist("PROJTYPE_XBOX");
#if 0
    BOOL fIsJava = DoesSymbolExist("PROJTYPE_JAVA");
#else
	BOOL fIsJava = FALSE;
#endif
	CStringList PlatformsLongCopy;
    {
	    POSITION pos = pPlatformsLong->GetHeadPosition();
	    while (pos != NULL)
	    {
		    CString strPlatLong = pPlatformsLong->GetNext(pos);
		    if (bIsDLL && strPlatLong == szPlatforms[MAC])
			    continue;

            if (!fIsJava && strPlatLong == szPlatforms[JAVA])
                continue;

            if (!bIsXbox && strPlatLong == szPlatforms[XBOX])
                continue;

		    PlatformsLongCopy.AddTail(strPlatLong);
	    }
    }

	// Consult the extension
	GetAWX()->GetPlatforms(PlatformsLongCopy);

	// Now fill in checklist with what's left in PlatformsLongCopy
	//  (converted to UI names if possible).  If this extension makes
	//  a DLL, be sure not to include the 68K Mac platform.
	g_strlPlatformsDisplayed.RemoveAll();
	POSITION pos = PlatformsLongCopy.GetHeadPosition();
	while (pos != NULL)
	{
		CString strPlatLong, strPlatUI;
		strPlatLong = PlatformsLongCopy.GetNext(pos);

		// Don't allow 68K Mac with a DLL
		if (bIsDLL && strPlatLong == szPlatforms[MAC])
			continue;

		g_PlatNameConvert.LongToUI(strPlatLong, strPlatUI);
		int i = pChklstPlatforms->InsertString(-1, strPlatUI);
		g_strlPlatformsDisplayed.AddTail(strPlatUI);	// Remember what we store for later
	}
}

void CAppWizIFace::FillPlatformsListFromAppWizType(int nProjType, CCheckList* pChklstPlatforms)
{
	// Special case: project type 2 == ocx, which is really a custom appwiz.
	if (nProjType == 2)
	{
		FillPlatformsListFromCustomAppWizType(szCtlWiz, pChklstPlatforms);
		return;
	}

	// This is an appwiz project, so we'll fill the platforms
	//  checklist with what the IDE would have given us, had
	//  the project type been "Application" or "Dynamic Link Library".
	// This is done so that we check the correct msvc key for whether
	//  Mac is installed.  If appwiz just went and checked on its own,
	//  it wouldn't know what key to use (i.e., whether we're launched
	//  by a sniff test).  Also, this way, all platform strings are gotten
	//  from the IDE rather than being hard coded here.
	//  This is also necessary so that we can get the localized
	//  string for the platforms, rather than hardcoding our own
	//  English version here.
	// This requires knowledge of the project types passed to us, by the
	//  IDE.  If the order or names ever change, we must update
	//  these hard-coded numbers.

	// First, be sure we're using our own symbol table.  (Soon symbols like
	//  "TARGET_POWERMAC" will be set, and we need to make sure they're set
	//  in AppWizard's own dictionary, rather than some extension we're
	//  going to detach later on.)
	projOptions.m_UserExtension.Detach();

	// Remember target type for when we create it later on
	pTermStatus->nProjType = nProjType;


	g_strlPlatformsDisplayed.RemoveAll();

	LPBUILDPLATFORMS pPlatforms;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&pPlatforms)));
	const CStringList* pPlatformsUI;
	pPlatforms->GetAvailablePlatforms(&pPlatformsUI, strlProjTypes.GetAt(strlProjTypes.FindIndex(nProjType)), TRUE);
	const CStringList* pPlatformsLong;
	pPlatforms->GetAvailablePlatforms(&pPlatformsLong, strlProjTypes.GetAt(strlProjTypes.FindIndex(nProjType)), FALSE);
	pPlatforms->Release();

	POSITION posUI = pPlatformsUI->GetHeadPosition();
	POSITION posLong = pPlatformsLong->GetHeadPosition();
	while (posUI != NULL && posLong != NULL)
	{
		CString strUI = pPlatformsUI->GetNext(posUI);
		CString strLong = pPlatformsLong->GetNext(posLong);

		if (strLong == szPlatforms[WIN]
				// This is the Win32 platform-- used for exe or dll
			|| (strLong == szPlatforms[MAC] && nProjType == 0)
				// This is the Macintosh platform-- used only for exe
			|| (strLong == szPlatforms[POWERMAC]))
				// This is the PowerMac platform-- used for exe or dll
		{
			pChklstPlatforms->InsertString(-1, strUI);
			g_strlPlatformsDisplayed.AddTail(strUI);	// Remember what we store for later
		}
	}
}

void CAppWizIFace::FillPlatformsListFromCustomAppWizType(LPCTSTR szExtName, CStringArray* pChklstPlatforms)
{
	// Update the list with what the extension allows us to.  First,
	//  load the extension.
	
	// Start by converting description (szExtName) to the DLL name
	CString strDllName;
	VERIFY(g_CustomAppWizards.Lookup(szExtName, strDllName));

	// Then load 'er up!
	if (!projOptions.m_UserExtension.Attach(strDllName))
		AfxThrowUserException();
	// Special case: if ControlWizard, use "MFC AppWizard" as title; otherwise, use
	//  what the awx gave us.
	if (!_tcsicmp(szExtName, szCtlWiz))
	{
		projOptions.m_UserExtension.m_strExtensionTitle.LoadString(IDS_CTLWIZ_TITLE);
		projOptions.m_UserExtension.m_bCtlWiz = TRUE;
	}
	else
		projOptions.m_UserExtension.m_strExtensionTitle = szExtName;

	// Next, get all available platforms
	LPBUILDPLATFORMS pPlatforms;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&pPlatforms)));
	const CStringList* pPlatformsLong;
	pPlatforms->GetAvailablePlatforms(&pPlatformsLong, NULL, FALSE);
	pPlatforms->Release();
	// Copy to a new list the extension can write to.  If this extension makes
	//  a DLL, be sure not to include the 68K Mac platform.
	BOOL bIsDLL = (DoesSymbolExist("PROJTYPE_DLL") || DoesSymbolExist("PROJTYPE_OCX"));
    BOOL bIsXbox = DoesSymbolExist("PROJTYPE_XBOX");
#if 0
    BOOL fIsJava = DoesSymbolExist("PROJTYPE_JAVA");
#else
	BOOL fIsJava = FALSE;
#endif
	CStringList PlatformsLongCopy;
    {
	    POSITION pos = pPlatformsLong->GetHeadPosition();
	    while (pos != NULL)
	    {
		    CString strPlatLong = pPlatformsLong->GetNext(pos);
		    if (bIsDLL && strPlatLong == szPlatforms[MAC])
			    continue;

            if (!fIsJava && strPlatLong == szPlatforms[JAVA])
                continue;

            if (!bIsXbox && strPlatLong == szPlatforms[XBOX])
                continue;

		    PlatformsLongCopy.AddTail(strPlatLong);
	    }
    }

	// Consult the extension
	GetAWX()->GetPlatforms(PlatformsLongCopy);

	// Now fill in checklist with what's left in PlatformsLongCopy
	//  (converted to UI names if possible).  If this extension makes
	//  a DLL, be sure not to include the 68K Mac platform.
	g_strlPlatformsDisplayed.RemoveAll();
	POSITION pos = PlatformsLongCopy.GetHeadPosition();
	while (pos != NULL)
	{
		CString strPlatLong, strPlatUI;
		strPlatLong = PlatformsLongCopy.GetNext(pos);

		// Don't allow 68K Mac with a DLL
		if (bIsDLL && strPlatLong == szPlatforms[MAC])
			continue;

		g_PlatNameConvert.LongToUI(strPlatLong, strPlatUI);
		int i = pChklstPlatforms->Add(strPlatUI);
		g_strlPlatformsDisplayed.AddTail(strPlatUI);	// Remember what we store for later
	}
}

void CAppWizIFace::FillPlatformsListFromAppWizType(int nProjType, CStringArray* pChklstPlatforms)
{
	// Special case: project type 2 == ocx, which is really a custom appwiz.
	if (nProjType == 2)
	{
		FillPlatformsListFromCustomAppWizType(szCtlWiz, pChklstPlatforms);
		return;
	}

	// This is an appwiz project, so we'll fill the platforms
	//  checklist with what the IDE would have given us, had
	//  the project type been "Application" or "Dynamic Link Library".
	// This is done so that we check the correct msvc key for whether
	//  Mac is installed.  If appwiz just went and checked on its own,
	//  it wouldn't know what key to use (i.e., whether we're launched
	//  by a sniff test).  Also, this way, all platform strings are gotten
	//  from the IDE rather than being hard coded here.
	//  This is also necessary so that we can get the localized
	//  string for the platforms, rather than hardcoding our own
	//  English version here.
	// This requires knowledge of the project types passed to us, by the
	//  IDE.  If the order or names ever change, we must update
	//  these hard-coded numbers.

	// First, be sure we're using our own symbol table.  (Soon symbols like
	//  "TARGET_POWERMAC" will be set, and we need to make sure they're set
	//  in AppWizard's own dictionary, rather than some extension we're
	//  going to detach later on.)
	projOptions.m_UserExtension.Detach();

	// Remember target type for when we create it later on
	pTermStatus->nProjType = nProjType;


	g_strlPlatformsDisplayed.RemoveAll();

	LPBUILDPLATFORMS pPlatforms;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&pPlatforms)));
	const CStringList* pPlatformsUI;
	pPlatforms->GetAvailablePlatforms(&pPlatformsUI, strlProjTypes.GetAt(strlProjTypes.FindIndex(nProjType)), TRUE);
	const CStringList* pPlatformsLong;
	pPlatforms->GetAvailablePlatforms(&pPlatformsLong, strlProjTypes.GetAt(strlProjTypes.FindIndex(nProjType)), FALSE);
	pPlatforms->Release();

	POSITION posUI = pPlatformsUI->GetHeadPosition();
	POSITION posLong = pPlatformsLong->GetHeadPosition();
	while (posUI != NULL && posLong != NULL)
	{
		CString strUI = pPlatformsUI->GetNext(posUI);
		CString strLong = pPlatformsLong->GetNext(posLong);

		if (strLong == szPlatforms[WIN]
				// This is the Win32 platform-- used for exe or dll
			|| (strLong == szPlatforms[MAC] && nProjType == 0)
				// This is the Macintosh platform-- used only for exe
			|| (strLong == szPlatforms[POWERMAC]))
				// This is the PowerMac platform-- used for exe or dll
		{
			pChklstPlatforms->Add(strUI);
			g_strlPlatformsDisplayed.AddTail(strUI);	// Remember what we store for later
		}
	}
}
#endif	// VS_PACKAGE

void ResetSymbolsForDLL()
{
	projOptions.m_nProjType = PROJTYPE_DLL;
	SetProjectTypeSymbol();
	ResetOleSymbols();
	RemoveSymbol("TARGET_68KMAC");

	// Undo database selections
	projOptions.m_nDataSource = dbOdbc;
	projOptions.m_bDBHeader = projOptions.m_bDBSimple = FALSE;
	if (projOptions.m_names.strBaseClass[classView] == "CDaoRecordView"
		|| projOptions.m_names.strBaseClass[classView] == "CRecordView")
	{
	    projOptions.m_names.strBaseClass[classView] = "CView";
	}
	RemoveSymbol("DB_COLSINFO");
	RemoveSymbol("DB_VARSINFO");
	RemoveSymbol("DB_SOURCE");
	RemoveSymbol("DB_DSN");
	SetDBSymbols();
	SetBaseViewSymbols();
}

BOOL CAppWizIFace::CanRunAppWizSteps(LPCTSTR szProj, LPCTSTR szProjDir, int* pnPlatforms)
{
	projOptions.m_strProj = szProj;
	VERIFY(projOptions.m_ProjDir.CreateFromString(szProjDir));
	CString strFullDirPath = (LPCTSTR) projOptions.m_ProjDir;
	if (*_tcsdec(strFullDirPath, ((LPCTSTR) strFullDirPath) + strFullDirPath.GetLength()) != '\\')
		strFullDirPath += '\\';
	SetSymbol("FULL_DIR_PATH", strFullDirPath);
	SetSymbol("SOURCE_FILTER","cpp;c;cxx;rc;def;r;odl;idl;hpj;bat");
	SetSymbol("INCLUDE_FILTER","h;hpp;hxx;hm;inl");

	CPath MakFile, MdpFile, VcpFile;
	MakFile.CreateFromDirAndFilename(projOptions.m_ProjDir, projOptions.m_strProj + BUILDER_EXT);
	MdpFile.CreateFromDirAndFilename(projOptions.m_ProjDir, projOptions.m_strProj + ".mdp");
	VcpFile.CreateFromDirAndFilename(projOptions.m_ProjDir, projOptions.m_strProj + ".opt");

	// COMMON BLOCK 1 (From CPromptDlg::FinishProcessing)
    // document info
    // fill symbol table if ok
	UpdateNamesIfNecessary(projOptions.m_names, projOptions.m_strProj);

	// Save a copy of the project name before munging it by upper-
	// casing it.
    SetSymbol("MIXED_CASE_ROOT", szProj);

	SetSymbol("ROOT", Upper(szProj));
	SetSymbol("root", szProj);
	SetSymbol("Root", szProj);

    if (projOptions.m_names.strClass[0].IsEmpty())
        FillDefaultNames(projOptions.m_names, projOptions.m_strProj);   // just use defaults
	SetDocumentSymbols();
	CString tmp = projOptions.m_strProjTag;   // non-DBCS root string
	SetSymbol("Safe_root", tmp);
	SetSymbol("safe_root", tmp);
	tmp.MakeUpper();
	SetSymbol("SAFE_ROOT", tmp);

    SetSymbol("platform_long", szPlatforms[WIN]);
#if defined(_X86_)
	SetSymbol("cc",			"cl");
	SetSymbol("cpu",		"i386");
	SetSymbol("host_cpu",	"X86");
	SetSymbol("linker",		"link");
#elif defined(_MIPS_)
	SetSymbol("cc",			"cl");
	SetSymbol("cpu",		"MIPS");
	SetSymbol("host_cpu",	"MIPS");
	SetSymbol("linker",		"link");
#elif defined(_ALPHA_)
	SetSymbol("cc",			"cl");
	SetSymbol("cpu",		"ALPHA");
	SetSymbol("host_cpu",	"ALPHA");
	SetSymbol("linker",		"link");
#else
#error "Need to define cc/cpu for this architecture"
#endif
	
	CString strPlatformShort;
	g_PlatNameConvert.LongToUI(szPlatforms[WIN], strPlatformShort);
	SetSymbol("platform_short", strPlatformShort);

    // Transfer info to projOptions
    UpdateTrackingNames(projOptions.m_names, projOptions.m_strProj);

	if (IsUserAWX())
	{
		// Custom AppWizard
		// this was where I set projOptions.m_UserExtension.m_strExtensionTItle.
		//  now, that's done immediately after we attach.
	}
	else
	{
		// Standard AppWizard

		// APPWIZ BLOCK 1
		// ...make sure a lang dll seems to be around
		if (!ScanForLangDll())
			return FALSE;

		// ...and make sure some files don't already exist
		CString strProjFile = strFullDirPath + projOptions.m_strProj;
        if (DoesFileExist(strProjFile + ".cpp")
            || DoesFileExist(strProjFile + ".h")
            || DoesFileExist(strProjFile + ".rc")
			|| DoesFileExist(strProjFile + ".clw")
			|| DoesFileExist(strFullDirPath + "stdafx.cpp")
			|| DoesFileExist(strFullDirPath + "stdafx.h")
			|| DoesFileExist(strFullDirPath + "resource.h"))
        {
            AfxMessageBox(IDP_FILE_EXISTS);
            return FALSE;
        }
	}
	// For either AppWizard or an extension, set symbols relating to
	//  the platforms selected.

	// Must do this now, since TARGET_MAC can get set here, and
	//  it's used below.
	ASSERT(pTermStatus != NULL);
	RecordPlatforms(pnPlatforms);

	// COMMON BLOCK 2
	// ...and make sure project name won't interfere with our
	//  default naming scheme
	if (DoesSymbolExist("PROJTYPE_OCX"))
	{
		if (InterfereWithDefaultsOCX(projOptions.m_strProj))
		{
			AfxMessageBox(IDP_FILE_INTERFERE_DEFAULTS_OCX);
			return FALSE;
		}
	}
	else if (InterfereWithDefaults(projOptions.m_strProj,
			DoesSymbolExist("TARGET_MAC"), DoesSymbolExist("PROJTYPE_CUSTOMAW")))
	{
		AfxMessageBox(IDP_FILE_INTERFERE_DEFAULTS);
		return FALSE;
	}

	// TODO: Properly separate powermac from 68kmac
	if (DoesSymbolExist("TARGET_MAC"))
	{
		// Reset Win32-only options previously set by the user.

		// ODBC
		if (!IsMacODBC())
		{
			projOptions.m_bDBSimple = projOptions.m_bDBHeader = FALSE;
	    	if (projOptions.m_names.strBaseClass[classView] == "CRecordView")
	        	projOptions.m_names.strBaseClass[classView] = "CView";
			SetDBSymbols();
			SetBaseViewSymbols();
		}

		// DAO
		if (projOptions.m_nDataSource == dbDao)
		{
			// If user previously picked a DAO data source, undo that
			projOptions.m_nDataSource = dbOdbc;
	    	if (projOptions.m_names.strBaseClass[classView] == "CDaoRecordView")
	        	projOptions.m_names.strBaseClass[classView] = "CView";
			RemoveSymbol("DB_COLSINFO");
			RemoveSymbol("DB_VARSINFO");
			RemoveSymbol("DB_SOURCE");
			RemoveSymbol("DB_DSN");
			SetDBSymbols();
			SetBaseViewSymbols();
		}

		// OLE
		if (!IsMacOle())
		{
			projOptions.m_nOleType = OLE_NO;
			projOptions.m_bOleAutomation = FALSE;
			projOptions.m_bOleCompFile = FALSE;
			SetOleSymbols();
		}
		if (!IsMacOcx())
		{
			projOptions.m_bOcx = FALSE;
			SetOleSymbols();
		}
	
		// WOSA
		if (!IsMacWOSA())
		{
			projOptions.m_options &= ~(1 << IDCD_POMAPI-IDCD_POBASE);
			projOptions.m_options &= ~(1 << IDCD_POSOCKETS-IDCD_POBASE);
			RemoveSymbol("MAPI");
			RemoveSymbol("SOCKETS");
		}

		// If Mac & no Win32 or Powermac targets, don't use shared mfc30.
		if (!DoesSymbolExist(szPlatforms[WIN]) && !DoesSymbolExist("TARGET_POWERMAC"))
			projOptions.m_projOptions &= ~(1 << (IDCD_PODLL-IDCD_POPROJBASE));
		SetProjOptionsSymbols();
	}

	if (IsMacInstalled())
		SetSymbol("INSTALLED_MAC", "1");
	else
		RemoveSymbol("INSTALLED_MAC");

	// We're going to be doing some symbol-setting below, so, if we're
	//  using an extension, it's time to attach its symbol table

	if (IsUserAWX())
	{
		// CUSTOM BLOCK 2

		// Start up the extension
		ASSERT(IsUserAWX());	// It was already loaded above

		// Change defaults if the extension creates a DLL
		if (DoesSymbolExist("PROJTYPE_DLL") || DoesSymbolExist("PROJTYPE_OCX"))
		{
			ResetSymbolsForDLL();
		}
		return TRUE;
	}
	else
	{
		// Here, the user selected appwiz.

		// APPWIZ BLOCK 2

		
		// We will eventually have to delete .bld, .mdp & .vcp if they
		//  exist.  To save user's time, let's check whether they're
		//  readonly now.
		if (!CheckIsReadOnly(MakFile.GetFullPath()))
			return FALSE;
		if (!CheckIsReadOnly(MdpFile.GetFullPath()))
			return FALSE;
		if (!CheckIsReadOnly(VcpFile.GetFullPath()))
			return FALSE;

		// Get rid of a previous loading of an extension
		projOptions.m_UserExtension.Detach();

        // Start up appwiz... finally!!
		if (pTermStatus->nProjType == 0)
		{
			// Create an .exe
			projOptions.m_nProjType = PROJTYPE_MDI;
			projOptions.m_bNoDocView = FALSE;
			SetProjectTypeSymbol();
			SetOleSymbols();
			if (projOptions.m_names.strBaseClass[classView] == "CRecordView")
				SetSymbol("CRecordView", "1");
		
		}
		else
		{
			// Create a .dll
			ResetSymbolsForDLL();
		}
		return TRUE;
	}

	ASSERT(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\xboxhelp.cpp ===
#include "stdafx.h"
#include <atlbase.h>
#include <initguid.h>
#include <ObjModel/bldguid.h>
#include <ObjModel/bldauto.h>
#include <utilauto.h>
#include "keywords.h"
#include <htmlhelp.h>

BOOL DoXboxHelp(LPCTSTR lpszKeyword)
{
	CComBSTR  bstrTemp;
	CString   strProjName;
	CString   strConfigName;
	BOOL      bXboxProj = FALSE;
	BOOL      bLaunchMSDN = FALSE;
	CString   strKeyword = lpszKeyword;
	IDispatch *iDisp = NULL;

	if( !theApp.m_pAutoApp ) return FALSE;

	try
	{
		// this call will throw a custom dev studio 
		// exception if there is no project loaded
		// and a tacky messagebox will be displayed
		// if I don't handle it
		iDisp = theApp.m_pAutoApp->GetActiveProject();
	}
	catch( CException* e )
	{
		// suppress the exception and messagebox
		// then let MSDN handle this F1 event
	    e->Delete();
	    return FALSE;
	}

	if( !iDisp ) return FALSE;
	IGenericProject *pActiveProj;
	iDisp->QueryInterface(IID_IGenericProject, (LPVOID FAR *)&pActiveProj);
	if(!pActiveProj) return FALSE;
	pActiveProj->get_Name(&bstrTemp);
	strProjName = bstrTemp;
	SysFreeString(bstrTemp);
//MessageBox(NULL,"ProjName",strProjName,MB_OK);
	pActiveProj->Release();
	iDisp->Release();

	// Get active configuration's name
	iDisp = theApp.m_pAutoApp->GetActiveConfiguration();
	IConfiguration *pActiveConfig; 
	iDisp->QueryInterface(IID_IConfiguration, (LPVOID FAR *)&pActiveConfig);
	if(!pActiveConfig) return FALSE;
	pActiveConfig->get_Name(&bstrTemp);
	strConfigName = bstrTemp;
	SysFreeString(bstrTemp);
//MessageBox(NULL,"ConfigName",strConfigName,MB_OK);
	pActiveConfig->Release();
	iDisp->Release();

	// Is this an Xbox project?
	CString strTestForXbox = strProjName + L" - Xbox";
	if(!strConfigName.Left(strTestForXbox.GetLength()).Compare(strTestForXbox))
	{
		// The final F1 help solution might use the project type as 
		// an index into an INI file. Each section describes what 
		// actions to take based on the project type. 
		bXboxProj = TRUE;
	}

	// Launch help
	if(bXboxProj)
	{
		strKeyword.TrimLeft();
		strKeyword.TrimRight();

		// Get path to Xbox help
		HKEY  hkXDK = NULL;
		char  szPathBuf[MAX_PATH];
		DWORD dwSize = sizeof(szPathBuf);

		memset(szPathBuf,0,sizeof(szPathBuf));
		
		RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\XboxSDK",NULL,KEY_QUERY_VALUE,&hkXDK);
		RegQueryValueEx(hkXDK,"InstallPath",NULL,NULL,(LPBYTE)szPathBuf,&dwSize);
		RegCloseKey(hkXDK);

		CString strChmPath = szPathBuf;

		// Did we get a valid path?
		if(strChmPath.IsEmpty())
		{
			// TODO: Needs to be a real dialog that has a "Don't show this in the future" checkbox.
			theApp.EnableModeless(VARIANT_FALSE);
			::MessageBox(NULL, "Cannot locate \"XboxSDK.chm\". The Xbox SDK may not be properly installed.", "Cannot locate \"XboxSDK.chm\"" , MB_OK | MB_ICONEXCLAMATION);
			theApp.EnableModeless(VARIANT_TRUE);
			// TODO: Display "launching default chm" in the msgbox above - and launch the default MSDN CHM here.
			// Launch MSDN Help
			bLaunchMSDN = TRUE;
		}
		else
		{
			strChmPath += L"\\Doc";
			CString strKwdFile = strChmPath;
			CString strChmFile = strChmPath;

			strKwdFile += "\\XboxSDK.kwd";
			strChmFile += "\\XboxSDK.chm";

			// does the chm even exist?
			if( -1 == GetFileAttributes(strChmFile) )
			{
				// TODO: Needs to be a real dialog that has a "Don't show this in the future" checkbox.
				theApp.EnableModeless(VARIANT_FALSE);
				::MessageBox(NULL, "Cannot locate \"XboxSDK.chm\". The Xbox SDK may not be properly installed.", "Cannot locate \"XboxSDK.chm\"" , MB_OK | MB_ICONEXCLAMATION);
				theApp.EnableModeless(VARIANT_TRUE);
				// TODO: Display "launching default chm" in the msgbox above - and launch the default MSDN CHM here.
				// Launch MSDN Help
				bLaunchMSDN = TRUE;
			}
			else
			{
				// Inefficient, to create this object each time, 
				// but I want this addin to be stateless.
				CKeywords kwdXbox(strKwdFile);
				
				if(kwdXbox.IsKeyword(strKeyword))
				{
					// Launch Xbox Help
					HH_AKLINK link;
	
					link.cbStruct =     sizeof(HH_AKLINK) ;
					link.fReserved =    FALSE ;
					link.pszKeywords =  strKeyword ; 
					link.pszUrl =       NULL ; 
					link.pszMsgText =   NULL ; 
					link.pszMsgTitle =  NULL ; 
					link.pszWindow =    NULL ;
					link.fIndexOnFail = TRUE ;
	
					// This will open the TOC to the entry found. 
					// I killed it since I want to behave just like VC's F1 help.
					// HtmlHelp(GetDesktopWindow(),szChmPath,HH_DISPLAY_TOC,NULL);
	
					HtmlHelp(GetDesktopWindow(),strChmFile,HH_KEYWORD_LOOKUP,(DWORD)&link);
				}
				else
				{
					// Launch MSDN Help
					bLaunchMSDN = TRUE;
				}
			}
		}
	}
	else
	{
		// Launch MSDN Help
		bLaunchMSDN = TRUE;
	}

	// Launch MSDN if we weren't able to handle the keyword.
	// I reverse the boolean so it looks cleaner for the caller.
	// TRUE means we handled it, FALSE means MSND should take a stab at it.
	return bLaunchMSDN ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\advanced.h ===
// advanced.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAdvancedDlg dialog

class CAdvancedDlg : public CTabbedDialog
{
public:
	CAdvancedDlg(CWnd* pParent);
};

/////////////////////////////////////////////////////////////////////////////
// CFrameStylesDlg dialog

class CFrameStylesDlg : public CDlgTab
{
// Construction
public:
	CFrameStylesDlg();

// Dialog Data
	//{{AFX_DATA(CFrameStylesDlg)
	enum { IDD = IDD_FRAME_STYLES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	// Generated message map functions
	//{{AFX_MSG(CFrameStylesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnMaximize();
	afx_msg void OnMinimize();
	afx_msg void OnChildMaximize();
	afx_msg void OnChildMinimize();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CDocStringsDlg dialog

class CDocStringsDlg : public CDlgTab
{
// Construction
public:
	CDocStringsDlg();

// Dialog Data
	//{{AFX_DATA(CDocStringsDlg)
	enum { IDD = IDD_DOCSTRINGS };
	CString	m_strDocTag;
	CString	m_strDocFileExt;
	CString	m_strDocFileNew;
	CString	m_strDocFilter;
	CString	m_strDocRegID;
	CString	m_strDocRegName;
	//}}AFX_DATA
	CString m_strTitle;

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void UpdateDocFields();	
	virtual BOOL ValidateTab();
	virtual void CommitTab();
	BOOL ValidateCurrLang();
	void DisplayCurrLang();

	// Generated message map functions
	//{{AFX_MSG(CDocStringsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeDocType();
	afx_msg void OnChangeDocExt();
	afx_msg void OnChangeFileNew();
	afx_msg void OnChangeFilter();
	afx_msg void OnChangeRegId();
	afx_msg void OnChangeRegName();
	//}}AFX_MSG
	// FUTURE: Multiple langs:
	//afx_msg void OnSelchangeLangCombo();
	DECLARE_MESSAGE_MAP()

	int m_nCurrLang;
};

/////////////////////////////////////////////////////////////////////////////
// CMacDlg dialog

class CMacDlg : public CDlgTab
{
// Construction
public:
	CMacDlg();

// Dialog Data
	//{{AFX_DATA(CMacDlg)
	enum { IDD = IDD_MAC };
	//}}AFX_DATA
	CString	m_strDocFileCreator;
	CString	m_strDocFileType;
	CString	m_strDocFilter;

// Implementation
protected:
	BOOL m_bTrackFilter;

	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual BOOL ValidateTab();
	virtual void CommitTab();

	// Generated message map functions
	//{{AFX_MSG(CMacDlg)
	afx_msg void OnChangeFileType();
	afx_msg void OnChangeFilter();
	afx_msg void OnChangeDocCreator();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\codegen.h ===
#ifndef __CODEGEN_H__
#define __CODEGEN_H__
#include "customaw.h"		// Has declaration of OutputStream
#include <fcntl.h>			// Has declaration of _O_BINARY


/////////////////////////////////////////////////////////////////////////////
// codegen.h, codegen.cpp: Code-generator engine


/////////////////////////////////////////////////////////////////////////////
// "OutputStream" structs to handle output

class ListStream : public OutputStream
{
public:
    void WriteLine(LPCTSTR psz)
        {
			LPCTSTR lpchBegin = psz;
			LPCTSTR lpchEnd;
			while ((lpchEnd = _tcschr(lpchBegin, '\n')) != NULL)
			{
				CString strLine(lpchBegin, lpchEnd-lpchBegin);
            	list.AddTail(strLine);
				lpchBegin = _tcsinc(lpchEnd);
			}
			list.AddTail(lpchBegin);
        }
	void WriteBlock(LPCTSTR pb, DWORD dwSize)
		{
			// AppWizard will never call a WriteBlock on an output stream tied
			//  to the New Project Information edit control.  However, a deranged
			//  extension might want to, so we'll grudgingly support it.
			ASSERT(FALSE);
			CString strBlock(pb, dwSize);
			list.AddTail(strBlock);
		}

    CStringList list;
};

class FileStream : public OutputStream
{
public:
    FileStream(FILE* pfile)
        : file(pfile)
        { pOpenFile = pfile; }
	// Normally, we'll close the file ourselves, checking for errors.  When
	//  we do this, we set pOpenFile to NULL.  If an exception is thrown, we don't
	//  have a chance to do this.  Thus, the destructor takes care of it.
	virtual ~FileStream()
		{ if (pOpenFile) fclose(pOpenFile); }
	FILE* pOpenFile;
    void WriteLine(const char* psz)
        {
            file.WriteString(psz);
            file.WriteString("\n");
        }
    void WriteBlock(LPCTSTR pb, DWORD dwSize)
        {
			VERIFY(_setmode(_fileno(pOpenFile), _O_BINARY) != -1);
            file.WriteHuge(pb, dwSize);
        }

private:
    CStdioFile file;        // output only - usually does not close
};

/* void GenFile(const char* szResName, OutputStream& output,
				HINSTANCE hMainRsc, HINSTANCE hLocRsc, CMapStringToString* pDictionary);*/

// Used internally by codegen.
extern CString strFileToOpen;

// Error reporting functions
void ReportErrorExt(UINT nIDP, LPCTSTR lpszArg = NULL);
void ReportAndThrowExt(UINT nIDP, LPCTSTR lpszArg = NULL);
void ReportAndThrow(UINT nIDP, LPCTSTR lpszArg);


/////////////////////////////////////////////////////////////////////////////
// State classes to handle nested $$IF's.

#define MAXSTATE        10       // nested limit of $$IF's.

class State
{
friend class CCodeGen;
public:
    State();
    BOOL Process(LPCTSTR lpch, LPCTSTR *plpchNext);
    BOOL IsOutput()
            { return m_pCurState->m_bOutput; }

protected:
    enum Mode
    {
        idle,
        inIf,
        inElse
    };

    struct IFSTATE
    {
        BOOL m_bOutput;			// currently output
        Mode m_mode;			// control bOutput
        BOOL m_bOneOutput;		// set once if output during IF/ELIF/ELSE
        DWORD m_nLine;		    // record the line # for better error output on IF
    };
    IFSTATE* m_pCurState;		// current state

    int m_iCurState;			// current state 0->MAXSTATE-1
    IFSTATE m_states[MAXSTATE];	// state stack
	CCodeGen* m_pCodeGen;		// code generator it's assoc. w/
};

/////////////////////////////////////////////////////////////////////////////
// One CCodeGen instance is created to generate each file.  CCodeGen's
//  are typically created by the master generator CProjGen below

class CCodeGen
{
friend class State;
friend class CProjGen;
public:
	CCodeGen();

	void Go(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput, CMapStringToString* pSymbols);

protected:
	BOOL InLoop();
	void ScanToAfterEndloop(LPCTSTR& lpch);
	BOOL ProcessControl(LPCTSTR& lpch, LPCTSTR lpchEnd);
	void Translate(CString& pchOut, LPCTSTR lpch);
	void GetLoopKey(LPCTSTR lpszKey, CString& rStrLoopKey);
	BOOL DoesSymbolExist(LPCTSTR lpszKey);
	BOOL GetSymbol(LPCTSTR lpszKey, CString& rStrValue);
	void ReportAndThrow(UINT nIDP, LPCTSTR lpszArg = NULL);

	CMapStringToString* m_pSymbols;
	OutputStream* m_pOutput;
	State m_state;

	BOOL m_bGeneratingWorklist;
	BOOL m_bLoopInProjGen;
	int m_nBeginLoop;
	LPCTSTR m_lpszBeginLoop;
	int m_nIteration, m_nTotalIterations;

	// We keep these around for error reporting
	CString m_strTemplateName;		// Name of template we're parsing
	int m_nLine;					// Current line number we're at
};

/////////////////////////////////////////////////////////////////////////////
// There is at most one CProjGen instance at any time.  It handles creating
//  CCodeGen's, creating the worklist, and parsing through that worklist
//  to drive the generation process.

class CProjGen
{
public:
	CProjGen()
		{ SetCurrent(this); m_nIteration = -1; m_bGeneratingWorklist = FALSE;
		  m_pProjStatus = NULL; m_pFileStatus = NULL; }
	~CProjGen()
		{ SetCurrent(NULL); }
		
	void Go(CWnd* pProjStatus, CWnd* pFileStatus);
	void SetTemplateName(LPCTSTR szTemplateName)	// Called by CCodeGen while processing
		{ m_strTemplateName = szTemplateName; }		//  $$INCLUDE
		
	static void InitCodeGen(CCodeGen* pCodeGen);
	static CProjGen* GetCurrent();
	void SetCurrentIteration(int i)
		{ ASSERT (m_nIteration == -1); m_nIteration = i; }
	void ResetCurrentIteration()
		{ ASSERT (m_nIteration != -1); m_nIteration = -1; }

protected:
	static void SetCurrent(CProjGen* pProjGen);
	BOOL InLoop();
	void GenerateFromWorkList(CStringList& list);

	CString m_strTemplateName;		// Name of template we're currently parsing
	BOOL m_bGeneratingWorklist;
	CWnd* m_pProjStatus;
	CWnd* m_pFileStatus;
	int m_nIteration;
};

// Keeps track of all the files currently on the include stack.  This exists
//  solely to check for recursive includes that would cause a stack overflow.
class IncludeStack
{
public:
	inline void Clear()
		{ m_IncludeStack.RemoveAll(); }
	inline void Add(LPCTSTR szTemplateName)
		{ 
			CString strEntry = szTemplateName;
			strEntry.MakeLower();
			m_IncludeStack[strEntry] = NULL;
		}
	inline BOOL Remove(LPCTSTR szTemplateName)
		{ 
			CString strEntry = szTemplateName;
			strEntry.MakeLower();
			return m_IncludeStack.RemoveKey(strEntry);
		}
	inline BOOL Lookup(LPCTSTR szTemplateName)
		{
			void* p;
			CString strEntry = szTemplateName;
			strEntry.MakeLower();
			return m_IncludeStack.Lookup(strEntry, p);
		}

protected:
	
	CMapStringToPtr m_IncludeStack;
};
extern IncludeStack g_IncludeStack;
extern AppWizTermStatus g_TermStatus;

void LoadAndProcessTemplate(LPCTSTR szTemplateName, OutputStream* pOutput, BOOL bBinary = FALSE);


#endif // __CODEGEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\customaw.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "myaw.h"		// also includes "customaw.h"
#include "codegen.h"
#include "lang.h"

extern HINSTANCE GetResourceHandle();

/////////////////////////////////////////////////////////////////////////////
// customaw.cpp -- Implementation of CCustomAppWiz & CMyCustomAppWiz

CMyCustomAppWiz MyAWX;

// Based on lpszResource's extension, we determined whether the resource
//  is located in rsc-only DLL or in mfcapwz.dll.  We have a special return
//  value for when the extension is .rtf, so we know whether we should try
//  .rft.  (See FindExtensionResource below.)
enum { LOC_NO, LOC_YES, LOC_YES_RTF };
int IsLocalizedTemplate(LPCTSTR lpszResource)
{
	LPCTSTR ext = _tcschr(lpszResource, '.')+1;
	if (!_tcscmp(ext, "rtf"))
		return LOC_YES_RTF;

	if (!_tcscmp(ext, "rc") || !_tcscmp(ext, "rc2") || !_tcscmp(ext, "rft")
		|| !_tcscmp(ext, "bmp") || !_tcscmp(ext, "hpj"))
		return LOC_YES;

	return LOC_NO;
}


// In the olden days, AppWizard separated its templates into two resource
//  types: SRCDATA & BINDATA.  They're now combined into one type: "TEMPLATE".
//  For backward compatibility, we continue to check the original two
//  types if necessary.
// TODO: When the appwiz*.dlls are updated, GET RID OF THIS!!!
/*HRSRC FindResourceAnyType(HINSTANCE hInstance, LPCTSTR lpszResource)
{
	HRSRC hrsrc = ::FindResource(hInstance, lpszResource, "TEMPLATE");
	if (hrsrc == NULL)
	{
		hrsrc = ::FindResource(hInstance, lpszResource, "SRCDATA");
		if (hrsrc == NULL)
			hrsrc = ::FindResource(hInstance, lpszResource, "BINDATA");
	}
	return hrsrc;
}*/

// Helper used in FindExtensionResource.  Creates name like "loc_enu.rc" from "loc.rc"
static void MakeLocTplName(CString& rStrResource, LPCTSTR lpszResource, LPCTSTR lpszDefaultLang)
{
	ASSERT(lpszResource != NULL);
	ASSERT(lpszDefaultLang != NULL);

	LPCTSTR lpszPeriod = _tcschr(lpszResource, '.');
	if (lpszPeriod != NULL)
	{
		// Append '_langSuffix' just before first period
		rStrResource = lpszResource;
		rStrResource = ((rStrResource.Left(lpszPeriod - lpszResource)
							+ '_') + lpszDefaultLang) + lpszPeriod;
	}
	else
	{
		// If there is no period, just append '_langSuffix' to end
		rStrResource = (((CString) lpszResource) + '_') + lpszDefaultLang;
	}

}

// Looks for specified custom resource...
//  1) In hInstance; if not there...
//  2) Through normal route of mfcapwz.dll & appropriate appwiz*.dll.
// This allows the extension to simply specify AppWizard templates, without
//  having to provide its own copies of them.
// When the function returns, the HINSTANCE used to load the resource is
//  stored in hInstance.
HRSRC FindExtensionResource
	(LPCTSTR lpszResource, HINSTANCE& hInstance)
{
	ASSERT(lpszResource != NULL);

	HRSRC hrsrc;
	if (hInstance != NULL)
	{
		LPCTSTR lpszDefaultLang;
		if (IsUserAWX() && 
			(lpszDefaultLang = langDlls.GetDefaultLang()) != NULL)
		{
			// Extensions have their own way of handling multiple languages.  First,
			//  we try appending _langSuffix (like _enu) to end of template name.
			CString strResource;
			MakeLocTplName(strResource, lpszResource, lpszDefaultLang);
			hrsrc = ::FindResource(hInstance, strResource, "TEMPLATE");
			if (hrsrc != NULL)
				return hrsrc;
		}

		// If that doesn't work, we just look for it under its actual name
		hrsrc = ::FindResource(hInstance, lpszResource, "TEMPLATE");
		if (hrsrc != NULL)
			// We found in the extension itself
			return hrsrc;
	}

	// The template is not in the extension (or there is no extension).
	//  Try mfcapwz.dll next.

	hrsrc = ::FindResource(hInstance = GetResourceHandle(), lpszResource, "TEMPLATE");

	if (hrsrc == NULL)
	{
		// The template is not in mfcapwz.dll.  Let's try the langDlls.
		hrsrc = langDlls.FindLangResource(lpszResource, hInstance);
	}
	return hrsrc;
}

// We wrap all calls to LoadTemplate, since the custom appwiz may override it, and we need to
//  be sure its return value is non-NULL.  (We can be sure that *our* LoadTemplate will never
//  return NULL, since it will throw an exception in that case before it can return.)
LPCTSTR LoadTemplateWrapper(LPCTSTR lpszResource, DWORD& dwSize, HINSTANCE hInstance /* = NULL */)
{
	LPCTSTR szReturn = GetAWX()->LoadTemplate(lpszResource, dwSize, hInstance);
	if (szReturn == NULL)
	{
		if (IsUserAWX())
		{
			// It's the custom appwiz's fault
			ReportAndThrowExt(IDS_CG_CANT_LOAD_TPL, lpszResource);
		}
		else
		{
			// It must be the appwz dll's fault
			ASSERT(FALSE);
			ReportAndThrow(IDP_BAD_LANG_DLL, langDlls.m_astrNameDll[0]);
		}
	}
	return szReturn;
}

LPCTSTR CCustomAppWiz::LoadTemplate(LPCTSTR lpszResource,
	DWORD& dwSize, HINSTANCE hInstance /* = NULL */)
{
	ASSERT_VALID(this);
	ASSERT(lpszResource != NULL);

	// Get handle to resource if it wasn't already passed to us
	extern BOOL g_bLoadFromAppwiz;	// Defined at top of codegen.cpp
	if (hInstance == NULL && !g_bLoadFromAppwiz)
		hInstance = projOptions.m_UserExtension.GetInstanceHandle();
	g_bLoadFromAppwiz = FALSE;		// Reset flag now that we're done w/ it

	// If hInstance is still NULL, that means we're probably being called
	//  by CMyCustomAppWiz, so just look through mfcapwz.dll & appwz*.dll.
	// TODO: TRACE. This is a great place to put an extension debugging TRACE.

	// Find, load, and lock resource.
	HRSRC hrsrc = FindExtensionResource(lpszResource, hInstance);
	if (hrsrc == NULL)
	{
		if (IsUserAWX())
		{
			// It's the custom appwiz's fault
			ReportAndThrowExt(IDS_CG_CANT_LOAD_TPL, lpszResource);
		}
		else
		{
			// It must be the appwz dll's fault
			ASSERT(FALSE);
			ReportAndThrow(IDP_BAD_LANG_DLL, langDlls.m_astrNameDll[0]);
		}
	}

	// Get size-- better be nonzero or we tattle
	dwSize = ::SizeofResource(hInstance, hrsrc);
	if (dwSize == 0)
	{
		if (IsUserAWX())
		{
			// It's the extension's fault
			ReportAndThrowExt(IDS_CG_0SIZE_RSC, lpszResource);
		}
		else
		{
			// It must be the appwz dll's fault
			ASSERT(FALSE);
			ReportAndThrow(IDP_BAD_LANG_DLL, langDlls.m_astrNameDll[0]);
		}
	}

	// Finally load & lock resource-- better be non-NULL or we tattle
	HGLOBAL hglb = ::LoadResource(hInstance, hrsrc);
	LPCTSTR lpszTemplate = NULL;
	if (hglb == NULL || (lpszTemplate = (LPCTSTR) ::LockResource(hglb)) == NULL)
	{
		if (IsUserAWX())
		{
			// It's the extension's fault
			ReportAndThrowExt(IDS_CG_BAD_RSC, lpszResource);
		}
		else
		{
			// It must be the appwz dll's fault
			ASSERT(FALSE);
			ReportAndThrow(IDP_BAD_LANG_DLL, langDlls.m_astrNameDll[0]);
		}
	}
	return lpszTemplate;
}


// This is basically the same as base class's LoadTemplate, but with an error messagebox
LPCTSTR CMyCustomAppWiz::LoadTemplate(LPCTSTR lpszResource,
	DWORD& dwSize, HINSTANCE hInstance)
{
	ASSERT_VALID(this);
	ASSERT(lpszResource != NULL);

	LPCTSTR pTempStrm
		= CCustomAppWiz::LoadTemplate(lpszResource, dwSize, hInstance);

	if (pTempStrm == NULL)
	{
		// We couldn't load the template.
		ASSERT(FALSE);

		// It must be the appwz DLL's fault, so report message
		CString strPrompt;
		AfxFormatString1(strPrompt, IDP_BAD_LANG_DLL, langDlls.m_astrNameDll[0]);
		AfxMessageBox(strPrompt);
		AfxThrowResourceException();
    }
	return pTempStrm;
}


// Takes a template (like a binary file) and copies it verbatim to output, without
//  doing any parsing.
void CCustomAppWiz::CopyTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput)
{
	pOutput->WriteBlock(lpszInput, dwSize);
}


#define LOC_TAG	'@'

// This is now called only for templates which must be parsed & processed.  No
//  binary files!
void CCustomAppWiz::ProcessTemplate(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput)
{
	ASSERT_VALID(this);
	// If lpszInput is NULL, this error is reported in Go.

	// We need to strip the localization tags out of the template
	DWORD dwStippedSize = 0;
	LPTSTR pstr = (LPTSTR)malloc(dwSize);
	LPTSTR pOut = pstr;
	LPCTSTR pIn = lpszInput;
	LPCTSTR pInEnd = pIn + dwSize;
	TCHAR c;
#ifdef _DEBUG
	BOOL fInTags = FALSE;
#endif // _DEBUG
	if(!pstr)
		return;
	while(pIn < pInEnd)
	{
		c = *pIn++;
		if(c != LOC_TAG)
		{
			*pOut++ = c;
			if(isleadbyte(c) && pIn < pInEnd)
				*pOut++ = *pIn++;
		}
		else
		{
			// look ahead one
			if(pIn < pInEnd)
			{
				c = *pIn;
				if(c != LOC_TAG)
				{
					*pOut++ = LOC_TAG;
				}
				else
				{
					// Skip the Tags
					pIn++;
#if _DEBUG
					fInTags = !fInTags;
#endif // _DEBUG
				}
			}
			else
				*pOut++ = LOC_TAG;
		}
		// Cannot have a localization tag that spans more than one line!
		// You need to split them up if necessary
		ASSERT(c != '\n' || !fInTags);
	}
	CCodeGen codeGen;
	codeGen.Go(pstr, pOut-pstr, pOutput, &m_Dictionary);
	free(pstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\codegen.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "codegen.h"
#include "myaw.h"
#include "lang.h"
#include "symbols.h"
#ifdef VS_PACKAGE
#include <direct.h>
#endif


/////////////////////////////////////////////////////////////////////////////
// This points to the one CProjGen instance available.  If there isn't one,
//  this is NULL.  This is used in CProjGen's GetCurrent & SetCurrent
static CProjGen* s_pProjGen = NULL;

// Keeps track of all the files currently on the include stack.  This exists
//  solely to check for recursive includes that would cause a stack overflow.
IncludeStack g_IncludeStack;

// Is set if the filename has a prepended '*' in newproj.inf, indicating
//  that we should bypass the extension and load the template directly
//  from appwiz.
BOOL g_bLoadFromAppwiz = FALSE;

/////////////////////////////////////////////////////////////////////////////
// Random helper C functions

void CreateDirectory(const char* szDir, BOOL bChangeTo)
{
    struct _stat st;
    if (_stat(szDir, &st) == 0)
    {
        // something already exists
        if (!(st.st_mode & _S_IFDIR))
            ReportAndThrow(IDP_DIRECT_IS_FILE, szDir);
    }
    else
    {
		CDir dir;
		dir.CreateFromString(szDir);
		if (!dir.CreateOnDisk())
			ReportAndThrow(IDP_DIRECT_CREATE, szDir);
    }

    if (bChangeTo)
    {
        // change to that directory
        if (_chdir(szDir) != 0)
            ReportAndThrow(IDP_DIRECT_CHANGE, szDir);
    }
}

const char* RemoveDot(const char* szFilename)
{
	if (szFilename[0] == '.' && szFilename[1] == '\\')
		return szFilename+2;
	else
		return szFilename;
}

inline void AddDotIfNecessary(CString& strFileName)
{
	if (strFileName.Find('\\') == -1)
		// Name doesn't have a path, so prepend ".\". This works around some
		//  weird Novell NetWare bug which causes the filename to be searched
		//  along some other environment path rather than searching cwd first
		strFileName = ".\\" + strFileName;
}


void MyMessageBox(LPCTSTR szPrompt)
{
	ASSERT (theDLL.m_pMainDlg != NULL);
	ASSERT (theDLL.m_pMainDlg->m_pConfirmDlg != NULL);
	theDLL.m_pMainDlg->m_pConfirmDlg->EnableWindow(FALSE);
	AfxMessageBox(szPrompt);
	theDLL.m_pMainDlg->m_pConfirmDlg->EnableWindow(TRUE);
}

// Note that the following function is duplicated in...
//
//	ide\pkgs\cpp\addclass.cpp
//	ide\wizards\appwiz\codegen.cpp
//	ide\wizards\clswiz\srcio.cpp
//
//	If you make a change to it in one place, please modify it in all places.
//	Yes, this just should be in the shell, but it's too late to get a change
//	like that in place.  -mgrier 12/4/96
static CString ConstructFileNameInclusionSymbol(const CString &rstrFileName)
{
	// Construct a symbol name corresponding to the current file name.  Each
	// character could yield up to 6 characters in the output.
	char rgchFileNameSymbol[(MAX_PATH * 6) + (sizeof(GUID) * 3) + 1];
	const char *pchInput = rstrFileName;
	char *pchOutput = rgchFileNameSymbol;
	char ch;

	*pchOutput++ = 'A';
	*pchOutput++ = 'F';
	*pchOutput++ = 'X';
	*pchOutput++ = '_';

	// A lot of filenames are expressed ".\foo.h", so skip past the .\ part.
	if (*pchInput == '.' && *(pchInput + 1) == '\\')
	{
		pchInput += 2;
	}

	// Keep track of whether any alphanumeric characters at all were found. If
	// there aren't any, we just skip the whole filename thing.  (per discussions
	// with anitag.)  -mgrier 12/3/96

	BOOL fAnyAlphanumerics = FALSE;

	while ((ch = *pchInput++) != '\0')
	{
		static char rgchHexChars[] = "0123456789ABCDEF";

		if (((ch >= 'A') && (ch <= 'Z')) ||
			((ch >= 'a') && (ch <= 'z')) ||
			((ch >= '0') && (ch <= '9')))
		{
			*pchOutput++ = (char)toupper(ch);
			fAnyAlphanumerics = TRUE;
		}
#if !defined(DONT_USE_GUID_IN_INCLUSION_SYMBOL_NAME)
//
// If the GUID is being used for uniqueness, we don't have to mangle
// the name as much; just pass letters and numbers through, and turn
// everything else into underscores.  -mgrier 9/30/96

		else if (isleadbyte(ch))
		{
			// We don't output anything for multibyte characters.
			if (*pchInput != '\0')
				pchInput++;
		}
		else if ((ch == '.') || (ch == '_'))
			*pchOutput++ = '_';
#else
		else if (isleadbyte(ch))
		{
			*pchOutput++ = '_';
			*pchOutput++ = rgchHexChars[(ch >> 4) & 0xf];
			*pchOutput++ = rgchHexChars[ch & 0xf];

			if ((ch = *pchInput) != '\0')
			{
				*pchOutput++ = rgchHexChars[(ch >> 4) & 0xf];
				*pchOutput++ = rgchHexChars[ch & 0xf];
				pchInput++;
			}

			*pchOutput++ = '_';
		}
		else if ((ch == '_') || (ch == '.'))
		{
			*pchOutput++ = '_';
			*pchOutput++ = '_';
		}
		else
		{
			// Tradeoff: we can generate a mapping which is intuitive but
			//				not one to one (e.g. "file 1.h" => "file_1_h")
			//				or one which is one to one but not intuitive
			//				(e.g. "file 1.h" => "file_41__04_h" assuming
			//				that space maps to _41_ and . to _04_ -- note
			//				the numbers in this example are just totally made
			//				up -mgrier 9/18/96).
			//
			//				I'm picking the non-intuitive one because while
			//				people might complain about the ugly preprocessor
			//				symbols, at least they won't get errors from
			//				naively named symbols.  -mgrier 9/18/96
			*pchOutput++ = '_';
			*pchOutput++ = rgchHexChars[(ch >> 4) & 0xf];
			*pchOutput++ = rgchHexChars[ch & 0xf];
			*pchOutput++ = '_';
		}
#endif // !defined(DONT_USE_GUID_IN_INCLUSION_SYMBOL_NAME)
	}


#if !defined(DONT_USE_GUID_IN_INCLUSION_SYMBOL_NAME)
	if (!fAnyAlphanumerics)
	{
		// There wasn't anything in the name which just passed through.  We'll start
		// over from just after the AFX_
		pchOutput = &rgchFileNameSymbol[4];
	}

	// If you want to get rid of the adding a GUID thing, just remove the lines
	// from here to the *pchOutput = '\0'; line.  -mgrier 9/24/96
	GUID guidUniqueness;

	HRESULT hr = ::CoCreateGuid(&guidUniqueness);
	if (SUCCEEDED(hr))
	{
		OLECHAR rgochGuid[256];
		CHAR rgchGuid[256];

		::StringFromGUID2(guidUniqueness, rgochGuid, sizeof(rgochGuid) / sizeof(rgochGuid[0]));

		::WideCharToMultiByte(CP_ACP, 0, rgochGuid, -1, rgchGuid, sizeof(rgchGuid), NULL, NULL);

		*pchOutput++ = '_';

		pchInput = rgchGuid;

		while ((ch = *pchInput++) != '\0')
		{
			if (isalnum(ch))
				*pchOutput++ = (char)toupper(ch);
			else
				*pchOutput++ = '_';
		}
	}
#endif // !defined(DONT_USE_GUID_IN_INCLUSION_SYMBOL_NAME)

	*pchOutput = '\0';

	return CString(rgchFileNameSymbol);
}

/////////////////////////////////////////////////////////////////////////////
// The State class.

State::State()
{
    m_iCurState = 0;
    m_pCurState = &m_states[m_iCurState];
    m_pCurState->m_bOutput = TRUE;
    m_pCurState->m_bOneOutput = TRUE;
    m_pCurState->m_mode = idle;
	m_pCodeGen = NULL;
}

static BOOL Match(LPCTSTR &lpch, const TCHAR* szMatch)
{
    int nLen = _tcslen(szMatch);
    if (_tcsncmp(lpch, szMatch, nLen) != 0)
        return FALSE;
    lpch += nLen;
    return TRUE;
}

// Special processing for $$IF, $$ELIF, $$ELSE, $$ENDIF
BOOL State::Process(LPCTSTR lpch, LPCTSTR *plpchNext)
{
	ASSERT(m_pCodeGen != NULL);
	ASSERT(m_pCodeGen->m_pSymbols != NULL);

	CMapStringToString* pSymbols = m_pCodeGen->m_pSymbols;
    if (*lpch != '$' || !Match(lpch, "$$"))
        return FALSE;

    if (Match(lpch, "//"))
    {
        // comment - ignore it
    }
    else if (Match(lpch, "IF("))
    {
        if (m_pCurState->m_mode != idle)
        {
            // allow nested IF
            if (++m_iCurState >= MAXSTATE)
            {
				m_pCodeGen->ReportAndThrow(IDS_CG_IF_TOO_DEEP);
            }
            m_states[m_iCurState] = m_states[m_iCurState-1];    // copy state
            m_pCurState = &m_states[m_iCurState];
            // cur set to new values below
            if (!m_pCurState->m_bOutput)
            {
                // ignore till next endif
                m_pCurState->m_bOneOutput = TRUE;       // pretend we did
                m_pCurState->m_bOutput = FALSE;
                m_pCurState->m_mode = inIf;
     			m_pCurState->m_nLine = m_pCodeGen->m_nLine;
                return TRUE;
            }
        }
Lif:
        // find the symbol
        LPCTSTR lpchEnd = _tcschr(lpch, ')');
        if (lpchEnd == NULL)
        {
			m_pCodeGen->ReportAndThrow(IDS_CG_BAD_IF);
        }

        CString value;
        BOOL finalAnswer = FALSE;
        CString flag(lpch, lpchEnd - lpch);
        int ncurr=0;
        CString currFlag;
        while (ncurr < lpchEnd - lpch)
        {
			BOOL bNegated = FALSE;
            currFlag = "";
            // Get next flag... first, is it negated?
			if (flag[ncurr] == '!')
			{
				bNegated = TRUE;
				ncurr++;
			}
			// ...get flag name
            for (; ncurr < lpchEnd-lpch
                && flag[ncurr] != '|' && flag[ncurr] != ' '; ncurr++)
			{
                currFlag += flag[ncurr];
			}
			ASSERT(pSymbols);
            if ((bNegated == FALSE && m_pCodeGen->DoesSymbolExist(currFlag))
				|| (bNegated == TRUE && !m_pCodeGen->DoesSymbolExist(currFlag)))
            {
                finalAnswer = TRUE;
                break;
            }
            // Reset ncurr to beginning of next flag
            for (; ncurr < lpchEnd-lpch &&
                (flag[ncurr] == '|' || flag[ncurr] == ' '); ncurr++);
        }
        m_pCurState->m_bOneOutput = m_pCurState->m_bOutput = finalAnswer;
        m_pCurState->m_mode = inIf;
        m_pCurState->m_nLine = m_pCodeGen->m_nLine;
    }
    else if (Match(lpch, "ELIF("))
    {
        if (m_pCurState->m_mode != inIf)
        {
			m_pCodeGen->ReportAndThrow(IDS_CG_BAD_ELIF);
        }
        if (m_pCurState->m_bOneOutput)
        {
            // already had output (ignore this until ENDIF)
            m_pCurState->m_bOutput = FALSE;
        }
        else
        {
            // still looking for TRUE conditional
            goto Lif;
        }
    }
    else if (Match(lpch, "ELSE"))
    {
        if (m_pCurState->m_mode != inIf)
        {
			m_pCodeGen->ReportAndThrow(IDS_CG_BAD_ELSE);
        }
        m_pCurState->m_mode = inElse;
        m_pCurState->m_bOneOutput = m_pCurState->m_bOutput = !m_pCurState->m_bOneOutput;
    }
    else if (Match(lpch, "ENDIF"))
    {
        if (m_pCurState->m_mode != inIf && m_pCurState->m_mode != inElse)
        {
			m_pCodeGen->ReportAndThrow(IDS_CG_BAD_ENDIF);
        }

        if (m_iCurState > 0)
        {
            // restore previous state
            m_pCurState = &m_states[--m_iCurState];
        }
        else
        {
            ASSERT(m_pCurState == &m_states[0]);
            m_pCurState->m_mode = idle;
            m_pCurState->m_bOutput = TRUE;
        }
    }
    else
    {
        // symbol at the start of a line - not special
        return FALSE;
    }

    return TRUE; // processed - ignore the rest of this line
}

/////////////////////////////////////////////////////////////////////////////
// The CCodeGen class-- handles one unit (e.g., file) of a project's
//   generation.


// Construction: If there's currently a CProjGen, have it initialize this
//  codegen with the current "loop state".  If CProjGen is parsing through
//  a loop in newproj.inf, the codegen must be aware of this, so it looks
//  up all its variables correctly, and so it can balk an attempt to further
//  loop within codegen's template.
CCodeGen::CCodeGen()
{
	m_pSymbols = NULL;
	m_pOutput = NULL;
	m_bLoopInProjGen = FALSE;
	m_lpszBeginLoop = NULL;
	m_nBeginLoop = -1;
	m_nIteration = -1;
	m_nTotalIterations = 0;
	m_bGeneratingWorklist = FALSE;
	m_nLine = 0;
	CProjGen::InitCodeGen(this);
	ASSERT(!m_strTemplateName.IsEmpty());
}

// This ties together the codegen class.  It coordinates the master parse through
//  the template and calls to process the directives & symbols.
void CCodeGen::Go(LPCTSTR lpszInput, DWORD dwSize, OutputStream* pOutput, CMapStringToString* pSymbols)
{
	if (lpszInput == NULL)
	{
		m_nLine = 0;
		ReportAndThrow(IDP_NULL_TEMPLATE);
		return;
	}

	// Initialize CCodeGen's member variables
	m_pSymbols = pSymbols;
	m_pOutput = pOutput;
	m_nLine = 1;
	m_state.m_pCodeGen = this;

    // parsed textual output
	LPCTSTR lpszBeginning = lpszInput;	// Remember beginning to keep track of size

    // output a line at a time (zero terminated)
    while ((DWORD) (lpszInput-lpszBeginning+1) <= dwSize && *lpszInput != '\0')
    {
        // find the end of the line
        LPCTSTR lpchEnd = _tcschr(lpszInput, '\n');
        if (lpchEnd == NULL)
        {
			m_pSymbols = NULL;
			ReportAndThrow(IDS_CG_MISSING_EOL);
        }
        int nLen = lpchEnd - lpszInput;
        ASSERT(*lpchEnd == '\n');
        lpchEnd = _tcsinc(lpchEnd);  // skip ending '\n'

        if (!m_state.Process(lpszInput, &lpchEnd))
        {
            CString strBuff = "";

            if (m_state.IsOutput())
            {
				// First, deal with looping.  If we loop back up, lpszInput will
				//  update to reflect this, and ProcessControl returns TRUE.
				if (ProcessControl(lpszInput, lpchEnd))
					continue;

                Translate(strBuff, lpszInput);
                m_pOutput->WriteLine(strBuff);
            }
        }
        lpszInput = lpchEnd;
		m_nLine++;
    }

	// Check for EOF type of errors.  First, did we hit a NULL before EOF?
	if (IsUserAWX() && *lpszInput == '\0' && (DWORD) (lpszInput-lpszBeginning+1) <= dwSize)
	{
		ReportAndThrow(IDS_CG_STRAY_NULL);
	}

	// Second: EOF before $$ENDIF
    if (m_state.m_iCurState != 0 || m_state.m_pCurState->m_mode != State::idle)
    {
		m_nLine = m_state.m_pCurState->m_nLine;
		ReportAndThrow(IDS_CG_NO_ENDIF);
	}

	// Third: EOF before $$ENDLOOP
	if (!m_bLoopInProjGen &&
		(m_nBeginLoop != -1 || m_lpszBeginLoop != NULL 
			|| m_nIteration != -1 || m_nTotalIterations != 0))
	{
			// Test our own sanity... if any of these are set, they should all be set.
			ASSERT(m_nBeginLoop != -1 && m_lpszBeginLoop != NULL 
				&& m_nIteration != -1 && m_nTotalIterations != 0);
			ReportAndThrow(IDS_CG_EOF_IN_LOOP);
	}

	// De-initialize member variables
	m_pSymbols = NULL;
	m_pOutput = NULL;
	m_state.m_pCodeGen = NULL;
}

// Seeks lpch to the beginning of the line after the next $$ENDLOOP.  Used
//  in $$BEGINLOOP(0).
void CCodeGen::ScanToAfterEndloop(LPCTSTR& lpch)
{
	while (*lpch != NULL && !Match(lpch, "$$ENDLOOP"))
	{
		lpch = _tcschr(lpch, '\n') + 1;
		m_nLine++;
	}

	if (*lpch == NULL)
		return;

	lpch = _tcschr(lpch, '\n') + 1;
	m_nLine++;
}
	

// This checks to see if there's a control directive ($$BEGINLOOP, $$ENDLOOP, $$INCLUDE, $$SET_DEFAULT_LANG)
//  to process, and if so, it processes it.
BOOL CCodeGen::ProcessControl(LPCTSTR& lpch, LPCTSTR lpchEnd)
{
	LPCTSTR lpchOrig = lpch;

    if (*lpch != '$' || !Match(lpch, "$$"))
        return FALSE;

	BOOL bReturn = TRUE;
	if (Match(lpch, "BEGINLOOP("))
	{
		if (m_nIteration != -1 || m_nBeginLoop != -1
			|| m_nTotalIterations != 0 || m_lpszBeginLoop != NULL)
		{
			// Check our own sanity: if any of these are set, they
			//  must all be set
			ASSERT (m_nIteration != -1 && m_nBeginLoop != -1
				&& m_nTotalIterations != 0 && m_lpszBeginLoop != NULL);
			ReportAndThrow(IDS_CG_LOOP_IN_LOOP);
		}
        LPCTSTR lpchEndVar = _tcschr(lpch, ')');
        if (lpchEndVar == NULL || lpchEndVar - lpch == 0)
        {
			ReportAndThrow(IDS_CG_BAD_BEGINLOOP);
        }

        CString strIterationsKey(lpch, lpchEndVar - lpch);
		CString strIterationsVal;
		if (!GetSymbol(strIterationsKey, strIterationsVal))
		{
			ReportAndThrow(IDS_CG_UNDEF_IN_BEGINLOOP);
		}
		m_nTotalIterations = atoi(strIterationsVal);
		if (m_nTotalIterations < 0)
		{
			ReportAndThrow(IDS_CG_BAD_ITERATIONS);
		}
		if (m_nTotalIterations == 0)
		{
			// A $$BEGINLOOP(0) should iterate zero times.  Thus, scan
			//  for the matching $$ENDLOOP and ignore everything before it
			lpch = lpchEnd;
			m_nLine++;
			ScanToAfterEndloop(lpch);
		}
		else
		{
			// Here we have a $$BEGINLOOP(positive integer)
			m_nIteration = 0;
			lpch = m_lpszBeginLoop = lpchEnd;
			m_nBeginLoop = ++m_nLine;
			// If we're generating the worklist, *retain* the beginloop & endloop directives
			//  while unfolding the loop, so that during GenerateFromWorklist, CProjGen
			//  will know at what points to up its iteration count.
			if (m_bGeneratingWorklist)
				m_pOutput->WriteLine("$$BEGINLOOP");
		}
	}
	else if (Match(lpch, "ENDLOOP"))
	{
		m_nIteration++;
		if (m_nIteration == m_nTotalIterations)
		{
			// Here, we're done iterating
			m_nIteration = -1;
			m_nTotalIterations = 0;
			m_lpszBeginLoop = NULL;
			m_nBeginLoop = -1;
			lpch = lpchEnd;
			m_nLine++;
			// If we're generating the worklist, *retain* the beginloop & endloop directives
			//  while unfolding the loop, so that during GenerateFromWorklist, CProjGen
			//  will know at what points to up its iteration count.
			if (m_bGeneratingWorklist)
				m_pOutput->WriteLine("$$ENDLOOP");
		}
		else
		{
			if (m_lpszBeginLoop == NULL || m_nBeginLoop == -1
				|| m_nIteration == -1 || m_nTotalIterations == 0)
			{
				// If one is unset, all must be unset
				ASSERT (m_lpszBeginLoop == NULL && m_nBeginLoop == -1
					&& m_nIteration == -1 && m_nTotalIterations == 0);
				ReportAndThrow(IDS_CG_EL_NO_BL);
			}
			lpch = m_lpszBeginLoop;
			m_nLine = m_nBeginLoop;
			if (m_bGeneratingWorklist)
				m_pOutput->WriteLine("$$BEGINLOOP");
		}
	}
	else if (Match(lpch, "INCLUDE("))
	{
        // Bad include syntax?
		LPCTSTR lpchEndVar = _tcschr(lpch, ')');
        if (lpchEndVar == NULL || lpchEndVar - lpch == 0)
        {
			ReportAndThrow(IDS_CG_BAD_INCLUDE);
        }

        // Bad include arg?
		CString strIncludeKey(lpch, lpchEndVar - lpch);
		CString strIncludeVal;
		if (!GetSymbol(strIncludeKey, strIncludeVal))
		{
			ReportAndThrow(IDS_CG_UNDEF_IN_INCLUDE);
		}

		// Recursive include call?
		if (g_IncludeStack.Lookup(strIncludeVal))
		{
			g_IncludeStack.Clear();
			ReportAndThrow(IDS_CG_RECURSIVE_INCLUDE, strIncludeVal);
		}

		// Are we inside a loop?  If so, transfer the insideness to the next
		//  codegen that gets created
		CProjGen* pProjGen = CProjGen::GetCurrent();
		if (m_nIteration != -1)
			pProjGen->SetCurrentIteration(m_nIteration);

		LoadAndProcessTemplate(strIncludeVal, m_pOutput);

		// If we're inside a loop, reset the projgen
		if (m_nIteration != -1)
			pProjGen->ResetCurrentIteration();

		lpch = lpchEnd;
	}
	else if (Match(lpch, "SET_DEFAULT_LANG("))
	{
		LPCTSTR lpchEndVar = _tcschr(lpch, ')');
		if (lpchEndVar == NULL || lpchEndVar - lpch == 0)
		{
			ReportAndThrow(IDS_CG_BAD_SETDEFLANG);
		}
		CString strLangKey(lpch, lpchEndVar - lpch);
		CString strLangVal;
		if (!GetSymbol(strLangKey, strLangVal))
		{
			ReportAndThrow(IDS_CG_UNDEF_IN_SETDEFLANG);
		}
		// Inform the langDlls class that the default language has changed.  Only
		//  show error if this is not an extension (since extensions can get
		//  localized templates independent of the appwz*.dll's).
		if (!langDlls.SetDefaultLang(strLangVal) && !IsUserAWX())
			ReportAndThrow(IDS_CG_BADLANG_IN_SETDEFLANG, strLangVal);

		lpch = lpchEnd;

		// If we're generating the worklist, *retain* the set_default_lang directives
		//  while unfolding the loop, so that during GenerateFromWorklist, CProjGen
		//  will know at what points to set the default lang
		if (m_bGeneratingWorklist)
		{
			m_pOutput->WriteLine("$$SET_DEFAULT_LANG" + strLangVal);
		}
	}
    else if (Match(lpch, "NEWPROJ("))
    {
        LPCTSTR lpchEndVar = _tcschr(lpch, ')');
        if (lpchEndVar == NULL || lpchEndVar - lpch == 0)
        {
            ReportAndThrow(IDS_CG_BAD_NEWPROJ);
        }
        
        // Expand the macro, if any
        CString strNewProjKey(lpch, lpchEndVar - lpch);
        CString strNewProjVal;
        if (!GetSymbol(strNewProjKey, strNewProjVal))
        {
            ReportAndThrow(IDS_CG_UNDEF_IN_NEWPROJ);
        }

        // Are we inside a loop?  If so, throw a tantrum
        if (m_nIteration != -1)
            ReportAndThrow(IDS_CG_LOOP_IN_NEWPROJ);

        // We have to create the new AppWizTermStatus
        ASSERT (pTermStatus->nextAppWizTermStatus == NULL);
        pTermStatus->nextAppWizTermStatus = new AppWizTermStatus;
        pTermStatus = pTermStatus->nextAppWizTermStatus;
        
        // Initialize the variables, otherwise they might contain junk
        pTermStatus->nextAppWizTermStatus = NULL;
        memset(pTermStatus->szFullName, '\0', MAX_PATH);

        // Copy the new name. We can add the full path later on
        ASSERT (_MAX_PATH > strNewProjVal.GetLength());
        strncpy(pTermStatus->szFullName, LPCTSTR(strNewProjVal), strNewProjVal.GetLength());

        
        // If we are generating a worklist, we have to put the
        // NewProj directive back in, so that we can start generating
        // the project properly. Remember we are not sending in the name though
        if (m_bGeneratingWorklist)
            m_pOutput->WriteLine("$$NEWPROJ");

        lpch = lpchEnd;
    }
	else
	{
		lpch = lpchOrig;
		bReturn = FALSE;
	}
	
	return bReturn;
}


#define BUFFER_INC_SIZE 1000   // Amount to increment buffer size

// This helper function is used in Translate to increase the buffer
//  size just before it's about to be exceeded.
void readjustBuf(
    char*& sBuf,        // Points to beginning of buffer
    int& iCurr,         // Index where next character may be inserted into buffer
    CString& pchOut,    // The CString the buffer is created from
    int& iMax)          // Maximum allowed index into buffer
{
    pchOut.ReleaseBuffer(iCurr);
    iMax += BUFFER_INC_SIZE;
    sBuf = pchOut.GetBuffer(iMax + 1);
}

// After all directives have been handled, this takes an ordinary template
//  line, and takes care of the rest (expanding all symbols).
void CCodeGen::Translate(CString& pchOut, LPCTSTR lpch)
{
    char* sBuf = pchOut.GetBuffer(BUFFER_INC_SIZE);
    int iCurr = 0;           // Current index into pchOut.
    int iMax = BUFFER_INC_SIZE - 1;  // Maximum allowed index into buffer
    while (*lpch != '\n' && *lpch != '\0')
    {
        if (lpch[0] == '$' && Match(lpch, "$$"))
        {
            // process it
            LPCTSTR lpchEnd = _tcschr(lpch, '$');
            if (lpchEnd == NULL || lpchEnd[1] != '$')
            {
				ReportAndThrow(IDS_CG_MISSING_DLR);
            }
			
            CString szKey(lpch, lpchEnd - lpch);
            if (szKey.IsEmpty())
            {
                // $$$$ => $$
                if (iCurr + 2 > iMax)
                    readjustBuf(sBuf, iCurr, pchOut, iMax);
                *(sBuf + iCurr++) = '$';
                *(sBuf + iCurr++) = '$';
            }
            else
            {
                CString value;
                if (!GetSymbol(szKey, value))
                {
					ReportAndThrow(IDS_CG_UNDEFINED_SYMBOL, szKey);
                }
                else
                {
                    int nLength = value.GetLength();
                    if (iCurr + nLength + 1 > iMax)     // +1 cuz strcpy copies null
                    {
                        readjustBuf(sBuf, iCurr, pchOut, iMax);
						
                        // We better make sure that "value" isn't so huge that one buffer-
                        //  increase still isn't enough space to allocate for it.
                        if (iCurr + nLength + 1 > iMax)
                        {
                            // Here, a buffer-increase was not enough, so revert to
                            //  the old CString +=.  This should RARELY happen.
                            pchOut.ReleaseBuffer(iCurr);
                            pchOut += value;
                            iCurr += nLength;
							
                            // Now, readjust the buffer by another BUFFER_INC_SIZE
                            iMax = pchOut.GetLength() + BUFFER_INC_SIZE;
                            sBuf = pchOut.GetBuffer(iMax + 1);
                        }
                        else
                        {
                            // Here, one buffer-increase was enough.
                            _tcscpy(sBuf+iCurr, (const TCHAR*) value);
                            iCurr += nLength;
                        }
						
                    }
                    else
                    {
                        // Here, we did not even need a buffer-increase.
                        _tcscpy(sBuf+iCurr, (const TCHAR*) value);
                        iCurr += nLength;
                    }
                }
            }
            lpch = lpchEnd + 2; // skip past second "$$"
        }
		else
        {
            // just a normal character
            // Store in buffer
			if (*lpch != '\r')
			{
				// Don't copy over '\r's
				int nCLength = _tclen(lpch);
            	if (iCurr + nCLength > iMax)
	                readjustBuf(sBuf, iCurr, pchOut, iMax);
            	_tccpy(sBuf + iCurr, lpch);
				iCurr += nCLength;
			}
			lpch = _tcsinc(lpch);
        }
    }
    pchOut.ReleaseBuffer(iCurr);
}

// Returns whether we're currently inside a $$BEGINLOOP, and asserts
//  that the loop-variables aren't contradictary.
BOOL CCodeGen::InLoop()
{
	if (m_nIteration == -1)
	{
		ASSERT(m_nTotalIterations == 0);
		ASSERT(m_lpszBeginLoop == NULL);
		return FALSE;
	}
	else
	{
		ASSERT(m_nTotalIterations != 0);
		ASSERT(m_lpszBeginLoop != NULL);
		return TRUE;
	}
}


// Generates a key name based on the current loop status.
// Example:  If we're in iteration #4,
//				KEY -> KEY_4
//			 If we're not in a loop,
//				KEY -> <empty string>
void CCodeGen::GetLoopKey(LPCTSTR lpszKey, CString& rStrLoopKey)
{
	if (!InLoop())
		rStrLoopKey.Empty();
	else
		rStrLoopKey.Format("%s_%d", lpszKey, m_nIteration);
}

// Look for non-empty string keyed by loop key or verbatim key.
BOOL CCodeGen::DoesSymbolExist(LPCTSTR lpszKey)
{
	ASSERT(m_pSymbols != NULL);
	ASSERT_VALID(m_pSymbols);

	CString strLoopKey;
	GetLoopKey(lpszKey, strLoopKey);

	CString tmp;

	// If we're in a loop and the loop key is there, return TRUE
	if (!strLoopKey.IsEmpty() && m_pSymbols->Lookup(strLoopKey, tmp) && !tmp.IsEmpty())
		return TRUE;

	// Otherwise, just check the key verbatim
	return (m_pSymbols->Lookup(lpszKey, tmp) && !tmp.IsEmpty());
}

// Find first occurrence of value keyed by loop key or verbatim key, even if that
//  first occurrence is an empty string.
BOOL CCodeGen::GetSymbol(LPCTSTR lpszKey, CString& rStrValue)
{
	ASSERT(m_pSymbols != NULL);
	ASSERT_VALID(m_pSymbols);

	CString strLoopKey;
	GetLoopKey(lpszKey, strLoopKey);

	// If we're in a loop and the loop key is there, return TRUE
	if (!strLoopKey.IsEmpty() && m_pSymbols->Lookup(strLoopKey, rStrValue))
		return TRUE;

	// Otherwise, just check the key verbatim
	return (m_pSymbols->Lookup(lpszKey, rStrValue));
}


/////////////////////////////////////////////////////////////////////////////
// Error reporting

// Reports error during code generation, and throws an exception.
//  This reports EXTENSION ERRORS
void CCodeGen::ReportAndThrow(UINT nIDP, LPCTSTR lpszArg)
{
	ASSERT(!m_strTemplateName.IsEmpty());

	// strFormat contains the format of the entire error string,
	//  including context information
	CString strFormat;
	strFormat.LoadString(IDP_GENERAL_ERROR);

	// strMessage is the specific error, including one optional argument
	CString strMessage;
	if (lpszArg)
		AfxFormatString1(strMessage, nIDP, lpszArg);
	else
		strMessage.LoadString(nIDP);

	// Now generate the actual error string.
	CString strPrompt;
	strPrompt.Format(strFormat, (LPCTSTR) m_strTemplateName, m_nLine, (LPCTSTR) strMessage);

    MyMessageBox(strPrompt);

    AfxThrowUserException();
}

// Reports generic EXTENSION ERRORS
void ReportErrorExt(UINT nIDP, LPCTSTR lpszArg /* = NULL */)
{
	// strMessage is the specific error, including one optional argument
	CString strMessage;
	if (lpszArg)
		AfxFormatString1(strMessage, nIDP, lpszArg);
	else
		strMessage.LoadString(nIDP);

	// Now generate the actual error string
	CString strPrompt;
	AfxFormatString1(strPrompt, IDP_EXTENSION_ERROR, (LPCTSTR) strMessage);
	
	MyMessageBox(strPrompt);
}

// Reports generic EXTENSION ERRORS and throws a user exception
void ReportAndThrowExt(UINT nIDP, LPCTSTR lpszArg /* = NULL */)
{
	ReportErrorExt(nIDP, lpszArg);
    AfxThrowUserException();
}

// Reports any generic error and throws a user exception
void ReportAndThrow(UINT nIDP, LPCTSTR lpszArg)
{
    CString strPrompt;
    //_tcsupr(lpszArg);     // cheat - force reported names to upper case
    AfxFormatString1(strPrompt, nIDP, lpszArg);
    MyMessageBox(strPrompt);

    AfxThrowUserException();
}

/////////////////////////////////////////////////////////////////////////////
// The CProjGen class-- handles the whole of project generation.

// Helper used in CProjGen's Go below.  Takes a worklist and makes sure
//  the files we're about to generate don't already exist.
void CheckExistingFromWorkList(CStringList& list)
{
    pTermStatus = &g_TermStatus;

    // first check we can create the files and directories
    POSITION pos = list.GetHeadPosition();
    while (pos)
    {
        CString const& s = list.GetNext(pos);

        if (s.IsEmpty() || s == "$$BEGINLOOP" || s == "$$ENDLOOP"
			|| s.Left(18) == "$$SET_DEFAULT_LANG")
            continue;   // just a comment or control directive

        if (s == "$$NEWPROJ") 
        {
            pTermStatus = pTermStatus->nextAppWizTermStatus;
            struct _stat st;
            if (_stat(pTermStatus->szFullName, &st) == 0 && !(st.st_mode & _S_IFDIR))
            {
                // it exists, but is not a directory
                ReportAndThrow(IDP_DIRECT_IS_FILE, pTermStatus->szFullName);
            }
            // TODO: ShankarV: SHOULD WE NOT CHANGE DIR AT THIS POINT???
            // so that the rest of the directory creation will be 
            // part of the new project directory.
            continue;
        }
            
        if (s[0] == '/')
        {
            // if the name exists it must be a directory
            CString dirName = s.Mid(1);
            struct _stat st;
            if (_stat(dirName, &st) == 0 && !(st.st_mode & _S_IFDIR))
            {
                // it exists, but is not a directory
                ReportAndThrow(IDP_DIRECT_IS_FILE, dirName);
            }
            continue;
        }
        int iSplit = s.Find('\t');
        if (iSplit == -1)
        {
            TRACE("illegal work list item '%s'\n", (const char*)s);
			ReportAndThrowExt(IDS_CG_BAD_WL_ITEM, s);
        }
        CString fileName = s.Mid(iSplit+1);
        struct _stat st;
        if (_stat(fileName, &st) == 0)
        {
            // it already exists
            UINT nIDP = (st.st_mode & _S_IFDIR) ?
                IDP_FILE_IS_DIRECT : IDP_FILE_EXISTS;
            ReportAndThrow(nIDP, fileName);
        }
    }

    // Reinitialize pTermStatus to the beginning of the list
    pTermStatus = &g_TermStatus;
}

// Helper used in CProjGen's Go below.  Takes a worklist and makes sure
//  there are no duplicate filenames
void CheckDuplicateInWorkList(CStringList& list)
{
	
    // TODO: ShankarV: Allow dup filnames in muliple projects
    // First make list of just the to-be-generated filenames
	CStringList listJustFiles;
	POSITION pos = list.GetHeadPosition();
    while (pos != NULL)
    {
        CString const& s = list.GetNext(pos);

        if (s.IsEmpty() || s == "$$BEGINLOOP" || s == "$$ENDLOOP" || s =="$$NEWPROJ"
			|| s.Left(18) == "$$SET_DEFAULT_LANG")
            continue;   // just a comment or control directive

        if (s[0] == '/')
			// Skip directory names
            continue;

        int iSplit = s.Find('\t');
		// This should have been caught in CheckExistingFromWorklist
		ASSERT (iSplit != -1);
        CString fileName = s.Mid(iSplit+1);
		listJustFiles.AddTail(fileName);
	}

    // TODO: ShankarV: Move this piece of code into a separate file so that
    // this may be called everytime we generate you new project
    pos = listJustFiles.GetHeadPosition();
	while (pos != NULL)
	{
		// Get next filename to check for duplicates
		CString strFile = listJustFiles.GetNext(pos);

		// Scan all filenames following strFile in the list, and make sure
		//  none of them duplicate strFile.
		POSITION pos2 = pos;
		while (pos2 != NULL)
		{
			CString strFile2 = listJustFiles.GetNext(pos2);
			if (!strFile.CompareNoCase(strFile2))
	            ReportAndThrow(IDP_DUPLICATE_FILEGEN, strFile);
		}

    }

}

// This coordinates the entire project generation process: It gets a worklist,
//  parses through it, and creates CCodeGens to generate each file.
void CProjGen::Go(CWnd* pProjStatus, CWnd* pFileStatus)
{
	ASSERT(pProjStatus != NULL);
	ASSERT(pFileStatus != NULL);

	m_pProjStatus = pProjStatus;
	m_pFileStatus = pFileStatus;

    // first get a work-list
	ListStream workList;

	m_bGeneratingWorklist = TRUE;
	LoadAndProcessTemplate("newproj.inf", &workList);
	m_bGeneratingWorklist = FALSE;
	m_strTemplateName.Empty();

    CheckExistingFromWorkList(workList.list);
	CheckDuplicateInWorkList(workList.list);
   	GenerateFromWorkList(workList.list);
}

// Takes a codegen and fills it with the current "loop" state, and the
//  current template name.  This is called from the codegen's constructor.
void CProjGen::InitCodeGen(CCodeGen* pCodeGen)
{
	ASSERT(!pCodeGen->InLoop());

	CProjGen* pProjGen = GetCurrent();
	if (pProjGen != NULL)
	{
		pCodeGen->m_bGeneratingWorklist = pProjGen->m_bGeneratingWorklist;
		if(pProjGen->InLoop())
		{
			pCodeGen->m_lpszBeginLoop = "";
			pCodeGen->m_nIteration = pProjGen->m_nIteration;
			pCodeGen->m_nTotalIterations = 1;
			pCodeGen->m_bLoopInProjGen = TRUE;
		}
		pCodeGen->m_strTemplateName = pProjGen->m_strTemplateName;
		ASSERT(!pCodeGen->m_strTemplateName.IsEmpty());
	}
}

// There is at most one project generator at a given time.  GetCurrent() and
//  SetCurrent() manipulate this pointer.

CProjGen* CProjGen::GetCurrent()
{
	return s_pProjGen;
}

void CProjGen::SetCurrent(CProjGen* pProjGen)
{
	ASSERT(pProjGen == NULL || s_pProjGen == NULL);		// Can have only one CProjGen
	s_pProjGen = pProjGen;
}

// This reads the flags to the left of a filename in newproj.inf, and
//  returns an int with the corresponding bits set.
// Examples:
//  =root.ico		Use CopyTemplate rather than ProcessTemplate
//  *confirm.inf	Load directly from appwiz's resources-- don't try extension's
//	+root.cpp		Add the file root.cpp generates to the project
#define FF_BINARY				0x01
#define FF_LOAD_FROM_APPWIZ		0x02
#define FF_ADD_TO_PROJECT		0x04
#define FF_NOT_IN_PROJECT		0x08
#define FF_EXCLUDE_FROM_BUILD  0x10
#define FF_HELP_FILE		   0x20
#define FF_RESOURCE_FILE	   0x40
#define FF_TEMPLATE_FILE	   0x80
int GetFileFlags(CString& strFileName)
{
	int nFlags = 0;
	int i = 0;
	BOOL bLoop = TRUE;
	do
	{
		char c = strFileName[i++];
		switch ( c )
		{
			case '=' :
				nFlags |= FF_BINARY;
				break;
			case '*' :
				nFlags |= FF_LOAD_FROM_APPWIZ;
				break;
			case '+' :
				nFlags |= FF_ADD_TO_PROJECT;
				break;
			case '-' : // REVIEW
				nFlags |= FF_NOT_IN_PROJECT;
				break;
			case '!' : // REVIEW: make sure not valid first char
				nFlags |= FF_EXCLUDE_FROM_BUILD;
				break;
			case '?' :
				nFlags |= FF_HELP_FILE;
				break;
			case '#' :
				nFlags |= FF_TEMPLATE_FILE;
				break;
			case ':' :
				nFlags |= FF_RESOURCE_FILE;
				break;
			default:
				bLoop = FALSE;	// done
				break;
		}
	} while (bLoop);

	strFileName = strFileName.Mid(i-1);
	return nFlags;
}


// Takes a generated worklist, and generates the project files from it.
void CProjGen::GenerateFromWorkList(CStringList& list)
{
    // save original directory
    char szOrigDir[_MAX_DIR];
    if (_getcwd(szOrigDir, _MAX_DIR) == NULL)
        szOrigDir[0] = '\0';

    // Initialize AppWizTermStatus
    pTermStatus = &g_TermStatus;

    if (m_pProjStatus != NULL)
        m_pProjStatus->SetWindowText(projOptions.m_strProj);
    // now for each item in the work list, do it
	pTermStatus->strDefFile.Empty();
	//pTermStatus->strClwFile.Empty();
    POSITION pos = list.GetHeadPosition();
    while (pos)
    {
        CString const& s = list.GetNext(pos);

        if (s.IsEmpty())
            continue;   // just a comment

		if (s == "$$BEGINLOOP")
		{
			m_nIteration++;
			continue;
		}

		if (s == "$$ENDLOOP")
		{
			m_nIteration = -1;
			continue;
		}

        if (s == "$$NEWPROJ")
        {
            pTermStatus = pTermStatus->nextAppWizTermStatus;
            pTermStatus->strDefFile.Empty();
            // pTermStatus->strClwFile.Empty();

            // restore to original directory in case a $$NEWPROJ directive 
            // was already used
            if (szOrigDir[0] != '\0')
                _chdir(szOrigDir);
			
            // Create Directory and change to it
            CreateDirectory(pTermStatus->szFullName, TRUE);
            continue;
        }

		if (s.Left(18) == "$$SET_DEFAULT_LANG")
		{
			// Shift over strlen("$$SET_DEFAULT_LANG") characters
			//  to get to language suffix
			LPCTSTR szLangVal = ((LPCTSTR) s) + 18;

			// Now make that be the default language.  Since we made sure
			//  this worked while processing newproj.inf to make this worklist,
			//  the language string should be valid.
			VERIFY (langDlls.SetDefaultLang(szLangVal));
			continue;
		}

        if (s[0] == '/')
        {
            // create a new sub-directory (don't change to it)
            CreateDirectory(s.Mid(1), FALSE);
            continue;
        }
        // work list format is : resname\tfilename

        int iSplit = s.Find('\t');
        if (iSplit == -1)
        {
			ReportAndThrowExt(IDS_CG_BAD_WL_ITEM, (const TCHAR*) s);
        }
        CString resName = s.Left(iSplit);

		// Set flags on this file
		int nFileFlags = GetFileFlags(resName);
		BOOL bBinary = ((nFileFlags & FF_BINARY) != 0);
		BOOL bExclude = ((nFileFlags & FF_EXCLUDE_FROM_BUILD) != 0);
		BOOL bHelpFile = ((nFileFlags & FF_HELP_FILE) != 0);
		BOOL bResFile = ((nFileFlags & FF_RESOURCE_FILE) != 0);
		BOOL bTemplFile = ((nFileFlags & FF_TEMPLATE_FILE) != 0);
		BOOL bNonProject = ((nFileFlags & FF_NOT_IN_PROJECT) != 0);
		g_bLoadFromAppwiz = (nFileFlags & FF_LOAD_FROM_APPWIZ);

        // Get filename, and remember it for IDE project creation
        CString fileName = s.Mid(iSplit+1);
		AddDotIfNecessary(fileName);
		LPCTSTR szFileNameNoDot = RemoveDot(fileName);
		LPCTSTR szExt;

		// Add this as a dependency file if it's not the project .clw file: i.e.,
		//  1) It's not in the CWD, or
		//  2) It has no extension, or
		//  3) It's extension is NOT .clw
		if (_tcschr(szFileNameNoDot, '\\')
			|| ((szExt = _tcsrchr(szFileNameNoDot, '.')) == NULL)
			|| _tcsicmp(szExt, ".clw"))
		{
			// n.b.  Order is important here:
			if (bNonProject)
				pTermStatus->strlNonPrjFiles.AddTail(szFileNameNoDot);
			else if (bTemplFile)
				pTermStatus->strlTemplFiles.AddTail(szFileNameNoDot);
			else if (bExclude)
				pTermStatus->strlNonBldFiles.AddTail(szFileNameNoDot);
			else if (bHelpFile)
				pTermStatus->strlHelpFiles.AddTail(szFileNameNoDot);
			else if (bResFile)
				pTermStatus->strlResFiles.AddTail(szFileNameNoDot);
			else // default
			{
				// Now, ALL files are added to the project.  Source
				//  files are automatically detected as such by the
				//  build system, so we lump them in with all the
				//  dependency files in this string list
				pTermStatus->strlDepFiles.AddTail(szFileNameNoDot);

				// Remember whether it's a .def file
				if (((szExt = _tcsrchr(szFileNameNoDot, '.')) != NULL)
					&& !_tcsicmp(szExt, ".def"))
				{
					pTermStatus->strDefFile = szFileNameNoDot;
				}
			}
		}

        if (m_pFileStatus != NULL)
            m_pFileStatus->SetWindowText(szFileNameNoDot);

        FILE* pfile = fopen(fileName, bBinary ? "wb" : "wt");
        if (pfile == NULL)
            ReportAndThrow(IDP_FILE_CREATE, fileName);

        BOOL bOK = TRUE;
        // BLOCK: generate file
        {
			SetSymbol(_T("FILE_NAME_SYMBOL"), ConstructFileNameInclusionSymbol(fileName));

            FileStream fileGen(pfile);
			g_IncludeStack.Clear();
			LoadAndProcessTemplate(resName, &fileGen, bBinary);
			m_strTemplateName.Empty();

            if (ferror(pfile) != 0)
                bOK = FALSE;
            if (fclose(pfile) != 0)
                bOK = FALSE;
			fileGen.pOpenFile = NULL;  // We closed the file, so the destructor shouldn't
        }

        if (!bOK)
            ReportAndThrow(IDP_FILE_WRITE, fileName);

    }

    // Finally set pTermStatus to its head
    pTermStatus = &g_TermStatus;
    // restore to original directory in case a $$NEWPROJ directive was used
    if (szOrigDir[0] != '\0')
        _chdir(szOrigDir);
}

// Returns whether the project generator is currently in a loop (i.e., a
//  loop in the worklist).
BOOL CProjGen::InLoop()
{
	return (m_nIteration != -1);
}

void LoadAndProcessTemplate(LPCTSTR szTemplateName, OutputStream* pOutput, BOOL bBinary /* = FALSE */)
{
	CProjGen* pProjGen = CProjGen::GetCurrent();

	// Set projgen to name of new template
	if (pProjGen != NULL)
		pProjGen->SetTemplateName(szTemplateName);

	// Load
	DWORD dwSize;
	LPCTSTR szTemplate = LoadTemplateWrapper(szTemplateName, dwSize);
	ASSERT(szTemplate != NULL);	// LoadTemplateWrapper will report & throw if error loading
	
	// Process
	g_IncludeStack.Add(szTemplateName);
	if (bBinary)
		GetAWX()->CopyTemplate(szTemplate, dwSize, pOutput);
	else
		GetAWX()->ProcessTemplate(szTemplate, dwSize, pOutput);
	GetAWX()->PostProcessTemplate(szTemplate);
	VERIFY(g_IncludeStack.Remove(szTemplateName));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\datbdlg.cpp ===
// datbdlg.cpp : implementation file
//

#include "stdafx.h"
#include "mfcappwz.h"
#include "symbols.h"
#include "datbdlg.h"

#pragma warning(disable:4103)
#ifndef VS_PACKAGE
#include <initguid.h>
#include <clwzguid.h>
#endif	// VS_PACKAGE
#pragma warning(default:4103)

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDBDlg dialog

CDBDlg::CDBDlg(CWnd* pParent /*=NULL*/)
    : CSeqDlg(CDBDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDBDlg)
    m_nDBOptions = -1;
    //}}AFX_DATA_INIT
#ifndef VS_PACKAGE
	m_lpWiz = NULL;
#endif	// VS_PACKAGE
}

void CDBDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDBDlg)
    DDX_Radio(pDX, IDC_DB_RADIO, m_nDBOptions);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDBDlg, CSeqDlg)
    //{{AFX_MSG_MAP(CDBDlg)
    ON_BN_CLICKED(IDC_DATA_SOURCE, OnClickedDataSource)
    ON_COMMAND_EX(IDC_DB_RADIO, OnClickedDBOption)
    ON_COMMAND_EX(IDC_DB_HEADER, OnClickedDBOption)
    ON_COMMAND_EX(IDC_DB_SIMPLE, OnClickedDBOption)
    ON_COMMAND_EX(IDC_DB_DOCVIEW, OnClickedDBOption)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDBDlg message handlers

void RemoveCarriageReturns(CString& str)
{
	CString strOld = str;
	str.Empty();
	int nLength = strOld.GetLength();
	for (int i=0; i < nLength; i++)
	{
		if (strOld[i] == '\r')
			continue;
		str += strOld[i];
	}
}

void CDBDlg::RunDataSource(CDialog* dlg)
{
	BOOL bBindAll = TRUE;
	CString strSQL, strConnect, strTableType;
	CStringList columnList;
	CStringList defVarsList;
	CString strParamVars, strParamBindings, strParamMap;

	GetSymbol("DB_SOURCE", strSQL);
	GetSymbol("DB_TABLE_TYPE", strTableType);
	GetSymbol("DB_CONNECT", strConnect);

	BOOL bEnableDAO = !DoesSymbolExist("TARGET_MAC");
	// ASSERT(!projOptions.m_bDAO || bEnableDAO);	// Can't default to DAO if we're disabling DAO
	
#ifndef VS_PACKAGE
	CString     strOpen;
	if (m_lpWiz != NULL)
	{
		CString strTableClass;
		if (SUCCEEDED(m_lpWiz->PickDataSource(projOptions.m_nDataSource, bBindAll, projOptions.m_bAutoDetect,
			bEnableDAO, strSQL, strConnect, strTableType, columnList, defVarsList,
			strParamVars, strParamBindings, strParamMap, strOpen, strTableClass, dlg)))
		{
			SetSymbol("DB_CONNECT", strConnect);
			//SetSymbol("DB_DSN", srcDlg.m_strDatasource);
			if(projOptions.m_nDataSource != dbOledb ){
				SetSymbol("DB_SOURCE", strSQL);
				SetSymbol("DB_DSN", strConnect);
				SetSymbol("DB_TABLE_TYPE", strTableType);
			
				char szCols[MAX_SHORT_TMP];
				wsprintf(szCols, "%d", columnList.GetCount());
				SetSymbol("DB_NUMCOLS", szCols);
	
				CString strInfo = "";
				int n = 1;
				char szT[MAX_SHORT_TMP];
				while (!columnList.IsEmpty())
				{
					wsprintf(szT, "Column%d=", n++);
					strInfo += szT;
					strInfo += columnList.RemoveHead() + '\n';
				}
				SetSymbol("DB_COLSINFO", strInfo);
	
				strInfo.Empty();
				while (!defVarsList.IsEmpty())
					strInfo += defVarsList.RemoveHead() + '\n';
				SetSymbol("DB_VARSINFO", strInfo);
	
				RemoveCarriageReturns(strParamVars);
				RemoveCarriageReturns(strParamBindings);
				RemoveCarriageReturns(strParamMap);
				SetSymbol("PARAM_VARS", strParamVars);
				SetSymbol("PARAM_VAR_BINDINGS", strParamBindings);
				SetSymbol("PARAM_RFX", strParamMap);
			}
			else
			{
				CString strClass = strTableClass; // GetTag destroys the first param before reading the second.
				GetTag(strTableClass,strClass);
				strTableClass =  "C" + strTableClass;
				SetSymbol("DB_SOURCE", strSQL);
				SetSymbol("DB_TABLECLASS",strTableClass);
				SetSymbol("DB_NUMCOLS", columnList.RemoveHead());
				SetSymbol("DB_OPEN", strOpen);
				if( !columnList.IsEmpty() )
					SetSymbol("DB_COLSINFO", columnList.RemoveHead());
				if( !defVarsList.IsEmpty() )
					SetSymbol("DB_VARSINFO", defVarsList.RemoveHead());
			}
		}
		else
		{
			RemoveSymbol("DB_SOURCE");
			RemoveSymbol("DB_DSN");
		}
	}
#endif	// VS_PACKAGE
}

void CDBDlg::UpdateDatasrcText()
{
	CString strMessage;
	CString strSource, strDSN;
#ifndef VS_PACKAGE
	if (m_lpWiz != NULL)
	{
		if( DoesSymbolExist("DB_SOURCE") &&
					(projOptions.m_nDataSource == dbOledb) )
		{
			strMessage.LoadString(IDS_OLEDATASOURCE_TEXT);
			GetDlgItem(IDC_DATASOURCE_TEXT)->SetWindowText(strMessage);
		} else {
			if (m_lpWiz->IsDBAvailable() != S_OK)
			{
				strMessage.LoadString(IDS_NO_ODBC);
				RemoveSymbol("DB_SOURCE");
				RemoveSymbol("DB_DSN");
			}
			else if (!DoesSymbolExist("DB_SOURCE")
				|| !DoesSymbolExist("DB_DSN"))
			{
				AfxFormatString1(strMessage, IDS_NODATASOURCE_TEXT, "");
			}
			else
			{
				GetSymbol("DB_SOURCE", strSource);
				GetSymbol("DB_DSN", strDSN);
				MakeUserString(strDSN);		// need to kill any double backslashes
				AfxFormatString2(strMessage, IDS_DATASOURCE_TEXT, strSource, strDSN);
			}
		}

		GetDlgItem(IDC_DATASOURCE_TEXT)->SetWindowText(strMessage);
	}
#endif	// VS_PACKAGE
}

void CDBDlg::MakeUserString(CString& str)
{
	CString strResult;

	// the output string can't be longer than the input
	LPTSTR lpszOut = strResult.GetBuffer(str.GetLength());
	LPCTSTR lpszIn = str;

	while (*lpszIn)
	{
		// if we have 2 slashes in a row, skip one of them
		_tccpy(lpszOut, lpszIn);
		lpszOut = _tcsinc(lpszOut); 
		lpszIn = _tcsinc(lpszIn);
		if (*lpszIn == _T('\\'))
			lpszIn = _tcsinc(lpszIn);
	}
	*lpszOut = _T('\0');
	strResult.ReleaseBuffer();
	str = strResult;
}

void CDBDlg::OnClickedDataSource()
{
    RunDataSource((CDialog*) m_pParentWnd);
	UpdateDatasrcText();
}

// Hide or show Data Sources button depending current option.
//  Also, update bitmap
BOOL CDBDlg::OnClickedDBOption(UINT nID)
{
    CButton* pDataSrc = (CButton*) GetDlgItem(IDC_DATA_SOURCE);
    if (nID == IDC_DB_RADIO || nID == IDC_DB_HEADER)
    {
        //   pDataSrc->ShowWindow(SW_HIDE);
        pDataSrc->EnableWindow(FALSE);
    }
    else
    {
        // pDataSrc->ShowWindow(SW_SHOW);
        pDataSrc->EnableWindow(TRUE);
		pDataSrc->SetButtonStyle(BS_PUSHBUTTON);
    }
	CMainDlg* pMainDlg = (CMainDlg*) GetParent();
	pMainDlg->RedrawBitmap(BMPSIZE_SUM);
    return TRUE;
}

BOOL CDBDlg::OnInitDialog()
{
#ifndef VS_PACKAGE
	theApp.FindInterface(IID_IClassWizard, (LPVOID*) &m_lpWiz);
#endif	// VS_PACKAGE

    CSeqDlg::OnInitDialog();
	VERIFY(m_btnDataSource.SubclassDlgItem(IDC_DATA_SOURCE, this));
	CString tmp;

	// On the Mac, there is no DAO
	if (DoesSymbolExist("TARGET_MAC"))
		GetDlgItem(IDC_NOMACDAO)->ShowWindow(SW_SHOW);
	else
		GetDlgItem(IDC_NOMACDAO)->ShowWindow(SW_HIDE);

	if (DoesSymbolExist("TARGET_MAC") && !IsMacODBC())
	{
		// MacODBC is not around, so select no ODBC support & disable the controls
		DisableAll();
		CString strMessage;
		strMessage.LoadString(IDS_NO_MACODBC);
		GetDlgItem(IDC_DATASOURCE_TEXT)->SetWindowText(strMessage);
	}
#ifndef VS_PACKAGE
    // ClassWizard interface will be NULL if Java Package only is loaded
	else if (m_lpWiz != NULL && m_lpWiz->IsDBAvailable() != S_OK)
	{
		DisableAll();
		UpdateDatasrcText();
	}
#endif	// VS_PACKAGE
	else if(DoesSymbolExist("NODOCVIEW"))
	{
		GetDlgItem(IDC_DB_SIMPLE)->EnableWindow(FALSE);
		GetDlgItem(IDC_DB_DOCVIEW)->EnableWindow(FALSE);
		m_nDBOptions = 0;
	    UpdateData(FALSE);
		UpdateDatasrcText();
	}
	else
	{
	    ReadValues();
	
	    // Hide/set Data Source button
	    CButton *pDataSrc = (CButton*) GetDlgItem(IDC_DATA_SOURCE);
	    if (m_nDBOptions == 0 || m_nDBOptions == IDC_DB_HEADER-IDC_DB_RADIO)
	    {
	        //   pDataSrc->ShowWindow(SW_HIDE);
	        pDataSrc->EnableWindow(FALSE);
	    }
	    else
	    {
	        // pDataSrc->ShowWindow(SW_SHOW);
	        pDataSrc->EnableWindow(TRUE);
	    }
	
	    UpdateData(FALSE);
		UpdateDatasrcText();
	}
    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDBDlg::DisableAll()
{
	m_nDBOptions = 0;
	UpdateData(FALSE);
	GetDlgItem(IDC_STATIC1)->EnableWindow(FALSE);
	GetDlgItem(IDC_STATIC2)->EnableWindow(FALSE);
	GetDlgItem(IDC_DB_RADIO)->EnableWindow(FALSE);
	GetDlgItem(IDC_DB_HEADER)->EnableWindow(FALSE);
	GetDlgItem(IDC_DB_SIMPLE)->EnableWindow(FALSE);
	GetDlgItem(IDC_DB_DOCVIEW)->EnableWindow(FALSE);
	GetDlgItem(IDC_DATA_SOURCE)->EnableWindow(FALSE);
}

// We override PreTranslate to make sure that if Data Sources button is default,
//  <return> causes it to be activated.
BOOL CDBDlg::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN
		&& ::GetFocus() == GetDlgItem(IDC_DATA_SOURCE)->GetSafeHwnd())
	{
		SendMessage(WM_COMMAND,
			MAKEWPARAM(IDC_DATA_SOURCE, BN_CLICKED),
			(LPARAM) (GetDlgItem(IDC_DATA_SOURCE)->GetSafeHwnd()));
		return TRUE;
	}

	return CSeqDlg::PreTranslateMessage(pMsg);
}

void SetOleSymbols();  // In mfcappwz.cpp.  Referenced in CanDestroy().
BOOL CDBDlg::CanDestroy()
{
	WriteValues();
    CString tmp;
    // We can destroy the dialog, as long as either (1) we don't need a
    //  a data source, or (2) we have a data source.
    if ((m_nDBOptions != IDC_DB_DOCVIEW-IDC_DB_RADIO
        && m_nDBOptions != IDC_DB_SIMPLE-IDC_DB_RADIO)
        || (DoesSymbolExist("DB_SOURCE")))
    {
        // If the user chose an OLE option, give him the chance to escape, lest
        //  OLE return to zero support.  (simple + OLE don't mix).
        if (projOptions.m_bDBSimple == TRUE
            && projOptions.m_nOleType != OLE_NO)
        {
            int nResult = AfxMessageBox(IDP_OLE_THEN_SIMPLE, MB_OKCANCEL);
            if (nResult == IDCANCEL)
                return FALSE;
            projOptions.m_nOleType = OLE_NO;
			SetOleSymbols();    // Reset corresponding symbols to reflect this change.
        }

 		if (m_nDBOptions ==	(IDC_DB_SIMPLE-IDC_DB_RADIO) && IsMDI())	
		{
			// no file support, so we can't be MDI
			// need to give him the chance to escape or at least know
			// what is happening to him
			int nResult = AfxMessageBox(IDP_MDI_THEN_SIMPLE, MB_OKCANCEL);
			if (nResult == IDCANCEL)
				return FALSE;
			SetMDI(FALSE);
		}

		// Ditto for previously selected MAPI support
		if ((projOptions.m_options & (1 << (IDCD_POMAPI-IDCD_POBASE)))
			&& projOptions.m_bDBSimple)
        {
            int nResult = AfxMessageBox(IDP_MAPI_THEN_SIMPLE, MB_OKCANCEL);
            if (nResult == IDCANCEL)
                return FALSE;
            projOptions.m_options &= ~(1 << (IDCD_POMAPI-IDCD_POBASE));
        }
    }
    else
    {
        AfxMessageBox(IDP_DB_NO_DATA_SOURCE);
        return FALSE;
    }
	SetDBSymbols();
	SetBaseViewSymbols();
    return TRUE;
}

void CDBDlg::OnDestroy()
{
#ifndef VS_PACKAGE
    // ClassWizard interface will be NULL if Java Package only is loaded
	if (m_lpWiz != NULL)
        m_lpWiz->Release();
#endif	// VS_PACKAGE
    WriteValues();
    CSeqDlg::OnDestroy();
}

static UINT DBbmp[] =
{
	IDB_B121000, IDB_B120100, IDB_B120001, IDB_B120010,
};

UINT CDBDlg::ChooseBitmap()
{
	for (int i=0; i < 4; i++)
	{
		if (((CButton*) GetDlgItem(IDC_DB_RADIO+i))->GetCheck())
			break;
	}
	ASSERT (((CButton*) GetDlgItem(IDC_DB_RADIO+i))->GetCheck());
	return DBbmp[i];
}

void CDBDlg::ReadValues()
{
	GetDBSymbols();
    // Determine what DBOption is currently selected by examining
    //  data gotten from other dialogs.
    if (projOptions.m_bDBSimple)
        m_nDBOptions = IDC_DB_SIMPLE-IDC_DB_RADIO;
    else if (projOptions.m_names.strBaseClass[classView] == "CRecordView" ||
			projOptions.m_names.strBaseClass[classView] == "COleDBRecordView" ||
			projOptions.m_names.strBaseClass[classView] == "CDaoRecordView")
        m_nDBOptions = IDC_DB_DOCVIEW-IDC_DB_RADIO;
    else if (projOptions.m_bDBHeader)
        m_nDBOptions = IDC_DB_HEADER-IDC_DB_RADIO;
    else
        m_nDBOptions = 0;
}

void CDBDlg::WriteValues()
{
	UpdateData(TRUE);
    // Affect data elsewhere, based on what DB option was selected
    switch(m_nDBOptions)
    {
    case 0:
        projOptions.m_bDBSimple = projOptions.m_bDBHeader = FALSE;
        if (projOptions.m_names.strBaseClass[classView] == "CRecordView" ||
			projOptions.m_names.strBaseClass[classView] == "COleDBRecordView" ||
			projOptions.m_names.strBaseClass[classView] == "CDaoRecordView")
            projOptions.m_names.strBaseClass[classView] = "CView";
        break;
    case IDC_DB_HEADER-IDC_DB_RADIO:
        projOptions.m_bDBSimple = FALSE;
        projOptions.m_bDBHeader = TRUE;
        if (projOptions.m_names.strBaseClass[classView] == "CRecordView" ||
			projOptions.m_names.strBaseClass[classView] == "COleDBRecordView" ||
			projOptions.m_names.strBaseClass[classView] == "CDaoRecordView")
            projOptions.m_names.strBaseClass[classView] = "CView";
        break;
    case IDC_DB_DOCVIEW-IDC_DB_RADIO:
        projOptions.m_bDBSimple = FALSE;
        projOptions.m_bDBHeader = TRUE;
		switch(projOptions.m_nDataSource) {
			case dbOdbc:
				projOptions.m_names.strBaseClass[classView] = "CRecordView";
				break;
			case dbDao:	
				projOptions.m_names.strBaseClass[classView] = "CDaoRecordView" ;
				break;
			case dbOledb:	
				projOptions.m_names.strBaseClass[classView] = "COleDBRecordView" ;
				break;
			default:
				break;
		}
        break;
    case IDC_DB_SIMPLE-IDC_DB_RADIO:
        projOptions.m_bDBSimple = projOptions.m_bDBHeader = TRUE;
		switch(projOptions.m_nDataSource) {
			case dbOdbc:
				projOptions.m_names.strBaseClass[classView] = "CRecordView";
				break;
			case dbDao:	
				projOptions.m_names.strBaseClass[classView] = "CDaoRecordView" ;
				break;
			case dbOledb:	
				projOptions.m_names.strBaseClass[classView] = "COleDBRecordView" ;
				break;
			default:
				break;
		}
        break;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CMyButton
// This class serves the purpose of making an appwiz inner dlg that has a pushbutton
//  act like the user will expect.  When the button gains focus, we take defaultness
//  away from CMainDlg's IDOK, and make it the default.  When it loses focus,
//  defaultness returns to CMainDlg's IDOK.  All this enhances the illusion that
//  the inner dialog is really the same dialog as the outer CMainDlg, and so we don't
//  end up with two or no default pushbuttons.

CMyButton::CMyButton()
{
}

CMyButton::~CMyButton()
{
}


BEGIN_MESSAGE_MAP(CMyButton, CButton)
	//{{AFX_MSG_MAP(CMyButton)
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyButton message handlers

void MakeOKDefault(CMainDlg*);

void CMyButton::OnKillFocus(CWnd* pNewWnd)
{
	CButton::OnKillFocus(pNewWnd);
	CDialog* pParent = (CDialog*) GetParent();

	// This is shameful, but it works.  IDC_BOGUS_DEFBTN is an invisible btn.
	//  In order to tell NT that we REALLY mean it when we say
	//  "SetButtonStyle(BS_PUSHBUTTON)", apparently, NT needs a new defbtn in
	//  its place.  Otherwise, IDC_DATA_SOURCE magically becomes the default
	//  again.  So, we make this hacky call to SetDefID to make sure that
	//  IDC_DATA_SOURCE stays nondefault.
	pParent->SetDefID(IDC_BOGUS_DEFBTN);
	SetButtonStyle(BS_PUSHBUTTON);

	if (pNewWnd == NULL || pNewWnd->GetParent() == NULL
		|| GetParent()->GetParent()->GetSafeHwnd()  // i.e., mainDlgs hwnd
		!= pNewWnd->GetParent()->GetSafeHwnd())     // i.e., wnd containing pNewWnd
	{
		// Here, the new guy with the focus is NOT one of CMainDlg's buttons.
		//  So OK should be the default.  (Otherwise, the new guy with focus should be.)
		MakeOKDefault((CMainDlg*) (GetParent()->GetParent()));
				
	}  
}

void CMyButton::OnSetFocus(CWnd* pOldWnd)
{
	CButton::OnSetFocus(pOldWnd);

	// Now that we have the focus, we should be the default btn, and
	//  none of CMainDlg's buttons should be default.
	CMainDlg* pMainDlg = (CMainDlg*) (GetParent()->GetParent());
    ((CButton*) (pMainDlg->GetDlgItem(IDCANCEL)))->SetButtonStyle(BS_PUSHBUTTON);
    ((CButton*) (pMainDlg->GetDlgItem(IDC_BACK)))->SetButtonStyle(BS_PUSHBUTTON);
    ((CButton*) (pMainDlg->GetDlgItem(IDC_END)))->SetButtonStyle(BS_PUSHBUTTON);
    ((CButton*) (pMainDlg->GetDlgItem(IDOK)))->SetButtonStyle(BS_PUSHBUTTON);
	CDialog* pParent = (CDialog*) GetParent();
	pParent->SetDefID(GetDlgCtrlID());
	SetButtonStyle(BS_DEFPUSHBUTTON);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\datbdlg.h ===
// datbdlg.h : header file
//

#ifndef DATBDLG_H
#define DATBDLG_H

#include "seqdlg.h"

#ifndef VS_PACKAGE
#include <clwzapi.h>
#endif	// VS_PACKAGE

/////////////////////////////////////////////////////////////////////////////
// CMyButton window

class CMyButton : public CButton
{
// Construction
public:
	CMyButton();

// Attributes
public:

// Operations
public:

// Implementation
public:
	virtual ~CMyButton();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMyButton)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDBDlg dialog

class CDBDlg : public CSeqDlg
{
// Construction
public:
	CDBDlg(CWnd* pParent = NULL);	// standard constructor
	virtual BOOL CanDestroy();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void WriteValues();
	virtual UINT ChooseBitmap();

// Dialog Data
	//{{AFX_DATA(CDBDlg)
	enum { IDD = IDD_DB_OPTIONS };
	int		m_nDBOptions;
	//}}AFX_DATA

// Implementation
protected:
#ifndef VS_PACKAGE
	LPCLASSWIZARD m_lpWiz;
#endif	// VS_PACKAGE
	CMyButton m_btnDataSource;
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void ReadValues();
	void UpdateDatasrcText();	
	void DisableAll();
	void RunDataSource(CDialog* dlg);
	void MakeUserString(CString& str);

	// Generated message map functions
	//{{AFX_MSG(CDBDlg)
	afx_msg void OnClickedDataSource();
	afx_msg BOOL OnClickedDBOption(UINT nID);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\exports.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "customaw.h"		// For export macros
#include "lang.h"

/////////////////////////////////////////////////////////////////////////////
// exports.cpp -- Implementation of C API's exported by AppWizard


void SetCustomAppWizClass(CCustomAppWiz* pAW)
{
	projOptions.m_UserExtension.SetCustomAppWizClass(pAW);
}

CAppWizStepDlg* GetDialog(AppWizDlgID nID)
{
	return theDLL.m_pMainDlg->ExtKeyFromID(nID);
}

void SetNumberOfSteps(int nSteps)
{
	theDLL.m_pMainDlg->SetNumberOfSteps(nSteps);
}

BOOL ScanForAvailableLanguages(CStringList& strlLanguages)
{
	if (!langDlls.m_AvailableLangDlls.ScanForAvailableLanguages())
		return FALSE;

	langDlls.m_AvailableLangDlls.GetAvailableLanguages(strlLanguages);
	return TRUE;
}

void SetSupportedLanguages(LPCTSTR szSupportedLangs)
{
	langDlls.m_AvailableLangDlls.SetSupportedLanguages(szSupportedLangs);
}

HRESULT FindInterface(REFIID riid, LPVOID FAR* ppvObj)
{
#ifdef VS_PACKAGE
	return NULL;
#else
	return theApp.FindInterface(riid, ppvObj);
#endif	// VS_PACKAGE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\ddxddv.h ===
#define _MAX_SYMBOL	64

void PASCAL DDV_ClassName(CDataExchange* pDX, CString const& s);
void PASCAL DDV_Symbol(CDataExchange* pDX, CString const& s);
void PASCAL DDV_SymbolCanBeginWithNumber(CDataExchange* pDX, CString const& s);
void PASCAL DDV_FileName(CDataExchange* pDX, CString& s,
			const char* pszExtension);
	// it will append suffix if none there
void PASCAL DDV_ProgID(CDataExchange* pDX, CString const& s);
void PASCAL DDV_ExactChars(CDataExchange* pDX, CString const& s, int nLen);
void PASCAL DDV_Title(CDataExchange* pDX, CString const& s);

BOOL IsValidSymbol(const char* psz, BOOL bCanBeginWithNumber, BOOL bCanHaveAngleBrackets=FALSE);
BOOL IsValidFileName(const char* psz, BOOL bAllowDot);

CString Upper(const char* psz);
CString Lower(const char* psz);
CString TcsLeft(const TCHAR* psz, int nMaxTChars);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\ddxddv.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "ddxddv.h"

/////////////////////////////////////////////////////////////////////////////
// Japanese-specific functions

// This tests whether we're on a Japanese system
inline BOOL IsJapaneseSystem(void)
{
	return (PRIMARYLANGID(GetSystemDefaultLangID()) == LANG_JAPANESE);
}

// This function assumes we're on a Japanese system
BOOL IsSBKatakana(unsigned char c)
{
	return c >= 0xa1 && c <= 0xdf;
}


/////////////////////////////////////////////////////////////////////////////

BOOL IsValidSymbol(const char* psz, BOOL bCanBeginWithNumber, BOOL bCanHaveAngleBrackets )
{
	if (!_istalpha(*psz) && *psz != '_'
		&& !(bCanBeginWithNumber && _istdigit(*psz))
		&& !(bCanHaveAngleBrackets && ( (*psz=='<') || (*psz=='>') )))
	{
		return FALSE;
	}
	if (strlen(psz) >= _MAX_SYMBOL)
		return FALSE;

	psz = _tcsinc(psz);
	while (*psz != NULL)
	{
		if( bCanHaveAngleBrackets ) 
		{
			if (!_istalnum(*psz) && *psz != '_' && *psz != '<' && *psz != '>')
				return FALSE;
		}
		else 
		{
			if (!_istalnum(*psz) && *psz != '_' )
				return FALSE;
		}
		psz = _tcsinc(psz);
	}
	return TRUE;
}

void PASCAL DDV_Symbol(CDataExchange* pDX, CString const& s)
{
	if (!pDX->m_bSaveAndValidate || IsValidSymbol(s, FALSE))
		return;

	AfxMessageBox(IDP_INVALID_SYMBOL, MB_OK, 0);
	pDX->Fail();
}

void PASCAL DDV_SymbolCanBeginWithNumber(CDataExchange* pDX, CString const& s)
{
	if (!pDX->m_bSaveAndValidate || IsValidSymbol(s, TRUE))
		return;

	AfxMessageBox(IDP_INVALID_SYMBOL, MB_OK, 0);
	pDX->Fail();
}

void PASCAL DDV_ClassName(CDataExchange* pDX, CString const& s)
{
	if (!pDX->m_bSaveAndValidate || IsValidSymbol(s, TRUE, TRUE))
		return;

	AfxMessageBox(IDP_INVALID_SYMBOL, MB_OK, 0);
	pDX->Fail();
}

/*
static BOOL LooksLikeAPath(const TCHAR* psz)
{
    while (_istspace(*psz))
        psz = _tcsinc(psz);
    if (*psz == '.')
        return TRUE;        // starting . or ..
    TCHAR ch;
    // we will allow '.' in the middle of a project name
    while ((ch = *psz) != '\0')
    {
		psz = _tcsinc(psz);
        if (ch == '/' || ch == '\\' || ch == ':')
            return TRUE;        // look like a path to me
    }
    return FALSE;       // try it as a project name
}
*/

BOOL IsValidFileName(const char* psz, BOOL bAllowDot)
	// NO PATH (allow suffix optionally)
{
	/*if (LooksLikeAPath(psz))
		return FALSE;

	HANDLE hFile = CreateFile(psz, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW, 
								FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	CloseHandle(hFile);
	return TRUE;*/

	if (*psz == '\0' || *psz == '.')
		return FALSE;
	
	int cchLeft = 8;                // 8 for file name
	DWORD dwMaxLen = 8;
	DWORD  dwDummy1;
	if (::GetVolumeInformation(NULL, NULL, 0, NULL, &dwMaxLen,
		&dwDummy1, NULL, 0))
	{
		// succesfully got info from file system -- use it.
		cchLeft = (int)dwMaxLen;
	}
	
	char ch;
	while ((ch = *psz) != '\0')
	{
		if (_istalnum(ch) || ch == '_' || ch == ' ' || IsDBCSLeadByte(ch)
			|| (IsJapaneseSystem() && IsSBKatakana(ch)) || ch < 0)
		{
			// count the character
			cchLeft -= _tclen(psz);
			if (cchLeft < 0)
				return FALSE;		// to long
		}
		else if (ch != '.' || !bAllowDot)
		{
			// illegal
			return FALSE;
		}
		psz = _tcsinc(psz);
	}
	return TRUE;
}

void PASCAL DDV_FileName(CDataExchange* pDX, CString& s,
			const char* pszExtension)
{
	if (!pDX->m_bSaveAndValidate)
		return;
	if (!IsValidFileName(s, pszExtension != NULL))
	{
		AfxMessageBox(IDP_INVALID_FILENAME, MB_OK, 0);
		pDX->Fail();
	}

	if (pszExtension == NULL)
		return;

	// make sure the suffix is ok
	char szExt[_MAX_EXT];
	_splitpath(s, NULL, NULL, NULL, szExt);
	if (szExt[0] == '\0')
	{
		// no extension - add it
		s += pszExtension;
		return;
	}
	if (_stricmp(szExt, pszExtension) != 0)
	{
		AfxMessageBox(IDP_INVALID_EXTENSION, MB_OK, 0);
		pDX->Fail();
	}
}

BOOL IsValidProgID(const char* psz)
{
	if (!_istalpha(*psz))
		return FALSE;

	psz = _tcsinc(psz);
	while (*psz != NULL)
	{
		if (!_istalnum(*psz) && *psz != '.')
			return FALSE;
		psz = _tcsinc(psz);
	}
	return TRUE;
}

BOOL IsValidTitle(const char* szTitle);		// Defined in miscdlgs.cpp

void PASCAL DDV_Title(CDataExchange* pDX, CString const& s)
{
	if (!pDX->m_bSaveAndValidate || IsValidTitle(s))
		return;
	
	AfxMessageBox(IDP_BAD_TITLE);
	pDX->Fail();
}


void PASCAL DDV_ProgID(CDataExchange* pDX, CString const& s)
{
	if (!pDX->m_bSaveAndValidate || IsValidProgID(s))
		return;

	AfxMessageBox(IDP_INVALID_PROGID, MB_OK, 0);
	pDX->Fail();
}

void PASCAL DDV_ExactChars(CDataExchange* pDX, CString const& s, int nLen)
{
	if (!pDX->m_bSaveAndValidate || s.GetLength() == nLen)
		return;

	CString strPrompt;
	TCHAR tszLen[128];
	sprintf(tszLen, "%d", nLen);
	AfxFormatString1(strPrompt, IDP_EXACT_CHARS, tszLen);
	AfxMessageBox(strPrompt, MB_OK, 0);
	pDX->Fail();
}
		

/////////////////////////////////////////////////////////////////////////////

CString Upper(const char* psz)
{
	CString s = psz;
	ASSERT(!s.IsEmpty());
	s.MakeUpper();
	return s;
}

CString Lower(const char* psz)
{
	CString s = psz;
	ASSERT(!s.IsEmpty());
	s.MakeLower();
	return s;
}

// Returns the largest left substring of psz with <= nMaxTChars TCHARS.
CString TcsLeft(const TCHAR* psz, int nMaxTChars)
{
	CString s = psz;
	TCHAR* pszRet = s.GetBuffer(s.GetLength() + 1);
	int nLength = 0;
	while (*pszRet != '\0')
	{
		nLength += _tclen(pszRet);
		if (nLength > nMaxTChars)
			break;
		pszRet = _tcsinc(pszRet);
	}
	// If we broke out, we need to shorten the string.  End at pszRet.
	*pszRet = '\0';
	s.ReleaseBuffer();
	return s;
}

#ifdef _DEBUG

DWORD MyGetLastError()
{
	return ::GetLastError();
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\extend.h ===
#ifndef __EXTENSION_H__
#define __EXTENSION_H__
#include "myaw.h"


class CUserExtension
{
public:

	// AppWizard APIs
	CUserExtension();
	~CUserExtension();
	void SetCustomAppWizClass(CCustomAppWiz* pAW);
	BOOL Attach(const TCHAR* szUserExtension);
	void Detach();
	CCustomAppWiz* GetAWX() { return m_pAWX; }
	BOOL IsUserAWX()
		{ extern CMyCustomAppWiz MyAWX; return m_pAWX != &MyAWX; }
	HINSTANCE GetInstanceHandle() { return m_hUserDLL; }
	LPCTSTR GetAWXName() { return (LPCTSTR) m_strUserDLL; }
	CString m_strExtensionTitle;
	BOOL m_bCtlWiz;		// Special case: treat ControlWizard differently

protected:
	CCustomAppWiz* m_pAWX;
	CString m_strUserDLL;
	HINSTANCE m_hUserDLL;

	BOOL m_bSetCustomAppWizClassCalled;
	BOOL m_bCalledSetCustomAppWizWithNULL;
};

CCustomAppWiz* GetAWX();
BOOL IsUserAWX();


#endif // __EXTENSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\lang.cpp ===
// lang.cpp : implementation file
//

#include "stdafx.h"
#include "mfcappwz.h"
#include "lang.h"
#include "symbols.h"

#ifndef VS_PACKAGE
#include <slob.h>
#include <utilctrl.h>
#endif // VS_PACKAGE

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef VS_PACKAGE
static const TCHAR* szModuleSubdir1 = "\\";
#else
	#ifdef _DEBUG
		static const TCHAR* szModuleSubdir1 = "\\ided\\";
	#else
		static const TCHAR* szModuleSubdir1 = "\\ide\\";
	#endif //_DEBUG
#endif

LangDlls langDlls;

/////////////////////////////////////////////////////////////////////////////
// Localizable text dll functions

// Return whether the DLL is the user's default language
BOOL GetLangFromDllName(const char* szFileName, CString& strLang, BOOL& bUS, DWORD& dwTranslation)
{
	LPVOID abData;
	DWORD handle;
	UINT dwSize;
	UINT dwDummySize;
	LPVOID lpBuffer;
	CString strUnknown;
	strUnknown.LoadString(IDS_UNKNOWN);
	strLang = strUnknown;

	CString strFileName = theDLL.m_strAppwizDir + szModuleSubdir1 + szFileName;

	dwSize = GetFileVersionInfoSize((TCHAR *)(const TCHAR *)strFileName, &handle);
	if (dwSize == 0)
		return FALSE;

	abData = new char[dwSize];
	if (!GetFileVersionInfo((TCHAR *)(const TCHAR *) strFileName, handle, dwSize, abData)
		|| !VerQueryValue(abData, "\\VarFileInfo\\Translation", &lpBuffer, &dwDummySize)
		|| dwSize == 0 || dwDummySize == 0)
	{
		delete [dwSize] abData;
		return FALSE;
	}

	// We've successfully read the versioninfo stuff.  Get the
	//  langid/charset pair
	LANGID langid = *((WORD*)lpBuffer);
	dwTranslation = langid;
	dwTranslation <<= 16;
	dwTranslation |= *((WORD*)lpBuffer+1);
	
	// Now translate the the langid into a localized string of the language name
	LCID lcid = MAKELCID(langid, SORT_DEFAULT);
	char szbufInfo[256];
	int nLength = GetLocaleInfo(lcid, LOCALE_SLANGUAGE | LOCALE_USE_CP_ACP, (LPTSTR) szbufInfo, 254);
	if (nLength != 0)
		strLang = szbufInfo;

	// If this didn't work (e.g., the language isn't yet in the user's version
	//  of NT (like Japanese on US NT3.1)), try the LanguageName string.
	if (strLang == strUnknown)
	{
		char szName[512];
		wsprintf(szName, "\\StringFileInfo\\%04x%04x\\LanguageName",
			*((WORD*)lpBuffer), *((WORD*)lpBuffer+1));
		if (VerQueryValue(abData, szName, &lpBuffer, &dwDummySize))
			strLang = (char*) lpBuffer;
	}

	// If strLang has parentheses in it, change them to brackets, since
	//  we put our own parentheses after the name around the DLL name, and
	//  assume no other parentheses exist.
	const TCHAR* pch = strLang;
	for (int i=0; *pch != '\0'; i += _tclen(pch), pch = _tcsinc(pch))
	{
		if (strLang[i] == _T('('))
			strLang.SetAt(i, _T('['));
		else if (strLang[i] == _T(')'))
			strLang.SetAt(i, _T(']'));
	}
	delete [dwSize] abData;

	// Set bUS
	if (MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) == langid)
		bUS = TRUE;
	else
		bUS = FALSE;

	if (PRIMARYLANGID(langid) == PRIMARYLANGID(GetUserDefaultLangID()))
		return TRUE;
	else
		return FALSE;
}

void ExtractDllName(const CString& strEntry, CString& strResult)
{
	int nStart = strEntry.Find('(');
	int nEnd = strEntry.ReverseFind(')');
	if (nStart >= nEnd)
	{
		// This should only happen if a custom apwz is being creative with the names
		//  of languages it's popping into the language checklist.
		ASSERT(FALSE);
		return;
	}
	CString strDllName = strEntry.Mid(nStart+1, nEnd - nStart - 1);

	// If the DLL has changed, we'll have to update the lang-dependent names.
	if (strResult != strDllName)
		projOptions.m_names.m_bUpdateNames = TRUE;

	strResult = strDllName;
}

void ExtractLangName(const CString& strEntry, CString& strResult)
{
	int nLength = strEntry.Find('(') - 1;
	ASSERT(nLength >= 0);
	strResult = strEntry.Left(nLength);
}

DWORD ExtractTranslation(LPCTSTR szEntry)
{
	szEntry = _tcsrchr(szEntry, ';') + 1;
	DWORD dwTranslation;
	if (sscanf(szEntry, "0x%lx", &dwTranslation) == 1)
		return dwTranslation;
	return 0xffffFFFF;
}

WORD CodepageFromTranslation(DWORD dwTranslation)
{
	// Ignore code page in the translation DWORD.  Instead, ask system what
	//  code page to use.  (If error, revert to CP in dwTranslation.)
	char szbufInfo[16];
	LANGID langid = (WORD) (dwTranslation >> 16);
	LCID lcid = MAKELCID(langid, SORT_DEFAULT);
	if (GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, (LPTSTR) szbufInfo, 14) == 0)
		return (WORD) (dwTranslation & 0x0000FFFF);
	return (WORD)atoi(szbufInfo);
}

/* void ExtractLangid(CCheckList* pList, const CString& strEntry, WORD& langid)
{
	int nEntry = pList->FindString(-1, strEntry);
	DWORD dwData = pList->GetItemData(nEntry);
	langid = (WORD) dwData;
}*/

HANDLE GetSearchHandle(WIN32_FIND_DATA* pffd)
{
	// NOTE: you MUST close the handle you get back from this method with ::FindClose().
	// Failure to do so will result in a memory leak.
	CString strMatch = theDLL.m_strAppwizDir + szModuleSubdir1 + "appwz*.dll";
	return ::FindFirstFile(strMatch, pffd);
}

BOOL ScanForLangDll()
{
	WIN32_FIND_DATA ffd;
	HANDLE hSearch;
	while ((hSearch = GetSearchHandle(&ffd)) == INVALID_HANDLE_VALUE)
	{
		if (AfxMessageBox(IDP_RESCAN_LANGDLL, MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
			return FALSE;
	}
	::FindClose(hSearch);
	return TRUE;
}

BOOL AvailableLangDlls::ScanForAvailableLanguages()
{
	m_bLastFilledManually = FALSE;
	m_adwTranslations.RemoveAll();
	m_astrAvailableLangs.RemoveAll();
	CStringList strlFiles;
	WIN32_FIND_DATA ffd;
	HANDLE hSearch = GetSearchHandle(&ffd);
	if (hSearch != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (ffd.dwFileAttributes != FILE_ATTRIBUTE_DIRECTORY)
			{
				DWORD dwTranslation;
				CString strEntry;
				BOOL bUS;
				BOOL bDefault = GetLangFromDllName(ffd.cFileName, strEntry, bUS, dwTranslation);
				int nEntry = m_astrAvailableLangs.Add
					( ( ( strEntry + " (" ) + ffd.cFileName ) + ")" );
				if (bDefault)
				{
					m_nDefaultEntry = nEntry;
					m_strDefaultDllName = ffd.cFileName;
					m_dwDefaultTranslation = dwTranslation;
				}
				if (bUS)
					m_nUSEntry = nEntry;
				VERIFY (m_adwTranslations.Add(dwTranslation) == nEntry);
			}
		}
		while (::FindNextFile(hSearch,  &ffd));
		::FindClose(hSearch);
	}

	int nCount = m_astrAvailableLangs.GetSize();
	ASSERT(nCount == m_adwTranslations.GetSize());
	if (nCount == 0)
	{
		// list is empty, so rescan for dlls
		if (!ScanForLangDll())
		{
			// User hit cancel, so get out of here
			return FALSE;
		}
		else
		{
			// We found a dll, so rerun
			return ScanForAvailableLanguages();
		}
	}
	return TRUE;
}

BOOL AvailableLangDlls::InitLangDllList(CComboBox* pCombo)
{
	pCombo->ResetContent();

	// If there are no languages scanned at all, we definitely
	//  want to scan for them now.
	if (!ScanForAvailableLanguagesIfNecessary())
		return FALSE;

	// Also, even if there are languages listed, we may want to
	//  force a rescan...
	if (!IsUserAWX() && m_bLastFilledManually)
	{
		// This is normal appwiz, but languages were last entered manually
		//  by a custom AppWizard.  Thus, rescan lang DLLs from disk
		if (!ScanForAvailableLanguages())
			return FALSE;
	}

	// Load checklist with languages
	int nSize = m_astrAvailableLangs.GetSize();
	ASSERT(nSize > 0);
	ASSERT(nSize == m_adwTranslations.GetSize());
	for (int i=0; i < nSize; i++)
		VERIFY (pCombo->AddString(m_astrAvailableLangs[i]) == i);

	// Check appropriate defaults
	if (!langDlls.CheckPreviouslyCheckedLangs(pCombo))
	{
		// The default or previously selected lang dll doesn't exist.  Select
		//  the user's language, or if unavailable, US English
		if (m_nDefaultEntry == -1)
			m_nDefaultEntry = m_nUSEntry;
		//pList->SetItemData(m_nDefaultEntry, 1);
		pCombo->SetCurSel(m_nDefaultEntry);
	}
	return TRUE;
}

BOOL AvailableLangDlls::GetAvailableLanguages(CStringList& strlLangs)
{
	strlLangs.RemoveAll();

	if (!ScanForAvailableLanguagesIfNecessary())
	{
		// This means that we hadn't yet scanned for languages, and on this scan,
		//  there weren't any.
		return FALSE;
	}

	// Load strlLangs with contents of m_astrAvailableLangs & m_adwTranslations
	int nSize = m_astrAvailableLangs.GetSize();
	ASSERT(nSize > 0);
	for (int i=0; i < nSize; i++)
	{
		CString strEntry;
		strEntry.Format("%s;%#x", (LPCTSTR) m_astrAvailableLangs[i], m_adwTranslations[i]);
		strlLangs.AddTail(strEntry);
	}

	return TRUE;
}

void GetNextLine(CString& strLangsToLoad, CString& rstrLine)
{
	int nEnd = strLangsToLoad.Find('\n');
	if (nEnd == -1)
		nEnd = strLangsToLoad.GetLength();
	ASSERT (strLangsToLoad.GetLength() >= nEnd);

	rstrLine = strLangsToLoad.Left(nEnd);
	if (nEnd + 1 >= strLangsToLoad.GetLength() - 1)
		strLangsToLoad.Empty();
	else
		strLangsToLoad = strLangsToLoad.Mid(nEnd + 1);
}

void AvailableLangDlls::SetSupportedLanguages(LPCTSTR szSupportedLangs, BOOL bParseTranslations /* = TRUE */)
{
	m_bLastFilledManually = TRUE;
	m_astrAvailableLangs.RemoveAll();
	m_adwTranslations.RemoveAll();
	m_nDefaultEntry = -1;
	m_nUSEntry = 0;
	
	CString strLangs = szSupportedLangs;
	CString strLine, strLang;
	DWORD dwTranslation;

	while (!strLangs.IsEmpty())
	{
		GetNextLine(strLangs, strLine);
		ASSERT(!strLine.IsEmpty());

		if (bParseTranslations)
		{
			int nSemicolon = strLine.Find(';');
			if (nSemicolon != -1)
			{
				CString strLang(strLine, nSemicolon);
				if ((dwTranslation = ExtractTranslation(strLine)) != 0xffffFFFF)
				{
					int nEntry = m_astrAvailableLangs.Add(strLang);
					m_adwTranslations.Add(dwTranslation);

					// See if this is English or the default language
					WORD langid = (WORD) (dwTranslation >> 16);
					if (MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) == langid)
						m_nUSEntry = nEntry;
					if (PRIMARYLANGID(langid) == PRIMARYLANGID(GetUserDefaultLangID()))
						m_nDefaultEntry = nEntry;
					continue;
				}
			}

			// If we've reached this point, strLine wasn't of the expected format.  So
			// forget trying to parse out the translation.
			SetSupportedLanguages(szSupportedLangs, FALSE);
			return;
		}

		// We've given up trying to parse out the translation, so just stick the whole
		//  line in m_astrAvailableLangs
		m_astrAvailableLangs.Add(strLine);
	}

	// If m_nDefaultEntry wasn't filled in yet, just make it be English
	if (m_nDefaultEntry == -1)
		m_nDefaultEntry = m_nUSEntry;
}


BOOL LangDlls::CheckPreviouslyCheckedLangs(CComboBox* pCombo)
{
	// LATER: Uncomment the source code lines when we allow multiple languages
	// First, uncheck all langs
	/*int nCount = pList->GetCount();
	for (int i = 0; i < nCount; i++)
		pList->SetItemData(i, 0);*/
	// Then, check the ones in this.
	int nCurrCount = GetSize();
	BOOL bAnyChecked = FALSE;
	for (int i = 0; i < nCurrCount && !m_astrNameLang[i].IsEmpty(); i++)
	{
		int nItem = (pCombo->FindString( -1,
			( ( m_astrNameLang[i] + " (" ) + m_astrNameDll[i] ) + ")" ));
			
		if (nItem != CB_ERR)
		{
			//pList->SetItemData(nItem, 1);
			pCombo->SetCurSel(nItem);
			ASSERT(bAnyChecked == FALSE); // Until we allow multiple languages, there can only be one
			bAnyChecked = TRUE;
		}
	}
	return bAnyChecked;
}


void LangDlls::WriteLangDlls(CComboBox* pCombo)
{
	if (pCombo->GetCount() == 0)
		// We're about to bounce to beginning, so just return
		return;
	
	int nNumChecked = 0;
	int nCount = pCombo->GetCount();
	/*for (int i = 0; i < nCount; i++)
	{
		// We only care about the languages selected
		if (pList->GetItemData(i) != 1)
			continue;
*/
		// LATER: remove this when we have multiple languages, and reinstate the for loop
		int i = pCombo->GetCurSel();
		
		CString strEntry;
		pCombo->GetLBText(i, strEntry);

		if (!strEntry.IsEmpty())
		{
			CString tmp;
			ExtractLangName(strEntry, tmp);
			m_astrNameLang.SetAtGrow(nNumChecked, tmp);
			ExtractDllName(strEntry, tmp);
			m_astrNameDll.SetAtGrow(nNumChecked, tmp);
			m_adwTranslation.SetAtGrow(nNumChecked, m_AvailableLangDlls.GetTranslationAt(i));
			nNumChecked++;
		}
//	}

	// Fill in rest of array with blanks
	int nArraySize = GetSize();
	for (i = nNumChecked; i < nArraySize; i++)
	{
		m_astrNameLang.SetAt(i, NULL);
		m_astrNameDll.SetAt(i, NULL);
	}
	// LATER: remove this when we have multiple languages
	ASSERT(nNumChecked == 1);
}

// General error-induced exit routine
void LangDlls::ComplainAndFreeAll(int nDll)
{
	ASSERT (nDll >= 0 && nDll < GetSize());
	CString strPrompt;
	AfxFormatString1(strPrompt, IDP_BAD_LANG_DLL, m_astrNameDll[nDll]);
	AfxMessageBox(strPrompt);
	FreeLibs();
}


BOOL LangDlls::LoadLangSpecificDefaults()
{
	int nSize = GetSize();
	for (int nDll = 0; nDll < nSize && IsValidEntry(nDll); nDll++)
	{
	
		// Pluck out language-dependent defaults from the langdll (e.g., from appwzenu.dll).
		//  These are stored as special strings in the DLL's stringtable (128 & 129).
		//  See the comment in appwzenu.rc for more information.

		CString strFiles;
		BOOL bFilesAfter;
		if (m_ahDll[nDll] == NULL)
		{
			// If this is an extension which supports a language we don't have, fake the
			//  translation of "Files" and its "after" attribute.
			ASSERT(IsUserAWX());
			strFiles.LoadString(IDS_FILES);
			bFilesAfter = TRUE;
		}
		else
		{
			// Get translation of "Files"
			int nRet = ::LoadString(m_ahDll[nDll], 128, strFiles.GetBuffer(256), 255);
			strFiles.ReleaseBuffer();
			if (nRet == 0 || nRet > 255)
			{
				ComplainAndFreeAll(nDll);
				return FALSE;
			}
		
			// Does "Files" come before or after the adjective?
			CString strAfter;
			nRet = ::LoadString(m_ahDll[nDll], 129, strAfter.GetBuffer(10), 9);
			strAfter.ReleaseBuffer();
			if (nRet == 0 || nRet > 9)
			{
				ComplainAndFreeAll(nDll);
				return FALSE;
			}

			if (strAfter == "0")
				bFilesAfter = FALSE;
			else if (strAfter == "1")
				bFilesAfter = TRUE;
			else
			{
				ComplainAndFreeAll(nDll);
				return FALSE;
			}
		}

		// Store Files & After in this
		m_astrFiles.SetAtGrow(nDll, strFiles);
		m_abFilesAfter.SetAtGrow(nDll, (USHORT)bFilesAfter);

		// TODO: Need to fix m_bUpdateNames
		// Only update these lang-specific names if necessary.  We don't want to
		//  trample over a user's edited name unless the project name changed
		//  or the language changed.
		/* if (!projOptions.m_names.m_bUpdateNames)
			return TRUE;*/
		CString strTag;
		GetTag(strTag);
		CString strDocTag = strTag;
	    if (strDocTag.GetLength() > MAX_TAG)
	        strDocTag = strDocTag.Left(MAX_TAG);

		m_astrDocTag.SetAtGrow(nDll, strDocTag);
		m_astrDocFilter.SetAtGrow(nDll, NULL);
		m_astrDocFileNew.SetAtGrow(nDll, strDocTag);
		m_astrDocRegName.SetAtGrow(nDll, strDocTag + " Document");
		m_astrTitle.SetAtGrow(nDll, projOptions.m_strProj);
		m_abUpdateFilter.SetAtGrow(nDll, TRUE);
		m_abUpdateFileNew.SetAtGrow(nDll, TRUE);
		m_abUpdateRegName.SetAtGrow(nDll, TRUE);

		// Update Win32 filter name
		if (!projOptions.m_names.strDocFileExt.IsEmpty())
		{
			if (bFilesAfter)
				m_astrDocFilter.SetAtGrow(nDll, m_astrDocTag[nDll] + " "
					+ strFiles);
			else
				m_astrDocFilter.SetAtGrow(nDll, strFiles + " "
					+ strDocTag);
			m_astrDocFilter[nDll] += " (*." + projOptions.m_names.strDocFileExt + ")";
		}

	}
	// Update Mac filter name
	// TODO: Fix this
	if (m_abFilesAfter[0])
		projOptions.m_names.strMacFilter = projOptions.m_names.strDocFileType + " "
			+ m_astrFiles[0];
	else
		projOptions.m_names.strMacFilter = m_astrFiles[0] + " "
			+ projOptions.m_names.strDocFileType;
	projOptions.m_names.m_bUpdateNames = FALSE;
	return TRUE;

}

BOOL LangDlls::LoadLibs()
{
	FreeLibs();
	int nArraySize = GetSize();
	for (int i = 0; i < nArraySize && !m_astrNameDll[i].IsEmpty(); i++)
	{
		HINSTANCE hinst;
		CString strFileName = theDLL.m_strAppwizDir + szModuleSubdir1 + m_astrNameDll[i];
	    while ((hinst = LoadLibrary((const TCHAR *)strFileName)) == NULL && !IsUserAWX())
		{
			CString strPrompt;
			AfxFormatString1(strPrompt, IDP_ERROR_LOAD_DLL, m_astrNameDll[0]);
			if (AfxMessageBox(strPrompt, MB_RETRYCANCEL) == IDCANCEL)
				return FALSE;
		}
		m_ahDll.SetAtGrow(i, hinst);
	}

	return TRUE;
}

BOOL LangDlls::LoadLibsByName(LPCTSTR szLibs /* = NULL */)
{
	FreeLibs();
	int nArrayCount = 0;
	if (!m_AvailableLangDlls.ScanForAvailableLanguagesIfNecessary())
		return FALSE;

	if (szLibs == NULL)
	{
		// No libs specified, so load them all.  One by one, fill in m_astrNameDll
		//  with the names of the installed languages.
		CStringList strlLangs;
		if (!m_AvailableLangDlls.GetAvailableLanguages(strlLangs))
			return FALSE;

		POSITION pos = strlLangs.GetHeadPosition();
		while (pos != NULL)
		{
			CString strLang = strlLangs.GetNext(pos);
			CString strDll;
			DWORD dwTranslation;
			ExtractDllName(strLang, strDll);
			if (strDll.IsEmpty() ||
				((dwTranslation = ExtractTranslation(strLang)) == 0xffffFFFF))
			{
				// Gracefully skip over bad DLL names.  We can get such things
				//  if a custom apwz is being creative about what it puts in
				//  the language checklist.
				continue;
			}
			m_astrNameDll.SetAtGrow(nArrayCount, strDll);
			ExtractLangName(strLang, strDll);
			m_astrNameLang.SetAtGrow(nArrayCount, strDll);
			m_adwTranslation.SetAtGrow(nArrayCount, dwTranslation);
			nArrayCount++;
		}
	}
	else
	{
		// Libs are specified, so only load the specified ones
		//  Its value looks like: appwzenu.dll\n0x040904E4\nappwzfra.dll\n0x444404E4
		CString strLangsToLoad = szLibs;
		ASSERT(!strLangsToLoad.IsEmpty());

		// One by one, fill in m_astrNameDll with each line from this string
		CString strLine;
		while (!strLangsToLoad.IsEmpty())
		{
			GetNextLine(strLangsToLoad, strLine);
			ASSERT(!strLine.IsEmpty());
			m_astrNameDll.SetAtGrow(nArrayCount, strLine);
			GetNextLine(strLangsToLoad, strLine);
			ASSERT(!strLine.IsEmpty());
			DWORD dwTranslation;
			sscanf((LPCTSTR) strLine, "0x%lx", &dwTranslation);
			m_adwTranslation.SetAtGrow(nArrayCount++, dwTranslation);
		}
	}

	// Finally, load the libraries
	return LoadLibs();
}

void LangDlls::FreeLibs()
{
	int nSize = m_ahDll.GetSize();
	for (int nDll = 0; nDll < nSize && IsValidEntry(nDll); nDll++)
	{
		if (m_ahDll[nDll] != NULL)
		{
			VERIFY(FreeLibrary(m_ahDll[nDll]));
			m_ahDll[nDll] = NULL;
		}
	}
	m_nDefaultDll = 0;
	m_strDefaultLang.Empty();

#ifdef _DEBUG
	// Make sure that m_ahDll is all NULL'd out
	for (nDll = 0; nDll < nSize; nDll++)
		ASSERT(m_ahDll[nDll] == NULL);
#endif //_DEBUG

}

int LangDlls::GetSize()
{
	int nSize = m_astrNameDll.GetSize();
	ASSERT (m_astrNameLang.GetSize() == nSize);
	return nSize;
}

LangDlls::LangDlls()
{
	Init();
}

BOOL LangDlls::SetDefaultLang(LPCTSTR szLangSuffix)
{
	CString strNameDll;
	strNameDll.Format("appwz%s.dll", szLangSuffix);
	m_strDefaultLang = szLangSuffix;

	// Search for loaded DLL with this name
	int nSize = m_ahDll.GetSize();
	for (int nDll = 0; nDll < nSize && IsValidEntry(nDll); nDll++)
	{
		if (!m_astrNameDll[nDll].CompareNoCase(strNameDll))
		{
			m_nDefaultDll = nDll;
			return TRUE;
		}
	}

	// Didn't find a match, so it's an error
	if (!IsUserAWX())
		m_strDefaultLang.Empty();
	return FALSE;
}

LPCTSTR LangDlls::GetDefaultLang()
{
	ASSERT(IsUserAWX());
	if (m_strDefaultLang.IsEmpty())
		return NULL;
	else
		return m_strDefaultLang;
}


#define INIT_LANG_ARRAY_SIZE 6
void LangDlls::Init()
{
	FreeLibs();

	m_astrNameLang.RemoveAll();
	m_astrNameDll.RemoveAll();
	m_adwTranslation.RemoveAll();
	m_ahDll.RemoveAll();
	m_astrNameLang.SetSize(INIT_LANG_ARRAY_SIZE);
	m_astrNameDll.SetSize(INIT_LANG_ARRAY_SIZE);
	m_adwTranslation.SetSize(INIT_LANG_ARRAY_SIZE);
	m_ahDll.SetSize(INIT_LANG_ARRAY_SIZE);

	m_astrFiles.RemoveAll();
	m_abFilesAfter.RemoveAll();
	m_astrFiles.SetSize(INIT_LANG_ARRAY_SIZE);
	m_abFilesAfter.SetSize(INIT_LANG_ARRAY_SIZE);

	m_astrTitle.RemoveAll();
	m_astrDocFileNew.RemoveAll();
	m_astrDocFilter.RemoveAll();
	m_astrDocTag.RemoveAll();
	m_astrDocRegName.RemoveAll();
	m_astrTitle.SetSize(INIT_LANG_ARRAY_SIZE);
	m_astrDocFileNew.SetSize(INIT_LANG_ARRAY_SIZE);
	m_astrDocFilter.SetSize(INIT_LANG_ARRAY_SIZE);
	m_astrDocTag.SetSize(INIT_LANG_ARRAY_SIZE);
	m_astrDocRegName.SetSize(INIT_LANG_ARRAY_SIZE);

	m_abUpdateFilter.RemoveAll();
	m_abUpdateFileNew.RemoveAll();
	m_abUpdateRegName.RemoveAll();
	m_abUpdateFilter.SetSize(INIT_LANG_ARRAY_SIZE);
	m_abUpdateFileNew.SetSize(INIT_LANG_ARRAY_SIZE);
	m_abUpdateRegName.SetSize(INIT_LANG_ARRAY_SIZE);

	for (int i=0; i < INIT_LANG_ARRAY_SIZE; i++)
	{
		m_astrNameLang.SetAt(i, NULL);
		m_astrNameDll.SetAt(i, NULL);
		m_ahDll.SetAt(i, NULL);

		m_astrFiles.SetAt(i, NULL);
		m_abFilesAfter.SetAt(i, TRUE);

		m_astrTitle.SetAt(i, NULL);
		m_astrDocFileNew.SetAt(i, NULL);
		m_astrDocFilter.SetAt(i, NULL);
		m_astrDocTag.SetAt(i, NULL);
		m_astrDocRegName.SetAt(i, NULL);

		m_abUpdateFilter.SetAt(i, TRUE);
		m_abUpdateFileNew.SetAt(i, TRUE);
		m_abUpdateRegName.SetAt(i, TRUE);
	}
	//projOptions.m_langid = 0;
}

// Defined in customaw.cpp.
// TODO: When the appwiz*.dlls are updated, GET RID OF THIS!!!
//HRSRC FindResourceAnyType(HINSTANCE hInstance, LPCTSTR lpszResource);

HRSRC LangDlls::FindLangResource(LPCTSTR lpszResource, HINSTANCE& hinst)
{
	ASSERT (0 <= m_nDefaultDll && m_nDefaultDll < m_ahDll.GetSize());
	ASSERT (m_ahDll[m_nDefaultDll] != NULL || IsUserAWX());

	HRSRC hrsrc = NULL;

	// First try the default DLL
	if ((hrsrc = ::FindResource(hinst = m_ahDll[m_nDefaultDll], lpszResource, "TEMPLATE")) != NULL)
		// Found it
		return hrsrc;
	if ((hrsrc = ::FindResource(hinst = m_ahDll[m_nDefaultDll], lpszResource, "TEMPLATE_TAG")) != NULL)
		// Found it
		return hrsrc;

	// Hmmm.  Not there.  Well, we gotta try them all now, though the chances we'll find
	//  it are pretty slim.
	
	int nSize = GetSize();
	for (int nDll = 0; nDll < nSize && IsValidEntry(nDll); nDll++)
	{
		hrsrc = ::FindResource(hinst = m_ahDll[nDll], lpszResource, "TEMPLATE");
		if (hrsrc != NULL)
			break;		// We've found the template, so stop looking
	}

/*	if (hrsrc == NULL)
	{
		// TODO: Errorbox: possible invalid appwiz dll.
		// Backward compatibility: a langdll created in the V2 timeframe will
		//  name its help file templates with an "rft" extension.  Our new newproj.inf
		//  uses "rtf".  So, to make sure *our* newproj.inf can find *their* template,
		//  allow "rtf" in newproj.inf map to "rft" in the resources, if necessary.
		// TODO: When the appwiz*.dlls are updated, GET RID OF THIS!!!

		CString strRFTResource = lpszResource;
		if (strRFTResource.Right(4) == ".rtf")
		{
			strRFTResource = strRFTResource.Left(strRFTResource.GetLength()-3) + "rft";
			for (nDll = 0; nDll < nSize && IsValidEntry(nDll); nDll++)
			{
				hrsrc = ::FindResource(hinst = m_ahDll[nDll], lpszResource, "TEMPLATE");
				if (hrsrc != NULL)
					break;		// We've found the template, so stop looking
			}
		}
	}

	if (langDlls.m_ahDll[0] == NULL)
	{
		ASSERT(IsUserAWX());
		ReportAndThrowExt(IDP_CANT_LOAD_LOC_TPL, lpszResource);
	}
	
	// We've determined whether to look in mfcapwz.dll or appwz*.dll, so look.
	// hrsrc better not be NULL at this point, or I'm telling Mommy.
	if (hrsrc == NULL)
	{
		if (IsUserAWX())
		{
			// The extension is to blame... let's tattle
			ReportAndThrowExt(IDS_CG_CANT_FIND_TPL, lpszResource);
		}
		else
		{
			// If we're not in an extension, it must be appwz*.dll's fault
			ASSERT(nLocalized != LOC_NO);	// ASSERT that we're right
			// TODO: Fix me
			ReportAndThrow(IDP_BAD_LANG_DLL, langDlls.m_astrNameDll[0]);
		}
	}*/
	//ASSERT(hrsrc != NULL);	// TODO: Remove this when we get in a good errorbox
	return hrsrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\extend.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "extend.h"
#include "codegen.h"	// For ReportAndThrow2
#include "symbols.h"

extern CMyCustomAppWiz MyAWX;

CUserExtension::CUserExtension()
{
	m_strUserDLL.Empty();
	m_hUserDLL = NULL;
	m_pAWX = &MyAWX;
	m_bCtlWiz = FALSE;
}

CUserExtension::~CUserExtension()
{
	// Detach before letting it go out of scope
	Detach();
}

/////////////////////////////////////////////////////////////////////////////
// Helper member functions

void CUserExtension::SetCustomAppWizClass(CCustomAppWiz* pAW)
{
	m_bSetCustomAppWizClassCalled = TRUE;

	if (pAW == NULL)
		m_bCalledSetCustomAppWizWithNULL = TRUE;
	else
	{
		m_bCalledSetCustomAppWizWithNULL = FALSE;
		m_pAWX = pAW;
	}
}

BOOL CUserExtension::Attach(const TCHAR* szUserExtension)
{
	// If we're already attached to something else, detach first.
	if (m_hUserDLL != NULL)
	{
		if (m_strUserDLL == szUserExtension)
		{
			// We've already attached to THIS extension
			return TRUE;       // So no need to reattach
		}
		else
		{
			// We're attached to something else, so detach first
			Detach();
		}
	}

	m_bSetCustomAppWizClassCalled = FALSE;
	HINSTANCE hLib = LoadLibrary(szUserExtension);
	if (hLib == NULL)
	{
		CString strPrompt;
		AfxFormatString1(strPrompt, IDP_CANT_LOAD_EXTENSION, szUserExtension);
		AfxMessageBox(strPrompt);
		return FALSE;
	}
	if (!m_bSetCustomAppWizClassCalled)
	{
		FreeLibrary(hLib);
		CString strPrompt;
		AfxFormatString1(strPrompt, IDP_EXT_NOT_CALL_SETAWX, szUserExtension);
		AfxMessageBox(strPrompt);
		return FALSE;
	}
	if (m_bCalledSetCustomAppWizWithNULL)
	{
		FreeLibrary(hLib);
		CString strPrompt;
		AfxFormatString1(strPrompt, IDP_SETAWX_WITH_NULL, szUserExtension);
		AfxMessageBox(strPrompt);
		return FALSE;
	}

	m_strUserDLL = szUserExtension;
	m_hUserDLL = hLib;

	projOptions.m_nProjType = PROJTYPE_MDI;
	if (theDLL.m_pMainDlg != NULL)
		theDLL.m_pMainDlg->SetNumberOfSteps(-1);
	SetProjectTypeSymbol();
	theDLL.m_pMainDlg->InitializeOptions();	// Init the extension's dictionary w/ defaults
	m_pAWX->InitCustomAppWiz();
	ASSERT (m_bCtlWiz == FALSE);

	return TRUE;
}

void CUserExtension::Detach()
{
	if (m_hUserDLL == NULL)
		return;
	if (theDLL.m_pMainDlg != NULL)
		theDLL.m_pMainDlg->DestroyUserDlgs();
	ASSERT(m_pAWX != NULL);
	m_pAWX->ExitCustomAppWiz();
	FreeLibrary(m_hUserDLL);
	m_strUserDLL.Empty();
	m_strExtensionTitle.Empty();
	m_hUserDLL = NULL;
	m_bCtlWiz = FALSE;
	m_pAWX = &MyAWX;
}

CCustomAppWiz* GetAWX()
{
	return projOptions.m_UserExtension.GetAWX();
}

BOOL IsUserAWX()
{
	return projOptions.m_UserExtension.IsUserAWX();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\lang.h ===
class CCheckList;

class AvailableLangDlls
{
public:
	AvailableLangDlls() { m_nDefaultEntry = -1, m_nUSEntry = 0; m_bLastFilledManually = FALSE;}
	BOOL ScanForAvailableLanguages();
	BOOL InitLangDllList(CComboBox* pCombo);
	BOOL GetAvailableLanguages(CStringList& strlLangs);
	void SetSupportedLanguages(LPCTSTR szSupportedLangs, BOOL bParseTranslations = TRUE);
	
	inline BOOL ScanForAvailableLanguagesIfNecessary()
		{	if (m_astrAvailableLangs.GetSize() == 0)
				return ScanForAvailableLanguages();
			else
				return TRUE; }
	
	inline DWORD GetTranslationAt(int i)
		{ return m_adwTranslations[i]; }
		
	CString m_strDefaultDllName;
	DWORD m_dwDefaultTranslation;

protected:
	CStringArray m_astrAvailableLangs;
	CDWordArray m_adwTranslations;
	int m_nUSEntry;
	int m_nDefaultEntry;
	BOOL m_bLastFilledManually;
};

class LangDlls
{
public:
	LangDlls();
	~LangDlls() { FreeLibs(); }
	inline BOOL IsAnythingLoaded() { return ((m_ahDll.GetSize() > 0)
										&& m_ahDll[0] != NULL); }
	inline BOOL IsValidEntry(int i) { return !m_astrNameDll[i].IsEmpty(); }
	BOOL SetDefaultLang(LPCTSTR szLangSuffix);
	LPCTSTR GetDefaultLang();

	void FreeLibs();
	BOOL LoadLibs();
	BOOL LoadLibsByName(LPCTSTR szLibs = NULL);
	BOOL LoadLangSpecificDefaults();
	int GetSize();
	void Init();
	BOOL CheckPreviouslyCheckedLangs(CComboBox* pCombo);
	void WriteLangDlls(CComboBox* pCombo);
	HRSRC FindLangResource(LPCTSTR lpszResource, HINSTANCE& hinst);

	CStringArray m_astrNameDll;		// Name of resource-only .dll, containing templates for
									//  all localizable text resources for generated app.
	CTypedPtrArray<CPtrArray, HINSTANCE> m_ahDll; // Handles to the .dlls
	CStringArray m_astrNameLang;	// Name of languages the .dlls use.
	CDWordArray m_adwTranslation;	// LANGID/code page pair of corresponding language

	CStringArray m_astrFiles;		// The string "Files" translated to DLL's language
	CWordArray m_abFilesAfter;		// Indicates whether "Files" appears after doctype

	// Localized doc template strings
	CStringArray m_astrTitle;
	CStringArray m_astrDocFileNew;
	CStringArray m_astrDocFilter;
    CStringArray m_astrDocTag;      // mixed case tag
	CStringArray m_astrDocRegName;

	// Tracking flags for doc template strings tab of advanced dialog
	CWordArray m_abUpdateFilter, m_abUpdateFileNew, m_abUpdateRegName;

	AvailableLangDlls m_AvailableLangDlls;

protected:
	int m_nDefaultDll;			// DLL to try to load loc tpl from first
	void ComplainAndFreeAll(int nDll);
	CString m_strDefaultLang;
};

extern LangDlls langDlls;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\mfcappwz.h ===
// Wizard for generating a new app

#ifndef VS_PACKAGE
#include <path.h>
#include <ids.h>
#endif	// VS_PACKAGE

#ifdef VS_PACKAGE
#include <tabdlg.h>
#endif

#include <dlgbase.h>


#include "resource.h"
#include "extend.h"

#ifdef VS_PACKAGE
#include "devbld.h"
#include "awiface.h"
#include <bldguid.h>
#endif

#include <bldapi.h>

#ifdef VS_PACKAGE
#include "path.h"
#endif

// special defines
#define NUM_PROJECTS 3

#define NORMAL_MENUS 0
#define REBAR_MENUS 1

#ifdef VS_PACKAGE
//BUGBUG: TEMPORARY until we get hooked up with the build system again
#define BUILDER_EXT    ".dsp"
#endif

                    // project name is the "file name" edit field of COMMDLG
#define MAX_SHORT_TMP  32  // max size of short temporary string
#define NUM_DLG_CLASSES 10  // Total number of main sequential dlgs appwiz brings up

// Field verification
#define MAX_TAG     6       /* limit for 2 digits for synthetic name */
#define MAX_OLE_SHORT 15
#define MAX_PROGID 39
#define MAX_LONGNAME 40
#define MAX_FILTER 100

// Values fed to GetBitmapRect(); they represent the different sizes
//  of bitmaps appwiz uses.
enum
{
	BMPSIZE_STANDARD,		// Same size used for most bitmaps
	BMPSIZE_FLAG,			// Flag is bigger
	BMPSIZE_3D,				// 3D checkbox bitmap is smaller
	BMPSIZE_SUM,			// Union of first two sizes; used for invalidation
};

enum { PS_MFCNORMAL, PS_EXPLORER };


// CFont* GetStdFont(BOOL bBold);
BOOL IsMacInstalled();
BOOL IsMacOle();
BOOL IsMacOcx();
BOOL IsMacODBC();

/////////////////////////////////////////////////////////////////////////////
// Structures

struct AppWizTermStatus
{
	int nTermType;
	int nProjType;
	_TCHAR szFullName[MAX_PATH];
	CStringList strlDepFiles;
	CStringList strlNonPrjFiles;
	CStringList strlNonBldFiles;
	CStringList strlResFiles;
	CStringList strlHelpFiles;
	CStringList strlTemplFiles;
	CString strDefFile;
	//CString strClwFile;
	AppWizTermStatus* nextAppWizTermStatus;
};

extern AppWizTermStatus* pTermStatus;

// the class roots
enum
{
    classView,
    classApp,
    classFrame,
	classChildFrame,
    classDoc,
    classDlg,
    classRecset,
    classSrvrItem,
    classCntrItem,
    classIPFrame,
	classDlgAutoProxy,
    classLeftView,
    classWndView,
    classMax
};

// Stores names of classes, files, etc.
struct NAMES
{
    CString strClass[classMax];
    BOOL bCategoryEnabled[classMax];
    CString strBaseClass[classMax];
    CString strHFile[classMax];
    CString strIFile[classMax];
	CString strTitle;    // Text of title of main frame or dialog.

    // special doc fields
    CString strDocFileExt;
	CString strDocRegID;

	// Mac-specific
	CString strDocFileType;
	CString strDocFileCreator;
	CString strMacFilter;

	BOOL m_bUpdateNames;
};

enum { OLE_NO, OLE_CONTAINER, OLE_MSERVER, OLE_FSERVER, OLE_CSERVER, OLE_MAX };

enum { PROJTYPE_SDI, PROJTYPE_MDI, PROJTYPE_DLG, PROJTYPE_DLL, PROJTYPE_COUNT };

enum {
	dbNone = -1,
	dbOdbc,
	dbDao,
	dbOledb,
	dbAdo
};

// ProjOptions contains what used to be member variables of the dialog classes.
//  They're made global here so that communication between dialogs is easier,
//  and doesn't need the mediation of CPromptDlg (which is impossible now that
//  the dialogs are independent & sequential).
struct ProjOptions
{
    int  m_options;        // general user-set flags
	WORD m_projOptions;    // general user-set project flags
	BOOL m_bExtdll;		   // Are we an extension DLL?
    NAMES m_names;         // names of classes, files, etc.
    int m_nOleType;        // container, server, etc.
    BOOL m_bOleAutomation;
	BOOL m_bOcx;	 	   // Ole control container
	BOOL m_bActiveDocServer;   // ActiveX document server
	BOOL m_bActiveDocContainer;   // ActiveX document server
	BOOL m_bOleCompFile;
    BOOL m_bPrevMDI;       // Remembers state of MDI before Mini-Server is selected
    BOOL m_bDBSimple;      // Whether we're a non-doc simple database viewer.
    BOOL m_bDBHeader;      // Whether we're DB enabled at all.
	int m_nDataSource;           // TRUE if we are using DAO recordsets instead of ODBC
	BOOL m_bAutoDetect;	   // TRUE if recordset should auto detect dirty fields
	int m_nFrameStyles;    // Main window frame styles flags.
	int m_nMenuStyle;      // Main menu style.
	BOOL m_bSplitter;  	   // Splitter window in SDI app.
	int m_nChildFrameStyles;        // MDI Child frame style flags.
    int m_nProjType;       // SDI, MDI, Dlg, extDll.
    int m_nProjStyle;       // Explorer or Normal.
	UINT m_nSizeMRU;       // # entries in MRU file menu.
	
	CUserExtension m_UserExtension;	// Keeps a handle to user extension
	BOOL m_bMayBeAppWizTrack;		// If an extension is controlling appwiz, this
		// flag tells us whether to set symbols at the end (in SetSymbols).
	
    CDir m_ProjDir;		   // Gotten from CPromptDlg, used during generation
    CString m_strProj;     // ditto
	CString m_strProjTag;  // "Safe" version of project name (no double-byte characters)
	
	BOOL m_bUpdateRegID;   // Tracking flag for nonloc entry in doc template strings tab
	BOOL m_bATLSupport;		// ATL Support
	int  m_nStartRes;		// Resource Base #
	BOOL m_bNoDocView;		// No Doc view architechture support
};

extern ProjOptions projOptions;

BOOL IsMDI();
void SetMDI(BOOL bMDI);

struct AppWizTermStatus;
class CMainDlg;

// Main app
class CTheDLL : public CObject
{
public:
    CTheDLL();
#ifndef VS_PACKAGE
	int RunAppWiz(HWND hWnd, HBUILDER* phBld);
#endif	// VS_PACKAGE
    virtual BOOL InitInstance();
    virtual int ExitInstance();

	void InitAppWiz(HWND hWnd);
	int RunAppWizSteps();
	void ExitAppWiz();


    HKEY m_hKey;
	CString m_strAppwizDir;   // Directory from which appwiz was launched (and
	                          //  thus where it should search for localized dlls).
	BOOL m_bQuit;
	BOOL m_bDeleteMainDlg;
	CMainDlg* m_pMainDlg;
private:
	BOOL m_bFirstTime;

};

extern CTheDLL theDLL;

/////////////////////////////////////////////////////////////////////////////
// CMainDlg dialog

class CSeqDlg;
class CAppWizStepDlg;
class CMainDlg : public C3dDialog
{
friend class CSeqDlg;
friend class CAppWizStepDlg;
friend class CTheDLL;
// Construction
public:
    CMainDlg(CWnd* pParent = NULL); // standard constructor
	~CMainDlg();
    int Create(CWnd *pWnd)
        { return C3dDialog::Create(MAKEINTRESOURCE(IDD_MAINDLG), pWnd); }

    virtual BOOL PreTranslateMessage(MSG* pMsg);
    BOOL FinalProcessing();
	void RedrawBitmap(int nBmpSize);
	CAppWizStepDlg* ExtKeyFromID(AppWizDlgID nID);
	CSeqDlg* ExtSeqDlgFromKey(CAppWizStepDlg* pStepDlg);
	void SetNumberOfSteps(int nSteps);
    void InitializeOptions();
	void DestroyUserDlgs();
	void UserDeletedStandardStep(CAppWizStepDlg* pDlg);

	// Called by the child/sub-dialogs when F1 is pressed
	virtual void ChildRequestingHelp() { OnHelp(); }
	
	// This is either IDOK or IDC_END.  See "InterchangeEndAndOK" in
	//  mfcappwz.cpp
	int m_nRightmostBtn;

	CDialog* m_pConfirmDlg;
	CString m_strLastSubdir;
	
// Dialog Data
    //{{AFX_DATA(CMainDlg)
    enum { IDD = IDD_MAINDLG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

// Implementation
protected:
	void SetCurrentTrack();
	int m_nHelpIDs[NUM_DLG_CLASSES];  // See mfcappwz.cpp: CMainDlg::FillHelpIDs()
    CSeqDlg* m_pDialogClasses[NUM_DLG_CLASSES];
    int m_nCurrIndex;
    int* m_nCurrTrack;
    int m_nCurrLastIndex;
	BOOL m_bFirstTimeFileDlg;

	CAppWizStepDlg* m_pCurrUserStepDlg;
	CSeqDlg* m_pCurrUserSeqDlg;
	BOOL IsUserDlg();
	CAppWizStepDlg* m_pExtensionKeys[NUM_DLG_CLASSES];
	CTypedPtrMap<CMapPtrToPtr, CAppWizStepDlg*, CSeqDlg*> m_DlgMap;
	CTypedPtrMap<CMapPtrToPtr, CAppWizStepDlg*, void*> m_UserDlgsToDestroy;
	int m_nCurrUserStep;
	int m_nMaxUserSteps;

	int GetSeqDlgIndex(CSeqDlg* pSeqDlg);
	void InitializeUserVars();
	void GetAllSymbols();
	CDialog* GetInnerDlg();
	BOOL DismissCurrentDlg(BOOL bShouldDestroy = TRUE);
    void ActivateDlg(int nDlg);
    BOOL StartAppWizSteps();
    BOOL ActivateConfirmDlg();
	void SetFocusOnStep(CDialog* pDlg);
	void ActivateUserDlg(BOOL bDirIsNext);
	void UpdateStepDisplay();
	void ArrangeButtons(int nAddHelpButton);
	int m_nHasHelpButton;

	int m_nChildDlgLeft;
	void CalculateDimensions();
    virtual void PostNcDestroy();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	void AdjustEndAndOK(BOOL bIsLastDlg);
	void InterchangeEndAndOK();
	void DrawBitmap(CDC* pdc, CSeqDlg* pDlg, int nBmp);
	void DrawLowerBackground(CDC* pdc, CBrush* pBrush, CPen* pOldPen);

	CString m_strCWDProjGen;

		
    // Generated message map functions
    //{{AFX_MSG(CMainDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedBack();
    afx_msg void OnDestroy();
    afx_msg void OnClickedEnd();
    virtual void OnCancel();
    virtual void OnOK();
    afx_msg void OnHelp();
	afx_msg void OnPaint();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG

	BOOL DoHelpInfo(HELPINFO* pInfo);
    BOOL Generate(CWnd* pProjStatus, CWnd* pFileStatus);  
    BOOL m_bWait;
    void FakeShellExecute(HWND hWnd, LPCSTR szVerb, LPCSTR szFile);
    LRESULT OnDDEAck(WPARAM wParam, LPARAM lParam);
    
    DECLARE_MESSAGE_MAP()

private:
    void InitDialogs();
    void DeleteDialogs();   
};

#define WM_GOTO_BEGINNING WM_USER+100

enum {WIN, MAC, POWERMAC, JAVA, XBOX, PLATFORM_MAX};
extern const TCHAR* szPlatforms[];
extern CMapStringToString g_PlatformsSelected; // Long names of selected platforms
extern CStringList g_strlPlatformsDisplayed;
extern CStringList strlProjTypes;


/////////////////////////////////////////////////////////////////////////////

int GetDefaultFrameStyles();
int GetDefaultChildFrameStyles();
int GetDefaultExtraChildFrameOptions();

void GetTag(CString& tag, LPCTSTR szRoot = NULL);
void SetOleSymbols();
void ResetOleSymbols();
void MyResetCheck(CButton* pBtn);
void UpdateTrackingNames(NAMES& names, const char* pszRoot);
void FillDefaultNames(NAMES& names, const char* pszRoot);
BOOL CanViewClassBeUsedWithSplitter(const CString &rstrViewClassName);
BOOL IsLearningBox();

#ifdef VS_PACKAGE
class CBldWiz : public IBuildWizard
{
public:
	
	STDMETHODIMP QueryInterface(REFIID /* riid */, LPVOID * /* ppv */) { return E_NOTIMPL; }
	STDMETHODIMP_(ULONG) AddRef() { return 0; }
	STDMETHODIMP_(ULONG) Release() { return 0; }

	STDMETHODIMP SetActiveTarget(HBLDTARGET hTarg, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetActiveTarget((DWORD) hTarg, (DWORD) hBld);
	}

	STDMETHODIMP SetDefaultTarget(HBLDTARGET hTarg, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetActiveTarget((DWORD) hTarg, (DWORD) hBld);
	}

	STDMETHODIMP GetTargetTypeNames(const CStringList **ppList, LPCSTR pchPlat, BOOL fUIDesc)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->GetTargetTypeNames((DWORD *) ppList, pchPlat, fUIDesc) ;
	}

	STDMETHODIMP AssignCustomBuildStep(LPCSTR pchCommand, LPCSTR pchOutput, 
		LPCSTR pchDescription, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AssignCustomBuildStep(pchCommand, pchOutput, 
				pchDescription, (DWORD) hTarg, (DWORD) hFile, (DWORD) hBld);
	}

	STDMETHODIMP UnassignCustomBuildStep(HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->UnassignCustomBuildStep((DWORD) hTarg, (DWORD) hFile, 
			(DWORD) hBld);
	}

	STDMETHODIMP SetToolSettings(HBLDTARGET hTarg, LPCSTR pchSettings, LPCSTR pchTool, 
		BOOL fAdd, BOOL fClear, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetToolSettings((DWORD) hTarg, pchSettings, 
			pchTool, fAdd, fClear, (DWORD) hBld);
	}

	STDMETHODIMP SetToolSettings(HBLDTARGET hTarg, HBLDFILE hFile, LPCSTR pchSettings, 
		LPCSTR pchTool, BOOL fAdd, BOOL fClear)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetToolSettings2((DWORD) hTarg, (DWORD) hFile,
				pchSettings, pchTool, fAdd, fClear);
	}

	STDMETHODIMP AddTarget(HBLDTARGET *pHandle, LPCSTR pchTarg, LPCSTR pchPlat, LPCSTR pchType, 
		BOOL fUIDesc, BOOL fDebug, TrgCreateOp trgop, HBLDTARGET hOtherTarg, SettingOp setop, 
		HBLDTARGET hSettingsTarg, BOOL fQuiet, BOOL fOutDir, BOOL fUseMFC, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AddTarget((DWORD *) pHandle, (DWORD) pchTarg, 
			(DWORD) pchPlat, (DWORD) pchType, fUIDesc, fDebug, (DWORD) trgop, 
			(DWORD) hOtherTarg, (DWORD) setop, (DWORD) hSettingsTarg, fQuiet, 
			fOutDir, fUseMFC, (DWORD)hBld);
	}

	STDMETHODIMP AddDefaultTargets(LPCSTR pchPlat, LPCSTR pchType, 
		HBLDTARGET &hDebugTarg, HBLDTARGET &hReleaseTarg, BOOL fUIDesc, BOOL fOutDir,
		BOOL fUseMFC, HBLDTARGET hMirrorTarg, HBUILDER hBld, LPCSTR pchTarg)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AddDefaultTargets(pchPlat, pchType, 
			(DWORD *) &hDebugTarg, (DWORD *) &hReleaseTarg, fUIDesc, fOutDir,
			fUseMFC, (DWORD) hMirrorTarg, (DWORD) hBld, pchTarg);
	}

	STDMETHODIMP GetTargetOutDir(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);	
		LPTSTR psz = NULL ;
		HRESULT hr = g_AppWizIFace.m_pBldWizX->GetTargetOutDir((DWORD) hTarg, 
				(DWORD *) psz, (DWORD) hBld);

		if (SUCCEEDED(hr))
			strOut = psz;

		return hr ;
	}

	STDMETHODIMP SetTargetOutDir(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);	
		return g_AppWizIFace.m_pBldWizX->SetTargetOutDir((DWORD) hTarg, 
				(DWORD *) strOut.GetBuffer(MAX_PATH), (DWORD) hBld);
		strOut.ReleaseBuffer();
	}

	STDMETHODIMP SetTargetIntDir(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);	
		return g_AppWizIFace.m_pBldWizX->SetTargetOutDir((DWORD) hTarg, 
				(DWORD *) strInt.GetBuffer(MAX_PATH), (DWORD) hBld);
		strInt.ReleaseBuffer();
	}

	STDMETHODIMP SetTargetIsAppWiz(HBLDTARGET hTarg, int iIsAppWiz, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetTargetIsAppWiz((DWORD) hTarg, 
					iIsAppWiz, (DWORD) hBld);
	}

	STDMETHODIMP SetTargetUseOfMFC(HBLDTARGET hTarg, int iUseOfMFC, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetTargetUseOfMFC((DWORD) hTarg, 
					iUseOfMFC, (DWORD) hBld);
	}

	STDMETHODIMP SetTargetDefExt(HBLDTARGET hTarg, CString &strExt, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);	
		LPTSTR psz = NULL ;
		HRESULT hr = g_AppWizIFace.m_pBldWizX->GetTargetOutDir((DWORD) hTarg, 
				(DWORD *) psz, (DWORD) hBld);

		if (SUCCEEDED(hr))
			strExt = psz;

		return hr ;
	}

	STDMETHODIMP SetBuildExclude(HBLDTARGET hTarg, HBLDFILE hFile, BOOL fExclude)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetBuildExclude((DWORD) hTarg, (DWORD) hFile, fExclude);
	}

	STDMETHODIMP AddFolder(HFOLDER *pHandle, HFILESET hFileSet, const TCHAR *pszFolder, HBUILDER hBld, 
		HFOLDER hFolder, const TCHAR * pszFilter)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AddFolder((DWORD *) pHandle, (DWORD) hFileSet, (DWORD *) pszFolder,
				(DWORD) hBld, (DWORD) hFolder, (DWORD *) pszFilter);
	}

	STDMETHODIMP AddFile(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile, 
		int fSettings, HBUILDER hBld, HFOLDER hFolder)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AddFile((DWORD *) pHandle, (DWORD) hFileSet, (DWORD *) ppathFile, 
			fSettings, (DWORD) hBld, (DWORD) hFolder);
	}

	STDMETHODIMP AddMultiFiles(HFILESET hFileSet, const CPtrList *plstpathFiles, 
		CPtrList *plstHBldFiles, int fSettings, HBUILDER hBld, HFOLDER hFolder)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AddMultiFiles((DWORD) hFileSet, (DWORD *) plstpathFiles, 
				(DWORD *) plstHBldFiles, fSettings, (DWORD) hBld, (DWORD) hFolder);
	}

	STDMETHODIMP AddDependencyFile(HFILESET hFileSet, const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->AddDependencyFile((DWORD) hFileSet, (DWORD *) ppathFile, 
			(DWORD) hBld, (DWORD) hFolder);
	}

	STDMETHODIMP GetFileSet(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->GetFileSet((DWORD) hBld, (DWORD) hTarg, (DWORD *) pHandle);
	}

	STDMETHODIMP GetAutoProject(HBUILDER hBld, IBuildProject** ppProject)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->GetAutoProject((DWORD) hBld, (DWORD *) ppProject);
	}

	STDMETHODIMP GetTargetUseOfMFC(HBLDTARGET hTarg, int *iUseOfMFC, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->GetTargetUseOfMFC((DWORD) hTarg, iUseOfMFC, (DWORD) hBld);
	}

	STDMETHODIMP SetUserDefinedDependencies(LPCSTR pchUserDeps, HBLDTARGET hTarg, 
		HBLDFILE hFile, HBUILDER hBld)
	{
		ASSERT(NULL != g_AppWizIFace.m_pBldWizX);
		return g_AppWizIFace.m_pBldWizX->SetUserDefinedDependencies(pchUserDeps, (DWORD) hTarg, 
			(DWORD) hFile, (DWORD) hBld);
	}
};

extern CBldWiz g_CBldWiz ;

#endif //VS_PACKAGE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\wizards\appwiz\mfcappwz.cpp ===
#include "stdafx.h"
#include "mfcappwz.h"
#include "seqdlg.h"
#include "codegen.h"
#include "dlgs.h"
#include "oleutil.h"
#include "ddxddv.h"
#include "projtype.h"
#include "miscdlgs.h"
#include "oledlg.h"
#include "datbdlg.h"
#include "symbols.h"
#include "extend.h"
#include "lang.h"

#ifndef VS_PACKAGE
#include "ids.h"
#endif	// VS_PACKAGE

#include "platname.h"
#include "awiface.h"

#ifndef VS_PACKAGE
#include <bldapi.h>
#include <bldguid.h>
#endif	// VS_PACKAGE

#include <limits.h>

#ifndef VS_PACKAGE
#include <slob.h>
#endif	// VS_PACKAGE

#ifndef VS_PACKAGE
#include <utilctrl.h>
#include <path.h>
#endif	// VS_PACKAGE

#include <dlgbase.h>
#include <direct.h>
#include <time.h>
#include <errno.h>
#include <ctype.h>
#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <windef.h>
#include "dde.h"            // directly send DDEEXECUTE

#ifdef VS_PACKAGE
#include "util.h"  //from sloblib
#else
#include "version.h"        // SLM generated version file
#include <afxdllxx.h>		// our modified version of afxdllx.h
#endif	// VS_PACKAGE

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef VS_PACKAGE
CBldWiz g_CBldWiz;
#endif

AFX_EXTENSION_MODULE AppWizardDLL = { NULL, NULL };

#ifndef VS_PACKAGE
extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;

extern "C" BOOL APIENTRY RawDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		if (!IsShellDefFileVersion(SHELL_DEFFILE_VERSION))
			return(FALSE);
	}
	return(ExtRawDllMain(hInstance, dwReason, lpReserved));
}

extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// Extension DLL one-time initialization.
		if (!AfxInitExtensionModule(AppWizardDLL, hInstance))
			return 0;

		// Wire up this DLL into the resource chain
		new CDynLinkLibrary(AppWizardDLL);

		// Don't need thread attach notifications
		VERIFY(DisableThreadLibraryCalls(hInstance));
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxTermExtensionModule(AppWizardDLL);
	}
	return 1;
}
#endif	// VS_PACKAGE

HINSTANCE GetResourceHandle()
{
	return AppWizardDLL.hModule;
}

// This figures out on the basis of the compiler version whether the current
// product is the learning edition (V5) or not.
BOOL IsLearningBox()
{
	// Assume Learning is false if any failure occurs.
	static BOOL bHaveChecked = FALSE;
	static BOOL bIsLearning = FALSE;

	if (bHaveChecked)
		return bIsLearning;

	bHaveChecked = TRUE;

	DWORD dw;
	CString strC2Dir;
	TCHAR szBuf [MAX_PATH];
	HKEY hKey;

	// strVCDir = "\\\\HKEYLOCALMACHINE\\microsoft\\devstudio\\products\\Microsoft Visual C++\\ProductDir"
	if ( RegOpenKeyEx (
		HKEY_LOCAL_MACHINE, _T ("Software\\Microsoft\\DevStudio\\6.0\\Products\\Microsoft Visual C++"),
		0, KEY_READ, &hKey) == ERROR_SUCCESS 
	   )
	{
		DWORD dwType, cbData = MAX_PATH;
		if (RegQueryValueEx (hKey, _T ("ProductDir"), NULL, &dwType, (LPBYTE) szBuf, &cbData) == ERROR_SUCCESS)
		{
			ASSERT (dwType == REG_SZ);
			szBuf [cbData] = 0;
			strC2Dir = szBuf;
			strC2Dir+="\\bin\\c2.dll";
		}
		RegCloseKey (hKey);
	}	

	TCHAR *szC2 = strC2Dir.GetBuffer(strC2Dir.GetLength());

	// Get version information from c2.exe.
	DWORD dwSize = GetFileVersionInfoSize( szC2, &dw );
	if (0!=dwSize)
	{
		LPVOID lpBuffer = new BYTE[dwSize];

		if (NULL==lpBuffer)
			return bIsLearning;

		if (GetFileVersionInfo( szC2, dw, dwSize, lpBuffer))
		{
			UINT uLen;
			VS_FIXEDFILEINFO* pVerInfo;
			if (0!=VerQueryValue( lpBuffer, _T("\\"), (LPVOID*)&pVerInfo, &uLen ))
			{
				// if the last digit in the version number is an 8 or a 9
				// then we have the learning edition
				UINT lower = pVerInfo->dwFileVersionMS & 0x0000FFFF;
				bIsLearning = ( lower % 10 ) >= 8 ;
			}
		}
		delete [] lpBuffer;
	}
	return bIsLearning;
}


/////////////////////////////////////////////////////////////////////////////
// mfc\src internal def
BOOL PASCAL _AfxFullPath(LPSTR lpszPathOut, LPCSTR lpszFileIn);

/////////////////////////////////////////////////////////////////////////////
// keys for Registry

//char BASED_CODE szMSVCSection[] = "Software\\Microsoft\\Visual C++ 3.0";
//char BASED_CODE szMSVCGeneralSection[] = "Software\\Microsoft\\Visual C++ 3.0\\General";
//char BASED_CODE szMFCPathKey[] = "MFCPath32Bit";
//static char BASED_CODE szHelpKey[] = "HelpFile32Bit";
//static char BASED_CODE szHelpFile[] = "MSVC20.HLP";

// Special string for user data of CMainDlg.  It identifies the window as the
//  AppWizard main window.
static LPCTSTR szMainDlgUserData = "AppWizard main window";

/////////////////////////////////////////////////////////////////////////////
// structures

struct ClassCategoryInfo
{
  int categoryID;
  const char* condition;
};

struct BaseClassInfo
{
  int categoryID;
  const char* baseClass;
  const char* condition;
};

// ClassCategoryInfo is used to determine which classes will be created
//  depending upon the symbols that are defined.  Any class with NULL
//  as a condition is always created.  A class listed more than once
//  with multiple symbols indicates an OR condition.  Multiple symbols
//  separated by (exactly) " && " indicates an AND condition (see
//  classDlgAutoProxy).
static ClassCategoryInfo classCategories[] =
{
    { classView, "PROJTYPE_NOT_DLG" },
    { classLeftView, "PROJTYPE_EXPLORER" },
    { classApp, NULL },
    { classFrame, "PROJTYPE_NOT_DLG" },
    { classFrame, "NODOCVIEW" },
    { classChildFrame, "MDICHILD" },
    { classDoc, "PROJTYPE_NOT_DLG" },
    { classDlg, "PROJTYPE_DLG"},
    { classRecset, "CRecordView" },
    { classRecset, "CDaoRecordView" },
    { classRecset, "COleDBRecordView" },
    { classSrvrItem, "MINI_SERVER" },
    { classSrvrItem, "FULL_SERVER" },
    { classSrvrItem, "CONTAINER_SERVER" },
    { classCntrItem, "CONTAINER" },
    { classCntrItem, "CONTAINER_SERVER" },
    { classIPFrame, "MINI_SERVER" },
    { classIPFrame, "FULL_SERVER" },
    { classIPFrame, "CONTAINER_SERVER" },
	{ classDlgAutoProxy, "PROJTYPE_DLG && AUTOMATION" },
    { classWndView, "NODOCVIEW" },
    { -1, NULL }
};


// BaseClassInfo is used to determine the base class of a given class.  The
//  base class is determined by finding the first entry where 1) the condition
//  is NULL or 2) the condition is TRUE.  Specific base classes depending on
//  symbol settings should therefore be placed before the generic ones where
//  the condition is NULL.
// Note: it is not necessary to qualify a class with its symbolic conditions
//  if it is always the same.  For example, classIPFrame will only be
//  created when either CONTAINER_SERVER, MINI_SERVER, or FULL_SERVER is
//  defined, but it is not necessary to qualify it as such.  That job is
//  handled by the ClassCategoryInfo above.
static BaseClassInfo baseClasses[] =
{
    { classApp, "CWinApp", NULL },
    { classFrame, "CMDIFrameWnd", "PROJTYPE_MDI" },
    { classFrame, "CFrameWnd", NULL },
    { classChildFrame, "CMDIChildWnd", NULL },
    { classRecset, "CDAORecordset", "DAO" },
    { classRecset, "CCommand", "OLEDB" },
	{ classRecset, "CRecordset", NULL },
	{ classDoc, "CRichEditDoc", "CRichEditView" },
	{ classDoc, "COleDocument", "CONTAINER" },
    { classDoc, "COleServerDoc", "FULL_SERVER" },
    { classDoc, "COleServerDoc", "MINI_SERVER" },
    { classDoc, "COleServerDoc", "CONTAINER_SERVER" },
    { classDoc, "CDocument", NULL },
    { classDlg, "CDialog", NULL },
	{ classSrvrItem, "CDocObjectServerItem", "ACTIVE_DOC_SERVER" },
    { classSrvrItem, "COleServerItem", NULL },
    { classCntrItem, "CRichEditCntrItem", "CRichEditView" },
	{ classCntrItem, "COleDocObjectItem", "ACTIVE_DOC_CONTAINER" },
	{ classCntrItem, "COleClientItem", NULL },
	{ classIPFrame, "COleDocIPFrameWnd", "ACTIVE_DOC_SERVER" },
    { classIPFrame, "COleIPFrameWnd", NULL },
	{ classDlgAutoProxy, "CCmdTarget", NULL },
	{ classLeftView, "CTreeView", NULL },
	{ classWndView, "CWnd", NULL },
    { -1, NULL, NULL }
};
// CView is a hard-coded special case, and is intentionally left out of baseClasses[].

/////////////////////////////////////////////////////////////////////////////
// Global state

// HINSTANCE hMSVCResHandle = NULL;

CWnd* pLaunchParent = NULL;     // will be non-null if launched from IDE
CStringList strlProjTypes;

const TCHAR* szPlatforms[] =
{
#if defined(_X86_)
	"Win32 (x86)",
#elif defined(_MIPS_)
	"Win32 (MIPS)",
#elif defined(_ALPHA_)
	"Win32 (ALPHA)",
#else
#error "Define TARGET for this platform"
#endif
	"Macintosh",
	"Power Macintosh",
	"Java Virtual Machine",
    "Xbox",
};
#if defined(_X86_)
#define TARGET "TARGET_INTEL"
#elif defined(_MIPS_)
#define TARGET "TARGET_MIPS"
#elif defined(_ALPHA_)
#define TARGET "TARGET_ALPHA"
#else
#error "Define TARGET for this platform"
#endif
CMapStringToString g_PlatformsSelected; // Long names of selected platforms
void InitPlatformsSelected()
{
	g_PlatformsSelected.RemoveAll();
	g_PlatformsSelected[szPlatforms[WIN]] = TARGET;
	g_PlatformsSelected[szPlatforms[MAC]] = "TARGET_68KMAC";
	g_PlatformsSelected[szPlatforms[POWERMAC]] = "TARGET_POWERMAC";
	g_PlatformsSelected[szPlatforms[JAVA]] = "TARGET_JAVA";
    g_PlatformsSelected[szPlatforms[XBOX]] = "TARGET_XBOX";
}
#undef TARGET
CPlatNameConvert g_PlatNameConvert;

// This remembers what AppWizard has last inserted into the platforms checklist,
//  so that when we get pnPlatforms back from CPromptDlg, we'll know what the hell
//  it's talking about.  (I.e., we'll know what indices of pnPlatforms correspond
//  to what platforms.)
CStringList g_strlPlatformsDisplayed;


#define WM_MYQUIT WM_USER+3
struct Message
{
    UINT messageName;
    WPARAM wparam;
    LPARAM lparam;
} msgNotification;

AppWizTermStatus g_TermStatus;
AppWizTermStatus* pTermStatus = &g_TermStatus;

void CreateDirectory(const char* szDir, BOOL bChangeTo);	// Defined in codegen.cpp
BOOL GenerateDBBindings(CString& strDecls, CString& strInits, CString& strRFX);

//static BOOL bODBCInstalled;
static BOOL bOLEInstalled;

//////////////////////////////////////////////////////////////////////////////

ProjOptions projOptions;   // Contains all user-set options, visible to all dlgs.


BOOL IsMacInstalled()
{
#ifndef VS_PACKAGE
	// Determine available platforms for a vanilla Application
	LPBUILDPLATFORMS pPlatforms;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&pPlatforms)));

	const CStringList* pPlatformsLong;
	pPlatforms->GetAvailablePlatforms(&pPlatformsLong, strlProjTypes.GetHead(), FALSE);
	pPlatforms->Release();

	// See if we can find the Mac platform
	POSITION pos = pPlatformsLong->GetHeadPosition();
	while (pos != NULL)
	{
		CString strLong = pPlatformsLong->GetNext(pos);
		if (strLong == szPlatforms[MAC] || strLong == szPlatforms[POWERMAC])
			return TRUE;
	}
	return FALSE;
#endif
	return FALSE ;
}

void MakeOKDefault(CMainDlg* pMainDlg)
{
	pMainDlg->SetDefID(IDOK);
	((CButton*) (pMainDlg->GetDlgItem(ID_HELP)))->SetButtonStyle(BS_PUSHBUTTON);
    ((CButton*) (pMainDlg->GetDlgItem(IDCANCEL)))->SetButtonStyle(BS_PUSHBUTTON);
    ((CButton*) (pMainDlg->GetDlgItem(IDC_BACK)))->SetButtonStyle(BS_PUSHBUTTON);
    ((CButton*) (pMainDlg->GetDlgItem(IDC_END)))->SetButtonStyle(BS_PUSHBUTTON);
	((CButton*) (pMainDlg->GetDlgItem(IDOK)))->SetButtonStyle(BS_DEFPUSHBUTTON);
}

/*BOOL IsaMainBtn(char c)
{
	return (c == 'n' || c == 'N'
		|| c == 'b' || c == 'B'
		|| c == 'f' || c == 'F'
		|| c == 'h' || c == 'H');
}*/

//////////////////////////////////////////////////////////////////////////////
// Borrowed from \cmpnt\src\profile.cpp
// Code for getting the correct help file path

BOOL BuildHelpPath(LPCSTR szHelpPath, LPCSTR szHelpFile, LPSTR szFullHelpPath)
{
    BOOL bRet = FALSE ;

    // blechh...  I hate casting away const, but it turns out that
    // this function doesn't really change the strings so I guess
    // it's okay
    LPSTR lpNextHelpPath = (LPSTR) szHelpPath;
    do
    {
        LPSTR lpCurrentHelpPath = lpNextHelpPath;
        lpNextHelpPath = strchr(lpCurrentHelpPath,';');
        if (lpNextHelpPath)
            *lpNextHelpPath = '\0';
        strcpy(szFullHelpPath,lpCurrentHelpPath) ;
        // Add a backslash if necessary
		TCHAR ch = *_tcsdec((TCHAR*) szFullHelpPath,
			((TCHAR*) szFullHelpPath) + _tcslen((TCHAR*) szFullHelpPath));
        if (ch != '\\')
            _tcscat((TCHAR*) szFullHelpPath, "\\") ;
        strcat(szFullHelpPath,szHelpFile) ;
        bRet = (_access(szFullHelpPath, 0) == 0);
        if (lpNextHelpPath)
        {
            *lpNextHelpPath = ';';
            lpNextHelpPath++;
        }
    }
    while (bRet == FALSE && lpNextHelpPath != NULL);

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////


void fillBaseClasses(CString bc[])
{
    int i = 0;
    int currID = -1;
    BaseClassInfo *pbci;
    while ((pbci = &baseClasses[i])->categoryID != -1)
    {
        CString value;
        currID = pbci->categoryID;
        // Pass over undefined symbols
        for( ; (pbci->condition != NULL) &&
            !DoesSymbolExist(pbci->condition) &&
            currID == pbci->categoryID; pbci = &baseClasses[++i])
            ;
        if (currID == pbci->categoryID)    // We found a defined symbol or NULL
        {
            ASSERT(currID != -1);
            // Enter base class name and skip to next category
            bc[currID] = pbci->baseClass;
            for (; currID == pbci->categoryID; pbci = &baseClasses[++i])
                ;
        }
        // (Otherwise, we've already skipped to the next category or the end.)
    }
}

// Helper used by fillCategoryEnabled as it parses through
//  the conditions in classCategories.  This simply parses
//  out any "&&"'s between symbols, indicating an 'and' condition
static BOOL IsClassConditionTrue(LPCTSTR szCondition)
{
	const int MAX_CONDITION_SIZE = 256;
	if (_tcslen(szCondition) >= MAX_CONDITION_SIZE)
	{
		// If this assert fails, a really big condition was passed.
		//  You may need to increase MAX_CONDITION_SIZE
		ASSERT(FALSE);
		return FALSE;
	}

	// Copy to our writeable stack buffer
	TCHAR szConditionBuffer[MAX_CONDITION_SIZE];
	_tcscpy(szConditionBuffer, szCondition);
	LPTSTR szCurrCondition = szConditionBuffer;
	LPTSTR szNextCondition = szCurrCondition-4;		// Compensate for initial iteration

	while (szNextCondition != NULL)
	{
		szCurrCondition = szNextCondition + 4;	// Skip over " && "

		// Find the end of the current symbol
		szNextCondition = _tcschr(szCurrCondition, ' ');
		if (szNextCondition != NULL)
		{
			// A space must be followed by double ampersands
			//  and then the next symbol e.g.,: "SYMBOL1 && SYMBOL2"
			ASSERT (*(szNextCondition+1) == '&');
			ASSERT (*(szNextCondition+2) == '&');
			ASSERT (*(szNextCondition+3) == ' ');
			ASSERT (*(szNextCondition+4) != '\0');

			*szNextCondition = '\0';	// plug it up so we don't read past current condition
		}

		if (!DoesSymbolExist(szCurrCondition))
			return FALSE;		// If any of the symbol is FALSE, return FALSE
	}

	// We survived this long, it must be TRUE
	return TRUE;
}

void fillCategoryEnabled(BOOL bce[])
{
    // First, reset enabled's to FALSE.
    for(int i=0; i < classMax; i++)
        bce[i] = FALSE;

    i=0;
    int currID = -1;
    ClassCategoryInfo *pcci;
    while ((pcci=&classCategories[i])->categoryID != -1)
    {
        CString value;
        currID = pcci->categoryID;

        // Pass over undefined symbols
        for( ; (pcci->condition != NULL) &&
            !IsClassConditionTrue(pcci->condition) &&
            currID == pcci->categoryID; pcci = &classCategories[++i])
            ;
        if (currID == pcci->categoryID)    // We found a defined symbol or NULL
        {
            ASSERT(currID != -1);
            bce[currID] = TRUE;
            for (; currID == pcci->categoryID; pcci = &classCategories[++i])
                ;
        }
        // (Otherwise, we've already skipped to the next category or the end.)
    }
}

/////////////////////////////////////////////////////////////////////////////
// Prevent overlap of canned classes or project name

//TODO: need to regen the mfcclass.h to include new classes!

char* rgszReserved[] =
{
#include "mfcclass.h"
    NULL
};

//TODO: need to regen the mfcproj.h to include new .DLLs and other
//reserved project names


static BOOL IsReservedClassName(const char* psz)
{
    for (char **ppsz = rgszReserved; *ppsz != NULL; ppsz++)
    {
        if (strcmp(psz, *ppsz) == 0)
            return TRUE;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Name verification dialog

void MakeDefRegID(const TCHAR* pch, CString& rRegID)
{
	rRegID.Empty();
	for( ; *pch != '\0'; pch = _tcsinc(pch))
	{
		if (*pch != '_')
		{
			rRegID += *pch;
		}
	}
	
	if (rRegID.IsEmpty() || _istdigit(rRegID[0]))
	   	rRegID += "My";

	rRegID += ".Document";
}

BOOL IsLower(const TCHAR* sz)
{
	CString str = sz;
	str.MakeLower();
	return (str == sz);
}

void GetTag(CString& tag, LPCTSTR szRoot /* = NULL */)
{
	if (szRoot == NULL)
		szRoot = projOptions.m_strProj;
	tag.Empty();
	
	const TCHAR* pch = szRoot;
	for( ; *pch != '\0'; pch = _tcsinc(pch))
	{
		if(_istalnum(*pch)	// Strip characters that cannot be in class names
		   || *pch == '_')  // valid chars are 'A'-'Z', 'a'-'z', '0'-'9', '_'
		{
			tag += *pch;
		}
    }
    if(tag.IsEmpty())		// An empty tag would produce: CApp, CDoc, and CView
    	tag = "My";			// CView would become CMyView, so just make tag="My"

	if (_istdigit(tag[0]))	// Can't begin with number
		tag = "My" + tag;

	if (!tag.Compare(_T("Custom")))		// probably only important for custom AppWiz...
		tag = _T("My") + tag;

	tag.SetAt(0, (TCHAR)_totupper(tag[0]));		// make 1st character upper

	// Limit length of tag so generated class names don't exceed _MAX_SYMBOL
	#define MAX_ADDED_TO_TAG 10
	if (tag.GetLength() + MAX_ADDED_TO_TAG > _MAX_SYMBOL)
		tag = tag.Left(_MAX_SYMBOL - MAX_ADDED_TO_TAG);
}

// NOTE: Adding additional classes (and consequently more default naming schemes)
//  requires updating InterfereWithDefaults() below.
// Also, no symbols are guaranteed to be set when this is called (like TARGET_MAC)
//  If a name depends on symbols, use FillTruncatedDefaultNames
void FillDefaultNames(NAMES& names, const char* pszRoot)
{
	ASSERT(*pszRoot != 0);	// empty Root is invalid

	CString tag;
	GetTag(tag, pszRoot);

	projOptions.m_strProjTag = tag;

    CString filebase = pszRoot;

    // Fill in names of base classes
    fillBaseClasses(names.strBaseClass);

    // App (file names are read-only)
    names.strClass[classApp] = "C" + tag + "App";
	if (IsReservedClassName(names.strClass[classApp]))
		names.strClass[classApp] = "CMy" + tag + "App";
	            //eg: when tag=="Win", CWinApp -> CMyWinApp

    // Frame (base class is read-only)
    names.strClass[classFrame] = "CMainFrame";
    names.strHFile[classFrame] = "MainFrm.h";
    names.strIFile[classFrame] = "MainFrm.cpp";

    // Child frame (base class is read-only)
    names.strClass[classChildFrame] = "CChildFrame";
    names.strHFile[classChildFrame] = "ChildFrm.h";
    names.strIFile[classChildFrame] = "ChildFrm.cpp";

    // Inplace frame (base class is read-only)
    names.strClass[classIPFrame] = "CInPlaceFrame";
    names.strHFile[classIPFrame] = "IpFrame.h";
    names.strIFile[classIPFrame] = "IpFrame.cpp";

    // Left View of Explorer (base class is read-only)
    names.strClass[classLeftView] = "CLeftView";
    names.strHFile[classLeftView] = "LeftView.h";
    names.strIFile[classLeftView] = "LeftView.cpp";

    // Left View of Explorer (base class is read-only)
    names.strClass[classWndView] = "CChildView";
    names.strHFile[classWndView] = "ChildView.h";
    names.strIFile[classWndView] = "ChildView.cpp";

    // Document
    names.strClass[classDoc] = "C" + tag + "Doc";
    if (IsReservedClassName(names.strClass[classDoc]))
        names.strClass[classDoc] = "CMy" + tag + "Doc";
    CString filename = filebase + "Doc";
    names.strHFile[classDoc] = filename + ".h";
    names.strIFile[classDoc] = filename + ".cpp";
	projOptions.m_bUpdateRegID = TRUE;

    /*names.strDocTag = tag;
    if (names.strDocTag.GetLength() > MAX_TAG)
        names.strDocTag = names.strDocTag.Left(MAX_TAG);
	names.strDocFilter = "";
	names.strDocFileNew = names.strDocTag;
	names.strDocRegName = names.strDocTag + " Document";
	projOptions.m_bUpdateFilter
		= projOptions.m_bUpdateFileNew
		= projOptions.m_bUpdateRegName = TRUE;*/

	// TODO: Use langdll
/*	if (projOptions.m_bFilesAfter)
		names.strDocFilter = names.strDocFileType + " "
			+ projOptions.m_strFiles;
	else
		names.strDocFilter = projOptions.m_strFiles + " "
			+ names.strDocFileType;*/
	// TODO: Should keep this Mixed?
	//names.strTitle = Mixed(pszRoot);
	names.strTitle = pszRoot;



	MakeDefRegID(tag, names.strDocRegID);
	names.strDocFileExt = "";

	// file type & creator must have exactly 4 characters.  Pad on right
	//  with ' ' if necessary
	names.strDocFileCreator = tag.Left(4);
	int nLen = names.strDocFileCreator.GetLength();
	if (nLen < 4)
	{
		CString strPad(' ', 4 - nLen);
		names.strDocFileCreator += strPad;
	}
	names.strDocFileCreator.MakeUpper();
	names.strDocFileType = names.strDocFileCreator;
    // View
    names.strClass[classView] = "C" + tag + "View";
    if (IsReservedClassName(names.strClass[classView]))
        names.strClass[classView] = "CMy" + tag + "View";
                //eg: CEditView -> CMyEditView
    if (names.strBaseClass[classView].IsEmpty())
        names.strBaseClass[classView] = "CView";
    filename = filebase + "View";   // don't abbreviate
    names.strHFile[classView] = filename + ".h";
    names.strIFile[classView] = filename + ".cpp";

    // Record set (base class is read-only)
    names.strClass[classRecset] = "C" + tag + "Set";
    if (IsReservedClassName(names.strClass[classRecset]))
        names.strClass[classRecset] = "CMy" + tag + "Set";
	switch(projOptions.m_nDataSource) {
		case dbOdbc:
			names.strBaseClass[classRecset] = "CRecordset";
			break;
		case dbDao:	
			names.strBaseClass[classRecset] = "CDAORecordset";
			break;
		case dbOledb:	
			names.strBaseClass[classRecset] = "CCommand";
			break;
		default:
			break;
	}
	
    filename = filebase + "Set";    // don't abbreviate
    names.strHFile[classRecset] = filename + ".h";
    names.strIFile[classRecset] = filename + ".cpp";

    // Dialog (for dialog-based app)
    names.strClass[classDlg] = "C" + tag + "Dlg";
    if (IsReservedClassName(names.strClass[classDlg]))
        names.strClass[classDlg] = "CMy" + tag + "Dlg";
    filename = filebase + "Dlg";    // don't abbreviate
    names.strHFile[classDlg] = filename + ".h";
    names.strIFile[classDlg] = filename + ".cpp";

	// Dialog's automation proxy (for dlg-based app w/ automation)
	names.strClass[classDlgAutoProxy] = names.strClass[classDlg] + "AutoProxy";
	names.strHFile[classDlgAutoProxy] = "DlgProxy.h";
	names.strIFile[classDlgAutoProxy] = "DlgProxy.cpp";

    // Container Item
    names.strClass[classCntrItem] = "C" + tag + "CntrItem";
    if (IsReservedClassName(names.strClass[classCntrItem]))
		names.strClass[classCntrItem] = "CMy" + tag + "CntrItem";
    names.strHFile[classCntrItem] = "CntrItem.h";
    names.strIFile[classCntrItem] = "CntrItem.cpp";
        // Note: not based on project name because too hard to come
        //  up with meaningful 4 and 2 character abbreviations
        //  for ServerItem and ContainerItem.

    // Server Item
    names.strClass[classSrvrItem] = "C" + tag + "SrvrItem";
    ASSERT(!IsReservedClassName(names.strClass[classSrvrItem]));
    names.strHFile[classSrvrItem] = "SrvrItem.h";
    names.strIFile[classSrvrItem] = "SrvrItem.cpp";
}

// these are read-only
void UpdateTrackingNames(NAMES& names, const char* pszRoot)
{
    CString filebase = pszRoot;

    // classApp names are always based on the app name
    names.strHFile[classApp] = filebase + ".h";
    names.strIFile[classApp] = filebase + ".cpp";

    // update base class names
    fillBaseClasses(names.strBaseClass);
}

// If we're run by the IDE, we need to tell it that we're exiting when
//  the user hits Cancel.
void CancelAppWiz()
{
    if (pLaunchParent == NULL) return;

    pLaunchParent->EnableWindow(TRUE);
	pLaunchParent->SetActiveWindow();
    ASSERT(pLaunchParent->IsWindowEnabled());
	pTermStatus->nTermType = APPWIZTERMTYPE_CANCEL;
}


/////////////////////////////////////////////////////////////////////////////
// Intro dialog

// OLE type equates
extern char* oleOptions[5];

class CNamesDlg;

class CConfirmDlg : public C3dDialog
{
// Construction
public:
    CConfirmDlg(CWnd* pParent = NULL, BOOL bHasCancel = TRUE);  // standard constructor

// Dialog Data
    CString m_strDir;
    //{{AFX_DATA(CConfirmDlg)
    enum { IDD = IDD_CONFIRM };
    CEdit m_stcOutput;
    CStatic m_stcDir;
    //}}AFX_DATA

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    // Generated message map functions
    //{{AFX_MSG(CConfirmDlg)
    virtual BOOL OnInitDialog();
	afx_msg void OnHelp();
    virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
    //afx_msg void OnClickedBack();
    DECLARE_MESSAGE_MAP()
	BOOL m_bHasCancel;

private:
    void SetSymbols();
};




extern char* rgszOptions[];
extern char* rgszProjOptions[];


extern char* rgszFrameStyles[];
extern char* rgszChildFrameStyles[];

extern char* szDefaultViews[];
extern const char* szProjTypeString[];

/*
/////////////////////////////////////////////////////////////////////////////
// file path helpers

// stolen from ClassWizard->
#define wInvalidName    0
#define wIsFile         1
#define wIsDir          2

static int QualifyFileName(const char* pszFileName, char* pszQualified)
    // grunge for getting the currently selected file name
    // and for telling whether it is likely to exist when we need it
{
    if (_fullpath(pszQualified, pszFileName, _MAX_PATH) == NULL)
        return wInvalidName;
    _tcslwr((TCHAR*) pszQualified);
	// NOTE: We use GetFileAttributes instead of _stat to allow for UNC names.
	DWORD nAttributes = GetFileAttributes(pszQualified);
	if (nAttributes == 0xffffffff)
		return wInvalidName;
	if (nAttributes & FILE_ATTRIBUTE_DIRECTORY)
        return wIsDir;  // directory or something strange happened
    return wIsFile;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog

class CStatusDlg : public C3dDialog
{
    enum { IDD = IDD_PROGRESS };

// Construction
public:
    CStatusDlg(CWnd* pParent)   // modeless constructor
	: C3dDialog(CStatusDlg::IDD, pParent)
    {
        Create(MAKEINTRESOURCE(CStatusDlg::IDD), pParent);
    }
    BOOL OnInitDialog()
    {
        CenterWindow();
		//ShowWindow(SW_SHOW);
        return C3dDialog::OnInitDialog();     // does DDX
   }
};


int GetDefaultFrameStyles()
{
	return 1<<(IDC_THICKFRAME - FRAME_STYLES_START)
		| 1<<(IDC_SYSMENU - FRAME_STYLES_START)
		| 1<<(IDC_MINIMIZEBOX - FRAME_STYLES_START)
		| 1<<(IDC_MAXIMIZEBOX - FRAME_STYLES_START);
}

int GetDefaultChildFrameStyles()
{
	return 1<<(IDC_CHILD_THICKFRAME - CHILD_FRAME_STYLES_START)
		| 1<<(IDC_CHILD_MINIMIZEBOX - CHILD_FRAME_STYLES_START)
		| 1<<(IDC_CHILD_MAXIMIZEBOX - CHILD_FRAME_STYLES_START);
}

/////////////////////////////////////////////////////////////////////////////
// Names dialog

class CNamesDlg : public CSeqDlg
{
public:
    CNamesDlg(CWnd* pParent = NULL);
	virtual void WriteValues();
    //{{AFX_DATA(CNamesDlg)
    enum { IDD = IDD_NAMES };
    //}}AFX_DATA
    CListBox    m_classList;
    virtual BOOL CanDestroy();
	virtual BOOL ShouldShowPicture() { return TRUE; }
	virtual UINT ChooseBitmap() { return IDB_FLAG; }
	virtual int GetBitmapSizeIndex() { return BMPSIZE_FLAG; }
	
// Implementation
    BOOL OnInitDialog();
    int m_iSelOld;  // old selection index (not index into class list)

    virtual void DoDataExchange(CDataExchange* pDX);

    //{{AFX_MSG(CNamesDlg)
    afx_msg void OnSelectClass();
    afx_msg void OnSelchangeBaseClass();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CNamesDlg::CNamesDlg(CWnd* pParent)
    : CSeqDlg(CNamesDlg::IDD, pParent)
{
}

BEGIN_MESSAGE_MAP(CNamesDlg, CSeqDlg)
    //{{AFX_MSG_MAP(CNamesDlg)
    ON_LBN_SELCHANGE(IDC_CLASS_LIST, OnSelectClass)
    ON_CBN_SELCHANGE(IDC_BASE_CLASS_COMBO, OnSelchangeBaseClass)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define OPT_DB                  1

// Item data to determine whether CRecordView is selected in combo box.
/*#define VIEW_OTHER   1
#define VIEW_RECORD  2*/

BOOL CNamesDlg::OnInitDialog()
{
    // If class names not yet filled in, use default names.
    if (projOptions.m_names.strClass[0].IsEmpty())
        FillDefaultNames(projOptions.m_names, projOptions.m_strProj);   // just use defaults

	// We shouldn't need this set here, since it's set after first dialog.
	//SetProjectTypeSymbol();

    // First, set view base class symbols.
    SetBaseViewSymbols();

	// Be sure the other base classes are set correctly (may depend on "CRichEditView" being
	//  set, which we did above in SetBaseViewSymbols()).
	fillBaseClasses(projOptions.m_names.strBaseClass);

    VERIFY(m_classList.SubclassDlgItem(IDC_CLASS_LIST, this));

    // Set relevant symbols so the correct classes appear in the list

    // DB_SIMPLE
    if (projOptions.m_bDBSimple)
		SetSymbol("DB_NO_FILE", "1");
    else
		RemoveSymbol("DB_NO_FILE");
    if (projOptions.m_nProjType == PROJTYPE_DLG)
    {
		// KEEP!!! the NOT used for classes dialog
        SetSymbol("PROJTYPE_DLG", "1");
        RemoveSymbol("PROJTYPE_NOT_DLG");
    }
    else
    {
        RemoveSymbol("PROJTYPE_DLG");
		if( projOptions.m_bNoDocView ){
			RemoveSymbol("PROJTYPE_NOT_DLG");
		} else {
			SetSymbol("PROJTYPE_NOT_DLG", "1");
		}
    }
    if (projOptions.m_nProjType != PROJTYPE_DLG && !projOptions.m_bDBSimple)
    {
        SetSymbol("NOT_DLG_OR_SIMPLE", "1");
    }
    else
    {
        RemoveSymbol("NOT_DLG_OR_SIMPLE");
    }
	
	// Third, CMDIChildWnd
	SetChildFrameSymbols();
	SetSplitterSymbols();

    // Fill with class list - non-sorted so we can use index for 'iClass'.
    //  Only enter those classes that are enabled
    ASSERT(!(m_classList.GetStyle() & LBS_SORT));
    fillCategoryEnabled(projOptions.m_names.bCategoryEnabled);
    for (int iClass = 0; iClass < classMax; iClass++)
    {
        if (projOptions.m_names.bCategoryEnabled[iClass])
        {
            int i = m_classList.AddString(projOptions.m_names.strClass[iClass]);
            TRACE2("Added class '%s'@%d\n",
                (const char*)projOptions.m_names.strClass[iClass], i);
            m_classList.SetItemData(i, iClass);
        }
    }
    m_classList.SetCurSel(m_iSelOld = 0);

    // Fill base-class-for-view combo box
    CComboBox* comboBox = (CComboBox*)GetDlgItem(IDC_BASE_CLASS_COMBO);
    ASSERT(comboBox);
    comboBox->ResetContent();
    for (int i=0; i < DEFAULT_VIEWS_COUNT; i++)  // First, add default views
    {
        int j = comboBox->AddString(szDefaultViews[i]);
        //comboBox->SetItemData(j, VIEW_OTHER);
        TRACE1("Added view '%s'\n", (const char*)szDefaultViews[i]);
    }
    // Add database view if appropriate
    // We're now allowing CRecordView in the combo iff DB support is
    //  chosen and a data source was selected.
    CString tmp;
    if (projOptions.m_bDBHeader &&
        DoesSymbolExist("DB_SOURCE"))
    {
        int j;
		switch(projOptions.m_nDataSource) {
			case dbOdbc:
				j = comboBox->AddString("CRecordView");
				break;
			case dbDao:	
				j = comboBox->AddString("CDaoRecordView");
				break;
			case dbOledb:	
				j = comboBox->AddString("COleDBRecordView");
				break;
			default:
				break;
		}
        //comboBox->SetItemData(j, VIEW_RECORD);
    }
	// Don't add editview if we're a type of OLE container, or we're using splitters
    if (projOptions.m_nOleType != OLE_CONTAINER && projOptions.m_nOleType != OLE_CSERVER
		&& (!DoesSymbolExist("SPLITTER")))
    {
        int j = comboBox->AddString("CEditView");
        //comboBox->SetItemData(j, VIEW_OTHER);
    }

	// Don't add htmlview if we're a type of OLE container
    if (projOptions.m_nOleType == OLE_NO)
    {
        int j = comboBox->AddString("CHtmlView");
        //comboBox->SetItemData(j, VIEW_OTHER);
    }

    CDialog::OnInitDialog();        // does DDX
    CenterWindow();
    return TRUE;
}

void CNamesDlg::OnSelectClass()
{
    // get current selection
    int iSel = m_classList.GetCurSel();
    ASSERT(iSel >= 0);
    if (m_iSelOld == iSel)
        return;

    // get class ID associated with that item
    int iClass = (int)m_classList.GetItemData(iSel);
    if (!UpdateData(TRUE))      // save old class
    {
        // restore to old selection
        m_classList.SetCurSel(m_iSelOld);
        return;
    }

    // class name may have changed
    CString oldName;
    int iClassOld = (int)m_classList.GetItemData(m_iSelOld);
    m_classList.GetText(m_iSelOld, oldName);
    if (projOptions.m_names.strClass[iClassOld] != oldName)
    {
        m_classList.DeleteString(m_iSelOld);
        m_classList.InsertString(m_iSelOld, projOptions.m_names.strClass[iClassOld]);
        m_classList.SetItemData(m_iSelOld, iClassOld);
        m_classList.SetCurSel(iSel);
    }

    m_iSelOld = iSel;
    UpdateData(FALSE);      // re-fill data with new class
}

void CNamesDlg::DoDataExchange(CDataExchange* pDX)
{
    int iClass = (int)m_classList.GetItemData(m_iSelOld);
    ASSERT(iClass >= 0 && iClass < classMax);

    DDX_Text(pDX, IDC_CLASS_NAME, projOptions.m_names.strClass[iClass]);
	projOptions.m_names.strClass[iClass].ReleaseBuffer();
    DDV_ClassName(pDX, projOptions.m_names.strClass[iClass]);
    if (iClass != classView)
	{
        DDX_Text(pDX, IDC_BASE_CLASS, projOptions.m_names.strBaseClass[iClass]);
		projOptions.m_names.strBaseClass[iClass].ReleaseBuffer();
	}
    DDV_ClassName(pDX, projOptions.m_names.strBaseClass[iClass]);
    if (iClass == classView)
	{
        DDX_CBString(pDX, IDC_BASE_CLASS_COMBO, projOptions.m_names.strBaseClass[iClass]);
		projOptions.m_names.strBaseClass[iClass].ReleaseBuffer();
	}
    DDV_ClassName(pDX, projOptions.m_names.strBaseClass[iClass]);
    DDX_Text(pDX, IDC_HFILE, projOptions.m_names.strHFile[iClass]);
 	projOptions.m_names.strHFile[iClass].ReleaseBuffer();
 	DDV_FileName(pDX, projOptions.m_names.strHFile[iClass], ".h");
    DDX_Text(pDX, IDC_IFILE, projOptions.m_names.strIFile[iClass]);
 	projOptions.m_names.strIFile[iClass].ReleaseBuffer();
    DDV_FileName(pDX, projOptions.m_names.strIFile[iClass], ".cpp");

    BOOL bEnableExtras = FALSE;
    BOOL bEnableBaseEdit = FALSE;       // never enabled today
    BOOL bEnableFileEdit = TRUE;
    BOOL bEnableCombo = FALSE;
    // special cases
    switch (iClass)
    {
    case classDoc:
        break;

    case classApp:
        bEnableFileEdit = FALSE;    // can't change it !
        break;

    case classView:
        bEnableCombo = TRUE;
        break;
    }

    GetDlgItem(IDC_HFILE)->EnableWindow(bEnableFileEdit);
	CString strLabel;
	strLabel.LoadString(bEnableFileEdit ? IDS_HEADERF_ACC : IDS_HEADERF_NOACC);
    GetDlgItem(IDC_STATIC_HEADER)->SetWindowText(strLabel);
    GetDlgItem(IDC_IFILE)->EnableWindow(bEnableFileEdit);
	strLabel.LoadString(bEnableFileEdit ? IDS_IMPLF_ACC : IDS_IMPLF_NOACC);
    GetDlgItem(IDC_STATIC_IMP)->SetWindowText(strLabel);
    GetDlgItem(IDC_BASE_CLASS)->EnableWindow(bEnableBaseEdit);
	strLabel.LoadString(bEnableCombo ? IDS_BASEC_ACC : IDS_BASEC_NOACC);
	GetDlgItem(IDC_BASE_STATIC)->SetWindowText(strLabel);

    GetDlgItem(IDC_BASE_CLASS_COMBO)->ShowWindow(bEnableCombo);
    GetDlgItem(IDC_BASE_CLASS_COMBO)->EnableWindow(bEnableCombo);
    GetDlgItem(IDC_BASE_CLASS)->ShowWindow(!bEnableCombo);

    // check for unique names (classes and files)
    if (pDX->m_bSaveAndValidate)
    {
        // check for reserved class names
        if (IsReservedClassName(projOptions.m_names.strClass[iClass]))
        {
            AfxMessageBox(IDP_RESERVED_CLASS, MB_OK, 0);
            pDX->PrepareEditCtrl(IDC_CLASS_NAME);
            pDX->Fail();
        }

        for (int iOther = 0; iOther < classMax; iOther++)
        {
            if (iOther == iClass)
                continue;
			if (!projOptions.m_names.bCategoryEnabled[iOther])
				continue;
            if (projOptions.m_names.strClass[iClass] == projOptions.m_names.strClass[iOther])
            {
                AfxMessageBox(IDP_DUPLICATE_CLASS, MB_OK, 0);
                pDX->PrepareEditCtrl(IDC_CLASS_NAME);
                pDX->Fail();
            }
            if (!projOptions.m_names.strHFile[iClass].CompareNoCase(projOptions.m_names.strHFile[iOther]))
            {
                AfxMessageBox(IDP_DUPLICATE_FILE, MB_OK, 0);
                pDX->PrepareEditCtrl(IDC_HFILE);
                pDX->Fail();
            }
            if (!projOptions.m_names.strIFile[iClass].CompareNoCase(projOptions.m_names.strIFile[iOther]))
            {
                AfxMessageBox(IDP_DUPLICATE_FILE, MB_OK, 0);
                pDX->PrepareEditCtrl(IDC_IFILE);
                pDX->Fail();
            }
        }
    }
}

void CNamesDlg::OnSelchangeBaseClass()
{
    CComboBox *viewCombo = (CComboBox*) GetDlgItem(IDC_BASE_CLASS_COMBO);
	
	// Set symbol for new base class so we can refill the classes
	//  listbox if necessary (e.g., if new base class is CRecordView,
	//  we must add CRecordset to listbox).
	viewCombo->GetLBText
    	(viewCombo->GetCurSel(), projOptions.m_names.strBaseClass[classView]);
	SetBaseViewSymbols();
	fillBaseClasses(projOptions.m_names.strBaseClass);
    m_classList.ResetContent();
    int nViewClass = 0;
    // fill with class list - non-sorted so we can use index for 'iClass'
    // Only enter those classes that are enabled
    ASSERT(!(m_classList.GetStyle() & LBS_SORT));
    fillCategoryEnabled(projOptions.m_names.bCategoryEnabled);
    for (int iClass = 0; iClass < classMax; iClass++)
    {
        if (projOptions.m_names.bCategoryEnabled[iClass])
        {
            int i = m_classList.AddString(projOptions.m_names.strClass[iClass]);
            TRACE2("Added class '%s'@%d\n",
                (const char*)projOptions.m_names.strClass[iClass], i);
            m_classList.SetItemData(i, iClass);
            if (iClass == classView) nViewClass = i;
        }
    }
    m_classList.SetCurSel(nViewClass);
}

BOOL CNamesDlg::CanDestroy()
{
	if (!UpdateData(TRUE))
		return FALSE;

	CString strViewBaseClass = projOptions.m_names.strBaseClass[classView];

	// CRichEditView requires a container
	if (strViewBaseClass == "CRichEditView"
		&& projOptions.m_nOleType != OLE_CONTAINER && projOptions.m_nOleType != OLE_CSERVER)
	{
		// User chose richedit w/out container support.  Do they want container support?
		if (AfxMessageBox(IDP_NOOLE_THEN_RICHEDIT, MB_OKCANCEL) == IDCANCEL)
			// ...no
			return FALSE;

		// ...yes.  Add container support for them.
		if (projOptions.m_nOleType == OLE_NO)
			projOptions.m_nOleType = OLE_CONTAINER;
		else
			projOptions.m_nOleType = OLE_CSERVER;
		SetOleSymbols();
	}

	if (projOptions.m_bSplitter)
	{
		if (!CanViewClassBeUsedWithSplitter(strViewBaseClass))
		{
			INT iResult = ::AfxMessageBox(IDP_CANT_USE_SPLITTER, MB_OKCANCEL);

			if (iResult == IDCANCEL)
				return FALSE;

			projOptions.m_bSplitter = FALSE;

			SetSplitterSymbols();
		}
	}

	return TRUE;
}

void CNamesDlg::WriteValues()
{
	UpdateData(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// CMainDlg dialog

static BOOL fKnownWizardDeterminedAlready;
static BOOL fIsKnownWizard;

CMainDlg::CMainDlg(CWnd* pParent /*=NULL*/)
    : C3dDialog(CMainDlg::IDD, pParent)
{
	m_nChildDlgLeft = -1;
    InitializeOptions();
	m_nMaxUserSteps = -1;
	m_nHasHelpButton = -1;		// any value is OK as long as it isn't valid...
	fKnownWizardDeterminedAlready = fIsKnownWizard = FALSE;
    InitDialogs();
    //{{AFX_DATA_INIT(CMainDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

void CMainDlg::DoDataExchange(CDataExchange* pDX)
{
    C3dDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMainDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMainDlg, C3dDialog)
    //{{AFX_MSG_MAP(CMainDlg)
    ON_BN_CLICKED(IDC_BACK, OnClickedBack)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_END, OnClickedEnd)
    //ON_BN_CLICKED(ID_HELP, OnHelp)
	ON_WM_PAINT()
    ON_WM_SYSCOMMAND()
	ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_ACTIVATE()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDlg message handlers

BOOL CMainDlg::PreTranslateMessage(MSG* pMsg)
{
/* #ifndef PRIVATE
	switch(pMsg->message)
	{
	case WM_KEYDOWN:
        if (pMsg->wParam == VK_TAB &&
            (SendMessage(WM_GETDLGCODE) &
             (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE | DLGC_WANTTAB)) == 0)
        {
            CWnd* pCtl = GetFocus();
            if (IsChild(pCtl))
            {
                do
                {
                    int nKeyState = GetKeyState(VK_SHIFT);
                    pCtl = pCtl->GetWindow(nKeyState < 0 ? GW_HWNDPREV : GW_HWNDNEXT);

                    if (pCtl == NULL)
                    {
                        CDialog* pDlg = GetInnerDlg();
                        pDlg->SetFocus();
                        pCtl = GetFocus();
                        pCtl = pCtl->GetWindow(nKeyState < 0 ? GW_HWNDLAST : GW_HWNDFIRST);
                        if ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP)
                            pCtl = pDlg->GetNextDlgTabItem(pCtl, nKeyState < 0);
                        MakeOKDefault(this);
						pCtl->SetFocus();
						
						// If pCtl is an edit control, select its contents.
						char szClassName[256];
						::GetClassName(pCtl->GetSafeHwnd(), szClassName, 256);
						if (!strcmp(szClassName, "Edit"))
						{
							((CEdit*) pCtl)->SetSel(DWORD(MAKELONG(0, -1)));
						}
                        return TRUE;
                    }

                }
                while ((pCtl->GetStyle() & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
            }
        }
		break;

	case WM_SYSCHAR:
	case WM_CHAR:
		if (IsaMainBtn((char) pMsg->wParam))
#ifdef VS_PACKAGE
			return CDialog::PreTranslateMessage(pMsg);
#else
			return C3dDialog::PreTranslateMessage(pMsg);
#endif	// VS_PACKAGE
		// If the user tries a kbd equivalent of a control in CSeqDlg, pass
		//  message to CSeqDlg.  (Since focus is in CMainDlg, focus must be
		//  on a button.  Thus, we pass WM_CHAR and WM_SYSCHAR messages.)
		HWND origHwnd = pMsg->hwnd;
		CDialog* pDlg = GetInnerDlg();
		pMsg->hwnd = pDlg->GetWindow(GW_CHILD)->GetSafeHwnd();
		if (pDlg->IsDialogMessage(pMsg))
		{
			return TRUE;
		}
		else
		{
			pMsg->hwnd = origHwnd;
#ifdef VS_PACKAGE
			return CDialog::PreTranslateMessage(pMsg);
#else
			return C3dDialog::PreTranslateMessage(pMsg);
#endif	// VS_PACKAGE
		}
	}
#endif //!PRIVATE
*/
	if (pMsg->message == WM_HELP && !IsWindowEnabled())
	{
		OnHelp();
		return TRUE;
	}
	return C3dDialog::PreTranslateMessage(pMsg);
}

void CMainDlg::InitializeUserVars()
{
	m_pCurrUserStepDlg = NULL;
	m_pCurrUserSeqDlg = NULL;
	m_nCurrUserStep = 0;
}

BOOL CMainDlg::OnInitDialog()
{
    C3dDialog::OnInitDialog();
    CenterWindow();
	m_strLastSubdir = "";
	
    m_nCurrIndex = -1;
	m_nRightmostBtn = IDC_END;
	m_pConfirmDlg = NULL;

	InitializeUserVars();

	::SetWindowLong(m_hWnd, GWL_USERDATA, (LONG) szMainDlgUserData);

    return TRUE;
}

void CMainDlg::FakeShellExecute(HWND hWnd, LPCSTR szVerb, LPCSTR szFile)
{
    // open the project file
    //  (don't use ShellExecute since VB may steal the .MAK suffix)
    //  (don't pass in an HWND since that may wedge the IDE)
    char szFullPath[_MAX_PATH];

    // Add info to the projects created by $$NEWPROJ directive as well
    pTermStatus = &g_TermStatus;
    ASSERT (*(pTermStatus->szFullName) == '\0');
    strcpy(pTermStatus->szFullName, szFile);
    while (pTermStatus) {
        if (!_fullpath(szFullPath, pTermStatus->szFullName, _MAX_PATH))
        {
            TRACE("FakeShellExecute failed - _AfxFullPath failed\n");
            return;
        }		
        strncpy(pTermStatus->szFullName, szFullPath, MAX_PATH);
        pTermStatus->nTermType = APPWIZTERMTYPE_APPWIZPROJ;
        pTermStatus = pTermStatus->nextAppWizTermStatus;
    }
    pTermStatus = &g_TermStatus;

    TRACE("FakeShellExecute worked!\n");
}

/////////////////////////////////////////////////////////////////////////////
// CTheDLL

CTheDLL theDLL;

CTheDLL::CTheDLL()
{
	m_bFirstTime = TRUE;
	m_pMainDlg = NULL;
}

BOOL CTheDLL::InitInstance()
{
    /* DWORD dwDisp;
    VERIFY(RegCreateKeyEx(HKEY_CURRENT_USER, (const char*) szMSVCSection,
        0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &m_hKey, &dwDisp)
        == ERROR_SUCCESS);*/

    return TRUE;
}



// This should be called immediately after LoadLibrarying AppWizard in the build system's
//  handler for File.New.Project.
void CTheDLL::InitAppWiz(HWND hWnd)
{
	OleInitialize(NULL);
	// Set pLaunchParent to window handle passed to us
	pLaunchParent = CWnd::FromHandlePermanent(hWnd);
	ASSERT(pLaunchParent != NULL);

	pTermStatus = &g_TermStatus;
	pTermStatus->strlDepFiles.RemoveAll();
	pTermStatus->strlNonPrjFiles.RemoveAll();
	pTermStatus->strlNonBldFiles.RemoveAll();
	pTermStatus->strlResFiles.RemoveAll();
	pTermStatus->strlHelpFiles.RemoveAll();
	pTermStatus->strlTemplFiles.RemoveAll();
	if (m_bFirstTime)
	{
		InitInstance();
		m_bFirstTime = FALSE;
	}
	// Initialize variables
	pTermStatus->nTermType = APPWIZTERMTYPE_CANCEL;
	pTermStatus->strDefFile.Empty();
	//pTermStatus->strClwFile.Empty();
	m_bQuit = FALSE;
	strlProjTypes.RemoveAll();
	projOptions.m_strProj = "";
	InitPlatformsSelected();
	g_PlatNameConvert.Init();
	extern BOOL g_bLoadFromAppwiz;			// See top of codegen.cpp
	g_bLoadFromAppwiz = FALSE;

	// Erase any leftover names from previous invocation
	for (int i=0; i < classMax; i++)
	{
		projOptions.m_names.strClass[i].Empty();
		projOptions.m_names.strBaseClass[i].Empty();
		projOptions.m_names.strHFile[i].Empty();
		projOptions.m_names.strIFile[i].Empty();
	}
	projOptions.m_names.strDocFileExt.Empty();
	//projOptions.m_names.strDocFilter.Empty();

	// Get appWizard's module's directory (eg. \bin\)
	DWORD nSize = GetModuleFileName(NULL, m_strAppwizDir.GetBuffer(MAX_PATH), MAX_PATH);
	m_strAppwizDir.ReleaseBuffer();
	if (nSize == 0 || nSize > MAX_PATH)
		m_strAppwizDir = "";
	else
		m_strAppwizDir = m_strAppwizDir.Left(m_strAppwizDir.ReverseFind('\\'));

	strlProjTypes.RemoveAll();

#ifdef VS_PACKAGE
	IBuildWizard *pBldWizIFace = &g_CBldWiz;
#else
	LPBUILDWIZARD pBldWizIFace;
	theApp.FindInterface(IID_IBuildWizard, (LPVOID FAR *)&pBldWizIFace);
#endif	
	
	const CStringList* pList;

	pBldWizIFace->GetTargetTypeNames(&pList, NULL, TRUE);
	pBldWizIFace->Release();
	POSITION pos = pList->GetHeadPosition();
    while (pos != NULL)
		strlProjTypes.AddTail(pList->GetNext(pos));

	g_strlPlatformsDisplayed.RemoveAll();

	// If this ASSERT fires, there's probably a memory leak due to successive calls
	//  to InitAppWiz without an intervening call to ExitAppWiz.
	ASSERT(m_pMainDlg == NULL);

	m_pMainDlg = new CMainDlg(pLaunchParent);
}

#ifndef VS_PACKAGE
int CTheDLL::RunAppWiz(HWND hWnd, HBUILDER* phBld)
{
	ASSERT(FALSE);
	return 0;
}
#endif	// VS_PACKAGE

BOOL DoesFileExist(const char* szFile)
{
    struct _stat st;
    return (_stat(szFile, &st) == 0);
}

BOOL DestroyFile(const char* szFile)
{
	if (!DoesFileExist(szFile))
		return TRUE;
	CString strPrompt;
	AfxFormatString1(strPrompt, IDP_CANT_DELETE_FILE, szFile);
	while (::remove(szFile) == -1)
	{
		if (AfxMessageBox(strPrompt, MB_RETRYCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
			return FALSE;
	}
	return TRUE;
}

#ifndef VS_PACKAGE
// Registers AppWizard's main window with the main frame, so that
//  F1 help is diverted to AppWizard.
class CRegisterWithFrame
{
public:
	CRegisterWithFrame(CWnd* pwndAppWiz)
	{
//		m_pMainWnd = AfxGetMainWnd();

		ASSERT (pwndAppWiz->GetSafeHwnd() != NULL);
		theApp.SetAppWizHwnd(pwndAppWiz->GetSafeHwnd());
	}
	~CRegisterWithFrame()
	{
		theApp.SetAppWizHwnd(NULL);
	}
protected:
//	CWnd* m_pMainWnd;
};
#endif	// VS_PACKAGE

int CTheDLL::RunAppWizSteps()
{
	// If these ASSERTs	fire, you didn't call InitAppWiz before calling this!
	ASSERT(pLaunchParent != NULL);
	ASSERT(m_pMainDlg != NULL);

	pLaunchParent->EnableWindow(FALSE);
	if (!m_pMainDlg->GetSafeHwnd())
		m_pMainDlg->Create(pLaunchParent);
	m_bQuit = FALSE;

	{
#ifndef VS_PACKAGE
		// Register our existence with the main frame
		CRegisterWithFrame rwf(m_pMainDlg);
#endif	// VS_PACKAGE
		
		if (m_pMainDlg->StartAppWizSteps())
		{
			// The steps have started, so pump messages until it's
			//  time to say goodbye.
			while (!m_bQuit)
				AfxGetApp()->PumpMessage();
		}
		else
		{
			// We didn't even get a chance to start the steps, before
			//  it was determined that we have to rerun CPromptDlg
			pTermStatus->nTermType = APPWIZTERMTYPE_RERUNPROMPTDLG;
		}
	}

	pLaunchParent->EnableWindow(TRUE);
	ExitInstance();

	// If we're leaving for good, get rid of CMainDlg.  Otherwise, leave it invisible,
	//  and we'll delete it in ExitAppWiz.
	if (m_pMainDlg->GetSafeHwnd())
		m_pMainDlg->ShowWindow(SW_HIDE);

	return pTermStatus->nTermType;
}

void CTheDLL::ExitAppWiz()
{
	projOptions.m_UserExtension.Detach();
	if (m_pMainDlg != NULL)
	{
		if (m_pMainDlg->GetSafeHwnd())
			m_pMainDlg->DestroyWindow();
		delete m_pMainDlg;
		m_pMainDlg = NULL;
	}
	OleUninitialize();
}

void CMainDlg::InitializeOptions()
{
	SetCurrentTrack();

	langDlls.Init();

	projOptions.m_bMayBeAppWizTrack = FALSE;

	projOptions.m_names.m_bUpdateNames = TRUE;
	SetLanguageSymbols();

    // Database options
    projOptions.m_bDBHeader = projOptions.m_bDBSimple
	     = projOptions.m_bAutoDetect = FALSE;
    projOptions.m_nDataSource = dbOdbc;

	SetDBSymbols();

    // OLE options
    projOptions.m_nOleType = OLE_NO;
    projOptions.m_bOleAutomation = FALSE;
	projOptions.m_bOleCompFile = FALSE;
	projOptions.m_bOcx = TRUE;	// Default to true per DevStudio '96 Bug 5100
	projOptions.m_bActiveDocServer = FALSE;
	projOptions.m_bActiveDocContainer = FALSE;
	SetOleSymbols();

	// Application options
    projOptions.m_options = (1<<(IDCD_POTOOLBAR-IDCD_POBASE))
		| (1<<(IDCD_POSTATUSBAR	-	IDCD_POBASE))
        | (1<<(IDCD_POPRINT		-	IDCD_POBASE))
		| (1<<(IDCD_PO3D		-	IDCD_POBASE))
        | (1<<(IDCD_POABOUT		-	IDCD_POBASE));

    if( projOptions.m_bNoDocView )
		 projOptions.m_options &= ~(1<<(IDCD_POPRINT - IDCD_POBASE));

	SetAppOptionsSymbols();

	projOptions.m_nSizeMRU = 4;
	SetSizeMRUSymbols(projOptions.m_nSizeMRU);

	// CDocStringsDlg tracking variables
/*	projOptions.m_bUpdateFilter
		= projOptions.m_bUpdateFileNew
		= projOptions.m_bUpdateRegID
		= projOptions.m_bUpdateRegName = TRUE;*/

	projOptions.m_nFrameStyles = GetDefaultFrameStyles();
	SetFrameSymbols();
	projOptions.m_nMenuStyle = 0;
	SetMenuSymbols();

	projOptions.m_bSplitter = FALSE;
	SetSplitterSymbols();

	projOptions.m_nChildFrameStyles = GetDefaultChildFrameStyles();
	SetChildFrameSymbols();

	// Project options
	projOptions.m_projOptions = (1<<(IDCD_POVERBOSE-IDCD_POPROJBASE))
		| (1<<(IDCD_PODLL		-	IDCD_POPROJBASE));
	projOptions.m_bExtdll = FALSE;
	projOptions.m_bATLSupport = FALSE;
	projOptions.m_nProjStyle = PS_MFCNORMAL;
	SetDllSymbol();
	SetProjOptionsSymbols();
}

void CMainDlg::GetAllSymbols()
{
	GetProjectTypeSymbol();
	GetFrameSymbols();
	GetChildFrameSymbols();
	GetSizeMRUSymbols();

	GetSplitterSymbols();
	GetLanguageSymbols();

	GetAppOptionsSymbols();

	GetProjOptionsSymbols();

	GetOleSymbols();

	GetClassesSymbols();
	GetDBSymbols();

	GetDocumentSymbols();
	
	// MAC-specific
	if (DoesSymbolExist("TARGET_MAC"))
	{
		GetSymbol("FILE_TYPE", projOptions.m_names.strDocFileType);
		GetSymbol("CREATOR", projOptions.m_names.strDocFileCreator);
		GetSymbol("MAC_FILTER", projOptions.m_names.strMacFilter);
	}
}


static int nAppTrack[] = {0, 1, 2, 3, 4, 5, 6, 9};
#define APP_LAST_INDEX 7

static int nDlgTrack[] = {0, 1, 7, 5, 6, 9};
#define DLG_LAST_INDEX 5

static int nDLLTrack[] = {0, 8, 9};
#define DLL_LAST_INDEX 2

#define DBDLG 2

// Pages through the various dialogs.
void CMainDlg::InitDialogs()
{
    CSeqDlg* dlg1 = (CSeqDlg*) new CProjDlg(this);
    CSeqDlg* dlg2 = (CSeqDlg*) new CDBDlg(this);
    CSeqDlg* dlg3 = (CSeqDlg*) new COleDlg(this);
    CSeqDlg* dlg4 = (CSeqDlg*) new CDocAppOptionsDlg(this);
    CSeqDlg* dlg5 = (CSeqDlg*) new CProjOptionsDlg(this);
    CSeqDlg* dlg6 = (CSeqDlg*) new CNamesDlg(this);
    CSeqDlg* dlg7 = (CSeqDlg*) new CDlgAppOptionsDlg(this);
	CSeqDlg* dlg8 = (CSeqDlg*) new CDllProjOptionsDlg(this);

    m_pDialogClasses[0] = NULL;            // Placeholder for where CPromptDlg goes
    m_pDialogClasses[1] = dlg1;
    m_pDialogClasses[2] = dlg2;
    m_pDialogClasses[3] = dlg3;
    m_pDialogClasses[4] = dlg4;
    m_pDialogClasses[5] = dlg5;
    m_pDialogClasses[6] = dlg6;
    m_pDialogClasses[7] = dlg7;
	m_pDialogClasses[8] = dlg8;
	m_pDialogClasses[9] = NULL;

	// This is defined in pagedlg.cpp.  When we set this, we have
	//  permission to call CAppWizStepDlg's constructor with 0.
	void AppWizCallingStructor(BOOL bAppWizCallingStructor);
	AppWizCallingStructor(TRUE);

	for (int i=0; i < NUM_DLG_CLASSES; i++)
	{
		m_pExtensionKeys[i] = new CAppWizStepDlg(0);
		m_DlgMap[m_pExtensionKeys[i]] = m_pDialogClasses[i];
	}

	AppWizCallingStructor(FALSE);
}

CAppWizStepDlg* CMainDlg::ExtKeyFromID(AppWizDlgID nID)
{
	if (1 > nID || nID > NUM_DLG_CLASSES-2)
	{
		CString strNum;
		strNum.Format("%d", nID);
		ReportErrorExt(IDS_GETDLG_BAD_RANGE, strNum);
	}
	return m_pExtensionKeys[nID];
}

CSeqDlg* CMainDlg::ExtSeqDlgFromKey(CAppWizStepDlg* pStepDlg)
{
	CSeqDlg* pSeqDlg;
	VERIFY (m_DlgMap.Lookup(pStepDlg, pSeqDlg));
	ASSERT_VALID(pSeqDlg);
	return pSeqDlg;
}

struct AltHelpIDEntry
{
	int nDlg;
	int nFirstHelpID;
};

// This structure and GetAltHelpID exist so that unambiguous help IDs
//  are sent.  Some dialogs appear on more than one track (e.g.,
//  Classes dialog)-- and thus the dialog will have a different
//  "step#" depending on where it appears in each track.  In order for
//  the documentation to correctly present the dialog's title (which
//  includes the step number), we pass distinct help IDs for the same
//  dialog on different tracks.
// AltHelpIDs's entries work like this:  The first field is the index
//  into m_pDialogClasses of the dialog.  (Not the index into a
//  track.)  The last field is an alternate ID for the dialog, which
//  is defined to be distinct from all other alternate IDs, all other
//  dialog IDs, and all other offsets from other alternate IDs.  The
//  latter is necessary, since, for example, the project options
//  dialog appears on three tracks: thus we use the original
//  dialog ID for its occurrence on nAppTrack, IDD_PROJOPTIONS_ALT for
//  its occurrence on nDlgTrack, and an offset IDD_PROJOPTIONS_ALT+1
//  for its occurrence on nDLLTrack.  The last entry in AltHelpIDs
//  is marked by a "-1" in the first field.
// The _ALT symbols are defined in resource.h.
// NOTE: All this help ID hokey-dokeying occurs before
//  CTheDLL::WinHelp adds the final offset to avoid collisions with
//  the rest of msvc.

static AltHelpIDEntry AltHelpIDs[] =
{
    { 5, IDD_PROJOPTIONS_ALT },
    { 6, IDD_NAMES_ALT },
    { -1, -1 },
};

// This takes an index into m_pDialogClasses and a track.  If it finds
//  the dialog in AltHelpIDs, it returns a suitable alternate ID to be
//  passed as the LPARAM to the Help Command.  Otherwise, it returns
//  0, which is the default LPARAM to the Help Command.
LPARAM GetAltHelpID(int nDlg, int* pnTrack)
{
	int i=0;
	int iDlg;
	while ((iDlg = AltHelpIDs[i].nDlg) != -1)
	{
		if (nDlg == iDlg)
		{
			// If we're on the regular app track, keep the ID the same
			if (pnTrack == (int*) nAppTrack)
				return (LPARAM) 0;

			// Generate helpID based on info in AltHelpIDs.  Add
			//  HID_BASE_RESOURCE, since CDialog::OnCommandHelp won't
			//  do this unless we send it 0 as the LPARAM.
			LPARAM nRetval = HID_BASE_RESOURCE + AltHelpIDs[i].nFirstHelpID;
			if (pnTrack == (int*) nDlgTrack)
				return nRetval;
			else
				return nRetval+1;
		}
		i++;
	}
	return (LPARAM) 0;
}

int CMainDlg::GetSeqDlgIndex(CSeqDlg* pSeqDlg)
{
	ASSERT (pSeqDlg != NULL);
	for (int i=0; i < NUM_DLG_CLASSES; i++)
	{
		if (pSeqDlg == m_pDialogClasses[i])
			return i;
	}
	ASSERT(FALSE);
	return 1;
}

#ifdef _DEBUG
#define szSuffix "D"
#else
#define szSuffix ""
#endif

// Table of the names of custom app-wizards whose control-help is included in the DevStudio
// help file.  For other app-wizards, we use the wizard's own .HLP file.
static LPCTSTR rgszKnownAppWizNames[] =
{
	"VJAPPWIZ" szSuffix,
	"INETAWZ" szSuffix,
	"MFCTLWZ" szSuffix,
	"ATLWIZ" szSuffix,
	"ADDINWZ" szSuffix,
	"FORMBAS" szSuffix,
	"CONWZ" szSuffix,
	"DLLWZ" szSuffix,
	"EXEWZ" szSuffix,
	"GENWZ" szSuffix,
	"LIBWZ" szSuffix,
	"MAKWZ" szSuffix,
	"XPWIZ" szSuffix,
	NULL
};

static BOOL IsKnownWizard()
{
	if (fKnownWizardDeterminedAlready)
		return fIsKnownWizard;

	fKnownWizardDeterminedAlready = TRUE;	// we're just about to determine it
	fIsKnownWizard = FALSE;

    if (IsUserAWX())
    {
		CString strAwxName = projOptions.m_UserExtension.GetAWXName();
		_TCHAR szFname[_MAX_FNAME];
		_tsplitpath(strAwxName, NULL, NULL, szFname, NULL);

		for (LPCTSTR *psz = rgszKnownAppWizNames; *psz != NULL && !fIsKnownWizard; psz++)
		{
			if (_tcsicmp(szFname, *psz) == 0)
			{
				fIsKnownWizard = TRUE;
			}
		}
    }

	return fIsKnownWizard;
}

static BOOL IsDefinitelyKnownWizard()	// slightly broader definition than IsKnownWizard
{
	return (!IsUserAWX() || projOptions.m_UserExtension.m_bCtlWiz || IsKnownWizard());
}

#ifdef _DEBUG
#define VJAPPWIZ "VJAPPWIZD.AWX"
#else
#define VJAPPWIZ "VJAPPWIZ.AWX"
#endif

// Black and white determination of help file name.
// Returns wrong result for standard AppWiz step called
// from within a custom AppWizard.  (Gray area case)
void GetHelpFile(CString& strHelpFile)
{
	if (IsDefinitelyKnownWizard())	// Known Wiz
	{
		strHelpFile = AfxGetApp()->m_pszHelpFilePath;
		if (!_access(strHelpFile, 04) == 0)		// not where it is expected.  Try again in help dir
		{
			_TCHAR szFile[_MAX_EXT];
			_splitpath(strHelpFile, NULL, NULL, szFile, NULL);
			CString strHelpDir;
			ASSERT(FALSE);
			//Fix this
			//::GetHelpDir(strHelpDir);
			strHelpFile.Format("%s\\%s.hlp", (LPCTSTR)strHelpDir, szFile);
		}
	}
	else
	{
		// custom appwiz showing custom step
		// Get extension's help file path
		//CString strHelpFile = projOptions.m_UserExtension.GetAWXName();
	    strHelpFile = projOptions.m_UserExtension.GetAWXName();
		int nLength = strHelpFile.GetLength();
		if (nLength < 3)
		{
			ASSERT(FALSE);
			return;
		}
		strHelpFile = strHelpFile.Left(nLength-3) + "hlp";
	}
}

void CMainDlg::OnHelp()
{
	// custom appwiz showing custom step
	// Get extension's help file path
    CString strHelpFile;
    BOOL    fUserAWX = IsUserAWX();
	BOOL	fKnownWizard = IsKnownWizard();

	if (fUserAWX)
	{
		strHelpFile = projOptions.m_UserExtension.GetAWXName();
		_TCHAR szFname[_MAX_FNAME];
		_tsplitpath(strHelpFile, NULL, NULL, szFname, NULL);
	}

	if (IsDefinitelyKnownWizard())
	{
		// No custom AppWizard
		if (!IsWindowEnabled())
		{
			// appwiz isn't on top.  Some other modal dialog is instead (like
			//  pick data source or confirmation dialog).  Let that dialog
			//  supply its own help ID.
			C3dDialog::OnHelp();
			return;
		}

	    if (!(0 < m_nCurrIndex && m_nCurrIndex < m_nCurrLastIndex))
	    {
			ASSERT(fKnownWizard || projOptions.m_UserExtension.m_bCtlWiz);	// all of IsDefinitelyKnownWizard except !IsUserAWX
			CDialog* pDlg = GetInnerDlg();
			// pDlg->SendMessage(WM_COMMANDHELP, 0, 0);
	        return;
	    }

		HWND hWnd = GetInnerDlg()->GetSafeHwnd();
	    ASSERT(hWnd != NULL);
		::SendMessage(hWnd, WM_COMMANDHELP, 0,
			GetAltHelpID(m_nCurrTrack[m_nCurrIndex], m_nCurrTrack));
	}
	else if (m_pCurrUserSeqDlg != NULL)
	{
		// custom appwiz showing standard appwiz step
		if (!IsWindowEnabled())
		{
			// appwiz isn't on top.  Some other modal dialog is instead (like
			//  pick data source or confirmation dialog).  Let that dialog
			//  supply its own help ID.
			C3dDialog::OnHelp();
			return;
		}
		int nDlg = GetSeqDlgIndex(m_pCurrUserSeqDlg);
		HWND hWnd = GetInnerDlg()->GetSafeHwnd();
	    ASSERT(hWnd != NULL);
		::SendMessage(hWnd, WM_COMMANDHELP, 0,
			GetAltHelpID(nDlg, m_nCurrTrack));
	}
	else
	{
		// custom appwiz showing custom step
		// Get context
		DWORD dwContext;
		CWnd* pAppMainWnd = AfxGetApp()->GetMainWnd();
		CWnd* pPopup = pAppMainWnd->GetLastActivePopup();
		if (pPopup == pAppMainWnd || pPopup == this)
		{
			// There's nothing on top of the custom appwiz step dialog
			dwContext = ((CAppWizStepDlg*) GetInnerDlg())->m_nIDTemplate + HID_BASE_RESOURCE;
		}
		else
		{
			// There's a modal dialog or something on top of the custom appwiz
			//  step dialog.  Use that modal guy's help context
			dwContext = pPopup->SendMessage(WM_HELPHITTEST, 0, 0);
		}

		// Directly call WinHelp
		::GetHelpFile(strHelpFile);
		::WinHelp(AfxGetApp()->GetMainWnd()->GetSafeHwnd(),
			strHelpFile, HELP_CONTEXT, dwContext);
	}
}

// This gets called when the user clicks "Next", or clicks "Finish" from
//  the last step (since, in that case, Finish == IDOK).
void CMainDlg::OnOK()
{
	if (IsUserAWX())
	{
		// Handle IDOK when a user dialog is present
		if (m_nCurrUserStep == m_nMaxUserSteps
			&& m_nMaxUserSteps != -1)
		{
			// Here we're the last step, so Finish == IDOK.
			OnClickedEnd();
			return;
		}
	    // This isn't the last dialog, so bring on the next one.
		ActivateUserDlg(TRUE);
	}
	else
	{
		// Handle IDOK when one of ours is present
		ASSERT(m_nCurrIndex != m_nCurrLastIndex);
		if (m_nCurrIndex == m_nCurrLastIndex - 1)
		{
			// Here we're the last step, so Finish == IDOK.
			OnClickedEnd();
			return;
		}
	    // This isn't the last dialog, so bring on the next one.
	    ActivateDlg(m_nCurrIndex + 1);
	}
}

void CMainDlg::OnClickedBack()
{
	if (IsUserAWX())
	{
		ActivateUserDlg(FALSE);
	}
	else
	    ActivateDlg(m_nCurrIndex - 1);
}

void CMainDlg::OnClickedEnd()
{
	CDialog* pDlg = GetInnerDlg();
	ASSERT(pDlg != NULL);

	if (!IsUserDlg())
	{
		// Hitting finish from one of our own dialogs
		if (!(((CSeqDlg*) pDlg)->CanDestroy()))
			return;
		((CSeqDlg*) pDlg)->WriteValues();
	}
	else
	{
		// It's a user's extension dialog
		if (!(((CAppWizStepDlg*) pDlg)->OnDismiss()))
			return;
	}
	ActivateConfirmDlg();
}

void CMainDlg::OnCancel()
{
    // Destroy current dialog before destroying main dialog
    CDialog* pCurrDlg = GetInnerDlg();
    ASSERT(pCurrDlg);
    VERIFY(pCurrDlg->DestroyWindow());
    CancelAppWiz();
    VERIFY(DestroyWindow());
}


// Hack: The last step has Next disabled, so Finish should be the
//  default. this becomes a problem when the user tabs around, since
//  the tabbing code is hard-coded in this file so the inner-dialog's
//  controls get put into the tab order.  In order that the proper
//  button stays the default even when the user tabs into the inner
//  dialog, I'm only letting IDOK be the default button.  Thus, for
//  Finish to "look" like it's the default, I interchange IDOK and
//  IDC_END, plus their captions.  Thus, the "Finish button" is really
//  IDOK on the classes dialog.
void CMainDlg::InterchangeEndAndOK()
{
	CString strOK, strEnd;
	CRect rectOK, rectEnd;
	CButton* pOK = (CButton*) GetDlgItem(IDOK);
	CButton* pEnd = (CButton*) GetDlgItem(IDC_END);
	pOK->GetWindowRect(&rectOK);
	pEnd->GetWindowRect(&rectEnd);
	ScreenToClient(&rectOK);
	ScreenToClient(&rectEnd);
	pOK->GetWindowText(strOK);
	pEnd->GetWindowText(strEnd);
	
	pOK->MoveWindow(&rectEnd);
	pEnd->MoveWindow(&rectOK);
	pOK->SetWindowText(strEnd);
	pEnd->SetWindowText(strOK);

	m_nRightmostBtn = (m_nRightmostBtn == IDOK) ? IDC_END : IDOK;
}

// This decides whether to call InterchangeEndAndOK, and how to
//  enable/disable the buttons.
void CMainDlg::AdjustEndAndOK(BOOL bIsLastDlg)
{
    if (bIsLastDlg)
    {
		// We're at the last dialog, so make "Finish" the default, and
		//  disable "Next".
		if (m_nRightmostBtn != IDOK)
			InterchangeEndAndOK();
		GetDlgItem(IDC_END)->EnableWindow(FALSE);
    }
    else
    {
        // We're not at the last dialog, so make sure "Next" is
		//  enabled and is the default
		if (m_nRightmostBtn != IDC_END)
			InterchangeEndAndOK();
		// only enable "Finish" if the in-progress app is not an ActiveX doc server or it has a file extension
        GetDlgItem(IDC_END)->EnableWindow(!(projOptions.m_bActiveDocServer && projOptions.m_names.strDocFileExt.IsEmpty()));
    }
}


void CMainDlg::SetCurrentTrack()
{
	switch(projOptions.m_nProjType)
	{
	case PROJTYPE_DLG:
		m_nCurrTrack = (int*) nDlgTrack;
		m_nCurrLastIndex = DLG_LAST_INDEX;
		break;
	case PROJTYPE_MDI:
	case PROJTYPE_SDI:
		m_nCurrTrack = (int*) nAppTrack;
		m_nCurrLastIndex = APP_LAST_INDEX;
		break;
	case PROJTYPE_DLL:
		m_nCurrTrack = (int*) nDLLTrack;
		m_nCurrLastIndex = DLL_LAST_INDEX;
		break;
	}
}

// Size of standard bitmap
#define BMP_LEFT 16
#define BMP_TOP 16
#define BMP_WIDTH 195
#define BMP_HEIGHT 147

// Size of flag bitmap
#define BMP_LEFT1 0
#define BMP_TOP1 0
#define BMP_WIDTH1 163
#define BMP_HEIGHT1 225

// Size of 3D checkbox bitmap
#define BMP2_LEFT (RIGHT_YELLOW-155)
#define BMP2_TOP (2*BMP_TOP + BMP_HEIGHT + 1)
#define BMP2_WIDTH 181
#define BMP2_HEIGHT 71

// Other values used for drawing around the bitmap
#define RIGHT_YELLOW (163+BMP_LEFT)
#define BOTTOM_YELLOW_DLGU 197
#define RIGHT_GRAY_DLGU 125


void GetBitmapRect(int nSize, RECT* rect)
{
	switch(nSize)
	{
	case BMPSIZE_STANDARD:   // The usual, regular bitmaps on most of the steps
		rect->left = BMP_LEFT;
		rect->top = BMP_TOP;
		rect->right = rect->left + BMP_WIDTH;
		rect->bottom = rect->top + BMP_HEIGHT;
		break;
	case BMPSIZE_FLAG:  	 // Checkered flag bitmap on last step
		rect->left = BMP_LEFT1;
		rect->top = BMP_TOP1;
		rect->right = rect->left + BMP_WIDTH1;
		rect->bottom = rect->top + BMP_HEIGHT1;
		break;
	case BMPSIZE_3D:		// Small dialog-cut picture for 3D checkbox
		rect->left = BMP2_LEFT;
		rect->top = BMP2_TOP;
		rect->right = rect->left + BMP2_WIDTH;
		rect->bottom = rect->top + BMP2_HEIGHT;
		break;
	case BMPSIZE_SUM:		// Union of sizes used for invalidation
		rect->left = rect->top = 0;
		rect->right = BMP_WIDTH + BMP_LEFT;
		rect->bottom = BMP_HEIGHT1 + BMP_TOP;
		break;
	}
}

void CMainDlg::CalculateDimensions()
{
	if (m_nChildDlgLeft != -1)
		return;

	const int nPadding = 5;
	CRect rect;
	CSeqDlg* pDlg = m_pDialogClasses[2];    // Just pick any CSeqDlg to check its size
	pDlg->Create(pDlg->m_nTemplate, this);
	pDlg->GetClientRect(&rect);
	VERIFY(pDlg->DestroyWindow());
	int nWidthLeftRegion = max(BMP2_WIDTH+BMP2_LEFT, max(BMP_WIDTH1+BMP_LEFT1, BMP_WIDTH+BMP_LEFT));
	int nWidthChildDlg = rect.right;
	GetWindowRect(&rect);
	int nMinWidthMainDlg = rect.Width();
	int nWidthMainDlg = nWidthLeftRegion + nWidthChildDlg + nPadding;
	if (nWidthMainDlg < nMinWidthMainDlg)
		nWidthMainDlg = nMinWidthMainDlg;
	VERIFY(SetWindowPos(NULL, 0, 0, nWidthMainDlg, rect.Height(), SWP_NOZORDER | SWP_NOMOVE));
	m_nChildDlgLeft = nWidthLeftRegion + nPadding;
}

COLORREF GetDlgBackground()
{
	static BOOL bFirstTime = TRUE;
	static DWORD dwDlgBk;

	if (bFirstTime)
	{
		dwDlgBk = GetSysColor(COLOR_BTNFACE);
		bFirstTime = FALSE;
	}

	return dwDlgBk;
}

void CMainDlg::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (IsUserDlg())
		return;                // Don't draw pictures for extensions.

	CSeqDlg* pDlg = (CSeqDlg*) GetInnerDlg();
	if (pDlg == NULL)
	{
		ASSERT(IsUserAWX());
		return;
	}

	if (!pDlg->ShouldShowPicture())
		return;

	BOOL bTwoBitmaps = pDlg->ShowTwoBitmaps();
	
	DrawBitmap(&dc, pDlg, 1);
	if (bTwoBitmaps)
		DrawBitmap(&dc, pDlg, 2);
	
	CBitmap pattern;
	pattern.LoadBitmap(IDB_YELLOW_PATTERN);
	CBrush brush(&pattern);
	RECT rectBmp;
	GetBitmapRect(pDlg->GetBitmapSizeIndex(), &rectBmp);
	BOOL bBmpIsFlag = (pDlg->GetBitmapSizeIndex() == BMPSIZE_FLAG);
	CPen penBogus(PS_SOLID, 0, COLORREF(0));
	CPen* pOldPen = dc.SelectObject(&penBogus);  // Remember current pen.

	// Draw yellow ABOVE bitmap
	RECT rect = {0, 0, 0, 0};
	rect.bottom = rectBmp.top;
	rect.right = RIGHT_YELLOW+1;
	dc.DPtoLP(&rect);
	dc.FillRect(&rect, &brush);

	// Draw yellow to LEFT of bitmap
	rect.left = 0;
	rect.top = rectBmp.top;
	rect.right = rectBmp.left;
	rect.bottom = rectBmp.bottom+1;
	dc.DPtoLP(&rect);
	dc.FillRect(&rect, &brush);

	// Draw yellow to RIGHT of bitmap
	//  (Only necessary for bitmaps not crossing right line.)
	rect.left = rectBmp.right;
	rect.top = rectBmp.top;
	rect.right = RIGHT_YELLOW+1;
	rect.bottom = rectBmp.bottom+1;
	if (rect.left < rect.right)
	{
		dc.DPtoLP(&rect);
		dc.FillRect(&rect, &brush);

		// Fill in gray to right of yellow.
		GetClientRect(&rect);
		rect.left = RIGHT_YELLOW+3;
		rect.top = rectBmp.top;
		rect.bottom = rectBmp.bottom+1;
		dc.DPtoLP(&rect);
		CBrush brushGray(GetDlgBackground());
		dc.FillRect(&rect, &brushGray);
	}

	// If we're showing a second bitmap, take care of its background
	if (bTwoBitmaps)
	{
		DrawLowerBackground(&dc, &brush, pOldPen);
		return;
	}

	// Draw yellow BELOW bitmap
	rect.left = 0;
	rect.top = 0;
	rect.right = 1;
	rect.bottom = BOTTOM_YELLOW_DLGU;
	MapDialogRect(&rect);
	rect.right = RIGHT_YELLOW+1;
	rect.top = rectBmp.bottom;
	dc.DPtoLP(&rect);
	dc.FillRect(&rect, &brush);

	// Draw right border lines
	CPen penGray(PS_SOLID, 0, 0x00808080);
	dc.SelectObject(&penGray);
	dc.MoveTo(rect.right, 0);
	POINT point;
	point.x = rect.right;
	point.y = rectBmp.top;
	dc.DPtoLP(&point);
	if (!bBmpIsFlag)
		dc.LineTo(point.x, point.y);
	point.x = rect.right;
	point.y = rectBmp.bottom;
	dc.DPtoLP(&point);
	if (!bBmpIsFlag)
		dc.MoveTo(point.x, point.y);
	dc.LineTo(point.x, rect.bottom);

	CPen penWhite(PS_SOLID, 0, 0x00ffffff);
	dc.SelectObject(&penWhite);
	dc.MoveTo(rect.right+1, 0);
	point.x = rect.right+1;
	point.y = rectBmp.top;
	dc.DPtoLP(&point);
	if (!bBmpIsFlag)
		dc.LineTo(point.x, point.y);
	point.x = rect.right+1;
	point.y = rectBmp.bottom;
	dc.DPtoLP(&point);
	if (!bBmpIsFlag)
		dc.MoveTo(point.x, point.y);
	dc.LineTo(point.x, rect.bottom);

	// Fill gray rectangle to right of nonexistent
	//  second bitmap
	GetBitmapRect(BMPSIZE_3D, &rectBmp);
	CBrush brushGray(GetDlgBackground());
	rect.left = RIGHT_YELLOW+3;
	rect.top = rectBmp.top;
	rect.right = rectBmp.right;
	rect.bottom = rectBmp.bottom;
	dc.DPtoLP(&rect);
	dc.FillRect(&rect, &brushGray);

	// Restore original pen
	dc.SelectObject(pOldPen);
}

void CMainDlg::DrawLowerBackground(CDC* pdc, CBrush* pBrush, CPen* pOldPen)
{
	RECT rectBmp, rectBmp2;
	GetBitmapRect(BMPSIZE_STANDARD, &rectBmp);
	GetBitmapRect(BMPSIZE_3D, &rectBmp2);
	
	// Draw yellow ABOVE bitmap
	RECT rect = {0, 0, 0, 0};
	rect.top = rectBmp.bottom;
	rect.bottom = rectBmp2.top;
	rect.right = RIGHT_YELLOW+1;
	pdc->DPtoLP(&rect);
	pdc->FillRect(&rect, pBrush);

	// Draw yellow to LEFT of bitmap
	rect.left = 0;
	rect.top = rectBmp2.top;
	rect.right = rectBmp2.left;
	rect.bottom = rectBmp2.bottom+1;
	pdc->DPtoLP(&rect);
	pdc->FillRect(&rect, pBrush);

	// Draw yellow BELOW bitmap
	rect.left = 0;
	rect.top = 0;
	rect.right = 1;
	rect.bottom = BOTTOM_YELLOW_DLGU;
	MapDialogRect(&rect);
	rect.right = RIGHT_YELLOW+1;
	rect.top = rectBmp2.bottom;
	pdc->DPtoLP(&rect);
	pdc->FillRect(&rect, pBrush);

	// Draw right border lines
	CPen penGray(PS_SOLID, 0, 0x00808080);
	pdc->SelectObject(&penGray);
	pdc->MoveTo(rect.right, 0);
	POINT point;
	point.x = rect.right;
	point.y = rectBmp.top;
	pdc->DPtoLP(&point);
	pdc->LineTo(point.x, point.y);
	point.x = rect.right;
	point.y = rectBmp.bottom;
	pdc->DPtoLP(&point);
	pdc->MoveTo(point.x, point.y);
	point.x = rect.right;
	point.y = rectBmp2.top;
	pdc->DPtoLP(&point);
	pdc->LineTo(point.x, point.y);
	point.x = rect.right;
	point.y = rectBmp2.bottom;
	pdc->DPtoLP(&point);
	pdc->MoveTo(point.x, point.y);
	pdc->LineTo(point.x, rect.bottom);

	CPen penWhite(PS_SOLID, 0, 0x00ffffff);
	pdc->SelectObject(&penWhite);
	pdc->MoveTo(rect.right+1, 0);
	point.x = rect.right+1;
	point.y = rectBmp.top;
	pdc->DPtoLP(&point);
	pdc->LineTo(point.x, point.y);
	point.x = rect.right+1;
	point.y = rectBmp.bottom;
	pdc->DPtoLP(&point);
	pdc->MoveTo(point.x, point.y);
	point.x = rect.right+1;
	point.y = rectBmp2.top;
	pdc->DPtoLP(&point);
	pdc->LineTo(point.x, point.y);
	point.x = rect.right+1;
	point.y = rectBmp2.bottom;
	pdc->DPtoLP(&point);
	pdc->MoveTo(point.x, point.y);
	pdc->LineTo(point.x, rect.bottom);

	// Restore original pen
	pdc->SelectObject(pOldPen);
}


void CMainDlg::DrawBitmap(CDC* pdc, CSeqDlg* pDlg, int nBmp)
{
	UINT nBmpID;
	if (nBmp == 1)
		nBmpID = pDlg->ChooseBitmap();
	else
		nBmpID = pDlg->ChooseBitmap2();
	if (nBmpID == 0)
		return;

	RECT rect;
	GetBitmapRect(nBmp == 1 ? pDlg->GetBitmapSizeIndex() : BMPSIZE_3D, &rect);
	int nWidth = rect.right - rect.left;
	int nHeight = rect.bottom - rect.top;

	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(pdc))
		return;

	if (nBmp == 1)
	{
		CBitmap picture;
		picture.LoadBitmap(nBmpID);
		BITMAP bitmap;
		picture.GetObject(sizeof (BITMAP), &bitmap);

		ASSERT(nWidth == bitmap.bmWidth);
		ASSERT(nHeight == bitmap.bmHeight);

		CBitmap* pOldBitmap = dcMem.SelectObject(&picture);
		pdc->BitBlt(rect.left, rect.top, nWidth, nHeight, &dcMem, 0, 0, SRCCOPY);
		dcMem.SelectObject(pOldBitmap);
	}
	else
	{
		CImageWell imageWell;
		CSize size(nWidth, nHeight);
		VERIFY(imageWell.Load(nBmpID, size));
		VERIFY(imageWell.Open());
		CBitmap picture;
		picture.CreateCompatibleBitmap(pdc, nWidth, nHeight);
		CBitmap* pOldBitmap = dcMem.SelectObject(&picture);
		dcMem.BitBlt(0, 0, nWidth, nHeight, pdc, rect.left, rect.top, SRCCOPY);

		CPoint destPoint(0, 0);
		VERIFY(imageWell.DrawImage(&dcMem, destPoint, 0));
		pdc->BitBlt(rect.left, rect.top, nWidth, nHeight, &dcMem, 0, 0, SRCCOPY);
		imageWell.Close();

		dcMem.SelectObject(pOldBitmap);
	}
	
}

void CMainDlg::RedrawBitmap(int nBmpSize)
{
	RECT rect;
	GetBitmapRect(nBmpSize, &rect);
	RedrawWindow(&rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
}

CDialog* CMainDlg::GetInnerDlg()
{
	if (IsUserAWX())
	{
		if (m_pCurrUserSeqDlg != NULL)
			return (CDialog*) m_pCurrUserSeqDlg;
		else if (m_pCurrUserStepDlg != NULL)
			return (CDialog*) m_pCurrUserStepDlg;
		else
			return NULL;
	}
	else
		return (CDialog*) m_pDialogClasses[m_nCurrTrack[m_nCurrIndex]];
}

BOOL CMainDlg::IsUserDlg()
{
	return (m_pCurrUserSeqDlg == NULL && m_pCurrUserStepDlg != NULL);
}

void CMainDlg::SetNumberOfSteps(int nSteps)
{
	m_nMaxUserSteps = nSteps;
	UpdateStepDisplay();
}


void CMainDlg::SetFocusOnStep(CDialog* pDlg)
{
	HWND hwnd = pDlg->GetSafeHwnd();
	ASSERT(hwnd != NULL);
	HWND hCtl = ::GetNextDlgTabItem(hwnd, NULL, FALSE);
	if (hCtl != NULL && ::IsWindow(hCtl) && ::IsWindowEnabled(hCtl))
	{
		CWnd* pCtl = CWnd::FromHandle(hCtl);
		ASSERT (pCtl != NULL);
		pDlg->GotoDlgCtrl(pCtl);
	}
	else
		GetDlgItem(IDOK)->SetFocus();
}

void CMainDlg::ActivateUserDlg(BOOL bDirIsNext)
{
	// Gross special case... if this is called immediately after appwiz is invoked,
	//  we just want to put up cpromptdlg.
	if (!bDirIsNext && m_pCurrUserStepDlg == NULL)
	{
		m_pCurrUserSeqDlg = NULL;
		theDLL.m_bQuit = TRUE;
		pTermStatus->nTermType = APPWIZTERMTYPE_RERUNPROMPTDLG;
		return;
	}

	if (m_pCurrUserStepDlg != NULL && !DismissCurrentDlg(FALSE))
		return;

	CDialog* pPrevDlg = GetInnerDlg();	// Remember old dialog
	
	BOOL bWasSeqDlg = (m_pCurrUserSeqDlg != NULL);

	if (bDirIsNext)
	{
		// User hit Next
		CAppWizStepDlg* pNewUserDlg = m_pCurrUserStepDlg;
		pNewUserDlg = GetAWX()->Next(pNewUserDlg);

		// If we just called Next(NULL), they might have updated their symbols,
		//  so load them in again
		if (m_pCurrUserStepDlg == NULL)
			GetAllSymbols();

		if (pNewUserDlg == NULL)
		{
			// NULL implies we're at the last step, so Finish == IDOK.
			m_pCurrUserSeqDlg = NULL;
			ActivateConfirmDlg();
			return;		// return without setting m_pCurrUserStepDlg to NULL
		}
		m_pCurrUserStepDlg = pNewUserDlg;
		m_nCurrUserStep++;
	}
	else
	{
		// User hit Back
		m_pCurrUserStepDlg = GetAWX()->Back(m_pCurrUserStepDlg);
		m_nCurrUserStep--;
		if (m_pCurrUserStepDlg == NULL)
		{
			// NULL implies to show CPromptDlg
			if (bWasSeqDlg)
				VERIFY(pPrevDlg->DestroyWindow());
			else
			{
				VERIFY(pPrevDlg->ShowWindow(SW_HIDE));
				m_UserDlgsToDestroy[pPrevDlg] = (void*) 1;
			}
			m_pCurrUserSeqDlg = NULL;
			theDLL.m_bQuit = TRUE;
			pTermStatus->nTermType = APPWIZTERMTYPE_RERUNPROMPTDLG;
			return;
		}
	}

	// We're still here.  So that means that the current dialog was
	//  successfully validated, and we will bring up another
	//  user dialog.  First, see if the "user" dialog is actually one
	//  of our own.
	if (!m_DlgMap.Lookup(m_pCurrUserStepDlg, m_pCurrUserSeqDlg))
		// It's not an appwiz dialog
		m_pCurrUserSeqDlg = NULL;
	else
		// It IS an appwiz dialog, so make sure the symbol-setting flag is set
		projOptions.m_bMayBeAppWizTrack = TRUE;

	// may need to add or remove the help button
	ArrangeButtons((IsDefinitelyKnownWizard() || m_pCurrUserSeqDlg != NULL) ? 0 : 1);
	
	// Since we're not activating confirm or prompt dlgs, we now know
	//  we can destroy the inner dialog.
	if (pPrevDlg != NULL)
	{
		if (bWasSeqDlg)
			VERIFY(pPrevDlg->DestroyWindow());
		else
		{
			VERIFY(pPrevDlg->ShowWindow(SW_HIDE));
			m_UserDlgsToDestroy[pPrevDlg] = (void*) 1;
		}
	}

    MakeOKDefault(this);

	// Here, we're given a valid new extension dlg (ours or theirs) to put up.
	CDialog* pNewDlg;
	if (m_pCurrUserSeqDlg != NULL)
	{
	    VERIFY(m_pCurrUserSeqDlg->Create(m_pCurrUserSeqDlg->m_nTemplate, this));
		pNewDlg = (CDialog*) m_pCurrUserSeqDlg;
	}
	else
	{
		if (m_pCurrUserStepDlg->GetSafeHwnd())
		{
			m_pCurrUserStepDlg->ShowWindow(SW_SHOW);
			m_pCurrUserStepDlg->SetFocus();
		}
		else
			VERIFY(m_pCurrUserStepDlg->Create(m_pCurrUserStepDlg->m_nIDTemplate, this));
		pNewDlg = (CDialog*) m_pCurrUserStepDlg;
	}

	// Placement of dialog depends on whether it's one of ours (in which case,
	//  save space on the left for picture.
	int nLeft = 0;						// Default == place dlg flush left.
	if (m_pCurrUserSeqDlg != NULL)
		nLeft = m_nChildDlgLeft;		// Save space on left for picture

    pNewDlg->SetWindowPos(NULL, nLeft, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);

    pNewDlg->ShowWindow(SW_SHOWNOACTIVATE);
    pNewDlg->EnableWindow(TRUE);
	EnableWindow(TRUE);
	SetFocusOnStep(pNewDlg);
#ifndef VS_PACKAGE
	imeEnableIME(0, TRUE);
#endif	// VS_PACKAGE
	UpdateStepDisplay();

	if (bWasSeqDlg != (m_pCurrUserSeqDlg != NULL))
	{
		// If we're going from a seq to non-seq dlg, or going from a
		//  non-seq to a seq dlg, we need to invalidate the picture area
		RECT rect = {0, 0, 0, 0};
		rect.bottom = BOTTOM_YELLOW_DLGU;
		MapDialogRect(&rect);
		int nBottom = rect.bottom;

		GetClientRect(&rect);
		rect.bottom = nBottom;
		
		CPaintDC dc(this);
		dc.DPtoLP(&rect);

		RedrawWindow(&rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
	}
	else if (m_pCurrUserSeqDlg != NULL)
	{
		// In any other case where we're about to put up a seqdlg, invalidate
		//  the bitmap areas.
		RedrawBitmap(BMPSIZE_SUM);
		RedrawBitmap(BMPSIZE_3D);
	}
}	

// Record current data, and reset track if necessary
BOOL CMainDlg::DismissCurrentDlg(BOOL bShouldDestroy /* = TRUE */)
{
	// If current dialog was CPromptDlg, it was already dismissed.
	if (!IsUserAWX() && m_nCurrIndex == 0)
		return TRUE;

    CDialog* pCurrDlg = NULL;
    pCurrDlg = GetInnerDlg();

	ASSERT(pCurrDlg != NULL);      // This isn't called if CPromptDlg or CConfirmDlg is active

	// Are we allowed to destroy the current dialog?
	if (!IsUserDlg())
	{
		// It's one of our own dialogs
		if (!(((CSeqDlg*) pCurrDlg)->CanDestroy()))
       		return FALSE;

		// We're still here, so we have permission to dismiss.
		if (bShouldDestroy)
			VERIFY(pCurrDlg->DestroyWindow());
	}
	else
	{
		// It's a user's extensions dialog
		if (!(((CAppWizStepDlg*) pCurrDlg)->OnDismiss()))
			return FALSE;

		// We're still here, so we have permission to dismiss.
		if (bShouldDestroy)
		{
			VERIFY(pCurrDlg->ShowWindow(SW_HIDE));
			m_UserDlgsToDestroy[pCurrDlg] = (void*) 1;
		}
	}

    // Decide if we need to change tracks.
    if (!IsUserAWX() && m_nCurrIndex == 1 && projOptions.m_nProjType != PROJTYPE_DLL)
    {
        // We're leaving the project type dialog, so ensure proper track
		SetCurrentTrack();
    }
	return TRUE;
}

void CMainDlg::DestroyUserDlgs()
{
	if (!GetSafeHwnd())
		return;

	POSITION pos = m_UserDlgsToDestroy.GetStartPosition();
	while (pos != NULL)
	{
		CAppWizStepDlg* pDlg;
		void* pTemp;
		m_UserDlgsToDestroy.GetNextAssoc(pos, pDlg, pTemp);
		VERIFY(pDlg->DestroyWindow());
	}
	m_UserDlgsToDestroy.RemoveAll();
}


void CMainDlg::ActivateDlg(int nDlg)
{
	if (m_nCurrIndex == nDlg)
        return;
    ASSERT(nDlg != -1);  // (Used to mean "End" was pushed).

	// Record current data, and reset track if necessary
	if (nDlg != -2 && !DismissCurrentDlg())
		return;

	// Make sure the proper button is default
    MakeOKDefault(this);

	// Special case for first (CPromptDlg) dialog
    if (nDlg == 0 || nDlg == -2)
    {
		theDLL.m_bQuit = TRUE;
		pTermStatus->nTermType = APPWIZTERMTYPE_RERUNPROMPTDLG;
        return;
    }

	// Display new dialog
    CSeqDlg* pDlg = m_pDialogClasses[m_nCurrTrack[nDlg]];
	int nHelpID = GetAltHelpID(m_nCurrTr